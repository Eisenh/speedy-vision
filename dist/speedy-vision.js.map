{"version":3,"sources":["webpack://Speedy/webpack/bootstrap","webpack://Speedy/./node_modules/process/browser.js","webpack://Speedy/./src/core/keypoints/descriptors/orb.js","webpack://Speedy/./src/core/keypoints/detectors/fast.js","webpack://Speedy/./src/core/keypoints/detectors/harris.js","webpack://Speedy/./src/core/keypoints/feature-algorithm-decorator.js","webpack://Speedy/./src/core/keypoints/feature-algorithm.js","webpack://Speedy/./src/core/keypoints/feature-description-algorithm.js","webpack://Speedy/./src/core/keypoints/feature-detection-algorithm.js","webpack://Speedy/./src/core/keypoints/feature-downloader.js","webpack://Speedy/./src/core/keypoints/feature-tracking-algorithm.js","webpack://Speedy/./src/core/keypoints/trackers/lk.js","webpack://Speedy/./src/core/math/linalg/basic.js","webpack://Speedy/./src/core/math/linalg/linalg.js","webpack://Speedy/./src/core/math/linalg/qr.js","webpack://Speedy/./src/core/math/linalg/solve.js","webpack://Speedy/./src/core/math/linalg/utils.js","webpack://Speedy/./src/core/math/matrix-buffer.js","webpack://Speedy/./src/core/math/matrix-expressions.js","webpack://Speedy/./src/core/math/matrix-operations-queue.js","webpack://Speedy/./src/core/math/matrix-operations.js","webpack://Speedy/./src/core/math/matrix-type.js","webpack://Speedy/./src/core/math/matrix-worker.js","webpack://Speedy/./src/core/math/matrix.js","webpack://Speedy/./src/core/math/speedy-vector.js","webpack://Speedy/./src/core/pipeline-operations.js","webpack://Speedy/./src/core/speedy-descriptor.js","webpack://Speedy/./src/core/speedy-feature-decorator.js","webpack://Speedy/./src/core/speedy-feature-descriptor-factory.js","webpack://Speedy/./src/core/speedy-feature-detector-factory.js","webpack://Speedy/./src/core/speedy-feature-detector.js","webpack://Speedy/./src/core/speedy-feature-tracker-factory.js","webpack://Speedy/./src/core/speedy-feature-tracker.js","webpack://Speedy/./src/core/speedy-feature.js","webpack://Speedy/./src/core/speedy-flags.js","webpack://Speedy/./src/core/speedy-media-source.js","webpack://Speedy/./src/core/speedy-media.js","webpack://Speedy/./src/core/speedy-namespace.js","webpack://Speedy/./src/core/speedy-pipeline.js","webpack://Speedy/./src/core/speedy.js","webpack://Speedy/./src/gpu/gl-utils.js","webpack://Speedy/./src/gpu/programs/colors.js","webpack://Speedy/./src/gpu/programs/encoders.js","webpack://Speedy/./src/gpu/programs/enhancements.js","webpack://Speedy/./src/gpu/programs/filters.js","webpack://Speedy/./src/gpu/programs/keypoints.js","webpack://Speedy/./src/gpu/programs/pyramids.js","webpack://Speedy/./src/gpu/programs/trackers.js","webpack://Speedy/./src/gpu/programs/utils.js","webpack://Speedy/./src/gpu/shader-declaration.js","webpack://Speedy/./src/gpu/shader-preprocessor.js","webpack://Speedy/./src/gpu/shaders sync ^\\.\\/.*$","webpack://Speedy/./src/gpu/shaders/colors/rgb2grey.glsl","webpack://Speedy/./src/gpu/shaders/encoders/encode-keypoint-long-offsets.glsl","webpack://Speedy/./src/gpu/shaders/encoders/encode-keypoint-offsets.glsl","webpack://Speedy/./src/gpu/shaders/encoders/encode-keypoints.glsl","webpack://Speedy/./src/gpu/shaders/encoders/resize-encoded-keypoints.glsl","webpack://Speedy/./src/gpu/shaders/encoders/upload-keypoints.glsl","webpack://Speedy/./src/gpu/shaders/enhancements/nightvision.glsl","webpack://Speedy/./src/gpu/shaders/enhancements/normalize-image.glsl","webpack://Speedy/./src/gpu/shaders/filters/convolution.js","webpack://Speedy/./src/gpu/shaders/filters/fast-median.glsl","webpack://Speedy/./src/gpu/shaders/filters/median.js","webpack://Speedy/./src/gpu/shaders/filters/multiscale-sobel.glsl","webpack://Speedy/./src/gpu/shaders/include sync ^\\.\\/.*$","webpack://Speedy/./src/gpu/shaders/include/colors.glsl","webpack://Speedy/./src/gpu/shaders/include/fixed-point.glsl","webpack://Speedy/./src/gpu/shaders/include/global.glsl","webpack://Speedy/./src/gpu/shaders/include/keypoints.glsl","webpack://Speedy/./src/gpu/shaders/include/math.glsl","webpack://Speedy/./src/gpu/shaders/include/orientation.glsl","webpack://Speedy/./src/gpu/shaders/include/pyramids.glsl","webpack://Speedy/./src/gpu/shaders/include/quickselect.glsl","webpack://Speedy/./src/gpu/shaders/include/sobel.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/brisk.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/fast-score12.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/fast-score16.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/fast-score8.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/fast5.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/fast7.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/fast9lg.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/harris-cutoff.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/multiscale-fast.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/multiscale-harris.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/multiscale-suppression.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/nonmax-suppression.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/orb-descriptor.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/orientation-via-centroid.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/samescale-suppression.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/sort-by-score.glsl","webpack://Speedy/./src/gpu/shaders/pyramids/downsample2.glsl","webpack://Speedy/./src/gpu/shaders/pyramids/upsample2.glsl","webpack://Speedy/./src/gpu/shaders/trackers/lk-discard.glsl","webpack://Speedy/./src/gpu/shaders/trackers/lk.glsl","webpack://Speedy/./src/gpu/shaders/utils/copy-components.glsl","webpack://Speedy/./src/gpu/shaders/utils/fill-components.glsl","webpack://Speedy/./src/gpu/shaders/utils/fill.glsl","webpack://Speedy/./src/gpu/shaders/utils/flip-y.glsl","webpack://Speedy/./src/gpu/shaders/utils/identity.glsl","webpack://Speedy/./src/gpu/shaders/utils/scan-minmax2d.glsl","webpack://Speedy/./src/gpu/speedy-gpu.js","webpack://Speedy/./src/gpu/speedy-program-center.js","webpack://Speedy/./src/gpu/speedy-program-group.js","webpack://Speedy/./src/gpu/speedy-program.js","webpack://Speedy/./src/gpu/speedy-texture.js","webpack://Speedy/./src/index.js","webpack://Speedy/./src/utils/errors.js","webpack://Speedy/./src/utils/fps-counter.js","webpack://Speedy/./src/utils/globals.js","webpack://Speedy/./src/utils/observable.js","webpack://Speedy/./src/utils/speedy-promise.js","webpack://Speedy/./src/utils/types.js","webpack://Speedy/./src/utils/utils.js"],"names":[],"mappings":";;;;;;;;;;;;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA,4BAA4B,UAAU;;;;;;;;;;;;;ACvLtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoD;AAC2B;AACvB;AACG;AACQ;AACP;;AAE5D;AACA,2BAA2B;AAC3B,2CAA2C;;AAE3C;AACA;AACA;AACO,0BAA0B,0FAA2B;AAC5D;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,gBAAgB;AAC/B,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,2EAA2B;AACvD;AACA,uCAAuC,mEAAgB;AACvD;AACA;AACA;AACA,C;;;;;;;;;;;;ACzGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoD;AACQ;AACe;AACjB;AACb;AACe;;AAE5D;AACA;AACA;AACA;AACA,gDAAgD;;;;AAIhD;AACA;AACA;AACO,2BAA2B,sFAAyB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,QAAQ,kDAAK;AACb;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,QAAQ,kDAAK;AACb;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+DAAiB;;AAEvC;AACA;;AAEA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACO,qCAAqC,sFAAyB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,QAAQ,kDAAK;AACb;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,QAAQ,kDAAK;AACb;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,QAAQ,kDAAK,2CAA2C,iEAAkB;AAC1E;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;AClRA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoD;AACuB;AACrB;AACM;AACf;;AAE7C;AACA,4BAA4B;AAC5B,wBAAwB;AACxB,8BAA8B;AAC9B,gDAAgD;AAChD,0BAA0B;AAC1B,0BAA0B;AAC1B,+BAA+B,iEAAkB,KAAK;;AAEtD;AACA;AACA;AACO,6BAA6B,sFAAyB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,QAAQ,kDAAK;AACb;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,6DAA6D,2DAAc;;AAE3E;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO,uCAAuC,sFAAyB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,QAAQ,kDAAK;AACb;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,QAAQ,kDAAK,2CAA2C,iEAAkB;AAC1E;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sBAAsB,qBAAqB;AAC3C;AACA,oCAAoC,6BAA6B;AACjE,wDAAwD;;AAExD;AACA;;AAEA;AACA,sBAAsB,qBAAqB;AAC3C;;AAEA;AACA,6DAA6D,2DAAc;;AAE3E;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;ACpOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuD;AACL;AACS;AACjB;;AAE1C;AACA;AACA;AACA;AACA;AACO,wCAAwC,mEAAgB;AAC/D;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA,QAAQ,kDAAK,sCAAsC,mEAAgB;AACnE,QAAQ,kDAAK;AACb,QAAQ,kDAAK;;AAEb;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,eAAe,sBAAsB;AACrC,iBAAiB;AACjB;AACA;AACA;AACA,QAAQ,kDAAK;AACb,QAAQ,kDAAK;;AAEb;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC9HA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiD;AACQ;AACA;AACf;AACQ;AACS;AACD;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA,QAAQ,kDAAK,0BAA0B,kEAAmB;AAC1D,QAAQ,kDAAK;AACb,QAAQ,kDAAK;;AAEb,mBAAmB,OAAO;AAC1B,8CAA8C;;AAE9C,mBAAmB,OAAO;AAC1B,oCAAoC;AACpC;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,eAAe,sBAAsB;AACrC,iBAAiB,+BAA+B;AAChD;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,gBAAgB;AAC/B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,QAAQ,kDAAK,mCAAmC;AAChD;;AAEA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,QAAQ,kDAAK,wCAAwC;AACrD;AACA,C;;;;;;;;;;;;ACrIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AACF;AACmB;AACA;AACxB;AACS;AACjB;;AAE1C;AACA;AACA;AACA;AACO,0CAA0C,sFAAyB;AAC1E;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,OAAO;AACtB;AACA;AACA;AACA,QAAQ,kDAAK,sCAAsC,mEAAgB;AACnE,QAAQ,kDAAK;;AAEb;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,eAAe,sBAAsB;AACrC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA,eAAe,gBAAgB;AAC/B,iBAAiB;AACjB;AACA;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;AACA,C;;;;;;;;;;;;ACnGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AACF;AACE;AACP;AACD;AACQ;AACE;;AAE3D;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACO,wCAAwC,mEAAgB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,kCAAkC;AACrD;;AAEA,mBAAmB,kBAAkB;AACrC,+BAA+B,qEAAiB;AAChD;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,eAAe,sBAAsB;AACrC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,qCAAqC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,EAAE;AAClD;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2DAA2D;AAC3D;;AAEA;AACA;AACA,C;;;;;;;;;;;;ACvIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2D;AACP;AACF;AACD;AACU;AACT;;AAElD;AACA,iCAAiC;AACjC,oCAAoC;AACpC,yBAAyB;AACzB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC;AAChC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACO,gCAAgC,4DAAU;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,sBAAsB;AACrC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,SAAS;AACT,sBAAsB,mEAAqB;AAC3C,SAAS;AACT;;AAEA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;;AAEA,qCAAqC,QAAQ;AAC7C,4CAA4C,0DAAW;;AAEvD;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA,UAAU;AACV;AACA,6C;;;;;;;;;;;;AC9NA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiD;AACQ;AACA;AACF;AACE;AACP;AACS;AACjB;;AAE1C;AACA;AACA;AACA;AACO,uCAAuC,mEAAgB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,cAAc;AACjC;;AAEA,mBAAmB,cAAc;AACjC;;AAEA,mBAAmB,kBAAkB;AACrC,+BAA+B,qEAAiB;AAChD;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,eAAe,sBAAsB;AACrC,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,qEAAiB;AACpC,YAAY,kDAAK;;AAEjB;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;AACA,C;;;;;;;;;;;;AC/HA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoD;AACQ;AACa;AAC5B;;AAE7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO,yCAAyC,oFAAwB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,QAAQ,kDAAK;AACb;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,QAAQ,kDAAK;AACb;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC/HA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA,WAAW,gCAAgC;AAC3C,WAAW,QAAQ;;AAEnB;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,aAAa;AAC/B;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA,WAAW,gCAAgC;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,aAAa;AACrC,kBAAkB,UAAU;AAC5B;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA,WAAW,wBAAwB;AACnC;AACA;;AAEA;AACA,mBAAmB,UAAU;AAC7B,uBAAuB,aAAa;AACpC;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA,WAAW,wBAAwB;AACnC;AACA;;AAEA;AACA,cAAc,aAAa;AAC3B;AACA;AACA;AACA,kBAAkB,UAAU;AAC5B;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA,WAAW,wBAAwB;AACnC;AACA;;AAEA;AACA,cAAc,aAAa;AAC3B;AACA;AACA;AACA,kBAAkB,UAAU;AAC5B;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA,WAAW,gCAAgC;AAC3C;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,aAAa;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,cAAc;AACtC,uBAAuB,cAAc;AACrC;AACA,sBAAsB,UAAU;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA,WAAW,gCAAgC;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,cAAc;AACtC,uBAAuB,cAAc;AACrC;AACA,sBAAsB,WAAW;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA,WAAW,gCAAgC;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,aAAa;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,cAAc;AACtC,uBAAuB,WAAW;AAClC;AACA,sBAAsB,UAAU;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,mBAAmB,cAAc;AACjC;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA,WAAW,wBAAwB;AACnC,WAAW,SAAS;AACpB;;AAEA;AACA,cAAc,aAAa;AAC3B;AACA,kBAAkB,UAAU;AAC5B;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA,WAAW,wBAAwB;AACnC;AACA;;AAEA;AACA,cAAc,aAAa;AAC3B;AACA;AACA;AACA,kBAAkB,UAAU;AAC5B;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA,WAAW,wBAAwB;AACnC;AACA,4B;;AAEA;AACA,cAAc,aAAa;AAC3B;AACA;AACA,kBAAkB,UAAU;AAC5B;AACA;AACA,C;;;;;;;;;;;AC/TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,aAAa,GAAG,mBAAO,CAAC,sDAAgB;AAC/C;AACA,OAAO,mBAAO,CAAC,gDAAS;AACxB,OAAO,mBAAO,CAAC,gDAAS;AACxB,OAAO,mBAAO,CAAC,0CAAM;AACrB,OAAO,mBAAO,CAAC,gDAAS;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB,WAAW,OAAO;AAClB;;AAEA,WAAW,OAAO;AAClB;;AAEA,WAAW,WAAW;AACtB;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA,2CAA2C,KAAK;AAChD;AACA,mDAAmD,KAAK;AACxD;AACA,kDAAkD,KAAK;;AAEvD;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,oCAAoC,EAAE,MAAM,mBAAmB,mBAAmB;AAClF;;AAEA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,2BAA2B,sBAAsB;;AAEjD,EAAE;;AAEF;AACA,CAAC;AACD;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;;AAED,kBAAkB,U;;;;;;;;;;;;AC5GlB;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,qCAAqC,EAAE,WAAW,eAAe;AACjE;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mEAAmE,MAAM,KAAK,SAAS;;AAEvF;AACA;AACA,mEAAmE,MAAM,KAAK,SAAS,wCAAwC,MAAM,+BAA+B,MAAM;;AAE1K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,cAAc;AAC5B,4BAA4B;AAC5B,8BAA8B;;AAE9B,sBAAsB;AACtB,oEAAoE;;AAEpE;AACA,kBAAkB,OAAO;AACzB;AACA,2DAA2D;;AAE3D;AACA;AACA;AACA,4BAA4B,UAAU;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gFAAgF,MAAM,KAAK,SAAS,6CAA6C,MAAM,KAAK,iBAAiB,UAAU,MAAM,KAAK,SAAS;;AAE3M;AACA,sBAAsB,WAAW,OAAO;AACxC;AACA,oCAAoC;AACpC,qCAAqC,QAAQ,OAAO;AACpD;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC,iCAAiC,WAAW;AAC5C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mFAAmF,MAAM,KAAK,SAAS,6CAA6C,MAAM,KAAK,oBAAoB,UAAU,MAAM,KAAK,SAAS;;AAEjN;AACA,sBAAsB,cAAc,OAAO;AAC3C;AACA,oCAAoC;AACpC,qCAAqC,QAAQ,OAAO;AACpD;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wFAAwF,EAAE,eAAe,MAAM,KAAK,SAAS;AAC7H;AACA,yFAAyF,EAAE,KAAK,IAAI,WAAW,MAAM,KAAK,SAAS;;AAEnI;AACA,sBAAsB,OAAO;AAC7B;;AAEA;AACA,sBAAsB,OAAO,OAAO;AACpC,+BAA+B;AAC/B;AACA,0BAA0B,OAAO;AACjC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wFAAwF,EAAE,eAAe,MAAM,KAAK,SAAS;AAC7H;AACA,yFAAyF,EAAE,KAAK,IAAI,WAAW,MAAM,KAAK,SAAS;;AAEnI;AACA,sBAAsB,OAAO;AAC7B;;AAEA;AACA,0BAA0B,QAAQ,OAAO;AACzC,+BAA+B;AAC/B;AACA,0BAA0B,OAAO;AACjC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,yCAAyC;AACzC;;AAEA;AACA;AACA,wFAAwF,EAAE,eAAe,MAAM,KAAK,SAAS;AAC7H;AACA,yFAAyF,EAAE,KAAK,IAAI,WAAW,MAAM,KAAK,SAAS;;AAEnI;AACA,sBAAsB,OAAO,OAAO;AACpC;AACA;AACA;;AAEA;AACA,8BAA8B,QAAQ;AACtC;AACA;AACA,kCAAkC,QAAQ;AAC1C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,+DAA+D,KAAK;AACpE;AACA,C;;;;;;;;;;;;ACzSA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;;AAEA;AACA,+DAA+D,MAAM,KAAK,QAAQ,MAAM,WAAW,KAAK,SAAS,qBAAqB,MAAM,KAAK,SAAS;AAC1J;AACA,gEAAgE,MAAM,yBAAyB,KAAK,KAAK,QAAQ;;AAEjH;AACA;AACA,qBAAqB;AACrB,yCAAyC;AACzC,sCAAsC;AACtC,wCAAwC;;AAExC;AACA,gBAAgB,QAAQ;AACxB;AACA,oBAAoB,OAAO;AAC3B;;AAEA;AACA;AACA;AACA;AACA,0DAA0D,IAAI;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA,WAAW,gBAAgB;AAC3B;AACA;AACA,oCAAoC,EAAE;;AAEtC;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,C;;;;;;;;;;;;ACnGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,MAAM;AACjB,aAAa;AACb;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;AACA;;AAEA;AACA;AACA,kBAAkB,SAAS;AAC3B;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,gBAAgB;AAC3B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACO;AACP;AACA;;AAEA,cAAc,YAAY;AAC1B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACO;AACP;AACA,WAAW,wBAAwB;AACnC;AACA;;AAEA;AACA,6BAA6B,aAAa;AAC1C,kBAAkB,UAAU;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,WAAW,UAAU;AACrB,WAAW,iBAAiB;AAC5B,aAAa,MAAM;AACnB;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8BAA8B,QAAQ;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,C;;;;;;;;;;;;ACrIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2C;AACyD;AACzC;;;AAG3D;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,8BAA8B;AAC7C,eAAe,eAAe;AAC9B,eAAe,cAAc;AAC7B;AACA,+CAA+C,uDAAU;AACzD;AACA;;AAEA;AACA,YAAY,uDAAU;AACtB,sBAAsB,kEAAoB,wBAAwB,MAAM;AACxE;AACA,sBAAsB,kEAAoB;;AAE1C;AACA;AACA,+BAA+B,uDAAU;AACzC,oCAAoC,uDAAU;AAC9C;;;AAGA;;AAEA,mBAAmB,eAAe;AAClC;;AAEA,mBAAmB,gBAAgB;AACnC;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;;;;;AAKA;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,kBAAkB;AACrC;;AAEA,mBAAmB,eAAe;AAClC;;AAEA,mBAAmB,cAAc;AACjC;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mEAAa;AACpC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,mBAAmB,mEAAa;AAChC;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,iBAAiB,EAAE;AACnC;;AAEA;AACA;;AAEA;AACA,4CAA4C,QAAQ;AACpD;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,iBAAiB,EAAE;AACnC;;AAEA;AACA;AACA,oEAAoE;;AAEpE;AACA;;AAEA,0BAA0B,0BAA0B;AACpD;AACA;AACA,yDAAyD,QAAQ;AACjE;AACA;AACA,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;;AAEA;AACA,4CAA4C,QAAQ;AACpD;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,iBAAiB,EAAE;AACnC;;AAEA;AACA,mBAAmB,uDAAU;;AAE7B;AACA,4CAA4C,QAAQ;AACpD;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;;AAEzD;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,C;;;;;;;;;;;;ACzOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwC;AACG;AACuB;AACoC;AAC3C;AAmB9B;;AAE7B;AACA,8BAA8B,8EAAqB;;;AAGnD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,eAAe;AAC9B;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,eAAe;AAClC;;AAEA,mBAAmB,UAAU;AAC7B;;;;AAIA;AACA;AACA,sBAAsB,kEAAoB,gDAAgD,WAAW,KAAK,cAAc;AACxH,iBAAiB,uDAAU;AAC3B,sBAAsB,kEAAoB,2CAA2C,YAAY;AACjG;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB,wCAAwC,iBAAiB,YAAY,YAAY;AAC5H;AACA,sBAAsB,mEAAqB,wCAAwC,aAAa,KAAK,gBAAgB,UAAU,WAAW,KAAK,cAAc;AAC7J;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA,kBAAkB,mEAAqB;AACvC;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA,eAAe,0BAA0B;AACzC,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,mEAAqB;AACvC;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,mEAAqB;AACvC;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;;;AAGA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,iBAAiB;AAChC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,iBAAiB;AAChC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,wBAAwB;AACvC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,iBAAiB;AAChC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,kEAAoB,kDAAkD,KAAK,KAAK,QAAQ;AAC9G;AACA,sBAAsB,kEAAoB,qBAAqB,KAAK,oCAAoC,OAAO,KAAK,UAAU;;AAE9H;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,0BAA0B,kEAAoB,+BAA+B,OAAO;AACpF;AACA;;;;;;;;AAQA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,eAAe;AAC9B;AACA;AACA;AACA;;AAEA,mBAAmB,aAAa;AAChC,8BAA8B,oDAAY;AAC1C;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,iBAAiB;AAChC,eAAe,SAAS;AACxB,eAAe,MAAM;AACrB;AACA;AACA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;;AAEA,mBAAmB,SAAS;AAC5B;;AAEA,mBAAmB,iBAAiB;AACpC;;AAEA,mBAAmB,MAAM;AACzB;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC,eAAe,SAAS;AACxB,eAAe,MAAM;AACrB;AACA;AACA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;;AAEA,mBAAmB,iBAAiB;AACpC;;AAEA,mBAAmB,SAAS;AAC5B;;AAEA,mBAAmB,iBAAiB;AACpC;;AAEA,mBAAmB,MAAM;AACzB;;;;AAIA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,mEAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,cAAc;AACjC;;AAEA,mBAAmB,cAAc;AACjC;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;;AAEA,mBAAmB,cAAc;AACjC;;AAEA,mBAAmB,cAAc;AACjC;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;;;;;AAKA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA,eAAe,0BAA0B;AACzC,iBAAiB,0CAA0C;AAC3D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,0BAA0B;AACzC;AACA;AACA;AACA,eAAe,uBAAuB;AACtC;;AAEA;AACA;AACA;AACA,mCAAmC,oDAAY;AAC/C;AACA;AACA;AACA,0BAA0B,kEAAoB,2BAA2B,OAAO;AAChF;;AAEA;;AAEA,mBAAmB,uBAAuB;AAC1C;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,mEAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,eAAe;AAC9B,eAAe,aAAa;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,cAAc;AACjC;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,mEAAa;AAC5B;;AAEA;AACA;AACA,+BAA+B;AAC/B,eAAe,aAAa;AAC5B,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA,eAAe,mEAAa;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,cAAc;AACjC;;AAEA,mBAAmB,cAAc;AACjC;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,SAAS;AACT;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,sEAAmB;AAC1D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;;AAEA,mBAAmB,cAAc;AACjC;;AAEA,mBAAmB,cAAc;AACjC;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,SAAS;AACT;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,sEAAmB;AAC1D;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,eAAe;AAC9B,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA,mBAAmB,gBAAgB;AACnC,8BAA8B,sEAAmB;AACjD;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA,6CAA6C,sEAAmB;AAChE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C,2EAAwB;AACrE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC;AACA;AACA;AACA,oEAAoE,qEAAkB;AACtF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC;AACA;AACA;AACA,oEAAoE,0EAAuB;AAC3F;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qEAAqE,0EAAuB;AAC5F;AACA,sBAAsB,kEAAoB,qBAAqB,cAAc,KAAK,iBAAiB,eAAe,eAAe,KAAK,kBAAkB;AACxJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC;AACA;AACA;AACA,wEAAwE,4EAAyB;AACjG;AACA,sBAAsB,kEAAoB,qBAAqB,iBAAiB,KAAK,cAAc,4BAA4B,eAAe,KAAK,kBAAkB;AACrK;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC;AACA;AACA;AACA,kEAAkE,4EAAyB;AAC3F;AACA,sBAAsB,kEAAoB,qBAAqB,cAAc,KAAK,iBAAiB,eAAe,kBAAkB,KAAK,eAAe;AACxJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC;AACA;AACA;AACA,qEAAqE,6EAA0B;AAC/F;AACA,sBAAsB,kEAAoB,qBAAqB,cAAc,KAAK,iBAAiB,eAAe,eAAe,KAAK,kBAAkB;AACxJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,OAAO;AACtB;AACA;AACA;AACA,6CAA6C,uEAAoB;AACjE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC;AACA;AACA;AACA,oEAAoE,0EAAuB;AAC3F;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB,4CAA4C,UAAU,KAAK,aAAa;;AAElH,wCAAwC,oEAAiB;AACzD;AACA;;;;;;;AAOA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB,4CAA4C,aAAa,KAAK,gBAAgB;AACxH;AACA,sBAAsB,kEAAoB,eAAe,aAAa,kCAAkC,aAAa,KAAK,gBAAgB;;AAE1I,mEAAmE,yEAAsB;AACzF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB,eAAe,WAAW,KAAK,eAAe,uBAAuB,WAAW,KAAK,cAAc;;AAE7I,oCAAoC,kFAA+B;AACnE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,kEAAoB,mDAAmD,EAAE,KAAK,EAAE;AACtG;AACA,sBAAsB,kEAAoB,eAAe,EAAE,kCAAkC,aAAa,KAAK,gBAAgB;;AAE/H,sCAAsC,yEAAsB;AAC5D;AACA;;;;;AAKA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,eAAe;AAC9B,iBAAiB;AACjB;AACA,yDAAyD,uDAAU;AACnE;AACA;;AAEA,YAAY,uDAAU;AACtB,sBAAsB,kEAAoB,0BAA0B,MAAM;;AAE1E;AACA;AACA,0BAA0B,kEAAoB,wCAAwC,OAAO;AAC7F;AACA,6BAA6B,oDAAY;AACzC;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,eAAe;AAC9B,iBAAiB;AACjB;AACA,wCAAwC,uDAAU;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,eAAe;AAC9B,iBAAiB;AACjB;AACA,uCAAuC,uDAAU;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,eAAe;AAC9B,iBAAiB;AACjB;AACA,sCAAsC,uDAAU;AAChD;AACA;AACA,gDAAgD,QAAQ;AACxD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACx/CA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwC;AACc;AACK;;AAE3D;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,aAAa;AAC5B,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA,mBAAmB,mEAAa;AAChC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,C;;;;;;;;;;;;AC/FA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoG;AACzC;AACnB;AACO;AACN;;AAEzC;AACA,0BAA0B;AAC1B;;AAEA;AACA,qBAAqB,2DAAY;;;AAGjC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,eAAe;AAC9B,eAAe,eAAe;AAC9B,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,0CAA0C;;AAE1C;AACA;;AAEA;AACA,YAAY,qDAAM;AAClB,sBAAsB,kEAAoB,qBAAqB,OAAO;AACtE;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,eAAe;AAC9B,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C,6CAA6C,QAAQ;AACrD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,mEAAqB;;AAE/C;AACA;AACA;;AAEA;AACA;;;;;;;AAOA;;;;;;;AAOA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA,eAAe,+BAA+B;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gDAAgD;AAChD,6CAA6C,QAAQ;AACrD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,QAAQ;AACzD;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA,eAAe,+BAA+B;AAC9C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C;AAC1C,6CAA6C,QAAQ;AACrD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS,qDAAM;AACf,eAAe,mEAAa;AAC5B;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,eAAe;AAC9B;AACA;AACA;AACA,eAAe,uBAAuB;;AAEtC;AACA;AACA;AACA,sBAAsB,mEAAqB,+BAA+B,iBAAiB,QAAQ,MAAM;AACzG;AACA,sBAAsB,mEAAqB,yBAAyB,KAAK,KAAK,QAAQ,aAAa,aAAa,KAAK,gBAAgB;AACrI;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,eAAe;AAC9B,eAAe,OAAO;AACtB;AACA;AACA;AACA,4EAA4E,gBAAgB;AAC5F;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,OAAO;AACtB;AACA;AACA;AACA,+EAA+E,kBAAkB;AACjG;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,OAAO;AACtB;AACA;AACA;AACA,oBAAoB,6CAA6C;AACjE;AACA,sBAAsB,kEAAoB,oCAAoC,KAAK;;AAEnF;AACA,qEAAqE,UAAU;AAC/E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,aAAa;AAC5B;AACA;AACA;AACA,6FAA6F,uBAAuB;AACpH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;AC5jBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,MAAM;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qDAAqD,MAAM;;AAE3D;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,SAAS;AACT;AACA;;AAEA,kBAAkB,c;;;;;;;;;;;;AC5FlB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyC;AACkB;AACA;;AAE3D;AACA,qCAAqC;AACrC,kBAAkB;;AAElB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B,eAAe,cAAc;AAC7B,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA,mBAAmB,mEAAa;;AAEhC;AACA;AACA;AACA;AACA,qBAAqB;;AAErB,mBAAmB,mEAAa;AAChC;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sCAAsC,qDAAM,gBAAgB;AAC5D,kEAAkE;AAClE,uCAAuC,iCAAiC;AACxE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB,kBAAkB,WAAW;AACxE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,aAAa;AACxB;AACA;AACA;AACA,WAAW,wDAAwD;AACnE;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA,C;;;;;;;;;;;;AClIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoG;AACzD;AACI;AACmB;AACT;AACE;;;;AAI3D;AACA,8BAA8B,8EAAqB;;;;AAInD;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,eAAe;AAC9B,eAAe,OAAO;AACtB,eAAe,aAAa;AAC5B;AACA,6DAA6D,uDAAU;AACvE;AACA;AACA,sBAAsB,kEAAoB;AAC1C;AACA,sBAAsB,kEAAoB;AAC1C,iBAAiB,uDAAU;AAC3B,sBAAsB,kEAAoB,wBAAwB,MAAM;AACxE;AACA,sBAAsB,kEAAoB,kDAAkD,eAAe,UAAU,cAAc;;AAEnI;AACA;AACA;AACA;AACA,qCAAqC,2DAAY;AACjD;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,iBAAiB,wBAAwB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,UAAU;AACpC,8BAA8B,UAAU;AACxC;AACA;;AAEA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA,sBAAsB,kEAAoB;;AAE1C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,OAAO;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,UAAU;AAChC;AACA,0BAA0B,aAAa;AACvC;AACA;;AAEA;AACA;AACA,6CAA6C,KAAK,SAAS,QAAQ,WAAW,WAAW,aAAa,IAAI;AAC1G;AACA,SAAS;AACT;;;;;;AAMA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,kEAAoB,kDAAkD,SAAS,GAAG,QAAQ,IAAI,YAAY,GAAG,WAAW;AAC9I;AACA,sBAAsB,kEAAoB,4CAA4C,SAAS,GAAG,QAAQ,IAAI,YAAY,GAAG,WAAW,OAAO,KAAK,KAAK,QAAQ;;AAEjK;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,oCAAoC,UAAU,SAAS,aAAa,WAAW,WAAW;AAC1F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kDAAkD,qEAAkB;AACpE;AACA;AACA,C;;;;;;;;;;;;ACrVA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0D;;AAE1D;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,gCAAgC,yBAAyB,IAAI,yBAAyB;AACtF;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,C;;;;;;;;;;;;AC3JA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6C;AACN;AACG;AACgC;;AAEnE,2BAA2B;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,UAAU;AACzB,eAAe,YAAY;AAC3B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,kBAAkB;AACjC,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB;AAC1C;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wDAAW;AAC5C;AACA,sCAAsC,wDAAW;AACjD,sBAAsB,+DAAiB;;AAEvC,6BAA6B,wDAAW;AACxC;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA,4BAA4B;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,eAAe;;AAE9B;AACA;AACA,sBAAsB,kEAAoB,qBAAqB,OAAO;AACtE;AACA,sBAAsB,kEAAoB,yBAAyB,KAAK;;AAExE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,sBAAsB,kEAAoB;AAC1C;AACA,sBAAsB,kEAAoB,gDAAgD,IAAI;;AAE9F;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kDAAK;;AAErB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA,4BAA4B;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,WAAW;;AAE1B,iCAAiC,wDAAW;AAC5C;AACA,sCAAsC,wDAAW;AACjD;AACA;AACA,sBAAsB,+DAAiB;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA,4BAA4B;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,+BAA+B;;AAE9C,iCAAiC,wDAAW;AAC5C;AACA,sCAAsC,wDAAW;AACjD;AACA;AACA,sBAAsB,+DAAiB;AACvC;AACA,C;;;;;;;;;;;;ACjTA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsD;;AAEtD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACzFA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoF;AACnB;AAC1B;;AAEvC;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,iBAAiB;AAChC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,kDAAK,sCAAsC,gGAAyB;;AAE5E;AACA;AACA,C;;;;;;;;;;;;ACxDA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqD;AACe;AACV;;AAE1D;AACA;AACA;AACA;AACO,6CAA6C,iEAAe;AACnE;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,gFAAsB,CAAC,sEAAW;AACrD;AACA,C;;;;;;;;;;;;ACvCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqD;AAMlB;AACuB;AAC2B;;AAErF;AACA;AACA;AACO,2CAA2C,iEAAe;AACjE;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,4EAAmB;AACtC;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,sFAA6B;AAChD;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,8EAAqB;AACxC;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,wFAA+B;AAClD;;AAEA;AACA;AACA,iBAAiB,gCAAgC;AACjD;AACA;AACA;AACA,oBAAoB,iGAA8B;AAClD,8BAA8B,wFAA+B;AAC7D;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC9FA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsH;AAC/E;AACK;AACC;AACC;AACQ;AACT;AACuC;AACI;AACrB;AACe;AACM;AACpB;;;;AAIpE;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;;AAE9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA,+BAA+B,+EAAiB;AAChD;;AAEA;AACA,mBAAmB,yDAAW;AAC9B;AACA;AACA;AACA;AACA;AACA,+BAA+B,+EAAiB;;AAEhD;AACA,4CAA4C;AAC5C;;AAEA;AACA;AACA,iCAAiC,+EAAiB;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wDAAW;AAC7C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB;;AAE1C;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,kBAAkB,uEAAY;;AAE9B;AACA;AACA,sBAAsB,+DAAiB,gDAAgD,EAAE;;AAEzF;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,kBAAkB,iFAAsB;;AAExC;AACA;AACA,sBAAsB,+DAAiB,2DAA2D,EAAE;;AAEpG;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2EAAc;AAChC;;AAEA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qFAAwB;AAC1C;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACvkBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqD;AACR;AACe;;AAE5D;AACA;AACA;AACO,0CAA0C,iEAAe;AAChE;AACA;AACA;AACA,eAAe,YAAY;AAC3B,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,wEAAgB;AACnC;AACA,C;;;;;;;;;;;;ACvCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkF;AACjB;AACE;AACtB;AACC;AACQ;AACD;AACyB;AACvC;AACQ;AACsB;AACD;;AAEpE;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,yBAAyB;AACxC,eAAe,YAAY;AAC3B;AACA;AACA;AACA,mBAAmB,yBAAyB;AAC5C;;AAEA,mBAAmB,iBAAiB;AACpC;;AAEA,mBAAmB,YAAY;AAC/B;;AAEA,mBAAmB,cAAc;AACjC;;AAEA,mBAAmB,cAAc;AACjC;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,qBAAqB;AACpC,eAAe,eAAe;AAC9B,iBAAiB;AACjB;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,kEAAoB;;AAE1C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,6BAA6B;AACvD,kEAAkE,0DAAW;;AAE7E;AACA;;AAEA;AACA;;AAEA;AACA;AACA,4BAA4B,iEAAa;AACzC,4BAA4B,iEAAa;AACzC;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,UAAU;AACzB,eAAe,mBAAmB;AAClC,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C;AACA;AACA;AACA,sBAAsB,mEAAqB,kDAAkD,aAAa;;AAE1G;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA,8BAA8B,kFAA0B;AACxD;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB;;AAE1C;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB,mBAAmB,SAAS;;AAEtE;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB;;AAE1C;AACA;AACA,C;;;;;;;;;;;;AC/OA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuD;AAChB;;AAEvC;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,WAAW;AAC1B,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,QAAQ,GAAG,QAAQ;AACtC;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,uCAAuC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACzKA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;;AAEP;AACA;;AAEA,CAAC,E;;;;;;;;;;;;AC1BD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuC;AACiB;AACyD;AACvE;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gEAAgE;AACnF;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;AACA;;AAEA;AACA;AACA,eAAe,gEAAgE;AAC/E,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB,4BAA4B,cAAc;AACpF;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,mEAAa;AAChC,YAAY,kDAAK,oBAAoB,UAAU,sBAAsB,QAAQ;;AAE7E;AACA,2BAA2B,0DAAY,IAAI,UAAU,6BAA6B,QAAQ,aAAa,QAAQ;AAC/G,aAAa;;AAEb;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,eAAe,sDAAS;AACxB;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,iBAAiB;AAChC,iBAAiB;AACjB;AACA;AACA;AACA,wDAAwD;AACxD,mBAAmB,mEAAa;AAChC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,eAAe,sDAAS;AACxB;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,iBAAiB;AAChC,iBAAiB;AACjB;AACA;AACA;AACA,mCAAmC;AACnC,mBAAmB,mEAAa;AAChC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,eAAe,sDAAS;AACxB;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C,0BAA0B,kDAAK;AAC/B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,kBAAkB;AACjC,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,mEAAa;AAC5B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,eAAe,sDAAS;AACxB;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,mEAAa;AAC5B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,C;;;;;;;;;;;;ACxWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE8C;AACS;AACuB;AACvC;AAC0C;AACvB;AACF;AACL;;AAEnD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,eAAe,8BAA8B;AAC7C,eAAe,OAAO;AACtB;AACA,iDAAiD,EAAE;AACnD;AACA,mBAAmB,kBAAkB;AACrC;;AAEA,mBAAmB,UAAU;AAC7B;;AAEA,mBAAmB,OAAO;AAC1B,4BAA4B,wDAAW;;AAEvC,mBAAmB,OAAO;AAC1B;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kDAAK;AACjB;;AAEA;AACA,oCAAoC,sDAAS;AAC7C,gBAAgB,kDAAK;;AAErB;AACA;;AAEA;AACA;AACA,6CAA6C,sDAAS;AACtD,aAAa;;AAEb;AACA,4BAA4B,yDAAS;AACrC;AACA;;AAEA;AACA;AACA;AACA,eAAe,gEAAgE;AAC/E,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA,wCAAwC,EAAE;AAC1C;AACA,eAAe,sEAAiB;AAChC,YAAY,kDAAK;;AAEjB;AACA,YAAY,kDAAK,kCAAkC,YAAY;;AAE/D;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA,wEAAwE,EAAE,kBAAkB,EAAE;AAC9F;AACA,eAAe,kDAAK;AACpB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,gEAAgE;AACjF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,iBAAiB,sDAAS;AAC1B;;AAEA,iBAAiB,sDAAS;AAC1B;;AAEA,iBAAiB,sDAAS;AAC1B;;AAEA,iBAAiB,sDAAS;AAC1B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA,YAAY,kDAAK;AACjB;AACA;AACA;AACA;;AAEA,eAAe,mEAAa;AAC5B;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,2BAA2B;AAC5C;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C;AACA;AACA;AACA,mBAAmB,mEAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,eAAe;AAC9B,iBAAiB,2BAA2B;AAC5C;AACA;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C;AACA,2BAA2B,oBAAoB;AAC/C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,sEAAiB;AACxC;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA,eAAe,kBAAkB;AACjC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B;AAC5B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB;AAC3C;AACA,sBAAsB,mEAAqB;;AAE3C;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iCAAiC,EAAE;;AAEnC;AACA;AACA,YAAY,kDAAK,0DAA0D,cAAc;AACzF;AACA,YAAY,kDAAK;AACjB;;AAEA;AACA,sCAAsC;AACtC;AACA,C;;;;;;;;;;;;AC1UA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqD;;AAErD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;AACA,C;;;;;;;;;;;;ACvCA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0D;AACf;AACa;AACD;;;AAGvD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,wBAAwB;AACzC;AACA;AACA;AACA;AACA,oDAAoD,QAAQ;AAC5D;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,wBAAwB;AACvC,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,UAAU;AACzB,eAAe,YAAY;AAC3B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA,sBAAsB,6BAA6B;AACnD;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,eAAe,eAAe;AAC9B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,kEAAoB,sBAAsB,SAAS;AACrE;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,oBAAoB,sEAAiB;AACrC;AACA;;AAEA,kBAAkB,kEAAoB,2CAA2C,WAAW;AAC5F;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA,qBAAqB;AACrB;AACA;AACA,gBAAgB,sEAAiB;AACjC;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,gBAAgB,sEAAiB;AACjC;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA,0BAA0B;AAC1B;AACA;AACA,gBAAgB,sEAAiB;AACjC;AACA;;AAEA;AACA;AACA,eAAe,wBAAwB;AACvC,iBAAiB;AACjB;AACA,4BAA4B;AAC5B;AACA;AACA,gBAAgB,sEAAiB;AACjC;AACA;AACA,C;;;;;;;;;;;;AC7LA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6C;AACM;AACD;AAC+B;AACF;AACM;AACxC;AACQ;AACe;AACZ;AACD;;AAEvD;AACA,8BAA8B,gFAAuB;;AAErD;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,oDAAoD;AACnE,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA,0CAA0C,EAAE;AAC5C;AACA,eAAe,yDAAW;AAC1B;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA,+DAA+D,mBAAmB;AAClF;AACA,eAAe,yDAAW;AAC1B;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,+DAAc;AACjC;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,eAAe,WAAkB;AACjC;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,eAAe,6DAAU;AACzB;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,6FAA4B;AAC3C;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,2FAA2B;AAC1C;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,iGAA8B;AAC7C;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA,mBAAmB,iEAAa;AAChC;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,mEAAa;AAC5B;AACA;;AAEA;AACA,4CAA4C,yDAAW,E;;;;;;;;;;;;ACrJvD;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuC;AACiB;AAC+B;;;;AAIvF;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,qDAAO;AAC1B;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,qDAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB;;AAE1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,aAAa;AAC5B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,aAAa;AAC5B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,0FAA0F;AACzG,eAAe,MAAM;AACrB,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;;AAE9B;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,iBAAiB;AAChC,eAAe,aAAa;AAC5B,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,MAAM;AACrB,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAsB,qDAAO,eAAe,aAAa,iCAAiC,oCAAoC;;AAE9H,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,aAAa;AAC5B,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qDAAO,8BAA8B,MAAM,IAAI,OAAO;AAC5E;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,iBAAiB;AAChC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,UAAU;AACzB,eAAe,WAAW;AAC1B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kDAAK,gFAAgF;AACrG,gGAAgG;AAChG;AACA;AACA,+DAA+D;AAC/D,oBAAoB,kDAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET,mBAAmB,mEAAa;AAChC;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,gBAAgB;AAC/B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,sBAAsB,mEAAqB;AAC3C,SAAS;AACT;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,WAAW;AAC1B,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,iBAAiB;AAChC,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,kEAAoB;;AAE1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,sBAAsB,mEAAqB;AAC3C,SAAS;AACT;AACA,SAAS;AACT;AACA,C;;;;;;;;;;;;ACjcA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6D;AACR;;;;AAIrD;AACA;AACA;;AAEA;AACA,iBAAiB,wEAAY;;;;;AAK7B;AACA;AACA;AACA;AACO,wBAAwB,wEAAkB;AACjD;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACxDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6D;AACR;AACK;AACP;AACV;AACiB;AACoB;AAMjD;;AAE7B;AACA;AACA,gCAAgC,gEAAiB,KAAK;AACtD,8BAA8B;AAC9B,+BAA+B;AAC/B,kDAAkD;AAClD,2BAA2B;AAC3B,4BAA4B;AAC5B,wDAAwD;AACxD,yBAAyB;AACzB,kCAAkC;AAClC,8CAA8C;;;;;AAK9C;AACA;AACA;;AAEA;AACA,kCAAkC,wEAAY;AAC9C;AACA,+CAA+C,kDAAkD;;AAEjG;AACA,sCAAsC,wEAAY;AAClD;AACA,mDAAmD,kDAAkD;;AAErG;AACA,wBAAwB,wEAAY;AACpC;;AAEA;AACA,+BAA+B,wEAAY;AAC3C;;AAEA;AACA,0BAA0B,wEAAY;AACtC;;AAEA;AACA,wBAAwB,wEAAY;AACpC;AACA;AACA;AACA,wBAAwB;;;;;AAKxB;AACA;AACA;AACA;AACO,0BAA0B,wEAAkB;AACnD;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;;;;AAIA;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B,oFAAoF,gEAAiB;;AAErG,mBAAmB,aAAa;AAChC,kCAAkC;AAClC;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,6BAA6B;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oBAAoB;AAC/C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA,mCAAmC,gEAAiB;AACpD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,UAAU;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA,iBAAiB,6DAAc;AAC/B,iBAAiB,6DAAc;;AAE/B;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,qEAAsB,IAAI,qEAAsB,GAAG,iEAAkB;;AAEtF;AACA,mCAAmC,2DAAY;AAC/C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA,oBAAoB,kEAAa;AACjC;AACA;;AAEA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,QAAQ;AACvB,iBAAiB,4BAA4B;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,mEAAqB;AAC5C,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+DAAiB,iBAAiB,cAAc,mCAAmC,uBAAuB;AAChI;;AAEA;AACA;AACA,kEAAkE;AAClE;AACA,YAAY,kDAAK;AACjB;AACA;;AAEA;AACA,sBAAsB,mBAAmB;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,6CAA6C,gEAAiB;AAC9D;;AAEA;AACA;AACA,C;;;;;;;;;;;;AC3YA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6D;AACR;AACS;AACX;AACT;AACgB;;;AAG1D;AACA;AACA;;AAEA;AACA,gCAAgC,wEAAY;AAC5C;AACA,6CAA6C,iBAAiB;AAC9D,8BAA8B,wEAAY;AAC1C;;AAEA;AACA,oBAAoB,wEAAY;AAChC;AACA,6BAA6B,wEAAY;AACzC;AACA,0CAA0C,iBAAiB;;;;;AAK3D;AACA;AACA;AACA;AACO,8BAA8B,wEAAkB;AACvD;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,4CAA4C,0EAAK,CAAC,kDAAK;AACvD,4CAA4C,0EAAK,CAAC,kDAAK;AACvD;AACA,0CAA0C,0EAAK,CAAC,kDAAK;AACrD,0CAA0C,0EAAK,CAAC,kDAAK;AACrD;AACA,4CAA4C,0EAAK,CAAC,kDAAK;AACvD,4CAA4C,0EAAK,CAAC,kDAAK;AACvD;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,+DAA+D,2DAAc;AAC7E;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,qFAAqF,2DAAc;AACnG,qFAAqF,2DAAc;AACnG,4DAA4D,2DAAc;;AAE1E;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO,2BAA2B;AACjD,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB,4CAA4C,QAAQ;;AAE9F;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC1JA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6D;AACR;AACwE;AAC1E;AACT;;;;AAI1C;AACA;AACA;;AAEA;AACA,oBAAoB,wEAAY;AAChC;AACA,iCAAiC,mBAAmB;;AAEpD;AACA,oBAAoB,wEAAY;AAChC;AACA,iCAAiC,mBAAmB;;;;AAIpD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACO,yBAAyB,wEAAkB;AAClD;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gCAAgC,sEAAM;;AAEtC;AACA;;AAEA;AACA,mCAAmC,8EAAS,MAAM;AAClD;AACA,aAAa;AACb,mCAAmC,8EAAS,MAAM;AAClD;AACA,aAAa;AACb,mCAAmC,8EAAS,MAAM;AAClD;AACA,aAAa;;AAEb;AACA;AACA,kCAAkC,6EAAQ;AAC1C,kCAAkC,6EAAQ;AAC1C;AACA,kCAAkC,6EAAQ;AAC1C,kCAAkC,6EAAQ;AAC1C;AACA,kCAAkC,6EAAQ;AAC1C,kCAAkC,6EAAQ;AAC1C;AACA,kCAAkC,6EAAQ;AAC1C,kCAAkC,6EAAQ;AAC1C;AACA,mCAAmC,6EAAQ;AAC3C,mCAAmC,6EAAQ;;AAE3C;AACA,wCAAwC,mFAAc,MAAM;AAC5D;AACA;AACA,aAAa;AACb,wCAAwC,mFAAc,MAAM;AAC5D;AACA;AACA,aAAa;AACb,wCAAwC,mFAAc,MAAM;AAC5D;AACA;AACA,aAAa;AACb,wCAAwC,mFAAc,MAAM;AAC5D;AACA;AACA,aAAa;AACb,wCAAwC,mFAAc,MAAM;AAC5D;AACA;AACA,aAAa;AACb,wCAAwC,mFAAc,MAAM;AAC5D;AACA;AACA,aAAa;AACb,wCAAwC,mFAAc,MAAM;AAC5D;AACA;AACA,aAAa;AACb,yCAAyC,mFAAc,OAAO;AAC9D;AACA;AACA,aAAa;AACb,oDAAoD;AACpD;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;;;;;AAKb;AACA;AACA,iCAAiC,0EAAK;AACtC;AACA;AACA;AACA,iCAAiC,0EAAK;AACtC;AACA;AACA;AACA,iCAAiC,0EAAK;AACtC;AACA;AACA;AACA,iCAAiC,0EAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,0EAAK,CAAC,kDAAK;AAC5C,iCAAiC,0EAAK,CAAC,kDAAK;AAC5C,iCAAiC,0EAAK,CAAC,kDAAK;AAC5C,iCAAiC,0EAAK,CAAC,kDAAK;AAC5C,kCAAkC,0EAAK,CAAC,kDAAK;AAC7C,kCAAkC,0EAAK,CAAC,kDAAK;;;;;AAK7C;AACA,+BAA+B,0EAAK;AACpC;AACA;AACA,+BAA+B,0EAAK;AACpC;AACA;AACA,+BAA+B,0EAAK;AACpC;AACA;AACA,+BAA+B,0EAAK;AACpC;AACA;AACA,+BAA+B,0EAAK;AACpC;AACA;AACA,+BAA+B,0EAAK;AACpC;AACA;AACA,+BAA+B,0EAAK;AACpC;AACA;AACA,+BAA+B,0EAAK;AACpC;AACA;AACA,gCAAgC,0EAAK;AACrC;AACA;AACA,gCAAgC,0EAAK;AACrC;AACA;;;AAGA;AACA;AACA,kCAAkC,0EAAK;AACvC;AACA;AACA,kCAAkC,0EAAK;AACvC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjPA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6D;AACR;AACX;;;;AAI1C;AACA;AACA;;AAEA;AACA;AACA,cAAc,wEAAY;;AAE1B;AACA;AACA,cAAc,wEAAY;;AAE1B;AACA;AACA,cAAc,wEAAY;;AAE1B;AACA;AACA,oBAAoB,wEAAY;;AAEhC;AACA;AACA,oBAAoB,wEAAY;;AAEhC;AACA;AACA,mBAAmB,wEAAY;;AAE/B;AACA;AACA,uBAAuB,wEAAY;AACnC;;AAEA;AACA;AACA,iCAAiC,wEAAY;AAC7C;AACA;AACA;AACA,iCAAiC;;;;AAIjC;AACA;AACA;;AAEA;AACA,yBAAyB,wEAAY;AACrC;;AAEA;AACA,qBAAqB,wEAAY;;;;AAIjC;AACA;AACA;AACA,cAAc,wEAAY;AAC1B;;;;AAIA;AACA;AACA;AACA,YAAY,wEAAY;AACxB;;;;AAIA;AACA;AACA;;AAEA;AACA,0BAA0B,wEAAY;AACtC,8BAA8B,wEAAY;AAC1C,6BAA6B,wEAAY;;AAEzC;AACA,wBAAwB,wEAAY;;AAEpC;AACA,+BAA+B,wEAAY;AAC3C;;;;;AAKA;AACA;AACA;AACA;AACO,2BAA2B,wEAAkB;AACpD;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,QAAQ,kDAAK;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AClNA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6D;AACnB;AACQ;AACA;AACG;AACS;AACH;;;;AAI3D;AACA;AACA;;AAEA;AACA,kBAAkB,wEAAY;AAC9B,oBAAoB,wEAAY;AAChC;AACA;;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;AACO,0BAA0B,wEAAkB;AACnD;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA,iCAAiC,0EAAK;AACtC;AACA;AACA,iCAAiC,0EAAK;AACtC;AACA;;AAEA;AACA;AACA,kCAAkC,0EAAK;AACvC;AACA;;AAEA,kCAAkC,0EAAK;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,cAAc;AACjC;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB;AAC3C;AACA,C;;;;;;;;;;;;AC7LA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6D;AACR;AACuB;;;;AAI5E;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B,oCAAoC;AACpC,sCAAsC;AACtC,sCAAsC;AACtC,6BAA6B;AAC7B;;AAEA,WAAW,wEAAY;AACvB;AACA;AACA;AACA,YAAY;;AAEZ,kBAAkB,wEAAY;AAC9B;AACA;AACA;AACA,mBAAmB;;AAEnB,gBAAgB,wEAAY;AAC5B;AACA;AACA;AACA,iBAAiB;;AAEjB,uBAAuB,wEAAY;AACnC;AACA;AACA;AACA,wBAAwB;;AAExB,kBAAkB,wEAAY;AAC9B;AACA;AACA;AACA,mBAAmB;;AAEnB,yBAAyB,wEAAY;AACrC;AACA;AACA;AACA,0BAA0B;;AAE1B,mBAAmB,wEAAY;AAC/B;AACA;AACA;AACA,oBAAoB;;AAEpB,0BAA0B,wEAAY;AACtC;AACA;AACA;AACA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACO,0BAA0B,wEAAkB;AACnD;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,yCAAyC,iEAAkB;AAC3D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,4BAA4B;AAC5B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gEAAiB;AACpD;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,eAAe;AACrC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;ACrLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6D;AACR;AACf;AAC+B;AACX;;;;AAI1D;AACA;AACA;;AAEA;AACA,iBAAiB,wEAAY;;AAE7B;AACA,cAAc,wEAAY;;AAE1B;AACA,aAAa,wEAAY;;AAEzB;AACA,uBAAuB,wEAAY;;AAEnC;AACA,uBAAuB,wEAAY;;AAEnC;AACA;;AAEA;AACA,qBAAqB,wEAAY;;;;AAIjC;AACA;AACA;AACA;AACO,uBAAuB,wEAAkB;AAChD;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA,oEAAoE,2DAAc;AAClF;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA,oEAAoE,2DAAc;AAClF;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA,YAAY,6DAAgB;AAC5B,sBAAsB,kEAAoB,0BAA0B,aAAa;;AAEjF,+BAA+B,6DAAgB;AAC/C;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,2DAAc;;AAEtE,sBAAsB,mBAAmB;AACzC;;AAEA;AACA;AACA,C;;;;;;;;;;;;AC5KA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2D;AACkD;;AAE7G;AACA;AACA;AACA,CAAC;;AAED;AACA,UAAU;AACV,UAAU;AACV;;AAEA;AACA,yBAAyB,4BAA4B;AACrD,iBAAiB;AACjB,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,kCAAkC,mEAAQ,IAAY,WAAW,CAAC;AAClE;AACA,sBAAsB,kEAAoB;;AAE1C,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B,6BAA6B,uEAAkB;;AAE/C,mBAAmB,OAAO;AAC1B,+BAA+B,uEAAkB;;AAEjD,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,SAAS;AAC5B;;AAEA,mBAAmB,mBAAmB;AACtC;;AAEA,mBAAmB,mBAAmB;AACtC;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,+DAAiB,0BAA0B,SAAS;;AAE1E,sCAAsC,WAAW;AACjD;;AAEA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B,kEAAoB,cAAc,QAAQ;AACxE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C;AACA;AACA;AACA,+CAA+C;AAC/C;AACA,iCAAiC,IAAI,GAAG,MAAM;AAC9C;;AAEA;AACA;AACA,+BAA+B,uEAAkB;;AAEjD;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB,oCAAoC,KAAK;;AAEnF;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB,+CAA+C,KAAK;;AAE9F;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA,yDAAyD;AACzD,+EAA+E;AAC/E;;AAEA;AACA;AACA;AACA,4FAA4F;;AAE5F;AACA;AACA;AACA;AACA,kCAAkC,wDAAU,0CAA0C,KAAK;;AAE3F;AACA;AACA;AACA,kCAAkC,wDAAU,UAAU,MAAM;;AAE5D;AACA,kCAAkC,UAAU;AAC5C,wCAAwC,MAAM,GAAG,EAAE;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;AACA;AACA,C;;;;;;;;;;;;AC5SA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAQ0B;AACa;AACS;AACgB;;AAEhE;AACA;AACA;AACA;AACA;AACA,6EAA6E,wCAAwC,iCAAiC,kBAAkB;AACxK,6EAA6E,wCAAwC,wCAAwC,kBAAkB;AAC/K;;AAEA;AACA;AACA;AACA,0BAA0B,iEAAkB;;AAE5C;AACA,0BAA0B,iEAAkB;AAC5C,8BAA8B,qEAAsB;AACpD,2BAA2B,kEAAmB;;AAE9C;AACA,0BAA0B,2DAAc;AACxC,4BAA4B,2DAAc;AAC1C,2BAA2B,2DAAc;AACzC,4BAA4B,2DAAc;;AAE1C;AACA,gBAAgB,uDAAQ;AACxB,sBAAsB,6DAAc;;AAEpC;AACA,2BAA2B,kEAAmB;AAC9C,yBAAyB,gEAAiB;AAC1C,gBAAgB,uDAAQ;AACxB,oBAAoB,2DAAY;AAChC,mBAAmB,0DAAW;AAC9B,CAAC;;AAED;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,mBAAmB;AAClC,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe,2EAAQ,IAAoB,WAAW,CAAC;;AAEvD,cAAc,+DAAiB,0CAA0C,SAAS;AAClF;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,mBAAmB;AAC9B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;;AAEA,kBAAkB,OAAO;AACzB;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAU,6CAA6C,MAAM,QAAQ,IAAI,cAAc,MAAM;AACnH;AACA,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA,IAAI,kDAAK;;AAET;AACA;AACA,8BAA8B,MAAM;AACpC,yBAAyB,KAAK;AAC9B,4BAA4B,QAAQ;AACpC,0BAA0B,MAAM;AAChC,wBAAwB,IAAI;AAC5B,wBAAwB,IAAI;AAC5B,yBAAyB,KAAK;AAC9B,6BAA6B,SAAS;AACtC;AACA;;AAEA;AACA;AACA,iDAAiD;;AAEjD;AACA,8CAA8C,iBAAiB;;AAE/D;AACA,uBAAuB,KAAK,GAAG,SAAS;;AAExC;AACA;AACA,sBAAsB,SAAS;AAC/B,0BAA0B,IAAI,QAAQ,KAAK,GAAG,IAAI,SAAS,GAAG;;AAE9D;AACA,sBAAsB;AACtB;;AAEA;AACA;AACA,C;;;;;;;;;;;AC5MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kE;;;;;;;;;;;ACtEA,uEAAuE,0BAA0B,gBAAgB,kCAAkC,6BAA6B,8BAA8B,GAAG,C;;;;;;;;;;;ACAjN,iDAAiD,0BAA0B,4PAA4P,yCAAyC,kCAAkC,yBAAyB,sDAAsD,uCAAuC,2BAA2B,qBAAqB,mFAAmF,wBAAwB,oEAAoE,qCAAqC,mCAAmC,wBAAwB,GAAG,uBAAuB,gBAAgB,oBAAoB,OAAO,2DAA2D,gCAAgC,oEAAoE,qCAAqC,mCAAmC,gCAAgC,GAAG,gDAAgD,sDAAsD,GAAG,C;;;;;;;;;;;ACA/vC,0CAA0C,0BAA0B,kKAAkK,kCAAkC,+BAA+B,yBAAyB,iBAAiB,iGAAiG,WAAW,oCAAoC,2BAA2B,GAAG,uBAAuB,gBAAgB,oBAAoB,OAAO,2DAA2D,kBAAkB,oCAAoC,2BAA2B,8BAA8B,GAAG,6DAA6D,GAAG,C;;;;;;;;;;;ACA9yB,8EAA8E,qCAAqC,0BAA0B,qBAAqB,wBAAwB,6BAA6B,wBAAwB,4BAA4B,uKAAuK,qCAAqC,2BAA2B,2BAA2B,oBAAoB,0DAA0D,6CAA6C,yEAAyE,gDAAgD,2BAA2B,iDAAiD,GAAG,kBAAkB,GAAG,gBAAgB,kCAAkC,+EAA+E,kGAAkG,gEAAgE,qBAAqB,iCAAiC,wCAAwC,gDAAgD,mDAAmD,0FAA0F,6CAA6C,qCAAqC,sEAAsE,kHAAkH,+GAA+G,4DAA4D,wCAAwC,2BAA2B,qBAAqB,+BAA+B,+FAA+F,kJAAkJ,GAAG,C;;;;;;;;;;;ACAnsE,8EAA8E,kCAAkC,6BAA6B,iCAAiC,mCAAmC,8BAA8B,kCAAkC,gBAAgB,yCAAyC,kCAAkC,6HAA6H,0FAA0F,yFAAyF,qGAAqG,mCAAmC,4DAA4D,qHAAqH,GAAG,C;;;;;;;;;;;ACAx9B,yEAAyE,4BAA4B,6BAA6B,wBAAwB,8HAA8H,8CAA8C,IAAI,gBAAgB,kCAAkC,kGAAkG,gEAAgE,qBAAqB,iCAAiC,gCAAgC,0BAA0B,WAAW,oCAAoC,0BAA0B,yBAAyB,4EAA4E,QAAQ,GAAG,WAAW,uBAAuB,kCAAkC,2CAA2C,6CAA6C,QAAQ,GAAG,YAAY,qBAAqB,QAAQ,GAAG,GAAG,GAAG,C;;;;;;;;;;;ACAhiC,0CAA0C,oCAAoC,qBAAqB,uBAAuB,sBAAsB,sHAAsH,0GAA0G,4BAA4B,0CAA0C,4BAA4B,iCAAiC,gBAAgB,kCAAkC,gDAAgD,sDAAsD,yCAAyC,2CAA2C,sCAAsC,gDAAgD,sGAAsG,oDAAoD,uCAAuC,6CAA6C,8CAA8C,0FAA0F,2BAA2B,6DAA6D,2DAA2D,wCAAwC,WAAW,C;;;;;;;;;;;ACAj3C,+DAA+D,0CAA0C,iCAAiC,yBAAyB,kCAAkC,gBAAgB,uEAAuE,+BAA+B,4CAA4C,sDAAsD,uDAAuD,kDAAkD,kIAAkI,qFAAqF,yFAAyF,mFAAmF,6EAA6E,uBAAuB,GAAG,C;;;;;;;;;;;;ACAh/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwD;AACX;AACgB;;;;AAI7D;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB;AACO;AACP;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA,kBAAkB,kEAAoB,4DAA4D,MAAM;AACxG;AACA,kBAAkB,kEAAoB,qCAAqC,gBAAgB;;AAE3F;AACA;;AAEA;AACA,uCAAuC,kDAAK,WAAW,kDAAK,oBAAoB,kDAAK;AACrF;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,cAAc,gBAAgB,OAAO,IAAI,OAAO,aAAa,GAAG;AACpF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA,WAAW,wEAAY;AACvB;;;;;AAKA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB;AACO;AACP;AACA;AACA;;;;;AAKA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB;AACO;AACP;AACA;AACA;;;;;AAKA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA,kBAAkB,kEAAoB,4DAA4D,MAAM;AACxG;AACA,kBAAkB,kEAAoB,gDAAgD,KAAK,IAAI;;AAE/F;AACA;;AAEA;AACA,uCAAuC,kDAAK;AAC5C;AACA;AACA;AACA,mBAAmB,cAAc,gBAAgB,MAAM,gBAAgB,GAAG;AAC1E;AACA,mBAAmB,cAAc,mBAAmB,MAAM,aAAa,GAAG;AAC1E;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA,WAAW,wEAAY;AACvB;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,IAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,OAAO;AAChB;AACA,uBAAuB,KAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACO;AACP;AACA;AACA;AACA;AACA,kBAAkB,kEAAoB,6CAA6C,WAAW;;AAE9F;AACA;AACA,2BAA2B,wBAAwB;;AAEnD;AACA;AACA;AACA,8BAA8B,WAAW;;AAEzC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,wEAAY;AACvB;;;;;AAKA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACO;AACP;AACA;AACA;AACA;AACA,kBAAkB,kEAAoB,6CAA6C,WAAW;;AAE9F;AACA;AACA,2BAA2B,WAAW;;AAEtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,wEAAY;AACvB;;;;;AAKA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACO;AACP;AACA;AACA,8BAA8B;AAC9B;AACA,kBAAkB,kEAAoB,gFAAgF,WAAW;;AAEjI;AACA;;AAEA;AACA,uCAAuC,kDAAK,WAAW,kDAAK,oBAAoB,kDAAK;AACrF;AACA;;AAEA;AACA,4CAA4C,MAAM,IAAI,MAAM;AAC5D;AACA,oBAAoB,cAAc,gBAAgB,EAAE,IAAI,EAAE;AAC1D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA,WAAW,wEAAY;AACvB;;;;;AAKA;AACA;AACA,WAAW,OAAO;AAClB;AACO;;;;AAIP;AACA;AACA,WAAW,OAAO;AAClB;AACO;;;;;AAKP;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,kBAAkB,kEAAoB,gFAAgF,WAAW;AACjI;AACA,kBAAkB,kEAAoB,gEAAgE,KAAK,IAAI;;AAE/G;AACA;;AAEA;AACA,uCAAuC,kDAAK;AAC5C;AACA,4CAA4C,MAAM;AAClD;AACA,oBAAoB,cAAc,gBAAgB,EAAE;AACpD;AACA,4CAA4C,MAAM;AAClD;AACA,oBAAoB,cAAc,mBAAmB,EAAE;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA,WAAW,wEAAY;AACvB,C;;;;;;;;;;;AC1ZA,0CAA0C,qCAAqC,wBAAwB,iBAAiB,gBAAgB,kBAAkB,mCAAmC,mDAAmD,kDAAkD,kDAAkD,kDAAkD,iDAAiD,iDAAiD,kDAAkD,iDAAiD,iDAAiD,YAAY,YAAY,YAAY,YAAY,YAAY,YAAY,YAAY,YAAY,YAAY,YAAY,YAAY,YAAY,YAAY,YAAY,YAAY,YAAY,YAAY,YAAY,YAAY,gBAAgB,sCAAsC,mDAAmD,mDAAmD,kDAAkD,kDAAkD,kDAAkD,mDAAmD,mDAAmD,kDAAkD,kDAAkD,kDAAkD,mDAAmD,mDAAmD,kDAAkD,kDAAkD,kDAAkD,mDAAmD,mDAAmD,kDAAkD,kDAAkD,kDAAkD,mDAAmD,mDAAmD,kDAAkD,kDAAkD,kDAAkD,YAAY,YAAY,YAAY,YAAY,YAAY,YAAY,YAAY,aAAa,aAAa,YAAY,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,YAAY,YAAY,YAAY,YAAY,YAAY,YAAY,YAAY,cAAc,aAAa,aAAa,cAAc,aAAa,aAAa,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,aAAa,aAAa,aAAa,YAAY,cAAc,aAAa,aAAa,cAAc,aAAa,aAAa,cAAc,aAAa,aAAa,cAAc,aAAa,aAAa,cAAc,aAAa,aAAa,cAAc,aAAa,aAAa,aAAa,aAAa,cAAc,cAAc,aAAa,aAAa,YAAY,aAAa,aAAa,cAAc,aAAa,aAAa,aAAa,aAAa,YAAY,YAAY,cAAc,cAAc,YAAY,cAAc,aAAa,aAAa,cAAc,aAAa,aAAa,cAAc,aAAa,cAAc,cAAc,cAAc,cAAc,iBAAiB,4FAA4F,GAAG,C;;;;;;;;;;;;ACAhhH;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwD;AACX;AACgB;;AAE7D;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACO;AACP;AACA;AACA;AACA;AACA,kBAAkB,kEAAoB,sCAAsC,WAAW,GAAG,WAAW;;AAErG;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,kDAAK;AAC5C,QAAQ,kDAAK,4BAA4B,kDAAK;AAC9C;AACA;AACA;AACA;AACA,YAAY,EAAE,MAAM,cAAc,gBAAgB,EAAE,IAAI,EAAE;AAC1D;;AAEA;AACA;AACA,uCAAuC,kDAAK;AAC5C,6BAA6B,kDAAK;AAClC,qBAAqB,EAAE,gBAAgB,EAAE;AACzC;AACA;AACA,cAAc;AACd,UAAU;AACV,mBAAmB,EAAE;AACrB,YAAY,EAAE;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,EAAE;AACpB;;AAEA;AACA,UAAU;;AAEV;AACA,UAAU;;AAEV;AACA,yBAAyB,IAAI,OAAO,IAAI,OAAO,IAAI;AACnD;AACA;;AAEA;AACA,WAAW,wEAAY;AACvB,C;;;;;;;;;;;AC1FA,iGAAiG,oBAAoB,oGAAoG,gGAAgG,2CAA2C,gBAAgB,wBAAwB,8fAA8f,4DAA4D,0DAA0D,kHAAkH,0BAA0B,GAAG,C;;;;;;;;;;;ACA/oC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0E;;;;;;;;;;;AC9BA,sR;;;;;;;;;;;ACAA,wJAAwJ,uDAAuD,sZ;;;;;;;;;;;ACA/M,iLAAiL,+CAA+C,QAAQ,EAAE,6Z;;;;;;;;;;;ACA1O,gLAAgL,gBAAgB,oBAAoB,YAAY,cAAc,YAAY,IAAI,2BAA2B,WAAW,aAAa,IAAI,6DAA6D,yDAAyD,uCAAuC,+CAA+C,6CAA6C,6hBAA6hB,yDAAyD,+EAA+E,4DAA4D,sHAAsH,iBAAiB,GAAG,oGAAoG,+BAA+B,oBAAoB,qCAAqC,2CAA2C,+FAA+F,6DAA6D,2IAA2I,gGAAgG,gEAAgE,gDAAgD,uCAAuC,qDAAqD,gEAAgE,mEAAmE,qGAAqG,kBAAkB,GAAG,+CAA+C,gCAAgC,iDAAiD,0BAA0B,yBAAyB,2EAA2E,GAAG,uOAAuO,uEAAuE,oEAAoE,GAAG,qE;;;;;;;;;;;ACAtkG,8UAA8U,0BAA0B,iIAAiI,GAAG,wGAAwG,8FAA8F,GAAG,gE;;;;;;;;;;;ACArrB,yO;;;;;;;;;;;ACAA,0yBAA0yB,2DAA2D,iEAAiE,uEAAuE,+BAA+B,0FAA0F,GAAG,sCAAsC,oGAAoG,wCAAwC,GAAG,0KAA0K,S;;;;;;;;;;;ACAx8C,k8BAAk8B,yCAAyC,+BAA+B,kEAAkE,qBAAqB,cAAc,gBAAgB,QAAQ,gBAAgB,OAAO,OAAO,kBAAkB,kBAAkB,+BAA+B,wBAAwB,+DAA+D,8BAA8B,8BAA8B,YAAY,GAAG,gBAAgB,WAAW,GAAG,mDAAmD,gBAAgB,0BAA0B,kCAAkC,gDAAgD,yEAAyE,GAAG,kDAAkD,GAAG,S;;;;;;;;;;;ACAxtD,wFAAwF,qDAAqD,6BAA6B,4BAA4B,gCAAgC,sCAAsC,sEAAsE,8BAA8B,WAAW,wCAAwC,qDAAqD,wCAAwC,oDAAoD,2EAA2E,8BAA8B,WAAW,S;;;;;;;;;;;ACAxqB,0DAA0D,uCAAuC,gBAAgB,kCAAkC,wBAAwB,2BAA2B,uCAAuC,uCAAuC,qDAAqD,sEAAsE,sEAAsE,iCAAiC,+CAA+C,+CAA+C,+CAA+C,iCAAiC,+CAA+C,+CAA+C,+CAA+C,kHAAkH,gCAAgC,gDAAgD,gCAAgC,gCAAgC,2IAA2I,2IAA2I,0EAA0E,0EAA0E,uCAAuC,qCAAqC,qCAAqC,uCAAuC,+CAA+C,iCAAiC,oEAAoE,wBAAwB,mFAAmF,kGAAkG,6BAA6B,sCAAsC,qEAAqE,mDAAmD,kDAAkD,+DAA+D,GAAG,C;;;;;;;;;;;ACArwE,0CAA0C,0BAA0B,gBAAgB,kCAAkC,yCAAyC,4CAA4C,sDAAsD,sDAAsD,sDAAsD,sDAAsD,uDAAuD,uDAAuD,uDAAuD,wDAAwD,wDAAwD,uDAAuD,wDAAwD,wDAAwD,iCAAiC,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,4DAA4D,4DAA4D,gDAAgD,qEAAqE,GAAG,C;;;;;;;;;;;ACAprD,0CAA0C,0BAA0B,mDAAmD,iDAAiD,gBAAgB,kCAAkC,yCAAyC,4CAA4C,ktBAAktB,uMAAuM,2DAA2D,6BAA6B,2BAA2B,6BAA6B,2BAA2B,6BAA6B,2BAA2B,0DAA0D,qEAAqE,GAAG,C;;;;;;;;;;;ACA7iD,0CAA0C,0BAA0B,gBAAgB,kCAAkC,yCAAyC,4CAA4C,sDAAsD,sDAAsD,sDAAsD,uDAAuD,uDAAuD,wDAAwD,uDAAuD,uDAAuD,iCAAiC,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,+CAA+C,qEAAqE,GAAG,C;;;;;;;;;;;ACAzuC,0CAA0C,0BAA0B,gBAAgB,kCAAkC,4BAA4B,kCAAkC,gCAAgC,6FAA6F,yCAAyC,oBAAoB,gCAAgC,sDAAsD,sDAAsD,sDAAsD,uDAAuD,uDAAuD,wDAAwD,uDAAuD,uDAAuD,oIAAoI,sBAAsB,2CAA2C,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,8BAA8B,2BAA2B,iCAAiC,YAAY,iCAAiC,YAAY,iCAAiC,YAAY,iCAAiC,YAAY,GAAG,cAAc,2BAA2B,gCAAgC,YAAY,gCAAgC,YAAY,gCAAgC,YAAY,gCAAgC,YAAY,GAAG,cAAc,wDAAwD,GAAG,QAAQ,gCAAgC,GAAG,GAAG,GAAG,GAAG,C;;;;;;;;;;;ACA1tF,0CAA0C,0BAA0B,gBAAgB,kCAAkC,4BAA4B,kCAAkC,gCAAgC,6FAA6F,yCAAyC,oBAAoB,gCAAgC,sDAAsD,sDAAsD,sDAAsD,sDAAsD,uDAAuD,uDAAuD,uDAAuD,wDAAwD,wDAAwD,uDAAuD,wDAAwD,wDAAwD,oIAAoI,sBAAsB,2CAA2C,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,iBAAiB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,eAAe,SAAS,yBAAyB,EAAE,aAAa,EAAE,iBAAiB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,eAAe,SAAS,yBAAyB,EAAE,aAAa,EAAE,8BAA8B,2BAA2B,iCAAiC,YAAY,iCAAiC,YAAY,iCAAiC,YAAY,iCAAiC,YAAY,iCAAiC,YAAY,iCAAiC,YAAY,GAAG,cAAc,2BAA2B,gCAAgC,YAAY,gCAAgC,YAAY,gCAAgC,YAAY,gCAAgC,YAAY,gCAAgC,YAAY,gCAAgC,YAAY,GAAG,cAAc,wDAAwD,GAAG,QAAQ,gCAAgC,GAAG,GAAG,GAAG,GAAG,C;;;;;;;;;;;ACAlrH,0CAA0C,0BAA0B,yCAAyC,gBAAgB,kCAAkC,kCAAkC,4BAA4B,gCAAgC,kEAAkE,yCAAyC,4CAA4C,sDAAsD,sDAAsD,uDAAuD,wDAAwD,gIAAgI,sDAAsD,sDAAsD,sDAAsD,uDAAuD,uDAAuD,uDAAuD,wDAAwD,yDAAyD,yDAAyD,wDAAwD,wDAAwD,wDAAwD,mWAAmW,8vEAA8vE,2CAA2C,GAAG,C;;;;;;;;;;;ACAvhI,4CAA4C,6BAA6B,wBAAwB,gBAAgB,oCAAoC,yCAAyC,wBAAwB,wDAAwD,kCAAkC,iCAAiC,GAAG,C;;;;;;;;;;;ACApV,wEAAwE,0BAA0B,8BAA8B,wBAAwB,yCAAyC,mDAAmD,iDAAiD,gBAAgB,oCAAoC,kCAAkC,4BAA4B,yCAAyC,4CAA4C,kCAAkC,oRAAoR,sBAAsB,gBAAgB,qBAAqB,OAAO,iCAAiC,wBAAwB,+DAA+D,6CAA6C,8DAA8D,6CAA6C,8DAA8D,6CAA6C,8DAA8D,6CAA6C,6DAA6D,6CAA6C,6DAA6D,6CAA6C,8DAA8D,6CAA6C,6DAA6D,6CAA6C,6DAA6D,6CAA6C,GAAG,qDAAqD,+BAA+B,qBAAqB,0BAA0B,YAAY,iCAAiC,mBAAmB,oBAAoB,2OAA2O,4rBAA4rB,uhBAAuhB,8vEAA8vE,qBAAqB,qNAAqN,uBAAuB,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,mGAAmG,iCAAiC,yDAAyD,2CAA2C,8BAA8B,8MAA8M,2DAA2D,6BAA6B,2BAA2B,6BAA6B,2BAA2B,6BAA6B,2BAA2B,oDAAoD,mCAAmC,sCAAsC,iDAAiD,+BAA+B,iCAAiC,qDAAqD,iBAAiB,kBAAkB,GAAG,uBAAuB,GAAG,C;;;;;;;;;;;ACAxhP,iGAAiG,yBAAyB,8BAA8B,wBAAwB,4DAA4D,uDAAuD,yLAAyL,2FAA2F,2FAA2F,2FAA2F,2FAA2F,2FAA2F,2FAA2F,2FAA2F,kHAAkH,oHAAoH,4FAA4F,oHAAoH,4FAA4F,mHAAmH,2FAA2F,kHAAkH,2FAA2F,qCAAqC,GAAG,GAAG,gBAAgB,kCAAkC,oCAAoC,kCAAkC,+BAA+B,oDAAoD,qBAAqB,0BAA0B,YAAY,sBAAsB,gBAAgB,gBAAgB,OAAO,gBAAgB,gBAAgB,OAAO,uEAAuE,mDAAmD,GAAG,GAAG,2FAA2F,uCAAuC,sCAAsC,sCAAsC,+BAA+B,iCAAiC,qDAAqD,GAAG,4CAA4C,+CAA+C,GAAG,C;;;;;;;;;;;ACA/7F,sEAAsE,wBAAwB,kGAAkG,kCAAkC,iCAAiC,gBAAgB,8BAA8B,6EAA6E,mDAAmD,mDAAmD,oDAAoD,oDAAoD,qDAAqD,oDAAoD,oDAAoD,6CAA6C,qDAAqD,sFAAsF,mDAAmD,mDAAmD,mDAAmD,mDAAmD,oDAAoD,oDAAoD,oDAAoD,oDAAoD,qDAAqD,sDAAsD,sDAAsD,qDAAqD,qDAAqD,qDAAqD,qDAAqD,mFAAmF,oGAAoG,qFAAqF,mDAAmD,mDAAmD,mDAAmD,oDAAoD,oDAAoD,oDAAoD,qDAAqD,qDAAqD,oDAAoD,qDAAqD,qDAAqD,oDAAoD,oDAAoD,qDAAqD,qDAAqD,mFAAmF,oGAAoG,wCAAwC,iCAAiC,uCAAuC,yCAAyC,muBAAmuB,+6CAA+6C,86CAA86C,8EAA8E,uGAAuG,kGAAkG,uFAAuF,mHAAmH,8GAA8G,0EAA0E,oDAAoD,mCAAmC,GAAG,C;;;;;;;;;;;ACAh1O,0CAA0C,gBAAgB,sDAAsD,sDAAsD,sDAAsD,uDAAuD,uDAAuD,wDAAwD,uDAAuD,uDAAuD,mFAAmF,kCAAkC,2CAA2C,iCAAiC,GAAG,C;;;;;;;;;;;ACAprB,gFAAgF,4BAA4B,4BAA4B,wBAAwB,gCAAgC,ikKAAikK,8EAA8E,4BAA4B,0BAA0B,0BAA0B,gFAAgF,gFAAgF,GAAG,gBAAgB,2CAA2C,kCAAkC,kGAAkG,gFAAgF,gBAAgB,iCAAiC,6EAA6E,sCAAsC,iCAAiC,yCAAyC,yCAAyC,iDAAiD,yCAAyC,yCAAyC,gBAAgB,OAAO,OAAO,iBAAiB,aAAa,YAAY,gBAAgB,yBAAyB,OAAO,OAAO,kDAAkD,+FAA+F,+FAA+F,+BAA+B,GAAG,iBAAiB,GAAG,wFAAwF,GAAG,C;;;;;;;;;;;ACA3uN,yEAAyE,qCAAqC,0BAA0B,6BAA6B,wBAAwB,4BAA4B,mEAAmE,wEAAwE,mpMAAmpM,iCAAiC,iCAAiC,gBAAgB,6CAA6C,kCAAkC,kGAAkG,gBAAgB,kCAAkC,+EAA+E,iCAAiC,sBAAsB,8CAA8C,yDAAyD,uEAAuE,iCAAiC,sCAAsC,gBAAgB,WAAW,OAAO,2CAA2C,0DAA0D,+EAA+E,6BAA6B,GAAG,oCAAoC,qCAAqC,+DAA+D,GAAG,C;;;;;;;;;;;ACAxiP,sEAAsE,gBAAgB,kCAAkC,kCAAkC,iCAAiC,wBAAwB,gBAAgB,8BAA8B,mDAAmD,mDAAmD,mDAAmD,oDAAoD,oDAAoD,qDAAqD,oDAAoD,oDAAoD,8ZAA8Z,0DAA0D,mEAAmE,oDAAoD,mCAAmC,GAAG,C;;;;;;;;;;;ACApxC,kFAAkF,qCAAqC,6BAA6B,wBAAwB,4BAA4B,yKAAyK,mDAAmD,mDAAmD,kEAAkE,sDAAsD,qBAAqB,GAAG,wMAAwM,6CAA6C,kCAAkC,oGAAoG,wEAAwE,+EAA+E,gBAAgB,gDAAgD,oBAAoB,kDAAkD,mDAAmD,gBAAgB,4BAA4B,OAAO,sEAAsE,0DAA0D,oGAAoG,oCAAoC,GAAG,0FAA0F,oDAAoD,uGAAuG,uEAAuE,4FAA4F,8EAA8E,GAAG,C;;;;;;;;;;;ACAzlE,0CAA0C,gBAAgB,kCAAkC,gEAAgE,8BAA8B,GAAG,C;;;;;;;;;;;ACA7L,0CAA0C,gBAAgB,kCAAkC,0CAA0C,uFAAuF,GAAG,C;;;;;;;;;;;ACAhO,yEAAyE,qCAAqC,yBAAyB,iCAAiC,oDAAoD,6BAA6B,wBAAwB,4BAA4B,4HAA4H,uFAAuF,oEAAoE,sDAAsD,kDAAkD,8MAA8M,8CAA8C,wBAAwB,yBAAyB,sKAAsK,gBAAgB,OAAO,gBAAgB,gBAAgB,OAAO,wBAAwB,GAAG,GAAG,eAAe,gBAAgB,gBAAgB,OAAO,wBAAwB,wBAAwB,uBAAuB,uBAAuB,GAAG,uBAAuB,uBAAuB,uBAAuB,uBAAuB,GAAG,0CAA0C,iEAAiE,iEAAiE,+aAA+a,2CAA2C,2CAA2C,+BAA+B,mIAAmI,GAAG,gBAAgB,6CAA6C,kCAAkC,kGAAkG,yBAAyB,gBAAgB,kCAAkC,+EAA+E,sCAAsC,kEAAkE,kEAAkE,6EAA6E,6CAA6C,8CAA8C,gCAAgC,6CAA6C,gBAAgB,gBAAgB,OAAO,gBAAgB,gBAAgB,OAAO,oDAAoD,kKAAkK,GAAG,GAAG,4CAA4C,uHAAuH,2CAA2C,oDAAoD,6BAA6B,4DAA4D,sDAAsD,GAAG,C;;;;;;;;;;;ACA/tH,6EAA6E,gCAAgC,kCAAkC,yBAAyB,oBAAoB,oDAAoD,6BAA6B,wBAAwB,4BAA4B,6RAA6R,uFAAuF,gFAAgF,oEAAoE,qGAAqG,4RAA4R,kDAAkD,wBAAwB,yBAAyB,eAAe,SAAS,0DAA0D,sCAAsC,8FAA8F,6GAA6G,gBAAgB,OAAO,gBAAgB,gBAAgB,OAAO,yBAAyB,GAAG,GAAG,eAAe,gBAAgB,gBAAgB,OAAO,yBAAyB,yBAAyB,wBAAwB,wBAAwB,GAAG,wBAAwB,wBAAwB,wBAAwB,wBAAwB,GAAG,yDAAyD,iEAAiE,iEAAiE,6DAA6D,+hBAA+hB,2CAA2C,2CAA2C,+BAA+B,mIAAmI,GAAG,yDAAyD,sCAAsC,wCAAwC,6DAA6D,mEAAmE,GAAG,gBAAgB,0CAA0C,kCAAkC,kGAAkG,yBAAyB,gBAAgB,iCAAiC,4EAA4E,sCAAsC,kEAAkE,kEAAkE,6BAA6B,gBAAgB,WAAW,OAAO,mCAAmC,qCAAqC,sDAAsD,gBAAgB,gBAAgB,OAAO,gBAAgB,gBAAgB,OAAO,qEAAqE,uJAAuJ,GAAG,GAAG,gCAAgC,0FAA0F,qCAAqC,gBAAgB,oBAAoB,OAAO,oCAAoC,iBAAiB,iBAAiB,QAAQ,iBAAiB,iBAAiB,QAAQ,iBAAiB,gBAAgB,uEAAuE,yJAAyJ,kDAAkD,GAAG,GAAG,0FAA0F,iCAAiC,GAAG,4CAA4C,GAAG,8BAA8B,sDAAsD,qDAAqD,uCAAuC,sLAAsL,iHAAiH,GAAG,C;;;;;;;;;;;ACAp9K,wEAAwE,6BAA6B,6BAA6B,gBAAgB,qCAAqC,mCAAmC,kNAAkN,gEAAgE,GAAG,C;;;;;;;;;;;ACA/e,oEAAoE,8BAA8B,sBAAsB,gBAAgB,kCAAkC,sNAAsN,yCAAyC,GAAG,C;;;;;;;;;;;ACA5a,sCAAsC,gBAAgB,sBAAsB,GAAG,C;;;;;;;;;;;ACA/E,0CAA0C,eAAe,+BAA+B,qCAAqC,8BAA8B,GAAG,C;;;;;;;;;;;ACA9J,0CAA0C,gBAAgB,6BAA6B,GAAG,C;;;;;;;;;;;ACA1F,0CAA0C,8BAA8B,gBAAgB,kCAAkC,uCAAuC,oCAAoC,gCAAgC,sCAAsC,qFAAqF,oFAAoF,oFAAoF,uFAAuF,yCAAyC,mDAAmD,mDAAmD,mDAAmD,4CAA4C,4CAA4C,sDAAsD,GAAG,C;;;;;;;;;;;;ACAl7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwC;AACS;AACV;AACuB;AACR;AACoB;;AAE1E;AACA,6BAA6B;;AAE7B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB,iEAAkB,mBAAmB,iEAAkB;AAChF,YAAY,kDAAK,iDAAiD,YAAY,KAAK,aAAa;AAChG,gDAAgD,iEAAkB;AAClE,kDAAkD,iEAAkB;AACpE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,0FAA0F;AACzG,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,kDAAK;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,kEAAoB;;AAE1C;AACA;AACA;AACA;AACA;AACA,oBAAoB,6DAAa;AACjC;AACA;AACA,YAAY,kDAAK,kCAAkC,MAAM,KAAK,OAAO;AACrE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kDAAK;AACzB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD,qBAAqB;AACrB;AACA;AACA,8BAA8B;AAC9B,aAAa;AACb;AACA;AACA,sBAAsB,+DAAiB;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,kDAAK;AACrB;AACA,SAAS;AACT;AACA;AACA,gBAAgB,kDAAK;AACrB;AACA,SAAS;;AAET;AACA;;AAEA;AACA,6BAA6B,0EAAmB;AAChD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,+DAAiB;;AAEvC;AACA;;AAEA,WAAW,kDAAK;AAChB;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,+DAAiB;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,kBAAkB,+DAAiB;;AAEnC;AACA,C;;;;;;;;;;;;ACvSA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4C;AACE;AACE;AACI;AACF;AACA;AACQ;AACR;AACK;AACD;;AAEtD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,iEAAkB;AACtD;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iDAAiD,wDAAQ;AACzD;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mDAAmD,0DAAS;AAC5D;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,qDAAqD,4DAAU;AAC/D;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yDAAyD,gEAAY;AACrE;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,uDAAuD,8DAAW;AAClE;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,uDAAuD,8DAAW;AAClE;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,+DAA+D,sEAAe;AAC9E;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,iEAAkB;AAC/C,sBAAsB,kEAAoB,2BAA2B,IAAI,wBAAwB,iEAAkB,GAAG;;AAEtH;AACA,iEAAiE,8DAAW;AAC5E;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACpKA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiD;;AAEjD;AACA;AACA;AACA;AACA;;AAEsB;AACtB;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,kBAAkB;AACjC,eAAe,OAAO;AACtB,iBAAiB,mBAAmB;AACpC;AACA,0DAA0D,EAAE;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;;AAET;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb,SAAS;AACT;;AAEA,yDAAyD,EAAE;AAC3D;AACA,mBAAmB,6DAAa;AAChC;AACA;AACA;AACA,SAAS;AACT;AACA,C;;;;;;;;;;;;ACjKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwC;AACS;AACO;AACjB;AAC0D;;AAEjG;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,kBAAkB;AACjC,eAAe,OAAO;AACtB;AACA,2CAA2C,EAAE;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,kBAAkB;AACjC,eAAe,OAAO;AACtB;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;;AAEA,mBAAmB,aAAa;AAChC,wBAAwB,oDAAO;;AAE/B,mBAAmB,gBAAgB;AACnC;;AAEA,mBAAmB,SAAS;AAC5B;;AAEA,mBAAmB,UAAU;AAC7B;;AAEA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,2BAA2B;AAC9C;;AAEA,mBAAmB,UAAU;AAC7B;;AAEA,mBAAmB,gBAAgB;AACnC;AACA;;AAEA,mBAAmB,mBAAmB;AACtC;AACA;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,aAAa;AAChC;;AAEA,mBAAmB,SAAS;AAC5B;;AAEA,mBAAmB,SAAS;AAC5B;;AAEA,mBAAmB,SAAS;AAC5B;;;;AAIA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C;AACA;AACA,sBAAsB,mEAAqB;;AAE3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sBAAsB,0BAA0B;AAChD,mCAAmC,6DAAa;AAChD,2BAA2B,oDAAO;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,2BAA2B;AACjD;AACA;AACA;AACA;AACA,8BAA8B,mEAAqB,sBAAsB,QAAQ;AACjF;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,UAAU;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,kEAAoB;;AAE1C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,iBAAiB;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,QAAQ,GAAG,aAAa;AAChE,8BAA8B,kEAAoB,+CAA+C,QAAQ;AACzG,mDAAmD,iCAAiC,QAAQ,GAAG,EAAE,mBAAmB;AACpH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;;AAEA;AACA;AACA;;AAEA;AACA,qCAAqC;;AAErC;AACA;AACA;AACA,sBAAsB;AACtB,oCAAoC,6DAAa;AACjD,gBAAgB,oDAAO;AACvB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,OAAO;AAC7B;AACA,mCAAmC,6DAAa;;AAEhD;AACA;AACA,qCAAqC;;AAErC;AACA,YAAY,oDAAO;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;;AAEA;AACA;AACA;AACA;;AAEA,kDAAkD,MAAM,KAAK,OAAO;AACpE;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,0BAA0B;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C;AACA;AACA,mBAAmB,mEAAa;;AAEhC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,oDAAO;AAC1B;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA,YAAY,oDAAO;AACnB;AACA,aAAa;AACb;AACA;AACA;AACA,YAAY,oDAAO;AACnB;AACA,aAAa;AACb,SAAS;;AAET;AACA;AACA;AACA,uBAAuB,mEAAa;AACpC;AACA,sDAAsD;AACtD,aAAa;AACb;AACA,wBAAwB,mEAAa;AACrC;AACA;AACA;AACA,sDAAsD;AACtD,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,kDAAK;AACb;AACA,sBAAsB,+DAAiB;;AAEvC;AACA,QAAQ,oDAAO;AACf;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,gDAAgD;AAC/D,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,+DAAiB,eAAe,MAAM,iCAAiC,oCAAoC;AACrI;AACA,0BAA0B,+DAAiB;AAC3C;AACA,0BAA0B,kEAAoB;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kEAAoB,6CAA6C,MAAM;AACjG;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C;AAC3C,6DAA6D;AAC7D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;;AAElC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sBAAsB,eAAe;AACrC;AACA;AACA,iDAAiD;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,mEAAa;AAChC;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,wCAAwC;AACxC;AACA;AACA;AACA,SAAS;AACT;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA,WAAW,uBAAuB;AAClC,WAAW,YAAY;AACvB,WAAW,YAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,qBAAqB;AAChC;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA,kBAAkB,+DAAiB,8BAA8B,UAAU;;AAE3E,eAAe,qBAAqB;AACpC;;AAEA,eAAe,OAAO;AACtB;;AAEA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,uBAAuB;AAClC,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,+EAA+E;AAC/E;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACjzBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyC;AACJ;AACE;AACiB;AACF;;AAEtD;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iDAAO;AACjC;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,8BAA8B,iDAAO;AACrC;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C;AACA;;AAEA;AACA;AACA,eAAe,0FAA0F;AACzG,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA,QAAQ,iDAAO;AACf;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,kDAAK;;AAEb;AACA;AACA,QAAQ,iDAAO;AACf;;AAEA;AACA;AACA;AACA,8BAA8B,SAAS,iEAAkB,CAAC;AAC1D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;ACzJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,2CAAe,S;;;;;;;;;;;;ACrBxC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,8BAA8B,QAAQ;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,8BAA8B,QAAQ;AACtC;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA,C;;;;;;;;;;;;ACzPA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiD;;AAEjD;AACA,4BAA4B;;AAErB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,6DAAqB;;AAE3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;ACvFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACO,6BAA6B;;AAEpC;AACO,uDAAuD;;AAE9D;AACO,4BAA4B;;AAEnC;AACO;;;;AAIP;AACA;AACA;;AAEA;AACO,mBAAmB;;AAE1B;AACO,6CAA6C;;;;AAIpD;AACA;AACA;;AAEA;AACO,sDAAsD;;;;AAI7D;AACA;AACA;;AAEA;AACO;;AAEP;AACO;;AAEP;AACO;;AAEP;AACO;;AAEP;AACO,yB;;;;;;;;;;;;AC7EP;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,IAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC9DA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8CAA8C;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC;AACvC,sCAAsC;AACtC;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA,2BAA2B,aAAa,YAAY;AACpD;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;;AAErB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,uCAAuC,YAAY;AACnD;AACA,uCAAuC,eAAe,YAAY,EAAE;AACpE;AACA,uCAAuC,cAAc,YAAY,EAAE;AACnE;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,IAAI;AACnB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,IAAI;AACnB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iDAAiD,iBAAiB,oCAAoC,EAAE;AACxG,0BAA0B,YAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,IAAI;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,IAAI;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,IAAI;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,cAAc;AACxC;AACA;;AAEA;AACA;AACA;AACA,kEAAkE;AAClE,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,cAAc;AACxC;AACA;;AAEA;AACA;AACA;AACA,kEAAkE;AAClE,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,IAAI;AACnB;AACA;AACA;AACA,gFAAgF;AAChF;AACA;AACA;;AAEA;AACA,kCAAkC;;AAElC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,YAAY,8BAA8B,EAAE;AAC1E,8BAA8B,WAAW,8BAA8B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB;;AAEpB;AACA;AACA,kBAAkB;AAClB,4CAA4C;AAC5C,E;;;;;;;;;;;;;ACvbA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgC;;AAEzB,kBAAkB,4CAAK;AAC9B;AACA;AACA;AACA;AACA;;AAEO,oBAAoB,4CAAK;AAChC;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC;;AAEM;AACP;AACA;AACA;AACA;AACA,CAAC,E;;;;;;;;;;;;ACjDD;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiH;AAChE;;AAEjD;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,UAAU;AAC1B,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,UAAU;AAC1B,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,WAAW,IAA2B;AACtC;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,sBAAsB,sDAAc;AACpC;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,0EAA0E,EAAE;AAC5E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA,iCAAiC,mBAAmB,EAAE;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kDAAU,uCAAuC,KAAK;;AAE5E;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB;;AAErB;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,mBAAmB,EAAE;AACjC;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ,EAAE,QAAQ;AAC1C,wBAAwB,EAAE,EAAE,QAAQ,iBAAiB,EAAE,EAAE,QAAQ;AACjE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,4DAAoB,iDAAiD,WAAW;AACtG;AACA,sBAAsB,4DAAoB,2CAA2C,MAAM;;AAE3F;AACA;AACA;;AAEA;AACA,oCAAoC;AACpC,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;;AAEA,0BAA0B,WAAW,UAAU;AAC/C,0BAA0B,WAAW,UAAU;;AAE/C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA,sBAAsB,4DAAoB;;AAE1C;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA,sBAAsB,4DAAoB;;AAE1C;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA,0DAA0D;AAC1D;AACA;;AAEA;AACA,sBAAsB,yDAAiB;;AAEvC,mBAAmB,6DAAa;AAChC;AACA;AACA;AACA,4BAA4B,eAAe;AAC3C,6BAA6B,gBAAgB;AAC7C;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,2BAA2B,yDAAiB;AAC5C;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,C","file":"speedy-vision.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * orb.js\n * ORB features\n */\n\nimport { SpeedyGPU } from '../../../gpu/speedy-gpu';\nimport { FeatureDescriptionAlgorithm } from '../feature-description-algorithm';\nimport { FeatureAlgorithm } from '../feature-algorithm';\nimport { BinaryDescriptor } from '../../speedy-descriptor';\nimport { SpeedyFeatureWithDescriptor } from '../../speedy-feature';\nimport { AbstractMethodError } from '../../../utils/errors';\n\n// constants\nconst DESCRIPTOR_SIZE = 32; // 256 bits\nconst DEFAULT_ORIENTATION_PATCH_RADIUS = 7; // for computing keypoint orientation\n\n/**\n * ORB features\n */\nexport class ORBFeatures extends FeatureDescriptionAlgorithm\n{\n    /**\n     * Constructor\n     * @param {FeatureAlgorithm} decoratedAlgorithm preferably Multiscale Harris\n     */\n    constructor(decoratedAlgorithm)\n    {\n        super(decoratedAlgorithm, DESCRIPTOR_SIZE);\n    }\n\n    /**\n     * Compute ORB feature descriptors\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture pre-processed greyscale image\n     * @param {SpeedyTexture} detectedKeypoints tiny texture with appropriate size for the descriptors\n     * @returns {SpeedyTexture} tiny texture with encoded keypoints & descriptors\n     */\n    _describe(gpu, inputTexture, detectedKeypoints)\n    {\n        const descriptorSize = this.descriptorSize;\n        const extraSize = this.extraSize;\n\n        // get oriented keypoints\n        const orientedKeypoints = this._computeOrientation(gpu, inputTexture, detectedKeypoints);\n\n        // smooth the image before computing the descriptors\n        const smoothTexture = gpu.programs.filters.gauss7(inputTexture);\n        const smoothPyramid = smoothTexture.generatePyramid(gpu);\n\n        // compute ORB feature descriptors\n        const encoderLength = gpu.programs.encoders.encoderLength;\n        return gpu.programs.keypoints.orb(smoothPyramid, orientedKeypoints, descriptorSize, extraSize, encoderLength);\n    }\n\n    /**\n     * Compute the orientation of the keypoints\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture pre-processed greyscale image\n     * @param {SpeedyTexture} detectedKeypoints tiny texture with appropriate size for the descriptors\n     * @returns {SpeedyTexture} tiny texture with encoded keypoints & descriptors\n     */\n    _computeOrientation(gpu, inputTexture, detectedKeypoints)\n    {\n        const descriptorSize = this.descriptorSize;\n        const extraSize = this.extraSize;\n        const orientationPatchRadius = DEFAULT_ORIENTATION_PATCH_RADIUS;\n\n        // generate pyramid\n        const pyramid = inputTexture.generatePyramid(gpu);\n\n        // compute orientation\n        const encoderLength = gpu.programs.encoders.encoderLength;\n        return gpu.programs.keypoints.orientationViaCentroid(pyramid, detectedKeypoints, orientationPatchRadius, descriptorSize, extraSize, encoderLength);\n    }\n\n    /**\n     * Post-process the keypoints after downloading them\n     * @param {SpeedyFeature[]} keypoints\n     * @returns {SpeedyFeature[]}\n     */\n    _postProcess(keypoints)\n    {\n        return keypoints.map(\n            keypoint => new SpeedyFeatureWithDescriptor(\n                keypoint,\n                descriptorBytes => new BinaryDescriptor(descriptorBytes)\n            )\n        );\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * fast.js\n * FAST corner detector\n */\n\nimport { SpeedyGPU } from '../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../gpu/speedy-texture';\nimport { FeatureDetectionAlgorithm } from '../feature-detection-algorithm';\nimport { NotSupportedError } from '../../../utils/errors';\nimport { Utils } from '../../../utils/utils';\nimport { PYRAMID_MAX_LEVELS } from '../../../utils/globals';\n\n// constants\nconst DEFAULT_FAST_VARIANT = 9;\nconst DEFAULT_FAST_THRESHOLD = 20;\nconst DEFAULT_DEPTH = 4;\nconst DEFAULT_SCALE_FACTOR = 1.4142135623730951; // scale factor between consecutive pyramid layers (sqrt(2))\n\n\n\n/**\n * FAST corner detector\n */\nexport class FASTFeatures extends FeatureDetectionAlgorithm\n{\n    /**\n     * Constructor\n     */\n    constructor()\n    {\n        super();\n        this._n = DEFAULT_FAST_VARIANT;\n        this._threshold = DEFAULT_FAST_THRESHOLD;\n    }\n\n    /**\n     * Get FAST variant\n     * @returns {number}\n     */\n    get n()\n    {\n        return this._n;\n    }\n\n    /**\n     * Set FAST variant\n     * @param {number} value 9, 7 or 5\n     */\n    set n(value)\n    {\n        this._n = value | 0;\n        Utils.assert(this._n === 9 || this._n === 7 || this._n === 5);\n    }\n\n    /**\n     * Get FAST threshold\n     * @returns {number}\n     */\n    get threshold()\n    {\n        return this._threshold;\n    }\n\n    /**\n     * Set FAST threshold\n     * @param {number} value a number in [0,255]\n     */\n    set threshold(value)\n    {\n        this._threshold = value | 0;\n        Utils.assert(this._threshold >= 0 && this._threshold <= 255);\n    }\n\n    /**\n     * Detect feature points\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture pre-processed greyscale image\n     * @returns {SpeedyTexture} encoded keypoints\n     */\n    _detect(gpu, inputTexture)\n    {\n        const n = this._n;\n        const threshold = this._threshold;\n        const normalizedThreshold = threshold / 255.0;\n        const descriptorSize = this.descriptorSize;\n        const extraSize = this.extraSize;\n\n        // find corners\n        let corners = null;\n        if(n == 9)\n            corners = gpu.programs.keypoints.fast9(inputTexture, normalizedThreshold);\n        else if(n == 7)\n            corners = gpu.programs.keypoints.fast7(inputTexture, normalizedThreshold);\n        else if(n == 5)\n            corners = gpu.programs.keypoints.fast5(inputTexture, normalizedThreshold);\n        else\n            throw new NotSupportedError();\n\n        // non-maximum suppression\n        corners = gpu.programs.keypoints.nonmaxSuppression(corners);\n\n        // encode corners\n        return gpu.programs.encoders.encodeKeypoints(corners, descriptorSize, extraSize);\n    }\n}\n\n\n\n\n\n/**\n * FAST corner detector in an image pyramid\n */\nexport class MultiscaleFASTFeatures extends FeatureDetectionAlgorithm\n{\n    /**\n     * Constructor\n     */\n    constructor()\n    {\n        super();\n        this._n = DEFAULT_FAST_VARIANT;\n        this._threshold = DEFAULT_FAST_THRESHOLD;\n        this._depth = DEFAULT_DEPTH;\n        this._scaleFactor = DEFAULT_SCALE_FACTOR;\n        this._useHarrisScore = false;\n    }\n\n    /**\n     * Get FAST variant\n     * @returns {number}\n     */\n    get n()\n    {\n        return this._n;\n    }\n\n    /**\n     * Set FAST variant\n     * @param {number} value only 9 is supported at this time\n     */\n    set n(value)\n    {\n        this._n = value | 0;\n        Utils.assert(this._n === 9);\n    }\n\n    /**\n     * Get FAST threshold\n     * @returns {number}\n     */\n    get threshold()\n    {\n        return this._threshold;\n    }\n\n    /**\n     * Set FAST threshold\n     * @param {number} value a number in [0,255]\n     */\n    set threshold(value)\n    {\n        this._threshold = value | 0;\n        Utils.assert(this._threshold >= 0 && this._threshold <= 255);\n    }\n\n    /**\n     * Get depth: how many pyramid levels we will scan\n     * @returns {number}\n     */\n    get depth()\n    {\n        return this._depth;\n    }\n\n    /**\n     * Set depth: how many pyramid levels we will scan\n     * @param {number} value 1, 2, 3...\n     */\n    set depth(value)\n    {\n        this._depth = value | 0;\n        Utils.assert(this._depth >= 1 && this._depth <= PYRAMID_MAX_LEVELS);\n    }\n\n    /**\n     * Get the scale factor between consecutive pyramid layers\n     * @returns {number}\n     */\n    get scaleFactor()\n    {\n        return this._scaleFactor;\n    }\n\n    /**\n     * Set the scale factor between consecutive pyramid layers\n     * @param {number} value a value greater than 1 and less than or equal to 2\n     */\n    set scaleFactor(value)\n    {\n        this._scaleFactor = Math.min(Math.max(1, +value), 2);\n    }\n\n    /**\n     * Use Harris scoring function?\n     * @returns {boolean}\n     */\n    get useHarrisScore()\n    {\n        return this._useHarrisScore;\n    }\n\n    /**\n     * Use Harris scoring function?\n     * @param {boolean} value\n     */\n    set useHarrisScore(value)\n    {\n        this._useHarrisScore = !!value;\n    }\n\n    /**\n     * Detect feature points\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture pre-processed greyscale image\n     * @returns {SpeedyTexture} encoded keypoints\n     */\n    _detect(gpu, inputTexture)\n    {\n        const threshold = this._threshold;\n        const depth = this._depth;\n        const useHarrisScore = this._useHarrisScore;\n        const normalizedThreshold = threshold / 255.0;\n        const numberOfOctaves = 2 * depth - 1;\n        const lodStep = Math.log2(this._scaleFactor);\n        const descriptorSize = this.descriptorSize;\n        const extraSize = this.extraSize;\n\n        // generate pyramid\n        const pyramid = inputTexture.generatePyramid(gpu);\n\n        // find corners\n        let corners = null;\n        if(!useHarrisScore)\n            corners = gpu.programs.keypoints.multiscaleFast(pyramid, normalizedThreshold, numberOfOctaves, lodStep);\n        else\n            corners = gpu.programs.keypoints.multiscaleFastWithHarris(pyramid, normalizedThreshold, numberOfOctaves, lodStep);\n\n        // non-maximum suppression\n        corners = gpu.programs.keypoints.samescaleSuppression(corners);\n        corners = gpu.programs.keypoints.multiscaleSuppression(corners, lodStep);\n\n        // encode keypoints\n        const detectedKeypoints = gpu.programs.encoders.encodeKeypoints(corners, descriptorSize, extraSize);\n\n        // done\n        return detectedKeypoints;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * harris.js\n * Harris corner detector\n */\n\nimport { SpeedyGPU } from '../../../gpu/speedy-gpu';\nimport { FeatureDetectionAlgorithm } from '../feature-detection-algorithm';\nimport { PixelComponent } from '../../../utils/types';\nimport { PYRAMID_MAX_LEVELS } from '../../../utils/globals';\nimport { Utils } from '../../../utils/utils';\n\n// constants\nconst DEFAULT_QUALITY = 0.1; // default quality metric\nconst DEFAULT_DEPTH = 4; // default depth for multiscale feature detection\nconst DEFAULT_WINDOW_SIZE = 3; // compute Harris autocorrelation matrix within a 3x3 window\nconst DEFAULT_SCALE_FACTOR = 1.4142135623730951; // scale factor between consecutive pyramid layers (sqrt(2))\nconst MIN_WINDOW_SIZE = 0; // minimum window size when computing the autocorrelation matrix\nconst MAX_WINDOW_SIZE = 7; // maximum window size when computing the autocorrelation matrix\nconst SOBEL_OCTAVE_COUNT = 2 * PYRAMID_MAX_LEVELS - 1; // Sobel derivatives for each pyramid layer\n\n/**\n * Harris corner detector\n */\nexport class HarrisFeatures extends FeatureDetectionAlgorithm\n{\n    /**\n     * Constructor\n     */\n    constructor()\n    {\n        super();\n        this._quality = DEFAULT_QUALITY;\n    }\n\n    /**\n     * Get detector quality\n     * @returns {number}\n     */\n    get quality()\n    {\n        return this._quality;\n    }\n\n    /**\n     * Set detector quality\n     * @param {number} value a number in [0,1]: we will pick corners having score >= quality * max(score)\n     */\n    set quality(value)\n    {\n        this._quality = +value;\n        Utils.assert(this._quality >= 0 && this._quality <= 1);\n    }\n\n    /**\n     * Run the Harris corner detector\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture pre-processed greyscale image\n     * @returns {SpeedyTexture} encoded keypoints\n     */\n    _detect(gpu, inputTexture)\n    {\n        const quality = this._quality;\n        const descriptorSize = this.descriptorSize;\n        const extraSize = this.extraSize;\n        const windowSize = DEFAULT_WINDOW_SIZE;\n        const lod = 0, lodStep = 1, numberOfOctaves = 1;\n\n        // compute derivatives\n        const df = gpu.programs.keypoints.multiscaleSobel(inputTexture, lod);\n        const sobelDerivatives = new Array(SOBEL_OCTAVE_COUNT).fill(df);\n\n        // corner detection\n        const corners = gpu.programs.keypoints.multiscaleHarris(inputTexture, windowSize, numberOfOctaves, lodStep, sobelDerivatives);\n\n        // release derivatives\n        df.release();\n\n        // find the maximum corner response\n        const maxScore = gpu.programs.utils.scanMax(corners, PixelComponent.RED);\n\n        // non-maximum suppression\n        const suppressedCorners = gpu.programs.keypoints.nonmaxSuppression(corners);\n\n        // discard corners according to quality level\n        const filteredCorners = gpu.programs.keypoints.harrisCutoff(suppressedCorners, maxScore, quality);\n\n        // encode corners\n        return gpu.programs.encoders.encodeKeypoints(filteredCorners, descriptorSize, extraSize);\n    }\n}\n\n/**\n * Harris corner detector in an image pyramid\n */\nexport class MultiscaleHarrisFeatures extends FeatureDetectionAlgorithm\n{\n    /**\n     * Constructor\n     */\n    constructor()\n    {\n        super();\n        this._quality = DEFAULT_QUALITY;\n        this._depth = DEFAULT_DEPTH;\n        this._scaleFactor = DEFAULT_SCALE_FACTOR;\n    }\n\n    /**\n     * Get detector quality\n     * @returns {number}\n     */\n    get quality()\n    {\n        return this._quality;\n    }\n\n    /**\n     * Set detector quality\n     * @param {number} value a number in [0,1]: we will pick corners having score >= quality * max(score)\n     */\n    set quality(value)\n    {\n        this._quality = +value;\n        Utils.assert(this._quality >= 0 && this._quality <= 1);\n    }\n\n    /**\n     * Get depth: how many pyramid levels we will scan\n     * @returns {number}\n     */\n    get depth()\n    {\n        return this._depth;\n    }\n\n    /**\n     * Set depth: how many pyramid levels we will scan\n     * @param {number} value 1, 2, 3...\n     */\n    set depth(value)\n    {\n        this._depth = value | 0;\n        Utils.assert(this._depth >= 1 && this._depth <= PYRAMID_MAX_LEVELS);\n    }\n\n    /**\n     * Get the scale factor between consecutive pyramid layers\n     * @returns {number}\n     */\n    get scaleFactor()\n    {\n        return this._scaleFactor;\n    }\n\n    /**\n     * Set the scale factor between consecutive pyramid layers\n     * @param {number} value a value greater than 1 and less than or equal to 2\n     */\n    set scaleFactor(value)\n    {\n        this._scaleFactor = Math.min(Math.max(1, +value), 2);\n    }\n\n    /**\n     * Detect feature points\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture pre-processed greyscale image\n     * @returns {SpeedyTexture} encoded keypoints\n     */\n    _detect(gpu, inputTexture)\n    {\n        const quality = this._quality;\n        const depth = this._depth;\n        const descriptorSize = this.descriptorSize;\n        const extraSize = this.extraSize;\n        const windowSize = DEFAULT_WINDOW_SIZE;\n        const numberOfOctaves = 2 * depth - 1;\n        const lodStep = Math.log2(this._scaleFactor);\n\n        // generate pyramid\n        const pyramid = inputTexture.generatePyramid(gpu);\n\n        // compute derivatives\n        const sobelDerivatives = Array(SOBEL_OCTAVE_COUNT);\n        for(let j = 0; j < numberOfOctaves; j++)\n            sobelDerivatives[j] = gpu.programs.keypoints.multiscaleSobel(pyramid, j * lodStep);\n        for(let k = numberOfOctaves; k < sobelDerivatives.length; k++)\n            sobelDerivatives[k] = sobelDerivatives[k-1]; // can't call shaders with null pointers\n\n        // corner detection\n        const corners = gpu.programs.keypoints.multiscaleHarris(pyramid, windowSize, numberOfOctaves, lodStep, sobelDerivatives);\n\n        // release derivatives\n        for(let i = 0; i < numberOfOctaves; i++)\n            sobelDerivatives[i].release();\n\n        // find the maximum corner response\n        const maxScore = gpu.programs.utils.scanMax(corners, PixelComponent.RED);\n\n        // non-maximum suppression\n        const suppressed1 = gpu.programs.keypoints.samescaleSuppression(corners);\n        const suppressed2 = gpu.programs.keypoints.multiscaleSuppression(suppressed1, lodStep);\n\n        // discard corners according to the quality level\n        const filteredCorners = gpu.programs.keypoints.harrisCutoff(suppressed2, maxScore, quality);\n\n        // encode keypoints\n        const detectedKeypoints = gpu.programs.encoders.encodeKeypoints(filteredCorners, descriptorSize, extraSize);\n\n        // done\n        return detectedKeypoints;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * feature-algorithm-decorator.js\n * Decorator pattern applied to the FeatureAlgorithm class\n */\n\nimport { FeatureAlgorithm } from './feature-algorithm';\nimport { SpeedyFeature } from '../speedy-feature';\nimport { SpeedyPromise } from '../../utils/speedy-promise';\nimport { Utils } from '../../utils/utils';\n\n/**\n * This decorator lets us extend and combine\n * the FeatureAlgorithm class in many ways\n * @abstract\n */\nexport class FeatureAlgorithmDecorator extends FeatureAlgorithm\n{\n    /**\n     * Constructor\n     * @param {FeatureAlgorithm} decoratedAlgorithm \n     * @param {number} [descriptorSize] in bytes, required for GPU algorithms\n     * @param {number} [extraSize] in bytes, required for GPU algorithms\n     */\n    constructor(decoratedAlgorithm, descriptorSize = 0, extraSize = 0)\n    {\n        Utils.assert(decoratedAlgorithm instanceof FeatureAlgorithm);\n        Utils.assert(descriptorSize >= decoratedAlgorithm.descriptorSize);\n        Utils.assert(extraSize >= decoratedAlgorithm.extraSize);\n\n        super(descriptorSize, extraSize);\n\n        /** @type {FeatureAlgorithm} decorated algorithm */\n        this._decoratedAlgorithm = decoratedAlgorithm;\n        this._decoratedAlgorithm.descriptorSize = this.descriptorSize;\n        this._decoratedAlgorithm.extraSize = this.extraSize;\n    }\n\n    /**\n     * Abstract \"run\" operation:\n     * runs something on the GPU\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture\n     * @returns {SpeedyTexture}\n     */\n    run(gpu, inputTexture)\n    {\n        return this._decoratedAlgorithm.run(gpu, inputTexture);\n    }\n\n    /**\n     * Download feature points from the GPU\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} encodedKeypoints tiny texture with encoded keypoints\n     * @param {FeatureDownloaderFlag} [flags] will be passed to the downloader\n     * @returns {SpeedyPromise<SpeedyFeature[]>}\n     */\n    download(gpu, encodedKeypoints, flags = 0)\n    {\n        Utils.assert(this.extraSize == this._decoratedAlgorithm.extraSize);\n        Utils.assert(this.descriptorSize == this._decoratedAlgorithm.descriptorSize);\n\n        return this._decoratedAlgorithm.download(gpu, encodedKeypoints, flags);\n    }\n\n    /**\n     * The decorated algorithm\n     * @returns {FeatureAlgorithm}\n     */\n    get decoratedAlgorithm()\n    {\n        return this._decoratedAlgorithm;\n    }\n\n    /**\n     * Extra size of the headers of the encoded keypoint texture\n     * @return {number} in bytes\n     */\n    get extraSize()\n    {\n        return super.extraSize;\n    }\n\n    /**\n     * Set the extra size of the headers of the encoded keypoint texture\n     * @param {number} bytes a multiple of 4 (32 bits)\n     */\n    set extraSize(bytes)\n    {\n        super.extraSize = bytes;\n        this._decoratedAlgorithm.extraSize = bytes;\n    }\n\n    /**\n     * Descriptor size\n     * @return {number} in bytes\n     */\n    get descriptorSize()\n    {\n        return super.descriptorSize;\n    }\n\n    /**\n     * Set the descriptor size, in bytes\n     * @param {number} bytes a multiple of 4 (32 bits)\n     */\n    set descriptorSize(bytes)\n    {\n        super.descriptorSize = bytes;\n        this._decoratedAlgorithm.descriptorSize = bytes;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * feature-algorithm.js\n * An abstract algorithm related to feature points\n */\n\nimport { SpeedyGPU } from '../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../gpu/speedy-texture';\nimport { AbstractMethodError } from '../../utils/errors';\nimport { Utils } from '../../utils/utils';\nimport { SpeedyFeature } from '../speedy-feature';\nimport { SpeedyPromise } from '../../utils/speedy-promise';\nimport { MAX_DESCRIPTOR_SIZE } from '../../utils/globals';\n\n/**\n * An abstract algorithm that deals with\n * feature points in any way (detection,\n * tracking, etc.)\n * @abstract\n */\nexport class FeatureAlgorithm\n{\n    /**\n     * Class constructor\n     * @param {number} [descriptorSize] in bytes, required for GPU algorithms\n     * @param {number} [extraSize] in bytes, required for GPU algorithms\n     */\n    constructor(descriptorSize = 0, extraSize = 0)\n    {\n        Utils.assert(descriptorSize <= MAX_DESCRIPTOR_SIZE);\n        Utils.assert(descriptorSize % 4 === 0);\n        Utils.assert(extraSize % 4 === 0);\n\n        /** @type {number} descriptor size in bytes */\n        this._descriptorSize = descriptorSize; // for encoded keypoint textures\n\n        /** @type {number} extra size in bytes */\n        this._extraSize = extraSize; // for encoded keypoint textures\n    }\n\n    /**\n     * Abstract \"run\" operation:\n     * runs something on the GPU\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture\n     * @returns {SpeedyTexture}\n     */\n    run(gpu, inputTexture)\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Download feature points from the GPU\n     * Needs to be overridden in subclasses\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} encodedKeypoints tiny texture\n     * @param {FeatureDownloaderFlag} [flags] will be passed to the downloader\n     * @returns {SpeedyPromise<SpeedyFeature[]>} feature points\n     */\n    download(gpu, encodedKeypoints, flags = 0)\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Upload feature points to the GPU\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyFeature[]} keypoints feature points\n     * @returns {SpeedyTexture} tiny texture\n     */\n    upload(gpu, keypoints)\n    {\n        return gpu.programs.encoders.uploadKeypoints(keypoints, this.descriptorSize, this.extraSize);\n    }\n\n    /**\n     * Extra size of the headers of the encoded keypoint texture\n     * By default, this is set to zero\n     * @return {number} in bytes\n     */\n    get extraSize()\n    {\n        return this._extraSize;\n    }\n\n    /**\n     * Set the extra size of the headers of the encoded keypoint texture\n     * By default, this is set to zero\n     * This is low-level stuff!\n     * @param {number} bytes a multiple of 4 (32 bits)\n     */\n    set extraSize(bytes)\n    {\n        this._extraSize = Math.max(0, bytes | 0);\n        Utils.assert(this._extraSize % 4 === 0); // multiple of 32 bits (RGBA pixel)\n    }\n\n    /**\n     * Descriptor size\n     * By default, this is set to zero\n     * @return {number} in bytes\n     */\n    get descriptorSize()\n    {\n        return this._descriptorSize;\n    }\n\n    /**\n     * Set the descriptor size, in bytes\n     * By default, this is set to zero\n     * @param {number} bytes a multiple of 4 (32 bits)\n     */\n    set descriptorSize(bytes)\n    {\n        this._descriptorSize = Math.max(0, bytes | 0);\n        Utils.assert(this._descriptorSize % 4 === 0); // multiple of 32 bits (RGBA pixel)\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * feature-description-algorithm.js\n * Abstract feature description algorithm\n */\n\nimport { AbstractMethodError } from '../../utils/errors';\nimport { FeatureAlgorithm } from './feature-algorithm';\nimport { FeatureAlgorithmDecorator } from './feature-algorithm-decorator';\nimport { FeatureDetectionAlgorithm } from './feature-detection-algorithm';\nimport { SpeedyFeature } from '../speedy-feature';\nimport { SpeedyPromise } from '../../utils/speedy-promise';\nimport { Utils } from '../../utils/utils';\n\n/**\n * Abstract feature description algorithm\n * @abstract\n */\nexport class FeatureDescriptionAlgorithm extends FeatureAlgorithmDecorator\n{\n    /**\n     * Constructor\n     * @param {FeatureAlgorithm} decoratedAlgorithm usually the feature detection algorithm \n     * @param {number} descriptorSize in bytes, required for GPU algorithms\n     */\n    constructor(decoratedAlgorithm, descriptorSize)\n    {\n        Utils.assert(decoratedAlgorithm instanceof FeatureAlgorithm);\n        Utils.assert(descriptorSize > 0);\n\n        super(decoratedAlgorithm, descriptorSize, decoratedAlgorithm.extraSize);\n    }\n\n    /**\n     * To \"run\" this algorithm means: to describe feature points\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture pre-processed greyscale image\n     * @returns {SpeedyTexture} tiny texture with encoded keypoints & descriptors\n     */\n    run(gpu, inputTexture)\n    {\n        // run decorated algorithm (e.g., feature detection)\n        const detectedKeypoints = this.decoratedAlgorithm.run(gpu, inputTexture);\n\n        // run feature description algorithm\n        return this._describe(gpu, inputTexture, detectedKeypoints);\n    }\n\n    /**\n     * Download feature points from the GPU\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} encodedKeypoints tiny texture with encoded keypoints\n     * @param {FeatureDownloaderFlag} [flags] will be passed to the downloader\n     * @returns {SpeedyPromise<SpeedyFeature[]>}\n     */\n    download(gpu, encodedKeypoints, flags = 0)\n    {\n        return this.decoratedAlgorithm.download(gpu, encodedKeypoints, flags).then(\n            keypoints => this._postProcess(keypoints)\n        );\n    }\n\n    /**\n     * Describe feature points\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture pre-processed greyscale image\n     * @param {SpeedyTexture} detectedKeypoints tiny texture with appropriate size for the descriptors\n     * @returns {SpeedyTexture} tiny texture with encoded keypoints & descriptors\n     */\n    _describe(gpu, inputTexture, detectedKeypoints)\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Post-process the keypoints after downloading them\n     * @param {SpeedyFeature[]} keypoints\n     * @returns {SpeedyFeature[]}\n     */\n    _postProcess(keypoints)\n    {\n        //return keypoints;\n        throw new AbstractMethodError();\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * feature-detection-algorithm.js\n * Feature detection & description: abstract class\n */\n\nimport { AbstractMethodError } from '../../utils/errors';\nimport { FeatureAlgorithm } from './feature-algorithm';\nimport { FeatureDownloader } from './feature-downloader';\nimport { SpeedyFeature } from '../speedy-feature';\nimport { SpeedyGPU } from '../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../gpu/speedy-texture';\nimport { SpeedyPromise } from '../../utils/speedy-promise';\n\n// Constants\n\n/**\n * Enhancements\n * @typedef {object} FeatureDetectionEnhancements\n * @property {number} gain contrast stretching, typically in [0,1]\n * @property {number} offset global brightness, typically in [0,1]\n * @property {number} decay from the center, in [0,1]\n * @property {string} quality filter quality ('high' | 'medium' | 'low')\n */\nconst DEFAULT_ENHANCEMENTS = Object.freeze({\n    gain: 0.9,\n    offset: 0.5,\n    decay: 0.0,\n    quality: 'low'\n});\n\n/**\n * An abstract class for feature\n * detection & description\n * @abstract\n */\nexport class FeatureDetectionAlgorithm extends FeatureAlgorithm\n{\n    /**\n     * Class constructor\n     */\n    constructor()\n    {\n        super(0, 0);\n\n        /** @type {FeatureDetectionEnhancements|null} */\n        this._enhancements = null;\n\n        /** @type {FeatureDownloader} */\n        this._downloader = new FeatureDownloader();\n    }\n\n    /**\n     * To \"run\" this algorithm means: to detect feature points\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture pre-processed greyscale image\n     * @returns {SpeedyTexture} tiny texture with encoded keypoints\n     */\n    run(gpu, inputTexture)\n    {\n        const enhancedInputTexture = this._enhanceTexture(gpu, inputTexture);\n        return this._detect(gpu, enhancedInputTexture);\n    }\n\n    /**\n     * Download feature points from the GPU\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} encodedKeypoints tiny texture with encoded keypoints\n     * @param {FeatureDownloaderFlag} [flags] will be passed to the downloader\n     * @returns {SpeedyPromise<SpeedyFeature[]>}\n     */\n    download(gpu, encodedKeypoints, flags = 0)\n    {\n        return this._downloader.download(gpu, encodedKeypoints, this.descriptorSize, this.extraSize, flags);\n    }\n\n    /**\n     * Setup enhancements to be applied when detecting features\n     * @param {FeatureDetectionEnhancements|boolean} [enhancements] fix irregular lighting in the scene?\n     */\n    setEnhancements(enhancements)\n    {\n        if(enhancements === true)\n            this._enhancements = DEFAULT_ENHANCEMENTS;\n        else if(typeof enhancements === 'object' && enhancements !== null)\n            this._enhancements = Object.assign({ }, DEFAULT_ENHANCEMENTS, enhancements);\n        else\n            this._enhancements = null;\n    }\n\n    /**\n     * Detect feature points\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture pre-processed greyscale image\n     * @returns {SpeedyTexture} tiny texture with encoded keypoints\n     */\n    _detect(gpu, inputTexture)\n    {\n        // This must be implemented in subclasses\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Enhances a texture specifically for feature detection\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture\n     * @returns {SpeedyTexture}\n     */\n    _enhanceTexture(gpu, inputTexture)\n    {\n        let texture = inputTexture;\n        const options = this._enhancements;\n\n        if(options !== null) {\n            texture = gpu.programs.enhancements.nightvision(texture, options.gain, options.offset, options.decay, options.quality, true);\n            texture = gpu.programs.filters.gauss3(texture); // blur a bit more\n        }\n\n        return texture;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * feature-downloader.js\n * Download features from the GPU\n */\n\nimport { IllegalOperationError } from '../../utils/errors';\nimport { Observable } from '../../utils/observable';\nimport { SpeedyFeature } from '../speedy-feature';\nimport { SpeedyGPU } from '../../gpu/speedy-gpu';\nimport { SpeedyPromise } from '../../utils/speedy-promise';\nimport { KPF_DISCARD } from '../../utils/globals';\n\n// constants\nconst INITIAL_FILTER_GAIN = 0.85; // a number in [0,1]\nconst INITIAL_KEYPOINTS_GUESS = 600; // a guess about the initial number of keypoints\nconst MIN_KEYPOINTS = 32; // at any point in time, the encoder will have space for\n                          // at least this number of keypoints\n\n\n/**\n * A filter used to estimate the future number of\n * keypoints given past measurements\n */\nclass FeatureCountEstimator\n{\n    /**\n     * Class constructor\n     */\n    constructor()\n    {\n        this._gain = INITIAL_FILTER_GAIN;\n        this._state = INITIAL_KEYPOINTS_GUESS;\n        this._prevState = this._state;\n    }\n\n    /**\n     * Estimate the number of keypoints on the next time-step\n     * @param {number} measurement\n     * @returns {number}\n     */\n    estimate(measurement)\n    {\n        // extrapolate the current state\n        const prediction = Math.max(0, this._state + (this._state - this._prevState));\n    \n        // estimate the new state\n        const gain = this._gain; // do we trust more the prediction or the measurement?\n        const newState = prediction + gain * (measurement - prediction);\n\n        // update gain\n        this._gain = Math.min(INITIAL_FILTER_GAIN, this._gain + 0.3);\n\n        // testing\n        /*\n        this._cnt = Math.round(measurement - this._state) >= 1 ? (this._cnt||0) + 1 : 0;\n        const diff = Math.abs(Math.round(measurement - this._state));\n        const ratio = measurement / this._state-1;\n        console.log(JSON.stringify({\n            gain,\n            prediction: Math.round(prediction),\n            newState: Math.round(newState),\n            measurement,\n            diff,\n            ratio: Math.round(100*ratio)+'%'\n        }).replace(/,/g,',\\n'));\n        if(ratio+1 > this.maxGrowth) console.log('maxGrowth exceeded!');\n        */\n\n        // save state\n        this._prevState = this._state;\n        this._state = newState;\n\n        // return\n        return Math.round(this._state);\n    }\n\n    /**\n     * Reset the filter to its initial state\n     */\n    reset()\n    {\n        // trust the prediction, not the measurement\n        this._gain = 0;\n\n        // reset state & prev state\n        this._state = this._prevState = INITIAL_KEYPOINTS_GUESS;\n    }\n\n    /**\n     * We expect measurement <= maxGrowth * previousState\n     * to be true (almost) all the time, so we can\n     * accomodate the encoder\n     * @returns {number} greater than 1\n     */\n    get maxGrowth()\n    {\n        // If you increase this number, you'll get\n        // more robust responses to abrupt and significant\n        // increases in the number of keypoints, but you'll\n        // also increase the amount of data going back and\n        // forth from the GPU, thus impacting performance.\n        // We would like to keep this value low.\n        return 1.5;\n    }\n}\n\n\n\n/**\n * The FeatureDownloader receives a texture of encoded\n * keypoints and returns a corresponding array of keypoints\n */\nexport class FeatureDownloader extends Observable\n{\n    /**\n     * Class constructor\n     */\n    constructor()\n    {\n        super();\n\n        /**\n         * Used to estimate the future number of keypoints\n         * @type {FeatureCountEstimator}\n         */\n        this._estimator = new FeatureCountEstimator();\n    }\n\n    /**\n     * Download feature points from the GPU\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} encodedKeypoints tiny texture with encoded keypoints\n     * @param {number} descriptorSize in bytes (set it to zero if there is no descriptor)\n     * @param {number} extraSize in bytes (set it to zero if there is no extra data)\n     * @param {FeatureDownloaderFlag} [flags] used to modify the behavior of the downloader\n     * @returns {SpeedyPromise<SpeedyFeature[]>}\n     */\n    download(gpu, encodedKeypoints, descriptorSize, extraSize, flags = 0)\n    {\n        // reset the capacity of the downloader\n        if(flags & FeatureDownloader.RESET_DOWNLOADER_STATE != 0)\n            this._estimator.reset();\n\n        // download keypoints\n        //console.log('downloading with encoderlength=', gpu.programs.encoders.encoderLength);\n        const useBufferedDownloads = (flags & FeatureDownloader.USE_BUFFERED_DOWNLOADS) != 0;\n        return gpu.programs.encoders.downloadEncodedKeypoints(encodedKeypoints, useBufferedDownloads).then(data => {\n\n            // decode the keypoints\n            const keypoints = gpu.programs.encoders.decodeKeypoints(data, descriptorSize, extraSize);\n\n            // how many keypoints do we expect in the next frame?\n            const discardedCount = this._countDiscardedKeypoints(keypoints);\n            const nextCount = this._estimator.estimate(keypoints.length - discardedCount);\n\n            // optimize the keypoint encoder\n            // add slack (maxGrowth) to accomodate abrupt changes in the number of keypoints\n            const capacity = Math.max(nextCount, MIN_KEYPOINTS);\n            const extraCapacity = this._estimator.maxGrowth * capacity;\n            gpu.programs.encoders.optimize(extraCapacity, descriptorSize, extraSize);\n            //console.log('Encoder Length', gpu.programs.encoders.encoderLength);\n\n            // notify observers\n            this._notify(keypoints);\n\n            // done!\n            return keypoints;\n\n        }).catch(err => {\n            throw new IllegalOperationError(`Can't download keypoints`, err);\n        });\n    }\n\n    /**\n     * Count keypoints that should be discarded\n     * @param {SpeedyFeature[]} keypoints\n     */\n    _countDiscardedKeypoints(keypoints)\n    {\n        let i, count = 0;\n\n        for(i = keypoints.length - 1; i >= 0; i--)\n            count += ((keypoints[i].flags & KPF_DISCARD) != 0) | 0;\n\n        return count;\n    }\n}\n\n/**\n * Flags accepted by the FeatureDownloader (bitwise)\n * @typedef {number} FeatureDownloaderFlag\n */\n\n/**\n * Flag: reset the state of the downloader\n * @type {FeatureDownloaderFlag}\n */\nFeatureDownloader.RESET_DOWNLOADER_STATE = 1;\n\n/**\n * Flag: use buffered downloads\n * It's an optimization technique that implies a 1-frame delay\n * in the downloads when using async transfers; it may or may\n * not be acceptable, depending on what you're trying to do\n * @type {FeatureDownloaderFlag}\n */\nFeatureDownloader.USE_BUFFERED_DOWNLOADS = 2;","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * feature-tracking-algorithm.js\n * Abstract feature tracking algorithm\n */\n\nimport { SpeedyGPU } from '../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../gpu/speedy-texture';\nimport { AbstractMethodError } from '../../utils/errors';\nimport { FeatureAlgorithm } from './feature-algorithm';\nimport { FeatureDownloader } from './feature-downloader';\nimport { SpeedyFeature } from '../speedy-feature';\nimport { SpeedyPromise } from '../../utils/speedy-promise';\nimport { Utils } from '../../utils/utils';\n\n/**\n * Abstract feature tracking algorithm\n * @abstract\n */\nexport class FeatureTrackingAlgorithm extends FeatureAlgorithm\n{\n    /**\n     * Class constructor\n     */\n    constructor()\n    {\n        super(0, 0);\n\n        /** @type {SpeedyTexture} previous image */\n        this._prevImage = null;\n\n        /** @type {SpeedyTexture} tiny texture with encoded keypoints */\n        this._prevKeypoints = null;\n\n        /** @type {FeatureDownloader} keypoint downloader */\n        this._downloader = new FeatureDownloader();\n    }\n\n    /**\n     * To \"run\" this algorithm means: to track feature points\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture pre-processed greyscale image (nextImage)\n     * @returns {SpeedyTexture} tiny texture with encoded keypoints (the result of tracking)\n     */\n    run(gpu, inputTexture)\n    {\n        return this._track(gpu, inputTexture);\n    }\n\n    /**\n     * Get previous image (time: t-1)\n     * @returns {SpeedyTexture}\n     */\n    get prevImage()\n    {\n        return this._prevImage;\n    }\n\n    /**\n     * Set previous image (time: t-1)\n     * @param {SpeedyTexture} texture\n     */\n    set prevImage(texture)\n    {\n        this._prevImage = texture;\n    }\n\n    /**\n     * Get previous keypoints (time: t-1)\n     * as a tiny texture with encoded data\n     * @returns {SpeedyTexture}\n     */\n    get prevKeypoints()\n    {\n        return this._prevKeypoints;\n    }\n\n    /**\n     * Set previous keypoints (time: t-1)\n     * as a tiny texture with encoded data\n     * @param {SpeedyTexture} texture\n     */\n    set prevKeypoints(texture)\n    {\n        this._prevKeypoints = texture;\n    }\n\n    /**\n     * Download feature points from the GPU\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} encodedKeypoints tiny texture with encoded keypoints\n     * @param {FeatureDownloaderFlag} [flags] will be passed to the downloader\n     * @returns {SpeedyPromise<SpeedyFeature[]>}\n     */\n    download(gpu, encodedKeypoints, flags = 0)\n    {\n        if(flags & FeatureDownloader.USE_BUFFERED_DOWNLOADS != 0)\n            Utils.warning(`Feature trackers shouldn't use buffered downloads`);\n\n        return this._downloader.download(gpu, encodedKeypoints, this.descriptorSize, this.extraSize, flags);\n    }\n\n    /**\n     * Track a set of feature points\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} nextImage next image (time: t)\n     * @returns {SpeedyTexture} nextKeypoints tiny texture with encoded keypoints (time: t)\n     */\n    _track(gpu, nextImage)\n    {\n        throw new AbstractMethodError();\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * lk.js\n * Lucas-Kanade feature tracker in a pyramid\n */\n\nimport { SpeedyGPU } from '../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../gpu/speedy-texture';\nimport { FeatureTrackingAlgorithm } from '../feature-tracking-algorithm';\nimport { Utils } from '../../../utils/utils';\n\n// Constants\nconst DEFAULT_WINDOW_SIZE = 15;\nconst DEFAULT_DEPTH = 5;\nconst DEFAULT_DISCARD_THRESHOLD = 0.0001;\n\n/**\n * Lucas-Kanade feature tracker in a pyramid\n */\nexport class LKFeatureTrackingAlgorithm extends FeatureTrackingAlgorithm\n{\n    /**\n     * Constructor\n     */\n    constructor()\n    {\n        super();\n        this._windowSize = DEFAULT_WINDOW_SIZE;\n        this._depth = DEFAULT_DEPTH;\n        this._discardThreshold = DEFAULT_DISCARD_THRESHOLD;\n    }\n\n    /**\n     * Get neighborhood size\n     * @returns {number}\n     */\n    get windowSize()\n    {\n        return this._windowSize;\n    }\n\n    /**\n     * Set neighborhood size\n     * @param {number} value positive odd number\n     */\n    set windowSize(value)\n    {\n        this._windowSize = value | 0;\n        Utils.assert(this._windowSize % 2 === 1 && this._windowSize >= 1);\n    }\n\n    /**\n     * Get depth, i.e., how many pyramid levels will be scanned\n     * @returns {number}\n     */\n    get depth()\n    {\n        return this._depth;\n    }\n\n    /**\n     * Set depth, i.e., how many pyramid levels will be scanned\n     * @param {number} value positive integer (1, 2, 3, 4...)\n     */\n    set depth(value)\n    {\n        this._depth = value | 0;\n        Utils.assert(this._depth >= 1);\n    }\n\n    /**\n     * Get the discard threshold, used to discard \"bad\" keypoints\n     * @returns {number}\n     */\n    get discardThreshold()\n    {\n        return this._discardThreshold;\n    }\n\n    /**\n     * Set the discard threshold, used to discard \"bad\" keypoints\n     * @param {number} value typically 10^(-4) - increase to discard more\n     */\n    set discardThreshold(value)\n    {\n        this._discardThreshold = Math.max(0, +value);\n    }\n\n    /**\n     * Track a set of feature points\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} nextImage next image (time: t)\n     * @returns {SpeedyTexture} nextKeypoints tiny texture with encoded keypoints (time: t)\n     */\n    _track(gpu, nextImage)\n    {\n        const prevImage = this.prevImage;\n        const prevKeypoints = this.prevKeypoints;\n        const descriptorSize = this.descriptorSize;\n        const extraSize = this.extraSize;\n        const windowSize = this.windowSize;\n        const depth = this.depth;\n        const discardThreshold = this.discardThreshold;\n\n        // create pyramids\n        const nextPyramid = nextImage.generatePyramid(gpu);\n        const prevPyramid = prevImage.generatePyramid(gpu);\n\n        // track feature points\n        const encoderLength = gpu.programs.encoders.encoderLength;\n        return gpu.programs.trackers.lk(nextPyramid, prevPyramid, prevKeypoints, windowSize, depth, discardThreshold, descriptorSize, extraSize, encoderLength);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * basic.js\n * Basic matrix operations\n */\n\n/**\n * No-operation\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs\n */\nexport function nop(header, output, inputs)\n{\n}\n\n/**\n * Fill the matrix with a constant value\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs\n */\nexport function fill(header, output, inputs)\n{\n    const { rows, columns, stride, length } = header;\n    const { value } = header.custom;\n\n    // use a memset-like operation if possible\n    if(rows * columns == length) {\n        output.fill(value, 0, length);\n        return;\n    }\n\n    // fill the columns one by one\n    for(let j = 0; j < columns; j++)\n        output.fill(value, j * stride, j * stride + rows);\n}\n\n/**\n * Copy matrix\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs\n */\nexport function copy(header, output, inputs)\n{\n    const { rows, columns, stride, length } = header;\n    const [ istride ] = header.strideOfInputs;\n    const [ input ] = inputs;\n\n    // use a memcpy-like operation if possible\n    if(length == header.lengthOfInputs[0] && rows * columns == length) {\n        output.set(input, 0, length);\n        return;\n    }\n\n    // copy values one by one\n    let i, j, oj, ij;\n    for(oj = ij = j = 0; j < columns; j++, oj += stride, ij += istride) {\n        for(i = 0; i < rows; i++)\n            output[oj + i] = input[ij + i];\n    }\n}\n\n/**\n * Transpose matrix\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs\n */\nexport function transpose(header, output, inputs)\n{\n    const { rows, columns, stride } = header;\n    const [ strideT ] = header.strideOfInputs;\n    const [ input ] = inputs;\n\n    let i, j, ii, oj;\n    for(ii = i = 0; i < rows; i++, ii += strideT) {\n        for(oj = j = 0; j < columns; j++, oj += stride)\n            output[oj + i] = input[ii + j];\n    }\n}\n\n/**\n * Add two matrices\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs\n */\nexport function add(header, output, inputs)\n{\n    const { rows, columns, stride } = header;\n    const [ strideA, strideB ] = header.strideOfInputs;\n    const [ a, b ] = inputs;\n\n    let i, j, oj, aj, bj;\n    for(j = 0; j < columns; j++) {\n        oj = j * stride;\n        aj = j * strideA;\n        bj = j * strideB;\n        for(i = 0; i < rows; i++)\n            output[oj + i] = a[aj + i] + b[bj + i];\n    }\n}\n\n/**\n * Subtract two matrices\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs\n */\nexport function subtract(header, output, inputs)\n{\n    const { rows, columns, stride } = header;\n    const [ strideA, strideB ] = header.strideOfInputs;\n    const [ a, b ] = inputs;\n\n    let i, j, oj, aj, bj;\n    for(j = 0; j < columns; j++) {\n        oj = j * stride;\n        aj = j * strideA;\n        bj = j * strideB;\n        for(i = 0; i < rows; i++)\n            output[oj + i] = a[aj + i] - b[bj + i];\n    }\n}\n\n/**\n * Multiply two matrices (e.g., C = A B)\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs\n */\nexport function multiply(header, output, inputs)\n{\n    const { rows, columns, stride, length } = header;\n    const [ columnsA, columnsB ] = header.columnsOfInputs;\n    const [ strideA, strideB ] = header.strideOfInputs;\n    const [ a, b ] = inputs;\n\n    // clear matrix\n    if(rows * columns != length) {\n        for(let c = 0; c < columns; c++)\n            output.fill(0, c * stride, c * stride + rows);\n    }\n    else\n        output.fill(0, 0, length);\n\n    // multiply taking cache locality into account\n    let i, j, k, ok, aj, bk, bjk;\n    for(ok = bk = k = 0; k < columnsB; k++, ok += stride, bk += strideB) {\n        for(aj = j = 0; j < columnsA; j++, aj += strideA) {\n            bjk = b[bk + j];\n            for(i = 0; i < rows; i++)\n                output[ok + i] += a[aj + i] * bjk;\n        }\n    }\n}\n\n/**\n * Multiply two matrices, transposing the left operand\n * (e.g., C = A^T B)\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs\n */\nexport function multiplylt(header, output, inputs)\n{\n    const { rows, columns, stride, length } = header;\n    const [ columnsA, columnsB ] = header.columnsOfInputs;\n    const [ rowsA, rowsB ] = header.rowsOfInputs;\n    const [ strideA, strideB ] = header.strideOfInputs;\n    const [ a, b ] = inputs;\n\n    // multiply taking cache locality into account\n    let i, j, k, aj, bk, ok, ojk;\n    for(ok = bk = k = 0; k < columnsB; k++, ok += stride, bk += strideB) {\n        for(aj = j = 0; j < columnsA; j++, aj += strideA) {\n            output[ojk = ok + j] = 0;\n            for(i = 0; i < rowsB; i++)\n                output[ojk] += a[aj + i] * b[bk + i];\n        }\n    }\n}\n\n/**\n * Multiply two matrices, transposing the right operand\n * (e.g., C = A B^T)\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs\n */\nexport function multiplyrt(header, output, inputs)\n{\n    const { rows, columns, stride, length } = header;\n    const [ columnsA, columnsB ] = header.columnsOfInputs;\n    const [ rowsA, rowsB ] = header.rowsOfInputs;\n    const [ strideA, strideB ] = header.strideOfInputs;\n    const [ a, b ] = inputs;\n\n    // clear matrix\n    if(rows * columns != length) {\n        for(let c = 0; c < columns; c++)\n            output.fill(0, c * stride, c * stride + rows);\n    }\n    else\n        output.fill(0, 0, length);\n\n    // multiply taking cache locality into account\n    let i, j, k, ok, aj, bj, bkj;\n    for(aj = bj = j = 0; j < columnsA; j++, aj += strideA, bj += strideB) {\n        for(ok = k = 0; k < rowsB; k++, ok += stride) {\n            bkj = b[bj + k];\n            for(i = 0; i < rows; i++)\n                output[ok + i] += a[aj + i] * bkj;\n        }\n    }\n}\n\n/**\n * Multiply by a column-vector\n * (i.e., y = A x)\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs\n */\nexport function multiplyvec(header, output, inputs)\n{\n    const [ irows ] = header.rowsOfInputs;\n    const [ icolumns ] = header.columnsOfInputs;\n    const [ istride ] = header.strideOfInputs;\n    const [ a, x ] = inputs;\n\n    output.fill(0, 0, irows);\n\n    let i, j, aj, xj;\n    for(aj = j = 0; j < icolumns; j++, aj += istride) {\n        xj = x[j];\n        for(i = 0; i < irows; i++)\n            output[i] += a[aj + i] * xj;\n    }\n}\n\n/**\n * Multiply by a constant\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs\n */\nexport function scale(header, output, inputs)\n{\n    const { rows, columns, stride } = header;\n    const { scalar } = header.custom;\n    const [ input ] = inputs;\n\n    let i, j, oj;\n    for(j = 0; j < columns; j++) {\n        oj = j * stride;\n        for(i = 0; i < rows; i++)\n            output[oj + i] = input[oj + i] * scalar;\n    }\n}\n\n/**\n * Component-wise multiplication\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs\n */\nexport function compmult(header, output, inputs)\n{\n    const { rows, columns, stride } = header;\n    const [ strideA, strideB ] = header.strideOfInputs;\n    const [ a, b ] = inputs;\n\n    let i, j, oj, aj, bj;\n    for(j = 0; j < columns; j++) {\n        oj = j * stride;\n        aj = j * strideA;\n        bj = j * strideB;\n        for(i = 0; i < rows; i++)\n            output[oj + i] = a[aj + i] * b[bj + i];\n    }\n}\n\n/**\n * Outer product (m x 1 vector by 1 x n vector)\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs\n */\nexport function outer(header, output, inputs)\n{\n    const { rows, columns, stride } = header;\n    const [ strideA, strideB ] = header.strideOfInputs;\n    const [ a, b ] = inputs;       \n\n    let i, j, bj, oj;\n    for(j = 0; j < columns; j++) {\n        bj = b[j * strideB];\n        oj = j * stride;\n        for(i = 0; i < rows; i++)\n            output[oj + i] = a[i] * bj;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * linalg.js\n * Plug & Play Linear algebra methods\n */\n\nconst { MatrixType } = require('../matrix-type');\nconst LinAlgLib = {\n    ...require('./basic'),\n    ...require('./solve'),\n    ...require('./qr'),\n    ...require('./utils'),\n};\n\n/**\n * Plug & Play Linear Algebra methods\n * The actual Linear Algebra methods will be plugged in!\n * This is a class of static methods that can be \"exported\" to a WebWorker.\n * Currently, LinAlgLib methods cannot import things external to LinAlg.\n * @class\n */\nconst LinAlg = (function() {\n'use strict';\nfunction LinAlg() { }\n\n/** @type {object} linear algebra library */\nLinAlg.lib = Object.create(null);\n\n/** @type {object} source code of methods */\nLinAlg.lib._src = Object.create(null);\n\n/** @type {MatrixType} types of matrices */\nLinAlg.lib.MatrixType = MatrixType;\n\n/**\n * Register a method\n * @param {string} name method name\n * @param {Function} fn function code\n */\nLinAlg.register = function(name, fn)\n{\n    if(typeof fn !== `function`)\n        throw new Error(`Not a function: ${name}`);\n    else if(typeof name !== `string` || !name.match(/^[a-z_][0-9a-z_]*$/i))\n        throw new Error(`Undesirable identifier: ${name}`);\n    else if(LinAlg.hasOperation(name))\n        throw new Error(`Can't redefine method \"${name}\"`)\n\n    // methods will be bound to LinAlg.lib\n    LinAlg.lib[name] = fn.bind(LinAlg.lib);\n    LinAlg.lib._src[name] = fn.toString();\n};\n\n/**\n * Checks if a method has been registered\n * @param {string} name method name\n */\nLinAlg.hasOperation = function(name)\n{\n    return Object.prototype.hasOwnProperty.call(LinAlg.lib, name);\n}\n\n/**\n * Convert this Plug & Play class to a string\n * @returns {string}\n */\nLinAlg.toString = function()\n{\n    const decl = Object.keys(LinAlg.lib._src)\n            .map(x => `LinAlg.lib.${x} = (${LinAlg.lib._src[x]}).bind(LinAlg.lib);`)\n            .join('\\n');\n\n    return `` + // IIFE\n`(function() {\n'use strict';\nfunction LinAlg() { }\nLinAlg.lib = Object.create(null);\nLinAlg.lib.MatrixType = (${MatrixType.toString()});\n\n${decl}\n\nreturn Object.freeze(LinAlg);\n})()`;\n};\n\nreturn Object.freeze(LinAlg);\n})();\n\n// Plug in the Linear Algebra methods\nObject.keys(LinAlgLib).forEach(method => {\n    LinAlg.register(method, LinAlgLib[method]);\n});\n\nmodule.exports = { LinAlg };","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * qr.js\n * QR decomposition\n */\n\n/**\n * QR decomposition\n * @param {object} header\n * @param {ArrayBufferView} output becomes [ Q | R ] or [ Q'x | R ] or [ Qx | R ]\n * @param {ArrayBufferView[]} inputs\n */\nexport function qr(header, output, inputs)\n{\n    const { stride, dtype } = header;\n    const [ orows, ocolumns ] = [ header.rows, header.columns ];\n    const [ irows, xrows ] = header.rowsOfInputs;\n    const [ icolumns, xcolumns ] = header.columnsOfInputs;\n    const [ istride ] = header.strideOfInputs;\n    const [ input, x ] = inputs;\n    const { mode } = header.custom;\n    const subheader = Object.assign({ }, header, { custom: null });\n    const wantMatrices = (mode == 'full-qr' || mode == 'reduced-qr');\n    let submatrices = [ null, null, null ];\n\n    // create temporary storage\n    const storage = this.createTypedArray(dtype, 2 * irows * icolumns + icolumns);\n    const reflect = storage.subarray(0, irows * icolumns);\n    const tmprow = storage.subarray(irows * icolumns, irows * icolumns + icolumns);\n    const tmp = storage.subarray(irows * icolumns + icolumns, 2 * irows * icolumns + icolumns);\n\n    // create soon-to-be upper triangular matrix R\n    const rstride = stride;\n    const triangular = !wantMatrices ? output.subarray(stride) :\n        output.subarray(((mode == 'reduced-qr') ? icolumns : irows) * stride);\n\n    // input matrix is m x n and should be such that m >= n\n    if(irows < icolumns)\n        throw new Error(`Can't compute the QR decomposition of a ${irows} x ${icolumns} matrix`);\n\n    // validate the number of rows of the output\n    if(orows != irows)\n        throw new Error(`Can't compute the QR decomposition of a ${irows} x ${icolumns} matrix: expected an output matrix of ${irows} rows, but found a matrix of ${orows} rows`);\n\n    // copy input[:,:] to triangular[:,:]\n    if(input.length != triangular.length) {\n        submatrices = this.submatrices(subheader, triangular, [ input ], rstride, [ istride ],\n            [ 0, irows-1, 0, icolumns-1 ],\n            [[ 0, irows-1, 0, icolumns-1 ]]\n        );\n        this.copy(submatrices[0], submatrices[1], submatrices[2]);\n    }\n    else\n        triangular.set(input, 0, input.length);\n\n    // Compute the reflection vectors and the upper triangular matrix R\n    let i, j, k, n, norm, sign, fkk, rkk;\n    for(k = 0; k < icolumns; k++) {\n        fkk = k * irows + k; // reflector index\n        rkk = k * rstride + k; // upper-triangular R\n\n        n = irows - k; // the k-th reflection vector has n components\n        sign = (+(triangular[rkk] >= 0)) - (+(triangular[rkk] < 0)); // sign(triangular[k,k]) is +1 or -1\n\n        // use reflect[k:irows-1,k] to temporarily store the k-th reflection vector\n        for(i = 0; i < n; i++) // copy triangular[k:irows-1,k] to reflect[k:irows-1,k]\n            reflect[fkk + i] = triangular[rkk + i];\n        reflect[fkk] += sign * this.norm2(reflect, fkk, n); // 1st coordinate\n\n        // normalize the k-th reflection vector\n        norm = this.norm2(reflect, fkk, n);\n        // if(norm > 0) // error\n        for(i = fkk + n - 1; i >= fkk; i--)\n            reflect[i] /= norm;\n\n        // extract reflect[k:irows-1,k], triangular[k:irows-1,k:icolumns-1] and tmprow[0,0:icolumns-k-1]\n        submatrices = this.submatrices(subheader, tmprow, [ reflect, triangular ], 1, [ irows, rstride ],\n            [ 0, 0, 0, icolumns-k-1 ], // row vector tmprow[0,0:icolumns-k-1]\n            [\n                [ k, irows-1, k, k ], // reflect[k:irows-1,k]\n                [ k, irows-1, k, icolumns-1 ] // triangular[k:irows-1,k:icolumns-1]\n            ]\n        );\n\n        // compute tmprow[0,0:icolumns-k-1] = reflect[k:irows-1,k]^T * triangular[k:irows-1,k:icolumns-1]\n        this.multiplylt(submatrices[0], submatrices[1], submatrices[2]);\n\n        // extract reflect[k:irows-1,k], tmprow[0,0:icolumns-k-1] and tmp[0:irows-k-1,0:icolumns-k-1]\n        submatrices = this.submatrices(subheader, tmp, [ reflect, tmprow ], irows, [ irows, 1 ],\n            [ 0, irows-k-1, 0, icolumns-k-1 ], // tmp[0:irows-k-1,0:icolumns-k-1]\n            [\n                [ k, irows-1, k, k ], // reflect[k:irows-1,k]\n                [ 0, 0, 0, icolumns-k-1] // tmprow[0,0:icolumns-k-1], the result of the previous calculation\n            ]\n        );\n\n        // compute tmp[0:irows-k-1,0:icolumns-k-1] = reflect[k:irows-1,k] * tmprow[0,0:icolumns-k-1]\n        this.outer(submatrices[0], submatrices[1], submatrices[2]);\n\n        // extract tmp[0:irows-k-1,0:icolumns-k-1] and triangular[k:irows-1,k:icolumns-1] (compute in-place)\n        submatrices = this.submatrices(subheader, triangular, [ triangular, tmp ], rstride, [ rstride, irows ],\n            [ k, irows-1, k, icolumns-1 ], // triangular[k:irows-1,k:icolumns-1]\n            [\n                [ k, irows-1, k, icolumns-1 ], // triangular[k:irows-1,k:icolumns-1]\n                [ 0, irows-k-1, 0, icolumns-k-1 ] // tmp[0:irows-k-1,0:icolumns-k-1], the result of the previous calculation\n            ]\n        );\n\n        // apply Householder reflector to set the column vector triangular[k+1:irows-1,k] to zero\n        this.addInPlace(submatrices[0], submatrices[1], submatrices[2], 1, -2);\n    }\n\n    // Compute the unitary matrix Q\n    switch(mode) {\n\n        //\n        // Full QR decomposition\n        // Q: m x m, R: m x n\n        //\n        case 'full-qr': {\n            const qstride = stride;\n            const unitary = output.subarray(0, qstride * irows).fill(0);\n            let fk, qj, dot;\n\n            // validate output size\n            if(orows != irows || ocolumns != icolumns + irows)\n                throw new Error(`Can't compute the full QR decomposition of a ${irows} x ${icolumns} matrix: expected an output matrix of size ${irows} x ${icolumns + irows}, found ${orows} x ${ocolumns}`);\n\n            // apply Householder reflectors to e_j = e_1, ... , e_m\n            for(j = 0; j < irows; j++) { // for each e_j\n                qj = j * qstride;\n                unitary[qj + j] = 1; // setup e_j = [ 0 0 0 ... 1 ... 0 0 0 ]^T\n                for(k = icolumns - 1; k >= 0; k--) { // compute Q e_j = ( Q_1 ... Q_n ) e_j\n                    fk = k * irows;\n                    dot = -2 * this.dot(unitary, reflect, qj + k, fk + k, irows - k);\n                    for(i = irows - 1; i >= k; i--)\n                        unitary[qj + i] += dot * reflect[fk + i];\n                }\n            }\n\n            /*\n            // fill the lower part of R with zeros\n            let rk;\n            for(rk = k = 0; k < icolumns; k++, rk += rstride) {\n                for(i = icolumns; i < irows; i++)\n                    triangular[rk + i] = 0;\n            }\n            */\n\n            break;\n        }\n\n        //\n        // Reduced QR decomposition\n        // Q: m x n, R: n x n\n        //\n        case 'reduced-qr': {\n            const qstride = stride;\n            const unitary = output.subarray(0, qstride * icolumns).fill(0);\n            let fk, qj, dot;\n\n            // validate output size\n            if(orows != irows || ocolumns != icolumns + icolumns)\n                throw new Error(`Can't compute the reduced QR decomposition of a ${irows} x ${icolumns} matrix: expected an output matrix of size ${irows} x ${icolumns + icolumns}, found ${orows} x ${ocolumns}`);\n\n            // apply Householder reflectors to e_j = e_1, ... , e_n (n <= m)\n            for(j = 0; j < icolumns; j++) { // for each e_j\n                qj = j * qstride;\n                unitary[qj + j] = 1; // setup e_j = [ 0 0 0 ... 1 ... 0 0 0 ]^T\n                for(k = icolumns - 1; k >= 0; k--) { // compute Q e_j = ( Q_1 ... Q_n ) e_j\n                    fk = k * irows;\n                    dot = -2 * this.dot(unitary, reflect, qj + k, fk + k, irows - k);\n                    for(i = irows - 1; i >= k; i--)\n                        unitary[qj + i] += dot * reflect[fk + i];\n                }\n            }\n\n            break;\n        }\n\n        //\n        // Compute y = Q'x for an input vector x (Q' means Q^T)\n        // x: m x 1, y: m x 1\n        //\n        case 'Q\\'x': {\n            const ystride = stride;\n            const y = output.subarray(0, ystride);\n            const m = irows, n = icolumns;\n            let fk, dot;\n\n            // validate input / output size\n            if(m != xrows || 1 != xcolumns)\n                throw new Error(`QR decomposition: the input vector is expected to be ${m} x 1, but is ${xrows} x ${xcolumns}`);\n            else if(m != orows || 1 + n != ocolumns)\n                throw new Error(`QR decomposition: the output matrix is expected to be ${m} x ${1+n}, but is ${orows} x ${ocolumns}`);\n\n            // initialize output vector\n            for(i = 0; i < m; i++)\n                y[i] = x[i];\n\n            // apply Householder reflectors to input x\n            for(k = 0; k < n; k++) { // compute Q'x = ( Q_n ... Q_1 ) x\n                fk = k * irows; // get the k-th reflector\n                dot = -2 * this.dot(y, reflect, k, fk + k, m - k);\n                for(i = k; i < m; i++)\n                    y[i] += dot * reflect[fk + i];\n            }\n\n            break;\n        }\n\n        //\n        // Compute Qx for an input vector x\n        // x: m x 1, y: m x 1\n        //\n        case 'Qx': {\n            const ystride = stride;\n            const y = output.subarray(0, ystride);\n            const m = irows, n = icolumns;\n            let fk, dot;\n\n            // validate input / output size\n            if(m != xrows || 1 != xcolumns)\n                throw new Error(`QR decomposition: the input vector is expected to be ${m} x 1, but is ${xrows} x ${xcolumns}`);\n            else if(m != orows || 1 + n != ocolumns)\n                throw new Error(`QR decomposition: the output matrix is expected to be ${m} x ${1+n}, but is ${orows} x ${ocolumns}`);\n\n            // initialize output vector\n            for(i = 0; i < m; i++)\n                y[i] = x[i];\n\n            // apply Householder reflectors to input x\n            for(k = n - 1; k >= 0; k--) { // compute Qx = ( Q_1 ... Q_n ) x\n                fk = k * irows; // get the k-th reflector\n                dot = -2 * this.dot(y, reflect, k, fk + k, m - k);\n                for(i = k; i < m; i++)\n                    y[i] += dot * reflect[fk + i];\n            }\n\n            break;\n        }\n\n        //\n        // Compute y = Q'x for an input vector x using reduced QR\n        // x: m x 1, y: m x 1\n        //\n        case 'reduced-Q\\'x': {\n            const m = irows, n = icolumns;\n            const y = output.subarray(0, n); // output[n..m-1] is unused\n            const e = tmp.subarray(0, m); // e_j is m x 1, for all j = 0, 1 .. n-1\n            let fk, dot;\n\n            // validate input / output size\n            if(m != xrows || 1 != xcolumns)\n                throw new Error(`QR decomposition: the input vector is expected to be ${m} x 1, but is ${xrows} x ${xcolumns}`);\n            else if(m != orows || 1 + n != ocolumns)\n                throw new Error(`QR decomposition: the output matrix is expected to be ${m} x ${1+n}, but is ${orows} x ${ocolumns}`);\n\n            // apply Householder reflectors\n            for(j = 0; j < n; j++) { // for each e_j\n                // setup e_j = [ 0 0 0 ... 1 ... 0 0 0 ]^T\n                e.fill(0);\n                e[j] = 1;\n\n                // compute Q e_j = ( Q_1 ... Q_n ) e_j\n                for(k = n - 1; k >= 0; k--) {\n                    fk = k * irows;\n                    dot = -2 * this.dot(e, reflect, k, fk + k, m - k);\n                    for(i = m - 1; i >= k; i--)\n                        e[i] += dot * reflect[fk + i];\n                }\n\n                // compute y_j = dot(x, Q e_j)\n                y[j] = this.dot(x, e, 0, 0, m);\n            }\n\n            break;\n        }\n\n        default:\n            throw new Error(`QR decomposition: unknown mode \"${mode}\"`);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * solve.js\n * Utilities for solving linear systems of equations\n */\n\n/**\n * Back-substitution: solve Rx = b for x,\n * where R is n x n upper triangular\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs a single input of the form [ b | R ]\n */\nexport function backsub(header, output, inputs)\n{\n    const { rows, columns } = header;\n    const [ input ] = inputs;\n    const [ irows ] = header.rowsOfInputs;\n    const [ icolumns ] = header.columnsOfInputs;\n    const [ istride ] = header.strideOfInputs;\n\n    if(icolumns !== irows + 1)\n        throw new Error(`Invalid input for backsub: expected ${irows} x ${irows+1} or ${icolumns-1} x ${icolumns} matrix, but found ${irows} x ${icolumns} matrix`);\n    else if(rows !== irows || columns !== 1)\n        throw new Error(`Invalid output for backsub: expected ${irows} x 1 matrix, but found ${rows} x ${columns} matrix`);\n\n    // Back-substitution\n    const n = irows;\n    const x = output; // x is n x 1 vector (output)\n    const b = input.subarray(0, istride); // b is n x 1 vector\n    const r = input.subarray(istride); // R is n x n upper triangular\n    let i, j, rjj, rj = (n-1) * istride; // column index\n\n    x[n-1] = b[n-1] / r[rj + (n-1)];\n    for(j = n-2; j >= 0; j--) {\n        x[j] = b[j];\n        for(i = j+1; i < n; i++)\n            x[j] -= x[i] * r[istride * i + j];\n\n        rj -= istride;\n        rjj = r[rj + j];\n        /*\n        if(rjj === 0)\n            throw new Error(`Invalid input for backsub: ${j+1}-th diagonal element of the upper triangular matrix is zero`);\n        */\n        x[j] /= rjj;\n    }\n}\n\n/**\n * Find best-fit solution of Ax = b with least-squares method\n * A is m x n, b is m x 1, output x is n x 1\n * (m equations, n unknowns, m >= n)\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs [ A, b [,tmp] ] where optional tmp is m x (n+1)\n */\nexport function lssolve(header, output, inputs)\n{\n    const { stride, dtype } = header;\n    const [ m, n ] = [ header.rowsOfInputs[0], header.columnsOfInputs[0] ];\n    const tmp = inputs[2] || this.createTypedArray(dtype, m * (n+1));\n    const lsHeader = Object.assign({ }, header);\n\n    // find [ Q'b | R ] with reduced QR of A\n    lsHeader.rows = m;\n    lsHeader.columns = n+1;\n    lsHeader.stride = m;\n    lsHeader.custom = { mode: 'reduced-Q\\'x' };\n    lsHeader.byteOffset = 0;\n    lsHeader.length = tmp.length;\n    this.qr(lsHeader, tmp, [ inputs[0], inputs[1] ]);\n\n    // extract the top n x (n+1) submatrix of [ Q'b | R ]\n    // (the bottom rows are zeros)\n    const triangsys = this.submatrices(lsHeader, output, [ tmp ], stride, [ m ],\n        [ 0, n-1, 0, 0 ],\n        [\n            [ 0, n-1, 0, n ]\n        ]\n    );\n\n    // solve R x = Q'b for x\n    this.backsub(triangsys[0], triangsys[1], triangsys[2]);\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * utils.js\n * Low-level utilities for Linear Algebra routines\n */\n\n/**\n * Create a TypedArray of the specified type\n * @param {MatrixDataType} dtype data type\n * @param {any[]} args will be passed to the constructor of the TypedArray\n * @returns {ArrayBufferView}\n */\nexport function createTypedArray(dtype, ...args)\n{\n    return this.MatrixType.createTypedArray(dtype, ...args);\n}\n\n/**\n * The 2-norm of a column vector\n * @param {ArrayBufferView} column\n * @param {number} [begin] first index\n * @param {number} [length]\n * @returns {number}\n */\nexport function norm2(column, begin = 0, length = column.length)\n{\n    let norm = 0, end = begin + length, i;\n\n    // Since we store data in column-major format,\n    // we don't need to use stride\n    for(i = begin; i < end; i++)\n        norm += column[i] * column[i];\n\n    return Math.sqrt(norm);\n}\n\n/**\n * The dot product of two column vectors\n * @param {ArrayBufferView} u\n * @param {ArrayBufferView} v\n * @param {number} [uBegin] first index \n * @param {number} [vBegin] first index \n * @param {number} [length] \n */\nexport function dot(u, v, uBegin = 0, vBegin = 0, length = u.length)\n{\n    let dot = 0, i;\n\n    for(i = 0; i < length; i++)\n        dot += u[uBegin + i] * v[vBegin + i];\n\n    return dot;\n}\n\n/**\n * Given matrices A and B, scalars alpha and beta,\n * compute the sum (alpha A + beta B). The output\n * array is allowed to be one of the input arrays\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs\n * @param {number} alpha\n * @param {number} beta\n */\nexport function addInPlace(header, output, inputs, alpha, beta)\n{\n    const { rows, columns, stride } = header;\n    const [ strideA, strideB ] = header.strideOfInputs;\n    const [ a, b ] = inputs;\n\n    let i, j, oj, aj, bj;\n    for(aj = bj = oj = j = 0; j < columns; j++, oj += stride, aj += strideA, bj += strideB) {\n        for(i = 0; i < rows; i++)\n            output[oj + i] = alpha * a[aj + i] + beta * b[bj + i];\n    }\n}\n\n/**\n * Create submatrices / block-views with shared memory\n * Low-level stuff. Make sure you pass valid indices...\n * @param {object} header will be modified!\n * @param {ArrayBufferView} output contains data\n * @param {ArrayBufferView[]} inputs contains data\n * @param {number} stride of output\n * @param {number[]} strideOfInputs\n * @param {number[4]} outputIndices [firstRow, lastRow, firstColumn, lastColumn] inclusive\n * @param {Array<number[4]>} inputsIndices for each input matrix\n * @returns {Array} a triple [ header, output, inputs ]\n */\nexport function submatrices(header, output, inputs, stride, strideOfInputs, outputIndices, inputsIndices)\n{\n    let i, inputIndices;\n\n    header.rows = outputIndices[1] - outputIndices[0] + 1;\n    header.columns = outputIndices[3] - outputIndices[2] + 1;\n    header.stride = stride;\n    output = output.subarray(\n        outputIndices[2] * stride + outputIndices[0],\n        outputIndices[3] * stride + outputIndices[1] + 1\n    );\n    header.length = output.length;\n    header.byteOffset = output.byteOffset;\n\n    for(i = inputs.length - 1; i >= 0; i--) {\n        inputIndices = inputsIndices[i];\n\n        header.rowsOfInputs[i] = inputIndices[1] - inputIndices[0] + 1;\n        header.columnsOfInputs[i] = inputIndices[3] - inputIndices[2] + 1;\n        header.strideOfInputs[i] = strideOfInputs[i];\n        inputs[i] = inputs[i].subarray(\n            inputIndices[2] * strideOfInputs[i] + inputIndices[0],\n            inputIndices[3] * strideOfInputs[i] + inputIndices[1] + 1\n        );\n        header.lengthOfInputs[i] = inputs[i].length;\n        header.byteOffsetOfInputs[i] = inputs[i].byteOffset;\n    }\n\n    return [ header, output, inputs ];\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * matrix-buffer.js\n * Storage for elements of matrices\n */\n\nimport { MatrixType } from './matrix-type';\nimport { IllegalArgumentError, IllegalOperationError, NotSupportedError } from '../../utils/errors';\nimport { SpeedyPromise } from '../../utils/speedy-promise';\n\n\n/**\n * Stores the contents of a matrix\n */\nexport class MatrixBuffer\n{\n    /**\n     * Class constructor\n     * @param {number} length number of elements of the buffer\n     * @param {number[]|ArrayBufferView|null} [values] initial values in column-major format\n     * @param {MatrixDataType} [dtype] the type of the elements of the matrix\n     * @param {?MatrixBuffer} [parent] the buffer that originated this one, if any\n     */\n    constructor(length, values = null, dtype = MatrixType.default, parent = null)\n    {\n        length |= 0;\n\n        // validate\n        if(!MatrixType.isValid(dtype))\n            throw new IllegalArgumentError(`Invalid data type: \"${dtype}\"`);\n        if(length <= 0)\n            throw new IllegalArgumentError(`Invalid matrix length`);\n\n        // allocate new TypedArray\n        const data =\n            (values == null) ? MatrixType.createTypedArray(dtype, length) : (\n            Array.isArray(values) ? MatrixType.createTypedArray(dtype, values) :\n            values);\n\n\n        // store data\n\n        /** @type {MatrixDataType} data type */\n        this._dtype = dtype;\n\n        /** @type {ArrayBufferView} a reference to the TypedArray (storage) */\n        this._data = data;\n\n        /** @type {number} TypedArray byte offset: assumed to be constant */\n        this._byteOffset = data.byteOffset;\n\n        /** @type {number} TypedArray length: assumed to be constant */\n        this._length = data.length;\n\n\n\n\n        // concurrency control\n\n        /** @type {number} number of pending operations that read from or write to the buffer */\n        this._pendingOperations = parent ? parent._pendingOperations : 0;\n\n        /** @type {Array<function()>} a list of Function<void> to be called as soon as there are no pending operations */\n        this._pendingAccessesQueue = [];\n\n        /** @type {MatrixBuffer[]} a list of MatrixBuffers that share their internal memory with this one (we create a tree structure) */\n        this._children = [];\n\n        /** @type {?MatrixBuffer} the buffer that originated this one, if any (null if none) */\n        this._parent = parent;\n    }\n\n    /**\n     * Data type\n     * @returns {MatrixDataType}\n     */\n    get dtype()\n    {\n        return this._dtype;\n    }\n\n    /**\n     * Get the internal TypedArray that holds the entries of the Matrix\n     * Make sure the buffer is ready() before accessing this property\n     * @returns {ArrayBufferView}\n     */\n    get data()\n    {\n        return this._data;\n    }\n\n    /**\n     * Wait for buffer readiness. Since the buffer holds\n     * a Transferable object, the data may or may not be\n     * available right now. The returned SpeedyPromise will be\n     * resolved as soon as the buffer is available for\n     * reading and writing\n     * @returns {SpeedyPromise<MatrixBuffer>}\n     */\n    ready()\n    {\n        if(this._pendingOperations > 0) {\n            // we're not ready yet: there are calculations taking place...\n            // we'll resolve this promise as soon as there are no pending calculations\n            return new SpeedyPromise(resolve => {\n                this._pendingAccessesQueue.push(() => resolve(this));\n            });\n        }\n        else {\n            // we're ready to go!\n            // no pending operations\n            return SpeedyPromise.resolve(this);\n        }\n    }\n\n    /**\n     * Lock the buffer, so it can't be read from nor written to\n     * @param {boolean} [ascend] internal\n     */\n    lock(ascend = true)\n    {\n        let my = this;\n\n        // climb the tree\n        if(my._parent && ascend) {\n            do { my = my._parent; } while(my._parent);\n        }\n\n        // lock this buffer\n        ++my._pendingOperations;\n\n        // broadcast\n        for(let i = my._children.length - 1; i >= 0; i--)\n            my._children[i].lock(false);\n    }\n\n    /**\n     * Unlock the buffer and resolve all pending read/write operations\n     * @param {boolean} [ascend] internal\n     */\n    unlock(ascend = true)\n    {\n        let my = this;\n\n        // climb the tree\n        if(my._parent && ascend) {\n            do { my = my._parent; } while(my._parent);\n        }\n\n        // unlock this buffer\n        if(--my._pendingOperations <= 0) {\n            const callbackQueue = my._pendingAccessesQueue.slice(0); // fast clone\n\n            my._pendingOperations = 0;\n            my._pendingAccessesQueue.length = 0;\n\n            for(let i = 0; i < callbackQueue.length; i++) {\n                // if the buffer has been locked again, put the functions back in the queue\n                if(my._pendingOperations > 0) {\n                    for(let j = callbackQueue.length - 1; j >= i; j--) {\n                        my._pendingAccessesQueue.unshift(callbackQueue[j]);\n                    }\n                    break; // note: for each lock() we need an unlock()\n                }\n\n                // if the buffer remains unlocked, we're cool\n                callbackQueue[i].call(my);\n            }\n        }\n\n        // broadcast\n        for(let i = my._children.length - 1; i >= 0; i--)\n            my._children[i].unlock(false);\n    }\n\n    /**\n     * Replace the internal buffer of the TypedArray\n     * @param {ArrayBuffer} arrayBuffer new internal buffer\n     * @param {boolean} [ascend] internal\n     */\n    replace(arrayBuffer, ascend = true)\n    {\n        let my = this;\n\n        // climb the tree\n        if(my._parent && ascend) {\n            do { my = my._parent; } while(my._parent);\n        }\n\n        // replace the internal buffer\n        my._data = MatrixType.createTypedArray(this._dtype, arrayBuffer, my._byteOffset, my._length);\n\n        // broadcast\n        for(let i = my._children.length - 1; i >= 0; i--)\n            my._children[i].replace(arrayBuffer, false);\n    }\n\n    /**\n     * Create a MatrixBuffer that shares its internal memory with this one\n     * @param {number} [begin] index of the first element of the TypedArray\n     * @param {number} [length] number of elements of the TypedArray\n     * @returns {SpeedyPromise<MatrixBuffer>}\n     */\n    createSharedBuffer(begin = 0, length = this._length)\n    {\n        return this.ready().then(() => {\n            // obtain shared area of memory\n            const end = Math.min(begin + length, this._length);\n            const data = this._data.subarray(begin, end); // the main thread must own this._data\n\n            // create shared buffer\n            const sharedBuffer = new MatrixBuffer(length, data, this._dtype, this);\n            this._children.push(sharedBuffer);\n\n            // done!\n            return sharedBuffer;\n        });\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * matrix-expressions.js\n * Abstract Matrix Algebra\n */\n\nimport { SpeedyMatrix } from './matrix';\nimport { MatrixType } from './matrix-type';\nimport { MatrixOperationsQueue } from './matrix-operations-queue';\nimport { AbstractMethodError, IllegalArgumentError, IllegalOperationError } from '../../utils/errors';\nimport { SpeedyPromise } from '../../utils/speedy-promise';\nimport {\n    MatrixOperation,\n    MatrixOperationNop,\n    MatrixOperationFill,\n    MatrixOperationCopy,\n    MatrixOperationTranspose,\n    MatrixOperationAdd,\n    MatrixOperationSubtract,\n    MatrixOperationMultiply,\n    MatrixOperationMultiplyLT,\n    MatrixOperationMultiplyRT,\n    MatrixOperationMultiplyVec,\n    MatrixOperationScale,\n    MatrixOperationCompMult,\n    MatrixOperationQR,\n    MatrixOperationQRSolve,\n    MatrixOperationBackSubstitution,\n    MatrixOperationLSSolve,\n} from './matrix-operations';\n\n// constants\nconst matrixOperationsQueue = MatrixOperationsQueue.instance;\n\n\n// ================================================\n// ABSTRACT TYPES\n// ================================================\n\n/**\n * An abstract algebraic expression with matrices\n * All expressions must be immutable from the outside\n * @abstract\n */\nclass SpeedyMatrixExpr\n{\n    /**\n     * Constructor\n     * @param {number} rows expected number of rows of the resulting expression\n     * @param {number} columns expected number of columns of the resulting expression\n     * @param {MatrixDataType} dtype data type\n     */\n    constructor(rows, columns, dtype)\n    {\n        /** @type {number} expected number of rows of the resulting expression */\n        this._rows = rows | 0;\n\n        /** @type {number} expected number of columns of the resulting expression */\n        this._columns = columns | 0;\n\n        /** @type {MatrixDataType} data type of the elements of the matrix */\n        this._dtype = dtype;\n\n        /** @type {?number[]} internal buffer for reading matrix data */\n        this._readbuf = null;\n\n\n\n        // validate\n        if(this._rows <= 0 || this._columns <= 0)\n            throw new IllegalArgumentError(`Invalid dimensions for a matrix expression: ${this._rows} x ${this._columns}`);\n        else if(!MatrixType.isValid(this._dtype))\n            throw new IllegalArgumentError(`Invalid type for a matrix expression: \"${this._dtype}\"`);\n    }\n\n    /**\n     * Number of rows of the resulting matrix\n     * @returns {number}\n     */\n    get rows()\n    {\n        return this._rows;\n    }\n\n    /**\n     * Number of columns of the resulting matrix\n     * @returns {number}\n     */\n    get columns()\n    {\n        return this._columns;\n    }\n\n    /**\n     * Type of the resulting matrix, as a string\n     * @returns {MatrixDataType}\n     */\n    get dtype()\n    {\n        return this._dtype;\n    }\n\n    /**\n     * Assert matrix shape and type\n     * @param {number} requiredRows\n     * @param {number} requiredColumns\n     * @param {MatrixDataType} [requiredDataType]\n     */\n    _assertCompatibility(requiredRows, requiredColumns, requiredDataType = this._dtype)\n    {\n        if(requiredRows === this._rows && requiredColumns === this._columns && requiredDataType === this._dtype)\n            return;\n        else if(requiredDataType !== this._dtype)\n            throw new IllegalOperationError(`Incompatible matrix type (expected \"${requiredDataType}\", found \"${this._dtype}\")`);\n        else\n            throw new IllegalOperationError(`Incompatible matrix shape (expected ${requiredRows} x ${requiredColumns}, found ${this._rows} x ${this._columns})`);\n    }\n\n    /**\n     * Evaluate the expression\n     * @returns {SpeedyPromise<SpeedyMatrixExpr>}\n     */\n    _evaluate()\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Get the matrix associated with the result of this expression\n     * This matrix must be guaranteed to be available after evaluating this expression\n     * @returns {SpeedyMatrix}\n     */\n    get _matrix()\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Assign a matrix\n     * @param {SpeedyMatrix} matrix\n     * @returns {SpeedyPromise<void>} resolves as soon as the assignment is done\n     */\n    _assign(matrix)\n    {\n        throw new IllegalOperationError(`Can't assign matrix: not a l-value`);\n    }\n\n\n\n    //\n    // GENERIC UTILITIES\n    //\n\n    /**\n     * Assign an expression (i.e., this := expr)\n     * @param {SpeedyMatrixExpr|number[]} expr\n     * @returns {SpeedyPromise<SpeedyMatrixAssignmentExpr>}\n     */\n    assign(expr)\n    {\n        throw new IllegalOperationError(`Can't assign matrix: not a l-value`);\n    }\n\n    /**\n     * Fill the matrix with a constant value\n     * @param {number} value\n     * @returns {SpeedyPromise<SpeedyMatrixAssignmentExpr>}\n     */\n    fill(value)\n    {\n        throw new IllegalOperationError(`Can't fill matrix: not a l-value`);\n    }\n\n    /**\n     * Read the entries of this matrix\n     * Results are given in column-major format\n     * @returns {SpeedyPromise<number[]>}\n     */\n    read()\n    {\n        this._readbuf = this._readbuf || [];\n        return this._evaluate().then(expr => expr._matrix.read(undefined, this._readbuf)).turbocharge();\n    }\n\n    /**\n     * Print the result of this matrix expression to the console\n     * @param {number} [decimals] format numbers to a number of decimals\n     * @param {Function} [printFunction] prints a string\n     * @returns {SpeedyPromise<void>} a promise that resolves as soon as the matrix is printed\n     */\n    print(decimals = undefined, printFunction = undefined)\n    {\n        return this._evaluate().then(expr => expr._matrix.print(decimals, printFunction)).turbocharge();\n    }\n\n    /**\n     * Convert to string\n     * @returns {string}\n     */\n    toString()\n    {\n        return this._matrix.toString();\n    }\n\n\n\n\n\n    //\n    // ACCESS BY BLOCK\n    //\n\n    /**\n     * Extract a (lastRow - firstRow + 1) x (lastColumn - firstColumn + 1)\n     * block from the matrix. All indices are 0-based. Note that the\n     * memory of the block is shared with the memory of the matrix.\n     * @param {number} firstRow\n     * @param {number} lastRow\n     * @param {number} firstColumn\n     * @param {number} lastColumn\n     * @returns {SpeedyMatrixReadonlyBlockExpr}\n     */\n    block(firstRow, lastRow, firstColumn, lastColumn)\n    {\n        return new SpeedyMatrixReadonlyBlockExpr(this, firstRow, lastRow, firstColumn, lastColumn);\n    }\n\n    /**\n     * Get the i-th row of the matrix\n     * @param {number} i 0-based index\n     */\n    row(i)\n    {\n        return this.block(i, i, 0, this._columns - 1);\n    }\n\n    /**\n     * Get the j-th column of the matrix\n     * @param {number} j 0-based index\n     */\n    column(j)\n    {\n        return this.block(0, this._rows - 1, j, j);\n    }\n\n    /**\n     * Get (lastRow - firstRow + 1) contiguous rows. Both indices are inclusive.\n     * @param {number} firstRow\n     * @param {number} lastRow\n     */\n    rowSpan(firstRow, lastRow)\n    {\n        return this.block(firstRow, lastRow, 0, this._columns - 1);\n    }\n\n    /**\n     * Get (lastColumn - firstColumn + 1) contiguous columns. Both indices are inclusive.\n     * @param {number} firstColumn\n     * @param {number} lastColumn\n     */\n    columnSpan(firstColumn, lastColumn)\n    {\n        return this.block(0, this._rows - 1, firstColumn, lastColumn);\n    }\n\n    /**\n     * Get the main diagonal of the matrix. Internal buffer is shared.\n     * @returns {SpeedyMatrixReadonlyDiagonalExpr}\n     */\n    diagonal()\n    {\n        return new SpeedyMatrixReadonlyDiagonalExpr(this);\n    }\n\n\n\n\n    //\n    // GENERAL OPERATIONS\n    //\n\n\n    /**\n     * Clone matrix\n     * @returns {SpeedyMatrixExpr}\n     */\n    clone()\n    {\n        return new SpeedyMatrixCloneExpr(this);\n    }\n\n    /**\n     * Transpose matrix\n     * @returns {SpeedyMatrixExpr}\n     */\n    transpose()\n    {\n        return new SpeedyMatrixTransposeExpr(this);\n    }\n\n    /**\n     * Add this matrix to another\n     * @param {SpeedyMatrixExpr} expr\n     * @returns {SpeedyMatrixExpr}\n     */\n    plus(expr)\n    {\n        return new SpeedyMatrixAddExpr(this, expr);\n    }\n\n    /**\n     * Subtract another matrix from this\n     * @param {SpeedyMatrixExpr} expr\n     * @returns {SpeedyMatrixExpr}\n     */\n    minus(expr)\n    {\n        return new SpeedyMatrixSubtractExpr(this, expr);\n    }\n\n    /**\n     * Multiply by a matrix or by a number\n     * @param {SpeedyMatrixExpr|number} expr\n     * @returns {SpeedyMatrixExpr}\n     */\n    times(expr)\n    {\n        if(expr instanceof SpeedyMatrixExpr)\n            return new SpeedyMatrixMultiplyExpr(this, expr);\n        else\n            return new SpeedyMatrixScaleExpr(this, expr);\n    }\n\n    /**\n     * Component-wise multiplication\n     * @param {SpeedyMatrixExpr} expr\n     * @returns {SpeedyMatrixExpr}\n     */\n    compMult(expr)\n    {\n        return new SpeedyMatrixCompMultExpr(this, expr);\n    }\n\n\n\n    //\n    // Linear Algebra\n    //\n\n    /**\n     * QR decomposition\n     * @param {string} [mode] 'full' | 'reduced'\n     * @returns {SpeedyMatrixExpr}\n     */\n    qr(mode = 'reduced')\n    {\n        return new SpeedyMatrixQRExpr(this, mode);\n    }\n\n    /**\n     * Find least squares solution for a system of linear equations,\n     * i.e., find x such that the 2-norm |b - Ax| is minimized.\n     * A is this (m x n) matrix expression, satisfying m >= n\n     * m is the number of equations and n is the number of unknowns\n     * @param {SpeedyMatrixExpr} b m x 1 matrix\n     */\n    lssolve(b)\n    {\n        return new SpeedyMatrixLSSolveNodeExpr(this, b);\n    }\n\n    /**\n     * Solve a linear system of equations,\n     * i.e., solve Ax = b for x. A is this\n     * (m x m) expression and b is m x 1\n     * @param {SpeedyMatrixExpr} b\n     * @param {string} [method] 'qr'\n     */\n    solve(b, method = 'qr')\n    {\n        // m: rows (number of equations), n: columns (number of unknowns)\n        const rows = this._rows, columns = this._columns;\n\n        // validate size\n        if(rows !== columns)\n            throw new IllegalArgumentError(`solve expects a square matrix, but received a ${rows} x ${columns} matrix`);\n        else if(b.rows !== rows || b.columns !== 1)\n            throw new IllegalArgumentError(`solve expected a ${rows} x 1 input vector, but received a ${b.rows} x ${b.columns} matrix`);\n\n        // solve system of equations\n        switch(method)\n        {\n            case 'qr':\n                return this.lssolve(b);\n\n            // TODO: Gaussian elimination\n            //case 'lu':\n\n            default:\n                throw new IllegalArgumentError(`Unknown method for solve: \"${method}\"`);\n        }\n    }\n\n\n\n\n\n\n\n    //\n    // Internal utilities\n    //\n\n    /**\n     * Internal QR solver: Ax = b\n     * This creates a matrix [ (Q^T) b | R ] using reduced QR\n     * All (m-n) entries at the bottom are zeros\n     * @param {SpeedyMatrixExpr} b\n     * @returns {SpeedyMatrixExpr}\n     */\n    _qrSolve(b)\n    {\n        return new SpeedyMatrixQRSolverNodeExpr(this, b);\n    }\n\n    /**\n     * Internal back-substitution algorithm. It assumes this\n     * matrix expression is of the form [ b | R ] for some\n     * upper-triangular R matrix and some column-vector b\n     */\n    _backSubstitution()\n    {\n        return new SpeedyMatrixBackSubstitutionNodeExpr(this);\n    }\n}\n\n/**\n * The result of an intermediate calculation (e.g., A + B)\n * A temporary matrix for storing the result of the calculation is created\n * @abstract\n */\nclass SpeedyMatrixTempExpr extends SpeedyMatrixExpr\n{\n    /**\n     * Constructor\n     * @param {number} rows number of rows of the output matrix\n     * @param {number} columns number of columns of the output matrix\n     * @param {MatrixDataType} dtype type of the output matrix\n     */\n    constructor(rows, columns, dtype)\n    {\n        super(rows, columns, dtype);\n\n        /** @type {SpeedyMatrix} used for temporary calculations */\n        this._tmpmatrix = new SpeedyMatrix(rows, columns, undefined, dtype);\n    }\n\n    /**\n     * Get the matrix associated with this expression\n     * This matrix must be guaranteed to be available after evaluating this expression\n     * @returns {SpeedyMatrix}\n     */\n    get _matrix()\n    {\n        return this._tmpmatrix;\n    }\n}\n\n/**\n * Unary expression\n * @abstract\n */\nclass SpeedyMatrixUnaryExpr extends SpeedyMatrixTempExpr\n{\n    /**\n     * Constructor\n     * @param {number} rows number of rows of the resulting (output) matrix\n     * @param {number} columns number of columns of the resulting (output) matrix\n     * @param {SpeedyMatrixExpr} expr input expression\n     * @param {Function} operationClass unary operation\n     * @param {any[]} [...args] will be used when instantiating the unary operation\n     */\n    constructor(rows, columns, expr, operationClass, ...args)\n    {\n        super(rows, columns, expr.dtype);\n\n        /** @type {SpeedyMatrixExpr} input expression */\n        this._expr = expr;\n\n        /** @type {Function} unary operation */\n        this._operationClass = operationClass;\n\n        /** @type {?MatrixOperation} we cache the MatrixOperation object */\n        this._operation = null;\n\n        /** @type {any[]} arguments to be used when instantiating the unary operation */\n        this._args = args;\n    }\n\n    /**\n     * Evaluate expression\n     * @returns {SpeedyPromise<SpeedyMatrixExpr>}\n     */\n    _evaluate()\n    {\n        return this._expr._evaluate().then(result =>\n            matrixOperationsQueue.enqueue(\n                (\n                    this._operation ? this._operation.update([ result._matrix ]) :\n                    (this._operation = new (this._operationClass)(result._matrix, ...(this._args)))\n                ),\n                this._matrix\n            )\n        ).then(() => this);\n    }\n\n    /**\n     * Input expression\n     * @returns {SpeedyMatrixExpr}\n     */\n    get child()\n    {\n        return this._expr;\n    }\n}\n\n/**\n * Binary expression\n * @abstract\n */\nclass SpeedyMatrixBinaryExpr extends SpeedyMatrixTempExpr\n{\n    /**\n     * Constructor\n     * @param {number} rows number of rows of the resulting (output) matrix\n     * @param {number} columns number of columns of the resulting (output) matrix\n     * @param {SpeedyMatrixExpr} leftExpr left operand/expression\n     * @param {SpeedyMatrixExpr} rightExpr right operand/expression\n     * @param {Function} operationClass binary operation\n     * @param {any[]} [...args] will be used when instantiating the binary operation\n     */\n    constructor(rows, columns, leftExpr, rightExpr, operationClass, ...args)\n    {\n        super(rows, columns, leftExpr.dtype);\n\n        /** @type {SpeedyMatrixExpr} left operand */\n        this._leftExpr = leftExpr;\n\n        /** @type {SpeedyMatrixExpr} right operand */\n        this._rightExpr = rightExpr;\n\n        /** @type {Function} binary operation */\n        this._operationClass = operationClass;\n\n        /** @type {?MatrixOperation} we cache the MatrixOperation object */\n        this._operation = null;\n\n        /** @type {any[]} arguments to be used when instantiating the binary operation */\n        this._args = args;\n\n\n\n        // validate\n        if(rightExpr.dtype !== leftExpr.dtype) // just in case...\n            this._assertCompatibility(rows, columns, rightExpr.dtype);\n    }\n\n    /**\n     * Evaluate expression\n     * @returns {SpeedyPromise<SpeedyMatrixExpr>}\n     */\n    _evaluate()\n    {\n        return SpeedyPromise.all([\n            this._leftExpr._evaluate().turbocharge(),\n            this._rightExpr._evaluate().turbocharge()\n        ]).then(([ leftResult, rightResult ]) =>\n            matrixOperationsQueue.enqueue(\n                (\n                    this._operation ? this._operation.update([ leftResult._matrix, rightResult._matrix ]) :\n                    (this._operation = new (this._operationClass)(leftResult._matrix, rightResult._matrix, ...(this._args)))\n                ),\n                this._matrix\n            )\n        ).then(() => this);\n    }\n\n    /**\n     * Left input expression\n     * @returns {SpeedyMatrixExpr}\n     */\n    get leftChild()\n    {\n        return this._leftExpr;\n    }\n\n    /**\n     * Right input expression\n     * @returns {SpeedyMatrixExpr}\n     */\n    get rightChild()\n    {\n        return this._rightExpr;\n    }\n}\n\n/**\n * Extract a read-only block submatrix from a matrix expression\n */\nclass SpeedyMatrixReadonlyBlockExpr extends SpeedyMatrixExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} expr originating matrix expression\n     * @param {number} firstRow indexed by 0\n     * @param {number} lastRow\n     * @param {number} firstColumn\n     * @param {number} lastColumn\n     */\n    constructor(expr, firstRow, lastRow, firstColumn, lastColumn)\n    {\n        super(lastRow - firstRow + 1, lastColumn - firstColumn + 1, expr.dtype);\n\n        /** @type {SpeedyMatrixExpr} originating matrix expression */\n        this._expr = expr;\n\n        /** @type {number} index of the top-most row (starts at zero) */\n        this._firstRow = firstRow;\n\n        /** @type {number} index of the last row */\n        this._lastRow = lastRow;\n\n        /** @type {number} index of the left-most column (starts at zero) */\n        this._firstColumn = firstColumn;\n\n        /** @type {number} index of the right-most column */\n        this._lastColumn = lastColumn;\n\n        /** @type {?SpeedyMatrix} the matrix associated with this expression */\n        this._submatrix = null;\n\n        /** @type {?SpeedyMatrix} used for caching */\n        this._cachedMatrix = null;\n    }\n\n    /**\n     * Get the matrix associated with this expression\n     * This matrix must be guaranteed to be available after evaluating this expression\n     * @returns {SpeedyMatrix}\n     */\n    get _matrix()\n    {\n        return this._submatrix;\n    }\n\n    /**\n     * Evaluate the expression\n     * @returns {SpeedyPromise<SpeedyMatrixExpr>}\n     */\n    _evaluate()\n    {\n        return this._expr._evaluate().then(result => {\n            if(result._matrix !== this._cachedMatrix || this._submatrix === null) {\n                this._cachedMatrix = result._matrix;\n                return this._cachedMatrix.block(this._firstRow, this._lastRow, this._firstColumn, this._lastColumn);\n            }\n            return this._submatrix; // we've already extracted the submatrix\n        }).then(submatrix => {\n            this._submatrix = submatrix;\n            return this;\n        });\n    }\n}\n\n/**\n * Extract a read-only diagonal from a matrix expression\n */\nclass SpeedyMatrixReadonlyDiagonalExpr extends SpeedyMatrixExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} expr originating matrix expression\n     */\n    constructor(expr)\n    {\n        const diagonalLength = Math.min(expr.rows, expr.columns);\n        super(1, diagonalLength, expr.dtype);\n\n        /** @type {SpeedyMatrixExpr} originating matrix expression */\n        this._expr = expr;\n\n        /** @type {?SpeedyMatrix} the matrix associated with this expression */\n        this._diagonal = null;\n\n        /** @type {?SpeedyMatrix} used for caching */\n        this._cachedMatrix = null;\n    }\n\n    /**\n     * Get the matrix associated with this expression\n     * This matrix must be guaranteed to be available after evaluating this expression\n     * @returns {SpeedyMatrix}\n     */\n    get _matrix()\n    {\n        return this._diagonal;\n    }\n\n    /**\n     * Evaluate the expression\n     * @returns {SpeedyPromise<SpeedyMatrixExpr>}\n     */\n    _evaluate()\n    {\n        return this._expr._evaluate().then(result => {\n            if(result._matrix !== this._cachedMatrix || this._diagonal === null) {\n                this._cachedMatrix = result._matrix;\n                return this._cachedMatrix.diagonal();\n            }\n            return this._diagonal; // we've already extracted the diagonal\n        }).then(diagonal => {\n            this._diagonal = diagonal;\n            return this;\n        });\n    }\n}\n\n\n\n\n// ================================================\n// L-VALUES\n// ================================================\n\n/**\n * An lvalue (locator value) expression represents a user-owned object stored in memory\n * @abstract\n */\nclass SpeedyMatrixLvalueExpr extends SpeedyMatrixExpr\n{\n    /**\n     * Get the matrix associated with this lvalue expression\n     * This matrix must be guaranteed to be available after evaluating this expression\n     * @returns {SpeedyMatrix}\n     */\n    get _matrix()\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Assign a matrix\n     * @param {SpeedyMatrix} matrix\n     * @returns {SpeedyPromise<void>} resolves as soon as the assignment is done\n     */\n    _assign(matrix)\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Assign an expression to this lvalue\n     * @param {SpeedyMatrixExpr|number[]} expr\n     * @returns {SpeedyPromise<SpeedyMatrixAssignmentExpr>} resolves as soon as the assignment is done\n     */\n    assign(expr)\n    {\n        const assignment = new SpeedyMatrixAssignmentExpr(this, expr);\n        return assignment._evaluate().turbocharge();\n    }\n\n    /**\n     * Fill the matrix with a constant value\n     * @param {number} value\n     * @returns {SpeedyPromise<SpeedyMatrixAssignmentExpr>}\n     */\n    fill(value)\n    {\n        return this.assign(new SpeedyMatrixFillExpr(this._rows, this._columns, this._dtype, +value));\n    }\n\n    /**\n     * Extract a (lastRow - firstRow + 1) x (lastColumn - firstColumn + 1)\n     * block from the matrix. All indices are 0-based. Note that the\n     * memory of the block is shared with the memory of the matrix.\n     * @param {number} firstRow\n     * @param {number} lastRow\n     * @param {number} firstColumn\n     * @param {number} lastColumn\n     * @returns {SpeedyMatrixReadwriteBlockExpr}\n     */\n    block(firstRow, lastRow, firstColumn, lastColumn)\n    {\n        return new SpeedyMatrixReadwriteBlockExpr(this, firstRow, lastRow, firstColumn, lastColumn);\n    }\n\n    /**\n     * Get the main diagonal of the matrix. Internal buffer is shared.\n     * @returns {SpeedyMatrixReadwriteDiagonalExpr}\n     */\n    diagonal()\n    {\n        return new SpeedyMatrixReadwriteDiagonalExpr(this);\n    }\n}\n\n/**\n * Assignment expression\n * Assign rvalue to lvalue (i.e., lvalue := rvalue)\n */\nclass SpeedyMatrixAssignmentExpr extends SpeedyMatrixLvalueExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixLvalueExpr} lvalue\n     * @param {SpeedyMatrixExpr|number[]} rvalue matrix expression or array of numbers in column-major format\n     */\n    constructor(lvalue, rvalue)\n    {\n        const { rows, columns, dtype } = lvalue;\n        super(rows, columns, dtype);\n\n        // convert rvalue to SpeedyMatrixExpr\n        if(!(rvalue instanceof SpeedyMatrixExpr)) {\n            if(Array.isArray(rvalue)) {\n                const matrix = new SpeedyMatrix(rows, columns, rvalue, dtype);\n                rvalue = new SpeedyMatrixElementaryExpr(rows, columns, dtype, matrix);\n            }\n            else\n                throw new IllegalArgumentError(`Can't assign matrix to ${rvalue}`)\n        }\n\n        this._assertCompatibility(rvalue.rows, rvalue.columns, rvalue.dtype);\n\n        /** @type {SpeedyMatrixLvalueExpr} */\n        this._lvalue = lvalue;\n\n        /** @type {SpeedyMatrixExpr} */\n        this._rvalue = rvalue;\n    }\n\n    /**\n     * Evaluate expression\n     * @returns {SpeedyPromise<SpeedyMatrixAssignmentExpr>}\n     */\n    _evaluate()\n    {\n        return SpeedyPromise.all([\n            this._lvalue._evaluate().turbocharge(),\n            this._rvalue._evaluate().turbocharge()\n        ]).then(([ lvalue, rvalue ]) =>\n            lvalue._assign(rvalue._matrix).turbocharge()\n        ).then(() => this);\n    }\n\n    /**\n     * Get the matrix associated with this lvalue expression\n     * This matrix must be guaranteed to be available after evaluating this expression\n     * @returns {SpeedyMatrix}\n     */\n    get _matrix()\n    {\n        return this._lvalue._matrix;\n    }\n}\n\n/**\n * An elementary expression representing a single matrix\n * (e.g., expression 'A' represents a single matrix)\n */\nclass SpeedyMatrixElementaryExpr extends SpeedyMatrixLvalueExpr\n{\n    /**\n     * Constructor\n     * @param {number} rows\n     * @param {number} columns\n     * @param {MatrixDataType} dtype\n     * @param {SpeedyMatrix} [matrix] user matrix\n     */\n    constructor(rows, columns, dtype, matrix = null)\n    {\n        super(rows, columns, dtype);\n\n        // validate\n        if(matrix != null)\n            this._assertCompatibility(matrix.rows, matrix.columns, matrix.dtype);\n\n        /** @type {?SpeedyMatrix} the matrix associated with this expression */\n        this._usermatrix = matrix;\n    }\n\n    /**\n     * Get the matrix associated with this lvalue expression\n     * This matrix must be guaranteed to be available after evaluating this expression\n     * @returns {SpeedyMatrix}\n     */\n    get _matrix()\n    {\n        if(this._usermatrix == null)\n            throw new IllegalOperationError(`Matrix doesn't have any data. Make sure you assign data to it.`);\n\n        return this._usermatrix;\n    }\n\n    /**\n     * Evaluate the expression\n     * @returns {SpeedyPromise<SpeedyMatrixExpr>}\n     */\n    _evaluate()\n    {\n        return SpeedyPromise.resolve(this);\n    }\n\n    /**\n     * Assign a matrix\n     * We just change pointers; no actual copying of data takes place\n     * @param {SpeedyMatrix} matrix\n     * @returns {SpeedyPromise<void>} resolves as soon as the assignment is done\n     */\n    _assign(matrix)\n    {\n        this._usermatrix = matrix;\n        return SpeedyPromise.resolve();\n    }\n}\n\n/**\n * Extract a read-write block submatrix from a matrix expression\n */\nclass SpeedyMatrixReadwriteBlockExpr extends SpeedyMatrixLvalueExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} expr originating matrix expression\n     * @param {number} firstRow indexed by 0\n     * @param {number} lastRow\n     * @param {number} firstColumn\n     * @param {number} lastColumn\n     */\n    constructor(expr, firstRow, lastRow, firstColumn, lastColumn)\n    {\n        super(lastRow - firstRow + 1, lastColumn - firstColumn + 1, expr.dtype);\n\n        /** @type {SpeedyMatrixExpr} originating matrix expression */\n        this._expr = expr;\n\n        /** @type {number} index of the top-most row (starts at zero) */\n        this._firstRow = firstRow;\n\n        /** @type {number} index of the last row */\n        this._lastRow = lastRow;\n\n        /** @type {number} index of the left-most column (starts at zero) */\n        this._firstColumn = firstColumn;\n\n        /** @type {number} index of the right-most column */\n        this._lastColumn = lastColumn;\n\n        /** @type {?SpeedyMatrix} the matrix associated with this expression */\n        this._submatrix = null;\n\n        /** @type {?SpeedyMatrix} used for caching */\n        this._cachedMatrix = null;\n\n        /** @type {?MatrixOperation} cached operation */\n        this._operation = null;\n    }\n\n    /**\n     * Get the matrix associated with this lvalue expression\n     * This matrix must be guaranteed to be available after evaluating this expression\n     * @returns {SpeedyMatrix}\n     */\n    get _matrix()\n    {\n        return this._submatrix;\n    }\n\n    /**\n     * Evaluate the expression\n     * @returns {SpeedyPromise<SpeedyMatrixExpr>}\n     */\n    _evaluate()\n    {\n        return this._expr._evaluate().then(result => {\n            if(result._matrix !== this._cachedMatrix || this._submatrix === null) {\n                this._cachedMatrix = result._matrix;\n                return this._cachedMatrix.block(this._firstRow, this._lastRow, this._firstColumn, this._lastColumn);\n            }\n            return this._submatrix; // we've already extracted the submatrix\n        }).then(submatrix => {\n            this._submatrix = submatrix;\n            return this;\n        });\n    }\n\n    /**\n     * Assign a matrix\n     * Since this is a submatrix, we can't just assign pointers.\n     * We need to copy the data\n     * @param {SpeedyMatrix} matrix\n     * @returns {SpeedyPromise<void>} resolves as soon as the assignment is done\n     */\n    _assign(matrix)\n    {\n        return matrixOperationsQueue.enqueue(\n            (\n                this._operation ? this._operation.update([ matrix ]) :\n                (this._operation = new MatrixOperationCopy(matrix))\n            ),\n            this._submatrix\n        );\n    }\n}\n\n/**\n * Extract a read-write diagonal from a matrix expression\n */\nclass SpeedyMatrixReadwriteDiagonalExpr extends SpeedyMatrixLvalueExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} expr originating matrix expression\n     */\n    constructor(expr)\n    {\n        const diagonalLength = Math.min(expr.rows, expr.columns);\n        super(1, diagonalLength, expr.dtype);\n\n        /** @type {SpeedyMatrixExpr} originating matrix expression */\n        this._expr = expr;\n\n        /** @type {?SpeedyMatrix} the matrix associated with this expression */\n        this._diagonal = null;\n\n        /** @type {?SpeedyMatrix} used for caching */\n        this._cachedMatrix = null;\n    }\n\n    /**\n     * Get the matrix associated with this expression\n     * This matrix must be guaranteed to be available after evaluating this expression\n     * @returns {SpeedyMatrix}\n     */\n    get _matrix()\n    {\n        return this._diagonal;\n    }\n\n    /**\n     * Evaluate the expression\n     * @returns {SpeedyPromise<SpeedyMatrixExpr>}\n     */\n    _evaluate()\n    {\n        return this._expr._evaluate().then(result => {\n            if(result._matrix !== this._cachedMatrix || this._diagonal === null) {\n                this._cachedMatrix = result._matrix;\n                return this._cachedMatrix.diagonal();\n            }\n            return this._diagonal; // we've already extracted the diagonal\n        }).then(diagonal => {\n            this._diagonal = diagonal;\n            return this;\n        });\n    }\n\n    /**\n     * Assign a matrix\n     * Since this is a diagonal, we can't just assign pointers.\n     * We need to copy the data\n     * @param {SpeedyMatrix} matrix\n     * @returns {SpeedyPromise<void>} resolves as soon as the assignment is done\n     */\n    _assign(matrix)\n    {\n        return matrixOperationsQueue.enqueue(\n            (\n                this._operation ? this._operation.update([ matrix ]) :\n                (this._operation = new MatrixOperationCopy(matrix))\n            ),\n            this._diagonal\n        );\n    }\n}\n\n\n// ================================================\n// BASIC OPERATIONS\n// ================================================\n\n/**\n * Fill the output matrix with a constant value\n */\nclass SpeedyMatrixFillExpr extends SpeedyMatrixTempExpr\n{\n    /**\n     * Constructor\n     * @param {number} rows number of rows of the resulting (output) matrix\n     * @param {number} columns number of columns of the resulting (output) matrix\n     * @param {MatrixDataType} dtype type of the resulting (output) matrix\n     * @param {number} value will fill the output matrix with this constant value\n     */\n    constructor(rows, columns, dtype, value)\n    {\n        super(rows, columns, dtype);\n\n        /** @type {MatrixOperation} */\n        this._operation = new MatrixOperationFill(rows, columns, dtype, value);\n    }\n\n    /**\n     * Evaluate expression\n     * @returns {SpeedyPromise<SpeedyMatrixExpr>}\n     */\n    _evaluate()\n    {\n        return matrixOperationsQueue.enqueue(\n            this._operation,\n            this._matrix\n        ).then(() => this);\n    }\n}\n\n/**\n * Clone a matrix, copying individual entries\n * e.g., A = B.clone()\n */\nclass SpeedyMatrixCloneExpr extends SpeedyMatrixUnaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} expr\n     */\n    constructor(expr)\n    {\n        super(expr.rows, expr.columns, expr, MatrixOperationCopy);\n    }\n}\n\n/**\n * Tranpose a matrix,\n * e.g., A = A^T\n */\nclass SpeedyMatrixTransposeExpr extends SpeedyMatrixUnaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} expr\n     */\n    constructor(expr)\n    {\n        // optimize if the input expression is a transposition\n        if(expr instanceof SpeedyMatrixTransposeExpr) {\n            // A = (A^T)^T\n            return expr.child;\n        }\n\n        // regular transposition\n        super(expr.columns, expr.rows, expr, MatrixOperationTranspose);\n    }\n}\n\n/**\n * Add two matrix expressions,\n * e.g., A = B + C\n */\nclass SpeedyMatrixAddExpr extends SpeedyMatrixBinaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} leftExpr\n     * @param {SpeedyMatrixExpr} rightExpr\n     */\n    constructor(leftExpr, rightExpr)\n    {\n        super(leftExpr.rows, leftExpr.columns, leftExpr, rightExpr, MatrixOperationAdd);\n        this._assertCompatibility(rightExpr.rows, rightExpr.columns);\n    }\n}\n\n/**\n * Subtract two matrix expressions,\n * e.g., A = B - C\n */\nclass SpeedyMatrixSubtractExpr extends SpeedyMatrixBinaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} leftExpr\n     * @param {SpeedyMatrixExpr} rightExpr\n     */\n    constructor(leftExpr, rightExpr)\n    {\n        super(leftExpr.rows, leftExpr.columns, leftExpr, rightExpr, MatrixOperationSubtract);\n        this._assertCompatibility(rightExpr.rows, rightExpr.columns);\n    }\n}\n\n/**\n * Multiply two matrix expressions,\n * e.g., A = B * C\n */\nclass SpeedyMatrixMultiplyExpr extends SpeedyMatrixBinaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} leftExpr\n     * @param {SpeedyMatrixExpr} rightExpr\n     */\n    constructor(leftExpr, rightExpr)\n    {\n        // optimize if the input expressions are transposed\n        const lt = leftExpr instanceof SpeedyMatrixTransposeExpr;\n        const rt = rightExpr instanceof SpeedyMatrixTransposeExpr;\n        if(lt && rt) {\n            // A = (B^T) (C^T) = (C B)^T\n            return new SpeedyMatrixTransposeExpr(\n                new SpeedyMatrixMultiplyExpr(rightExpr.child, leftExpr.child)\n            );\n        }\n        else if(lt && !rt) {\n            // A = (B^T) C\n            return new SpeedyMatrixMultiplyLTExpr(leftExpr.child, rightExpr);\n        }\n        else if(!lt && rt) {\n            // A = B (C^T)\n            return new SpeedyMatrixMultiplyRTExpr(leftExpr, rightExpr.child);\n        }\n\n        // multiply by a column-vector\n        if(rightExpr.columns === 1)\n            return new SpeedyMatrixMultiplyVecExpr(leftExpr, rightExpr);\n\n        // regular multiplication\n        super(leftExpr.rows, rightExpr.columns, leftExpr, rightExpr, MatrixOperationMultiply);\n        if(leftExpr.columns !== rightExpr.rows)\n            throw new IllegalArgumentError(`Can't multiply a ${leftExpr.rows} x ${leftExpr.columns} matrix by a ${rightExpr.rows} x ${rightExpr.columns} matrix`);\n    }\n}\n\n/**\n * Multiply two matrix expressions, transposing the left operand\n * e.g., A = B^T * C\n */\nclass SpeedyMatrixMultiplyLTExpr extends SpeedyMatrixBinaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} leftExpr\n     * @param {SpeedyMatrixExpr} rightExpr\n     */\n    constructor(leftExpr, rightExpr)\n    {\n        super(leftExpr.columns, rightExpr.columns, leftExpr, rightExpr, MatrixOperationMultiplyLT);\n        if(leftExpr.rows !== rightExpr.rows)\n            throw new IllegalArgumentError(`Can't multiply a ${leftExpr.columns} x ${leftExpr.rows} (transposed) matrix by a ${rightExpr.rows} x ${rightExpr.columns} matrix`);\n    }\n}\n\n/**\n * Multiply two matrix expressions, transposing the right operand\n * e.g., A = B * C^T\n */\nclass SpeedyMatrixMultiplyRTExpr extends SpeedyMatrixBinaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} leftExpr\n     * @param {SpeedyMatrixExpr} rightExpr\n     */\n    constructor(leftExpr, rightExpr)\n    {\n        super(leftExpr.rows, rightExpr.rows, leftExpr, rightExpr, MatrixOperationMultiplyRT);\n        if(leftExpr.columns !== rightExpr.columns)\n            throw new IllegalArgumentError(`Can't multiply a ${leftExpr.rows} x ${leftExpr.columns} matrix by a ${rightExpr.columns} x ${rightExpr.rows} (transposed) matrix`);\n    }\n}\n\n/**\n * Multiply a matrix A by a column-vector x,\n * e.g., y = A x\n */\nclass SpeedyMatrixMultiplyVecExpr extends SpeedyMatrixBinaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} leftExpr\n     * @param {SpeedyMatrixExpr} rightExpr\n     */\n    constructor(leftExpr, rightExpr)\n    {\n        super(leftExpr.rows, rightExpr.columns, leftExpr, rightExpr, MatrixOperationMultiplyVec);\n        if(leftExpr.columns !== rightExpr.rows || rightExpr.columns !== 1)\n            throw new IllegalArgumentError(`Can't multiply a ${leftExpr.rows} x ${leftExpr.columns} matrix by a ${rightExpr.rows} x ${rightExpr.columns} matrix / column-vector`);\n    }\n}\n\n/**\n * Multiply a matrix expression by a number,\n * e.g., A = alpha B\n */\nclass SpeedyMatrixScaleExpr extends SpeedyMatrixUnaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} expr\n     * @param {number} scalar\n     */\n    constructor(expr, scalar)\n    {\n        super(expr.rows, expr.columns, expr, MatrixOperationScale, scalar);\n    }\n}\n\n/**\n * Component-wise multiplication of two matrix expressions\n */\nclass SpeedyMatrixCompMultExpr extends SpeedyMatrixBinaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} leftExpr\n     * @param {SpeedyMatrixExpr} rightExpr\n     */\n    constructor(leftExpr, rightExpr)\n    {\n        super(leftExpr.rows, leftExpr.columns, leftExpr, rightExpr, MatrixOperationCompMult);\n        this._assertCompatibility(rightExpr.rows, rightExpr.columns);\n    }\n}\n\n/**\n * QR decomposition\n */\nclass SpeedyMatrixQRExpr extends SpeedyMatrixUnaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} expr\n     * @param {string} mode 'full' | 'reduced'\n     */\n    constructor(expr, mode)\n    {\n        const columns = mode == 'full' ? expr.columns + expr.rows : 2 * expr.columns;\n        if(expr.rows < expr.columns)\n            throw new IllegalArgumentError(`Can't compute the QR decomposition of a ${expr.rows} x ${expr.columns} matrix`);\n\n        super(expr.rows, columns, expr, MatrixOperationQR, mode);\n    }\n}\n\n\n\n\n\n\n// ==============================================\n// INTERNAL UTILITIES\n// ==============================================\n\n/**\n * Internal QR solver (Ax = b)\n */\nclass SpeedyMatrixQRSolverNodeExpr extends SpeedyMatrixBinaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} matrixA m x n matrix\n     * @param {SpeedyMatrixExpr} vectorB m x 1 vector\n     */\n    constructor(matrixA, vectorB)\n    {\n        if(matrixA.rows < matrixA.columns)\n            throw new IllegalArgumentError(`Can't compute the QR decomposition of a ${matrixA.rows} x ${matrixA.columns} matrix`);\n        else if(vectorB.columns != 1 || vectorB.rows != matrixA.rows)\n            throw new IllegalArgumentError(`Expected a ${matrixA.rows} x 1 column-vector, but found a ${vectorB.rows} x ${vectorB.columns} matrix`);\n\n        super(matrixA.rows, matrixA.columns + 1, matrixA, vectorB, MatrixOperationQRSolve);\n    }\n}\n\n/**\n * Back-substitution algorithm\n * (solve Rx = b for x, R is upper-triangular)\n */\nclass SpeedyMatrixBackSubstitutionNodeExpr extends SpeedyMatrixUnaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} input [b | R] matrix\n     */\n    constructor(input)\n    {\n        if(input.columns != input.rows + 1)\n            throw new IllegalArgumentError(`Expected a ${input.rows} x ${input.rows + 1} matrix, but found a ${input.rows} x ${input.columns} matrix`);\n\n        super(input.rows, 1, input, MatrixOperationBackSubstitution);\n    }\n}\n\n/**\n * Find best-fit solution x of Ax = b with least-squares method\n * A is m x n, b is m x 1, output x is n x 1\n * (m equations, n unknowns, m >= n)\n */\nclass SpeedyMatrixLSSolveNodeExpr extends SpeedyMatrixBinaryExpr\n{\n    constructor(matrixA, vectorB)\n    {\n        const [ m, n ] = [ matrixA.rows, matrixA.columns ];\n\n        if(m < n)\n            throw new IllegalArgumentError(`Input matrix has more columns than rows - it's ${m} x ${n}`);\n        else if(vectorB.rows != m || vectorB.columns != 1)\n            throw new IllegalArgumentError(`Expected a ${m} x 1 column-vector, but found a ${vectorB.rows} x ${vectorB.columns} matrix`);\n\n        super(n, 1, matrixA, vectorB, MatrixOperationLSSolve);\n    }\n}\n\n\n\n\n// ================================================\n// MATRIX FACTORY\n// ================================================\n\n/**\n * A Factory of matrix expressions\n */\nexport class SpeedyMatrixExprFactory extends Function\n{\n    /**\n     * Create a new SpeedyMatrixExpr that evaluates to a user-defined matrix\n     * (or to a matrix without data if its entries are not provided)\n     * @param {number} rows number of rows\n     * @param {number} [columns] number of columns (defaults to the number of rows)\n     * @param {number[]} [values] initial values in column-major format\n     * @param {MatrixDataType} [dtype] data type of the elements of the matrix\n     * @returns {SpeedyMatrixElementaryExpr}\n     */\n    _create(rows, columns = rows, values = null, dtype = MatrixType.default)\n    {\n        let matrix = null;\n\n        if(!MatrixType.isValid(dtype))\n            throw new IllegalArgumentError(`Invalid matrix type: \"${dtype}\"`);\n\n        if(values != null) {\n            if(!Array.isArray(values))\n                throw new IllegalArgumentError(`Can't initialize Matrix with values ${values}`);\n            if(values.length > 0)\n                matrix = new SpeedyMatrix(rows, columns, values, dtype);\n        }\n\n        return new SpeedyMatrixElementaryExpr(rows, columns, dtype, matrix);\n    }\n\n    /**\n     * Create a new matrix filled with zeroes\n     * @param {number} rows number of rows\n     * @param {number} [columns] number of columns (defaults to the number of rows)\n     * @param {number[]} [values] initial values in column-major format\n     * @param {MatrixDataType} [dtype] data type of the elements of the matrix\n     * @returns {SpeedyMatrixElementaryExpr}\n     */\n    Zeros(rows, columns = rows, dtype = MatrixType.default)\n    {\n        const values = (new Array(rows * columns)).fill(0);\n        return this._create(rows, columns, values, dtype);\n    }\n\n    /**\n     * Create a new matrix filled with ones\n     * @param {number} rows number of rows\n     * @param {number} [columns] number of columns (defaults to the number of rows)\n     * @param {number[]} [values] initial values in column-major format\n     * @param {MatrixDataType} [dtype] data type of the elements of the matrix\n     * @returns {SpeedyMatrixElementaryExpr}\n     */\n    Ones(rows, columns = rows, dtype = MatrixType.default)\n    {\n        const values = (new Array(rows * columns)).fill(1);\n        return this._create(rows, columns, values, dtype);\n    }\n\n    /**\n     * Create a new identity matrix\n     * @param {number} rows number of rows\n     * @param {number} [columns] number of columns (defaults to the number of rows)\n     * @param {number[]} [values] initial values in column-major format\n     * @param {MatrixDataType} [dtype] data type of the elements of the matrix\n     * @returns {SpeedyMatrixElementaryExpr}\n     */\n    Eye(rows, columns = rows, dtype = MatrixType.default)\n    {\n        const values = (new Array(rows * columns)).fill(0);\n        for(let j = Math.min(rows, columns) - 1; j >= 0; j--)\n            values[j * rows + j] = 1;\n\n        return this._create(rows, columns, values, dtype);\n    }\n\n    /**\n     * The factory can be invoked as a function\n     * This is an alias to SpeedyMatrixExprFactory._create()\n     */\n    constructor()\n    {\n        super('...args', 'return this._create(...args)');\n        return this.bind(this);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * matrix-operations-queue.js\n * Run matrix operations in a FIFO fashion\n */\n\nimport { SpeedyMatrix } from './matrix';\nimport { MatrixOperation } from './matrix-operations';\nimport { SpeedyPromise } from '../../utils/speedy-promise';\n\n/**\n * Used to run matrix operations in a FIFO fashion\n */\nexport class MatrixOperationsQueue\n{\n    /**\n     * Class constructor\n     */\n    constructor()\n    {\n        this._queue = [];\n        this._busy = false;\n    }\n\n    /**\n     * Get Singleton\n     * @returns {MatrixOperationsQueue}\n     */\n    static get instance()\n    {\n        return this._instance || (this._instance = new MatrixOperationsQueue());\n    }\n\n    /**\n     * Enqueue matrix operation\n     * @param {MatrixOperation} matrixOperation \n     * @param {SpeedyMatrix} outputMatrix\n     * @returns {SpeedyPromise<void>} a promise that resolves as soon as the operation is complete\n     */\n    enqueue(matrixOperation, outputMatrix)\n    {\n        // enqueue operation\n        return new SpeedyPromise(resolve => {\n            this._queue.push([ matrixOperation, outputMatrix, resolve ]);\n            if(!this._busy) {\n                this._busy = true;\n                this._resolveAll();\n            }\n        });\n    }\n\n    /**\n     * Run all enqueued matrix operations\n     */\n    _resolveAll()\n    {\n        // finished the processing?\n        if(this._queue.length == 0) {\n            this._busy = false;\n            return;\n        }\n\n        // obtain the next operation\n        const [ matrixOperation, outputMatrix, resolve ] = this._queue.shift();\n\n        // lock matrices\n        outputMatrix.lock();\n        matrixOperation.inputMatrices.forEach(inputMatrix => inputMatrix.lock());\n\n        // run the next operation\n        matrixOperation.run(outputMatrix).then(() => {\n            // unlock matrices\n            matrixOperation.inputMatrices.forEach(inputMatrix => inputMatrix.unlock());\n            outputMatrix.unlock();\n\n            // this operation is done\n            resolve();\n            this._resolveAll();\n        }).turbocharge();\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * matrix-operations.js\n * Matrix operations\n */\n\nimport { IllegalArgumentError, IllegalOperationError, NotSupportedError } from '../../utils/errors';\nimport { SpeedyPromise } from '../../utils/speedy-promise';\nimport { SpeedyMatrix } from './matrix';\nimport { MatrixWorker } from './matrix-worker';\nimport { LinAlg } from './linalg/linalg';\n\n// Constants\nconst SMALL_WORKLOAD = 40; // what is \"small\"? further experimental testing is desirable\n                           // a binary operation for 3x3 matrices, e.g. C = A + B, has \"small\" workload\n\n// Worker\nconst matrixWorker = MatrixWorker.instance;\n\n\n/**\n * Abstract matrix operation\n * @abstract\n */\nexport class MatrixOperation\n{\n    /**\n     * (protected) Class constructor\n     * @param {string} method method name\n     * @param {number} requiredRows required number of rows of the output matrix\n     * @param {number} requiredColumns required number of columns of the output matrix\n     * @param {MatrixDataType} requiredDataType required type of the output matrix\n     * @param {SpeedyMatrix[]} [inputMatrices] input matrices, if any\n     * @param {?object} [userData] custom user-data, serializable\n     */\n    constructor(method, requiredRows, requiredColumns, requiredDataType, inputMatrices = [], userData = null)\n    {\n        // handy vars\n        const n = inputMatrices.length;\n        const hasInput = n > 0;\n\n        // obtain the shape of the input matrices\n        const rowsOfInputs = hasInput && inputMatrices.map(matrix => matrix.rows);\n        const columnsOfInputs = hasInput && inputMatrices.map(matrix => matrix.columns);\n        const strideOfInputs = hasInput && new Array(n);\n        const byteOffsetOfInputs = hasInput && new Array(n);\n        const lengthOfInputs = hasInput && new Array(n);\n\n        // the header stores metadata related to the operation\n        // (all fields are serializable)\n        this._header = {\n            method: method, // method name\n            dtype: requiredDataType, // type of the output matrix (the same as the input matrices)\n\n            rows: requiredRows, // number of rows of the output matrix\n            columns: requiredColumns, // number of columns of the output matrix\n            stride: null, // stride of the output matrix (unknown)\n            byteOffset: null, // used to recover the data view (unknown)\n            length: null, // used to recover the data view (unknown)\n\n            rowsOfInputs: rowsOfInputs, // number of rows of the input matrices\n            columnsOfInputs: columnsOfInputs, // number of columns of the input matrices\n            strideOfInputs: strideOfInputs, // strides of the input matrices\n            byteOffsetOfInputs: byteOffsetOfInputs, // used to recover the data view (to be determined later - buffer may be locked)\n            lengthOfInputs: lengthOfInputs, // used to recover the data view (to be determined layer - buffer may be locked)\n\n            custom: userData // custom user-data\n        };\n\n        // save the input matrices\n        this._inputMatrices = inputMatrices;\n        this._inputBuffers = new Array(n); // temporary storage\n\n        // compute a measure of (a fraction of) the workload of this operation\n        this._workloadOfInputs = inputMatrices.reduce((w, m) => w + this._workload(m), 0);\n\n        // is it a valid operation?\n        if(!LinAlg.hasOperation(method))\n            throw new IllegalArgumentError(`Invalid method: \"${method}\"`);\n    }\n\n    /**\n     * The required number of rows of the output matrix\n     * @returns {number}\n     */\n    get rows()\n    {\n        return this._header.rows;\n    }\n\n    /**\n     * The required number of columns of the output matrix\n     * @returns {number}\n     */\n    get columns()\n    {\n        return this._header.columns;\n    }\n\n    /**\n     * The required type of the output matrix\n     * @returns {MatrixDataType}\n     */\n    get dtype()\n    {\n        return this._header.dtype;\n    }\n\n    /**\n     * Replace input matrices\n     * @param {SpeedyMatrix[]} inputMatrices \n     * @returns {MatrixOperation} this\n     */\n    update(inputMatrices)\n    {\n        if(this._inputMatrices.length !== inputMatrices.length)\n            throw new IllegalOperationError();\n\n        for(let i = inputMatrices.length - 1; i >= 0; i--) {\n            const inputMatrix = inputMatrices[i];\n            const prevInputMatrix = this._inputMatrices[i];\n\n            // i-th matrix didn't change\n            if(inputMatrix === prevInputMatrix)\n                continue;\n\n            // can't change shape\n            if(inputMatrix.rows !== prevInputMatrix.rows || inputMatrix.columns !== prevInputMatrix.columns || inputMatrix.dtype !== prevInputMatrix.dtype)\n                throw new IllegalOperationError(`Can't change the input matrix shape / type`);\n\n            // update input matrix\n            this._inputMatrices[i] = inputMatrix;\n        }\n\n        return this;\n    }\n\n\n\n\n\n\n    // =======================================================\n\n\n\n\n\n\n    /**\n     * Run the matrix operation in a Web Worker\n     * The internal buffers of the input & the output matrices are assumed to be locked\n     * @param {SpeedyMatrix} outputMatrix\n     * @returns {SpeedyPromise<void>} a promise that resolves to outbuf as soon as the operation is completed\n     */\n    run(outputMatrix)\n    {\n        const { rows, columns, stride, dtype } = outputMatrix;\n        const header = this._header;\n\n        // run locally if the matrices are \"small enough\"\n        const workload = this._workloadOfInputs + this._workload(outputMatrix);\n        if(workload <= SMALL_WORKLOAD) {\n            // there's an overhead for passing data\n            // back and forth to the Web Worker, and\n            // we don't want to pay it if we're\n            // dealing with \"small\" matrices\n            return this._runLocally(outputMatrix);\n        }\n\n        // do we have a compatible output matrix?\n        this._assertCompatibility(rows, columns, dtype);\n\n        // save output metadata\n        const output = outputMatrix.buffer.data;\n        header.stride = stride;\n        header.byteOffset = output.byteOffset;\n        header.length = output.length;\n\n        // save input metadata & buffers\n        const inputMatrices = this._inputMatrices;\n        const inputBuffers = this._inputBuffers; // new Array(inputMatrices.length);\n        for(let i = inputMatrices.length - 1; i >= 0; i--) {\n            const inputMatrix = inputMatrices[i];\n            const input = inputMatrix.buffer.data;\n\n            header.strideOfInputs[i] = inputMatrix.stride;\n            header.byteOffsetOfInputs[i] = input.byteOffset;\n            header.lengthOfInputs[i] = input.length;\n\n            inputBuffers[i] = input.buffer;\n        }\n\n        // crunch numbers in a WebWorker\n        return matrixWorker.run(\n            header,\n            output.buffer,\n            inputBuffers\n        ).then(([newOutputBuffer, newInputBuffers]) => {\n            // update the internal buffers with the new data\n            outputMatrix.buffer.replace(newOutputBuffer);\n            for(let i = inputMatrices.length - 1; i >= 0; i--)\n                inputMatrices[i].buffer.replace(newInputBuffers[i]);\n        });\n    }\n\n    /**\n     * Run matrix operation in the same thread\n     * @param {SpeedyMatrix} outputMatrix\n     * @returns {SpeedyPromise<void>} a promise that resolves to outbuf as soon as the operation is completed\n     */\n    _runLocally(outputMatrix)\n    {\n        // obtain properties of the output matrix\n        const { rows, columns, stride, dtype } = outputMatrix;\n        const header = this._header;\n\n        // do we have a compatible output matrix?\n        this._assertCompatibility(rows, columns, dtype);\n\n        // save output metadata\n        const output = outputMatrix.buffer.data;\n        header.stride = stride;\n        header.byteOffset = output.byteOffset;\n        header.length = output.length;\n\n        // save input metadata & buffers\n        const inputMatrices = this._inputMatrices;\n        const inputs = this._inputBuffers; // new Array(inputMatrices.length);\n        for(let i = inputMatrices.length - 1; i >= 0; i--) {\n            const inputMatrix = inputMatrices[i];\n            const input = inputMatrix.buffer.data;\n\n            header.strideOfInputs[i] = inputMatrix.stride;\n            header.byteOffsetOfInputs[i] = input.byteOffset;\n            header.lengthOfInputs[i] = input.length;\n\n            inputs[i] = input;\n        }\n\n        // crunch numbers locally\n        (LinAlg.lib[header.method])(header, output, inputs);\n        return SpeedyPromise.resolve();\n    }\n\n    /**\n     * The matrices that belong to the operation,\n     * with the exception of the output matrix\n     * @returns {SpeedyMatrix[]}\n     */\n    get inputMatrices()\n    {\n        return this._inputMatrices;\n    }\n\n    /**\n     * Assert matrix size and type\n     * @param {number} requiredRows \n     * @param {number} requiredColumns \n     * @param {MatrixDataType} [requiredDataType]\n     */\n    _assertCompatibility(requiredRows, requiredColumns, requiredDataType = this._header.dtype)\n    {\n        const { rows, columns, dtype } = this._header;\n\n        if(requiredRows === rows && requiredColumns === columns && requiredDataType === dtype)\n            return;\n        else if(requiredDataType !== dtype)\n            throw new IllegalOperationError(`Incompatible matrix type: \"${requiredDataType}\" vs \"${dtype}\"`);\n        else\n            throw new IllegalOperationError(`Invalid matrix size: ${rows} x ${columns} (expected ${requiredRows} x ${requiredColumns})`);\n    }\n\n    /**\n     * Compute a measure of the workload of an operation involving this matrix\n     * @param {SpeedyMatrix} matrix\n     * @returns {number}\n     */\n    _workload(matrix)\n    {\n        return matrix.rows * matrix.columns;\n    }\n}\n\n/**\n * No-operation\n */\nexport class MatrixOperationNop extends MatrixOperation\n{\n    /**\n     * Class constructor\n     * @param {number} requiredRows required number of rows of the output matrix\n     * @param {number} requiredColumns required number of columns of the output matrix\n     * @param {MatrixDataType} requiredDataType required type of the output matrix\n     */\n    constructor(requiredRows, requiredColumns, requiredDataType)\n    {\n        super('nop', requiredRows, requiredColumns, requiredDataType);\n    }\n}\n\n/**\n * Fill matrix with a number\n */\nexport class MatrixOperationFill extends MatrixOperation\n{\n    /**\n     * Class constructor\n     * @param {number} requiredRows required number of rows of the output matrix\n     * @param {number} requiredColumns required number of columns of the output matrix\n     * @param {MatrixDataType} requiredDataType required type of the output matrix\n     * @param {number} value the value we'll use to fill the matrix\n     */\n    constructor(requiredRows, requiredColumns, requiredDataType, value)\n    {\n        super('fill', requiredRows, requiredColumns, requiredDataType, [], { value: +value });\n    }\n}\n\n/**\n * Copy matrix\n */\nexport class MatrixOperationCopy extends MatrixOperation\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrix} matrix \n     */\n    constructor(matrix)\n    {\n        super('copy', matrix.rows, matrix.columns, matrix.dtype, [ matrix ]);\n    }\n}\n\n/**\n * Transpose Matrix\n */\nexport class MatrixOperationTranspose extends MatrixOperation\n{\n    /**\n     * Class constructor\n     * @param {SpeedyMatrix} matrix the matrix that we'll transpose\n     */\n    constructor(matrix)\n    {\n        super('transpose', matrix.columns, matrix.rows, matrix.dtype, [ matrix ]);\n    }\n}\n\n/**\n * Add two matrices\n * e.g., A + B\n */\nexport class MatrixOperationAdd extends MatrixOperation\n{\n    /**\n     * Class constructor\n     * @param {SpeedyMatrix} matrixA\n     * @param {SpeedyMatrix} matrixB\n     */\n    constructor(matrixA, matrixB)\n    {\n        super('add', matrixA.rows, matrixA.columns, matrixA.dtype, [ matrixA, matrixB ]);\n    }\n}\n\n/**\n * Subtract two matrices\n * e.g., A - B\n */\nexport class MatrixOperationSubtract extends MatrixOperation\n{\n    /**\n     * Class constructor\n     * @param {SpeedyMatrix} matrixA\n     * @param {SpeedyMatrix} matrixB\n     */\n    constructor(matrixA, matrixB)\n    {\n        super('subtract', matrixA.rows, matrixA.columns, matrixA.dtype, [ matrixA, matrixB ]);\n    }\n}\n\n/**\n * Multiply two matrices\n * e.g., A * B\n */\nexport class MatrixOperationMultiply extends MatrixOperation\n{\n    /**\n     * Class constructor\n     * @param {SpeedyMatrix} matrixA left matrix\n     * @param {SpeedyMatrix} matrixB right matrix\n     */\n    constructor(matrixA, matrixB)\n    {\n        super('multiply', matrixA.rows, matrixB.columns, matrixA.dtype, [ matrixA, matrixB ]);\n    }\n}\n\n/**\n * Multiply by a scalar\n * e.g., alpha * A\n */\nexport class MatrixOperationScale extends MatrixOperation\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrix} matrix\n     * @param {number} scalar\n     */\n    constructor(matrix, scalar)\n    {\n        super('scale', matrix.rows, matrix.columns, matrix.dtype, [ matrix ], { scalar: +scalar });\n    }\n}\n\n/**\n * Component-wise multiplication\n */\nexport class MatrixOperationCompMult extends MatrixOperation\n{\n    /**\n     * Class constructor\n     * @param {SpeedyMatrix} matrixA\n     * @param {SpeedyMatrix} matrixB\n     */\n    constructor(matrixA, matrixB)\n    {\n        super('compmult', matrixA.rows, matrixA.columns, matrixA.dtype, [ matrixA, matrixB ]);\n    }\n}\n\n/**\n * Multiply two matrices, transposing the left operand\n * e.g., A^T * B\n */\nexport class MatrixOperationMultiplyLT extends MatrixOperation\n{\n    /**\n     * Class constructor\n     * @param {SpeedyMatrix} matrixA left matrix\n     * @param {SpeedyMatrix} matrixB right matrix\n     */\n    constructor(matrixA, matrixB)\n    {\n        super('multiplylt', matrixA.columns, matrixB.columns, matrixA.dtype, [ matrixA, matrixB ]);\n    }\n}\n\n/**\n * Multiply two matrices, transposing the right operand\n * e.g., A * B^T\n */\nexport class MatrixOperationMultiplyRT extends MatrixOperation\n{\n    /**\n     * Class constructor\n     * @param {SpeedyMatrix} matrixA left matrix\n     * @param {SpeedyMatrix} matrixB right matrix\n     */\n    constructor(matrixA, matrixB)\n    {\n        super('multiplyrt', matrixA.rows, matrixB.rows, matrixA.dtype, [ matrixA, matrixB ]);\n    }\n}\n\n/**\n * Multiply by a column vector,\n * e.g., y = A x\n */\nexport class MatrixOperationMultiplyVec extends MatrixOperation\n{\n    /**\n     * Class constructor\n     * @param {SpeedyMatrix} matrixA left matrix\n     * @param {SpeedyMatrix} vectorX column-vector\n     */\n    constructor(matrixA, vectorX)\n    {\n        super('multiplyvec', matrixA.rows, 1, matrixA.dtype, [ matrixA, vectorX ]);\n    }\n}\n\n/**\n * QR decomposition\n */\nexport class MatrixOperationQR extends MatrixOperation\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrix} matrix\n     * @param {string} mode 'full' | 'reduced'\n     */\n    constructor(matrix, mode)\n    {\n        const m = ({ 'full': 'full-qr', 'reduced': 'reduced-qr' })[mode];\n        if(m === undefined)\n            throw new IllegalArgumentError(`QR decomposition: unknown mode \"${mode}\"`)\n\n        const columns = m == 'full-qr' ? matrix.columns + matrix.rows : 2 * matrix.columns;\n        super('qr', matrix.rows, columns, matrix.dtype, [ matrix ], { mode: m });\n    }\n}\n\n/**\n * Internal QR solver (Ax = b) produces\n * the matrix [(Q^T)b | R] using reduced QR(*)\n * A is m x n (m >= n), b is m x 1,\n * (Q^T)b is m x 1 and R is m x n\n *\n * (*) The last (m-n) rows of the output matrix\n * will be filled with zeros. Those rows are\n * required by the calculation. You may extract\n * the first n rows\n */\nexport class MatrixOperationQRSolve extends MatrixOperation\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrix} matrixA\n     * @param {SpeedyMatrix} vectorB\n     */\n    constructor(matrixA, vectorB)\n    {\n        super('qr', matrixA.rows, matrixA.columns + 1, matrixA.dtype, [ matrixA, vectorB ], { mode: 'reduced-Q\\'x' });\n    }\n}\n\n/**\n * Given an input matrix of the form [b | R]\n * where b is n x 1 and R is an n x n upper\n * triangular matrix, solve Rx = b for x\n */\nexport class MatrixOperationBackSubstitution extends MatrixOperation\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrix} input\n     */\n    constructor(input)\n    {\n        super('backsub', input.rows, 1, input.dtype, [ input ]);\n    }\n}\n\n/**\n * Find best-fit solution x of Ax = b with least-squares method\n * A is m x n, b is m x 1, output x is n x 1\n * (m equations, n unknowns, m >= n)\n */\nexport class MatrixOperationLSSolve extends MatrixOperation\n{\n    constructor(matrixA, vectorB)\n    {\n        super('lssolve', matrixA.columns, 1, matrixA.dtype, [ matrixA, vectorB ]);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * matrix-type.js\n * Data types of matrices\n */\n\n//! No imports here\n//! MatrixType is exported to a WebWorker\n\n/**\n * Types of matrices: utilities\n * \n * Matrices store data of a certain type\n * (e.g., 'float32', 'float64', etc.)\n * \n * @typedef {string} MatrixDataType\n */\nclass MatrixType\n{\n    /**\n     * Is the specified matrix data type valid?\n     * @param {MatrixDataType} dtype data type\n     * @returns {boolean}\n     */\n    static isValid(dtype)\n    {\n        return Object.prototype.hasOwnProperty.call(this._classOf, dtype);\n    }\n\n    /**\n     * Create a TypedArray of the specified type\n     * @param {MatrixDataType} dtype data type\n     * @param {any[]} args will be passed to the constructor of the TypedArray\n     * @returns {ArrayBufferView}\n     */\n    static createTypedArray(dtype, ...args)\n    {\n        if(!this.isValid(dtype))\n            throw new Error(`Invalid matrix type: \"${dtype}\"`);\n\n        return Reflect.construct(this._classOf[dtype], args);\n    }\n\n    /**\n     * Default data type for matrices\n     * @returns {MatrixDataType}\n     */\n    static get default()\n    {\n        return 'float32';\n    }\n\n    /**\n     * A mapping between MatrixDataType and\n     * corresponding TypedArray constructors\n     * @returns {object}\n     */\n    static get _classOf()\n    {\n        return this._dataType || (this._dataType = Object.freeze({\n\n            /** 32-bit float */\n            'float32': Float32Array,\n\n            /** 64-bit float */\n            'float64': Float64Array,\n\n            /** 32-bit signed integer */\n            'int32': Int32Array,\n\n            /** 8-bit unsigned integer */\n            'uint8': Uint8Array,\n\n        }));\n    }\n}\n\nmodule.exports = { MatrixType };","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * matrix-worker.js\n * Web Worker bridge\n */\n\nimport { LinAlg } from './linalg/linalg';\nimport { IllegalOperationError } from '../../utils/errors';\nimport { SpeedyPromise } from '../../utils/speedy-promise';\n\n// Constants\nconst MAX_MESSAGE_ID = (1 << 30) - 1; // use the form 2^n - 1\nconst NOP = 'nop'; // no operation\n\n/**\n * A bridge between the main thread and a Web Worker\n * that performs matrix computations\n */\nexport class MatrixWorker\n{\n    /**\n     * Get Singleton\n     * @returns {MatrixWorker}\n     */\n    static get instance()\n    {\n        return this._instance || (this._instance = new MatrixWorker());\n    }\n\n    /**\n     * Class constructor\n     */\n    constructor()\n    {\n        this._msgId = 0;\n        this._callbackTable = new Map();\n        this._worker = this._createWorker();\n    }\n\n    /**\n     * Run computation in a Web Worker\n     * @param {object} header serializable\n     * @param {ArrayBuffer} outputBuffer data of the output matrix\n     * @param {ArrayBuffer[]} inputBuffers data of the input matrices\n     * @returns {SpeedyPromise<Array>} resolves as soon as the computation is complete\n     */\n    run(header, outputBuffer, inputBuffers)\n    {\n        if(header.method === NOP) // save some time\n            return SpeedyPromise.resolve([outputBuffer, inputBuffers]);\n\n        const id = (this._msgId = (this._msgId + 1) & MAX_MESSAGE_ID);\n        const transferables = [ outputBuffer, ...inputBuffers ].filter(\n            (x, i, arr) => arr.indexOf(x) === i // remove duplicates\n        );\n        const msg = { id, header, outputBuffer, inputBuffers, transferables };\n\n        return new SpeedyPromise(resolve => {\n            this._callbackTable.set(id, (outputBuffer, inputBuffers) => {\n                resolve([outputBuffer, inputBuffers]);\n                this._callbackTable.delete(id);\n            });\n            this._worker.postMessage(msg, transferables);\n        }, true);\n    }\n\n    /**\n     * Create a Web Worker capable of performing Matrix computations\n     * @returns {Worker}\n     */\n    _createWorker()\n    {\n        // setup the code\n        const js = 'self.LinAlg = ' + LinAlg.toString() + ';\\n' +\n                   'self.onmessage = ' + onmessage.toString() + ';';\n        const blob = new Blob([ js ], { type: 'application/javascript' });\n        //console.log(js);\n\n        // setup the Worker\n        const worker = new Worker(URL.createObjectURL(blob));\n        worker.onmessage = ev => {\n            const msg = ev.data;\n            const done = this._callbackTable.get(msg.id);\n            done(msg.outputBuffer, msg.inputBuffers);\n        };\n        worker.onerror = ev => {\n            throw new IllegalOperationError(`Worker error: ${ev.message}`);\n        };\n\n        // done!\n        return worker;\n    }\n}\n\n/**\n * This function runs in the Web Worker\n * @param {MessageEvent} ev\n */\nfunction onmessage(ev)\n{\n    const { id, header, outputBuffer, inputBuffers, transferables } = ev.data;\n    const LinAlg = self.LinAlg;\n\n    // wrap the incoming buffers with the appropriate TypedArrays\n    const output = LinAlg.lib.createTypedArray(header.dtype, outputBuffer, header.byteOffset, header.length);\n    const inputs = inputBuffers.map((inputBuffer, i) =>\n        LinAlg.lib.createTypedArray(header.dtype, inputBuffer, header.byteOffsetOfInputs[i], header.lengthOfInputs[i])\n    );\n\n    // perform the computation\n    (LinAlg.lib[header.method])(header, output, inputs);\n\n    // send the result of the computation back to the main thread\n    const msg = { id, outputBuffer, inputBuffers };\n    self.postMessage(msg, transferables);\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * matrix.js\n * Matrix type\n */\n\nimport { IllegalArgumentError, IllegalOperationError, NotSupportedError } from '../../utils/errors';\nimport { MatrixType } from './matrix-type';\nimport { MatrixBuffer } from './matrix-buffer';\nimport { MatrixOperationsQueue } from './matrix-operations-queue';\nimport { MatrixOperationNop } from './matrix-operations';\nimport { SpeedyPromise } from '../../utils/speedy-promise';\n\n\n\n// Constants\nconst matrixOperationsQueue = MatrixOperationsQueue.instance;\n\n\n\n/**\n * Matrix class\n */\nexport class SpeedyMatrix\n{\n    /**\n     * Class constructor\n     * @param {number} rows number of rows\n     * @param {number} [columns] number of columns (defaults to the number of rows)\n     * @param {number[]} [values] initial values in column-major format\n     * @param {MatrixDataType} [dtype] data type: the type of the elements of the matrix\n     * @param {number} [stride] custom stride\n     * @param {MatrixBuffer} [buffer] custom buffer\n     */\n    constructor(rows, columns = rows, values = null, dtype = MatrixType.default, stride = rows, buffer = null)\n    {\n        if(rows <= 0 || columns <= 0)\n            throw new IllegalArgumentError(`Invalid dimensions`);\n        else if(stride < rows)\n            throw new IllegalArgumentError(`Invalid stride`);\n        else if(!MatrixType.isValid(dtype))\n            throw new IllegalArgumentError(`Invalid data type: \"${dtype}\"`);\n        else if(Array.isArray(values) && values.length != rows * columns)\n            throw new IllegalArgumentError(`Incorrect number of matrix elements (expected ${rows * columns}, found ${values.length})`);\n\n        this._rows = rows | 0;\n        this._columns = columns | 0;\n        this._stride = stride | 0;\n        this._dtype = dtype;\n        this._buffer = buffer || new MatrixBuffer(this._stride * this._columns, values, this._dtype);\n        this._nop = null;\n    }\n\n\n\n    // ====================================\n    // MATRIX PROPERTIES\n    // ====================================\n\n    /**\n     * Number of rows of the matrix\n     * @returns {number}\n     */\n    get rows()\n    {\n        return this._rows;\n    }\n\n    /**\n     * Number of columns of the matrix\n     * @returns {number}\n     */\n    get columns()\n    {\n        return this._columns;\n    }\n\n    /**\n     * The number of entries, in the MatrixBuffer,\n     * between the beginning of two columns\n     * @returns {number}\n     */\n    get stride()\n    {\n        return this._stride;\n    }\n\n    /**\n     * Data type (string)\n     * @returns {MatrixDataType}\n     */\n    get dtype()\n    {\n        return this._dtype;\n    }\n\n\n\n    // ====================================\n    // READ MATRIX\n    // ====================================\n\n    /**\n     * Read entries of the matrix. Note that this method is asynchronous.\n     * It will read the data as soon as all relevant calculations have been\n     * completed. Make sure you await.\n     *\n     * If the entries parameter is left unspecified, the entire matrix will\n     * be read and its contents will be returned as a flattened array in\n     * column-major format.\n     *\n     * @param {number[]} [entries] a flattened array of (row,col) indices, indexed by zero\n     * @param {number[]} [result] pre-allocated array where we'll store the results\n     * @returns {SpeedyPromise<number[]>} a promise that resolves to the requested entries\n     */\n    read(entries = undefined, result = undefined)\n    {\n        const rows = this._rows, cols = this._columns;\n        const stride = this._stride;\n\n        // read the entire array\n        if(entries === undefined)\n        {\n            return this.sync().then(() => this._buffer.ready().turbocharge()).then(buffer => {\n                const data = buffer.data;\n                const n = rows * cols;\n\n                // resize result array\n                result = result || new Array(n);\n                if(result.length != n)\n                    result.length = n;\n\n                // write entries in column-major format\n                let i, j, k = 0;\n                for(j = 0; j < cols; j++) {\n                    for(i = 0; i < rows; i++)\n                        result[k++] = data[j * stride + i];\n                }\n\n                // done!\n                return result;\n            }).turbocharge();\n        }\n\n        // read specific entries\n        if(entries.length % 2 > 0)\n            throw new IllegalArgumentError(`Can't read matrix entries: missing index`);\n\n        return this.sync().then(() => this._buffer.ready().turbocharge()).then(buffer => {\n            const data = buffer.data;\n            const n = entries.length >> 1;\n\n            // resize result array\n            result = result || new Array(n);\n            if(result.length != n)\n                result.length = n;\n\n            // read entries\n            let row, col;\n            for(let i = 0; i < n; i++) {\n                row = entries[i << 1] | 0;\n                col = entries[1 + (i << 1)] | 0;\n                result[i] = ((row >= 0 && row < rows && col >= 0 && col < cols) &&\n                    data[col * stride + row]\n                ) || undefined;\n            }\n\n            // done!\n            return result;\n        }).turbocharge();\n    }\n\n    /**\n     * Read a single entry of the matrix. This is provided for your convenience.\n     * It's much faster to use read() if you need to read multiple entries\n     * @param {number} row the row you want to read, indexed by zero\n     * @param {number} column the column you want to read, indexed by zero\n     * @returns {SpeedyPromise<number>} a promise that resolves to the requested entry\n     */\n    at(row, column)\n    {\n        return this.read([ row, column ]).then(nums => nums[0]).turbocharge();\n    }\n\n    /**\n     * Print the matrix. Useful for debugging\n     * @param {number} [decimals] format numbers to a number of decimals\n     * @param {Function} [printFunction] prints a string\n     * @returns {SpeedyPromise<void>} a promise that resolves as soon as the matrix is printed\n     */\n    print(decimals = undefined, printFunction = console.log)\n    {\n        return this.read().then(data => {\n            const rows = this.rows, columns = this.columns;\n            const row = new Array(rows);\n            let i, j;\n\n            for(i = 0; i < rows; i++) {\n                row[i] = new Array(columns);\n                for(j = 0; j < columns; j++)\n                    row[i][j] = data[j * rows + i];\n            }\n\n            const fix = decimals !== undefined ? x => x.toFixed(decimals) : x => x;\n            const fmt = row.map(r => '    ' + r.map(fix).join(', ')).join(',\\n');\n            const str = `SpeedyMatrix(rows=${rows}, cols=${columns}, dtype=\"${this.dtype}\", data=[\\n${fmt}\\n])`;\n            printFunction(str);\n        });\n    }\n\n\n\n\n\n    // ====================================\n    // ACCESS BY BLOCK\n    // ====================================\n\n    /**\n     * Create a submatrix using the range [firstRow:lastRow, firstColumn:lastColumn].\n     * It will have size (lastRow - firstRow + 1) x (lastColumn - firstColumn + 1).\n     * The internal buffer of the matrix will be shared with the submatrix,\n     * so if you modify one, you'll modify the other.\n     * @param {number} firstRow indexed by 0\n     * @param {number} lastRow indexed by 0\n     * @param {number} firstColumn indexed by 0\n     * @param {number} lastColumn indexed by 0\n     * @returns {SpeedyPromise<SpeedyMatrix>}\n     */\n    block(firstRow, lastRow, firstColumn, lastColumn)\n    {\n        const rows = this._rows, columns = this._columns;\n\n        // validate range\n        if(lastRow < firstRow || lastColumn < firstColumn)\n            throw new IllegalArgumentError(`Can't create empty submatrix - invalid range [${firstRow}:${lastRow}, ${firstColumn}:${lastColumn}]`);\n        else if(firstRow < 0 || lastRow >= rows || firstColumn < 0 || lastColumn >= columns)\n            throw new IllegalArgumentError(`Can't create submatrix - invalid range [${firstRow}:${lastRow}, ${firstColumn}:${lastColumn}] of ${rows} x ${columns} matrix`);\n\n        // compute the dimensions of the new submatrix\n        const subRows = lastRow - firstRow + 1;\n        const subColumns = lastColumn - firstColumn + 1;\n\n        // obtain the relevant portion of the data\n        const stride = this._stride;\n        const begin = firstColumn * stride + firstRow;\n        const length = (lastColumn - firstColumn) * stride + subRows;\n\n        // create submatrix\n        return this._buffer.createSharedBuffer(begin, length).then(sharedBuffer =>\n            new SpeedyMatrix(subRows, subColumns, undefined, this._dtype, stride, sharedBuffer)\n        ).turbocharge();\n    }\n\n    /**\n     * Creates a column-vector featuring the elements of the main diagonal\n     * of the matrix. The internal buffers of the column-vector and of the\n     * matrix are shared, so if you change the data in one, you'll change\n     * the data in the other.\n     * @returns {SpeedyPromise<SpeedyMatrix>}\n     */\n    diagonal()\n    {\n        const rows = this._rows, stride = this._stride;\n        const diagonalLength = Math.min(rows, this._columns);\n        const bufferLength = (diagonalLength - 1) * stride + rows;\n\n        return this._buffer.createSharedBuffer(0, bufferLength).then(sharedBuffer =>\n            new SpeedyMatrix(1, diagonalLength, undefined, this._dtype, stride + 1, sharedBuffer)\n        ).turbocharge();\n    }\n\n\n\n\n\n    // ====================================\n    // MATRIX UTILITIES\n    // ====================================\n\n    /**\n     * Convert to string\n     * @returns {string}\n     */\n    toString()\n    {\n        return `SpeedyMatrix(rows=${this.rows}, cols=${this.columns}, dtype=\"${this.dtype}\")`;\n    }\n\n    /**\n     * Locks the internal buffer of this matrix,\n     * so it can't be read from nor written to\n     */\n    lock()\n    {\n        this._buffer.lock();\n    }\n\n    /**\n     * Unlocks the internal buffer of this matrix and\n     * resolves all pending read/write operations\n     */\n    unlock()\n    {\n        this._buffer.unlock();\n    }\n\n    /**\n     * The internal buffer of this matrix\n     * @returns {MatrixBuffer}\n     */\n    get buffer()\n    {\n        return this._buffer;\n    }\n\n    /**\n     * Returns a promise that resolves as soon as all\n     * operations submitted UP TO NOW have finished\n     * @returns {SpeedyPromise<void>}\n     */\n    sync()\n    {\n        this._nop = this._nop || (this._nop = new MatrixOperationNop(this._rows, this._columns, this._dtype));\n        return matrixOperationsQueue.enqueue(this._nop, this);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-vector.js\n * Vectors\n */\n\nimport { IllegalArgumentError } from '../../utils/errors';\n\n/**\n * 2D vector of floating-point numbers\n */\nexport class SpeedyVector2\n{\n    /**\n     * Create a 2D vector\n     * @param {number} x\n     * @param {number} y\n     */\n    constructor(x, y)\n    {\n        this._data = new Float32Array([x, y]);\n    }\n\n\n    //\n    // ===== PROPERTIES =====\n    //\n\n    /**\n     * Get x-coordinate\n     * @returns {number}\n     */\n    get x()\n    {\n        return this._data[0];\n    }\n\n    /**\n     * Set x-coordinate\n     * @param {number} value\n     */\n    set x(value)\n    {\n        this._data[0] = value;\n    }\n\n    /**\n     * Get y-coordinate\n     * @returns {number}\n     */\n    get y()\n    {\n        return this._data[1];\n    }\n\n    /**\n     * Set y-coordinate\n     * @param {number} value\n     */\n    set y(value)\n    {\n        this._data[1] = value;\n    }\n\n\n\n\n    //\n    // ===== METHODS =====\n    //\n\n    /**\n     * Convert to string\n     * @returns {string}\n     */\n    toString()\n    {\n        return `SpeedyVector2(${this._data[0].toFixed(5)}, ${this._data[1].toFixed(5)})`;\n    }\n\n    /**\n     * Get vector coordinate\n     * @param {number} row 0 or 1\n     * @returns {number}\n     */\n    at(row)\n    {\n        return this._data[row];\n    }\n\n    /**\n     * Dot product between this vector and another vector\n     * @param {SpeedyVector2} v another vector\n     * @returns {number}\n     */\n    dot(v)\n    {\n        return this._data[0] * v._data[0] + this._data[1] * v._data[1];\n    }\n\n    /**\n     * The distance between this vector and another vector\n     * @param {SpeedyVector2} v another vector\n     * @returns {number}\n     */\n    distanceTo(v)\n    {\n        const dx = this._data[0] - v._data[0];\n        const dy = this._data[1] - v._data[1];\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    /**\n     * Euclidean norm\n     * @returns {number}\n     */\n    length()\n    {\n        return Math.sqrt(this._data[0] * this._data[0] + this._data[1] * this._data[1]);\n    }\n\n    /**\n     * Normalizes this vector\n     * @returns {SpeedyVector2} this vector, normalized\n     */\n    normalize()\n    {\n        const l = this.length();\n\n        if(l == 0.0) {\n            this._data.fill(0.0);\n            return this;\n        }\n\n        this._data[0] /= l;\n        this._data[1] /= l;\n\n        return this;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * pipeline-operations.js\n * A pipeline operation is an element of a SpeedyPipeline\n */\n\nimport { ColorFormat } from '../utils/types';\nimport { Utils } from '../utils/utils';\nimport { GLUtils } from '../gpu/gl-utils';\nimport { NotSupportedError, IllegalArgumentError } from '../utils/errors';\n\nexport const PipelineOperation = { };\n\n/**\n * Abstract basic operation\n */\n/* abstract */ class SpeedyPipelineOperation\n{\n    /**\n     * Class constructor\n     */\n    constructor()\n    {\n        // lambda: load options object\n        this._loadOptions = () => ({});\n    }\n\n    /**\n     * Runs the pipeline operation\n     * @param {SpeedyTexture} texture\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyMedia} [media]\n     * @returns {SpeedyTexture}\n     */\n    run(texture, gpu, media)\n    {\n        return texture;\n    }\n\n    /**\n     * Perform any necessary cleanup\n     */\n    release()\n    {\n    }\n\n    /**\n     * Save an options object\n     * @param {object|()=>object} options user-passed parameter\n     * @param {object} [defaultOptions]\n     * @returns {()=>object}\n     */\n    _saveOptions(options, defaultOptions = {})\n    {\n        if(typeof options == 'object') {\n            // evaluate when instantiating the pipeline\n            const storedOptions = Object.assign(defaultOptions, options);\n            this._loadOptions = () => storedOptions;\n        }\n        else if(typeof options == 'function') {\n            // evaluate when running the pipeline\n            this._loadOptions = () => Object.assign(defaultOptions, options());\n        }\n        else\n            throw new IllegalArgumentError(`Expected an options object | function`);\n    }\n}\n\n\n// =====================================================\n//               COLOR CONVERSIONS\n// =====================================================\n\n/**\n * Convert to greyscale\n */\nPipelineOperation.ConvertToGreyscale = class extends SpeedyPipelineOperation\n{\n    run(texture, gpu, media)\n    {\n        if(media._colorFormat == ColorFormat.RGB)\n            texture = gpu.programs.colors.rgb2grey(texture);\n        else if(media._colorFormat != ColorFormat.Greyscale)\n            throw new NotSupportedError(`Can't convert image to greyscale: unknown color format`);\n\n        media._colorFormat = ColorFormat.Greyscale;\n        return texture;\n    }\n}\n\n\n\n// =====================================================\n//               IMAGE FILTERS\n// =====================================================\n\n/**\n * Blur image\n */\nPipelineOperation.Blur = class extends SpeedyPipelineOperation\n{\n    /**\n     * Blur operation\n     * @param {object|()=>object} [options]\n     */\n    constructor(options = {})\n    {\n        super();\n\n        // save options\n        this._saveOptions(options, {\n            filter: 'gaussian', // \"gassuian\" | \"box\"\n            size: 5             // 3 | 5 | 7\n        });\n    }\n\n    run(texture, gpu, media)\n    {\n        const { filter, size } = this._loadOptions();\n\n        // validate options\n        if(filter != 'gaussian' && filter != 'box')\n            throw new IllegalArgumentError(`Invalid filter: \"${filter}\"`);\n        else if(size != 3 && size != 5 && size != 7)\n            throw new IllegalArgumentError(`Invalid kernel size: ${size}`);\n        \n        // run filter\n        let fname = filter == 'gaussian' ? 'gauss' : 'box';\n        return gpu.programs.filters[fname + size](texture);\n    }\n}\n\n/**\n * Image convolution\n */\nPipelineOperation.Convolve = class extends SpeedyPipelineOperation\n{\n    /**\n     * Perform a convolution\n     * Must provide a SQUARE kernel with size: 3x3, 5x5 or 7x7\n     * @param {Array<number>} kernel convolution kernel\n     * @param {number} [divisor] divide all kernel entries by this number\n     */\n    constructor(kernel, divisor = 1.0)\n    {\n        let kern = new Float32Array(kernel).map(x => x / divisor);\n        const len = kern.length;\n        const size = Math.sqrt(len) | 0;\n        const method = ({\n            3: ['createKernel3x3', 'texConv2D3'],\n            5: ['createKernel5x5', 'texConv2D5'],\n            7: ['createKernel7x7', 'texConv2D7'],\n        })[size] || null;\n        super();\n\n        // validate kernel\n        if(len == 1)\n            throw new IllegalArgumentError(`Cannot convolve with a kernel containing a single element`);\n        else if(size * size != len || !method)\n            throw new IllegalArgumentError(`Cannot convolve with a non-square kernel of ${len} elements`);\n\n        // normalize kernel entries to [0,1]\n        const min = Math.min(...kern), max = Math.max(...kern);\n        const offset = min;\n        const scale = Math.abs(max - min) > 1e-5 ? max - min : 1;\n        kern = kern.map(x => (x - offset) / scale);\n\n        // store the normalized kernel\n        this._method = method;\n        this._scale = scale;\n        this._offset = offset;\n        this._kernel = kern;\n        this._kernelSize = size;\n        this._texKernel = null;\n        this._gl = null;\n    }\n\n    run(texture, gpu, media)\n    {\n        // lost context?\n        if(gpu.gl.isContextLost()) {\n            this._texKernel = null;\n            this._gl = null;\n            // convolve with a null texKernel anyway,\n            // SpeedyProgram handles lost contexts\n        }\n\n        // instantiate the texture kernel\n        else if(this._texKernel == null || (this._gl !== gpu.gl && this._gl !== null)) {\n            // warn about performance\n            if(this._gl !== gpu.gl && this._gl !== null && !this._gl.isContextLost()) {\n                const warn = 'Performance warning: need to recreate the texture kernel. ' +\n                             'Consider duplicating the pipeline when using convolutions ' +\n                             'for different media objects.';\n                Utils.warning(warn);\n\n                // release old texture\n                this._texKernel.release();\n            }\n\n            this._texKernel = gpu.programs.filters[this._method[0]](this._kernel);\n            this._gl = gpu.gl;\n        }\n\n        // convolve\n        return gpu.programs.filters[this._method[1]](\n            texture,\n            this._texKernel,\n            this._scale,\n            this._offset\n        );\n    }\n\n    release()\n    {\n        if(this._texKernel != null) {\n            this._texKernel.release();\n            this._texKernel = this._gl = null;\n        }\n\n        super.release();\n    }\n}\n\n/**\n * Normalize image\n */\nPipelineOperation.Normalize = class extends SpeedyPipelineOperation\n{\n    /**\n     * Normalize operation\n     * @param {object|()=>object} [options]\n     */\n    constructor(options = {})\n    {\n        super();\n\n        // save options\n        this._saveOptions(options, {\n            min: undefined, // min. desired pixel intensity, a value in [0,255]\n            max: undefined  // max. desired pixel intensity, a value in [0,255]\n        });\n    }\n\n    run(texture, gpu, media)\n    {\n        const { min, max } = this._loadOptions();\n\n        if(media._colorFormat == ColorFormat.RGB)\n            return gpu.programs.enhancements.normalizeColoredImage(texture, min, max);\n        else if(media._colorFormat == ColorFormat.Greyscale)\n            return gpu.programs.enhancements.normalizeGreyscaleImage(texture, min, max);\n        else\n            throw new NotSupportedError('Invalid color format');\n    }\n}\n\n/**\n * Nightvision: \"see in the dark\"\n */\nPipelineOperation.Nightvision = class extends SpeedyPipelineOperation\n{\n    /**\n     * Class constructor\n     * @param {object|()=>object} [options]\n     */\n    constructor(options = {})\n    {\n        super();\n\n        // save options\n        this._saveOptions(options, {\n            gain: undefined,    // controls the contrast\n            offset: undefined,  // controls the brightness\n            decay: undefined,   // gain decay from the center\n            quality: undefined, // \"high\" | \"medium\" | \"low\"\n        });\n    }\n\n    run(texture, gpu, media)\n    {\n        const { gain, offset, decay, quality } = this._loadOptions();\n\n        if(media._colorFormat == ColorFormat.RGB)\n            return gpu.programs.enhancements.nightvision(texture, gain, offset, decay, quality, false);\n        else if(media._colorFormat == ColorFormat.Greyscale)\n            return gpu.programs.enhancements.nightvision(texture, gain, offset, decay, quality, true);\n        else\n            throw new NotSupportedError('Invalid color format');\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-descriptor.js\n * Feature descriptor\n */\n\nimport { AbstractMethodError } from '../utils/errors';\n\n/**\n * Abstract feature descriptor\n */\nexport class SpeedyDescriptor\n{\n    /**\n     * Abstract constructor\n     */\n    constructor()\n    {\n        /*if(this.constructor === SpeedyDescriptor)\n            throw new AbstractMethodError();*/\n    }\n    \n    /**\n     * Descriptor data\n     * @returns {null}\n     */\n    get data()\n    {\n        return null;\n    }\n\n    /**\n     * Descriptor size, in bytes\n     * @returns {number}\n     */\n    get size()\n    {\n        return 0;\n    }\n}\n\n/**\n * Binary feature descriptor\n */\nexport class BinaryDescriptor extends SpeedyDescriptor\n{\n    /**\n     * Class constructor\n     * @param {Uint8Array} bytes descriptor data\n     */\n    constructor(bytes)\n    {\n        super();\n        this._data = bytes;\n        this._size = bytes.length;\n    }\n\n    /**\n     * Descriptor data\n     * @returns {Uint8Array}\n     */\n    get data()\n    {\n        return this._data;\n    }\n\n    /**\n     * Descriptor size, in bytes\n     * @returns {number}\n     */\n    get size()\n    {\n        return this._size;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-feature-decorator.js\n * A wrapper around a FeatureAlgorithmDecorator\n */\n\nimport { FeatureAlgorithmDecorator } from './keypoints/feature-algorithm-decorator';\nimport { FeatureAlgorithm } from './keypoints/feature-algorithm';\nimport { Utils } from '../utils/utils';\n\n/**\n * A wrapper around a FeatureAlgorithmDecorator\n */\nexport class SpeedyFeatureDecorator\n{\n    /**\n     * Constructor\n     * @param {Function} decorator a FeatureAlgorithmDecorator\n     * @param {...*} [args] additional arguments to be passed when instantiating the decorator\n     */\n    constructor(decorator, ...args)\n    {\n        this._decorator = decorator;\n        this._args = args;\n    }\n\n    /**\n     * Decorate an algorithm\n     * @param {FeatureAlgorithm} algorithm \n     * @returns {FeatureAlgorithmDecorator}\n     */\n    decorate(algorithm)\n    {\n        const args = this._args;\n        const decorator = this._decorator;\n        const decoratedAlgorithm = new decorator(algorithm, ...args);\n\n        Utils.assert(decoratedAlgorithm instanceof FeatureAlgorithmDecorator);\n\n        return decoratedAlgorithm;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-feature-descriptor-factory.js\n * Factory of feature descriptors\n */\n\nimport { SpeedyNamespace } from './speedy-namespace';\nimport { SpeedyFeatureDecorator } from './speedy-feature-decorator';\nimport { ORBFeatures } from './keypoints/descriptors/orb';\n\n/**\n * A collection of methods for decorating Feature Detectors &\n * Feature Trackers with Descriptors\n */\nexport class SpeedyFeatureDescriptorFactory extends SpeedyNamespace\n{\n    /**\n     * ORB descriptor\n     * @returns {SpeedyFeatureDecorator}\n     */\n    static ORB()\n    {\n        return new SpeedyFeatureDecorator(ORBFeatures);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-feature-detector-factory.js\n * A collection of methods for instantiating SpeedyFeatureDetectors\n */\n\nimport { SpeedyNamespace } from './speedy-namespace';\nimport {\n    FASTFeatureDetector,\n    MultiscaleFASTFeatureDetector,\n    HarrisFeatureDetector,\n    MultiscaleHarrisFeatureDetector,\n} from './speedy-feature-detector';\nimport { ORBFeatures } from './keypoints/descriptors/orb';\nimport { SpeedyFeatureDescriptorFactory } from './speedy-feature-descriptor-factory';\n\n/**\n * A collection of methods for instantiating SpeedyFeatureDetectors\n */\nexport class SpeedyFeatureDetectorFactory extends SpeedyNamespace\n{\n    /**\n     * FAST feature detector\n     * @param {number} [n] Variant of the algorithm. Must be 9, 7 or 5.\n     * @returns {FASTFeatureDetector}\n     */\n    static FAST(n = 9)\n    {\n        return new FASTFeatureDetector(n);\n    }\n\n    /**\n     * FAST feature detector in scale-space\n     * @param {number} [n] Variant of the algorithm. Must be 9.\n     * @returns {MultiscaleFASTFeatureDetector}\n     */\n    static MultiscaleFAST(n = 9)\n    {\n        return new MultiscaleFASTFeatureDetector(n);\n    }\n\n    /**\n     * Harris corner detector\n     * @returns {HarrisFeatureDetector}\n     */\n    static Harris()\n    {\n        return new HarrisFeatureDetector();\n    }\n\n    /**\n     * Harris corner detector in scale-space\n     * @returns {MultiscaleHarrisFeatureDetector}\n     */\n    static MultiscaleHarris()\n    {\n        return new MultiscaleHarrisFeatureDetector();\n    }\n\n    /**\n     * ORB feature detector & descriptor\n     * @returns {MultiscaleHarrisFeatureDetector} decorated with ORB\n     */\n    static ORB()\n    {\n        const orb = SpeedyFeatureDescriptorFactory.ORB();\n        const detector = (new MultiscaleHarrisFeatureDetector()).link(orb);\n        detector.scaleFactor = 1.19;\n        return detector;\n    }\n\n    /**\n     * BRISK feature detector & descriptor\n     * @returns {BRISKFeatureDetector}\n     */\n    static BRISK()\n    {\n        return new BRISKFeatureDetector();\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-feature-detector.js\n * Feature detection API\n */\n\nimport { IllegalArgumentError, IllegalOperationError, AbstractMethodError, NotSupportedError } from '../utils/errors';\nimport { Utils } from '../utils/utils';\nimport { ColorFormat } from '../utils/types'\nimport { SpeedyFlags } from './speedy-flags';\nimport { SpeedyGPU } from '../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../gpu/speedy-texture';\nimport { SpeedyMedia } from './speedy-media';\nimport { FeatureDetectionAlgorithm } from './keypoints/feature-detection-algorithm';\nimport { FeatureDescriptionAlgorithm } from './keypoints/feature-description-algorithm';\nimport { FeatureDownloader } from './keypoints/feature-downloader';\nimport { FASTFeatures, MultiscaleFASTFeatures } from './keypoints/detectors/fast';\nimport { HarrisFeatures, MultiscaleHarrisFeatures } from './keypoints/detectors/harris';\nimport { SpeedyFeatureDecorator } from './speedy-feature-decorator';\n\n\n\n/**\n * Basic feature detection & description API\n * This is an easy-to-use wrapper around the internal\n * FeatureDetectionAlgorithm class, which deals with encoded\n * textures and is not suitable for end-user usage\n * @abstract\n */\nexport class SpeedyFeatureDetector\n{\n    /**\n     * Class constructor\n     * @param {FeatureDetectionAlgorithm} algorithm\n     */\n    constructor(algorithm)\n    {\n        // Set the algorithm\n        this._algorithm = algorithm;\n        this._decoratedAlgorithm = this._algorithm;\n\n        // sensitivity: the higher the value, the more feature points you get\n        this._sensitivity = 0; // a value in [0,1]\n\n        // cap the number of keypoints?\n        this._max = undefined;\n        this._capKeypoints = this._capKeypoints.bind(this);\n\n        // enhance the image in different ways before detecting the features\n        this._enhancements = {\n            denoise: true,\n            illumination: false,\n            nightvision: null,\n        };\n    }\n\n    /**\n     * Decorate the underlying algorithm\n     * @param {SpeedyFeatureDecorator} decorator\n     * @returns {SpeedyFeatureDetector} this instance, now decorated\n     */\n    link(decorator)\n    {\n        this._decoratedAlgorithm = decorator.decorate(this._decoratedAlgorithm);\n        return this;\n    }\n\n    /**\n     * Detect & describe feature points\n     * @param {SpeedyMedia} media\n     * @param {number} [flags]\n     * @returns {Promise<SpeedyFeature[]>}\n     */\n    detect(media, flags = 0)\n    {\n        const gpu = media._gpu;\n        const isStaticMedia = (media.options.usage == 'static');\n        const descriptorSize = this._decoratedAlgorithm.descriptorSize;\n        const extraSize = this._decoratedAlgorithm.extraSize;\n        let downloaderFlags = 0;\n\n        // check if the media has been released\n        if(media.isReleased())\n            throw new IllegalOperationError(`Can't detect features: the SpeedyMedia has been released`);\n\n        // Check usage hint: dynamic or static\n        if(isStaticMedia) {\n            // Allocate encoder space for static media\n            const MAX_KEYPOINT_GUESS = 8192; // hmmmmmmmm...\n            gpu.programs.encoders.reserveSpace(MAX_KEYPOINT_GUESS, descriptorSize, extraSize);\n        }\n        else {\n            // Use buffered downloads for dynamic media\n            downloaderFlags |= FeatureDownloader.USE_BUFFERED_DOWNLOADS;\n        }\n\n        // Reset encoder capacity & downloader state\n        if(flags & SpeedyFlags.FEATURE_DETECTOR_RESET_CAPACITY) {\n            // Speedy performs optimizations behind the scenes,\n            // specially when detecting features in videos.\n            // This flag will undo some optimizations. Use it\n            // when you expect a sudden increase in the number\n            // of keypoints (between two consecutive frames).\n            downloaderFlags |= FeatureDownloader.RESET_DOWNLOADER_STATE;\n\n            // reset the encoder capacity\n            const A_LOT_OF_KEYPOINTS = 2048; // hmmmm...\n            gpu.programs.encoders.reserveSpace(A_LOT_OF_KEYPOINTS, descriptorSize, extraSize);\n\n            // since we're resizing the encoder, we can't use\n            // buffered downloads in this framestep\n            downloaderFlags &= ~(FeatureDownloader.USE_BUFFERED_DOWNLOADS);\n        }\n\n        // Upload & preprocess media\n        const texture = gpu.upload(media.source);\n        const preprocessedTexture = this._preprocessTexture(\n            gpu,\n            texture,\n            this._enhancements.denoise == true,\n            media._colorFormat != ColorFormat.Greyscale\n        );\n\n        // Feature detection & description\n        this._algorithm.setEnhancements(\n            this._enhancements.nightvision || this._enhancements.illumination\n        );\n        const encodedKeypoints = this._decoratedAlgorithm.run(gpu, preprocessedTexture);\n\n        // Download keypoints from the GPU\n        return this._decoratedAlgorithm.download(\n            gpu,\n            encodedKeypoints,\n            downloaderFlags\n        ).then(this._capKeypoints);\n    }\n\n    /**\n     * Get the current detector sensitivity\n     * @returns {number} a value in [0,1]\n     */\n    get sensitivity()\n    {\n        return this._sensitivity;\n    }\n\n    /**\n     * Set the sensitivity of the feature detector\n     * The higher the sensitivity, the more features you get\n     * @param {number} sensitivity a value in [0,1]\n     */\n    set sensitivity(sensitivity)\n    {\n        this._sensitivity = Math.max(0, Math.min(+sensitivity, 1));\n        this._onSensitivityChange(this._sensitivity);\n    }\n\n    /**\n     * The maximum number of keypoints that will be\n     * returned by the feature detector. If it's\n     * undefined, then there is no pre-defined limit\n     * @returns {number | undefined}\n     */\n    get max()\n    {\n        return this._max;\n    }\n\n    /**\n     * The maximum number of keypoints that will be\n     * returned by the feature detector. Set it to\n     * undefined to disable any limits\n     * @param {number | undefined} maxFeaturePoints\n     */\n    set max(maxFeaturePoints)\n    {\n        if(maxFeaturePoints !== undefined)\n            this._max = Math.max(0, maxFeaturePoints | 0);\n        else\n            this._max = undefined;\n    }\n\n    /**\n     * Specify different enhancements to applied\n     * to the image before detecting the features\n     * @param {object} enhancements\n     */\n    enhance(enhancements)\n    {\n        // validate parameter\n        if(typeof enhancements !== 'object')\n            throw new IllegalArgumentError('enhancements must be an object');\n\n        // merge enhancements object\n        this._enhancements = Object.assign(this._enhancements, enhancements);\n    }\n\n    /**\n     * Preprocess a texture for feature detection & description\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture a RGB or greyscale image\n     * @param {boolean} [denoise] should we smooth the media a bit?\n     * @param {boolean} [convertToGreyscale] set to true if the texture is not greyscale\n     * @returns {SpeedyTexture} pre-processed greyscale image\n     */\n    _preprocessTexture(gpu, inputTexture, denoise = true, convertToGreyscale = true)\n    {\n        let texture = inputTexture;\n\n        if(denoise)\n            texture = gpu.programs.filters.gauss5(texture);\n\n        if(convertToGreyscale)\n            texture = gpu.programs.colors.rgb2grey(texture);\n\n        return texture;\n    }\n\n    /**\n     * Convert a normalized sensitivity into an\n     * algorithm-specific value such as a threshold\n     * \n     * Sensitivity is a generic parameter that can be\n     * mapped to different feature detectors. The\n     * higher the sensitivity, the more features\n     * you should get\n     *\n     * @param {number} sensitivity a value in [0,1]\n     */\n    _onSensitivityChange(sensitivity)\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Compare two keypoints for sorting (higher scores come first)\n     * @param {SpeedyFeature} a\n     * @param {SpeedyFeature} b\n     * @returns {number}\n     */\n    _compareKeypoints(a, b)\n    {\n        return (+(b.score)) - (+(a.score));\n    }\n\n    /**\n     * Cap the number of keypoints, so that only the ones with\n     * the highest scores will be returned to the user\n     * @param {SpeedyFeature[]} keypoints\n     * @returns {SpeedyFeature[]}\n     */\n    _capKeypoints(keypoints)\n    {\n        // nothing to do\n        if(this._max === undefined)\n            return keypoints;\n\n        // cap the number of keypoints\n        return keypoints.sort(this._compareKeypoints).slice(0, this._max);\n    }\n}\n\n\n\n\n/**\n * FAST feature detector\n */\nexport class FASTFeatureDetector extends SpeedyFeatureDetector\n{\n    /**\n     * Class constructor\n     * @param {number} [n] FAST variant: 9, 7 or 5\n     */\n    constructor(n = 9)\n    {\n        // Create algorithm\n        super(new FASTFeatures());\n\n        // Validate FAST variant\n        if(!(n === 9 || n === 7 || n === 5))\n            throw new NotSupportedError(`Can't create FAST feature detector with n = ${n}`);\n\n        // Set FAST variant\n        this._algorithm.n = n;\n    }\n\n    /**\n     * Get FAST variant\n     * @returns {number}\n     */\n    get n()\n    {\n        return this._algorithm.n;\n    }\n\n    /**\n     * Get FAST threshold\n     * @returns {number} a value in [0,255]\n     */\n    get threshold()\n    {\n        return this._algorithm.threshold;\n    }\n\n    /**\n     * Set FAST threshold\n     * @param {number} threshold an integer in [0,255]\n     */\n    set threshold(threshold)\n    {\n        this._algorithm.threshold = threshold;\n    }\n\n    /**\n     * Convert a normalized sensitivity to a FAST threshold\n     * @param {number} sensitivity \n     */\n    _onSensitivityChange(sensitivity)\n    {\n        this.threshold = Math.round(255.0 * (1.0 - Math.tanh(2.77 * sensitivity)));\n    }\n}\n\n\n\n/**\n * FAST feature detector in an image pyramid\n */\nexport class MultiscaleFASTFeatureDetector extends SpeedyFeatureDetector\n{\n    /**\n     * Class constructor\n     * @param {number} [n] Multiscale FAST variant. Must be 9\n     */\n    constructor(n = 9)\n    {\n        // setup algorithm\n        super(new MultiscaleFASTFeatures());\n\n        // Validate FAST variant\n        if(n !== 9)\n            throw new NotSupportedError(`Can't create Multiscale FAST feature detector with n = ${n}`);\n\n        // Set FAST variant\n        this._algorithm.n = n;\n    }\n\n    /**\n     * Get FAST variant\n     * @returns {number}\n     */\n    get n()\n    {\n        return this._algorithm.n;\n    }\n\n    /**\n     * Get FAST threshold\n     * @returns {number} a value in [0,255]\n     */\n    get threshold()\n    {\n        return this._algorithm.threshold;\n    }\n\n    /**\n     * Set FAST threshold\n     * @param {number} threshold an integer in [0,255]\n     */\n    set threshold(threshold)\n    {\n        this._algorithm.threshold = threshold;\n    }\n\n    /**\n     * Get the depth of the algorithm: how many pyramid layers will be scanned\n     * @returns {number}\n     */\n    get depth()\n    {\n        return this._algorithm.depth;\n    }\n\n    /**\n     * Set the depth of the algorithm: how many pyramid layers will be scanned\n     * @param {number} depth\n     */\n    set depth(depth)\n    {\n        this._algorithm.depth = depth;\n    }\n\n    /**\n     * Get the scale factor between consecutive pyramid layers\n     * @returns {number}\n     */\n    get scaleFactor()\n    {\n        return this._algorithm.scaleFactor;\n    }\n\n    /**\n     * Set the scale factor between consecutive pyramid layers\n     * @param {number} value must be greater than 1 and less than or equal to 2\n     */\n    set scaleFactor(value)\n    {\n        this._algorithm.scaleFactor = value;\n    }\n\n    /**\n     * Whether or not we're using an approximation of\n     * Harris corner responses for keypoint scores\n     * @returns {boolean}\n     */\n    get useHarrisScore()\n    {\n        return this._algorithm.useHarrisScore;\n    }\n\n    /**\n     * Should we use an approximation of Harris corner\n     * responses for keypoint scores?\n     * @param {boolean} useHarris\n     */\n    set useHarrisScore(useHarris)\n    {\n        this._algorithm.useHarrisScore = useHarris;\n    }\n\n    /**\n     * Convert a normalized sensitivity to a FAST threshold\n     * @param {number} sensitivity \n     */\n    _onSensitivityChange(sensitivity)\n    {\n        this.threshold = Math.round(255.0 * (1.0 - Math.tanh(2.77 * sensitivity)));\n    }\n}\n\n\n\n\n/**\n * Harris corner detector\n */\nexport class HarrisFeatureDetector extends SpeedyFeatureDetector\n{\n    /**\n     * Class constructor\n     */\n    constructor()\n    {\n        // setup the algorithm\n        super(new HarrisFeatures());\n    }\n\n    /**\n     * Get current quality level\n     * We will pick corners having score >= quality * max(score)\n     * @returns {number} a value in [0,1]\n     */\n    get quality()\n    {\n        return this._algorithm.quality;\n    }\n\n    /**\n     * Set quality level\n     * We will pick corners having score >= quality * max(score)\n     * @param {number} quality a value in [0,1]\n     */\n    set quality(quality)\n    {\n        this._algorithm.quality = Math.max(0, Math.min(quality, 1));\n    }\n\n    /**\n     * Convert a normalized sensitivity to a quality value\n     * @param {number} sensitivity \n     */\n    _onSensitivityChange(sensitivity)\n    {\n        this.quality = 1.0 - sensitivity;\n    }\n}\n\n\n\n/**\n * Harris corner detector in an image pyramid\n */\nexport class MultiscaleHarrisFeatureDetector extends SpeedyFeatureDetector\n{\n    /**\n     * Class constructor\n     */\n    constructor()\n    {\n        // setup algorithm\n        super(new MultiscaleHarrisFeatures());\n    }\n\n    /**\n     * Get the depth of the algorithm: how many pyramid layers will be scanned\n     * @returns {number}\n     */\n    get depth()\n    {\n        return this._algorithm.depth;\n    }\n\n    /**\n     * Set the depth of the algorithm: how many pyramid layers will be scanned\n     * @param {number} depth a number between 1 and PYRAMID_MAX_LEVELS, inclusive\n     */\n    set depth(depth)\n    {\n        this._algorithm.depth = depth;\n    }\n\n    /**\n     * Get the scale factor between consecutive pyramid layers\n     * @returns {number}\n     */\n    get scaleFactor()\n    {\n        return this._algorithm.scaleFactor;\n    }\n\n    /**\n     * Set the scale factor between consecutive pyramid layers\n     * @param {number} value must be greater than 1\n     */\n    set scaleFactor(value)\n    {\n        this._algorithm.scaleFactor = value;\n    }\n\n    /**\n     * Get current quality level\n     * We will pick corners having score >= quality * max(score)\n     * @returns {number} a value in [0,1]\n     */\n    get quality()\n    {\n        return this._algorithm.quality;\n    }\n\n    /**\n     * Set quality level\n     * We will pick corners having score >= quality * max(score)\n     * @param {number} quality a value in [0,1]\n     */\n    set quality(quality)\n    {\n        this._algorithm.quality = Math.max(0, Math.min(quality, 1));\n    }\n\n    /**\n     * Convert a normalized sensitivity to a quality value\n     * @param {number} sensitivity \n     */\n    _onSensitivityChange(sensitivity)\n    {\n        this.quality = 1.0 - sensitivity;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-feature-tracker-factory.js\n * A collection of methods for instantiating Feature Trackers\n */\n\nimport { SpeedyNamespace } from './speedy-namespace';\nimport { SpeedyMedia } from './speedy-media';\nimport { LKFeatureTracker } from './speedy-feature-tracker';\n\n/**\n * A collection of methods for instantiating Feature Trackers\n */\nexport class SpeedyFeatureTrackerFactory extends SpeedyNamespace\n{\n    /**\n     * Spawns a LK feature tracker\n     * @param {SpeedyMedia} media\n     * @returns {LKFeatureTracker}\n     */\n    static LK(media)\n    {\n        return new LKFeatureTracker(media);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-feature-tracker.js\n * An easy-to-use class for working with feature trackers\n */\n\nimport { FeatureTrackingAlgorithm } from './keypoints/feature-tracking-algorithm';\nimport { FeatureAlgorithm } from './keypoints/feature-algorithm';\nimport { FeatureDownloader } from './keypoints/feature-downloader';\nimport { SpeedyMedia } from './speedy-media';\nimport { SpeedyGPU } from '../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../gpu/speedy-texture';\nimport { SpeedyVector2 } from './math/speedy-vector';\nimport { IllegalOperationError, IllegalArgumentError } from '../utils/errors';\nimport { Utils } from '../utils/utils';\nimport { KPF_DISCARD } from '../utils/globals';\nimport { LKFeatureTrackingAlgorithm } from './keypoints/trackers/lk';\nimport { SpeedyFeatureDecorator } from './speedy-feature-decorator';\n\n/**\n * An easy-to-use class for working with feature trackers\n * (it performs sparse optical-flow)\n * @abstract\n */\nexport class SpeedyFeatureTracker\n{\n    /**\n     * Class constructor\n     * @param {FeatureTrackingAlgorithm} trackingAlgorithm used to track the features\n     * @param {SpeedyMedia} media the media that holds the features\n     */\n    constructor(trackingAlgorithm, media)\n    {\n        /** @type {FeatureTrackingAlgorithm} tracking algorithm */\n        this._trackingAlgorithm = trackingAlgorithm;\n\n        /** @type {FeatureAlgorithm} decorated tracking algorithm */\n        this._decoratedAlgorithm = this._trackingAlgorithm;\n\n        /** @type {SpeedyMedia} the media we're using to track the features */\n        this._media = media;\n\n        /** @type {SpeedyTexture} image at time t */\n        this._inputTexture = null;\n\n        /** @type {SpeedyTexture} image at time t-1 */\n        this._prevInputTexture = null;\n    }\n\n    /**\n     * Decorate the underlying algorithm\n     * @param {SpeedyFeatureDecorator} decorator\n     * @returns {SpeedyFeatureTracker} this instance, now decorated\n     */\n    link(decorator)\n    {\n        this._decoratedAlgorithm = decorator.decorate(this._decoratedAlgorithm);\n        return this;\n    }\n\n    /**\n     * Track keypoints in the media\n     * @param {SpeedyFeature[]} keypoints the keypoints you want to track\n     * @param {SpeedyVector2[]|null} [flow] output parameter: flow vector for the i-th keypoint\n     * @param {boolean[]|null} [found] output parameter: found[i] will be true if the i-th keypoint has been found\n     * @returns {Promise<SpeedyFeature[]>}\n     */\n    track(keypoints, flow = null, found = null)\n    {\n        const gpu = this._media._gpu; // friend class?!\n        const descriptorSize = this._decoratedAlgorithm.descriptorSize;\n        const extraSize = this._decoratedAlgorithm.extraSize;\n        const flags = 0;\n\n        // validate arguments\n        if(!Array.isArray(keypoints) || (found != null && !Array.isArray(found)) || (flow != null && !Array.isArray(flow)))\n            throw new IllegalArgumentError();\n\n        // upload media to the GPU\n        const [ nextImage, prevImage ] = this._updatedImages(this._media, gpu, this._prevInputTexture);\n        this._prevInputTexture = prevImage;\n        this._inputTexture = nextImage;\n\n        // adjust the size of the encoder\n        gpu.programs.encoders.optimize(keypoints.length, descriptorSize, extraSize);\n\n        // upload & track keypoints\n        this._trackingAlgorithm.prevImage = prevImage;\n        this._trackingAlgorithm.prevKeypoints = this._trackingAlgorithm.upload(gpu, keypoints);\n        const encodedKeypoints = this._decoratedAlgorithm.run(gpu, nextImage);\n\n        // download keypoints\n        return this._decoratedAlgorithm.download(gpu, encodedKeypoints, flags).then(trackedKeypoints => {\n            const filteredKeypoints = [];\n\n            // initialize output arrays\n            if(found != null)\n                found.length = trackedKeypoints.length;\n            if(flow != null)\n                flow.length = trackedKeypoints.length;\n\n            // compute additional data and filter out discarded keypoints\n            for(let i = 0; i < trackedKeypoints.length; i++) {\n                const goodFeature = ((trackedKeypoints[i].flags & KPF_DISCARD) == 0);\n\n                if(goodFeature)\n                    filteredKeypoints.push(trackedKeypoints[i]);\n\n                if(found != null)\n                    found[i] = goodFeature;\n\n                if(flow != null) {\n                    flow[i] = goodFeature ? \n                        new SpeedyVector2(trackedKeypoints[i].x - keypoints[i].x, trackedKeypoints[i].y - keypoints[i].y) :\n                        new SpeedyVector2(0, 0);\n                }\n            }\n\n            // done!\n            return filteredKeypoints;\n        });\n    }\n\n    /**\n     * Upload the media to GPU and keep track of the previous frame\n     * @param {SpeedyMedia} media\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture|null} prevImage\n     * @returns {SpeedyTexture[]} [nextImage, prevImage] tuple\n     */\n    _updatedImages(media, gpu, prevImage)\n    {\n        // validate the media\n        if(media.isReleased())\n            throw new IllegalOperationError(`The media has been released`);\n\n        // upload the media\n        const nextImage = gpu.upload(media.source);\n        if(nextImage == null)\n            throw new IllegalOperationError(`Tracking error: can't upload image to the GPU ${media.source}`);\n\n        // done!\n        return [ nextImage, prevImage || nextImage ];\n    }\n}\n\n\n/**\n * LK feature tracker with image pyramids\n */\nexport class LKFeatureTracker extends SpeedyFeatureTracker\n{\n    /**\n     * Class constructor\n     * @param {SpeedyMedia} media media to track\n     */\n    constructor(media)\n    {\n        const algorithm = new LKFeatureTrackingAlgorithm();\n        super(algorithm, media);\n    }\n\n    /**\n     * Neighborhood size\n     * @returns {number}\n     */\n    get windowSize()\n    {\n        return this._trackingAlgorithm.windowSize;\n    }\n\n    /**\n     * Neighborhood size\n     * @param {number} newSize a positive odd number, typically 21 or 15\n     */\n    set windowSize(newSize)\n    {\n        if(typeof newSize !== 'number' || newSize < 1 || newSize % 2 == 0)\n            throw new IllegalArgumentError(`Window size must be a positive odd number`);\n\n        this._trackingAlgorithm.windowSize = newSize;\n    }\n\n    /**\n     * How many pyramid levels will be scanned\n     * @returns {number}\n     */\n    get depth()\n    {\n        return this._trackingAlgorithm.depth;\n    }\n\n    /**\n     * How many pyramid levels will be scanned\n     * @param {number} newDepth positive integer\n     */\n    set depth(newDepth)\n    {\n        if(typeof newDepth !== 'number' || newDepth < 1)\n            throw new IllegalArgumentError(`Invalid depth: ${newDepth}`);\n\n        this._trackingAlgorithm.depth = newDepth;\n    }\n\n    /**\n     * A threshold used to discard \"bad\" keypoints\n     * @returns {number}\n     */\n    get discardThreshold()\n    {\n        return this._trackingAlgorithm.discardThreshold;\n    }\n\n    /**\n     * A threshold used to discard \"bad\" keypoints\n     * @param {number} threshold typically 0.0001 - increase to discard more keypoints\n     */\n    set discardThreshold(threshold)\n    {\n        if(typeof threshold !== 'number' || threshold < 0)\n            throw new IllegalArgumentError(`Invalid discardThreshold`);\n\n        this._trackingAlgorithm.discardThreshold = threshold;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-feature.js\n * Feature Point class\n */\n\nimport { SpeedyDescriptor } from './speedy-descriptor';\nimport { Utils } from '../utils/utils';\n\n// Constants\nconst noBytes = new Uint8Array([]);\n\n\n\n/**\n * A SpeedyFeature is a keypoint in an image,\n * with optional scale, rotation and\n * descriptor bytes / extra bytes\n */\nexport class SpeedyFeature\n{\n    /**\n     * Constructor\n     * @param {number} x X position\n     * @param {number} y Y position\n     * @param {number} [lod] Level-of-detail\n     * @param {number} [rotation] Rotation in radians\n     * @param {number} [score] Cornerness measure\n     * @param {number} [flags] Keypoint flags\n     * @param {Uint8Array} [extraBytes] extra bytes of the header, if any\n     * @param {Uint8Array} [descriptorBytes] bytes of the feature descriptor, if any\n     */\n    constructor(x, y, lod = 0.0, rotation = 0.0, score = 0.0, flags = 0, extraBytes = null, descriptorBytes = null)\n    {\n        this._x = +x;\n        this._y = +y;\n        this._lod = +lod;\n        this._rotation = +rotation;\n        this._score = +score;\n        this._scale = Math.pow(2, +lod);\n        this._flags = flags | 0;\n        this._extraBytes = extraBytes || noBytes;\n        this._descriptorBytes = descriptorBytes || noBytes;\n    }\n\n    /**\n     * Converts a SpeedyFeature to a representative string\n     * @returns {string}\n     */\n    toString()\n    {\n        return `(${this._x},${this._y})`;\n    }\n\n    /**\n     * The X position of the feature point\n     * @returns {number} X position\n     */\n    get x()\n    {\n        return this._x;\n    }\n\n    /**\n     * The y position of the feature point\n     * @returns {number} Y position\n     */\n    get y()\n    {\n        return this._y;\n    }\n\n    /**\n     * The pyramid level-of-detail from which\n     * this feature point was extracted\n     */\n    get lod()\n    {\n        return this._lod;\n    }\n\n    /**\n     * The scale of the feature point\n     * @returns {number} Scale\n     */\n    get scale()\n    {\n        return this._scale;\n    }\n\n    /**\n     * The rotation of the feature point, in radians\n     * @returns {number} Angle in radians\n     */\n    get rotation()\n    {\n        return this._rotation;\n    }\n\n    /**\n     * Score: a cornerness measure\n     * @returns {number} Score\n     */\n    get score()\n    {\n        return this._score;\n    }\n\n    /**\n     * Internal flags\n     * @returns {number}\n     */\n    get flags()\n    {\n        return this._flags;\n    }\n}\n\n/**\n * A feature point with a descriptor\n */\nexport class SpeedyFeatureWithDescriptor extends SpeedyFeature\n{\n    /**\n     * Constructor\n     * @param {SpeedyFeature} feature\n     * @param {function(Uint8Array): SpeedyDescriptor} spawnDescriptor spawns a descriptor given a sequence of bytes\n     */\n    constructor(feature, spawnDescriptor)\n    {\n        // copy values\n        super(\n            feature._x,\n            feature._y,\n            feature._lod,\n            feature._rotation,\n            feature._score,\n            feature._flags,\n            feature._extraBytes,\n            feature._descriptorBytes\n        );\n\n        // setup descriptor\n        this._descriptor = spawnDescriptor(this._descriptorBytes);\n    }\n\n    /**\n     * The descriptor of the feature point\n     * @returns {SpeedyDescriptor} feature descriptor\n     */\n    get descriptor()\n    {\n        return this._descriptor;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-flags.js\n * Flags available to users\n */\n\nexport const SpeedyFlags = Object.freeze({\n\n    // Feature detectors\n    FEATURE_DETECTOR_RESET_CAPACITY: 0x1,\n\n});","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-media-source.js\n * Wrappers around <img>, <video>, <canvas>, etc.\n */\n\nimport { Utils } from '../utils/utils';\nimport { SpeedyPromise } from '../utils/speedy-promise';\nimport { AbstractMethodError, IllegalArgumentError, IllegalOperationError, TimeoutError } from '../utils/errors';\nimport { MediaType } from '../utils/types'\n\n/**\n * An abstract media source: a wrapper around native\n * elements such as: HTMLImageElement, HTMLVideoElement,\n * and so on\n * @abstract\n */\nexport class SpeedyMediaSource\n{\n    /**\n     * Constructor\n     */\n    constructor()\n    {\n        /** @type {HTMLImageElement|HTMLVideoElement|HTMLCanvasElement|ImageBitmap} underlying media object */\n        this._data = null;\n\n        /** @type {number} media width, in pixels */\n        this._width = 0;\n\n        /** @type {number} media height, in pixels */\n        this._height = 0;\n    }\n\n    /**\n     * Load a media source\n     * @param {HTMLImageElement|HTMLVideoElement|HTMLCanvasElement|ImageBitmap} wrapperObject\n     * @returns {SpeedyPromise<SpeedyMediaSource>}\n     */\n    static load(wrappedObject)\n    {\n        const constructor = wrappedObject.constructor.name;\n\n        if(constructor == 'HTMLImageElement')\n            return new SpeedyImageMediaSource()._load(wrappedObject);\n        else if(constructor == 'HTMLVideoElement')\n            return new SpeedyVideoMediaSource()._load(wrappedObject);\n        else if(constructor == 'HTMLCanvasElement')\n            return new SpeedyCanvasMediaSource()._load(wrappedObject);\n        else if(constructor == 'ImageBitmap')\n            return new SpeedyBitmapMediaSource()._load(wrappedObject);\n        else\n            throw new IllegalArgumentError(`Unsupported media type: ${wrappedObject}`);\n    }\n\n    /**\n     * The underlying wrapped object\n     * @returns {HTMLImageElement|HTMLVideoElement|HTMLCanvasElement|ImageBitmap}\n     */\n    get data()\n    {\n        return this._data;\n    }\n\n    /**\n     * Media width, in pixels\n     * @returns {number}\n     */\n    get width()\n    {\n        return this._width;\n    }\n\n    /**\n     * Media height, in pixels\n     * @returns {number}\n     */\n    get height()\n    {\n        return this._height;\n    }\n\n    /**\n     * Is the underlying media loaded?\n     * @returns {boolean}\n     */\n    isLoaded()\n    {\n        return this._data !== null;\n    }\n\n    /**\n     * The type of the underlying media source\n     * @returns {Symbol} MediaType enum\n     */\n    get type()\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Clone this media source\n     * @returns {SpeedyPromise<SpeedyMediaSource>}\n     */\n    clone()\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Load the underlying media\n     * @returns {SpeedyPromise<SpeedyMediaSource>}\n     */\n    _load()\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Wait for an event to be triggered in this._data\n     * @param {Element} element\n     * @param {string} eventName\n     * @param {number} [timeout] in ms\n     * @returns {SpeedyPromise<Element>}\n     */\n    _waitUntil(element, eventName, timeout = 30000)\n    {\n        return new SpeedyPromise((resolve, reject) => {\n            Utils.log(`Waiting for ${eventName} to be triggered in ${element}...`);\n\n            const timer = setTimeout(() => {\n                reject(new TimeoutError(`${eventName} has not been triggered in ${element}: timeout (${timeout}ms)`));\n            }, timeout);\n\n            element.addEventListener(eventName, () => {\n                clearTimeout(timer);\n                resolve(element);\n            }, false);\n        });\n    }\n}\n\n/**\n * Image media source:\n * a wrapper around HTMLImageElement\n */\nclass SpeedyImageMediaSource extends SpeedyMediaSource\n{\n    /**\n     * The type of the underlying media source\n     * @returns {Symbol} MediaType enum\n     */\n    get type()\n    {\n        return MediaType.Image;\n    }\n\n    /**\n     * Clone this media source\n     * @returns {SpeedyPromise<SpeedyMediaSource>}\n     */\n    clone()\n    {\n        if(this._data == null)\n            throw new IllegalOperationError(`Media not loaded`);\n\n        const newNode = this._data.cloneNode(true);\n        const newSource = new SpeedyImageMediaSource();\n        return newSource._load(newNode);\n    }\n\n    /**\n     * Load the underlying media\n     * @param {HTMLImageElement} image\n     * @returns {SpeedyPromise<SpeedyMediaSource>}\n     */\n    _load(image)\n    {\n        if(image.complete && image.naturalWidth !== 0) { // already loaded?\n            return SpeedyPromise.resolve().then(() => {\n                this._data = image;\n                this._width = image.naturalWidth;\n                this._height = image.naturalHeight;\n                return this;\n            });\n        }\n        else {\n            return this._waitUntil(image, 'load').then(() => {\n                this._data = image;\n                this._width = image.naturalWidth;\n                this._height = image.naturalHeight;\n                return this;\n            });\n        }\n    }\n}\n\n/**\n * Video media source:\n * a wrapper around HTMLVideoElement\n */\nclass SpeedyVideoMediaSource extends SpeedyMediaSource\n{\n    /**\n     * The type of the underlying media source\n     * @returns {Symbol} MediaType enum\n     */\n    get type()\n    {\n        return MediaType.Video;\n    }\n\n    /**\n     * Clone this media source\n     * @returns {SpeedyPromise<SpeedyMediaSource>}\n     */\n    clone()\n    {\n        if(this._data == null)\n            throw new IllegalOperationError(`Media not loaded`);\n\n        const newNode = this._data.cloneNode(true);\n        const newSource = new SpeedyVideoMediaSource();\n        return newSource._load(newNode);\n    }\n\n    /**\n     * Load the underlying media\n     * @param {HTMLVideoElement} video\n     * @returns {SpeedyPromise<SpeedyMediaSource>}\n     */\n    _load(video)\n    {\n        if(video.readyState >= 4) { // already loaded?\n            return SpeedyPromise.resolve().then(() => {\n                this._data = video;\n                this._width = video.videoWidth;\n                this._height = video.videoHeight;\n                return this;\n            });\n        }\n        else {\n            // waitUntil('canplay'); // use readyState >= 3\n            return this._waitUntil(video, 'canplaythrough').then(() => {\n                this._data = video;\n                this._width = video.videoWidth;\n                this._height = video.videoHeight;\n                return this;\n            })\n        }\n    }\n}\n\n/**\n * Canvas media source:\n * a wrapper around HTMLCanvasElement\n */\nclass SpeedyCanvasMediaSource extends SpeedyMediaSource\n{\n    /**\n     * The type of the underlying media source\n     * @returns {Symbol} MediaType enum\n     */\n    get type()\n    {\n        return MediaType.Canvas;\n    }\n\n    /**\n     * Clone this media source\n     * @returns {SpeedyPromise<SpeedyMediaSource>}\n     */\n    clone()\n    {\n        if(this._data == null)\n            throw new IllegalOperationError(`Media not loaded`);\n\n        const newCanvas = Utils.createCanvas(this._width, this._height);\n        const newContext = newCanvas.getContext('2d');\n        newContext.draw(this._data, 0, 0);\n\n        const newSource = new SpeedyCanvasMediaSource();\n        return newSource._load(newCanvas);\n    }\n\n    /**\n     * Load the underlying media\n     * @param {HTMLCanvasElement} canvas\n     * @returns {SpeedyPromise<SpeedyMediaSource>}\n     */\n    _load(canvas)\n    {\n        return SpeedyPromise.resolve().then(() => {\n            this._data = canvas;\n            this._width = canvas.width;\n            this._height = canvas.height;\n            return this;\n        });\n    }\n}\n\n/**\n * Bitmap media source:\n * a wrapper around ImageBitmap\n */\nclass SpeedyBitmapMediaSource extends SpeedyMediaSource\n{\n    /**\n     * The type of the underlying media source\n     * @returns {Symbol} MediaType enum\n     */\n    get type()\n    {\n        return MediaType.Bitmap;\n    }\n\n    /**\n     * Clone this media source\n     * @returns {SpeedyPromise<SpeedyMediaSource>}\n     */\n    clone()\n    {\n        if(this._data == null)\n            throw new IllegalOperationError(`Media not loaded`);\n\n        const newSource = new SpeedyBitmapMediaSource();\n        return createImageBitmap(this._data).then(\n            newBitmap => newSource._load(newBitmap)\n        );\n    }\n\n    /**\n     * Load the underlying media\n     * @param {ImageBitmap} bitmap\n     * @returns {SpeedyPromise<SpeedyMediaSource>}\n     */\n    _load(bitmap)\n    {\n        return SpeedyPromise.resolve().then(() => {\n            this._data = bitmap;\n            this._width = bitmap.width;\n            this._height = bitmap.height;\n            return this;\n        });\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-media.js\n * SpeedyMedia implementation\n */\n\nimport { SpeedyGPU } from '../gpu/speedy-gpu';\nimport { MediaType, ColorFormat } from '../utils/types'\nimport { IllegalArgumentError, IllegalOperationError } from '../utils/errors';\nimport { Utils } from '../utils/utils';\nimport { SpeedyFeatureDetectorFactory } from './speedy-feature-detector-factory';\nimport { SpeedyMediaSource } from './speedy-media-source';\nimport { SpeedyPromise } from '../utils/speedy-promise';\nimport { SpeedyPipeline } from './speedy-pipeline';\n\n/**\n * SpeedyMedia encapsulates a media element\n * (e.g., image, video, canvas)\n */\nexport class SpeedyMedia\n{\n    /**\n     * Class constructor\n     * It receives A VALID media source that is already loaded\n     * @param {SpeedyMediaSource|SpeedyMedia} source\n     * @param {object} [options] options object\n     */\n    /* private */ constructor(source, options = { })\n    {\n        /** @type {SpeedyMediaSource} media source */\n        this._source = null;\n\n        /** @type {SpeedyGPU} GPU routines */\n        this._gpu = null;\n\n        /** @type {Symbol} ColorFormat enum */\n        this._colorFormat = ColorFormat.RGB;\n\n        /** @type {object} options */\n        this._options = null;\n\n\n\n        // Setup the new SpeedyMedia\n        const constructor = source.constructor.name;\n        if(constructor == 'SpeedyMedia') {\n            // copy constructor (shallow copy)\n            const media = source;\n            this._source = media._source;\n            this._colorFormat = media._colorFormat;\n            this._options = media._options;\n            this._gpu = media._gpu;\n        }\n        else {\n            // store the media source\n            Utils.assert(source.isLoaded());\n            this._source = source;\n\n            // warning: loading canvas without explicit usage option\n            if(this._source.type == MediaType.Canvas && options.usage === undefined)\n                Utils.warning('Loading a canvas without an explicit usage flag. I will set the usage to \"static\". This will result in suboptimal performance if the canvas is animated');\n\n            // set the color format\n            //this._colorFormat = ColorFormat.RGB;\n\n            // set options\n            this._options = this._buildOptions(options, {\n                usage: (this._source.type == MediaType.Video) ? 'dynamic' : 'static',\n            });\n\n            // spawn relevant components\n            this._gpu = new SpeedyGPU(this._source.width, this._source.height);\n        }\n    }\n\n    /**\n     * Load a media source\n     * Will wait until the HTML media source is loaded\n     * @param {HTMLImageElement|HTMLVideoElement|HTMLCanvasElement|ImageBitmap} mediaSource An image, video or canvas\n     * @param {object} [options] options object\n     * @returns {SpeedyPromise<SpeedyMedia>}\n     */\n    static load(mediaSource, options = { })\n    {\n        return SpeedyMediaSource.load(mediaSource).then(source => {\n            Utils.assert(source.width !== 0 && source.height !== 0);\n\n            const media = new SpeedyMedia(source, options);\n            Utils.log(`Loaded SpeedyMedia with a ${mediaSource}.`);\n\n            return media;\n        });\n    }\n\n    /**\n     * Loads a camera stream\n     * @param {number} [width] width of the stream\n     * @param {number} [height] height of the stream\n     * @param {object} [cameraOptions] additional options to pass to getUserMedia()\n     * @param {object} [mediaOptions] additional options for advanced configuration of the SpeedyMedia\n     * @returns {SpeedyPromise<SpeedyMedia>}\n     */\n    static loadCameraStream(width = 426, height = 240, cameraOptions = { }, mediaOptions = { })\n    {\n        return Utils.requestCameraStream(width, height, cameraOptions).then(\n            video => SpeedyMedia.load(video, mediaOptions)\n        );\n    }\n\n    /**\n     * The media element (image, video, canvas) encapsulated by this SpeedyMedia object\n     * @returns {HTMLImageElement|HTMLVideoElement|HTMLCanvasElement|ImageBitmap} the media element\n     */\n    get source()\n    {\n        return this._source.data;\n    }\n\n    /**\n     * Gets the width of the media\n     * @returns {number} media width\n     */\n    get width()\n    {\n        return this._source.width;\n    }\n\n    /**\n     * Gets the height of the media\n     * @returns {number} media height\n     */\n    get height()\n    {\n        return this._source.height;\n    }\n\n    /**\n     * The type of the media attached to this SpeedyMedia object\n     * @returns {string} \"image\" | \"video\" | \"canvas\" | \"bitmap\"\n     */\n    get type()\n    {\n        switch(this._source.type) {\n            case MediaType.Image:\n                return 'image';\n\n            case MediaType.Video:\n                return 'video';\n\n            case MediaType.Canvas:\n                return 'canvas';\n\n            case MediaType.Bitmap:\n                return 'bitmap';\n\n            default: // this shouldn't happen\n                return 'unknown';\n        }\n    }\n\n    /**\n     * Returns a read-only object featuring advanced options\n     * related to this SpeedyMedia object\n     * @returns {object}\n     */\n    get options()\n    {\n        return this._options;\n    }\n\n    /**\n     * Releases resources associated with this media.\n     * You will no longer be able to use it, nor any of its lightweight clones.\n     * @returns {SpeedyPromise} resolves as soon as the resources are released\n     */\n    release()\n    {\n        if(!this.isReleased()) {\n            Utils.log('Releasing SpeedyMedia object...');\n            this._gpu.loseWebGLContext();\n            this._gpu = null;\n            this._source = null;\n        }\n\n        return SpeedyPromise.resolve();\n    }\n\n    /**\n     * Is this SpeedyMedia released?\n     * @returns {bool}\n     */\n    isReleased()\n    {\n        return this._gpu == null;\n    }\n\n    /**\n     * Clones the SpeedyMedia object\n     * @param {object} options options object\n     * @returns {SpeedyPromise<SpeedyMedia>} a clone object\n     */\n    clone(options = {})\n    {\n        // Default settings\n        options = {\n            lightweight: false,\n            ...(options)\n        };\n\n        // has the media been released?\n        if(this.isReleased())\n            throw new IllegalOperationError('Can\\'t clone a SpeedyMedia that has been released');\n\n        // clone the object\n        if(options.lightweight) {\n            // shallow copy\n            return SpeedyPromise.resolve(new SpeedyMedia(this, this._options));\n        }\n        else {\n            // deep copy\n            return this._source.clone().then(\n                newSource => new SpeedyMedia(newSource, this._options)\n            );\n        }\n    }\n\n    /**\n     * Runs a pipeline\n     * @param {SpeedyPipeline} pipeline\n     * @returns {SpeedyPromise<SpeedyMedia>} a promise that resolves to A CLONE of this SpeedyMedia\n     */\n    run(pipeline)\n    {\n        // has the media been released?\n        if(this.isReleased())\n            throw new IllegalOperationError('Can\\'t run pipeline: SpeedyMedia has been released');\n\n        // create a lightweight clone\n        return this.clone({ lightweight: true }).then(media => {\n            // upload the media to the GPU\n            let texture = media._gpu.upload(media._source.data);\n\n            // run the pipeline\n            texture = pipeline._run(texture, media._gpu, media);\n\n            // convert to bitmap\n            media._gpu.programs.utils.output(texture);\n            return createImageBitmap(media._gpu.canvas, 0, 0, media.width, media.height).then(bitmap => {\n                return SpeedyMediaSource.load(bitmap).then(source => {\n                    media._source = source;\n                    return media;\n                });\n            });\n        });\n    }\n\n    /**\n     * Draws the media to a canvas\n     * @param {HTMLCanvasElement} canvas canvas element\n     * @param {number} [x] x-position\n     * @param {number} [y] y-position\n     * @param {number} [width] desired width\n     * @param {number} [height] desired height\n     */\n    draw(canvas, x = 0, y = 0, width = this.width, height = this.height)\n    {\n        // fail silently if the media been released\n        if(this.isReleased())\n            return;\n\n        // validate parameters\n        x = Math.max(+x, 0); y = Math.max(+y, 0);\n        width = Math.max(+width, 0);\n        height = Math.max(+height, 0);\n\n        // draw\n        const ctx = canvas.getContext('2d');\n        ctx.drawImage(this._source.data, x, y, width, height);\n    }\n\n    /**\n     * Converts the media to an ImageBitmap\n     * @returns {Promise<ImageBitmap>}\n     */\n    toBitmap()\n    {\n        if(this.isReleased())\n            throw new IllegalOperationError('Can\\'t convert SpeedyMedia to ImageBitmap: the media has been released');\n        else if(!this._source.isLoaded())\n            throw new IllegalOperationError('Can\\'t convert SpeedyMedia to bitmap: the media hasn\\'t been loaded');\n\n        return createImageBitmap(this._source.data);\n    }\n\n    /**\n     * Build & validate options object\n     * @param {object} options\n     * @param {object} defaultOptions\n     * @returns {object}\n     */\n    _buildOptions(options, defaultOptions)\n    {\n        // build options object\n        options = Object.assign({ }, defaultOptions, options);\n\n        // validate\n        if(options.usage != 'dynamic' && options.usage != 'static') {\n            Utils.warning(`Can't load media. Unrecognized usage option: \"${options.usage}\"`);\n            options.usage = defaultOptions.usage;\n            Utils.assert(options.usage == 'dynamic' || options.usage == 'static');\n        }\n\n        // done!\n        return Object.freeze(options); // must be read-only\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-namespace.js\n * Symbolizes a namespace\n */\n\nimport { AbstractMethodError } from '../utils/errors'\n\n/**\n * An abstract namespace\n * @abstract\n */\nexport class SpeedyNamespace\n{\n    /**\n     * Namespaces can't be instantiated.\n     * Only static methods are allowed.\n     * @throws SpeedyError\n     */\n    constructor()\n    {\n        // only static methods are allowed\n        throw new AbstractMethodError(`Namespaces can't be instantiated`);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-pipeline.js\n * A pipeline is a sequence of operations that transform the image in some way\n */\n\nimport { PipelineOperation } from './pipeline-operations';\nimport { MediaType } from '../utils/types';\nimport { IllegalOperationError } from '../utils/errors';\nimport { IllegalArgumentError } from '../utils/errors';\n\n\n/**\n * A SpeedyPipeline holds a sequence of operations that\n * graphically transform the incoming media in some way\n * \n * SpeedyPipeline's methods are chainable: use them to\n * create your own sequence of image operations\n */\nexport class SpeedyPipeline\n{\n    /**\n     * Class constructor\n     */\n    constructor()\n    {\n        /** @type {SpeedyPipelineOperation[]} operations vector */\n        this._operations = [];\n    }\n\n    /**\n     * The number of the operations of the pipeline\n     * @returns {number}\n     */\n    get length()\n    {\n        return this._operations.length;\n    }\n\n    /**\n     * Cleanup pipeline memory\n     * @returns {Promise<SpeedyPipeline>} resolves as soon as the memory is released\n     */\n    release()\n    {\n        return new Promise((resolve, reject) => {\n            for(let i = this._operations.length - 1; i >= 0; i--)\n                this._operations[i].release();\n            this._operations.length = 0;\n            resolve(this);\n        });\n    }\n\n    /**\n     * Adds a new operation to the end of the pipeline\n     * @param {SpeedyPipelineOperation} operation\n     * @returns {SpeedyPipeline} the pipeline itself\n     */\n    _spawn(operation)\n    {\n        this._operations.push(operation);\n        return this;\n    }\n\n    /**\n     * Runs the pipeline\n     * @param {SpeedyTexture} texture input texture\n     * @param {SpeedyGPU} gpu gpu attached to the media\n     * @param {SpeedyMedia} media media object\n     * @returns {SpeedyTexture} output texutre\n     */\n    _run(texture, gpu, media)\n    {\n        for(let i = 0; i < this._operations.length; i++)\n            texture = this._operations[i].run(texture, gpu, media);\n\n        return texture;\n    }\n\n\n    // =====================================================\n    //                    GENERIC\n    // =====================================================\n\n    /**\n     * Concatenates another pipeline into this one\n     * @param {SpeedyPipeline} pipeline\n     * @returns {SpeedyPipeline}\n     */\n    concat(pipeline)\n    {\n        if(pipeline instanceof SpeedyPipeline) {\n            this._operations = this._operations.concat(pipeline._operations);\n            return this;\n        }\n\n        throw new IllegalArgumentError(`Invalid argument \"${pipeline}\" given to SpeedyPipeline.concatenate()`);\n    }\n\n\n    // =====================================================\n    //               COLOR CONVERSIONS\n    // =====================================================\n\n    /**\n     * Convert to a color space\n     * @param {string} [colorSpace] 'greyscale' | 'grayscale'\n     * @returns {SpeedyPipeline}\n     */\n    convertTo(colorSpace = null)\n    {\n        if(colorSpace == 'greyscale' || colorSpace == 'grayscale') {\n            return this._spawn(\n                new PipelineOperation.ConvertToGreyscale()\n            );\n        }\n\n        throw new IllegalArgumentError(`Can't convert to unknown color space: \"${colorSpace}\"`);\n    }\n\n\n\n    // =====================================================\n    //               IMAGE FILTERING\n    // =====================================================\n\n    /**\n     * Image smoothing\n     * @param {object} [options]\n     * @returns {SpeedyPipeline}\n     */\n    blur(options = {})\n    {\n        return this._spawn(\n            new PipelineOperation.Blur(options)\n        );\n    }\n\n    /**\n     * Image convolution\n     * @param {Array<number>} kernel\n     * @param {number} [divisor]\n     * @returns {SpeedyPipeline}\n     */\n    convolve(kernel, divisor = 1.0)\n    {\n        return this._spawn(\n            new PipelineOperation.Convolve(kernel, divisor)\n        );\n    }\n\n    /**\n     * Image normalization\n     * @param {object} [options]\n     * @returns {SpeedyPipeline}\n     */\n    normalize(options = {})\n    {\n        return this._spawn(\n            new PipelineOperation.Normalize(options)\n        );\n    }\n\n    /**\n     * Nightvision\n     * @param {object|Function<object>} [options]\n     * @returns {SpeedyPipeline}\n     */\n    nightvision(options = {})\n    {\n        return this._spawn(\n            new PipelineOperation.Nightvision(options)\n        );\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy.js\n * Speedy's main class\n */\n\nimport { SpeedyMedia } from './speedy-media';\nimport { SpeedyPipeline } from './speedy-pipeline';\nimport { FPSCounter } from '../utils/fps-counter';\nimport { SpeedyFeatureDetectorFactory } from './speedy-feature-detector-factory';\nimport { SpeedyFeatureTrackerFactory } from './speedy-feature-tracker-factory';\nimport { SpeedyFeatureDescriptorFactory } from './speedy-feature-descriptor-factory';\nimport { SpeedyFlags } from './speedy-flags';\nimport { SpeedyVector2 } from './math/speedy-vector';\nimport { SpeedyMatrixExprFactory } from './math/matrix-expressions';\nimport { SpeedyPromise } from '../utils/speedy-promise';\nimport { IllegalArgumentError } from '../utils/errors';\n\n// Constants\nconst matrixExprFactory = new SpeedyMatrixExprFactory();\n\n/**\n * Speedy's main class\n */\nexport class Speedy\n{\n    /**\n     * Loads a SpeedyMedia object based on the provided source element\n     * @param {HTMLImageElement|HTMLVideoElement|HTMLCanvasElement} sourceElement The source media\n     * @param {object} [options] Additional options for advanced configuration\n     * @returns {Promise<SpeedyMedia>}\n     */\n    static load(sourceElement, options = { })\n    {\n        return SpeedyMedia.load(sourceElement, options);\n    }\n\n    /**\n     * Loads a camera stream\n     * @param {number} [width] width of the stream\n     * @param {number} [height] height of the stream\n     * @param {object} [cameraOptions] additional options to pass to getUserMedia()\n     * @param {object} [mediaOptions] additional options for advanced configuration of the SpeedyMedia\n     * @returns {Promise<SpeedyMedia>}\n     */\n    static camera(width = 426, height = 240, cameraOptions = {}, mediaOptions = {})\n    {\n        return SpeedyMedia.loadCameraStream(width, height, cameraOptions, mediaOptions);\n    }\n\n    /**\n     * Creates a new pipeline\n     * @returns {SpeedyPipeline}\n     */\n    static pipeline()\n    {\n        return new SpeedyPipeline();\n    }\n\n    /**\n     * The version of the library\n     * @returns {string} The version of the library\n     */\n    static get version()\n    {\n        return __SPEEDY_VERSION__;\n    }\n\n    /**\n     * The FPS rate\n     * @returns {number} Frames per second (FPS)\n     */\n    static get fps()\n    {\n        return FPSCounter.instance.fps;\n    }\n\n    /**\n     * Feature detectors\n     * @returns {SpeedyFeatureDetectorFactory}\n     */\n    static get FeatureDetector()\n    {\n        return SpeedyFeatureDetectorFactory;\n    }\n\n    /**\n     * Feature trackers\n     * @returns {SpeedyFeatureTrackerFactory}\n     */\n    static get FeatureTracker()\n    {\n        return SpeedyFeatureTrackerFactory;\n    }\n\n    /**\n     * Feature descriptors\n     * @returns {SpeedyFeatureDescriptorFactory}\n     */\n    static get FeatureDescriptor()\n    {\n        return SpeedyFeatureDescriptorFactory;\n    }\n\n    /**\n     * Create a 2D vector\n     * @param {number} x\n     * @param {number} [y]\n     */\n    static Vector2(x, y = x)\n    {\n        return new SpeedyVector2(x, y);\n    }\n\n    /**\n     * Create a matrix expression\n     * @returns {SpeedyMatrixExprFactory}\n     */\n    static get Matrix()\n    {\n        return matrixExprFactory;\n    }\n\n    /**\n     * Speedy Promises\n     * @returns {Function}\n     */\n    static get Promise()\n    {\n        return SpeedyPromise;\n    }\n}\n\n// Mix SpeedyFlags with Speedy\nObject.assign(Speedy.constructor.prototype, SpeedyFlags);","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * gl-utils.js\n * WebGL utilities\n */\n\nimport { Utils } from '../utils/utils';\nimport { SpeedyPromise } from '../utils/speedy-promise';\nimport { GLError, IllegalArgumentError, IllegalOperationError } from '../utils/errors';\n\n\n\n//\n// Constants\n//\nconst isFirefox = navigator.userAgent.includes('Firefox');\n\n\n\n/**\n * WebGL Utilities\n */\nexport class GLUtils\n{\n    /**\n     * Get an error object describing the latest WebGL error\n     * @param {WebGL2RenderingContext} gl \n     * @returns {GLError}\n     */\n    static getError(gl)\n    {\n        const recognizedErrors = [\n            'NO_ERROR',\n            'INVALID_ENUM',\n            'INVALID_VALUE',\n            'INVALID_OPERATION',\n            'INVALID_FRAMEBUFFER_OPERATION',\n            'OUT_OF_MEMORY',\n            'CONTEXT_LOST_WEBGL',\n        ];\n\n        const glError = gl.getError();\n        const message = recognizedErrors.find(error => gl[error] == glError) || 'Unknown';\n        return new GLError(message);\n    }\n\n    /**\n     * Create a shader\n     * @param {WebGL2RenderingContext} gl\n     * @param {number} type\n     * @param {string} source\n     * @returns {WebGLShader}\n     */\n    static createShader(gl, type, source)\n    {\n        const shader = gl.createShader(type);\n\n        gl.shaderSource(shader, source);\n        gl.compileShader(shader);\n\n        return shader;\n    }\n\n    /**\n     * Create a vertex-shader + fragment-shader program\n     * @param {WebGL2RenderingContext} gl\n     * @param {string} vertexShaderSource\n     * @param {string} fragmentShaderSource\n     * @returns {WebGLProgram}\n     */\n    static createProgram(gl, vertexShaderSource, fragmentShaderSource)\n    {\n        const program = gl.createProgram();\n        const vertexShader = GLUtils.createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n        const fragmentShader = GLUtils.createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n\n        gl.attachShader(program, vertexShader);\n        gl.attachShader(program, fragmentShader);\n        gl.linkProgram(program);\n        gl.validateProgram(program);\n\n        // error?\n        if(!gl.getProgramParameter(program, gl.LINK_STATUS) && !gl.isContextLost()) {\n            const errors = [\n                gl.getShaderInfoLog(fragmentShader),\n                gl.getShaderInfoLog(vertexShader),\n                gl.getProgramInfoLog(program),\n            ];\n\n            gl.deleteProgram(program);\n            gl.deleteShader(fragmentShader);\n            gl.deleteShader(vertexShader);\n\n            // display error\n            const spaces = i => Math.max(0, 2 - Math.floor(Math.log10(i)));\n            const col = k => Array(spaces(k)).fill(' ').join('') + k + '. ';\n            const formattedSource = fragmentShaderSource.split('\\n')\n                .map((line, no) => col(1+no) + line)\n                .join('\\n');\n\n            throw new GLError(\n                `Can't create shader.\\n\\n` +\n                `---------- ERROR ----------\\n` +\n                errors.join('\\n') + '\\n\\n' +\n                `---------- SOURCE CODE ----------\\n` +\n                formattedSource\n            );\n        }\n\n        return program;\n    }\n\n    /**\n     * Create a WebGL texture\n     * @param {WebGL2RenderingContext} gl \n     * @param {number} width in pixels\n     * @param {number} height in pixels\n     * @returns {WebGLTexture}\n     */\n    static createTexture(gl, width, height)\n    {\n        // validate dimensions\n        if(width <= 0 || height <= 0)\n            throw new IllegalArgumentError(`Invalid dimensions given to createTexture()`);\n\n        // create texture\n        const texture = gl.createTexture();\n\n        // setup texture\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT);\n        //gl.texStorage2D(gl.TEXTURE_2D, 1, gl.RGBA8, width, height);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA8, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n\n        // unbind & return\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        return texture;\n    }\n\n    /**\n     * Destroys a WebGL texture\n     * @param {WebGL2RenderingContext} gl \n     * @param {WebGLTexture} texture \n     * @returns {null}\n     */\n    static destroyTexture(gl, texture)\n    {\n        gl.deleteTexture(texture);\n        return null;\n    }\n\n    /**\n     * Upload pixel data to a WebGL texture\n     * @param {WebGL2RenderingContext} gl \n     * @param {WebGLTexture} texture \n     * @param {GLsizei} width texture width\n     * @param {GLsizei} height texture height\n     * @param {ImageBitmap|ImageData|ArrayBufferView|HTMLImageElement|HTMLVideoElement|HTMLCanvasElement} pixels \n     * @param {GLint} [lod] mipmap level-of-detail\n     * @returns {WebGLTexture} texture\n     */\n    static uploadToTexture(gl, texture, width, height, pixels, lod = 0)\n    {\n        // Prefer calling uploadToTexture() before gl.useProgram() to avoid the\n        // needless switching of GL programs internally. See also:\n        // https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n\n        /*\n        // slower than texImage2D, unlike the spec?\n        gl.texSubImage2D(gl.TEXTURE_2D,     // target\n                         lod,               // mip level\n                         0,                 // x-offset\n                         0,                 // y-offset\n                         width,             // texture width\n                         height,            // texture height\n                         gl.RGBA,           // source format\n                         gl.UNSIGNED_BYTE,  // source type\n                         pixels);           // source data\n        */\n\n        gl.texImage2D(gl.TEXTURE_2D,        // target\n                      lod,                  // mip level\n                      gl.RGBA8,             // internal format\n                      width,              // texture width\n                      height,             // texture height\n                      0,                  // border\n                      gl.RGBA,              // source format\n                      gl.UNSIGNED_BYTE,     // source type\n                      pixels);              // source data\n\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        return texture;\n    }\n\n    /**\n     * Copy data from a framebuffer into a texture\n     * @param {WebGL2RenderingContext} gl\n     * @param {WebGLFramebuffer} fbo we'll read the data from this\n     * @param {WebGLTexture} texture destination texture\n     * @param {GLint} x xpos (where to start copying)\n     * @param {GLint} y ypos (where to start copying)\n     * @param {GLsizei} width width of the texture\n     * @param {GLsizei} height height of the texture\n     * @param {GLint} [lod] mipmap level-of-detail\n     * @returns {WebGLTexture} texture\n     */\n    static copyToTexture(gl, fbo, texture, x, y, width, height, lod = 0)\n    {\n        gl.activeTexture(gl.TEXTURE0);\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n\n        gl.copyTexSubImage2D(\n            gl.TEXTURE_2D, // target\n            lod, // mipmap level\n            0, // xoffset\n            0, // yoffset\n            x, // xpos (where to start copying)\n            y, // ypos (where to start copying)\n            width, // width of the texture\n            height // height of the texture\n        );\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        gl.bindTexture(gl.TEXTURE_2D, null);\n\n        return texture;\n    }\n\n    /**\n     * Generate texture mipmap with bilinear interpolation\n     * @param {WebGL2RenderingContext} gl \n     * @param {WebGLTexture} texture \n     */\n    static generateMipmap(gl, texture)\n    {\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);\n        gl.generateMipmap(gl.TEXTURE_2D);\n        gl.bindTexture(gl.TEXTURE_2D, null);\n    }\n\n    // bind the textures and assign their numbers\n    // textureMap: { 'textureName': <texture> , ... }\n    // locationMap: { 'textureName': <uniformLocation> , ... }\n    static bindTextures(gl, textureMap, locationMap)\n    {\n        const names = Object.keys(textureMap);\n\n        if(gl.isContextLost())\n            return;\n\n        if(names.length > gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS)\n            throw new GLError(`Can't bind ${names.length} textures to a program: max is ${gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS}`);\n\n        for(let i = 0; i < names.length; i++) {\n            gl.activeTexture(gl.TEXTURE0 + i);\n            gl.bindTexture(gl.TEXTURE_2D, textureMap[names[i]]);\n            gl.uniform1i(locationMap[names[i]], i);\n        }\n    }\n\n    /**\n     * Creates a framebuffer object (FBO) associated with an existing texture\n     * @param {WebGL2RenderingContext} gl \n     * @param {WebGLTexture} texture \n     * @returns {WebGLFramebuffer}\n     */\n    static createFramebuffer(gl, texture)\n    {\n        const fbo = gl.createFramebuffer();\n\n        // setup framebuffer\n        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n        gl.framebufferTexture2D(gl.FRAMEBUFFER,         // target\n                                gl.COLOR_ATTACHMENT0,   // color buffer\n                                gl.TEXTURE_2D,          // tex target\n                                texture,                // texture\n                                0);                     // mipmap level\n\n        // check for errors\n        const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n        if(status != gl.FRAMEBUFFER_COMPLETE) {\n            const error = (() => (([\n                'FRAMEBUFFER_UNSUPPORTED',\n                'FRAMEBUFFER_INCOMPLETE_ATTACHMENT',\n                'FRAMEBUFFER_INCOMPLETE_DIMENSIONS',\n                'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT',\n                'FRAMEBUFFER_INCOMPLETE_MULTISAMPLE'\n            ].filter(err => gl[err] === status))[0] || 'unknown error'))();\n            throw new GLError(`Can't create framebuffer: ${error} (${status})`);\n        }\n\n        // unbind & return\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        return fbo;\n    }\n\n    /**\n     * Destroys a framebuffer object (FBO)\n     * @param {WebGL2RenderingContext} gl\n     * @param {WebGLFramebuffer} fbo \n     * @returns {null}\n     */\n    static destroyFramebuffer(gl, fbo)\n    {\n        gl.deleteFramebuffer(fbo);\n        return null;\n    }\n\n    /**\n     * Waits for a sync object to become signaled\n     * @param {WebGL2RenderingContext} gl\n     * @param {WebGLSync} sync sync object\n     * @param {GLbitfield} [flags] may be gl.SYNC_FLUSH_COMMANDS_BIT or 0\n     * @returns {SpeedyPromise} a promise that resolves as soon as the sync object becomes signaled\n     */\n    static clientWaitAsync(gl, sync, flags = 0)\n    {\n        this._checkStatus = this._checkStatus || (this._checkStatus = function checkStatus(gl, sync, flags, resolve, reject) {\n            const status = gl.clientWaitSync(sync, flags, 0);\n            if(status == gl.TIMEOUT_EXPIRED) {\n                Utils.setZeroTimeout(() => checkStatus.call(this, gl, sync, flags, resolve, reject)); // better performance (preferred)\n                //setTimeout(() => checkStatus.call(this, gl, sync, flags, resolve, reject), 0); // easier on the CPU\n            }\n            else if(status == gl.WAIT_FAILED) {\n                if(isFirefox && gl.getError() == gl.NO_ERROR) { // firefox bug?\n                    Utils.setZeroTimeout(() => checkStatus.call(this, gl, sync, flags, resolve, reject));\n                    //setTimeout(() => checkStatus.call(this, gl, sync, flags, resolve, reject), 0);\n                }\n                else {\n                    reject(GLUtils.getError(gl));\n                }\n            }\n            else {\n                resolve();\n            }\n        });\n\n        return new SpeedyPromise((resolve, reject) => {\n            this._checkStatus(gl, sync, flags, resolve, reject);\n        });\n    }\n\n    /**\n     * Reads data from a WebGLBuffer into an ArrayBufferView\n     * This is like gl.getBufferSubData(), but async\n     * @param {WebGL2RenderingContext} gl\n     * @param {WebGLBuffer} glBuffer will be bound to target\n     * @param {GLenum} target\n     * @param {GLintptr} srcByteOffset usually 0\n     * @param {ArrayBufferView} destBuffer\n     * @param {GLuint} [destOffset]\n     * @param {GLuint} [length]\n     * @returns {SpeedyPromise<number>} a promise that resolves to the time it took to read the data (in ms)\n     */\n    static getBufferSubDataAsync(gl, glBuffer, target, srcByteOffset, destBuffer, destOffset = 0, length = 0)\n    {\n        const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);\n        const start = performance.now();\n\n        // empty internal command queues and send them to the GPU asap\n        gl.flush(); // make sure the sync command is read\n\n        // wait for the commands to be processed by the GPU\n        return GLUtils.clientWaitAsync(gl, sync).then(() => {\n            gl.bindBuffer(target, glBuffer);\n            gl.getBufferSubData(target, srcByteOffset, destBuffer, destOffset, length);\n            gl.bindBuffer(target, null);\n            return performance.now() - start;\n        }).catch(err => {\n            throw new IllegalOperationError(`Can't getBufferSubDataAsync(): error in clientWaitAsync()`, err);\n        }).finally(() => {\n            gl.deleteSync(sync);\n        });\n    }\n\n    /**\n     * Read pixels to a Uint8Array using a Pixel Buffer Object (PBO)\n     * You may optionally specify a FBO to read pixels from a texture\n     * @param {WebGL2RenderingContext} gl\n     * @param {Uint8Array} arrayBuffer with size >= width * height * 4\n     * @param {GLint} x\n     * @param {GLint} y\n     * @param {GLsizei} width\n     * @param {GLsizei} height\n     * @param {WebGLFramebuffer} [fbo]\n     * @returns {SpeedyPromise<number>} a promise that resolves to the time it took to read the data (in ms)\n     */\n    static readPixelsViaPBO(gl, arrayBuffer, x, y, width, height, fbo = null)\n    {\n        // create temp buffer\n        const pbo = gl.createBuffer();\n\n        // validate arrayBuffer\n        if(!(arrayBuffer.byteLength >= width * height * 4))\n            throw new IllegalArgumentError(`Can't read pixels: invalid buffer size`);\n\n        // bind the PBO\n        gl.bindBuffer(gl.PIXEL_PACK_BUFFER, pbo);\n        gl.bufferData(gl.PIXEL_PACK_BUFFER, arrayBuffer.byteLength, gl.STREAM_READ);\n\n        // read pixels into the PBO\n        if(fbo) {\n            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n            gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, 0);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        }\n        else {\n            gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, 0);\n        }\n\n        // unbind the PBO\n        gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);\n\n        // wait for DMA transfer\n        return GLUtils.getBufferSubDataAsync(gl, pbo,\n            gl.PIXEL_PACK_BUFFER,\n            0,\n            arrayBuffer,\n            0,\n            0\n        ).then(timeInMs => {\n            return timeInMs;\n        }).catch(err => {\n            throw new IllegalOperationError(`Can't read pixels`, err);\n        }).finally(() => {\n            gl.deleteBuffer(pbo);\n        });\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * colors.js\n * Color routines & conversion algorithms\n */\n\nimport { SpeedyProgramGroup } from '../speedy-program-group';\nimport { importShader } from '../shader-declaration';\n\n\n\n//\n// Shaders\n//\n\n// Convert to greyscale\nconst rgb2grey = importShader('colors/rgb2grey.glsl').withArguments('image');\n\n\n\n\n/**\n * GPUColors\n * Color routines & conversion algorithms\n */\nexport class GPUColors extends SpeedyProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            // convert to greyscale\n            .declare('rgb2grey', rgb2grey)\n        ;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * encoders.js\n * Texture encoders\n */\n\nimport { SpeedyProgramGroup } from '../speedy-program-group';\nimport { importShader } from '../shader-declaration';\nimport { SpeedyFeature } from '../../core/speedy-feature';\nimport { PixelComponent } from '../../utils/types';\nimport { Utils } from '../../utils/utils'\nimport { SpeedyPromise } from '../../utils/speedy-promise'\nimport { IllegalOperationError, NotSupportedError } from '../../utils/errors';\nimport {\n    PYRAMID_MAX_LEVELS, LOG2_PYRAMID_MAX_SCALE,\n    FIX_RESOLUTION, MAX_TEXTURE_LENGTH,\n    KPF_ORIENTED, KPF_DISCARD,\n    MAX_DESCRIPTOR_SIZE, MIN_KEYPOINT_SIZE,\n} from '../../utils/globals';\n\n// We won't admit more than MAX_KEYPOINTS per media.\n// The larger this value is, the more data we need to transfer from the GPU.\nconst MIN_PIXELS_PER_KEYPOINT = MIN_KEYPOINT_SIZE / 4; // encodes a keypoint header\nconst MIN_ENCODER_LENGTH = 16; // storage for 16*16/MIN_PIXELS_PER_KEYPOINT <= 128 keypoints\nconst MAX_ENCODER_LENGTH = 300; // in pixels (if too large, WebGL may lose context - so be careful!)\nconst INITIAL_ENCODER_LENGTH = MIN_ENCODER_LENGTH; // pick a small number to reduce processing load and not crash things on mobile (WebGL lost context)\nconst MAX_KEYPOINTS = 8192; // can't detect more than this number of keypoints per frame\nconst UBO_MAX_BYTES = 16384; // UBOs can hold at least 16KB of data: gl.MAX_UNIFORM_BLOCK_SIZE >= 16384 according to the GL ES 3 reference\nconst KEYPOINT_BUFFER_LENGTH = (UBO_MAX_BYTES / 16) | 0; // maximum number of keypoints that can be uploaded to the GPU via UBOs (each keypoint uses 16 bytes)\nconst ENCODER_PASSES = 8; // number of passes of the keypoint encoder: directly impacts performance\nconst LONG_SKIP_OFFSET_PASSES = 2; // number of passes of the long skip offsets shader\nconst MAX_SKIP_OFFSET_ITERATIONS = [ 32, 32 ]; // used when computing skip offsets\n\n\n\n\n//\n// Shaders\n//\n\n// encode keypoint offsets: maxIterations is an experimentally determined integer\nconst encodeKeypointSkipOffsets = importShader('encoders/encode-keypoint-offsets.glsl')\n                                 .withArguments('image', 'imageSize')\n                                 .withDefines({ 'MAX_ITERATIONS': MAX_SKIP_OFFSET_ITERATIONS[0] });\n\n// encode long offsets for improved performance\nconst encodeKeypointLongSkipOffsets = importShader('encoders/encode-keypoint-long-offsets.glsl')\n                                     .withArguments('offsetsImage', 'imageSize')\n                                     .withDefines({ 'MAX_ITERATIONS': MAX_SKIP_OFFSET_ITERATIONS[1] });\n\n// encode keypoints\nconst encodeKeypoints = importShader('encoders/encode-keypoints.glsl')\n                       .withArguments('offsetsImage', 'encodedKeypoints', 'imageSize', 'passId', 'numPasses', 'descriptorSize', 'extraSize', 'encoderLength');\n\n// resize encoded keypoints\nconst resizeEncodedKeypoints = importShader('encoders/resize-encoded-keypoints.glsl')\n                              .withArguments('inputTexture', 'inputDescriptorSize', 'inputExtraSize', 'inputEncoderLength', 'outputDescriptorSize', 'outputExtraSize', 'outputEncoderLength');\n\n// helper for downloading the keypoints\nconst downloadKeypoints = importShader('utils/identity.glsl')\n                         .withArguments('image');\n\n// upload keypoints via UBO\nconst uploadKeypoints = importShader('encoders/upload-keypoints.glsl')\n                       .withArguments('keypointCount', 'encoderLength', 'descriptorSize', 'extraSize')\n                       .withDefines({\n                           'KEYPOINT_BUFFER_LENGTH': KEYPOINT_BUFFER_LENGTH\n                       });\n\n\n\n\n/**\n * GPUEncoders\n * Keypoint encoding\n */\nexport class GPUEncoders extends SpeedyProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            // encode skip offsets\n            .declare('_encodeKeypointSkipOffsets', encodeKeypointSkipOffsets)\n            .declare('_encodeKeypointLongSkipOffsets', encodeKeypointLongSkipOffsets, {\n                ...this.program.usesPingpongRendering()\n            })\n\n            // tiny textures\n            .declare('_encodeKeypoints', encodeKeypoints, {\n                ...this.program.hasTextureSize(INITIAL_ENCODER_LENGTH, INITIAL_ENCODER_LENGTH),\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('_resizeEncodedKeypoints', resizeEncodedKeypoints, {\n                ...this.program.hasTextureSize(INITIAL_ENCODER_LENGTH, INITIAL_ENCODER_LENGTH)\n            })\n            .declare('_downloadKeypoints', downloadKeypoints, {\n                ...this.program.hasTextureSize(INITIAL_ENCODER_LENGTH, INITIAL_ENCODER_LENGTH)\n            })\n            .declare('_uploadKeypoints', uploadKeypoints, {\n                ...this.program.hasTextureSize(INITIAL_ENCODER_LENGTH, INITIAL_ENCODER_LENGTH)\n            })\n        ;\n\n\n\n        // setup internal data\n\n        /** @type {number} length of the tiny encoding textures */\n        this._encoderLength = INITIAL_ENCODER_LENGTH;\n\n        /** @type {number} how many keypoints we can encode at the moment */\n        this._keypointCapacity = (INITIAL_ENCODER_LENGTH * INITIAL_ENCODER_LENGTH / MIN_KEYPOINT_SIZE) | 0;\n\n        /** @type {Float32Array} UBO stuff */\n        this._uploadBuffer = null; // lazy spawn\n    }\n\n    /**\n     * Keypoint encoder length\n     * @returns {number}\n     */\n    get encoderLength()\n    {\n        return this._encoderLength;\n    }\n\n    /**\n     * Optimizes the keypoint encoder for an expected number of keypoints\n     * @param {number} maxKeypointCount expected maximum number of keypoints\n     * @param {number} descriptorSize in bytes\n     * @param {number} extraSize in bytes\n     * @returns {boolean} true if the encoder has been optimized\n     */\n    optimize(maxKeypointCount, descriptorSize, extraSize)\n    {\n        const keypointCapacity = Math.ceil(maxKeypointCount); // ensure this is an integer\n        const newEncoderLength = this._minimumEncoderLength(keypointCapacity, descriptorSize, extraSize);\n        const oldEncoderLength = this._encoderLength;\n\n        this._encoderLength = newEncoderLength;\n        this._keypointCapacity = keypointCapacity;\n\n        return (newEncoderLength - oldEncoderLength) != 0;\n    }\n\n    /**\n     * Ensures that the encoder has enough capacity to deliver the specified number of keypoints\n     * @param {number} keypointCapacity the number of keypoints\n     * @param {number} descriptorSize in bytes\n     * @param {number} extraSize in bytes\n     * @returns {boolean} true if there was any change to the length of the encoder\n     */\n    reserveSpace(keypointCapacity, descriptorSize, extraSize)\n    {\n        // resize if not enough space\n        if(this._minimumEncoderLength(keypointCapacity, descriptorSize, extraSize) > this._encoderLength)\n            return this.optimize(keypointCapacity, descriptorSize, extraSize);\n\n        return false;\n    }\n\n    /**\n     * Encodes the keypoints of an image into a compressed texture\n     * @param {SpeedyTexture} corners texture with corners\n     * @param {number} descriptorSize in bytes\n     * @param {number} extraSize in bytes\n     * @returns {SpeedyTexture} texture with encoded keypoints\n     */\n    encodeKeypoints(corners, descriptorSize, extraSize)\n    {\n        // parameters\n        const encoderLength = this._encoderLength;\n        const imageSize = [ this._width, this._height ];\n\n        // encode skip offsets\n        let offsets = this._encodeKeypointSkipOffsets(corners, imageSize);\n        for(let i = 0; i < LONG_SKIP_OFFSET_PASSES; i++) // meant to boost performance\n            offsets = this._encodeKeypointLongSkipOffsets(offsets, imageSize);\n\n        /*\n        // debug: view corners\n        let cornerview = corners;\n        cornerview = this._gpu.programs.utils.fillComponents(cornerview, PixelComponent.GREEN, 0);\n        cornerview = this._gpu.programs.utils.identity(cornerview);\n        cornerview = this._gpu.programs.utils.fillComponents(cornerview, PixelComponent.ALPHA, 1);\n        this._gpu.programs.utils.output(cornerview);\n        if(!window._ww) document.body.appendChild(this._gpu.canvas);\n        window._ww = 1;\n        */\n\n        // encode keypoints\n        const numPasses = ENCODER_PASSES;\n        const pixelsPerKeypointHeader = MIN_PIXELS_PER_KEYPOINT;\n        const headerEncoderLength = Math.max(MIN_ENCODER_LENGTH, Math.ceil(Math.sqrt(this._keypointCapacity * pixelsPerKeypointHeader)));\n        this._encodeKeypoints.resize(headerEncoderLength, headerEncoderLength);\n        let encodedKeypointHeaders = this._encodeKeypoints.clear(0, 0, 0, 0);\n        for(let passId = 0; passId < numPasses; passId++)\n            encodedKeypointHeaders = this._encodeKeypoints(offsets, encodedKeypointHeaders, imageSize, passId, numPasses, 0, 0, headerEncoderLength);\n\n        // transfer keypoints to a elastic tiny texture with storage for descriptors & extra data\n        this._resizeEncodedKeypoints.resize(encoderLength, encoderLength);\n        return this._resizeEncodedKeypoints(encodedKeypointHeaders, 0, 0, headerEncoderLength, descriptorSize, extraSize, encoderLength);\n    }\n\n    /**\n     * Decodes the keypoints, given a flattened image of encoded pixels\n     * @param {Uint8Array[]} pixels pixels in the [r,g,b,a,...] format\n     * @param {number} descriptorSize in bytes\n     * @param {number} extraSize in bytes\n     * @returns {SpeedyFeature[]} keypoints\n     */\n    decodeKeypoints(pixels, descriptorSize, extraSize)\n    {\n        const pixelsPerKeypoint = (MIN_KEYPOINT_SIZE + descriptorSize + extraSize) / 4;\n        let x, y, lod, rotation, score, flags, extraBytes, descriptorBytes;\n        let hasLod, hasRotation;\n        const keypoints = [];\n\n        // how many bytes should we read?\n        const e = this._encoderLength;\n        const e2 = e * e * pixelsPerKeypoint * 4;\n        const size = Math.min(pixels.length, e2);\n\n        // for each encoded keypoint\n        for(let i = 0; i < size; i += 4 /* RGBA */ * pixelsPerKeypoint) {\n            // extract fixed-point coordinates\n            x = (pixels[i+1] << 8) | pixels[i];\n            y = (pixels[i+3] << 8) | pixels[i+2];\n            if(x >= 0xFFFF && y >= 0xFFFF) // if end of list\n                break;\n\n            // We've cleared the texture to black.\n            // Likely to be incorrect black pixels\n            // due to resize. Bad for encoderLength\n            if(x + y == 0 && pixels[i+6] == 0)\n                continue; // discard, it's noise\n\n            // convert from fixed-point\n            x /= FIX_RESOLUTION;\n            y /= FIX_RESOLUTION;\n\n            // extract flags\n            flags = pixels[i+7];\n\n            // extract LOD\n            hasLod = (pixels[i+4] < 255);\n            lod = !hasLod ? 0.0 :\n                -LOG2_PYRAMID_MAX_SCALE + (LOG2_PYRAMID_MAX_SCALE + PYRAMID_MAX_LEVELS) * pixels[i+4] / 255.0;\n\n            // extract orientation\n            hasRotation = (flags & KPF_ORIENTED != 0);\n            rotation = !hasRotation ? 0.0 :\n                ((2 * pixels[i+5]) / 255.0 - 1.0) * Math.PI;\n\n            // extract score\n            score = pixels[i+6] / 255.0;\n\n            // extra bytes\n            extraBytes = (extraSize > 0) ? new Uint8Array(\n                pixels.slice(8 + i, 8 + i + extraSize)\n            ) : null;\n\n            // descriptor bytes\n            descriptorBytes = (descriptorSize > 0) ? new Uint8Array(\n                pixels.slice(8 + i + extraSize, 8 + i + extraSize + descriptorSize)\n            ) : null;\n\n            // something is off with the encoder length\n            if(\n                (descriptorSize > 0 && descriptorBytes.length < descriptorSize) ||\n                (extraSize > 0 && extraBytes.length < extraSize)\n            )\n                continue; // discard\n\n            // register keypoint\n            keypoints.push(\n                new SpeedyFeature(x, y, lod, rotation, score, flags, extraBytes, descriptorBytes)\n            );\n        }\n\n        /*\n        // developer's secret ;)\n        // reset the tuner\n        if(keypoints.length == 0) {\n            if(this._tuner.finished())\n                this._tuner.reset();\n        }\n        */\n\n        // done!\n        return keypoints;\n    }\n\n    /**\n     * Download RAW encoded keypoint data from the GPU - this is a bottleneck!\n     * @param {SpeedyTexture} encodedKeypoints texture with keypoints that have already been encoded\n     * @param {boolean} [useBufferedDownloads] download keypoints detected in the previous framestep (optimization)\n     * @returns {SpeedyPromise<Uint8Array[]>} pixels in the [r,g,b,a, ...] format\n     */\n    downloadEncodedKeypoints(encodedKeypoints, useBufferedDownloads = true)\n    {\n        // helper shader for reading the data\n        this._downloadKeypoints.resize(this._encoderLength, this._encoderLength);\n        this._downloadKeypoints(encodedKeypoints);\n\n        // read data from the GPU\n        return this._downloadKeypoints.readPixelsAsync(useBufferedDownloads).catch(err => {\n            return new IllegalOperationError(`Can't download encoded keypoint texture`, err);\n        });\n    }\n\n    /**\n     * Upload keypoints to the GPU\n     * The descriptor & orientation of the keypoints will be lost\n     * (need to recalculate)\n     * @param {SpeedyFeature[]} keypoints\n     * @param {number} descriptorSize in bytes\n     * @param {number} extraSize in bytes\n     * @returns {SpeedyTexture} encodedKeypoints\n     */\n    uploadKeypoints(keypoints, descriptorSize, extraSize)\n    {\n        // Too many keypoints?\n        const keypointCount = keypoints.length;\n        if(keypointCount > KEYPOINT_BUFFER_LENGTH) {\n            // TODO: multipass\n            throw new NotSupportedError(`Can't upload ${keypointCount} keypoints: maximum is currently ${KEYPOINT_BUFFER_LENGTH}`);\n        }\n\n        // Create a buffer for uploading the data\n        if(this._uploadBuffer === null) {\n            const sizeofVec4 = Float32Array.BYTES_PER_ELEMENT * 4; // 16\n            const internalBuffer = new ArrayBuffer(sizeofVec4 * KEYPOINT_BUFFER_LENGTH);\n            Utils.assert(internalBuffer.byteLength <= UBO_MAX_BYTES);\n            this._uploadBuffer = new Float32Array(internalBuffer);\n        }\n\n        // Format data as follows: (xpos, ypos, lod, score)\n        for(let i = 0; i < keypointCount; i++) {\n            const keypoint = keypoints[i];\n            const j = i * 4;\n\n            // this will be uploaded into a vec4\n            this._uploadBuffer[j]   = +(keypoint.x) || 0;\n            this._uploadBuffer[j+1] = +(keypoint.y) || 0;\n            this._uploadBuffer[j+2] = +(keypoint.lod) || 0;\n            this._uploadBuffer[j+3] = +(keypoint.score) || 0;\n        }\n\n        // Reserve space for the keypoints\n        this.reserveSpace(keypointCount, descriptorSize, extraSize);\n\n        // Upload data\n        this._uploadKeypoints.resize(this._encoderLength, this._encoderLength);\n        this._uploadKeypoints.setUBO('KeypointBuffer', this._uploadBuffer);\n        return this._uploadKeypoints(keypointCount, this._encoderLength, descriptorSize, extraSize);\n    }\n\n    /**\n     * The minimum encoder length for a set of keypoints\n     * @param {number} keypointCount\n     * @param {number} descriptorSize\n     * @param {number} extraSize\n     * @returns {number} between 1 and MAX_ENCODER_LENGTH\n     */\n    _minimumEncoderLength(keypointCount, descriptorSize, extraSize)\n    {\n        const clampedKeypointCount = Math.max(0, Math.min(Math.ceil(keypointCount), MAX_KEYPOINTS));\n        const pixelsPerKeypoint = Math.ceil((MIN_KEYPOINT_SIZE + descriptorSize + extraSize) / 4);\n        const len = Math.ceil(Math.sqrt(clampedKeypointCount * pixelsPerKeypoint));\n\n        return Math.max(MIN_ENCODER_LENGTH, Math.min(len, MAX_ENCODER_LENGTH));\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * enhancements.js\n * Image enhancement methods\n */\n\nimport { SpeedyProgramGroup } from '../speedy-program-group';\nimport { importShader } from '../shader-declaration';\nimport { convX, convY } from '../shaders/filters/convolution';\nimport { PixelComponent } from '../../utils/types';\nimport { Utils } from '../../utils/utils';\nimport { IllegalArgumentError } from '../../utils/errors';\n\n\n//\n// Shaders\n//\n\n// Normalize image\nconst normalizeGreyscaleImage = importShader('enhancements/normalize-image.glsl')\n                               .withArguments('minmax2d', 'minValue', 'maxValue')\n                               .withDefines({ 'GREYSCALE': 1 });\nconst normalizeColoredImage = importShader('enhancements/normalize-image.glsl')\n                             .withArguments('minmax2dRGB', 'minValue', 'maxValue');\n\n// Nightvision\nconst nightvision = importShader('enhancements/nightvision.glsl')\n                   .withArguments('image', 'illuminationMap', 'gain', 'offset', 'decay');\nconst nightvisionGreyscale = importShader('enhancements/nightvision.glsl')\n                            .withArguments('image', 'illuminationMap', 'gain', 'offset', 'decay')\n                            .withDefines({ 'GREYSCALE': 1 });\n\n\n\n\n/**\n * GPUEnhancements\n * Image enhancement algorithms\n */\nexport class GPUEnhancements extends SpeedyProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            // normalize a greyscale image\n            .declare('_normalizeGreyscaleImage', normalizeGreyscaleImage)\n\n            // normalize a colored image\n            .declare('_normalizeColoredImage', normalizeColoredImage)\n\n            // nightvision\n            .declare('_nightvision', nightvision)\n            .declare('_nightvisionGreyscale', nightvisionGreyscale)\n            .compose('_illuminationMapLo', '_illuminationMapLoX', '_illuminationMapLoY')\n            .declare('_illuminationMapLoX', convX(Utils.gaussianKernel(80, 31)))\n            .declare('_illuminationMapLoY', convY(Utils.gaussianKernel(80, 31)))\n            .compose('_illuminationMap', '_illuminationMapX', '_illuminationMapY')\n            .declare('_illuminationMapX', convX(Utils.gaussianKernel(80, 63)))\n            .declare('_illuminationMapY', convY(Utils.gaussianKernel(80, 63)))\n            .compose('_illuminationMapHi', '_illuminationMapHiX', '_illuminationMapHiY')\n            .declare('_illuminationMapHiX', convX(Utils.gaussianKernel(80, 255)))\n            .declare('_illuminationMapHiY', convY(Utils.gaussianKernel(80, 255)))\n        ;\n    }\n\n    /**\n     * Normalize a greyscale image\n     * @param {SpeedyTexture} image greyscale image (RGB components are the same)\n     * @param {number} [minValue] minimum desired pixel intensity (from 0 to 255, inclusive)\n     * @param {number} [maxValue] maximum desired pixel intensity (from 0 to 255, inclusive)\n     * @returns {SpeedyTexture}\n     */\n    normalizeGreyscaleImage(image, minValue = 0, maxValue = 255)\n    {\n        const gpu = this._gpu;\n        const minmax2d = gpu.programs.utils._scanMinMax(image, PixelComponent.GREEN);\n        return this._normalizeGreyscaleImage(minmax2d, Math.min(minValue, maxValue), Math.max(minValue, maxValue));\n    }\n\n    /**\n     * Normalize a RGB image\n     * @param {SpeedyTexture} image\n     * @param {number} [minValue] minimum desired pixel intensity (from 0 to 255, inclusive)\n     * @param {number} [maxValue] maximum desired pixel intensity (from 0 to 255, inclusive)\n     * @returns {SpeedyTexture}\n     */\n    normalizeColoredImage(image, minValue = 0, maxValue = 255)\n    {\n        const gpu = this._gpu;\n        \n        // TODO: normalize on a luminance channel instead (e.g., use HSL color space)\n        const minmax2d = new Array(3);\n        minmax2d[0] = gpu.programs.utils.clone(gpu.programs.utils._scanMinMax(image, PixelComponent.RED));\n        minmax2d[1] = gpu.programs.utils.clone(gpu.programs.utils._scanMinMax(image, PixelComponent.GREEN));\n        minmax2d[2] = gpu.programs.utils._scanMinMax(image, PixelComponent.BLUE);\n\n        const normalized = this._normalizeColoredImage(minmax2d, Math.min(minValue, maxValue), Math.max(minValue, maxValue));\n\n        minmax2d[1].release();\n        minmax2d[0].release();\n\n        return normalized;\n    }\n\n    /**\n     * Nightvision filter: \"see in the dark\"\n     * @param {SpeedyTexture} image\n     * @param {number} [gain] typically in [0,1]; higher values => higher contrast\n     * @param {number} [offset] brightness, typically in [0,1]\n     * @param {number} [decay] gain decay, in the [0,1] range\n     * @param {string} [quality] \"high\" | \"medium\" | \"low\" (more quality -> more expensive)\n     * @param {boolean} [greyscale] use the greyscale variant of the algorithm\n     * @returns {SpeedyTexture}\n     */\n    nightvision(image, gain = 0.5, offset = 0.5, decay = 0.0, quality = 'medium', greyscale = false)\n    {\n        // compute illumination map\n        let illuminationMap = null;\n        if(quality == 'medium')\n            illuminationMap = this._illuminationMap(image);\n        else if(quality == 'high')\n            illuminationMap = this._illuminationMapHi(image);\n        else if(quality == 'low')\n            illuminationMap = this._illuminationMapLo(image);\n        else\n            throw new IllegalArgumentError(`Invalid quality level for nightvision: \"${quality}\"`);\n\n        // run nightvision\n        const strategy = greyscale ? this._nightvisionGreyscale : this._nightvision;\n        const enhancedImage = strategy(image, illuminationMap, gain, offset, decay);\n        return enhancedImage;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * filters.js\n * Image filtering on the GPU\n */\n\nimport { SpeedyProgramGroup } from '../speedy-program-group';\nimport { importShader } from '../shader-declaration';\nimport { convX, convY, texConvX, texConvY, texConv2D, createKernel2D, createKernel1D } from '../shaders/filters/convolution';\nimport { median } from '../shaders/filters/median';\nimport { Utils } from '../../utils/utils';\n\n\n\n//\n// Fast median filters\n//\n\n// Fast median filter: 3x3 window\nconst fastMedian3 = importShader('filters/fast-median.glsl')\n                   .withArguments('image')\n                   .withDefines({ 'WINDOW_SIZE': 3 });\n\n// Fast median filter: 5x5 window\nconst fastMedian5 = importShader('filters/fast-median.glsl')\n                   .withArguments('image')\n                   .withDefines({ 'WINDOW_SIZE': 5 });\n\n\n\n//\n// Utilities\n//\n\n// Handy conversion for Gaussian filters\nconst ksize2sigma = ksize => Math.max(1.0, ksize / 6.0);\n\n/**\n * GPUFilters\n * Image filtering\n */\nexport class GPUFilters extends SpeedyProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            // gaussian filters\n            .compose('gauss3', '_gauss3x', '_gauss3y') // size: 3x3 (sigma ~ 1.0)\n            .compose('gauss5', '_gauss5x', '_gauss5y') // size: 5x5 (sigma ~ 1.0)\n            .compose('gauss7', '_gauss7x', '_gauss7y') // size: 7x7\n            .compose('gauss9', '_gauss9x', '_gauss9y') // size: 9x9\n            .compose('gauss11', '_gauss11x', '_gauss11y') // size: 11x11\n\n            // box filters\n            .compose('box3', '_box3x', '_box3y') // size: 3x3\n            .compose('box5', '_box5x', '_box5y') // size: 5x5\n            .compose('box7', '_box7x', '_box7y') // size: 7x7\n            .compose('box9', '_box9x', '_box9y') // size: 9x9\n            .compose('box11', '_box11x', '_box11y') // size: 11x11\n\n            // median filters\n            .declare('median3', fastMedian3) // 3x3 window\n            .declare('median5', fastMedian5) // 5x5 window\n            .declare('median7', median(7)) // 7x7 window\n\n            // difference of gaussians\n            .compose('dog16_1', '_dog16_1x', '_dog16_1y') // sigma_2 / sigma_1 = 1.6 (approx. laplacian with sigma = 1)\n\n            // texture-based convolutions\n            .declare('texConv2D3', texConv2D(3), { // 2D convolution with a 3x3 texture-based kernel\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('texConv2D5', texConv2D(5), { // 2D convolution with a 5x5 texture-based kernel\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('texConv2D7', texConv2D(7), { // 2D convolution with a 7x7 texture-based kernel\n                ...this.program.usesPingpongRendering()\n            })\n\n            // texture-based separable convolutions\n            .compose('texConvXY3', 'texConvX3', 'texConvY3') // 2D convolution with same 1D separable kernel in both axes\n            .declare('texConvX3', texConvX(3)) // 3x1 convolution, x-axis\n            .declare('texConvY3', texConvY(3)) // 1x3 convolution, y-axis\n            .compose('texConvXY5', 'texConvX5', 'texConvY5') // 2D convolution with same 1D separable kernel in both axes\n            .declare('texConvX5', texConvX(5)) // 5x1 convolution, x-axis\n            .declare('texConvY5', texConvY(5)) // 1x5 convolution, y-axis\n            .compose('texConvXY7', 'texConvX7', 'texConvY7') // 2D convolution with same 1D separable kernel in both axes\n            .declare('texConvX7', texConvX(7)) // 7x1 convolution, x-axis\n            .declare('texConvY7', texConvY(7)) // 1x7 convolution, y-axis\n            .compose('texConvXY9', 'texConvX9', 'texConvY9') // 2D convolution with same 1D separable kernel in both axes\n            .declare('texConvX9', texConvX(9)) // 9x1 convolution, x-axis\n            .declare('texConvY9', texConvY(9)) // 1x9 convolution, y-axis\n            .compose('texConvXY11', 'texConvX11', 'texConvY11') // 2D convolution with same 1D separable kernel in both axes\n            .declare('texConvX11', texConvX(11)) // 11x1 convolution, x-axis\n            .declare('texConvY11', texConvY(11)) // 1x11 convolution, y-axis\n\n            // create custom convolution kernels\n            .declare('createKernel3x3', createKernel2D(3), { // 3x3 texture kernel\n                ...(this.program.hasTextureSize(3, 3)),\n                ...(this.program.doesNotRecycleTextures())\n            })\n            .declare('createKernel5x5', createKernel2D(5), { // 5x5 texture kernel\n                ...(this.program.hasTextureSize(5, 5)),\n                ...(this.program.doesNotRecycleTextures())\n            })\n            .declare('createKernel7x7', createKernel2D(7), { // 7x7 texture kernel\n                ...(this.program.hasTextureSize(7, 7)),\n                ...(this.program.doesNotRecycleTextures())\n            })\n            .declare('createKernel3x1', createKernel1D(3), { // 3x1 texture kernel\n                ...(this.program.hasTextureSize(3, 1)),\n                ...(this.program.doesNotRecycleTextures())\n            })\n            .declare('createKernel5x1', createKernel1D(5), { // 5x1 texture kernel\n                ...(this.program.hasTextureSize(5, 1)),\n                ...(this.program.doesNotRecycleTextures())\n            })\n            .declare('createKernel7x1', createKernel1D(7), { // 7x1 texture kernel\n                ...(this.program.hasTextureSize(7, 1)),\n                ...(this.program.doesNotRecycleTextures())\n            })\n            .declare('createKernel9x1', createKernel1D(9), { // 9x1 texture kernel\n                ...(this.program.hasTextureSize(9, 1)),\n                ...(this.program.doesNotRecycleTextures())\n            })\n            .declare('createKernel11x1', createKernel1D(11), { // 11x1 texture kernel\n                ...(this.program.hasTextureSize(11, 1)),\n                ...(this.program.doesNotRecycleTextures())\n            })\n            /*.declare('_readKernel3x3', identity, { // for testing\n                ...(this.program.hasTextureSize(3, 3)),\n                ...(this.program.displaysGraphics())\n            })\n            .declare('_readKernel3x1', identity, {\n                ...(this.program.hasTextureSize(3, 1)),\n                ...(this.program.displaysGraphics())\n            })*/\n\n\n\n\n            // separable kernels (Gaussian)\n            // see also: http://dev.theomader.com/gaussian-kernel-calculator/\n            .declare('_gauss3x', convX([ // sigma ~ 1.0\n                0.25, 0.5, 0.25\n                //0.27901, 0.44198, 0.27901\n            ]))\n            .declare('_gauss3y', convY([\n                0.25, 0.5, 0.25\n                //0.27901, 0.44198, 0.27901\n            ]))\n            .declare('_gauss5x', convX([ // sigma ~ 1.0\n                0.05, 0.25, 0.4, 0.25, 0.05\n                //0.06136, 0.24477, 0.38774, 0.24477, 0.06136\n            ]))\n            .declare('_gauss5y', convY([\n                0.05, 0.25, 0.4, 0.25, 0.05\n                //0.06136, 0.24477, 0.38774, 0.24477, 0.06136\n            ]))\n            /*.declare('_gauss5', conv2D([ // for testing\n                1, 4, 7, 4, 1,\n                4, 16, 26, 16, 4,\n                7, 26, 41, 26, 7,\n                4, 16, 26, 16, 4,\n                1, 4, 7, 4, 1,\n            ], 1 / 237))*/\n            .declare('_gauss7x', convX(Utils.gaussianKernel(ksize2sigma(7), 7)))\n            .declare('_gauss7y', convY(Utils.gaussianKernel(ksize2sigma(7), 7)))\n            .declare('_gauss9x', convX(Utils.gaussianKernel(ksize2sigma(9), 9)))\n            .declare('_gauss9y', convY(Utils.gaussianKernel(ksize2sigma(9), 9)))\n            .declare('_gauss11x', convX(Utils.gaussianKernel(ksize2sigma(11), 11)))\n            .declare('_gauss11y', convY(Utils.gaussianKernel(ksize2sigma(11), 11)))\n\n\n\n\n            // separable kernels (Box filter)\n            .declare('_box3x', convX([\n                1, 1, 1\n            ], 1 / 3))\n            .declare('_box3y', convY([\n                1, 1, 1\n            ], 1 / 3))\n            .declare('_box5x', convX([\n                1, 1, 1, 1, 1\n            ], 1 / 5))\n            .declare('_box5y', convY([\n                1, 1, 1, 1, 1\n            ], 1 / 5))\n            .declare('_box7x', convX([\n                1, 1, 1, 1, 1, 1, 1\n            ], 1 / 7))\n            .declare('_box7y', convY([\n                1, 1, 1, 1, 1, 1, 1\n            ], 1 / 7))\n            .declare('_box9x', convX([\n                1, 1, 1, 1, 1, 1, 1, 1, 1\n            ], 1 / 9))\n            .declare('_box9y', convY([\n                1, 1, 1, 1, 1, 1, 1, 1, 1\n            ], 1 / 9))\n            .declare('_box11x', convX([\n                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\n            ], 1 / 11))\n            .declare('_box11y', convY([\n                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\n            ], 1 / 11))\n\n\n            // difference of gaussians (DoG)\n            // sigma_2 (1.6) - sigma_1 (1.0) => approximates laplacian of gaussian (LoG)\n            .declare('_dog16_1x', convX([\n                0.011725, 0.038976, 0.055137, -0.037649, -0.136377, -0.037649, 0.055137, 0.038976, 0.011725\n            ]))\n            .declare('_dog16_1y', convY([\n                0.011725, 0.038976, 0.055137, -0.037649, -0.136377, -0.037649, 0.055137, 0.038976, 0.011725\n            ]))\n        ;\n    }\n}\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * keypoints.js\n * Facade for various keypoint detection algorithms\n */\n\nimport { SpeedyProgramGroup } from '../speedy-program-group';\nimport { importShader } from '../shader-declaration';\nimport { Utils } from '../../utils/utils';\n\n\n\n//\n// FAST corner detector\n//\n\n// FAST-9_16: requires 9 contiguous pixels\n// on a circumference of 16 pixels\nconst fast9 = importShader('keypoints/fast9lg.glsl').withArguments('image', 'threshold');\n\n// FAST-7_12: requires 7 contiguous pixels\n// on a circumference of 12 pixels\nconst fast7 = importShader('keypoints/fast7.glsl').withArguments('image', 'threshold');\n\n// FAST-5_8: requires 5 contiguous pixels\n// on a circumference of 8 pixels\nconst fast5 = importShader('keypoints/fast5.glsl').withArguments('image', 'threshold');\n\n// compute corner score considering a\n// neighboring circumference of 16 pixels\nconst fastScore16 = importShader('keypoints/fast-score16.glsl').withArguments('image', 'threshold');\n\n// compute corner score considering a\n// neighboring circumference of 12 pixels\nconst fastScore12 = importShader('keypoints/fast-score12.glsl').withArguments('image', 'threshold');\n\n// compute corner score considering a\n// neighboring circumference of 8 pixels\nconst fastScore8 = importShader('keypoints/fast-score8.glsl').withArguments('image', 'threshold');\n\n// FAST-9_16 on scale-space\n// Requires image mipmap\nconst multiscaleFast = importShader('keypoints/multiscale-fast.glsl')\n                      .withArguments('pyramid', 'threshold', 'numberOfOctaves', 'lodStep');\n\n// FAST-9_16 on scale-space\n// with Harris scoring\nconst multiscaleFastWithHarris = importShader('keypoints/multiscale-fast.glsl')\n                                .withArguments('pyramid', 'threshold', 'numberOfOctaves', 'lodStep')\n                                .withDefines({\n                                    'USE_HARRIS_SCORE': 1\n                                });\n\n\n\n//\n// Harris-Shi-Tomasi corner detector\n//\n\n// compute corner responses (score map)\nconst multiscaleHarris = importShader('keypoints/multiscale-harris.glsl')\n                        .withArguments('pyramid', 'windowSize', 'numberOfOctaves', 'lodStep', 'sobelDerivatives');\n\n// discard corners below a specified quality level\nconst harrisCutoff = importShader('keypoints/harris-cutoff.glsl').withArguments('corners', 'maxScore', 'quality');\n\n\n\n//\n// BRISK feature detection\n//\nconst brisk = importShader('keypoints/brisk.glsl')\n             .withArguments('image', 'layerA', 'layerB', 'scaleA', 'scaleB', 'lgM', 'h');\n\n\n\n//\n// ORB feature description\n//\nconst orb = importShader('keypoints/orb-descriptor.glsl')\n           .withArguments('pyramid', 'encodedCorners', 'extraSize', 'encoderLength');\n\n\n\n//\n// Generic keypoint routines\n//\n\n// non-maximum suppression\nconst nonmaxSuppression = importShader('keypoints/nonmax-suppression.glsl').withArguments('image');\nconst multiscaleSuppression = importShader('keypoints/multiscale-suppression.glsl').withArguments('image', 'lodStep');\nconst samescaleSuppression = importShader('keypoints/samescale-suppression.glsl').withArguments('image');\n\n// Sobel derivatives\nconst multiscaleSobel = importShader('filters/multiscale-sobel.glsl').withArguments('pyramid', 'lod');\n\n// compute keypoint orientation\nconst orientationViaCentroid = importShader('keypoints/orientation-via-centroid.glsl')\n                              .withArguments('pyramid', 'encodedKeypoints', 'patchRadius', 'descriptorSize', 'extraSize', 'encoderLength')\n\n\n\n\n/**\n * GPUKeypoints\n * Keypoint detection\n */\nexport class GPUKeypoints extends SpeedyProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            // FAST-9,16\n            .compose('fast9', '_fast9', '_fastScore16')\n            .declare('_fast9', fast9) // find corners\n            .declare('_fastScore16', fastScore16) // compute scores\n\n            // FAST-7,12\n            .compose('fast7', '_fast7', '_fastScore12')\n            .declare('_fast7', fast7)\n            .declare('_fastScore12', fastScore12)\n\n            // FAST-5,8\n            .compose('fast5', '_fast5', '_fastScore8')\n            .declare('_fast5', fast5)\n            .declare('_fastScore8', fastScore8)\n\n            // FAST-9,16 (multi-scale)\n            .declare('multiscaleFast', multiscaleFast)\n            .declare('multiscaleFastWithHarris', multiscaleFastWithHarris)\n\n            // BRISK Scale-Space Non-Maximum Suppression & Interpolation\n            .declare('brisk', brisk)\n\n            // Harris-Shi-Tomasi corner detector\n            .declare('multiscaleHarris', multiscaleHarris) // scale-space\n            .declare('harrisCutoff', harrisCutoff)\n\n            // ORB\n            .declare('_orb', orb)\n\n            // Generic non-maximum suppression\n            .declare('nonmaxSuppression', nonmaxSuppression)\n            .declare('multiscaleSuppression', multiscaleSuppression) // scale-space\n            .declare('samescaleSuppression', samescaleSuppression) // scale-space\n\n            // Sobel derivatives\n            .declare('multiscaleSobel', multiscaleSobel, {\n                ...this.program.doesNotRecycleTextures()\n            }) // scale-space\n\n            // Compute keypoint orientation\n            .declare('_orientationViaCentroid', orientationViaCentroid);\n        ;\n    }\n\n    /**\n     * Compute ORB descriptor (256 bits)\n     * @param {SpeedyTexture} pyramid pre-smoothed on the intensity channel\n     * @param {SpeedyTexture} encodedKeypoints tiny texture\n     * @param {number} descriptorSize in bytes\n     * @param {number} extraSize in bytes\n     * @param {number} encoderLength\n     * @returns {SpeedyTexture}\n     */\n    orb(pyramid, encodedKeypoints, descriptorSize, extraSize, encoderLength)\n    {\n        Utils.assert(descriptorSize === 32);\n        this._orb.resize(encoderLength, encoderLength);\n        return this._orb(pyramid, encodedKeypoints, extraSize, encoderLength);\n    }\n\n    /**\n     * Finds the orientation of all keypoints given a texture with encoded keypoints\n     * (using the centroid method)\n     * @param {SpeedyTexture} pyramid image pyramid\n     * @param {SpeedyTexture} encodedKeypoints tiny texture\n     * @param {number} patchRadius radius of a circular patch used to compute the radius when lod = 0 (e.g., 7)\n     * @param {number} descriptorSize in bytes\n     * @param {number} extraSize in bytes\n     * @param {number} encoderLength\n     * @returns {SpeedyTexture}\n     */\n    orientationViaCentroid(pyramid, encodedKeypoints, patchRadius, descriptorSize, extraSize, encoderLength)\n    {\n        this._orientationViaCentroid.resize(encoderLength, encoderLength);\n        return this._orientationViaCentroid(pyramid, encodedKeypoints, patchRadius, descriptorSize, extraSize, encoderLength);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * pyramids.js\n * Image pyramids\n */\n\nimport { SpeedyProgramGroup } from '../speedy-program-group';\nimport { SpeedyGPU } from '../speedy-gpu';\nimport { SpeedyProgram } from '../speedy-program';\nimport { SpeedyTexture } from '../speedy-texture';\nimport { importShader } from '../shader-declaration';\nimport { convX, convY } from '../shaders/filters/convolution';\nimport { IllegalOperationError } from '../../utils/errors';\n\n\n\n//\n// Shaders\n//\n\n// pyramid generation\nconst upsample2 = importShader('pyramids/upsample2.glsl').withArguments('image');\nconst downsample2 = importShader('pyramids/downsample2.glsl').withArguments('image');\n//const upsample3 = importShader('pyramids/upsample3.glsl').withArguments('image');\n//const downsample3 = importShader('pyramids/downsample3.glsl').withArguments('image');\n\n// debug\n//const flipY = importShader('utils/flip-y.glsl').withArguments('image');\n\n\n\n/**\n * GPUPyramids\n * Image pyramids\n */\nexport class GPUPyramids extends SpeedyProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            /*\n            // pyramid operations (scale = 2)\n            .compose('_reduce', '_smoothX', '_smoothY', '_downsample2')\n            .compose('_expand', '_upsample2', '_smoothX2', '_smoothY2')\n           \n            // intra-pyramid operations (scale = 1.5)\n            .compose('_intraReduce', '_upsample2', '_smoothX2', '_smoothY2', '_downsample3/2')\n            .compose('_intraExpand', '_upsample3', '_smoothX3', '_smoothY3', '_downsample2/3')\n            */\n\n            /*\n            // utilities for debugging\n            .declare('output1', flipY, {\n                ...this.program.hasTextureSize(this._width, this._height),\n                ...this.program.displaysGraphics()\n            })\n\n            .declare('outputHalf', flipY, {\n                ...this.program.hasTextureSize(Math.floor(this._width / 2), Math.floor(this._height / 2)),\n                ...this.program.displaysGraphics()\n            })\n\n            .declare('output2', flipY, {\n                ...this.program.hasTextureSize(2 * this._width, 2 * this._height),\n                ...this.program.displaysGraphics()\n            })\n            */\n            \n            // separable kernels for gaussian smoothing\n            // use [c, b, a, b, c] where a+2c = 2b and a+2b+2c = 1\n            // pick a = 0.4 for gaussian approximation\n            .declare('_smoothX', convX([\n                0.05, 0.25, 0.4, 0.25, 0.05\n            ]))\n            .declare('_smoothY', convY([\n                0.05, 0.25, 0.4, 0.25, 0.05\n            ]))\n\n            // smoothing for 2x image\n            // same rules as above with sum(k) = 2\n            .declare('_smoothX2', convX([\n                0.1, 0.5, 0.8, 0.5, 0.1 // NOTE: this would saturate the image, but we apply it on a 2x upsampled version with lots of zero pixels\n            ]), this.program.hasTextureSize(2 * this._width, 2 * this._height))\n\n            .declare('_smoothY2', convY([\n                0.1, 0.5, 0.8, 0.5, 0.1\n            ], 1.0 / 2.0), this.program.hasTextureSize(2 * this._width, 2 * this._height))\n\n            /*\n            // smoothing for 3x image\n            // use [1-b, b, 1, b, 1-b], where 0 < b < 1\n            .declare('_smoothX3', convX([\n                0.2, 0.8, 1.0, 0.8, 0.2\n            ]), this.program.hasTextureSize(3 * this._width, 3 * this._height))\n\n            .declare('_smoothY3', convY([\n                0.2, 0.8, 1.0, 0.8, 0.2\n            ], 1.0 / 3.0), this.program.hasTextureSize(3 * this._width, 3 * this._height))\n            */\n\n            // upsampling & downsampling\n            .declare('_upsample2', upsample2,\n                this.program.hasTextureSize(2 * this._width, 2 * this._height))\n\n            .declare('_downsample2', downsample2,\n                this.program.hasTextureSize(Math.max(1, Math.floor(this._width / 2)), Math.max(1, Math.floor(this._height / 2))))\n\n            /*\n            .declare('_upsample3', upsample3,\n                this.program.hasTextureSize(3 * this._width, 3 * this._height))\n\n            .declare('_downsample3', downsample3,\n                this.program.hasTextureSize(Math.floor(this._width / 3), Math.floor(this._height / 3)))\n\n            .declare('_downsample2/3', downsample2,\n                this.program.hasTextureSize(Math.floor(3 * this._width / 2), Math.floor(3 * this._height / 2)))\n\n            .declare('_downsample3/2', downsample3,\n                this.program.hasTextureSize(Math.floor(2 * this._width / 3), Math.floor(2 * this._height / 3)))\n            */\n        ;\n\n        /** @type {SpeedyProgram} */\n        this._lastOperation = null;\n    }\n\n    /**\n     * Reduce the image (0.5x)\n     * @param {SpeedyTexture} image\n     * @returns {SpeedyTexture}\n     */\n    reduce(image)\n    {\n        const smoothImage = this._smoothY(this._smoothX(image));\n        const downsampledImage = this._downsample2(smoothImage);\n\n        this._lastOperation = this._downsample2;\n        return downsampledImage;\n    }\n\n    /**\n     * Expand the image (2x)\n     * @param {SpeedyTexture} image\n     * @returns {SpeedyTexture}\n     */\n    expand(image)\n    {\n        const upsampledImage = this._upsample2(image);\n        const smoothImage = this._smoothY2(this._smoothX2(upsampledImage));\n\n        this._lastOperation = this._smoothY2;\n        return smoothImage;\n    }\n\n    /**\n     * Export the result of the last operation to\n     * a specific level of detail of a texture\n     * @param {SpeedyTexture} texture\n     * @param {number} lod level-of-detail\n     */\n    exportTo(texture, lod)\n    {\n        if(this._lastOperation !== null)\n            this._lastOperation.exportTo(texture, lod);\n        else\n            throw new IllegalOperationError(`Can't export pyramid level before generating it`);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * trackers.js\n * Feature trackers\n */\n\nimport { SpeedyProgramGroup } from '../speedy-program-group';\nimport { importShader } from '../shader-declaration';\nimport { PYRAMID_MAX_LEVELS, MIN_KEYPOINT_SIZE } from '../../utils/globals';\n\n\n\n//\n// Shaders\n//\n\n// LK\nconst LK_MAX_WINDOW_SIZE = 21; // 21x21 window\nconst LK_MAX_WINDOW_SIZE_SMALL = 15; // 15x15 window - the smaller the window, the easier it is on the GPU\nconst LK_MAX_WINDOW_SIZE_SMALLER = 11; // 11x11 window - works best on mobile\nconst LK_MAX_WINDOW_SIZE_SMALLEST = 7; // 7x7 window\nconst LK_MIN_WINDOW_SIZE = 5; // 5x5 window: (-2, -1, 0, 1, 2) x (-2, -1, 0, 1, 2)\nconst LK_MAX_KEYPOINTS_PER_PASS = 100;\n\nconst lk = importShader('trackers/lk.glsl')\n           .withArguments('nextPyramid', 'prevPyramid', 'prevKeypoints', 'windowSize', 'depth', 'firstKeypointIndex', 'lastKeypointIndex', 'descriptorSize', 'extraSize', 'encoderLength')\n           .withDefines({\n               'MAX_WINDOW_SIZE': LK_MAX_WINDOW_SIZE\n           });\n\nconst lkDiscard = importShader('trackers/lk-discard.glsl')\n                  .withArguments('pyramid', 'encodedKeypoints', 'windowSize', 'discardThreshold', 'firstKeypointIndex', 'lastKeypointIndex', 'descriptorSize', 'extraSize', 'encoderLength')\n                  .withDefines({\n                      'MAX_WINDOW_SIZE': LK_MAX_WINDOW_SIZE\n                  });\n\nconst lkSmall = importShader('trackers/lk.glsl')\n                .withArguments('nextPyramid', 'prevPyramid', 'prevKeypoints', 'windowSize', 'depth', 'firstKeypointIndex', 'lastKeypointIndex', 'descriptorSize', 'extraSize', 'encoderLength')\n                .withDefines({\n                    'MAX_WINDOW_SIZE': LK_MAX_WINDOW_SIZE_SMALL\n                });\n\nconst lkDiscardSmall = importShader('trackers/lk-discard.glsl')\n                       .withArguments('pyramid', 'encodedKeypoints', 'windowSize', 'discardThreshold', 'firstKeypointIndex', 'lastKeypointIndex', 'descriptorSize', 'extraSize', 'encoderLength')\n                       .withDefines({\n                           'MAX_WINDOW_SIZE': LK_MAX_WINDOW_SIZE_SMALL\n                       });\n\nconst lkSmaller = importShader('trackers/lk.glsl')\n                  .withArguments('nextPyramid', 'prevPyramid', 'prevKeypoints', 'windowSize', 'depth', 'firstKeypointIndex', 'lastKeypointIndex', 'descriptorSize', 'extraSize', 'encoderLength')\n                  .withDefines({\n                      'MAX_WINDOW_SIZE': LK_MAX_WINDOW_SIZE_SMALLER\n                  });\n\nconst lkDiscardSmaller = importShader('trackers/lk-discard.glsl')\n                         .withArguments('pyramid', 'encodedKeypoints', 'windowSize', 'discardThreshold', 'firstKeypointIndex', 'lastKeypointIndex', 'descriptorSize', 'extraSize', 'encoderLength')\n                         .withDefines({\n                             'MAX_WINDOW_SIZE': LK_MAX_WINDOW_SIZE_SMALLER\n                         });\n\nconst lkSmallest = importShader('trackers/lk.glsl')\n                   .withArguments('nextPyramid', 'prevPyramid', 'prevKeypoints', 'windowSize', 'depth', 'firstKeypointIndex', 'lastKeypointIndex', 'descriptorSize', 'extraSize', 'encoderLength')\n                   .withDefines({\n                       'MAX_WINDOW_SIZE': LK_MAX_WINDOW_SIZE_SMALLEST\n                   });\n\nconst lkDiscardSmallest = importShader('trackers/lk-discard.glsl')\n                          .withArguments('pyramid', 'encodedKeypoints', 'windowSize', 'discardThreshold', 'firstKeypointIndex', 'lastKeypointIndex', 'descriptorSize', 'extraSize', 'encoderLength')\n                          .withDefines({\n                              'MAX_WINDOW_SIZE': LK_MAX_WINDOW_SIZE_SMALLEST\n                          });\n\n/**\n * GPUTrackers\n * Feature trackers\n */\nexport class GPUTrackers extends SpeedyProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            // LK\n            .declare('_lk', lk)\n            .declare('_lkSmall', lkSmall)\n            .declare('_lkSmaller', lkSmaller)\n            .declare('_lkSmallest', lkSmallest)\n            .declare('_lkDiscard', lkDiscard)\n            .declare('_lkDiscardSmall', lkDiscardSmall)\n            .declare('_lkDiscardSmaller', lkDiscardSmaller)\n            .declare('_lkDiscardSmallest', lkDiscardSmallest)\n        ;\n    }\n\n    /**\n     * LK feature tracker\n     * @param {SpeedyTexture} nextPyramid image pyramid at time t\n     * @param {SpeedyTexture} prevPyramid image pyramid at time t-1\n     * @param {SpeedyTexture} prevKeypoints tiny texture of encoded keypoints at time t-1\n     * @param {number} windowSize neighborhood size, an odd number (5, 7, 9, 11...)\n     * @param {number} depth how many pyramid layers will be scanned\n     * @param {number} discardThreshold used to discard \"bad\" keypoints, typically 10^(-4)\n     * @param {number} descriptorSize in bytes\n     * @param {number} extraSize in bytes\n     * @param {number} encoderLength\n     * @returns {SpeedyTexture}\n     */\n    lk(nextPyramid, prevPyramid, prevKeypoints, windowSize, depth, discardThreshold, descriptorSize, extraSize, encoderLength)\n    {\n        // make sure we get a proper depth\n        const MIN_DEPTH = 1, MAX_DEPTH = PYRAMID_MAX_LEVELS;\n        depth = Math.max(MIN_DEPTH, Math.min(depth | 0, MAX_DEPTH));\n\n        // windowSize must be a positive odd number\n        windowSize = windowSize + ((windowSize + 1) % 2);\n        windowSize = Math.max(LK_MIN_WINDOW_SIZE, Math.min(windowSize, LK_MAX_WINDOW_SIZE));\n\n        // select programs\n        let lk = '_lk', lkDiscard = '_lkDiscard';\n        if(windowSize <= LK_MAX_WINDOW_SIZE_SMALLEST) {\n            lk = '_lkSmallest'; lkDiscard = '_lkDiscardSmallest';\n        }\n        else if(windowSize <= LK_MAX_WINDOW_SIZE_SMALLER) {\n            lk = '_lkSmaller'; lkDiscard = '_lkDiscardSmaller';\n        }\n        else if(windowSize <= LK_MAX_WINDOW_SIZE_SMALL) {\n            lk = '_lkSmall'; lkDiscard = '_lkDiscardSmall';\n        }\n\n        // resize programs\n        this[lk].resize(encoderLength, encoderLength);\n        this[lkDiscard].resize(encoderLength, encoderLength);\n\n        //\n        // Optimization!\n        // because this is such a demanding algorithm, we'll\n        // split the work into multiple passes of the shaders\n        // (so we don't get WebGL context loss on mobile)\n        //\n        const pixelsPerKeypoint = (MIN_KEYPOINT_SIZE + descriptorSize + extraSize) / 4;\n        const numKeypointsApprox = encoderLength * encoderLength / pixelsPerKeypoint;\n        const numPasses = Math.ceil(Math.max(1, numKeypointsApprox) / LK_MAX_KEYPOINTS_PER_PASS);\n        //console.log('num passes', numPasses, lk);\n\n        // for each pass\n        let nextKeypoints = prevKeypoints;\n        for(let i = 0; i < numPasses; i++) {\n            const firstKeypointIndex = i * LK_MAX_KEYPOINTS_PER_PASS;\n            const lastKeypointIndex = firstKeypointIndex + LK_MAX_KEYPOINTS_PER_PASS - 1;\n\n            // compute optical-flow\n            nextKeypoints = (this[lk])(nextPyramid, prevPyramid, nextKeypoints, windowSize, depth, firstKeypointIndex, lastKeypointIndex, descriptorSize, extraSize, encoderLength);\n\n            // discard \"bad\" keypoints\n            nextKeypoints = (this[lkDiscard])(nextPyramid, nextKeypoints, windowSize, discardThreshold, firstKeypointIndex, lastKeypointIndex, descriptorSize, extraSize, encoderLength);\n        }\n\n        // done!\n        return nextKeypoints;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * utils.js\n * GPU utilities\n */\n\nimport { SpeedyProgramGroup } from '../speedy-program-group';\nimport { importShader } from '../shader-declaration';\nimport { GLUtils } from '../gl-utils';\nimport { PixelComponent, ColorComponentId } from '../../utils/types';\nimport { IllegalArgumentError } from '../../utils/errors';\n\n\n\n//\n// Shaders\n//\n\n// Identity shader: no-operation\nconst identity = importShader('utils/identity.glsl').withArguments('image');\n\n// Flip y-axis for output\nconst flipY = importShader('utils/flip-y.glsl').withArguments('image');\n\n// Fill image with a constant\nconst fill = importShader('utils/fill.glsl').withArguments('value');\n\n// Fill zero or more color components of the input image with a constant value\nconst fillComponents = importShader('utils/fill-components.glsl').withArguments('image', 'pixelComponents', 'value');\n\n// Copy the src component of src to zero or more color components of a copy of dest\nconst copyComponents = importShader('utils/copy-components.glsl').withArguments('dest', 'src', 'destComponents', 'srcComponentId');\n\n// Scan the entire image and find the minimum & maximum pixel intensity for each row and column\n//const scanMinMax1D = importShader('utils/scan-minmax1d.glsl').withArguments('image', 'iterationNumber');\n\n// Scan the entire image and find the minimum & maximum pixel intensity\nconst scanMinMax2D = importShader('utils/scan-minmax2d.glsl').withArguments('image', 'iterationNumber');\n\n\n\n/**\n * GPUUtils\n * Utility operations\n */\nexport class GPUUtils extends SpeedyProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            // no-operation\n            .declare('identity', identity)\n\n            // output a texture from a pipeline\n            .declare('output', flipY, {\n                ...this.program.displaysGraphics()\n            })\n                \n            // clone a texture (release it afterwards)\n            .declare('clone', identity, {\n                ...this.program.doesNotRecycleTextures()\n            })\n\n            // flip y-axis\n            .declare('flipY', flipY)\n\n            // Fill image with a constant\n            .declare('fill', fill)\n\n            // Fill zero or more color components of the input image with a constant value\n            .declare('fillComponents', fillComponents)\n\n            // Copy the src component of src to zero or more color components of a copy of dest\n            .declare('_copyComponents', copyComponents)\n\n            // find minimum & maximum pixel intensity for each row and column\n            /*.declare('_scanMinMax1D', scanMinMax1D, {\n                ...this.program.usesPingpongRendering()\n            })*/\n\n            // find minimum & maximum pixel intensity\n            .declare('_scanMinMax2D', scanMinMax2D, {\n                ...this.program.usesPingpongRendering()\n            })\n        ;\n    }\n\n    /**\n     * Scan a single component in all pixels of the image and find the maximum intensity\n     * @param {SpeedyTexture} image \n     * @param {number} pixelComponent a single PixelComponent flag\n     * @returns {SpeedyTexture} such that pixel[component] = max(image_pixel[component])\n     *                                                           for all image_pixels\n     */\n    scanMax(image, pixelComponent)\n    {\n        const minmax2d = this._scanMinMax(image, pixelComponent);\n        return this.copyComponents(image, minmax2d, pixelComponent, PixelComponent.RED);\n    }\n\n    /**\n     * Scan a single component in all pixels of the image and find the minimum intensity\n     * @param {SpeedyTexture} image \n     * @param {number} pixelComponent a single PixelComponent flag\n     * @returns {SpeedyTexture} such that pixel[component] = min(image_pixel[component])\n     *                                                           for all image_pixels\n     */\n    scanMin(image, pixelComponent)\n    {\n        const minmax2d = this._scanMinMax(image, pixelComponent);\n        return this.copyComponents(image, minmax2d, pixelComponent, PixelComponent.GREEN);\n    }\n\n    /**\n     * Copy color component\n     * @param {SpeedyTexture} dest\n     * @param {SpeedyTexture} src \n     * @param {number} destComponents one or more PixelComponent flags\n     * @param {number} srcComponent a single PixelComponent flag\n     * @returns {SpeedyTexture} a copy of dest with its destComponents replaced by the srcComponent of src\n     */\n    copyComponents(dest, src, destComponents, srcComponent)\n    {\n        if(!ColorComponentId.hasOwnProperty(srcComponent))\n            throw new IllegalArgumentError(`Invalid srcComponent: ${srcComponent}`)\n\n        const srcComponentId = ColorComponentId[srcComponent];\n        return this._copyComponents(dest, src, destComponents, srcComponentId);\n    }\n\n    /**\n     * Scan a single component in all pixels of the image and find the min & max intensities\n     * @param {SpeedyTexture} image \n     * @param {number} pixelComponent a single PixelComponent flag\n     * @returns {SpeedyTexture} RGBA = (max, min, max - min, original_pixel)\n     */\n    _scanMinMax(image, pixelComponent)\n    {\n        //\n        // FIXME: combinations of PixelComponent (e.g., PixelComponent.ALL)\n        //        are currently unsupported. Make separate calls.\n        //\n        const numIterations = Math.ceil(Math.log2(Math.max(this._width, this._height))) | 0;\n        let texture = this.copyComponents(image, image, PixelComponent.ALL, pixelComponent);\n\n        for(let i = 0; i < numIterations; i++)\n            texture = this._scanMinMax2D(texture, i);\n\n        return texture;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * shader-declaration.js\n * Encapsulates a shader declaration\n */\n\nimport { ShaderPreprocessor } from './shader-preprocessor';\nimport { FileNotFoundError, IllegalArgumentError, IllegalOperationError, ParseError } from '../utils/errors';\n\nconst DEFAULT_ATTRIBUTES = Object.freeze({\n    position: 'a_position',\n    texCoord: 'a_texCoord'\n});\n\nconst DEFAULT_VERTEX_SHADER = `#version 300 es\nin vec2 ${DEFAULT_ATTRIBUTES.position};\nin vec2 ${DEFAULT_ATTRIBUTES.texCoord};\nout vec2 texCoord;\n\nvoid main() {\n    gl_Position = vec4(${DEFAULT_ATTRIBUTES.position}, 0.0, 1.0);\n    texCoord = ${DEFAULT_ATTRIBUTES.texCoord};\n}`;\n\nconst DEFAULT_FRAGMENT_SHADER_PREFIX = `#version 300 es\nprecision highp int;\nprecision mediump float;\nprecision mediump sampler2D;\n\nout vec4 color;\nin vec2 texCoord;\nuniform vec2 texSize;\n\n@include \"global.glsl\"\\n`;\n\n/**\n * Shader Declaration\n */\nclass ShaderDeclaration\n{\n    /**\n     * @private Constructor\n     * @param {object} options\n     * @param {string} [options.filepath]\n     * @param {string} [options.source]\n     */\n    constructor(options)\n    {\n        const filepath = options.filepath || null;\n        const source = filepath ? require('./shaders/' + filepath) : (options.source || '');\n        if(source.length == 0)\n            throw new IllegalArgumentError(`Can't import shader: empty code`);\n\n        /** @type {string} original source code provided by the user */\n        this._userSource = source;\n\n        /** @type {string} preprocessed source code of the vertex shader */\n        this._vertexSource = ShaderPreprocessor.run(DEFAULT_VERTEX_SHADER);\n\n        /** @type {string} preprocessed source code of the fragment shader */\n        this._fragmentSource = ShaderPreprocessor.run(DEFAULT_FRAGMENT_SHADER_PREFIX + this._userSource);\n\n        /** @type {string} the filepath from which the (fragment) shader was imported */\n        this._filepath = filepath || '<in-memory>';\n\n        /** @type {string[]} an ordered list of uniform names */\n        this._arguments = [];\n\n        /** @type {Map<string,string>} it maps uniform names to their types */\n        this._uniforms = this._autodetectUniforms(this._fragmentSource);\n\n        /** @type {Map<string,number>} it maps externally #defined constants to their values */\n        this._defines = new Map();\n    }\n\n    /**\n     * Creates a new Shader directly from a GLSL source\n     * @param {string} source\n     * @returns {ShaderDeclaration}\n     */\n    static create(source)\n    {\n        return new ShaderDeclaration({ source });\n    }\n\n    /**\n     * Import a Shader from a file containing a GLSL source\n     * @param {string} filepath path to .glsl file relative to the shaders/ folder\n     * @returns {ShaderDeclaration}\n     */\n    static import(filepath)\n    {\n        if(!String(filepath).match(/^[a-zA-Z0-9_\\-\\/]+\\.glsl$/))\n            throw new FileNotFoundError(`Can't import shader: \"${filepath}\"`);\n\n        return new ShaderDeclaration({ filepath });\n    }\n\n    /**\n     * Specify the list & order of arguments to be\n     * passed to the shader\n     * @param  {...string} args argument names\n     * @returns {ShaderDeclaration} this\n     */\n    withArguments(...args)\n    {\n        // the list of arguments may be declared only once\n        if(this._arguments.length > 0)\n            throw new IllegalOperationError(`Redefinition of shader arguments`);\n\n        // get arguments\n        this._arguments = args.map(arg => String(arg));\n\n        // validate\n        for(const argname of this._arguments) {\n            if(!this._uniforms.has(argname)) {\n                if(!this._uniforms.has(argname + '[0]'))\n                    throw new IllegalArgumentError(`Argument \"${argname}\" has not been declared in the shader`);\n            }\n        }\n\n        // done!\n        return this;\n    }\n\n    /**\n     * Specify a set of #defines to be prepended to the fragment shader\n     * @param {object} defines key-value pairs (define-name: define-value)\n     * @returns {ShaderDeclaration} this\n     */\n    withDefines(defines)\n    {\n        // the list of #defines may be defined only once\n        if(this._defines.size > 0)\n            throw new IllegalOperationError(`Redefinition of externally defined constants of a shader`);\n\n        // store and write the #defines\n        const defs = [];\n        for(const key of Object.keys(defines)) {\n            const value = Number(defines[key]); // force numeric values\n            this._defines.set(key, value);\n            defs.push(`#define ${key} ${value}\\n`);\n        }\n\n        // update the fragment shader\n        const source = DEFAULT_FRAGMENT_SHADER_PREFIX + defs.join('') + this._userSource;\n        this._fragmentSource = ShaderPreprocessor.run(source, this._defines);\n\n        // done!\n        return this;\n    }\n\n    /**\n     * Return the GLSL source of the fragment shader\n     * @returns {string}\n     */\n    get fragmentSource()\n    {\n        return this._fragmentSource;\n    }\n\n    /**\n     * Return the GLSL source of the vertex shader\n     * @returns {string}\n     */\n    get vertexSource()\n    {\n        return this._vertexSource;\n    }\n\n    /**\n     * Get the names of the vertex shader attributes\n     * @returns {object}\n     */\n    get attributes()\n    {\n        return DEFAULT_ATTRIBUTES;\n    }\n\n    /**\n     * Names of the arguments that will be passed to the Shader,\n     * corresponding to GLSL uniforms, in the order they will be passed\n     * @returns {string[]}\n     */\n    get arguments()\n    {\n        return this._arguments;\n    }\n\n    /**\n     * Names of the uniforms declared in the shader\n     * @returns {string[]}\n     */\n    get uniforms()\n    {\n        return Array.from(this._uniforms.keys());\n    }\n\n    /**\n     * The GLSL type of a uniform variable declared in the shader\n     * @param {string} name\n     * @returns {string}\n     */\n    uniformType(name)\n    {\n        if(!this._uniforms.has(name))\n            throw new IllegalArgumentError(`Unrecognized uniform variable: \"${name}\"`);\n\n        return this._uniforms.get(name);\n    }\n\n    /**\n     * The value of an externally defined constant, i.e., via withDefines()\n     * @param {string} name \n     * @returns {number}\n     */\n    definedConstant(name)\n    {\n        if(!this._defines.has(name))\n            throw new IllegalArgumentError(`Unrecognized externally defined constant: \"${name}\"`);\n\n        return this._defines.get(name);\n    }\n\n    /**\n     * Parses a GLSL source and detects the uniform variables,\n     * as well as their types\n     * @param {string} preprocessedSource \n     * @returns {Map<string,string>} specifies the types of all uniforms\n     */\n    _autodetectUniforms(preprocessedSource)\n    {\n        const sourceWithoutComments = preprocessedSource; // assume we've preprocessed the source already\n        const regex = /^\\s*uniform\\s+(highp\\s+|mediump\\s+|lowp\\s+)?(\\w+)\\s+([^;]+)/gm;\n        const uniforms = new Map();\n\n        let match;\n        while((match = regex.exec(sourceWithoutComments)) !== null) {\n            const type = match[2];\n            const names = match[3].split(',').map(name => name.trim()).filter(name => name); // trim & remove empty names\n\n            for(const name of names) {\n                if(name.endsWith(']')) {\n                    // is it an array?\n                    if(!(match = name.match(/(\\w+)\\s*\\[\\s*(\\d+)\\s*\\]$/)))\n                        throw new ParseError(`Unspecified array length for uniform \"${name}\" in the shader`);\n\n                    // read array name & size\n                    const [ array, size ] = [ match[1], Number(match[2]) ];\n                    if(size == 0)\n                        throw new ParseError(`Array ${array} has size zero`);\n\n                    // register uniforms\n                    for(let i = 0; i < size; i++)\n                        uniforms.set(`${array}[${i}]`, type);\n                }\n                else {\n                    // register a regular uniform\n                    uniforms.set(name, type);\n                }\n            }\n        }\n\n        return uniforms;\n    }\n}\n\n/**\n * Import a ShaderDeclaration from a GLSL file\n * @param {string} filepath relative to the shaders/ folder\n * @returns {ShaderDeclaration}\n */\nexport function importShader(filepath)\n{\n    return ShaderDeclaration.import(filepath);\n}\n\n/**\n * Create a ShaderDeclaration from a GLSL source\n * @param {string} source\n * @returns {ShaderDeclaration}\n */\nexport function createShader(source)\n{\n    return ShaderDeclaration.create(source);\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * shader-preprocessor.js\n * Custom preprocessor for shaders\n */\n\nimport {\n    PYRAMID_MAX_LEVELS, PYRAMID_MAX_OCTAVES, LOG2_PYRAMID_MAX_SCALE,\n    MAX_TEXTURE_LENGTH,\n    FIX_BITS, FIX_RESOLUTION,\n    MAX_DESCRIPTOR_SIZE, MIN_KEYPOINT_SIZE,\n    KPF_NONE, KPF_ORIENTED, KPF_DISCARD\n} from '../utils/globals';\nimport { Utils } from '../utils/utils';\nimport { PixelComponent } from '../utils/types';\nimport { FileNotFoundError, ParseError } from '../utils/errors';\n\n// Regular Expressions\nconst commentsRegex = [ /\\/\\*(.|\\s)*?\\*\\//g , /\\/\\/.*$/gm ];\nconst includeRegex = /^\\s*@\\s*include\\s+\"(.*?)\"/gm;\nconst constantRegex = /@(\\w+)@/g;\nconst unrollRegex = [\n    /@\\s*unroll\\s+?for\\s*\\(\\s*(int|)\\s*(?<counter>\\w+)\\s*\\=\\s*(-?\\d+|\\w+)\\s*;\\s*\\k<counter>\\s*(<=?)\\s*(-?\\d+|\\w+)\\s*;\\s*\\k<counter>\\s*\\+\\+()\\s*\\)\\s*\\{\\s*([\\s\\S]+?)\\s*\\}/g,\n    /@\\s*unroll\\s+?for\\s*\\(\\s*(int|)\\s*(?<counter>\\w+)\\s*\\=\\s*(-?\\d+|\\w+)\\s*;\\s*\\k<counter>\\s*(<=?)\\s*(-?\\d+|\\w+)\\s*;\\s*\\k<counter>\\s*\\+=\\s*(-?\\d+)\\s*\\)\\s*\\{\\s*([\\s\\S]+?)\\s*\\}/g,\n];\n\n// Constants accessible by all shaders\nconst constants = Object.freeze({\n    // general\n    'MAX_TEXTURE_LENGTH': MAX_TEXTURE_LENGTH,\n\n    // pyramids\n    'PYRAMID_MAX_LEVELS': PYRAMID_MAX_LEVELS,\n    'LOG2_PYRAMID_MAX_SCALE': LOG2_PYRAMID_MAX_SCALE,\n    'PYRAMID_MAX_OCTAVES': PYRAMID_MAX_OCTAVES,\n\n    // colors\n    'PIXELCOMPONENT_RED': PixelComponent.RED,\n    'PIXELCOMPONENT_GREEN': PixelComponent.GREEN,\n    'PIXELCOMPONENT_BLUE': PixelComponent.BLUE,\n    'PIXELCOMPONENT_ALPHA': PixelComponent.ALPHA,\n\n    // fixed-point math\n    'FIX_BITS': FIX_BITS,\n    'FIX_RESOLUTION': FIX_RESOLUTION,\n\n    // keypoints\n    'MAX_DESCRIPTOR_SIZE': MAX_DESCRIPTOR_SIZE,\n    'MIN_KEYPOINT_SIZE': MIN_KEYPOINT_SIZE,\n    'KPF_NONE': KPF_NONE,\n    'KPF_ORIENTED': KPF_ORIENTED,\n    'KPF_DISCARD': KPF_DISCARD,\n});\n\n/**\n * Custom preprocessor for shaders\n */\nexport class ShaderPreprocessor\n{\n    /**\n     * Runs the preprocessor\n     * @param {string} code \n     * @param {Map<string,number>} [defines]\n     * @returns {string} preprocessed code\n     */\n    static run(code, defines = new Map())\n    {\n        //\n        // The preprocessor will remove comments from GLSL code,\n        // include requested GLSL files and import global constants\n        // defined for all shaders (see above)\n        //\n        return unrollLoops(\n            String(code)\n                .replace(commentsRegex[0], '')\n                .replace(commentsRegex[1], '')\n                .replace(includeRegex, (_, filename) =>\n                    // FIXME: no cycle detection for @include\n                    ShaderPreprocessor.run(readfileSync(filename), defines)\n                )\n                .replace(constantRegex, (_, name) =>\n                    String(constants[name] !== undefined ? constants[name] : 'UNDEFINED_CONSTANT')\n                ),\n            defines\n        );\n    }\n}\n\n /**\n * Reads a shader from the shaders/include/ folder\n * @param {string} filename\n * @returns {string}\n */\nfunction readfileSync(filename)\n{\n    if(String(filename).match(/^[a-zA-Z0-9_\\-]+\\.glsl$/))\n        return require('./shaders/include/' + filename);\n\n    throw new FileNotFoundError(`Shader preprocessor: can't read file \"${filename}\"`);\n}\n\n/**\n * Unroll for loops in our own preprocessor\n * @param {string} code\n * @param {Map<string,number>} defines\n * @returns {string}\n */\nfunction unrollLoops(code, defines)\n{\n    //\n    // Currently, only integer for loops with positive step values\n    // can be unrolled. (TODO: negative step values?)\n    //\n    // The current implementation does not support curly braces\n    // inside unrolled loops. You may define macros to get around\n    // this, but do you actually need to unroll such loops?\n    //\n    // Loops that don't fit the supported pattern will crash\n    // the preprocessor if you try to unroll them.\n    //\n    const fn = unroll.bind(defines); // CRAZY!\n    const n = unrollRegex.length;\n\n    for(let i = 0; i < n; i++)\n        code = code.replace(unrollRegex[i], fn);\n\n    return code;\n}\n\n/**\n * Unroll a loop pattern (regexp)\n * @param {string} match the matched for loop\n * @param {...string} pi matched expression\n * @returns {string} unrolled loop\n */\nfunction unroll(match, type, counter, start, cmp, end, step, loopcode)\n{\n    const defines = this;\n\n    // check if the loop limits are numeric constants or #defined numbers from the outside\n    start = Number.isFinite(+start) ? start : defines.get(start);\n    end = Number.isFinite(+end) ? end : defines.get(end);\n    if(start === undefined || end === undefined) {\n        if(defines.size > 0)\n            throw new ParseError(`Can't unroll loop: unknown limits (start=${start}, end=${end}). Code:\\n\\n${match}`);\n        else\n            return match; // don't unroll now, because defines is empty - maybe we'll succeed in the next pass\n    }\n\n    // parse limits\n    start = parseInt(start);\n    end = parseInt(end);\n    step = (step.length == 0) ? 1 : parseInt(step);\n    Utils.assert(start <= end && step > 0);\n\n    /*\n    // debug\n    console.log(`Encontrei \"${match}\"`);\n    console.log(`type=\"${type}\"`);\n    console.log(`counter=\"${counter}\"`);\n    console.log(`start=\"${start}\"`);\n    console.log(`cmp=\"${cmp}\"`);\n    console.log(`end=\"${end}\"`);\n    console.log(`step=\"${step}\"`);\n    console.log(`loopcode=\"${loopcode}\"`)\n    console.log('Defines:', defines);\n    */\n\n    // continue statements are not supported inside unrolled loops\n    // and will generate a compiler error. Using break is ok.\n    const hasBreak = (loopcode.match(/\\bbreak\\s*;/) !== null);\n\n    // create a new scope\n    let unrolledCode = hasBreak ? 'switch(1) { default:\\n' : '{\\n';\n\n    // declare counter\n    unrolledCode += `${type} ${counter};\\n`;\n\n    // unroll loop\n    end += (cmp == '<=') ? 1 : 0;\n    for(let i = start; i < end; i += step)\n        unrolledCode += `{\\n${counter} = ${i};\\n${loopcode}\\n}\\n`;\n\n    // close scope\n    unrolledCode += '}\\n';\n    //console.log('Unrolled code:\\n\\n' + unrolledCode);\n\n    // done!\n    return unrolledCode;\n}","var map = {\n\t\"./colors/rgb2grey.glsl\": \"./src/gpu/shaders/colors/rgb2grey.glsl\",\n\t\"./encoders/encode-keypoint-long-offsets.glsl\": \"./src/gpu/shaders/encoders/encode-keypoint-long-offsets.glsl\",\n\t\"./encoders/encode-keypoint-offsets.glsl\": \"./src/gpu/shaders/encoders/encode-keypoint-offsets.glsl\",\n\t\"./encoders/encode-keypoints.glsl\": \"./src/gpu/shaders/encoders/encode-keypoints.glsl\",\n\t\"./encoders/resize-encoded-keypoints.glsl\": \"./src/gpu/shaders/encoders/resize-encoded-keypoints.glsl\",\n\t\"./encoders/upload-keypoints.glsl\": \"./src/gpu/shaders/encoders/upload-keypoints.glsl\",\n\t\"./enhancements/nightvision.glsl\": \"./src/gpu/shaders/enhancements/nightvision.glsl\",\n\t\"./enhancements/normalize-image.glsl\": \"./src/gpu/shaders/enhancements/normalize-image.glsl\",\n\t\"./filters/convolution\": \"./src/gpu/shaders/filters/convolution.js\",\n\t\"./filters/convolution.js\": \"./src/gpu/shaders/filters/convolution.js\",\n\t\"./filters/fast-median.glsl\": \"./src/gpu/shaders/filters/fast-median.glsl\",\n\t\"./filters/median\": \"./src/gpu/shaders/filters/median.js\",\n\t\"./filters/median.js\": \"./src/gpu/shaders/filters/median.js\",\n\t\"./filters/multiscale-sobel.glsl\": \"./src/gpu/shaders/filters/multiscale-sobel.glsl\",\n\t\"./include/colors.glsl\": \"./src/gpu/shaders/include/colors.glsl\",\n\t\"./include/fixed-point.glsl\": \"./src/gpu/shaders/include/fixed-point.glsl\",\n\t\"./include/global.glsl\": \"./src/gpu/shaders/include/global.glsl\",\n\t\"./include/keypoints.glsl\": \"./src/gpu/shaders/include/keypoints.glsl\",\n\t\"./include/math.glsl\": \"./src/gpu/shaders/include/math.glsl\",\n\t\"./include/orientation.glsl\": \"./src/gpu/shaders/include/orientation.glsl\",\n\t\"./include/pyramids.glsl\": \"./src/gpu/shaders/include/pyramids.glsl\",\n\t\"./include/quickselect.glsl\": \"./src/gpu/shaders/include/quickselect.glsl\",\n\t\"./include/sobel.glsl\": \"./src/gpu/shaders/include/sobel.glsl\",\n\t\"./keypoints/brisk.glsl\": \"./src/gpu/shaders/keypoints/brisk.glsl\",\n\t\"./keypoints/fast-score12.glsl\": \"./src/gpu/shaders/keypoints/fast-score12.glsl\",\n\t\"./keypoints/fast-score16.glsl\": \"./src/gpu/shaders/keypoints/fast-score16.glsl\",\n\t\"./keypoints/fast-score8.glsl\": \"./src/gpu/shaders/keypoints/fast-score8.glsl\",\n\t\"./keypoints/fast5.glsl\": \"./src/gpu/shaders/keypoints/fast5.glsl\",\n\t\"./keypoints/fast7.glsl\": \"./src/gpu/shaders/keypoints/fast7.glsl\",\n\t\"./keypoints/fast9lg.glsl\": \"./src/gpu/shaders/keypoints/fast9lg.glsl\",\n\t\"./keypoints/harris-cutoff.glsl\": \"./src/gpu/shaders/keypoints/harris-cutoff.glsl\",\n\t\"./keypoints/multiscale-fast.glsl\": \"./src/gpu/shaders/keypoints/multiscale-fast.glsl\",\n\t\"./keypoints/multiscale-harris.glsl\": \"./src/gpu/shaders/keypoints/multiscale-harris.glsl\",\n\t\"./keypoints/multiscale-suppression.glsl\": \"./src/gpu/shaders/keypoints/multiscale-suppression.glsl\",\n\t\"./keypoints/nonmax-suppression.glsl\": \"./src/gpu/shaders/keypoints/nonmax-suppression.glsl\",\n\t\"./keypoints/orb-descriptor.glsl\": \"./src/gpu/shaders/keypoints/orb-descriptor.glsl\",\n\t\"./keypoints/orientation-via-centroid.glsl\": \"./src/gpu/shaders/keypoints/orientation-via-centroid.glsl\",\n\t\"./keypoints/samescale-suppression.glsl\": \"./src/gpu/shaders/keypoints/samescale-suppression.glsl\",\n\t\"./keypoints/sort-by-score.glsl\": \"./src/gpu/shaders/keypoints/sort-by-score.glsl\",\n\t\"./pyramids/downsample2.glsl\": \"./src/gpu/shaders/pyramids/downsample2.glsl\",\n\t\"./pyramids/upsample2.glsl\": \"./src/gpu/shaders/pyramids/upsample2.glsl\",\n\t\"./trackers/lk-discard.glsl\": \"./src/gpu/shaders/trackers/lk-discard.glsl\",\n\t\"./trackers/lk.glsl\": \"./src/gpu/shaders/trackers/lk.glsl\",\n\t\"./utils/copy-components.glsl\": \"./src/gpu/shaders/utils/copy-components.glsl\",\n\t\"./utils/fill-components.glsl\": \"./src/gpu/shaders/utils/fill-components.glsl\",\n\t\"./utils/fill.glsl\": \"./src/gpu/shaders/utils/fill.glsl\",\n\t\"./utils/flip-y.glsl\": \"./src/gpu/shaders/utils/flip-y.glsl\",\n\t\"./utils/identity.glsl\": \"./src/gpu/shaders/utils/identity.glsl\",\n\t\"./utils/scan-minmax2d.glsl\": \"./src/gpu/shaders/utils/scan-minmax2d.glsl\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./src/gpu/shaders sync recursive ^\\\\.\\\\/.*$\";","module.exports = \"const vec4 grey = vec4(0.299f, 0.587f, 0.114f, 0.0f);\\nuniform sampler2D image;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nfloat g = dot(pixel, grey);\\ncolor = vec4(g, g, g, 1.0f);\\n}\"","module.exports = \"uniform sampler2D offsetsImage;\\nuniform ivec2 imageSize;\\n#ifndef MAX_ITERATIONS\\n#error Must define MAX_ITERATIONS\\n#endif\\n#define decodeSkipOffset(pixel) int((pixel).b * 255.0f) | (int((pixel).a * 255.0f) << 8)\\n#define encodeSkipOffset(offset) vec2((offset) & 255, (offset) >> 8) / 255.0f\\nvoid main()\\n{\\nvec4 pixel = threadPixel(offsetsImage);\\nivec2 thread = threadLocation();\\nvec2 prefix = pixel.rg;\\nint rasterIndex = thread.y * imageSize.x + thread.x;\\nint offset = decodeSkipOffset(pixel);\\nint totalOffset = offset;\\nivec2 pos = thread;\\n#if 0\\nwhile(offset < MAX_ITERATIONS && pos.y < imageSize.y && pixel.r == 0.0f) {\\nrasterIndex += offset;\\npos = ivec2(rasterIndex % imageSize.x, rasterIndex / imageSize.x);\\npixel = pixelAt(offsetsImage, pos);\\noffset = decodeSkipOffset(pixel);\\ntotalOffset += offset;\\n}\\n#else\\nint allow = 1;\\nfor(int i = 0; i < MAX_ITERATIONS; i++) {\\nallow *= int(pos.y < imageSize.y) * int(pixel.r == 0.0f);\\nrasterIndex += allow * offset;\\npos = ivec2(rasterIndex % imageSize.x, rasterIndex / imageSize.x);\\npixel = pixelAt(offsetsImage, pos);\\noffset = decodeSkipOffset(pixel);\\ntotalOffset += allow * offset;\\n}\\n#endif\\ntotalOffset = min(totalOffset, 65535);\\ncolor = vec4(prefix, encodeSkipOffset(totalOffset));\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform ivec2 imageSize;\\n#if !defined(MAX_ITERATIONS)\\n#error Must define MAX_ITERATIONS\\n#elif MAX_ITERATIONS > 255\\n#error MAX_ITERATIONS must be less than 256\\n#endif\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nivec2 pos = threadLocation();\\nvec2 prefix = pixel.ra;\\nint offset = 0;\\n#if 0\\nwhile(offset < MAX_ITERATIONS && pos.y < imageSize.y && pixelAt(image, pos).r == 0.0f) {\\n++offset;\\npos.x = (pos.x + 1) % imageSize.x;\\npos.y += int(pos.x == 0);\\n}\\n#else\\nint allow = 1;\\nfor(int i = 0; i < MAX_ITERATIONS; i++) {\\nallow *= int(pos.y < imageSize.y) * int(pixel.r == 0.0f);\\noffset += allow;\\npos.x = (pos.x + 1) % imageSize.x;\\npos.y += int(pos.x == 0);\\npixel = pixelAt(image, pos);\\n}\\n#endif\\ncolor = vec4(prefix, float(offset) / 255.0f, 0.0f);\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform sampler2D offsetsImage;\\nuniform sampler2D encodedKeypoints;\\nuniform ivec2 imageSize;\\nuniform int passId;\\nuniform int numPasses;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int encoderLength;\\n#define decodeSkipOffset(pixel) int((pixel).b * 255.0f) | (int((pixel).a * 255.0f) << 8)\\nbool findQthKeypoint(int q, int p, inout ivec2 position, out vec4 pixel)\\n{\\nint notFirstPass = int(passId > 0);\\nposition *= notFirstPass;\\np |= -(1 - notFirstPass);\\np -= notFirstPass;\\nint rasterIndex = position.y * imageSize.x + position.x;\\nwhile(position.y < imageSize.y && p != q) {\\nposition = ivec2(rasterIndex % imageSize.x, rasterIndex / imageSize.x);\\npixel = texelFetch(offsetsImage, position, 0);\\np += int(pixel.r > 0.0f);\\nrasterIndex += max(1, decodeSkipOffset(pixel));\\n}\\nreturn (p == q);\\n}\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\\nint q = findKeypointIndex(address, descriptorSize, extraSize);\\ncolor = vec4(0.0f);\\nif(address.offset > 1)\\nreturn;\\ncolor = threadPixel(encodedKeypoints);\\nint numPixels = encoderLength * encoderLength;\\nint maxKeypoints = numPixels / pixelsPerKeypoint;\\nint maxKeypointsPerPass = maxKeypoints / numPasses + int(maxKeypoints % numPasses != 0);\\nint targetPassId = q / maxKeypointsPerPass;\\nif(passId != targetPassId)\\nreturn;\\n#if 1\\nint lastIndexFromPrevPass = passId * maxKeypointsPerPass - 1;\\nKeypointAddress lastAddressFromPrevPass = KeypointAddress(max(0, lastIndexFromPrevPass) * pixelsPerKeypoint, 0);\\nKeypoint lastKeypointFromPrevPass = decodeKeypoint(encodedKeypoints, encoderLength, lastAddressFromPrevPass);\\nivec2 position = ivec2(lastKeypointFromPrevPass.position);\\n#else\\nint lastIndexFromPrevPass = -1; ivec2 position = ivec2(0);\\n#endif\\nvec4 pixel;\\ncolor = encodeNullKeypoint();\\nif(q >= maxKeypoints || !findQthKeypoint(q, lastIndexFromPrevPass, position, pixel))\\nreturn;\\ncolor = (address.offset == 1) ? vec4(\\npixel.g,\\n0.0f,\\npixel.r,\\nencodeKeypointFlags(KPF_NONE)\\n) : encodeKeypointPosition(\\nvec2(position)\\n);\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform sampler2D inputTexture;\\nuniform int inputDescriptorSize;\\nuniform int inputExtraSize;\\nuniform int inputEncoderLength;\\nuniform int outputDescriptorSize;\\nuniform int outputExtraSize;\\nuniform int outputEncoderLength;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(inputTexture);\\nivec2 thread = threadLocation();\\nKeypointAddress myAddress = findKeypointAddress(\\nthread,\\noutputEncoderLength,\\noutputDescriptorSize,\\noutputExtraSize\\n);\\nint myIndex = findKeypointIndex(\\nmyAddress,\\noutputDescriptorSize,\\noutputExtraSize\\n);\\nint pixelsPerKeypoint = sizeofEncodedKeypoint(inputDescriptorSize, inputExtraSize) / 4;\\nKeypointAddress otherAddress = KeypointAddress(\\nmyIndex * pixelsPerKeypoint,\\nmyAddress.offset\\n);\\nint head = MIN_KEYPOINT_SIZE / 4;\\nint rasterIndex = otherAddress.base + otherAddress.offset;\\ncolor = (myAddress.offset >= head) ? vec4(0.0f) :\\nreadKeypointData(inputTexture, inputEncoderLength, rasterIndex);\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform int keypointCount;\\nuniform int encoderLength;\\nuniform int descriptorSize;\\nuniform int extraSize;\\n#ifndef KEYPOINT_BUFFER_LENGTH\\n#error Must specify KEYPOINT_BUFFER_LENGTH\\n#endif\\nlayout(std140) uniform KeypointBuffer\\n{\\nvec4 keypointBuffer[KEYPOINT_BUFFER_LENGTH];\\n};\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\\nint q = findKeypointIndex(address, descriptorSize, extraSize);\\ncolor = vec4(1.0f);\\nif(q >= keypointCount)\\nreturn;\\nvec4 data = keypointBuffer[q];\\nswitch(address.offset) {\\ncase 0: {\\nfixed2_t pos = vec2tofix(data.xy);\\nfixed2_t lo = pos & 255;\\nfixed2_t hi = pos >> 8;\\ncolor = vec4(float(lo.x), float(hi.x), float(lo.y), float(hi.y)) / 255.0f;\\nbreak;\\n}\\ncase 1: {\\nfloat score = data.w;\\nfloat scale = encodeLod(data.z);\\nfloat rotation = encodeOrientation(0.0f);\\ncolor = vec4(scale, rotation, score, 0.0f);\\nbreak;\\n}\\ndefault: {\\ncolor = vec4(0.0f);\\nbreak;\\n}\\n}\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform sampler2D illuminationMap;\\nuniform float gain;\\nuniform float offset;\\nuniform float decay;\\nconst mat3 rgb2yuv = mat3(\\n0.299f, -0.14713f, 0.615f,\\n0.587f, -0.28886f, -0.51499f,\\n0.114f, 0.436f, -0.10001f\\n);\\nconst mat3 yuv2rgb = mat3(\\n1.0f, 1.0f, 1.0f,\\n0.0f, -0.39465f, 2.03211f,\\n1.13983f, -0.58060f, 0.0f\\n);\\nconst float eps = 0.0001f;\\nconst float sqrt2 = 1.4142135623730951f;\\nconst float magic = 20.0f;\\nconst vec2 center = vec2(0.5f);\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nvec4 imapPixel = threadPixel(illuminationMap);\\nfloat lambda = -sqrt2 * log(max(1.0f - decay, eps));\\nfloat dist = length(texCoord - center);\\nfloat vgain = gain * exp(-lambda * dist);\\nfloat normalizedGain = 2.0f * vgain;\\nfloat normalizedOffset = 2.0f * offset - 1.0f;\\n#ifdef GREYSCALE\\nfloat luma = 1.0 / (1.0 + exp(-normalizedGain * magic * (pixel.g - imapPixel.g)));\\nluma = clamp(luma + normalizedOffset, 0.0f, 1.0f);\\ncolor = vec4(luma, luma, luma, 1.0f);\\n#else\\nvec3 yuvPixel = rgb2yuv * pixel.rgb;\\nvec3 yuvImapPixel = rgb2yuv * imapPixel.rgb;\\nfloat luma = 1.0 / (1.0 + exp(-normalizedGain * magic * (yuvPixel.r - yuvImapPixel.r)));\\nluma += normalizedOffset;\\nvec3 rgbCorrectedPixel = yuv2rgb * vec3(luma, yuvPixel.gb);\\nrgbCorrectedPixel = clamp(rgbCorrectedPixel, 0.0f, 1.0f);\\ncolor = vec4(rgbCorrectedPixel, 1.0f);\\n#endif\\n}\"","module.exports = \"#ifdef GREYSCALE\\nuniform sampler2D minmax2d;\\n#else\\nuniform sampler2D minmax2dRGB[3];\\n#endif\\nuniform float minValue;\\nuniform float maxValue;\\nconst float eps = 1.0f / 255.0f;\\nvoid main()\\n{\\nvec2 minmax = clamp(vec2(minValue, maxValue), 0.0f, 255.0f) / 255.0f;\\nvec4 newMin = vec4(minmax.x);\\nvec4 newRange = vec4(minmax.y - minmax.x);\\nvec4 alpha = vec4(1.0f, newMin.x, newRange.x, 1.0f);\\n#ifdef GREYSCALE\\nvec4 pixel = threadPixel(minmax2d);\\nmat4 channel = mat4(pixel, pixel, pixel, alpha);\\n#else\\nmat4 channel = mat4(\\nthreadPixel(minmax2dRGB[0]),\\nthreadPixel(minmax2dRGB[1]),\\nthreadPixel(minmax2dRGB[2]),\\nalpha\\n);\\n#endif\\nvec4 oldMin = vec4(channel[0].g, channel[1].g, channel[2].g, channel[3].g);\\nvec4 oldRange = max(vec4(channel[0].b, channel[1].b, channel[2].b, channel[3].b), eps);\\nvec4 oldIntensity = vec4(channel[0].a, channel[1].a, channel[2].a, channel[3].a);\\nvec4 newIntensity = (oldIntensity - oldMin) * newRange / oldRange + newMin;\\ncolor = newIntensity;\\n}\"","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * convolution.js\n * Convolution shader generators\n */\n\nimport { createShader } from '../../shader-declaration';\nimport { Utils } from '../../../utils/utils';\nimport { IllegalArgumentError } from '../../../utils/errors';\n\n\n\n/**\n * Generate a 2D convolution with a square kernel\n * @param {Array<number>} kernel convolution kernel\n * @param {number} [normalizationConstant] will be multiplied by all kernel entries\n */\nexport function conv2D(kernel, normalizationConstant = 1.0)\n{\n    const kernel32 = new Float32Array(kernel.map(x => (+x) * (+normalizationConstant)));\n    const kSize = Math.sqrt(kernel32.length) | 0;\n    const N = kSize >> 1; // idiv 2\n\n    // validate input\n    if(kSize < 1 || kSize % 2 == 0)\n        throw new IllegalArgumentError(`Can't perform a 2D convolution with an invalid kSize of ${kSize}`);\n    else if(kSize * kSize != kernel32.length)\n        throw new IllegalArgumentError(`Invalid 2D convolution kernel of ${kernel32.length} elements (expected: square)`);\n\n    // select the appropriate pixel function\n    const pixelAtOffset = (N <= 7) ? 'pixelAtShortOffset' : 'pixelAtLongOffset';\n\n    // code generator\n    const foreachKernelElement = fn => Utils.cartesian(Utils.symmetricRange(N), Utils.symmetricRange(N)).map(\n        cur => fn(\n            kernel32[(cur[0] + N) * kSize + (cur[1] + N)],\n            cur[0], cur[1]\n        )\n    ).join('\\n');\n\n    const generateCode = (k, dy, dx) => `\n        result += ${pixelAtOffset}(image, ivec2(${dx | 0}, ${dy | 0})) * float(${+k});\n    `;\n\n    // shader\n    const source = `\n    uniform sampler2D image;\n\n    void main()\n    {\n        float alpha = threadPixel(image).a;\n        vec4 result = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n\n        ${foreachKernelElement(generateCode)}\n\n        color = vec4(result.rgb, alpha);\n    }\n    `;\n\n    // done!\n    return createShader(source).withArguments('image');\n}\n\n\n\n\n/**\n * Generate a 1D convolution function on the x-axis\n * @param {Array<number>} kernel convolution kernel\n * @param {number} [normalizationConstant] will be multiplied by all kernel entries\n */\nexport function convX(kernel, normalizationConstant = 1.0)\n{\n    return conv1D('x', kernel, normalizationConstant);\n}\n\n\n\n\n/**\n * Generate a 1D convolution function on the y-axis\n * @param {Array<number>} kernel convolution kernel\n * @param {number} [normalizationConstant] will be multiplied by all kernel entries\n */\nexport function convY(kernel, normalizationConstant = 1.0)\n{\n    return conv1D('y', kernel, normalizationConstant);\n}\n\n\n\n\n/**\n * 1D convolution function generator\n * @param {string} axis either \"x\" or \"y\"\n * @param {Array<number>} kernel convolution kernel\n * @param {number} [normalizationConstant] will be multiplied by all kernel entries\n */\nfunction conv1D(axis, kernel, normalizationConstant = 1.0)\n{\n    const kernel32 = new Float32Array(kernel.map(x => (+x) * (+normalizationConstant)));\n    const kSize = kernel32.length;\n    const N = kSize >> 1; // idiv 2\n\n    // validate input\n    if(kSize < 1 || kSize % 2 == 0)\n        throw new IllegalArgumentError(`Can't perform a 1D convolution with an invalid kSize of ${kSize}`);\n    else if(axis != 'x' && axis != 'y')\n        throw new IllegalArgumentError(`Can't perform 1D convolution: invalid axis \"${axis}\"`); // this should never happen\n\n    // select the appropriate pixel function\n    const pixelAtOffset = (N <= 7) ? 'pixelAtShortOffset' : 'pixelAtLongOffset';\n\n    // code generator\n    const foreachKernelElement = fn => Utils.symmetricRange(N).reduce(\n        (acc, cur) => acc + fn(kernel32[cur + N], cur),\n    '');\n    const generateCode = (k, i) => ((axis == 'x') ? `\n        pixel += ${pixelAtOffset}(image, ivec2(${i | 0}, 0)) * float(${+k});\n    ` : `\n        pixel += ${pixelAtOffset}(image, ivec2(0, ${i | 0})) * float(${+k});\n    `);\n\n    // shader\n    const source = `\n    uniform sampler2D image;\n\n    void main()\n    {\n        float alpha = threadPixel(image).a;\n        vec4 pixel = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n\n        ${foreachKernelElement(generateCode)}\n\n        color = vec4(pixel.rgb, alpha);\n    }\n    `;\n\n    // done!\n    return createShader(source).withArguments('image');\n}\n\n\n\n\n\n/*\n * ------------------------------------------------------------------\n * Texture Encoding\n * Encoding a float in [0,1] into RGB[A]\n * ------------------------------------------------------------------\n * Define frac(x) := x - floor(x)\n * Of course, 0 <= frac(x) < 1.\n * \n * Given: x in [0,1]\n * \n * Define e0 := floor(x),\n *        e1 := 256 frac(x)\n *        e2 := 256 frac(e1) = 256 frac(256 frac(x))\n *        e3 := 256 frac(e2) = 256 frac(256 frac(e1)) = 256 frac(256 frac(256 frac(x))),\n *        ...\n *        more generally,\n *        ej := 256 frac(e_{j-1}), j >= 2\n * \n * Since x = frac(x) + floor(x), it follows that\n * x = floor(x) + 256 frac(x) / 256 = e0 + e1 / 256 = e0 + (frac(e1) + floor(e1)) / 256 =\n * e0 + (256 frac(e1) + 256 floor(e1)) / (256^2) = e0 + (e2 + 256 floor(e1)) / (256^2) =\n * e0 + ((256 frac(e2) + 256 floor(e2)) + 256^2 floor(e1)) / (256^3) =\n * e0 + (e3 + 256 floor(e2) + 256^2 floor(e1)) / (256^3) = \n * floor(e0) + floor(e1) / 256 + floor(e2) / (256^2) + e3 / (256^3) = ... =\n * floor(e0) + floor(e1) / 256 + floor(e2) / (256^2) + floor(e3) / (256^3) + e4 / (256^4) = ... ~\n * \\sum_{i >= 0} floor(e_i) / 256^i\n * \n * Observe that e0 in {0, 1} and, for j >= 1, 0 <= e_j < 256, meaning that\n * e0 and (e_j / 256) can be stored in a 8-bit color channel.\n * \n * We now have approximations for x:\n * x ~ x0 <-- first order\n * x ~ x0 + x1 / 256 <-- second order\n * x ~ x0 + x1 / 256 + x2 / (256^2) <-- third order (RGB)\n * x ~ x0 + x1 / 256 + x2 / (256^2) + x3 / (256^3) <-- fourth order (RGBA)\n * where x_i = floor(e_i).\n */\n\n\n\n\n/**\n * Generate a texture-based 2D convolution kernel of size\n * (kernelSize x kernelSize), where all entries belong to\n * the [0, 1] range\n * @param {number} kernelSize odd number, e.g., 3 to create a 3x3 kernel, and so on\n */\nexport function createKernel2D(kernelSize)\n{\n    // validate input\n    kernelSize |= 0;\n    if(kernelSize < 1 || kernelSize % 2 == 0)\n        throw new IllegalArgumentError(`Can't create a 2D texture kernel of size ${kernelSize}`);\n\n    // encode float in the [0,1] range to RGBA\n    const shader = `\n    uniform float kernel[${kernelSize * kernelSize}];\n\n    void main()\n    {\n        ivec2 thread = threadLocation();\n        float val = kernel[(${kernelSize}) * thread.y + thread.x];\n\n        float e0 = floor(val);\n        float e1 = 256.0f * fract(val);\n        float e2 = 256.0f * fract(e1);\n        float e3 = 256.0f * fract(e2);\n\n        color = vec4(e0, floor(e1) / 256.0f, floor(e2) / 256.0f, floor(e3) / 256.0f);\n    }\n    `;\n\n    // IMPORTANT: all entries of the input kernel\n    // are assumed to be in the [0, 1] range AND\n    // kernel.length >= kernelSize * kernelSize\n    return createShader(shader).withArguments('kernel');\n}\n\n\n\n\n/**\n * Generate a texture-based 1D convolution kernel of size\n * (kernelSize x 1), where all entries belong to the [0,1] range\n * @param {number} kernelSize odd number\n */\nexport function createKernel1D(kernelSize)\n{\n    // validate input\n    kernelSize |= 0;\n    if(kernelSize < 1 || kernelSize % 2 == 0)\n        throw new IllegalArgumentError(`Can't create a 1D texture kernel of size ${kernelSize}`);\n\n    // encode float in the [0,1] range to RGBA\n    const shader = `\n    uniform float kernel[${kernelSize}];\n\n    void main()\n    {\n        ivec2 thread = threadLocation();\n        float val = kernel[thread.x];\n\n        float e0 = floor(val);\n        float e1 = 256.0f * fract(val);\n        float e2 = 256.0f * fract(e1);\n        float e3 = 256.0f * fract(e2);\n\n        color = vec4(e0, floor(e1) / 256.0f, floor(e2) / 256.0f, floor(e3) / 256.0f);\n    }\n    `;\n\n    // IMPORTANT: all entries of the input kernel\n    // are assumed to be in the [0, 1] range AND\n    // kernel.length >= kernelSize\n    return createShader(shader).withArguments('kernel');\n}\n\n\n\n\n/**\n * 2D convolution with a texture-based kernel of size\n * kernelSize x kernelSize, with optional scale & offset\n * By default, scale and offset are 1 and 0, respectively\n * @param {number} kernelSize odd number, e.g., 3 to create a 3x3 kernel, and so on\n */\nexport function texConv2D(kernelSize)\n{\n    // validate input\n    const N = kernelSize >> 1; // idiv 2\n    if(kernelSize < 1 || kernelSize % 2 == 0)\n        throw new IllegalArgumentError(`Can't perform a texture-based 2D convolution with an invalid kernel size of ${kernelSize}`);\n\n    // select the appropriate pixel function\n    const pixelAtOffset = (N <= 7) ? 'pixelAtShortOffset' : 'pixelAtLongOffset';\n\n    // utilities\n    const foreachKernelElement = fn => Utils.cartesian(Utils.symmetricRange(N), Utils.symmetricRange(N)).map(\n        ij => fn(ij[0], ij[1])\n    ).join('\\n');\n\n    const generateCode = (i, j) => `\n        kernel = pixelAt(texKernel, ivec2(${i + N}, ${j + N}));\n        value = dot(kernel, magic) * scale + offset;\n        result += ${pixelAtOffset}(image, ivec2(${i}, ${j})) * value;\n    `;\n\n    // image: target image\n    // texKernel: convolution kernel (all entries in [0,1])\n    // scale: multiply the kernel entries by a number (like 1.0)\n    // offset: add a number to all kernel entries (like 0.0)\n    const shader = `\n    const vec4 magic = vec4(1.0f, 1.0f, 1.0f / 256.0f, 1.0f / 65536.0f);\n    uniform sampler2D image, texKernel;\n    uniform float scale, offset;\n\n    void main()\n    {\n        vec4 kernel = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n        vec4 result = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n        float alpha = threadPixel(image).a;\n        float value = 0.0f;\n\n        ${foreachKernelElement(generateCode)}\n\n        result = clamp(result, 0.0f, 1.0f);\n        color = vec4(result.rgb, alpha);\n    }\n    `;\n\n    // done!\n    return createShader(shader).withArguments('image', 'texKernel', 'scale', 'offset');\n}\n\n\n\n\n/**\n * Texture-based 1D convolution on the x-axis\n * @param {number} kernelSize odd number\n */\nexport const texConvX = kernelSize => texConv1D(kernelSize, 'x');\n\n\n\n/**\n * Texture-based 1D convolution on the x-axis\n * @param {number} kernelSize odd number\n */\nexport const texConvY = kernelSize => texConv1D(kernelSize, 'y');\n\n\n\n\n/**\n * Texture-based 1D convolution function generator\n * (the convolution kernel is stored in a texture)\n * @param {number} kernelSize odd number\n * @param {string} axis either \"x\" or \"y\"\n */\nfunction texConv1D(kernelSize, axis)\n{\n    // validate input\n    const N = kernelSize >> 1; // idiv 2\n    if(kernelSize < 1 || kernelSize % 2 == 0)\n        throw new IllegalArgumentError(`Can't perform a texture-based 2D convolution with an invalid kernel size of ${kernelSize}`);\n    else if(axis != 'x' && axis != 'y')\n        throw new IllegalArgumentError(`Can't perform a texture-based 1D convolution: invalid axis \"${axis}\"`); // this should never happen\n\n    // select the appropriate pixel function\n    const pixelAtOffset = (N <= 7) ? 'pixelAtShortOffset' : 'pixelAtLongOffset';\n\n    // utilities\n    const foreachKernelElement = fn => Utils.symmetricRange(N).map(fn).join('\\n');\n    const generateCode = i => ((axis == 'x') ? `\n        kernel = pixelAt(texKernel, ivec2(${i + N}, 0));\n        value = dot(kernel, magic) * scale + offset;\n        result += ${pixelAtOffset}(image, ivec2(${i}, 0)) * value;\n    ` : `\n        kernel = pixelAt(texKernel, ivec2(${i + N}, 0));\n        value = dot(kernel, magic) * scale + offset;\n        result += ${pixelAtOffset}(image, ivec2(0, ${i})) * value;\n    `);\n\n    // image: target image\n    // texKernel: convolution kernel (all entries in [0,1])\n    // scale: multiply the kernel entries by a number (like 1.0)\n    // offset: add a number to all kernel entries (like 0.0)\n    const shader = `\n    const vec4 magic = vec4(1.0f, 1.0f, 1.0f / 256.0f, 1.0f / 65536.0f);\n    uniform sampler2D image, texKernel;\n    uniform float scale, offset;\n\n    void main()\n    {\n        vec4 kernel = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n        vec4 result = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n        float alpha = threadPixel(image).a;\n        float value = 0.0f;\n\n        ${foreachKernelElement(generateCode)}\n\n        result = clamp(result, 0.0f, 1.0f);\n        color = vec4(result.rgb, alpha);\n    }\n    `;\n\n    // done!\n    return createShader(shader).withArguments('image', 'texKernel', 'scale', 'offset');\n}","module.exports = \"uniform sampler2D image;\\n#define SORT(i, j) t = p[i] + p[j]; p[i] = min(p[i], p[j]); p[j] = t - p[i];\\nvoid main()\\n{\\nfloat median, t;\\n#if WINDOW_SIZE == 3\\nfloat p[9];\\np[0] = pixelAtShortOffset(image, ivec2(-1,-1)).g;\\np[1] = pixelAtShortOffset(image, ivec2(0,-1)).g;\\np[2] = pixelAtShortOffset(image, ivec2(1,-1)).g;\\np[3] = pixelAtShortOffset(image, ivec2(-1,0)).g;\\np[4] = pixelAtShortOffset(image, ivec2(0,0)).g;\\np[5] = pixelAtShortOffset(image, ivec2(1,0)).g;\\np[6] = pixelAtShortOffset(image, ivec2(-1,1)).g;\\np[7] = pixelAtShortOffset(image, ivec2(0,1)).g;\\np[8] = pixelAtShortOffset(image, ivec2(1,1)).g;\\nSORT(1,2);\\nSORT(4,5);\\nSORT(7,8);\\nSORT(0,1);\\nSORT(3,4);\\nSORT(6,7);\\nSORT(1,2);\\nSORT(4,5);\\nSORT(7,8);\\nSORT(0,3);\\nSORT(5,8);\\nSORT(4,7);\\nSORT(3,6);\\nSORT(1,4);\\nSORT(2,5);\\nSORT(4,7);\\nSORT(4,2);\\nSORT(6,4);\\nSORT(4,2);\\nmedian = p[4];\\n#elif WINDOW_SIZE == 5\\nfloat p[25];\\np[0] = pixelAtShortOffset(image, ivec2(-2,-2)).g;\\np[1] = pixelAtShortOffset(image, ivec2(-1,-2)).g;\\np[2] = pixelAtShortOffset(image, ivec2(0,-2)).g;\\np[3] = pixelAtShortOffset(image, ivec2(1,-2)).g;\\np[4] = pixelAtShortOffset(image, ivec2(2,-2)).g;\\np[5] = pixelAtShortOffset(image, ivec2(-2,-1)).g;\\np[6] = pixelAtShortOffset(image, ivec2(-1,-1)).g;\\np[7] = pixelAtShortOffset(image, ivec2(0,-1)).g;\\np[8] = pixelAtShortOffset(image, ivec2(1,-1)).g;\\np[9] = pixelAtShortOffset(image, ivec2(2,-1)).g;\\np[10] = pixelAtShortOffset(image, ivec2(-2,0)).g;\\np[11] = pixelAtShortOffset(image, ivec2(-1,0)).g;\\np[12] = pixelAtShortOffset(image, ivec2(0,0)).g;\\np[13] = pixelAtShortOffset(image, ivec2(1,0)).g;\\np[14] = pixelAtShortOffset(image, ivec2(2,0)).g;\\np[15] = pixelAtShortOffset(image, ivec2(-2,1)).g;\\np[16] = pixelAtShortOffset(image, ivec2(-1,1)).g;\\np[17] = pixelAtShortOffset(image, ivec2(0,1)).g;\\np[18] = pixelAtShortOffset(image, ivec2(1,1)).g;\\np[19] = pixelAtShortOffset(image, ivec2(2,1)).g;\\np[20] = pixelAtShortOffset(image, ivec2(-2,2)).g;\\np[21] = pixelAtShortOffset(image, ivec2(-1,2)).g;\\np[22] = pixelAtShortOffset(image, ivec2(0,2)).g;\\np[23] = pixelAtShortOffset(image, ivec2(1,2)).g;\\np[24] = pixelAtShortOffset(image, ivec2(2,2)).g;\\nSORT(0,1);\\nSORT(3,4);\\nSORT(2,4);\\nSORT(2,3);\\nSORT(6,7);\\nSORT(5,7);\\nSORT(5,6);\\nSORT(9,10);\\nSORT(8,10);\\nSORT(8,9);\\nSORT(12,13);\\nSORT(11,13);\\nSORT(11,12);\\nSORT(15,16);\\nSORT(14,16);\\nSORT(14,15);\\nSORT(18,19);\\nSORT(17,19);\\nSORT(17,18);\\nSORT(21,22);\\nSORT(20,22);\\nSORT(20,21);\\nSORT(23,24);\\nSORT(2,5);\\nSORT(3,6);\\nSORT(0,6);\\nSORT(0,3);\\nSORT(4,7);\\nSORT(1,7);\\nSORT(1,4);\\nSORT(11,14);\\nSORT(8,14);\\nSORT(8,11);\\nSORT(12,15);\\nSORT(9,15);\\nSORT(9,12);\\nSORT(13,16);\\nSORT(10,16);\\nSORT(10,13);\\nSORT(20,23);\\nSORT(17,23);\\nSORT(17,20);\\nSORT(21,24);\\nSORT(18,24);\\nSORT(18,21);\\nSORT(19,22);\\nSORT(8,17);\\nSORT(9,18);\\nSORT(0,18);\\nSORT(0,9);\\nSORT(10,19);\\nSORT(1,19);\\nSORT(1,10);\\nSORT(11,20);\\nSORT(2,20);\\nSORT(2,11);\\nSORT(12,21);\\nSORT(3,21);\\nSORT(3,12);\\nSORT(13,22);\\nSORT(4,22);\\nSORT(4,13);\\nSORT(14,23);\\nSORT(5,23);\\nSORT(5,14);\\nSORT(15,24);\\nSORT(6,24);\\nSORT(6,15);\\nSORT(7,16);\\nSORT(7,19);\\nSORT(13,21);\\nSORT(15,23);\\nSORT(7,13);\\nSORT(7,15);\\nSORT(1,9);\\nSORT(3,11);\\nSORT(5,17);\\nSORT(11,17);\\nSORT(9,17);\\nSORT(4,10);\\nSORT(6,12);\\nSORT(7,14);\\nSORT(4,6);\\nSORT(4,7);\\nSORT(12,14);\\nSORT(10,14);\\nSORT(6,7);\\nSORT(10,12);\\nSORT(6,10);\\nSORT(6,17);\\nSORT(12,17);\\nSORT(7,17);\\nSORT(7,10);\\nSORT(12,18);\\nSORT(7,12);\\nSORT(10,18);\\nSORT(12,20);\\nSORT(10,20);\\nSORT(10,12);\\nmedian = p[12];\\n#else\\n#error Unsupported window size\\n#endif\\ncolor = vec4(median, median, median, 1.0f);\\n}\"","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * median.js\n * Median filter generator\n */\n\nimport { createShader } from '../../shader-declaration';\nimport { Utils } from '../../../utils/utils';\nimport { IllegalArgumentError } from '../../../utils/errors';\n\n/**\n * Generate a median filter with a\n * (windowSize x windowSize) window\n * (for greyscale images only)\n * @param {number} windowSize 3, 5, 7, ...\n */\nexport function median(windowSize)\n{\n    // validate argument\n    windowSize |= 0;\n    if(windowSize <= 1 || windowSize % 2 == 0)\n        throw new IllegalArgumentError(`Can't create median filter with a ${windowSize}x${windowSize} window`);\n\n    // prepare data\n    const maxOffset = windowSize >> 1;\n    const pixelAtOffset = maxOffset <= 7 ? 'pixelAtShortOffset' : 'pixelAtLongOffset';\n    const n = windowSize * windowSize;\n    const med = n >> 1;\n\n    // code generator\n    const foreachWindowElement = fn => Utils.cartesian(\n        Utils.symmetricRange(maxOffset), Utils.symmetricRange(maxOffset)\n    ).map(\n        (pair, idx) => fn(idx, pair[0], pair[1])\n    ).join('\\n');\n    const readPixel = (k, j, i) => `\n        v[${k}] = ${pixelAtOffset}(image, ivec2(${i}, ${j})).g;\n    `;\n\n    // selection sort: unrolled & branchless\n    // TODO implement a faster selection algorithm\n    const foreachVectorElement = fn => Utils.range(med + 1).map(fn).join('\\n');\n    const findMinimum = j => Utils.range(n - (j + 1)).map(x => x + j + 1).map(i => `\n        m += int(v[${i}] >= v[m]) * (${i} - m);\n    `).join('\\n');\n    const selectMinimum = j => `\n        m = ${j};\n        ${findMinimum(j)}\n        swpv = v[${j}];\n        v[${j}] = v[m];\n        v[m] = swpv;\n    `;\n\n    // shader\n    const source = `\n    uniform sampler2D image;\n\n    void main()\n    {\n        float v[${n}], swpv;\n        int m;\n\n        // read pixels\n        ${foreachWindowElement(readPixel)}\n\n        // sort v[0..med]\n        ${foreachVectorElement(selectMinimum)}\n\n        // return the median\n        color = vec4(v[${med}], v[${med}], v[${med}], 1.0f);\n    }\n    `;\n\n    // done!\n    return createShader(source).withArguments('image');\n}","module.exports = \"@include \\\"sobel.glsl\\\"\\n@include \\\"pyramids.glsl\\\"\\nuniform sampler2D pyramid;\\nuniform float lod;\\nconst mat3 horizontalKernel = mat3(\\n-1.0f, 0.0f, 1.0f,\\n-2.0f, 0.0f, 2.0f,\\n-1.0f, 0.0f, 1.0f\\n);\\nconst mat3 verticalKernel = mat3(\\n1.0f, 2.0f, 1.0f,\\n0.0f, 0.0f, 0.0f,\\n-1.0f,-2.0f,-1.0f\\n);\\nconst vec3 ones = vec3(1.0f, 1.0f, 1.0f);\\nvoid main()\\n{\\nfloat pot = exp2(lod);\\nmat3 neighbors = mat3(\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-1, -1)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(0, -1)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(1, -1)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-1, 0)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(0, 0)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(1, 0)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-1, 1)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(0, 1)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(1, 1)).g\\n);\\nmat3 sobelX = matrixCompMult(horizontalKernel, neighbors);\\nmat3 sobelY = matrixCompMult(verticalKernel, neighbors);\\nvec2 df = vec2(\\ndot(sobelX[0] + sobelX[1] + sobelX[2], ones),\\ndot(sobelY[0] + sobelY[1] + sobelY[2], ones)\\n);\\ncolor = encodeSobel(df);\\n}\"","var map = {\n\t\"./colors.glsl\": \"./src/gpu/shaders/include/colors.glsl\",\n\t\"./fixed-point.glsl\": \"./src/gpu/shaders/include/fixed-point.glsl\",\n\t\"./global.glsl\": \"./src/gpu/shaders/include/global.glsl\",\n\t\"./keypoints.glsl\": \"./src/gpu/shaders/include/keypoints.glsl\",\n\t\"./math.glsl\": \"./src/gpu/shaders/include/math.glsl\",\n\t\"./orientation.glsl\": \"./src/gpu/shaders/include/orientation.glsl\",\n\t\"./pyramids.glsl\": \"./src/gpu/shaders/include/pyramids.glsl\",\n\t\"./quickselect.glsl\": \"./src/gpu/shaders/include/quickselect.glsl\",\n\t\"./sobel.glsl\": \"./src/gpu/shaders/include/sobel.glsl\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./src/gpu/shaders/include sync recursive ^\\\\.\\\\/.*$\";","module.exports = \"#ifndef _COLORS_GLSL\\n#define _COLORS_GLSL\\n#define PIXELCOMPONENT_RED   @PIXELCOMPONENT_RED@\\n#define PIXELCOMPONENT_GREEN @PIXELCOMPONENT_GREEN@\\n#define PIXELCOMPONENT_BLUE  @PIXELCOMPONENT_BLUE@\\n#define PIXELCOMPONENT_ALPHA @PIXELCOMPONENT_ALPHA@\\n#endif\"","module.exports = \"#ifndef _FIXEDPOINT_GLSL\\n#define _FIXEDPOINT_GLSL\\n#define fixed_t int\\n#define fixed2_t ivec2\\nconst int FIX_BITS = int(@FIX_BITS@);\\nconst float FIX_RESOLUTION = float(@FIX_RESOLUTION@);\\n#define itofix(x) fixed_t((x) << FIX_BITS)\\n#define fixtoi(f) int((x) >> FIX_BITS)\\n#define ftofix(x) fixed_t((x) * FIX_RESOLUTION + 0.5f)\\n#define fixtof(f) (float(f) / FIX_RESOLUTION)\\n#define ivec2tofix(x) fixed2_t((x) << FIX_BITS)\\n#define fixtoivec2(f) ivec2((f) >> FIX_BITS)\\n#define vec2tofix(v) fixed2_t((v) * FIX_RESOLUTION + vec2(0.5f))\\n#define fixtovec2(f) (vec2(f) / FIX_RESOLUTION)\\n#endif\"","module.exports = \"#ifndef _GLOBAL_GLSL\\n#define _GLOBAL_GLSL\\n#define threadLocation() ivec2(texCoord * texSize)\\n#define outputSize() ivec2(texSize)\\n#define DEBUG(scalar) do { color = vec4(float(scalar), 0.0f, 0.0f, 1.0f); return; } while(false)\\n#define threadPixel(img) textureLod((img), texCoord, 0.0f)\\n#define pixelAt(img, pos) texelFetch((img), (pos), 0)\\n#define pixelAtShortOffset(img, offset) textureLodOffset((img), texCoord, 0.0f, (offset))\\n#define pixelAtLongOffset(img, offset) textureLod((img), texCoord + vec2(offset) / texSize, 0.0f)\\n#define subpixelAt(img, pos) textureLod((img), ((pos) + vec2(0.5f)) / texSize, 0.0f)\\n#endif\"","module.exports = \"#ifndef _KEYPOINTS_GLSL\\n#define _KEYPOINTS_GLSL\\n@include \\\"pyramids.glsl\\\"\\n@include \\\"orientation.glsl\\\"\\n@include \\\"fixed-point.glsl\\\"\\nstruct Keypoint\\n{\\nvec2 position;\\nfloat orientation;\\nfloat lod;\\nfloat score;\\nint flags;\\n};\\nstruct KeypointAddress\\n{\\nint base;\\nint offset;\\n};\\nconst int MAX_DESCRIPTOR_SIZE = int(@MAX_DESCRIPTOR_SIZE@);\\nconst int MIN_KEYPOINT_SIZE = int(@MIN_KEYPOINT_SIZE@);\\nconst int KPF_NONE = int(@KPF_NONE@);\\nconst int KPF_ORIENTED = int(@KPF_ORIENTED@);\\nconst int KPF_DISCARD = int(@KPF_DISCARD@);\\n#define readKeypointData(encodedKeypoints, encoderLength, rasterIndex) texelFetch((encodedKeypoints), ivec2((rasterIndex) % (encoderLength), (rasterIndex) / (encoderLength)), 0)\\n#define sizeofEncodedKeypoint(descriptorSize, extraSize) (MIN_KEYPOINT_SIZE + (descriptorSize) + (extraSize))\\n#define findKeypointIndex(address, descriptorSize, extraSize) ((address).base / ((sizeofEncodedKeypoint((descriptorSize), (extraSize))) / 4))\\nKeypointAddress findKeypointAddress(ivec2 thread, int encoderLength, int descriptorSize, int extraSize)\\n{\\nint threadRaster = thread.y * encoderLength + thread.x;\\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\\nint keypointIndex = int(threadRaster / pixelsPerKeypoint);\\nKeypointAddress address = KeypointAddress(\\nkeypointIndex * pixelsPerKeypoint,\\nthreadRaster % pixelsPerKeypoint\\n);\\nreturn address;\\n}\\nKeypoint decodeKeypoint(sampler2D encodedKeypoints, int encoderLength, KeypointAddress address)\\n{\\nconst vec4 ones = vec4(1.0f);\\nKeypoint keypoint;\\nint positionAddress = address.base;\\nint propertiesAddress = address.base + 1;\\nvec4 rawEncodedPosition = readKeypointData(encodedKeypoints, encoderLength, positionAddress);\\nivec4 encodedPosition = ivec4(rawEncodedPosition * 255.0f);\\nkeypoint.position = fixtovec2(fixed2_t(\\nencodedPosition.r | (encodedPosition.g << 8),\\nencodedPosition.b | (encodedPosition.a << 8)\\n));\\nvec4 encodedProperties = readKeypointData(encodedKeypoints, encoderLength, propertiesAddress);\\nkeypoint.orientation = decodeOrientation(encodedProperties.g);\\nkeypoint.lod = decodeLod(encodedProperties.r);\\nkeypoint.score = encodedProperties.b;\\nkeypoint.flags = int(encodedProperties.a * 255.0f);\\nbool isNull = all(greaterThanEqual(rawEncodedPosition, ones));\\nkeypoint.score = keypoint.score * float(!isNull) - float(isNull);\\nkeypoint.score -= float(keypoint.score == 0.0f) * float(all(equal(keypoint.position, vec2(0.0f))));\\nreturn keypoint;\\n}\\nvec4 encodeKeypointPosition(vec2 position)\\n{\\nconst vec2 zeros = vec2(0.0f);\\nfixed2_t pos = vec2tofix(max(position, zeros));\\nfixed2_t lo = pos & 255;\\nfixed2_t hi = pos >> 8;\\nreturn vec4(float(lo.x), float(hi.x), float(lo.y), float(hi.y)) / 255.0f;\\n}\\n#define encodeNullKeypoint() (vec4(1.0f))\\n#define isBadKeypoint(keypoint) ((keypoint).score < 0.0f)\\n#define encodeKeypointPositionAtInfinity() (vec4(254.0f / 255.0f, vec3(1.0f)))\\nbool isKeypointAtInfinity(Keypoint keypoint)\\n{\\nconst vec2 V2_MAX_TEXTURE_LENGTH = vec2(float(@MAX_TEXTURE_LENGTH@));\\nreturn any(greaterThan(keypoint.position, V2_MAX_TEXTURE_LENGTH));\\n}\\n#define encodeKeypointFlags(flags) (float(flags) / 255.0f)\\n#endif\"","module.exports = \"#ifndef _MATH_GLSL\\n#define _MATH_GLSL\\n#define TWO_PI          6.28318530718f\\n#define PI              3.14159265359f\\n#define PI_OVER_2       1.57079632679f\\n#define PI_OVER_4       0.78539816339f\\n#define INV_PI          0.3183098861837907f\\n#define USE_FAST_ATAN\\n#ifdef USE_FAST_ATAN\\nfloat fastAtan(float x)\\n{\\nfloat w = 1.0f - abs(x);\\nreturn (w >= 0.0f) ? ((PI_OVER_4 + 0.273 * w) * x) :\\n(sign(x) * PI_OVER_2 - (PI_OVER_4 + 0.273 * (1.0f - abs(1.0f / x))) / x);\\n}\\n#else\\n#define fastAtan(x) atan(x)\\n#endif\\n#ifdef USE_FAST_ATAN\\nfloat fastAtan2(float y, float x)\\n{\\nreturn (x == 0.0f) ? PI_OVER_2 * sign(y) : fastAtan(y / x) + float(x < 0.0f) * PI * sign(y);\\n}\\n#else\\n#define fastAtan2(y, x) atan((y), (x))\\n#endif\\n#endif\"","module.exports = \"#ifndef _ORIENTATION_GLSL\\n#define _ORIENTATION_GLSL\\n@include \\\"math.glsl\\\"\\n#define encodeOrientation(angle) ((angle) * INV_PI + 1.0f) * 0.5f\\n#define decodeOrientation(value) ((value) * 2.0f - 1.0f) * PI\\n#endif\"","module.exports = \"#ifndef _PYRAMIDS_GLSL\\n#define _PYRAMIDS_GLSL\\n#define pyrPixel(pyr, lod) textureLod((pyr), texCoord, (lod))\\n#define pyrPixelAtOffset(pyr, lod, pot, offset) textureLod((pyr), texCoord + ((pot) * vec2(offset)) / texSize, (lod))\\n#define pyrPixelAt(pyr, pos, lod) textureLod((pyr), (vec2(pos) + vec2(0.5f)) / texSize, (lod))\\n#define pyrPixelAtEx(pyr, pos, lod, pyrBaseSize) textureLod((pyr), (vec2(pos) + vec2(0.5f)) / vec2(pyrBaseSize), (lod))\\n#define pyrSubpixelAtEx(pyr, pos, lod, pyrBaseSize) textureLod((pyr), ((pos) + vec2(0.5f)) / vec2(pyrBaseSize), (lod))\\n#define pyrSubpixelAtExOffset(pyr, pos, lod, pot, offset, pyrBaseSize) textureLod((pyr), (((pos) + vec2(0.5f)) + ((pot) * vec2(offset))) / vec2(pyrBaseSize), (lod))\\nconst int PYRAMID_MAX_OCTAVES = int(@PYRAMID_MAX_OCTAVES@);\\nconst int PYRAMID_MAX_LEVELS = int(@PYRAMID_MAX_LEVELS@);\\nconst float F_PYRAMID_MAX_LEVELS = float(@PYRAMID_MAX_LEVELS@);\\nconst float LOG2_PYRAMID_MAX_SCALE = float(@LOG2_PYRAMID_MAX_SCALE@);\\nfloat encodeLod(float lod)\\n{\\nreturn (LOG2_PYRAMID_MAX_SCALE + lod) / (LOG2_PYRAMID_MAX_SCALE + F_PYRAMID_MAX_LEVELS);\\n}\\nfloat decodeLod(float encodedLod)\\n{\\nfloat lod = encodedLod * (LOG2_PYRAMID_MAX_SCALE + F_PYRAMID_MAX_LEVELS) - LOG2_PYRAMID_MAX_SCALE;\\nreturn lod * float(encodedLod < 1.0f);\\n}\\n#define isSameEncodedLod(alpha1, alpha2) (abs((alpha1) - (alpha2)) < encodedLodEps)\\nconst float encodedLodEps = 0.2f / (LOG2_PYRAMID_MAX_SCALE + F_PYRAMID_MAX_LEVELS);\\n#endif\"","module.exports = \"#ifndef _QUICKSELECT_GLSL\\n#define _QUICKSELECT_GLSL\\n#if defined(QUICKSELECT_UNSIGNED) && !defined(QUICKSELECT_SIGNED)\\n#define QS_TYPE uint\\n#define QS_TYPE4 uvec4\\n#elif !defined(QUICKSELECT_UNSIGNED) && defined(QUICKSELECT_SIGNED)\\n#define QS_TYPE int\\n#define QS_TYPE4 ivec4\\n#else\\n#error Must define either QUICKSELECT_SIGNED or QUICKSELECT_UNSIGNED before including quickselect\\n#endif\\n#if defined(QUICKSELECT_ASCENDING) && !defined(QUICKSELECT_DESCENDING)\\n#define QS_ORD(element,pivot) ((element) < (pivot))\\n#elif defined(QUICKSELECT_DESCENDING) && !defined(QUICKSELECT_ASCENDING)\\n#define QS_ORD(element,pivot) ((element) > (pivot))\\n#else\\n#error Must define either QUICKSELECT_ASCENDING or QUICKSELECT_DESCENDING before including quickselect\\n#endif\\n#ifdef QUICKSELECT_ARRAY\\n#define QS_ARRAY QUICKSELECT_ARRAY\\n#else\\n#error Must define QUICKSELECT_ARRAY before including quickselect\\n#endif\\nint qspart(int l, int r, int p)\\n{\\n#define QS_SWAP(a,b) t = QS_ARRAY[(a)]; QS_ARRAY[(a)] = QS_ARRAY[(b)]; QS_ARRAY[(b)] = t\\nhighp QS_TYPE e, t, mask, pivot = QS_ARRAY[p];\\nhighp QS_TYPE4 tmp;\\nint q, cond;\\nQS_SWAP(p, r);\\nq = l;\\nfor(int i = l; i < r; i++) {\\ne = QS_ARRAY[i];\\nt = QS_ARRAY[q];\\ncond = int(QS_ORD(e, pivot));\\nmask = QS_TYPE(-cond);\\ntmp = QS_TYPE4(mask & t, (~mask) & e, mask & e, (~mask) & t);\\nQS_ARRAY[i] = tmp.x | tmp.y;\\nQS_ARRAY[q] = tmp.z | tmp.w;\\nq += cond;\\n}\\nQS_SWAP(q, r);\\nreturn q;\\n}\\nhighp QS_TYPE quickselect(int l, int r, int k)\\n{\\nint p = -1337;\\nivec2 idx = ivec2(l, r);\\nwhile(idx.s < idx.t && p != k) {\\np = qspart(idx.s, idx.t, (idx.s + idx.t) / 2);\\nidx = int(k < p) * ivec2(idx.s, p-1) + int(k >= p) * ivec2(p+1, idx.t);\\n}\\nreturn (p == k) ? QS_ARRAY[k] : QS_ARRAY[idx.s];\\n}\\n#endif\"","module.exports = \"#ifndef _SOBEL_GLSL\\n#define _SOBEL_GLSL\\nvec4 encodeSobel(vec2 df)\\n{\\n#ifdef SOBEL_USE_LOG\\nconst vec2 zero = vec2(0.0f);\\nvec2 dmax = -max(df, zero);\\nvec2 dmin = min(df, zero);\\nreturn exp2(vec4(dmax, dmin));\\n#else\\nuint data = packHalf2x16(df);\\nuvec4 bytes = uvec4(data, data >> 8, data >> 16, data >> 24) & 255u;\\nreturn vec4(bytes) / 255.0f;\\n#endif\\n}\\nvec2 decodeSobel(vec4 encodedSobel)\\n{\\n#ifdef SOBEL_USE_LOG\\nvec4 lg = log2(encodedSobel);\\nreturn vec2(lg.b - lg.r, lg.a - lg.g);\\n#else\\nuvec4 bytes = uvec4(encodedSobel * 255.0f);\\nuint data = bytes.r | (bytes.g << 8) | (bytes.b << 16) | (bytes.a << 24);\\nreturn unpackHalf2x16(data);\\n#endif\\n}\\n#endif\"","module.exports = \"uniform sampler2D image, layerA, layerB;\\nuniform float scaleA, scaleB, lgM, h;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nfloat score = pixel.r;\\nivec2 zero = ivec2(0, 0);\\nivec2 sizeA = textureSize(layerA, 0);\\nivec2 sizeB = textureSize(layerB, 0);\\nvec2 mid = (texCoord * texSize) + vec2(0.5f, 0.5f);\\nivec2 pa = clamp(ivec2(ceil(mid * scaleA - 1.0f)), zero, sizeA - 2);\\nivec2 pb = clamp(ivec2(ceil(mid * scaleB - 1.0f)), zero, sizeB - 2);\\nvec4 a00 = pixelAt(layerA, pa);\\nvec4 a10 = pixelAt(layerA, pa + ivec2(1, 0));\\nvec4 a01 = pixelAt(layerA, pa + ivec2(0, 1));\\nvec4 a11 = pixelAt(layerA, pa + ivec2(1, 1));\\nvec4 b00 = pixelAt(layerB, pb);\\nvec4 b10 = pixelAt(layerB, pb + ivec2(1, 0));\\nvec4 b01 = pixelAt(layerB, pb + ivec2(0, 1));\\nvec4 b11 = pixelAt(layerB, pb + ivec2(1, 1));\\nfloat maxScore = max(\\nmax(max(a00.r, a10.r), max(a01.r, a11.r)),\\nmax(max(b00.r, b10.r), max(b01.r, b11.r))\\n);\\ncolor = vec4(0.0f, pixel.gba);\\nif(score < maxScore || score == 0.0f)\\nreturn;\\nvec2 ea = fract(mid * scaleA);\\nvec2 eb = fract(mid * scaleB);\\nfloat isa = a00.b * (1.0f - ea.x) * (1.0f - ea.y) +\\na10.b * ea.x * (1.0f - ea.y) +\\na01.b * (1.0f - ea.x) * ea.y +\\na11.b * ea.x * ea.y;\\nfloat isb = b00.b * (1.0f - eb.x) * (1.0f - eb.y) +\\nb10.b * eb.x * (1.0f - eb.y) +\\nb01.b * (1.0f - eb.x) * eb.y +\\nb11.b * eb.x * eb.y;\\ncolor = (isa > score && isa > isb) ? vec4(isa, pixel.gb, a00.a) : pixel;\\ncolor = (isb > score && isb > isa) ? vec4(isb, pixel.gb, b00.a) : pixel;\\nfloat y1 = isa, y2 = isb, y3 = score;\\nfloat x1 = lgM - (lgM + h) * a00.a;\\nfloat x2 = lgM - (lgM + h) * b00.a;\\nfloat x3 = lgM - (lgM + h) * pixel.a;\\nfloat dn = (x1 - x2) * (x1 - x3) * (x2 - x3);\\nif(abs(dn) < 0.00001f)\\nreturn;\\nfloat a = (x3 * (y2 - y1) + x2 * (y1 - y3) + x1 * (y3 - y2)) / dn;\\nif(a >= 0.0f)\\nreturn;\\nfloat b = (x3 * x3 * (y1 - y2) + x2 * x2 * (y3 - y1) + x1 * x1 * (y2 - y3)) / dn;\\nfloat c = (x2 * x3 * (x2 - x3) * y1 + x3 * x1 * (x3 - x1) * y2 + x1 * x2 * (x1 - x2) * y3) / dn;\\nfloat xv = -b / (2.0f * a);\\nfloat yv = c - (b * b) / (4.0f * a);\\nif(xv < min(x1, min(x2, x3)) || xv > max(x1, max(x2, x3)))\\nreturn;\\nfloat interpolatedScale = (lgM - xv) / (lgM + h);\\nfloat interpolatedScore = clamp(yv, 0.0f, 1.0f);\\ncolor = vec4(interpolatedScore, pixel.gb, interpolatedScale);\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform float threshold;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nfloat t = clamp(threshold, 0.0f, 1.0f);\\nfloat ct = pixel.g + t, c_t = pixel.g - t;\\nfloat p0 = pixelAtShortOffset(image, ivec2(0, 2)).g;\\nfloat p1 = pixelAtShortOffset(image, ivec2(1, 2)).g;\\nfloat p2 = pixelAtShortOffset(image, ivec2(2, 1)).g;\\nfloat p3 = pixelAtShortOffset(image, ivec2(2, 0)).g;\\nfloat p4 = pixelAtShortOffset(image, ivec2(2, -1)).g;\\nfloat p5 = pixelAtShortOffset(image, ivec2(1, -2)).g;\\nfloat p6 = pixelAtShortOffset(image, ivec2(0, -2)).g;\\nfloat p7 = pixelAtShortOffset(image, ivec2(-1, -2)).g;\\nfloat p8 = pixelAtShortOffset(image, ivec2(-2, -1)).g;\\nfloat p9 = pixelAtShortOffset(image, ivec2(-2, 0)).g;\\nfloat p10 = pixelAtShortOffset(image, ivec2(-2, 1)).g;\\nfloat p11 = pixelAtShortOffset(image, ivec2(-1, 2)).g;\\nvec2 scores = vec2(0.0f, 0.0f);\\nscores += vec2(max(c_t - p0, 0.0f), max(p0 - ct, 0.0f));\\nscores += vec2(max(c_t - p1, 0.0f), max(p1 - ct, 0.0f));\\nscores += vec2(max(c_t - p2, 0.0f), max(p2 - ct, 0.0f));\\nscores += vec2(max(c_t - p3, 0.0f), max(p3 - ct, 0.0f));\\nscores += vec2(max(c_t - p4, 0.0f), max(p4 - ct, 0.0f));\\nscores += vec2(max(c_t - p5, 0.0f), max(p5 - ct, 0.0f));\\nscores += vec2(max(c_t - p6, 0.0f), max(p6 - ct, 0.0f));\\nscores += vec2(max(c_t - p7, 0.0f), max(p7 - ct, 0.0f));\\nscores += vec2(max(c_t - p8, 0.0f), max(p8 - ct, 0.0f));\\nscores += vec2(max(c_t - p9, 0.0f), max(p9 - ct, 0.0f));\\nscores += vec2(max(c_t - p10, 0.0f), max(p10 - ct, 0.0f));\\nscores += vec2(max(c_t - p11, 0.0f), max(p11 - ct, 0.0f));\\nfloat score = max(scores.x, scores.y) / 12.0f;\\ncolor = vec4(score * step(1.0f, pixel.r), pixel.g, score, pixel.a);\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform float threshold;\\nconst vec4 zeroes = vec4(0.0f, 0.0f, 0.0f, 0.0f);\\nconst vec4 ones = vec4(1.0f, 1.0f, 1.0f, 1.0f);\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nfloat t = clamp(threshold, 0.0f, 1.0f);\\nfloat ct = pixel.g + t, c_t = pixel.g - t;\\nmat4 mp = mat4(\\npixelAtShortOffset(image, ivec2(0, 3)).g,\\npixelAtShortOffset(image, ivec2(1, 3)).g,\\npixelAtShortOffset(image, ivec2(2, 2)).g,\\npixelAtShortOffset(image, ivec2(3, 1)).g,\\npixelAtShortOffset(image, ivec2(3, 0)).g,\\npixelAtShortOffset(image, ivec2(3, -1)).g,\\npixelAtShortOffset(image, ivec2(2, -2)).g,\\npixelAtShortOffset(image, ivec2(1, -3)).g,\\npixelAtShortOffset(image, ivec2(0, -3)).g,\\npixelAtShortOffset(image, ivec2(-1, -3)).g,\\npixelAtShortOffset(image, ivec2(-2, -2)).g,\\npixelAtShortOffset(image, ivec2(-3, -1)).g,\\npixelAtShortOffset(image, ivec2(-3, 0)).g,\\npixelAtShortOffset(image, ivec2(-3, 1)).g,\\npixelAtShortOffset(image, ivec2(-2, 2)).g,\\npixelAtShortOffset(image, ivec2(-1, 3)).g\\n);\\nmat4 mct = mp - mat4(\\nct, ct, ct, ct,\\nct, ct, ct, ct,\\nct, ct, ct, ct,\\nct, ct, ct, ct\\n), mc_t = mat4(\\nc_t, c_t, c_t, c_t,\\nc_t, c_t, c_t, c_t,\\nc_t, c_t, c_t, c_t,\\nc_t, c_t, c_t, c_t\\n) - mp;\\nvec4 bs = max(mc_t[0], zeroes), ds = max(mct[0], zeroes);\\nbs += max(mc_t[1], zeroes); ds += max(mct[1], zeroes);\\nbs += max(mc_t[2], zeroes); ds += max(mct[2], zeroes);\\nbs += max(mc_t[3], zeroes); ds += max(mct[3], zeroes);\\nfloat score = max(dot(bs, ones), dot(ds, ones)) / 16.0f;\\ncolor = vec4(score * step(1.0f, pixel.r), pixel.g, score, pixel.a);\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform float threshold;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nfloat t = clamp(threshold, 0.0f, 1.0f);\\nfloat ct = pixel.g + t, c_t = pixel.g - t;\\nfloat p0 = pixelAtShortOffset(image, ivec2(0, 1)).g;\\nfloat p1 = pixelAtShortOffset(image, ivec2(1, 1)).g;\\nfloat p2 = pixelAtShortOffset(image, ivec2(1, 0)).g;\\nfloat p3 = pixelAtShortOffset(image, ivec2(1, -1)).g;\\nfloat p4 = pixelAtShortOffset(image, ivec2(0, -1)).g;\\nfloat p5 = pixelAtShortOffset(image, ivec2(-1, -1)).g;\\nfloat p6 = pixelAtShortOffset(image, ivec2(-1, 0)).g;\\nfloat p7 = pixelAtShortOffset(image, ivec2(-1, 1)).g;\\nvec2 scores = vec2(0.0f, 0.0f);\\nscores += vec2(max(c_t - p0, 0.0f), max(p0 - ct, 0.0f));\\nscores += vec2(max(c_t - p1, 0.0f), max(p1 - ct, 0.0f));\\nscores += vec2(max(c_t - p2, 0.0f), max(p2 - ct, 0.0f));\\nscores += vec2(max(c_t - p3, 0.0f), max(p3 - ct, 0.0f));\\nscores += vec2(max(c_t - p4, 0.0f), max(p4 - ct, 0.0f));\\nscores += vec2(max(c_t - p5, 0.0f), max(p5 - ct, 0.0f));\\nscores += vec2(max(c_t - p6, 0.0f), max(p6 - ct, 0.0f));\\nscores += vec2(max(c_t - p7, 0.0f), max(p7 - ct, 0.0f));\\nfloat score = max(scores.x, scores.y) / 8.0f;\\ncolor = vec4(score * step(1.0f, pixel.r), pixel.g, score, pixel.a);\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform float threshold;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nivec2 size = outputSize();\\nvec4 pixel = threadPixel(image);\\ncolor = vec4(0.0f, pixel.gba);\\nif(\\nthread.x >= 3 && thread.x < size.x - 3 &&\\nthread.y >= 3 && thread.y < size.y - 3\\n) {\\nfloat t = clamp(threshold, 0.0f, 1.0f);\\nfloat c = pixel.g;\\nfloat ct = c + t, c_t = c - t;\\nfloat p0 = pixelAtShortOffset(image, ivec2(0, 1)).g;\\nfloat p1 = pixelAtShortOffset(image, ivec2(1, 1)).g;\\nfloat p2 = pixelAtShortOffset(image, ivec2(1, 0)).g;\\nfloat p3 = pixelAtShortOffset(image, ivec2(1, -1)).g;\\nfloat p4 = pixelAtShortOffset(image, ivec2(0, -1)).g;\\nfloat p5 = pixelAtShortOffset(image, ivec2(-1, -1)).g;\\nfloat p6 = pixelAtShortOffset(image, ivec2(-1, 0)).g;\\nfloat p7 = pixelAtShortOffset(image, ivec2(-1, 1)).g;\\nbool possibleCorner =\\n((c_t > p1 || c_t > p5) && (c_t > p3 || c_t > p7)) ||\\n((ct < p1  || ct < p5)  && (ct < p3  || ct < p7))  ;\\nif(possibleCorner) {\\nint bright = 0, dark = 0, bc = 0, dc = 0;\\nif(c_t > p0) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p0) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p1) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p1) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p2) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p2) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p3) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p3) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p4) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p4) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p5) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p5) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p6) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p6) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p7) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p7) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(bright < 5 && dark < 5) {\\nif(bc > 0 && bc < 5) do {\\nif(c_t > p0)           bc += 1; else break;\\nif(c_t > p1 && bc < 5) bc += 1; else break;\\nif(c_t > p2 && bc < 5) bc += 1; else break;\\nif(c_t > p3 && bc < 5) bc += 1; else break;\\n} while(false);\\nif(dc > 0 && dc < 5) do {\\nif(ct < p0)           dc += 1; else break;\\nif(ct < p1 && dc < 5) dc += 1; else break;\\nif(ct < p2 && dc < 5) dc += 1; else break;\\nif(ct < p3 && dc < 5) dc += 1; else break;\\n} while(false);\\nif(bc >= 5 || dc >= 5)\\ncolor = vec4(1.0f, pixel.gba);\\n}\\nelse {\\ncolor = vec4(1.0f, pixel.gba);\\n}\\n}\\n}\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform float threshold;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nivec2 size = outputSize();\\nvec4 pixel = threadPixel(image);\\ncolor = vec4(0.0f, pixel.gba);\\nif(\\nthread.x >= 3 && thread.x < size.x - 3 &&\\nthread.y >= 3 && thread.y < size.y - 3\\n) {\\nfloat t = clamp(threshold, 0.0f, 1.0f);\\nfloat c = pixel.g;\\nfloat ct = c + t, c_t = c - t;\\nfloat p0 = pixelAtShortOffset(image, ivec2(0, 2)).g;\\nfloat p1 = pixelAtShortOffset(image, ivec2(1, 2)).g;\\nfloat p2 = pixelAtShortOffset(image, ivec2(2, 1)).g;\\nfloat p3 = pixelAtShortOffset(image, ivec2(2, 0)).g;\\nfloat p4 = pixelAtShortOffset(image, ivec2(2, -1)).g;\\nfloat p5 = pixelAtShortOffset(image, ivec2(1, -2)).g;\\nfloat p6 = pixelAtShortOffset(image, ivec2(0, -2)).g;\\nfloat p7 = pixelAtShortOffset(image, ivec2(-1, -2)).g;\\nfloat p8 = pixelAtShortOffset(image, ivec2(-2, -1)).g;\\nfloat p9 = pixelAtShortOffset(image, ivec2(-2, 0)).g;\\nfloat p10 = pixelAtShortOffset(image, ivec2(-2, 1)).g;\\nfloat p11 = pixelAtShortOffset(image, ivec2(-1, 2)).g;\\nbool possibleCorner =\\n((c_t > p0 || c_t > p6) && (c_t > p3 || c_t > p9)) ||\\n((ct < p0  || ct < p6)  && (ct < p3  || ct < p9))  ;\\nif(possibleCorner) {\\nint bright = 0, dark = 0, bc = 0, dc = 0;\\nif(c_t > p0) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p0) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p1) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p1) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p2) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p2) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p3) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p3) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p4) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p4) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p5) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p5) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p6) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p6) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p7) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p7) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p8) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p8) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p9) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p9) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p10) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p10) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p11) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p11) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(bright < 7 && dark < 7) {\\nif(bc > 0 && bc < 7) do {\\nif(c_t > p0)           bc += 1; else break;\\nif(c_t > p1 && bc < 7) bc += 1; else break;\\nif(c_t > p2 && bc < 7) bc += 1; else break;\\nif(c_t > p3 && bc < 7) bc += 1; else break;\\nif(c_t > p4 && bc < 7) bc += 1; else break;\\nif(c_t > p5 && bc < 7) bc += 1; else break;\\n} while(false);\\nif(dc > 0 && dc < 7) do {\\nif(ct < p0)           dc += 1; else break;\\nif(ct < p1 && dc < 7) dc += 1; else break;\\nif(ct < p2 && dc < 7) dc += 1; else break;\\nif(ct < p3 && dc < 7) dc += 1; else break;\\nif(ct < p4 && dc < 7) dc += 1; else break;\\nif(ct < p5 && dc < 7) dc += 1; else break;\\n} while(false);\\nif(bc >= 7 || dc >= 7)\\ncolor = vec4(1.0f, pixel.gba);\\n}\\nelse {\\ncolor = vec4(1.0f, pixel.gba);\\n}\\n}\\n}\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform float threshold;\\nconst ivec4 margin = ivec4(3, 3, 4, 4);\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nivec2 thread = threadLocation();\\nivec2 size = outputSize();\\ncolor = vec4(0.0f, pixel.gba);\\nif(any(lessThan(ivec4(thread, size - thread), margin)))\\nreturn;\\nfloat t = clamp(threshold, 0.0f, 1.0f);\\nfloat ct = pixel.g + t, c_t = pixel.g - t;\\nfloat p0 = pixelAtShortOffset(image, ivec2(0, 3)).g;\\nfloat p4 = pixelAtShortOffset(image, ivec2(3, 0)).g;\\nfloat p8 = pixelAtShortOffset(image, ivec2(0, -3)).g;\\nfloat p12 = pixelAtShortOffset(image, ivec2(-3, 0)).g;\\nif(!(\\n((c_t > p0 || c_t > p8) && (c_t > p4 || c_t > p12)) ||\\n((ct < p0  || ct < p8)  && (ct < p4  || ct < p12))\\n))\\nreturn;\\nfloat p1 = pixelAtShortOffset(image, ivec2(1, 3)).g;\\nfloat p2 = pixelAtShortOffset(image, ivec2(2, 2)).g;\\nfloat p3 = pixelAtShortOffset(image, ivec2(3, 1)).g;\\nfloat p5 = pixelAtShortOffset(image, ivec2(3, -1)).g;\\nfloat p6 = pixelAtShortOffset(image, ivec2(2, -2)).g;\\nfloat p7 = pixelAtShortOffset(image, ivec2(1, -3)).g;\\nfloat p9 = pixelAtShortOffset(image, ivec2(-1, -3)).g;\\nfloat p10 = pixelAtShortOffset(image, ivec2(-2, -2)).g;\\nfloat p11 = pixelAtShortOffset(image, ivec2(-3, -1)).g;\\nfloat p13 = pixelAtShortOffset(image, ivec2(-3, 1)).g;\\nfloat p14 = pixelAtShortOffset(image, ivec2(-2, 2)).g;\\nfloat p15 = pixelAtShortOffset(image, ivec2(-1, 3)).g;\\nbool A=(p0>ct),B=(p1>ct),C=(p2>ct),D=(p3>ct),E=(p4>ct),F=(p5>ct),G=(p6>ct),H=(p7>ct),I=(p8>ct),J=(p9>ct),K=(p10>ct),L=(p11>ct),M=(p12>ct),N=(p13>ct),O=(p14>ct),P=(p15>ct),a=(p0<c_t),b=(p1<c_t),c=(p2<c_t),d=(p3<c_t),e=(p4<c_t),f=(p5<c_t),g=(p6<c_t),h=(p7<c_t),i=(p8<c_t),j=(p9<c_t),k=(p10<c_t),l=(p11<c_t),m=(p12<c_t),n=(p13<c_t),o=(p14<c_t),p=(p15<c_t);\\nbool isCorner=A&&(B&&(K&&L&&J&&(M&&N&&O&&P||G&&H&&I&&(M&&N&&O||F&&(M&&N||E&&(M||D))))||C&&(K&&L&&M&&(N&&O&&P||G&&H&&I&&J&&(N&&O||F&&(N||E)))||D&&(N&&(L&&M&&(K&&G&&H&&I&&J&&(O||F)||O&&P)||k&&l&&m&&e&&f&&g&&h&&i&&j)||E&&(O&&(M&&N&&(K&&L&&G&&H&&I&&J||P)||k&&l&&m&&n&&f&&g&&h&&i&&j)||F&&(P&&(N&&O||k&&l&&m&&n&&o&&g&&h&&i&&j)||G&&(O&&P||H&&(P||I)||k&&l&&m&&n&&o&&p&&h&&i&&j)||k&&l&&m&&n&&o&&h&&i&&j&&(p||g))||k&&l&&m&&n&&h&&i&&j&&(o&&(p||g)||f&&(o&&p||g)))||k&&l&&m&&h&&i&&j&&(n&&(o&&p||g&&(o||f))||e&&(n&&o&&p||g&&(n&&o||f))))||k&&l&&h&&i&&j&&(m&&(n&&o&&p||g&&(n&&o||f&&(n||e)))||d&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e)))))||k&&h&&i&&j&&(l&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d))))))||K&&I&&J&&(L&&M&&N&&O&&P||G&&H&&(L&&M&&N&&O||F&&(L&&M&&N||E&&(L&&M||D&&(L||C)))))||h&&i&&j&&(b&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c)))))||k&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c)))))))||B&&(H&&I&&J&&(K&&L&&M&&N&&O&&P&&a||G&&(K&&L&&M&&N&&O&&a||F&&(K&&L&&M&&N&&a||E&&(K&&L&&M&&a||D&&(K&&L&&a||C)))))||a&&k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||C&&(K&&H&&I&&J&&(L&&M&&N&&O&&P&&a&&b||G&&(L&&M&&N&&O&&a&&b||F&&(L&&M&&N&&a&&b||E&&(L&&M&&a&&b||D))))||a&&b&&k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d)))))||D&&(K&&L&&H&&I&&J&&(M&&N&&O&&P&&a&&b&&c||G&&(M&&N&&O&&a&&b&&c||F&&(M&&N&&a&&b&&c||E)))||a&&b&&k&&l&&m&&c&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e))))||E&&(K&&L&&M&&H&&I&&J&&(N&&O&&P&&a&&b&&c&&d||G&&(N&&O&&a&&b&&c&&d||F))||a&&b&&l&&m&&n&&c&&d&&(k&&g&&h&&i&&j&&(o||f)||o&&p))||F&&(K&&L&&M&&N&&H&&I&&J&&(O&&P&&a&&b&&c&&d&&e||G)||a&&b&&m&&n&&o&&c&&d&&e&&(k&&l&&g&&h&&i&&j||p))||G&&(K&&L&&M&&N&&O&&H&&I&&J||a&&b&&n&&o&&p&&c&&d&&e&&f)||H&&(K&&L&&M&&N&&O&&P&&I&&J||a&&b&&o&&p&&c&&d&&e&&f&&g)||a&&(b&&(k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(k&&l&&m&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e)))||d&&(l&&m&&n&&(k&&g&&h&&i&&j&&(o||f)||o&&p)||e&&(m&&n&&o&&(k&&l&&g&&h&&i&&j||p)||f&&(n&&o&&p||g&&(o&&p||h&&(p||i)))))))||k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||h&&i&&j&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c&&(b||k))))));\\ncolor = vec4(float(isCorner), pixel.gba);\\n}\"","module.exports = \"uniform sampler2D corners;\\nuniform sampler2D maxScore;\\nuniform float quality;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(corners);\\nfloat maxVal = threadPixel(maxScore).r;\\nfloat score = pixel.r;\\nfloat threshold = maxVal * clamp(quality, 0.0f, 1.0f);\\nscore *= step(threshold, score);\\ncolor = vec4(score, pixel.gba);\\n}\"","module.exports = \"@include \\\"pyramids.glsl\\\"\\nuniform sampler2D pyramid;\\nuniform float threshold;\\nuniform int numberOfOctaves;\\nuniform float lodStep;\\nconst ivec4 margin = ivec4(3, 3, 4, 4);\\nconst vec4 zeroes = vec4(0.0f, 0.0f, 0.0f, 0.0f);\\nconst vec4 ones = vec4(1.0f, 1.0f, 1.0f, 1.0f);\\nvoid main()\\n{\\nvec4 pixel = threadPixel(pyramid);\\nivec2 thread = threadLocation();\\nivec2 size = outputSize();\\nfloat t = clamp(threshold, 0.0f, 1.0f);\\nfloat ct = pixel.g + t, c_t = pixel.g - t;\\nvec2 best = vec2(0.0f, pixel.a);\\n#ifdef USE_HARRIS_SCORE\\nvec2 dfmm[PYRAMID_MAX_OCTAVES], dfm0[PYRAMID_MAX_OCTAVES], dfm1[PYRAMID_MAX_OCTAVES],\\ndf0m[PYRAMID_MAX_OCTAVES], df00[PYRAMID_MAX_OCTAVES], df01[PYRAMID_MAX_OCTAVES],\\ndf1m[PYRAMID_MAX_OCTAVES], df10[PYRAMID_MAX_OCTAVES], df11[PYRAMID_MAX_OCTAVES];\\nfloat pyrpix = 0.0f;\\nfor(int l = 0; l < numberOfOctaves; l++) {\\nfloat lod = float(l) * lodStep;\\nfloat pot = exp2(lod);\\npyrpix = pyrPixelAtOffset(pyramid, lod, pot, ivec2(-1,-1)).g;\\ndfmm[l] = vec2(dFdx(pyrpix), dFdy(pyrpix));\\npyrpix = pyrPixelAtOffset(pyramid, lod, pot, ivec2(-1,0)).g;\\ndfm0[l] = vec2(dFdx(pyrpix), dFdy(pyrpix));\\npyrpix = pyrPixelAtOffset(pyramid, lod, pot, ivec2(-1,1)).g;\\ndfm1[l] = vec2(dFdx(pyrpix), dFdy(pyrpix));\\npyrpix = pyrPixelAtOffset(pyramid, lod, pot, ivec2(0,-1)).g;\\ndf0m[l] = vec2(dFdx(pyrpix), dFdy(pyrpix));\\npyrpix = pyrPixelAtOffset(pyramid, lod, pot, ivec2(0,0)).g;\\ndf00[l] = vec2(dFdx(pyrpix), dFdy(pyrpix));\\npyrpix = pyrPixelAtOffset(pyramid, lod, pot, ivec2(0,1)).g;\\ndf01[l] = vec2(dFdx(pyrpix), dFdy(pyrpix));\\npyrpix = pyrPixelAtOffset(pyramid, lod, pot, ivec2(1,-1)).g;\\ndf1m[l] = vec2(dFdx(pyrpix), dFdy(pyrpix));\\npyrpix = pyrPixelAtOffset(pyramid, lod, pot, ivec2(1,0)).g;\\ndf10[l] = vec2(dFdx(pyrpix), dFdy(pyrpix));\\npyrpix = pyrPixelAtOffset(pyramid, lod, pot, ivec2(1,1)).g;\\ndf11[l] = vec2(dFdx(pyrpix), dFdy(pyrpix));\\n}\\n#endif\\ncolor = vec4(0.0f, pixel.g, 0.0f, pixel.a);\\nfloat lod = 0.0f, pot = 1.0f;\\nfor(int octave = 0; octave < numberOfOctaves; octave++) {\\npixel = pyrPixel(pyramid, lod);\\nct = pixel.g + t;\\nc_t = pixel.g - t;\\nvec4 p4k = vec4(\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(0, 3)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(3, 0)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(0, -3)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-3, 0)).g\\n);\\nmat4 mp = mat4(\\np4k.x,\\np4k.y,\\np4k.z,\\np4k.w,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(1, 3)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(3, -1)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-1, -3)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-3, 1)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(2, 2)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(2, -2)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-2, -2)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-2, 2)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(3, 1)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(1, -3)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-3, -1)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-1, 3)).g\\n);\\nbool A=(mp[0][0]>ct),B=(mp[1][0]>ct),C=(mp[2][0]>ct),D=(mp[3][0]>ct),E=(mp[0][1]>ct),F=(mp[1][1]>ct),G=(mp[2][1]>ct),H=(mp[3][1]>ct),I=(mp[0][2]>ct),J=(mp[1][2]>ct),K=(mp[2][2]>ct),L=(mp[3][2]>ct),M=(mp[0][3]>ct),N=(mp[1][3]>ct),O=(mp[2][3]>ct),P=(mp[3][3]>ct),a=(mp[0][0]<c_t),b=(mp[1][0]<c_t),c=(mp[2][0]<c_t),d=(mp[3][0]<c_t),e=(mp[0][1]<c_t),f=(mp[1][1]<c_t),g=(mp[2][1]<c_t),h=(mp[3][1]<c_t),i=(mp[0][2]<c_t),j=(mp[1][2]<c_t),k=(mp[2][2]<c_t),l=(mp[3][2]<c_t),m=(mp[0][3]<c_t),n=(mp[1][3]<c_t),o=(mp[2][3]<c_t),p=(mp[3][3]<c_t);\\nbool isCorner=A&&(B&&(K&&L&&J&&(M&&N&&O&&P||G&&H&&I&&(M&&N&&O||F&&(M&&N||E&&(M||D))))||C&&(K&&L&&M&&(N&&O&&P||G&&H&&I&&J&&(N&&O||F&&(N||E)))||D&&(N&&(L&&M&&(K&&G&&H&&I&&J&&(O||F)||O&&P)||k&&l&&m&&e&&f&&g&&h&&i&&j)||E&&(O&&(M&&N&&(K&&L&&G&&H&&I&&J||P)||k&&l&&m&&n&&f&&g&&h&&i&&j)||F&&(P&&(N&&O||k&&l&&m&&n&&o&&g&&h&&i&&j)||G&&(O&&P||H&&(P||I)||k&&l&&m&&n&&o&&p&&h&&i&&j)||k&&l&&m&&n&&o&&h&&i&&j&&(p||g))||k&&l&&m&&n&&h&&i&&j&&(o&&(p||g)||f&&(o&&p||g)))||k&&l&&m&&h&&i&&j&&(n&&(o&&p||g&&(o||f))||e&&(n&&o&&p||g&&(n&&o||f))))||k&&l&&h&&i&&j&&(m&&(n&&o&&p||g&&(n&&o||f&&(n||e)))||d&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e)))))||k&&h&&i&&j&&(l&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d))))))||K&&I&&J&&(L&&M&&N&&O&&P||G&&H&&(L&&M&&N&&O||F&&(L&&M&&N||E&&(L&&M||D&&(L||C)))))||h&&i&&j&&(b&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c)))))||k&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c)))))))||B&&(H&&I&&J&&(K&&L&&M&&N&&O&&P&&a||G&&(K&&L&&M&&N&&O&&a||F&&(K&&L&&M&&N&&a||E&&(K&&L&&M&&a||D&&(K&&L&&a||C)))))||a&&k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||C&&(K&&H&&I&&J&&(L&&M&&N&&O&&P&&a&&b||G&&(L&&M&&N&&O&&a&&b||F&&(L&&M&&N&&a&&b||E&&(L&&M&&a&&b||D))))||a&&b&&k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d)))))||D&&(K&&L&&H&&I&&J&&(M&&N&&O&&P&&a&&b&&c||G&&(M&&N&&O&&a&&b&&c||F&&(M&&N&&a&&b&&c||E)))||a&&b&&k&&l&&m&&c&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e))))||E&&(K&&L&&M&&H&&I&&J&&(N&&O&&P&&a&&b&&c&&d||G&&(N&&O&&a&&b&&c&&d||F))||a&&b&&l&&m&&n&&c&&d&&(k&&g&&h&&i&&j&&(o||f)||o&&p))||F&&(K&&L&&M&&N&&H&&I&&J&&(O&&P&&a&&b&&c&&d&&e||G)||a&&b&&m&&n&&o&&c&&d&&e&&(k&&l&&g&&h&&i&&j||p))||G&&(K&&L&&M&&N&&O&&H&&I&&J||a&&b&&n&&o&&p&&c&&d&&e&&f)||H&&(K&&L&&M&&N&&O&&P&&I&&J||a&&b&&o&&p&&c&&d&&e&&f&&g)||a&&(b&&(k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(k&&l&&m&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e)))||d&&(l&&m&&n&&(k&&g&&h&&i&&j&&(o||f)||o&&p)||e&&(m&&n&&o&&(k&&l&&g&&h&&i&&j||p)||f&&(n&&o&&p||g&&(o&&p||h&&(p||i)))))))||k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||h&&i&&j&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c&&(b||k))))));\\nfloat score = 0.0f;\\n#ifdef USE_HARRIS_SCORE\\nvec2 df0 = dfmm[octave], df1 = dfm0[octave], df2 = dfm1[octave],\\ndf3 = df0m[octave], df4 = df00[octave], df5 = df01[octave],\\ndf6 = df1m[octave], df7 = df10[octave], df8 = df11[octave];\\nvec3 hm = vec3(0.0f);\\nhm += vec3(df0.x * df0.x, df0.x * df0.y, df0.y * df0.y);\\nhm += vec3(df1.x * df1.x, df1.x * df1.y, df1.y * df1.y);\\nhm += vec3(df2.x * df2.x, df2.x * df2.y, df2.y * df2.y);\\nhm += vec3(df3.x * df3.x, df3.x * df3.y, df3.y * df3.y);\\nhm += vec3(df4.x * df4.x, df4.x * df4.y, df4.y * df4.y);\\nhm += vec3(df5.x * df5.x, df5.x * df5.y, df5.y * df5.y);\\nhm += vec3(df6.x * df6.x, df6.x * df6.y, df6.y * df6.y);\\nhm += vec3(df7.x * df7.x, df7.x * df7.y, df7.y * df7.y);\\nhm += vec3(df8.x * df8.x, df8.x * df8.y, df8.y * df8.y);\\nfloat response = 0.5f * (hm.x + hm.z - sqrt((hm.x - hm.z) * (hm.x - hm.z) + 4.0f * hm.y * hm.y));\\nconst float WINDOW_AREA = 9.0f;\\nconst float EIGENVALUE_NORMALIZER = 9.0f / WINDOW_AREA;\\nscore = response * EIGENVALUE_NORMALIZER;\\nscore = 1.0f - exp2(-score);\\n#else\\nmat4 mct = mp - mat4(\\nct, ct, ct, ct,\\nct, ct, ct, ct,\\nct, ct, ct, ct,\\nct, ct, ct, ct\\n), mc_t = mat4(\\nc_t, c_t, c_t, c_t,\\nc_t, c_t, c_t, c_t,\\nc_t, c_t, c_t, c_t,\\nc_t, c_t, c_t, c_t\\n) - mp;\\nvec4 bs = max(mc_t[0], zeroes), ds = max(mct[0], zeroes);\\nbs += max(mc_t[1], zeroes); ds += max(mct[1], zeroes);\\nbs += max(mc_t[2], zeroes); ds += max(mct[2], zeroes);\\nbs += max(mc_t[3], zeroes); ds += max(mct[3], zeroes);\\nscore = max(dot(bs, ones), dot(ds, ones)) / 16.0f;\\n#endif\\nscore *= float(isCorner);\\nivec2 remainder = thread % int(pot);\\nscore *= float(remainder.x + remainder.y == 0);\\nfloat scale = encodeLod(lod);\\nbest *= float(score <= best.x);\\nbest += float(score > best.x) * vec2(score, scale);\\nlod += lodStep;\\npot = exp2(lod);\\n}\\ncolor.rba = best.xxy;\\n}\"","module.exports = \"@include \\\"sobel.glsl\\\"\\n@include \\\"pyramids.glsl\\\"\\nuniform sampler2D pyramid;\\nuniform int windowSize;\\nuniform int numberOfOctaves;\\nuniform float lodStep;\\nuniform sampler2D sobelDerivatives[@PYRAMID_MAX_OCTAVES@];\\nvec4 pickSobelDerivatives(int index, ivec2 offset)\\n{\\n#define MAX_OCTAVES @PYRAMID_MAX_OCTAVES@\\n#if MAX_OCTAVES < 7 || MAX_OCTAVES > 16 || MAX_OCTAVES % 2 == 0\\n#error MAX_OCTAVES cannot be @PYRAMID_MAX_OCTAVES@\\n#endif\\nswitch(index) {\\ncase 0:  return textureLod(sobelDerivatives[0], texCoord + vec2(offset) / texSize, 0.0f);\\ncase 1:  return textureLod(sobelDerivatives[1], texCoord + vec2(offset) / texSize, 0.0f);\\ncase 2:  return textureLod(sobelDerivatives[2], texCoord + vec2(offset) / texSize, 0.0f);\\ncase 3:  return textureLod(sobelDerivatives[3], texCoord + vec2(offset) / texSize, 0.0f);\\ncase 4:  return textureLod(sobelDerivatives[4], texCoord + vec2(offset) / texSize, 0.0f);\\ncase 5:  return textureLod(sobelDerivatives[5], texCoord + vec2(offset) / texSize, 0.0f);\\ncase 6:  return textureLod(sobelDerivatives[6], texCoord + vec2(offset) / texSize, 0.0f);\\n#if MAX_OCTAVES > 15\\ncase 15: return textureLod(sobelDerivatives[15], texCoord + vec2(offset) / texSize, 0.0f);\\n#elif MAX_OCTAVES > 13\\ncase 14: return textureLod(sobelDerivatives[14], texCoord + vec2(offset) / texSize, 0.0f);\\ncase 13: return textureLod(sobelDerivatives[13], texCoord + vec2(offset) / texSize, 0.0f);\\n#elif MAX_OCTAVES > 11\\ncase 12: return textureLod(sobelDerivatives[12], texCoord + vec2(offset) / texSize, 0.0f);\\ncase 11: return textureLod(sobelDerivatives[11], texCoord + vec2(offset) / texSize, 0.0f);\\n#elif MAX_OCTAVES > 9\\ncase 10: return textureLod(sobelDerivatives[10], texCoord + vec2(offset) / texSize, 0.0f);\\ncase 9:  return textureLod(sobelDerivatives[9], texCoord + vec2(offset) / texSize, 0.0f);\\n#elif MAX_OCTAVES > 7\\ncase 8:  return textureLod(sobelDerivatives[8], texCoord + vec2(offset) / texSize, 0.0f);\\ncase 7:  return textureLod(sobelDerivatives[7], texCoord + vec2(offset) / texSize, 0.0f);\\n#endif\\ndefault: return vec4(0.0f);\\n}\\n}\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nvec4 pixel = threadPixel(pyramid);\\nvec2 best = vec2(0.0f, pixel.a);\\nint r = (windowSize - 1) / 2;\\nfloat windowArea = float(windowSize * windowSize);\\nfor(int octave = 0; octave < numberOfOctaves; octave++) {\\nvec3 m = vec3(0.0f);\\nfor(int j = 0; j < windowSize; j++) {\\nfor(int i = 0; i < windowSize; i++) {\\nvec2 df = decodeSobel(pickSobelDerivatives(octave, ivec2(i-r, j-r)));\\nm += vec3(df.x * df.x, df.x * df.y, df.y * df.y);\\n}\\n}\\nfloat response = 0.5f * (m.x + m.z - sqrt((m.x - m.z) * (m.x - m.z) + 4.0f * m.y * m.y));\\nfloat normalizer = 9.0f / windowArea;\\nfloat score = response * normalizer;\\nfloat lod = lodStep * float(octave);\\nfloat scale = encodeLod(lod);\\nbest *= float(score <= best.x);\\nbest += float(score > best.x) * vec2(score, scale);\\n}\\nfloat encodedScore = 1.0f - exp2(-best.x);\\ncolor = vec4(encodedScore, pixel.g, best.xy);\\n}\"","module.exports = \"@include \\\"pyramids.glsl\\\"\\nuniform sampler2D image;\\nuniform float lodStep;\\n#define ENABLE_INNER_RING\\n#define ENABLE_MIDDLE_RING\\n#define ENABLE_OUTER_RING\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nfloat lod = decodeLod(pixel.a);\\ncolor = pixel;\\nif(pixel.r == 0.0f)\\nreturn;\\n#ifdef ENABLE_INNER_RING\\nvec4 p0 = pixelAtShortOffset(image, ivec2(0, 1));\\nvec4 p1 = pixelAtShortOffset(image, ivec2(1, 1));\\nvec4 p2 = pixelAtShortOffset(image, ivec2(1, 0));\\nvec4 p3 = pixelAtShortOffset(image, ivec2(1, -1));\\nvec4 p4 = pixelAtShortOffset(image, ivec2(0, -1));\\nvec4 p5 = pixelAtShortOffset(image, ivec2(-1, -1));\\nvec4 p6 = pixelAtShortOffset(image, ivec2(-1, 0));\\nvec4 p7 = pixelAtShortOffset(image, ivec2(-1, 1));\\n#else\\nvec4 p0, p1, p2, p3, p4, p5, p6, p7;\\np0 = p1 = p2 = p3 = p4 = p5 = p6 = p7 = vec4(0.0f);\\n#endif\\n#ifdef ENABLE_MIDDLE_RING\\nvec4 q0 = pixelAtShortOffset(image, ivec2(0, 2));\\nvec4 q1 = pixelAtShortOffset(image, ivec2(1, 2));\\nvec4 q2 = pixelAtShortOffset(image, ivec2(2, 2));\\nvec4 q3 = pixelAtShortOffset(image, ivec2(2, 1));\\nvec4 q4 = pixelAtShortOffset(image, ivec2(2, 0));\\nvec4 q5 = pixelAtShortOffset(image, ivec2(2, -1));\\nvec4 q6 = pixelAtShortOffset(image, ivec2(2, -2));\\nvec4 q7 = pixelAtShortOffset(image, ivec2(1, -2));\\nvec4 q8 = pixelAtShortOffset(image, ivec2(0, -2));\\nvec4 q9 = pixelAtShortOffset(image, ivec2(-1, -2));\\nvec4 q10 = pixelAtShortOffset(image, ivec2(-2, -2));\\nvec4 q11 = pixelAtShortOffset(image, ivec2(-2, -1));\\nvec4 q12 = pixelAtShortOffset(image, ivec2(-2, 0));\\nvec4 q13 = pixelAtShortOffset(image, ivec2(-2, 1));\\nvec4 q14 = pixelAtShortOffset(image, ivec2(-2, 2));\\nvec4 q15 = pixelAtShortOffset(image, ivec2(-1, 2));\\n#else\\nvec4 q0, q1, q2, q3, q4, q5, q6, q7, q8, q9, q10, q11, q12, q13, q14, q15;\\nq0 = q1 = q2 = q3 = q4 = q5 = q6 = q7 = q8 = q9 = q10 =\\nq11 = q12 = q13 = q14 = q15 = vec4(0.0f);\\n#endif\\n#ifdef ENABLE_OUTER_RING\\nvec4 r0 = pixelAtShortOffset(image, ivec2(0, 3));\\nvec4 r1 = pixelAtShortOffset(image, ivec2(1, 3));\\nvec4 r2 = pixelAtShortOffset(image, ivec2(3, 1));\\nvec4 r3 = pixelAtShortOffset(image, ivec2(3, 0));\\nvec4 r4 = pixelAtShortOffset(image, ivec2(3, -1));\\nvec4 r5 = pixelAtShortOffset(image, ivec2(1, -3));\\nvec4 r6 = pixelAtShortOffset(image, ivec2(0, -3));\\nvec4 r7 = pixelAtShortOffset(image, ivec2(-1, -3));\\nvec4 r8 = pixelAtShortOffset(image, ivec2(-3, -1));\\nvec4 r9 = pixelAtShortOffset(image, ivec2(-3, 0));\\nvec4 r10 = pixelAtShortOffset(image, ivec2(-3, 1));\\nvec4 r11 = pixelAtShortOffset(image, ivec2(-1, 3));\\nvec4 r12 = pixelAtShortOffset(image, ivec2(0, 4));\\nvec4 r13 = pixelAtShortOffset(image, ivec2(4, 0));\\nvec4 r14 = pixelAtShortOffset(image, ivec2(0, -4));\\nvec4 r15 = pixelAtShortOffset(image, ivec2(-4, 0));\\n#else\\nvec4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15;\\nr0 = r1 = r2 = r3 = r4 = r5 = r6 = r7 = r8 = r9 = r10 =\\nr11 = r12 = r13 = r14 = r15 = vec4(0.0f);\\n#endif\\nfloat lodPlus = lod + lodStep;\\nfloat lodMinus = lod - lodStep;\\nfloat alphaPlus = encodeLod(lodPlus);\\nfloat alphaMinus = encodeLod(lodMinus);\\nmat3 innerScore = mat3(\\np0.r * float(isSameEncodedLod(p0.a, alphaPlus) || isSameEncodedLod(p0.a, alphaMinus)),\\np1.r * float(isSameEncodedLod(p1.a, alphaPlus) || isSameEncodedLod(p1.a, alphaMinus)),\\np2.r * float(isSameEncodedLod(p2.a, alphaPlus) || isSameEncodedLod(p2.a, alphaMinus)),\\np3.r * float(isSameEncodedLod(p3.a, alphaPlus) || isSameEncodedLod(p3.a, alphaMinus)),\\np4.r * float(isSameEncodedLod(p4.a, alphaPlus) || isSameEncodedLod(p4.a, alphaMinus)),\\np5.r * float(isSameEncodedLod(p5.a, alphaPlus) || isSameEncodedLod(p5.a, alphaMinus)),\\np6.r * float(isSameEncodedLod(p6.a, alphaPlus) || isSameEncodedLod(p6.a, alphaMinus)),\\np7.r * float(isSameEncodedLod(p7.a, alphaPlus) || isSameEncodedLod(p7.a, alphaMinus)),\\n0.0f\\n);\\nmat4 middleScore = mat4(\\nq0.r * float(isSameEncodedLod(q0.a, alphaPlus) || isSameEncodedLod(q0.a, alphaMinus)),\\nq1.r * float(isSameEncodedLod(q1.a, alphaPlus) || isSameEncodedLod(q1.a, alphaMinus)),\\nq2.r * float(isSameEncodedLod(q2.a, alphaPlus) || isSameEncodedLod(q2.a, alphaMinus)),\\nq3.r * float(isSameEncodedLod(q3.a, alphaPlus) || isSameEncodedLod(q3.a, alphaMinus)),\\nq4.r * float(isSameEncodedLod(q4.a, alphaPlus) || isSameEncodedLod(q4.a, alphaMinus)),\\nq5.r * float(isSameEncodedLod(q5.a, alphaPlus) || isSameEncodedLod(q5.a, alphaMinus)),\\nq6.r * float(isSameEncodedLod(q6.a, alphaPlus) || isSameEncodedLod(q6.a, alphaMinus)),\\nq7.r * float(isSameEncodedLod(q7.a, alphaPlus) || isSameEncodedLod(q7.a, alphaMinus)),\\nq8.r * float(isSameEncodedLod(q8.a, alphaPlus) || isSameEncodedLod(q8.a, alphaMinus)),\\nq9.r * float(isSameEncodedLod(q9.a, alphaPlus) || isSameEncodedLod(q9.a, alphaMinus)),\\nq10.r * float(isSameEncodedLod(q10.a, alphaPlus) || isSameEncodedLod(q10.a, alphaMinus)),\\nq11.r * float(isSameEncodedLod(q11.a, alphaPlus) || isSameEncodedLod(q11.a, alphaMinus)),\\nq12.r * float(isSameEncodedLod(q12.a, alphaPlus) || isSameEncodedLod(q12.a, alphaMinus)),\\nq13.r * float(isSameEncodedLod(q13.a, alphaPlus) || isSameEncodedLod(q13.a, alphaMinus)),\\nq14.r * float(isSameEncodedLod(q14.a, alphaPlus) || isSameEncodedLod(q14.a, alphaMinus)),\\nq15.r * float(isSameEncodedLod(q15.a, alphaPlus) || isSameEncodedLod(q15.a, alphaMinus))\\n);\\nmat4 outerScore = mat4(\\nr0.r * float(isSameEncodedLod(r0.a, alphaPlus) || isSameEncodedLod(r0.a, alphaMinus)),\\nr1.r * float(isSameEncodedLod(r1.a, alphaPlus) || isSameEncodedLod(r1.a, alphaMinus)),\\nr2.r * float(isSameEncodedLod(r2.a, alphaPlus) || isSameEncodedLod(r2.a, alphaMinus)),\\nr3.r * float(isSameEncodedLod(r3.a, alphaPlus) || isSameEncodedLod(r3.a, alphaMinus)),\\nr4.r * float(isSameEncodedLod(r4.a, alphaPlus) || isSameEncodedLod(r4.a, alphaMinus)),\\nr5.r * float(isSameEncodedLod(r5.a, alphaPlus) || isSameEncodedLod(r5.a, alphaMinus)),\\nr6.r * float(isSameEncodedLod(r6.a, alphaPlus) || isSameEncodedLod(r6.a, alphaMinus)),\\nr7.r * float(isSameEncodedLod(r7.a, alphaPlus) || isSameEncodedLod(r7.a, alphaMinus)),\\nr8.r * float(isSameEncodedLod(r8.a, alphaPlus) || isSameEncodedLod(r8.a, alphaMinus)),\\nr9.r * float(isSameEncodedLod(r9.a, alphaPlus) || isSameEncodedLod(r9.a, alphaMinus)),\\nr10.r * float(isSameEncodedLod(r10.a, alphaPlus) || isSameEncodedLod(r10.a, alphaMinus)),\\nr11.r * float(isSameEncodedLod(r11.a, alphaPlus) || isSameEncodedLod(r11.a, alphaMinus)),\\nr12.r * float(isSameEncodedLod(r12.a, alphaPlus) || isSameEncodedLod(r12.a, alphaMinus)),\\nr13.r * float(isSameEncodedLod(r13.a, alphaPlus) || isSameEncodedLod(r13.a, alphaMinus)),\\nr14.r * float(isSameEncodedLod(r14.a, alphaPlus) || isSameEncodedLod(r14.a, alphaMinus)),\\nr15.r * float(isSameEncodedLod(r15.a, alphaPlus) || isSameEncodedLod(r15.a, alphaMinus))\\n);\\nvec3 maxInnerScore3 = max(innerScore[0], max(innerScore[1], innerScore[2]));\\nvec4 maxMiddleScore4 = max(max(middleScore[0], middleScore[1]), max(middleScore[2], middleScore[3]));\\nvec4 maxOuterScore4 = max(max(outerScore[0], outerScore[1]), max(outerScore[2], outerScore[3]));\\nfloat maxInnerScore = max(maxInnerScore3.x, max(maxInnerScore3.y, maxInnerScore3.z));\\nfloat maxMiddleScore = max(max(maxMiddleScore4.x, maxMiddleScore4.y), max(maxMiddleScore4.z, maxMiddleScore4.w));\\nfloat maxOuterScore = max(max(maxOuterScore4.x, maxOuterScore4.y), max(maxOuterScore4.z, maxOuterScore4.w));\\nfloat maxScore = max(maxInnerScore, max(maxMiddleScore, maxOuterScore));\\nfloat myScore = step(maxScore, pixel.r) * pixel.r;\\ncolor = vec4(myScore, pixel.gba);\\n}\"","module.exports = \"uniform sampler2D image;\\nvoid main()\\n{\\nfloat p0 = pixelAtShortOffset(image, ivec2(0, 1)).r;\\nfloat p1 = pixelAtShortOffset(image, ivec2(1, 1)).r;\\nfloat p2 = pixelAtShortOffset(image, ivec2(1, 0)).r;\\nfloat p3 = pixelAtShortOffset(image, ivec2(1, -1)).r;\\nfloat p4 = pixelAtShortOffset(image, ivec2(0, -1)).r;\\nfloat p5 = pixelAtShortOffset(image, ivec2(-1, -1)).r;\\nfloat p6 = pixelAtShortOffset(image, ivec2(-1, 0)).r;\\nfloat p7 = pixelAtShortOffset(image, ivec2(-1, 1)).r;\\nfloat m = max(\\nmax(max(p0, p1), max(p2, p3)),\\nmax(max(p4, p5), max(p6, p7))\\n);\\nvec4 pixel = threadPixel(image);\\nfloat score = step(m, pixel.r) * pixel.r;\\ncolor = vec4(score, pixel.gba);\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform sampler2D encodedCorners;\\nuniform int encoderLength;\\nuniform sampler2D pyramid;\\nuniform int extraSize;\\nconst int descriptorSize = 32;\\nconst ivec4 pat31[256] = ivec4[256](\\nivec4(8,-3,9,5),\\nivec4(4,2,7,-12),\\nivec4(-11,9,-8,2),\\nivec4(7,-12,12,-13),\\nivec4(2,-13,2,12),\\nivec4(1,-7,1,6),\\nivec4(-2,-10,-2,-4),\\nivec4(-13,-13,-11,-8),\\nivec4(-13,-3,-12,-9),\\nivec4(10,4,11,9),\\nivec4(-13,-8,-8,-9),\\nivec4(-11,7,-9,12),\\nivec4(7,7,12,6),\\nivec4(-4,-5,-3,0),\\nivec4(-13,2,-12,-3),\\nivec4(-9,0,-7,5),\\nivec4(12,-6,12,-1),\\nivec4(-3,6,-2,12),\\nivec4(-6,-13,-4,-8),\\nivec4(11,-13,12,-8),\\nivec4(4,7,5,1),\\nivec4(5,-3,10,-3),\\nivec4(3,-7,6,12),\\nivec4(-8,-7,-6,-2),\\nivec4(-2,11,-1,-10),\\nivec4(-13,12,-8,10),\\nivec4(-7,3,-5,-3),\\nivec4(-4,2,-3,7),\\nivec4(-10,-12,-6,11),\\nivec4(5,-12,6,-7),\\nivec4(5,-6,7,-1),\\nivec4(1,0,4,-5),\\nivec4(9,11,11,-13),\\nivec4(4,7,4,12),\\nivec4(2,-1,4,4),\\nivec4(-4,-12,-2,7),\\nivec4(-8,-5,-7,-10),\\nivec4(4,11,9,12),\\nivec4(0,-8,1,-13),\\nivec4(-13,-2,-8,2),\\nivec4(-3,-2,-2,3),\\nivec4(-6,9,-4,-9),\\nivec4(8,12,10,7),\\nivec4(0,9,1,3),\\nivec4(7,-5,11,-10),\\nivec4(-13,-6,-11,0),\\nivec4(10,7,12,1),\\nivec4(-6,-3,-6,12),\\nivec4(10,-9,12,-4),\\nivec4(-13,8,-8,-12),\\nivec4(-13,0,-8,-4),\\nivec4(3,3,7,8),\\nivec4(5,7,10,-7),\\nivec4(-1,7,1,-12),\\nivec4(3,-10,5,6),\\nivec4(2,-4,3,-10),\\nivec4(-13,0,-13,5),\\nivec4(-13,-7,-12,12),\\nivec4(-13,3,-11,8),\\nivec4(-7,12,-4,7),\\nivec4(6,-10,12,8),\\nivec4(-9,-1,-7,-6),\\nivec4(-2,-5,0,12),\\nivec4(-12,5,-7,5),\\nivec4(3,-10,8,-13),\\nivec4(-7,-7,-4,5),\\nivec4(-3,-2,-1,-7),\\nivec4(2,9,5,-11),\\nivec4(-11,-13,-5,-13),\\nivec4(-1,6,0,-1),\\nivec4(5,-3,5,2),\\nivec4(-4,-13,-4,12),\\nivec4(-9,-6,-9,6),\\nivec4(-12,-10,-8,-4),\\nivec4(10,2,12,-3),\\nivec4(7,12,12,12),\\nivec4(-7,-13,-6,5),\\nivec4(-4,9,-3,4),\\nivec4(7,-1,12,2),\\nivec4(-7,6,-5,1),\\nivec4(-13,11,-12,5),\\nivec4(-3,7,-2,-6),\\nivec4(7,-8,12,-7),\\nivec4(-13,-7,-11,-12),\\nivec4(1,-3,12,12),\\nivec4(2,-6,3,0),\\nivec4(-4,3,-2,-13),\\nivec4(-1,-13,1,9),\\nivec4(7,1,8,-6),\\nivec4(1,-1,3,12),\\nivec4(9,1,12,6),\\nivec4(-1,-9,-1,3),\\nivec4(-13,-13,-10,5),\\nivec4(7,7,10,12),\\nivec4(12,-5,12,9),\\nivec4(6,3,7,11),\\nivec4(5,-13,6,10),\\nivec4(2,-12,2,3),\\nivec4(3,8,4,-6),\\nivec4(2,6,12,-13),\\nivec4(9,-12,10,3),\\nivec4(-8,4,-7,9),\\nivec4(-11,12,-4,-6),\\nivec4(1,12,2,-8),\\nivec4(6,-9,7,-4),\\nivec4(2,3,3,-2),\\nivec4(6,3,11,0),\\nivec4(3,-3,8,-8),\\nivec4(7,8,9,3),\\nivec4(-11,-5,-6,-4),\\nivec4(-10,11,-5,10),\\nivec4(-5,-8,-3,12),\\nivec4(-10,5,-9,0),\\nivec4(8,-1,12,-6),\\nivec4(4,-6,6,-11),\\nivec4(-10,12,-8,7),\\nivec4(4,-2,6,7),\\nivec4(-2,0,-2,12),\\nivec4(-5,-8,-5,2),\\nivec4(7,-6,10,12),\\nivec4(-9,-13,-8,-8),\\nivec4(-5,-13,-5,-2),\\nivec4(8,-8,9,-13),\\nivec4(-9,-11,-9,0),\\nivec4(1,-8,1,-2),\\nivec4(7,-4,9,1),\\nivec4(-2,1,-1,-4),\\nivec4(11,-6,12,-11),\\nivec4(-12,-9,-6,4),\\nivec4(3,7,7,12),\\nivec4(5,5,10,8),\\nivec4(0,-4,2,8),\\nivec4(-9,12,-5,-13),\\nivec4(0,7,2,12),\\nivec4(-1,2,1,7),\\nivec4(5,11,7,-9),\\nivec4(3,5,6,-8),\\nivec4(-13,-4,-8,9),\\nivec4(-5,9,-3,-3),\\nivec4(-4,-7,-3,-12),\\nivec4(6,5,8,0),\\nivec4(-7,6,-6,12),\\nivec4(-13,6,-5,-2),\\nivec4(1,-10,3,10),\\nivec4(4,1,8,-4),\\nivec4(-2,-2,2,-13),\\nivec4(2,-12,12,12),\\nivec4(-2,-13,0,-6),\\nivec4(4,1,9,3),\\nivec4(-6,-10,-3,-5),\\nivec4(-3,-13,-1,1),\\nivec4(7,5,12,-11),\\nivec4(4,-2,5,-7),\\nivec4(-13,9,-9,-5),\\nivec4(7,1,8,6),\\nivec4(7,-8,7,6),\\nivec4(-7,-4,-7,1),\\nivec4(-8,11,-7,-8),\\nivec4(-13,6,-12,-8),\\nivec4(2,4,3,9),\\nivec4(10,-5,12,3),\\nivec4(-6,-5,-6,7),\\nivec4(8,-3,9,-8),\\nivec4(2,-12,2,8),\\nivec4(-11,-2,-10,3),\\nivec4(-12,-13,-7,-9),\\nivec4(-11,0,-10,-5),\\nivec4(5,-3,11,8),\\nivec4(-2,-13,-1,12),\\nivec4(-1,-8,0,9),\\nivec4(-13,-11,-12,-5),\\nivec4(-10,-2,-10,11),\\nivec4(-3,9,-2,-13),\\nivec4(2,-3,3,2),\\nivec4(-9,-13,-4,0),\\nivec4(-4,6,-3,-10),\\nivec4(-4,12,-2,-7),\\nivec4(-6,-11,-4,9),\\nivec4(6,-3,6,11),\\nivec4(-13,11,-5,5),\\nivec4(11,11,12,6),\\nivec4(7,-5,12,-2),\\nivec4(-1,12,0,7),\\nivec4(-4,-8,-3,-2),\\nivec4(-7,1,-6,7),\\nivec4(-13,-12,-8,-13),\\nivec4(-7,-2,-6,-8),\\nivec4(-8,5,-6,-9),\\nivec4(-5,-1,-4,5),\\nivec4(-13,7,-8,10),\\nivec4(1,5,5,-13),\\nivec4(1,0,10,-13),\\nivec4(9,12,10,-1),\\nivec4(5,-8,10,-9),\\nivec4(-1,11,1,-13),\\nivec4(-9,-3,-6,2),\\nivec4(-1,-10,1,12),\\nivec4(-13,1,-8,-10),\\nivec4(8,-11,10,-6),\\nivec4(2,-13,3,-6),\\nivec4(7,-13,12,-9),\\nivec4(-10,-10,-5,-7),\\nivec4(-10,-8,-8,-13),\\nivec4(4,-6,8,5),\\nivec4(3,12,8,-13),\\nivec4(-4,2,-3,-3),\\nivec4(5,-13,10,-12),\\nivec4(4,-13,5,-1),\\nivec4(-9,9,-4,3),\\nivec4(0,3,3,-9),\\nivec4(-12,1,-6,1),\\nivec4(3,2,4,-8),\\nivec4(-10,-10,-10,9),\\nivec4(8,-13,12,12),\\nivec4(-8,-12,-6,-5),\\nivec4(2,2,3,7),\\nivec4(10,6,11,-8),\\nivec4(6,8,8,-12),\\nivec4(-7,10,-6,5),\\nivec4(-3,-9,-3,9),\\nivec4(-1,-13,-1,5),\\nivec4(-3,-7,-3,4),\\nivec4(-8,-2,-8,3),\\nivec4(4,2,12,12),\\nivec4(2,-5,3,11),\\nivec4(6,-9,11,-13),\\nivec4(3,-1,7,12),\\nivec4(11,-1,12,4),\\nivec4(-3,0,-3,6),\\nivec4(4,-11,4,12),\\nivec4(2,-4,2,1),\\nivec4(-10,-6,-8,1),\\nivec4(-13,7,-11,1),\\nivec4(-13,12,-11,-13),\\nivec4(6,0,11,-13),\\nivec4(0,-1,1,4),\\nivec4(-13,3,-9,-2),\\nivec4(-9,8,-6,-3),\\nivec4(-13,-6,-8,-2),\\nivec4(5,-9,8,10),\\nivec4(2,7,3,-9),\\nivec4(-1,-6,-1,-1),\\nivec4(9,5,11,-2),\\nivec4(11,-3,12,-8),\\nivec4(3,0,3,5),\\nivec4(-1,4,0,10),\\nivec4(3,-6,4,5),\\nivec4(-13,0,-10,5),\\nivec4(5,8,12,11),\\nivec4(8,9,9,-6),\\nivec4(7,-4,8,-12),\\nivec4(-10,4,-10,9),\\nivec4(7,3,12,4),\\nivec4(9,-7,10,-2),\\nivec4(7,0,12,-2),\\nivec4(-1,-6,0,-11)\\n);\\nvoid getPair(int index, float kcos, float ksin, out ivec2 p, out ivec2 q)\\n{\\nivec4 data = pat31[index];\\nvec2 op = vec2(data.xy);\\nvec2 oq = vec2(data.zw);\\np = ivec2(round(op.x * kcos - op.y * ksin), round(op.x * ksin + op.y * kcos));\\nq = ivec2(round(oq.x * kcos - oq.y * ksin), round(oq.x * ksin + oq.y * kcos));\\n}\\nvoid main()\\n{\\nvec4 pixel = threadPixel(encodedCorners);\\nivec2 thread = threadLocation();\\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\\nint descriptorCell = address.offset - sizeofEncodedKeypoint(0, extraSize) / 4;\\ncolor = pixel;\\nif(descriptorCell < 0)\\nreturn;\\nKeypoint keypoint = decodeKeypoint(encodedCorners, encoderLength, address);\\nif(isBadKeypoint(keypoint))\\nreturn;\\nfloat pot = exp2(keypoint.lod);\\nfloat kcos = cos(keypoint.orientation);\\nfloat ksin = sin(keypoint.orientation);\\nvec2 imageSize = vec2(textureSize(pyramid, 0));\\nint patternStart = 32 * descriptorCell;\\nuint test[4] = uint[4](0u, 0u, 0u, 0u);\\nfor(int t = 0; t < 4; t++) {\\nuint bits = 0u;\\nivec2 p, q;\\nvec4 a, b;\\nint i = t * 8;\\n@unroll\\nfor(int j = 0; j < 8; j++) {\\ngetPair(patternStart + i + j, kcos, ksin, p, q);\\na = pyrPixelAtEx(pyramid, round(keypoint.position + pot * vec2(p)), keypoint.lod, imageSize);\\nb = pyrPixelAtEx(pyramid, round(keypoint.position + pot * vec2(q)), keypoint.lod, imageSize);\\nbits |= uint(a.g < b.g) << j;\\n}\\ntest[t] = bits;\\n}\\ncolor = vec4(float(test[0]), float(test[1]), float(test[2]), float(test[3])) / 255.0f;\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform sampler2D pyramid;\\nuniform sampler2D encodedKeypoints;\\nuniform int patchRadius;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int encoderLength;\\nconst int patchStart[8] = int[8](0, 0, 8, 28, 64, 132, 228, 356);\\nconst int patchPointCount[8] = int[8](0, 8, 20, 36, 68, 96, 128, 168);\\nconst ivec2 patchData[524] = ivec2[524](\\nivec2(-1,-1),ivec2(0,-1),ivec2(1,-1),ivec2(-1,0),ivec2(1,0),ivec2(-1,1),ivec2(0,1),ivec2(1,1),\\nivec2(-1,-2),ivec2(0,-2),ivec2(1,-2),ivec2(-2,-1),ivec2(-1,-1),ivec2(0,-1),ivec2(1,-1),ivec2(2,-1),ivec2(-2,0),ivec2(-1,0),ivec2(1,0),ivec2(2,0),ivec2(-2,1),ivec2(-1,1),ivec2(0,1),ivec2(1,1),ivec2(2,1),ivec2(-1,2),ivec2(0,2),ivec2(1,2),\\nivec2(-1,-3),ivec2(0,-3),ivec2(1,-3),ivec2(-2,-2),ivec2(-1,-2),ivec2(0,-2),ivec2(1,-2),ivec2(2,-2),ivec2(-3,-1),ivec2(-2,-1),ivec2(-1,-1),ivec2(0,-1),ivec2(1,-1),ivec2(2,-1),ivec2(3,-1),ivec2(-3,0),ivec2(-2,0),ivec2(-1,0),ivec2(1,0),ivec2(2,0),ivec2(3,0),ivec2(-3,1),ivec2(-2,1),ivec2(-1,1),ivec2(0,1),ivec2(1,1),ivec2(2,1),ivec2(3,1),ivec2(-2,2),ivec2(-1,2),ivec2(0,2),ivec2(1,2),ivec2(2,2),ivec2(-1,3),ivec2(0,3),ivec2(1,3),\\nivec2(-2,-4),ivec2(-1,-4),ivec2(0,-4),ivec2(1,-4),ivec2(2,-4),ivec2(-3,-3),ivec2(-2,-3),ivec2(-1,-3),ivec2(0,-3),ivec2(1,-3),ivec2(2,-3),ivec2(3,-3),ivec2(-4,-2),ivec2(-3,-2),ivec2(-2,-2),ivec2(-1,-2),ivec2(0,-2),ivec2(1,-2),ivec2(2,-2),ivec2(3,-2),ivec2(4,-2),ivec2(-4,-1),ivec2(-3,-1),ivec2(-2,-1),ivec2(-1,-1),ivec2(0,-1),ivec2(1,-1),ivec2(2,-1),ivec2(3,-1),ivec2(4,-1),ivec2(-4,0),ivec2(-3,0),ivec2(-2,0),ivec2(-1,0),ivec2(1,0),ivec2(2,0),ivec2(3,0),ivec2(4,0),ivec2(-4,1),ivec2(-3,1),ivec2(-2,1),ivec2(-1,1),ivec2(0,1),ivec2(1,1),ivec2(2,1),ivec2(3,1),ivec2(4,1),ivec2(-4,2),ivec2(-3,2),ivec2(-2,2),ivec2(-1,2),ivec2(0,2),ivec2(1,2),ivec2(2,2),ivec2(3,2),ivec2(4,2),ivec2(-3,3),ivec2(-2,3),ivec2(-1,3),ivec2(0,3),ivec2(1,3),ivec2(2,3),ivec2(3,3),ivec2(-2,4),ivec2(-1,4),ivec2(0,4),ivec2(1,4),ivec2(2,4),\\nivec2(-2,-5),ivec2(-1,-5),ivec2(0,-5),ivec2(1,-5),ivec2(2,-5),ivec2(-3,-4),ivec2(-2,-4),ivec2(-1,-4),ivec2(0,-4),ivec2(1,-4),ivec2(2,-4),ivec2(3,-4),ivec2(-4,-3),ivec2(-3,-3),ivec2(-2,-3),ivec2(-1,-3),ivec2(0,-3),ivec2(1,-3),ivec2(2,-3),ivec2(3,-3),ivec2(4,-3),ivec2(-5,-2),ivec2(-4,-2),ivec2(-3,-2),ivec2(-2,-2),ivec2(-1,-2),ivec2(0,-2),ivec2(1,-2),ivec2(2,-2),ivec2(3,-2),ivec2(4,-2),ivec2(5,-2),ivec2(-5,-1),ivec2(-4,-1),ivec2(-3,-1),ivec2(-2,-1),ivec2(-1,-1),ivec2(0,-1),ivec2(1,-1),ivec2(2,-1),ivec2(3,-1),ivec2(4,-1),ivec2(5,-1),ivec2(-5,0),ivec2(-4,0),ivec2(-3,0),ivec2(-2,0),ivec2(-1,0),ivec2(1,0),ivec2(2,0),ivec2(3,0),ivec2(4,0),ivec2(5,0),ivec2(-5,1),ivec2(-4,1),ivec2(-3,1),ivec2(-2,1),ivec2(-1,1),ivec2(0,1),ivec2(1,1),ivec2(2,1),ivec2(3,1),ivec2(4,1),ivec2(5,1),ivec2(-5,2),ivec2(-4,2),ivec2(-3,2),ivec2(-2,2),ivec2(-1,2),ivec2(0,2),ivec2(1,2),ivec2(2,2),ivec2(3,2),ivec2(4,2),ivec2(5,2),ivec2(-4,3),ivec2(-3,3),ivec2(-2,3),ivec2(-1,3),ivec2(0,3),ivec2(1,3),ivec2(2,3),ivec2(3,3),ivec2(4,3),ivec2(-3,4),ivec2(-2,4),ivec2(-1,4),ivec2(0,4),ivec2(1,4),ivec2(2,4),ivec2(3,4),ivec2(-2,5),ivec2(-1,5),ivec2(0,5),ivec2(1,5),ivec2(2,5),\\nivec2(-2,-6),ivec2(-1,-6),ivec2(0,-6),ivec2(1,-6),ivec2(2,-6),ivec2(-3,-5),ivec2(-2,-5),ivec2(-1,-5),ivec2(0,-5),ivec2(1,-5),ivec2(2,-5),ivec2(3,-5),ivec2(-4,-4),ivec2(-3,-4),ivec2(-2,-4),ivec2(-1,-4),ivec2(0,-4),ivec2(1,-4),ivec2(2,-4),ivec2(3,-4),ivec2(4,-4),ivec2(-5,-3),ivec2(-4,-3),ivec2(-3,-3),ivec2(-2,-3),ivec2(-1,-3),ivec2(0,-3),ivec2(1,-3),ivec2(2,-3),ivec2(3,-3),ivec2(4,-3),ivec2(5,-3),ivec2(-6,-2),ivec2(-5,-2),ivec2(-4,-2),ivec2(-3,-2),ivec2(-2,-2),ivec2(-1,-2),ivec2(0,-2),ivec2(1,-2),ivec2(2,-2),ivec2(3,-2),ivec2(4,-2),ivec2(5,-2),ivec2(6,-2),ivec2(-6,-1),ivec2(-5,-1),ivec2(-4,-1),ivec2(-3,-1),ivec2(-2,-1),ivec2(-1,-1),ivec2(0,-1),ivec2(1,-1),ivec2(2,-1),ivec2(3,-1),ivec2(4,-1),ivec2(5,-1),ivec2(6,-1),ivec2(-6,0),ivec2(-5,0),ivec2(-4,0),ivec2(-3,0),ivec2(-2,0),ivec2(-1,0),ivec2(1,0),ivec2(2,0),ivec2(3,0),ivec2(4,0),ivec2(5,0),ivec2(6,0),ivec2(-6,1),ivec2(-5,1),ivec2(-4,1),ivec2(-3,1),ivec2(-2,1),ivec2(-1,1),ivec2(0,1),ivec2(1,1),ivec2(2,1),ivec2(3,1),ivec2(4,1),ivec2(5,1),ivec2(6,1),ivec2(-6,2),ivec2(-5,2),ivec2(-4,2),ivec2(-3,2),ivec2(-2,2),ivec2(-1,2),ivec2(0,2),ivec2(1,2),ivec2(2,2),ivec2(3,2),ivec2(4,2),ivec2(5,2),ivec2(6,2),ivec2(-5,3),ivec2(-4,3),ivec2(-3,3),ivec2(-2,3),ivec2(-1,3),ivec2(0,3),ivec2(1,3),ivec2(2,3),ivec2(3,3),ivec2(4,3),ivec2(5,3),ivec2(-4,4),ivec2(-3,4),ivec2(-2,4),ivec2(-1,4),ivec2(0,4),ivec2(1,4),ivec2(2,4),ivec2(3,4),ivec2(4,4),ivec2(-3,5),ivec2(-2,5),ivec2(-1,5),ivec2(0,5),ivec2(1,5),ivec2(2,5),ivec2(3,5),ivec2(-2,6),ivec2(-1,6),ivec2(0,6),ivec2(1,6),ivec2(2,6),\\nivec2(-2,-7),ivec2(-1,-7),ivec2(0,-7),ivec2(1,-7),ivec2(2,-7),ivec2(-4,-6),ivec2(-3,-6),ivec2(-2,-6),ivec2(-1,-6),ivec2(0,-6),ivec2(1,-6),ivec2(2,-6),ivec2(3,-6),ivec2(4,-6),ivec2(-5,-5),ivec2(-3,-5),ivec2(-2,-5),ivec2(-1,-5),ivec2(0,-5),ivec2(1,-5),ivec2(2,-5),ivec2(3,-5),ivec2(5,-5),ivec2(-6,-4),ivec2(-4,-4),ivec2(-3,-4),ivec2(-2,-4),ivec2(-1,-4),ivec2(0,-4),ivec2(1,-4),ivec2(2,-4),ivec2(3,-4),ivec2(4,-4),ivec2(6,-4),ivec2(-6,-3),ivec2(-5,-3),ivec2(-4,-3),ivec2(-3,-3),ivec2(-2,-3),ivec2(-1,-3),ivec2(0,-3),ivec2(1,-3),ivec2(2,-3),ivec2(3,-3),ivec2(4,-3),ivec2(5,-3),ivec2(6,-3),ivec2(-7,-2),ivec2(-6,-2),ivec2(-5,-2),ivec2(-4,-2),ivec2(-3,-2),ivec2(-2,-2),ivec2(-1,-2),ivec2(0,-2),ivec2(1,-2),ivec2(2,-2),ivec2(3,-2),ivec2(4,-2),ivec2(5,-2),ivec2(6,-2),ivec2(7,-2),ivec2(-7,-1),ivec2(-6,-1),ivec2(-5,-1),ivec2(-4,-1),ivec2(-3,-1),ivec2(-2,-1),ivec2(-1,-1),ivec2(0,-1),ivec2(1,-1),ivec2(2,-1),ivec2(3,-1),ivec2(4,-1),ivec2(5,-1),ivec2(6,-1),ivec2(7,-1),ivec2(-7,0),ivec2(-6,0),ivec2(-5,0),ivec2(-4,0),ivec2(-3,0),ivec2(-2,0),ivec2(-1,0),ivec2(1,0),ivec2(2,0),ivec2(3,0),ivec2(4,0),ivec2(5,0),ivec2(6,0),ivec2(7,0),ivec2(-7,1),ivec2(-6,1),ivec2(-5,1),ivec2(-4,1),ivec2(-3,1),ivec2(-2,1),ivec2(-1,1),ivec2(0,1),ivec2(1,1),ivec2(2,1),ivec2(3,1),ivec2(4,1),ivec2(5,1),ivec2(6,1),ivec2(7,1),ivec2(-7,2),ivec2(-6,2),ivec2(-5,2),ivec2(-4,2),ivec2(-3,2),ivec2(-2,2),ivec2(-1,2),ivec2(0,2),ivec2(1,2),ivec2(2,2),ivec2(3,2),ivec2(4,2),ivec2(5,2),ivec2(6,2),ivec2(7,2),ivec2(-6,3),ivec2(-5,3),ivec2(-4,3),ivec2(-3,3),ivec2(-2,3),ivec2(-1,3),ivec2(0,3),ivec2(1,3),ivec2(2,3),ivec2(3,3),ivec2(4,3),ivec2(5,3),ivec2(6,3),ivec2(-6,4),ivec2(-4,4),ivec2(-3,4),ivec2(-2,4),ivec2(-1,4),ivec2(0,4),ivec2(1,4),ivec2(2,4),ivec2(3,4),ivec2(4,4),ivec2(6,4),ivec2(-5,5),ivec2(-3,5),ivec2(-2,5),ivec2(-1,5),ivec2(0,5),ivec2(1,5),ivec2(2,5),ivec2(3,5),ivec2(5,5),ivec2(-4,6),ivec2(-3,6),ivec2(-2,6),ivec2(-1,6),ivec2(0,6),ivec2(1,6),ivec2(2,6),ivec2(3,6),ivec2(4,6),ivec2(-2,7),ivec2(-1,7),ivec2(0,7),ivec2(1,7),ivec2(2,7)\\n);\\nconst int MIN_PATCH_RADIUS = 3;\\nconst int MAX_PATCH_RADIUS = 7;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(encodedKeypoints);\\nivec2 thread = threadLocation();\\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\\ncolor = pixel;\\nif(address.offset != 1)\\nreturn;\\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\\nfloat pot = exp2(keypoint.lod);\\nvec2 m = vec2(0.0f);\\nivec2 pyrBaseSize = textureSize(pyramid, 0);\\nint scaledRadius = int(ceil(float(patchRadius) / pot));\\nint radius = clamp(scaledRadius, MIN_PATCH_RADIUS, MAX_PATCH_RADIUS);\\nint start = patchStart[radius];\\nint count = patchPointCount[radius];\\nfor(int j = 0; j < count; j++) {\\nvec2 offset = vec2(patchData[start + j]);\\nvec2 position = keypoint.position + round(pot * offset);\\nvec4 patchPixel = pyrPixelAtEx(pyramid, position, keypoint.lod, pyrBaseSize);\\nm += offset * patchPixel.g;\\n}\\nfloat angle = fastAtan2(m.y, m.x);\\ncolor.g = encodeOrientation(angle);\\ncolor.a = encodeKeypointFlags(keypoint.flags | KPF_ORIENTED);\\n}\"","module.exports = \"@include \\\"pyramids.glsl\\\"\\nuniform sampler2D image;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nivec2 thread = threadLocation();\\nfloat lod = decodeLod(pixel.a);\\nfloat pot = exp2(lod);\\ncolor = pixel;\\nif(pixel.r == 0.0f)\\nreturn;\\nvec4 p0 = pixelAtShortOffset(image, ivec2(0, 1));\\nvec4 p1 = pixelAtShortOffset(image, ivec2(1, 1));\\nvec4 p2 = pixelAtShortOffset(image, ivec2(1, 0));\\nvec4 p3 = pixelAtShortOffset(image, ivec2(1, -1));\\nvec4 p4 = pixelAtShortOffset(image, ivec2(0, -1));\\nvec4 p5 = pixelAtShortOffset(image, ivec2(-1, -1));\\nvec4 p6 = pixelAtShortOffset(image, ivec2(-1, 0));\\nvec4 p7 = pixelAtShortOffset(image, ivec2(-1, 1));\\nmat3 score = mat3(\\np0.r * float(isSameEncodedLod(p0.a, pixel.a)),\\np1.r * float(isSameEncodedLod(p1.a, pixel.a)),\\np2.r * float(isSameEncodedLod(p2.a, pixel.a)),\\np3.r * float(isSameEncodedLod(p3.a, pixel.a)),\\np4.r * float(isSameEncodedLod(p4.a, pixel.a)),\\np5.r * float(isSameEncodedLod(p5.a, pixel.a)),\\np6.r * float(isSameEncodedLod(p6.a, pixel.a)),\\np7.r * float(isSameEncodedLod(p7.a, pixel.a)),\\n0.0f\\n);\\nvec3 maxScore3 = max(score[0], max(score[1], score[2]));\\nfloat maxScore = max(maxScore3.x, max(maxScore3.y, maxScore3.z));\\nfloat myScore = step(maxScore, pixel.r) * pixel.r;\\ncolor = vec4(myScore, pixel.gba);\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform sampler2D encodedKeypoints;\\nuniform int estimatedKeypointCount;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int encoderLength;\\n#if !defined(MAX_KEYPOINTS)\\n#error Must define MAX_KEYPOINTS\\n#elif MAX_KEYPOINTS >= 65536\\n#error MAX_KEYPOINTS is too large!\\n#endif\\nuint tuple[1 + MAX_KEYPOINTS];\\nuint encodeTuple(Keypoint keypoint, int index)\\n{\\nuint mask = uint(-int(!isBadKeypoint(keypoint)));\\nuint score = uint(clamp(keypoint.score, 0.0f, 1.0f) * 65535.0f);\\nuint data = (uint(index) & 65535u) | (score << 16u);\\nreturn data & mask;\\n}\\n#define decodeTupleIndex(tuple) int((tuple) & 16777215u)\\n#define QUICKSELECT_UNSIGNED\\n#define QUICKSELECT_DESCENDING\\n#define QUICKSELECT_ARRAY tuple\\n@include \\\"quickselect.glsl\\\"\\nvoid main()\\n{\\nvec4 pixel = threadPixel(encodedKeypoints);\\nivec2 thread = threadLocation();\\nKeypointAddress myAddress = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\\nint myIndex = findKeypointIndex(myAddress, descriptorSize, extraSize);\\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\\ncolor = pixel;\\nif(myIndex >= estimatedKeypointCount)\\nreturn;\\nKeypoint keypoint;\\nKeypointAddress address = KeypointAddress(0, 0);\\nint actualKeypointCount = estimatedKeypointCount;\\nfor(int i = 0; i < estimatedKeypointCount; i++) {\\nkeypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\\ntuple[min(i, MAX_KEYPOINTS)] = encodeTuple(keypoint, i);\\nactualKeypointCount = isBadKeypoint(keypoint) ? min(actualKeypointCount, i) : actualKeypointCount;\\naddress.base += pixelsPerKeypoint;\\n}\\nint desiredTuple = quickselect(0, min(MAX_KEYPOINTS, actualKeypointCount - 1), myIndex);\\nint desiredIndex = decodeTupleIndex(desiredTuple);\\nKeypointAddress desiredAddress = KeypointAddress(desiredIndex * pixelsPerKeypoint, myAddress.offset);\\nint desiredRasterIndex = desiredAddress.base + desiredAddress.offset;\\nvec4 desiredPixel = readKeypointData(encodedKeypoints, encoderLength, desiredRasterIndex);\\ncolor = myIndex < actualKeypointCount ? desiredPixel : encodeNullKeypoint();\\n}\"","module.exports = \"uniform sampler2D image;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nivec2 pos = min(thread * 2, textureSize(image, 0) - ivec2(1));\\ncolor = pixelAt(image, pos);\\n}\"","module.exports = \"uniform sampler2D image;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nvec4 pixel = pixelAt(image, thread / 2);\\ncolor = (((thread.x + thread.y) & 1) == 0) ? pixel : vec4(0.0f, 0.0f, 0.0f, pixel.a);\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform sampler2D pyramid;\\nuniform sampler2D encodedKeypoints;\\nuniform int windowSize;\\nuniform float discardThreshold;\\nuniform int firstKeypointIndex, lastKeypointIndex;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int encoderLength;\\n#ifndef MAX_WINDOW_SIZE\\n#error Must define MAX_WINDOW_SIZE\\n#endif\\nconst int MAX_WINDOW_SIZE_PLUS = MAX_WINDOW_SIZE + 2;\\nconst int MAX_WINDOW_SIZE_PLUS_SQUARED = MAX_WINDOW_SIZE_PLUS * MAX_WINDOW_SIZE_PLUS;\\nconst int MAX_WINDOW_RADIUS_PLUS = (MAX_WINDOW_SIZE_PLUS - 1) / 2;\\nconst float DISCARD_SCALE = 0.00024318695068359375f;\\nfloat pixelBuffer[MAX_WINDOW_SIZE_PLUS_SQUARED];\\n#define pixelIndex(i, j) (((j) + MAX_WINDOW_RADIUS_PLUS) * MAX_WINDOW_SIZE_PLUS + ((i) + MAX_WINDOW_RADIUS_PLUS))\\n#define windowRadius() ((windowSize - 1) / 2)\\nvoid readWindow(vec2 center, float lod)\\n{\\nivec2 pyrBaseSize = textureSize(pyramid, 0);\\nfloat pot = exp2(lod);\\nint r = windowRadius();\\n#define readPixelAt(ox, oy) pixelBuffer[pixelIndex((ox), (oy))] = pyrSubpixelAtExOffset(pyramid, center, lod, pot, ivec2((ox), (oy)), pyrBaseSize).g\\nfor(int j = 0; j < windowSize; j++) {\\nfor(int i = 0; i < windowSize; i++) {\\nreadPixelAt(i-r, j-r);\\n}\\n}\\nint r1 = r+1;\\nfor(int k = 0; k < windowSize; k++) {\\nreadPixelAt(-r1, k-r);\\nreadPixelAt( r1, k-r);\\nreadPixelAt(k-r,-r1);\\nreadPixelAt(k-r, r1);\\n}\\nreadPixelAt(-r1,-r1);\\nreadPixelAt( r1,-r1);\\nreadPixelAt(-r1, r1);\\nreadPixelAt( r1, r1);\\n}\\nvec2 computeDerivatives(ivec2 offset)\\n{\\nconst mat3 derivX = mat3(\\n3, 0, -3,\\n10, 0, -10,\\n3, 0, -3\\n);\\nconst mat3 derivY = mat3(\\n3, 10, 3,\\n0, 0, 0,\\n-3, -10, -3\\n);\\nmat3 window = mat3(\\npixelBuffer[pixelIndex(offset.x-1, offset.y-1)],\\npixelBuffer[pixelIndex(offset.x+0, offset.y-1)],\\npixelBuffer[pixelIndex(offset.x+1, offset.y-1)],\\npixelBuffer[pixelIndex(offset.x-1, offset.y+0)],\\n0.0f,\\npixelBuffer[pixelIndex(offset.x+1, offset.y+0)],\\npixelBuffer[pixelIndex(offset.x-1, offset.y+1)],\\npixelBuffer[pixelIndex(offset.x+0, offset.y+1)],\\npixelBuffer[pixelIndex(offset.x+1, offset.y+1)]\\n);\\nmat3 fx = matrixCompMult(derivX, window);\\nmat3 fy = matrixCompMult(derivY, window);\\nconst vec3 ones = vec3(1.0f);\\nreturn vec2(\\ndot(fx[0], ones) + dot(fx[1], ones) + dot(fx[2], ones),\\ndot(fy[0], ones) + dot(fy[1], ones) + dot(fy[2], ones)\\n);\\n}\\nvoid main()\\n{\\nvec4 pixel = threadPixel(encodedKeypoints);\\nivec2 thread = threadLocation();\\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\\nint r = windowRadius();\\ncolor = pixel;\\nif(address.offset != 1)\\nreturn;\\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\\nif(isBadKeypoint(keypoint))\\nreturn;\\nint idx = findKeypointIndex(address, descriptorSize, extraSize);\\nif(idx < firstKeypointIndex || idx > lastKeypointIndex)\\nreturn;\\ncolor = vec4(pixel.rgb, encodeKeypointFlags(keypoint.flags | KPF_DISCARD));\\nif(isKeypointAtInfinity(keypoint))\\nreturn;\\nreadWindow(keypoint.position, keypoint.lod);\\nvec2 derivatives = vec2(0.0f);\\nmat2 harris = mat2(0.0f, 0.0f, 0.0f, 0.0f);\\nfor(int j = 0; j < windowSize; j++) {\\nfor(int i = 0; i < windowSize; i++) {\\nderivatives = computeDerivatives(ivec2(i-r, j-r));\\nharris += mat2(\\nderivatives.x * derivatives.x, derivatives.x * derivatives.y,\\nderivatives.x * derivatives.y, derivatives.y * derivatives.y\\n) * DISCARD_SCALE;\\n}\\n}\\nfloat delta = harris[0][0] - harris[1][1];\\nfloat eigenvalue = 0.5f * ((harris[0][0] + harris[1][1]) - sqrt(delta * delta - 4.0f * harris[0][1] * harris[0][1]));\\nint windowArea = windowSize * windowSize;\\nfloat cornerness = eigenvalue / float(windowArea);\\nint flags = keypoint.flags;\\nflags |= int(cornerness < discardThreshold) * KPF_DISCARD;\\ncolor = vec4(pixel.rgb, encodeKeypointFlags(flags));\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform sampler2D nextPyramid;\\nuniform sampler2D prevPyramid;\\nuniform sampler2D prevKeypoints;\\nuniform int windowSize;\\nuniform int depth;\\nuniform int firstKeypointIndex, lastKeypointIndex;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int encoderLength;\\n#ifndef NUM_ITERATIONS\\n#define NUM_ITERATIONS 5\\n#endif\\n#ifndef MAX_WINDOW_SIZE\\n#error Must define MAX_WINDOW_SIZE\\n#endif\\n#ifndef DISCARD_MARGIN\\n#define DISCARD_MARGIN 20\\n#endif\\n#define NEXT_IMAGE 1\\n#define PREV_IMAGE 0\\nconst int MAX_WINDOW_SIZE_PLUS = MAX_WINDOW_SIZE + 2;\\nconst int MAX_WINDOW_SIZE_PLUS_SQUARED = MAX_WINDOW_SIZE_PLUS * MAX_WINDOW_SIZE_PLUS;\\nconst int DBL_MAX_WINDOW_SIZE_PLUS_SQUARED = 2 * MAX_WINDOW_SIZE_PLUS_SQUARED;\\nconst int MAX_WINDOW_RADIUS_PLUS = (MAX_WINDOW_SIZE_PLUS - 1) / 2;\\n#define windowRadius() ((windowSize - 1) / 2)\\nfloat pixelBuffer[DBL_MAX_WINDOW_SIZE_PLUS_SQUARED];\\n#define prevPixel(index) pixelBuffer[(index)]\\n#define nextPixel(index) pixelBuffer[MAX_WINDOW_SIZE_PLUS_SQUARED + (index)]\\n#define pixelIndex(i, j) (((j) + MAX_WINDOW_RADIUS_PLUS) * MAX_WINDOW_SIZE_PLUS + ((i) + MAX_WINDOW_RADIUS_PLUS))\\nvoid readWindow(vec2 center, float lod)\\n{\\nivec2 pyrBaseSize = textureSize(prevPyramid, 0);\\nfloat pot = exp2(lod);\\nint r = windowRadius();\\nivec2 offset; int idx;\\n#define readPixelsAt(ox, oy) offset = ivec2((ox), (oy)); idx = pixelIndex(offset.x, offset.y); nextPixel(idx) = pyrSubpixelAtExOffset(nextPyramid, center, lod, pot, offset, pyrBaseSize).g; prevPixel(idx) = pyrSubpixelAtExOffset(prevPyramid, center, lod, pot, offset, pyrBaseSize).g\\nfor(int j = 0; j < windowSize; j++) {\\nfor(int i = 0; i < windowSize; i++) {\\nreadPixelsAt(i-r, j-r);\\n}\\n}\\nint r1 = r+1;\\nfor(int k = 0; k < windowSize; k++) {\\nreadPixelsAt(-r1, k-r);\\nreadPixelsAt( r1, k-r);\\nreadPixelsAt(k-r,-r1);\\nreadPixelsAt(k-r, r1);\\n}\\nreadPixelsAt(-r1,-r1);\\nreadPixelsAt( r1,-r1);\\nreadPixelsAt(-r1, r1);\\nreadPixelsAt( r1, r1);\\n}\\nvec2 computeDerivatives(int imageCode, ivec2 offset)\\n{\\nconst mat3 derivX = mat3(\\n3, 0, -3,\\n10, 0, -10,\\n3, 0, -3\\n);\\nconst mat3 derivY = mat3(\\n3, 10, 3,\\n0, 0, 0,\\n-3, -10, -3\\n);\\nint indexOffset = imageCode * MAX_WINDOW_SIZE_PLUS_SQUARED;\\nmat3 window = mat3(\\npixelBuffer[indexOffset + pixelIndex(offset.x-1, offset.y-1)],\\npixelBuffer[indexOffset + pixelIndex(offset.x+0, offset.y-1)],\\npixelBuffer[indexOffset + pixelIndex(offset.x+1, offset.y-1)],\\npixelBuffer[indexOffset + pixelIndex(offset.x-1, offset.y+0)],\\n0.0f,\\npixelBuffer[indexOffset + pixelIndex(offset.x+1, offset.y+0)],\\npixelBuffer[indexOffset + pixelIndex(offset.x-1, offset.y+1)],\\npixelBuffer[indexOffset + pixelIndex(offset.x+0, offset.y+1)],\\npixelBuffer[indexOffset + pixelIndex(offset.x+1, offset.y+1)]\\n);\\nmat3 fx = matrixCompMult(derivX, window);\\nmat3 fy = matrixCompMult(derivY, window);\\nconst vec3 ones = vec3(1.0f);\\nreturn vec2(\\ndot(fx[0], ones) + dot(fx[1], ones) + dot(fx[2], ones),\\ndot(fy[0], ones) + dot(fy[1], ones) + dot(fy[2], ones)\\n);\\n}\\nfloat readBufferedPixel(int imageCode, ivec2 offset)\\n{\\nivec2 limit = ivec2(windowRadius());\\noffset = clamp(offset, -limit, limit);\\nint indexOffset = imageCode * MAX_WINDOW_SIZE_PLUS_SQUARED;\\nreturn pixelBuffer[indexOffset + pixelIndex(offset.x, offset.y)];\\n}\\nvoid main()\\n{\\nvec4 pixel = threadPixel(prevKeypoints);\\nivec2 thread = threadLocation();\\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\\nint r = windowRadius();\\ncolor = pixel;\\nif(address.offset > 0)\\nreturn;\\nKeypoint keypoint = decodeKeypoint(prevKeypoints, encoderLength, address);\\nif(isBadKeypoint(keypoint))\\nreturn;\\nint idx = findKeypointIndex(address, descriptorSize, extraSize);\\nif(idx < firstKeypointIndex || idx > lastKeypointIndex)\\nreturn;\\nvec2 pyrGuess = vec2(0.0f);\\nfor(int d = 0; d < depth; d++) {\\nfloat lod = float(depth - 1 - d);\\nreadWindow(keypoint.position, lod);\\nhighp mat2 invHarris = mat2(0.0f, 0.0f, 0.0f, 0.0f);\\nfor(int j = 0; j < windowSize; j++) {\\nfor(int i = 0; i < windowSize; i++) {\\nvec2 derivatives = computeDerivatives(PREV_IMAGE, ivec2(i-r, j-r));\\ninvHarris += mat2(\\nderivatives.y * derivatives.y, -derivatives.x * derivatives.y,\\n-derivatives.x * derivatives.y, derivatives.x * derivatives.x\\n);\\n}\\n}\\nconst float minDet = 0.00001f;\\nhighp float det = invHarris[0][0] * invHarris[1][1] - invHarris[0][1] * invHarris[1][0];\\nhighp vec2 localGuess = vec2(0.0f);\\nfor(int k = 0; k < NUM_ITERATIONS; k++) {\\nhighp vec2 spaceTime = vec2(0.0f);\\nfor(int _y = 0; _y < windowSize; _y++) {\\nfor(int _x = 0; _x < windowSize; _x++) {\\nint x = _x - r; int y = _y - r;\\nvec2 spatialDerivative = computeDerivatives(PREV_IMAGE, ivec2(x, y));\\nfloat timeDerivative = readBufferedPixel(NEXT_IMAGE,\\nivec2(round(vec2(x, y) + pyrGuess + localGuess))\\n) - readBufferedPixel(PREV_IMAGE, ivec2(x, y));\\nspaceTime += spatialDerivative * timeDerivative;\\n}\\n}\\nhighp vec2 localOpticalFlow = float(abs(det) >= minDet) * (invHarris * spaceTime / det);\\nlocalGuess += localOpticalFlow;\\n}\\npyrGuess = 2.0f * (pyrGuess + localGuess);\\n}\\nvec2 opticalFlow = pyrGuess;\\nvec2 nextPosition = keypoint.position + opticalFlow;\\nvec2 imageSize = vec2(textureSize(nextPyramid, 0));\\nfloat margin = float(DISCARD_MARGIN);\\nbool isKeypointWithinBoundaries = (\\nnextPosition.x >= margin &&\\nnextPosition.y >= margin &&\\nnextPosition.x <= imageSize.x - margin &&\\nnextPosition.y <= imageSize.y - margin\\n);\\ncolor = isKeypointWithinBoundaries ? encodeKeypointPosition(nextPosition) : encodeKeypointPositionAtInfinity();\\n}\"","module.exports = \"@include \\\"colors.glsl\\\"\\nuniform sampler2D dest, src;\\nuniform int destComponents;\\nuniform int srcComponentId;\\nvoid main()\\n{\\nvec4 destPixel = threadPixel(dest);\\nvec4 srcPixel = threadPixel(src);\\nbvec4 flags = bvec4(\\n(destComponents & PIXELCOMPONENT_RED) != 0,\\n(destComponents & PIXELCOMPONENT_GREEN) != 0,\\n(destComponents & PIXELCOMPONENT_BLUE) != 0,\\n(destComponents & PIXELCOMPONENT_ALPHA) != 0\\n);\\ncolor = mix(destPixel, vec4(srcPixel[srcComponentId]), flags);\\n}\"","module.exports = \"@include \\\"colors.glsl\\\"\\nuniform sampler2D image;\\nuniform int pixelComponents;\\nuniform float value;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nbvec4 flags = bvec4(\\n(pixelComponents & PIXELCOMPONENT_RED) != 0,\\n(pixelComponents & PIXELCOMPONENT_GREEN) != 0,\\n(pixelComponents & PIXELCOMPONENT_BLUE) != 0,\\n(pixelComponents & PIXELCOMPONENT_ALPHA) != 0\\n);\\ncolor = mix(pixel, vec4(value), flags);\\n}\"","module.exports = \"uniform float value;\\nvoid main()\\n{\\ncolor = vec4(value);\\n}\"","module.exports = \"uniform sampler2D image;\\nvoid main() {\\nivec2 pos = threadLocation();\\npos.y = int(texSize.y) - 1 - pos.y;\\ncolor = pixelAt(image, pos);\\n}\"","module.exports = \"uniform sampler2D image;\\nvoid main()\\n{\\ncolor = threadPixel(image);\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform int iterationNumber;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nivec2 last = outputSize() - ivec2(1);\\nint jump = (1 << iterationNumber);\\nint clusterLength = jump << 1;\\nint clusterMask = clusterLength - 1;\\nivec2 clusterPos = ivec2(thread >> (1 + iterationNumber)) << (1 + iterationNumber);\\nivec2 next1 = clusterPos + ((thread - clusterPos + ivec2(jump, 0)) & clusterMask);\\nivec2 next2 = clusterPos + ((thread - clusterPos + ivec2(0, jump)) & clusterMask);\\nivec2 next3 = clusterPos + ((thread - clusterPos + ivec2(jump, jump)) & clusterMask);\\nvec4 p0 = texelFetch(image, thread, 0);\\nvec4 p1 = texelFetch(image, min(next1, last), 0);\\nvec4 p2 = texelFetch(image, min(next2, last), 0);\\nvec4 p3 = texelFetch(image, min(next3, last), 0);\\nvec4 pmax = max(max(p0, p1), max(p2, p3));\\nvec4 pmin = min(min(p0, p1), min(p2, p3));\\ncolor = vec4(pmax.r, pmin.g, pmax.r - pmin.g, p0.a);\\n}\"","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-gpu.js\n * GPU routines for accelerated computer vision\n */\n\nimport { GLUtils } from './gl-utils.js';\nimport { SpeedyTexture } from './speedy-texture';\nimport { Utils } from '../utils/utils';\nimport { SpeedyProgramCenter } from './speedy-program-center';\nimport { MAX_TEXTURE_LENGTH } from '../utils/globals';\nimport { NotSupportedError, IllegalArgumentError } from '../utils/errors';\n\n// Constants\nconst UPLOAD_BUFFER_SIZE = 4; // how many textures we allocate for uploading data\n\n/**\n * GPU routines for\n * accelerated computer vision\n */\nexport class SpeedyGPU\n{\n    /**\n     * Class constructor\n     * @param {number} width Texture width\n     * @param {number} height Texture height\n     */\n    constructor(width, height)\n    {\n        // initialize properties\n        this._gl = null;\n        this._canvas = null;\n        this._width = 0;\n        this._height = 0;\n        this._programs = null;\n        this._inputTexture = null;\n        this._inputTextureIndex = 0;\n        this._omitGLContextWarning = false;\n\n        // does the browser support WebGL2?\n        checkWebGL2Availability();\n\n        // read & validate texture size\n        this._width = Math.max(1, width | 0);\n        this._height = Math.max(1, height | 0);\n        if(this._width > MAX_TEXTURE_LENGTH || this._height > MAX_TEXTURE_LENGTH) {\n            Utils.warning(`Maximum texture size exceeded (using ${this._width} x ${this._height}).`);\n            this._width = Math.min(this._width, MAX_TEXTURE_LENGTH);\n            this._height = Math.min(this._height, MAX_TEXTURE_LENGTH);\n        }\n\n        // setup WebGL\n        this._setupWebGL();\n    }\n\n    /**\n     * WebGL context\n     * Be careful when caching this, as the context may be lost!\n     * @returns {WebGL2RenderingContext}\n     */\n    get gl()\n    {\n        return this._gl;\n    }\n\n    /**\n     * Internal canvas\n     * @returns {HTMLCanvasElement|OffscreenCanvas}\n     */\n    get canvas()\n    {\n        return this._canvas;\n    }\n\n    /**\n     * Access point to all GPU programs\n     * @returns {SpeedyProgramCenter}\n     */\n    get programs()\n    {\n        return this._programs;\n    }\n\n    /**\n     * Upload data to the GPU\n     * We reuse textures by means of an internal buffer of size UPLOAD_BUFFER_SIZE\n     * @param {ImageBitmap|ImageData|ArrayBufferView|HTMLImageElement|HTMLVideoElement|HTMLCanvasElement} data \n     * @param {number} [width]\n     * @param {number} [height] \n     * @returns {SpeedyTexture}\n     */\n    upload(data, width = -1, height = -1)\n    {\n        const gl = this._gl;\n\n        // lost GL context?\n        if(gl.isContextLost()) {\n            Utils.warning(`Can't upload texture without a WebGL context`);\n            return (this._inputTexture = null);\n        }\n\n        // default values\n        if(width < 0)\n            width = gl.canvas.width;\n        if(height < 0)\n            height = gl.canvas.height;\n\n        // invalid dimensions?\n        if(width == 0 || height == 0)\n            throw new IllegalArgumentError(`Can't upload an image of area 0`);\n\n        // create (or recreate) internal textures\n        if(this._inputTexture === null) {\n            gl.canvas.width = Math.max(gl.canvas.width, width);\n            gl.canvas.height = Math.max(gl.canvas.height, height);\n            this._inputTexture = Array(UPLOAD_BUFFER_SIZE).fill(null).map(_ =>\n                new SpeedyTexture(gl, gl.canvas.width, gl.canvas.height));\n        }\n        else if(width > gl.canvas.width || height > gl.canvas.height) {\n            Utils.log(`Resizing input texture to ${width} x ${height}`);\n            this._inputTexture.forEach(inputTexture =>\n                inputTexture.release());\n            this._inputTexture = null;\n            return this.upload(data, width, height);\n        }\n\n        // bugfix: if the media is a video, we can't really\n        // upload it to the GPU unless it's ready\n        if(data.constructor.name == 'HTMLVideoElement') {\n            if(data.readyState < 2) {\n                // this may happen when the video loops (Firefox)\n                // return the previously uploaded texture\n                if(this._inputTexture[this._inputTextureIndex] != null)\n                    return this._inputTexture[this._inputTextureIndex];\n                else\n                    Utils.warning(`Trying to process a video that isn't ready yet`);\n            }\n        }\n\n        // use round-robin to mitigate WebGL's implicit synchronization\n        // and maybe minimize texture upload times\n        this._inputTextureIndex = (1 + this._inputTextureIndex) % UPLOAD_BUFFER_SIZE;\n\n        // done! note: the input texture is upside-down, i.e.,\n        // flipped on the y-axis. We need to unflip it on the\n        // output, so that (0,0) becomes the top-left corner\n        const texture = this._inputTexture[this._inputTextureIndex];\n        texture.upload(data);\n        return texture;\n    }\n\n    /**\n     * Clear the internal canvas\n     */\n    /*clearCanvas()\n    {\n        const gl = this._gl;\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n        gl.clearColor(0, 0, 0, 1);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n    }*/\n\n    /**\n     * Lose & restore the WebGL context\n     * @param {number} [timeToRestore] in seconds\n     * @return {Promise} resolves as soon as the context is restored,\n     *                   or as soon as it is lost if timeToRestore is Infinity\n     */\n    loseAndRestoreWebGLContext(timeToRestore = 1.0)\n    {\n        const gl = this._gl;\n\n        if(gl.isContextLost())\n            return Promise.reject('Context already lost');\n\n        const ext = gl.getExtension('WEBGL_lose_context');\n\n        if(ext) {\n            ext.loseContext();\n            return new Promise(resolve => {\n                if(isFinite(timeToRestore)) {\n                    setTimeout(() => {\n                        ext.restoreContext();\n                        setTimeout(() => resolve(), 0); // next frame\n                    }, Math.max(timeToRestore, 0) * 1000.0);\n                }\n                else\n                    resolve(); // won't restore\n            });\n        }\n        else\n            throw new NotSupportedError('WEBGL_lose_context is unavailable');\n    }\n\n    /**\n     * Lose the WebGL context.\n     * This is a way to manually free resources.\n     */\n    loseWebGLContext()\n    {\n        this._omitGLContextWarning = true;\n        return this.loseAndRestoreWebGLContext(Infinity);\n    }\n\n    // setup WebGL\n    _setupWebGL()\n    {\n        const width = this._width;\n        const height = this._height;\n\n        // initializing\n        this._programs = null;\n        this._inputTexture = null;\n        this._inputTextureIndex = 0;\n        this._omitGLContextWarning = false;\n        if(this._canvas !== undefined)\n            delete this._canvas;\n\n        // create canvas\n        this._canvas = createCanvas(width, height);\n        this._canvas.addEventListener('webglcontextlost', ev => {\n            if(!this._omitGLContextWarning)\n                Utils.warning('Lost WebGL context');\n            ev.preventDefault();\n        }, false);\n        this._canvas.addEventListener('webglcontextrestored', ev => {\n            if(!this._omitGLContextWarning)\n                Utils.warning('Restoring WebGL context...');\n            this._setupWebGL();\n        }, false);\n\n        // create WebGL context\n        this._gl = createWebGLContext(this._canvas);\n\n        // spawn program groups\n        this._programs = new SpeedyProgramCenter(this, width, height);\n    }\n}\n\n// Create a canvas\nfunction createCanvas(width, height)\n{\n    const inWorker = (typeof importScripts === 'function') && (typeof WorkerGlobalScope !== 'undefined');\n\n    if(inWorker) {\n        if(typeof OffscreenCanvas !== 'function')\n            throw new NotSupportedError('OffscreenCanvas is not available in your browser. Please upgrade.');\n\n        return new OffscreenCanvas(width, height);\n    }\n\n    return Utils.createCanvas(width, height);\n}\n\n// Checks if the browser supports WebGL2\nfunction checkWebGL2Availability()\n{\n    if(typeof WebGL2RenderingContext === 'undefined')\n        throw new NotSupportedError('WebGL2 is required by this application, but it\\'s not available in your browser. Please use a different browser.');\n}\n\n// Create a WebGL2 context\nfunction createWebGLContext(canvas)\n{\n    const gl = canvas.getContext('webgl2', {\n        premultipliedAlpha: false,\n        preserveDrawingBuffer: false,\n        //preferLowPowerToHighPerformance: false, // TODO user option?\n        alpha: true,\n        antialias: false,\n        depth: false,\n        stencil: false,\n    });\n\n    if(!gl)\n        throw new NotSupportedError('Can\\'t create WebGL2 context. Try in a different browser.');\n\n    return gl;\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-program-center.js\n * An access point to all programs that run on the GPU\n */\n\nimport { GPUUtils } from './programs/utils';\nimport { GPUColors } from './programs/colors';\nimport { GPUFilters } from './programs/filters';\nimport { GPUKeypoints } from './programs/keypoints';\nimport { GPUEncoders } from './programs/encoders';\nimport { GPUPyramids } from './programs/pyramids';\nimport { GPUEnhancements } from './programs/enhancements';\nimport { GPUTrackers } from './programs/trackers';\nimport { IllegalArgumentError } from '../utils/errors';\nimport { PYRAMID_MAX_LEVELS } from '../utils/globals';\n\n/**\n * An access point to all programs that run on the CPU\n * All program groups can be accessed via this class\n */\nexport class SpeedyProgramCenter\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu \n     * @param {number} width default width for output textures\n     * @param {number} height default height for output textures\n     */\n    constructor(gpu, width, height)\n    {\n        // properties\n        this._gpu = gpu;\n        this._width = width;\n        this._height = height;\n\n        // program groups\n        // (lazy instantiation)\n        this._utils = null;\n        this._colors = null;\n        this._filters = null;\n        this._keypoints = null;\n        this._encoders = null;\n        this._descriptors = null;\n        this._enhancements = null;\n        this._trackers = null;\n        this._pyramids = (new Array(PYRAMID_MAX_LEVELS)).fill(null);\n    }\n\n    /**\n     * Default width of the output texture of the programs\n     * @returns {number}\n     */\n    get width()\n    {\n        return this._width;\n    }\n\n    /**\n     * Default height of the output texture of the programs\n     * @returns {number}\n     */\n    get height()\n    {\n        return this._height;\n    }\n\n    /**\n     * Utility programs\n     * @returns {GPUUtils}\n     */\n    get utils()\n    {\n        return this._utils || (this._utils = new GPUUtils(this._gpu, this._width, this._height));\n    }\n\n    /**\n     * Programs related to color conversions\n     * @returns {GPUColors}\n     */\n    get colors()\n    {\n        return this._colors || (this._colors = new GPUColors(this._gpu, this._width, this._height));\n    }\n\n    /**\n     * Image filters & convolutions\n     * @returns {GPUFilters}\n     */\n    get filters()\n    {\n        return this._filters || (this._filters = new GPUFilters(this._gpu, this._width, this._height));\n    }\n\n    /**\n     * Keypoint detection & description\n     * @returns {GPUKeypoints}\n     */\n    get keypoints()\n    {\n        return this._keypoints || (this._keypoints = new GPUKeypoints(this._gpu, this._width, this._height));\n    }\n\n    /**\n     * Keypoint encoders\n     * @returns {GPUEncoders}\n     */\n    get encoders()\n    {\n        return this._encoders || (this._encoders = new GPUEncoders(this._gpu, this._width, this._height));\n    }\n\n    /**\n     * Feature trackers\n     * @returns {GPUTrackers}\n     */\n    get trackers()\n    {\n        return this._trackers || (this._trackers = new GPUTrackers(this._gpu, this._width, this._height));\n    }\n\n    /**\n     * Image enhancement algorithms\n     * @returns {GPUEnhancements}\n     */\n    get enhancements()\n    {\n        return this._enhancements || (this._enhancements = new GPUEnhancements(this._gpu, this._width, this._height));\n    }\n\n    /**\n     * Image pyramids & scale-space\n     * @param {number} [level] level-of-detail: 0, 1, 2, ... (PYRAMID_MAX_LEVELS - 1)\n     * @returns {GPUPyramids}\n     */\n    pyramids(level = 0)\n    {\n        const lod = level | 0;\n        const pot = 1 << lod;\n\n        if(lod < 0 || lod >= PYRAMID_MAX_LEVELS)\n            throw new IllegalArgumentError(`Invalid pyramid level: ${lod} (outside of range [0,${PYRAMID_MAX_LEVELS-1}])`);\n\n        // use max(1, floor(size / 2^lod)), in accordance to the OpenGL ES 3.0 spec sec 3.8.10.4 (Mipmapping)\n        return this._pyramids[lod] || (this._pyramids[lod] = new GPUPyramids(this._gpu,\n            Math.max(1, Math.floor(this._width / pot)),\n            Math.max(1, Math.floor(this._height / pot))\n        ));\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-program-group.js\n * An abstract group of programs that run on the GPU\n */\n\nimport { SpeedyProgram } from './speedy-program';\n\n/**\n * SpeedyProgramGroup\n * A semantically correlated group\n * of programs that run on the GPU\n */\n\nexport /* abstract */ class SpeedyProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} width Texture width (depends on the pyramid layer)\n     * @param {number} height Texture height (depends on the pyramid layer)\n     */\n    /* protected */ constructor(gpu, width, height)\n    {\n        this._gpu = gpu;\n        this._width = width;\n        this._height = height;\n    }\n\n    /**\n     * Declare a program\n     * @param {string} name Program name\n     * @param {ShaderDeclaration} shaderdecl Shader declaration\n     * @param {object} settings Program settings\n     * @returns {SpeedyProgramGroup} This object\n     */\n    /* protected */ declare(name, shaderdecl, settings = { })\n    {\n        // lazy instantiation of kernels\n        Object.defineProperty(this, name, {\n            get: (() => {\n                const key = '__k_' + name;\n                return (function() {\n                    return this[key] || (this[key] = this._createProgram(shaderdecl, settings));\n                }).bind(this);\n            })()\n        });\n\n        return this;\n    }\n\n    /**\n     * Multi-pass composition\n     * @param {string} name Program name\n     * @param {string} fn Other programs\n     * @returns {SpeedyProgramGroup} This object\n     */\n    /* protected */ compose(name, ...fn)\n    {\n        // function composition: functions are called in the order they are specified\n        // e.g., compose('h', 'f', 'g') means h(x) = g(f(x))\n        Object.defineProperty(this, name, {\n            get: (() => {\n                const key = '__c_' + name;\n                return (function() {\n                    return this[key] || (this[key] = (fn.length == 2) ? (() => {\n                        fn = fn.map(fi => this[fi]);\n                        return function compose(image, ...args) {\n                            return (fn[1])((fn[0])(image, ...args), ...args);\n                        };\n                    })() : ((fn.length == 3) ? (() => {\n                        fn = fn.map(fi => this[fi]);\n                        return function compose(image, ...args) {\n                            return (fn[2])((fn[1])((fn[0])(image, ...args), ...args), ...args);\n                        };\n                    })() : ((fn.length == 4) ? (() => {\n                        fn = fn.map(fi => this[fi]);\n                        return function compose(image, ...args) {\n                            return (fn[3])((fn[2])((fn[1])((fn[0])(image, ...args), ...args), ...args), ...args);\n                        };\n                    })() : (() => {\n                        fn = fn.map(fi => this[fi]);\n                        return function compose(image, ...args) {\n                            return fn.reduce((img, fi) => fi(img, ...args), image);\n                        };\n                    })())));\n                }).bind(this);\n            })()\n        });\n\n        return this;\n    }\n\n    /**\n     * Neat helpers to be used\n     * when defining programs\n     */\n    get program()\n    {\n        return this._helpers || (this.helpers = {\n\n            // Set texture input/output size\n            // Dimensions are converted to integers\n            hasTextureSize(width, height) {\n                return {\n                    output: [ Math.max(1, width | 0), Math.max(1, height | 0) ]\n                };\n            },\n\n            // Render to canvas\n            // Use it when we're supposed to see the texture\n            displaysGraphics() {\n                return {\n                    renderToTexture: false\n                };\n            },\n\n            // Calling the program will return a new\n            // instance of the output texture every time\n            // The returned texture must be released manually\n            doesNotRecycleTextures() {\n                return {\n                    recycleTexture: false\n                };\n            },\n\n            // Pingpong Rendering: the output texture of a\n            // program cannot be used as an input to itself.\n            // This is a convenient helper in these situations\n            usesPingpongRendering() {\n                return {\n                    pingpong: true\n                };\n            },\n\n        });\n    }\n\n    /* private */ _createProgram(shaderdecl, settings = { })\n    {\n        return new SpeedyProgram(this._gpu.gl, shaderdecl, {\n            // default settings\n            output: [ this._width, this._height ],\n            ...settings\n        });\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-program.js\n * SpeedyProgram class\n */\n\nimport { GLUtils } from './gl-utils.js';\nimport { SpeedyTexture } from './speedy-texture';\nimport { SpeedyPromise } from '../utils/speedy-promise';\nimport { Utils } from '../utils/utils';\nimport { NotSupportedError, IllegalArgumentError, IllegalOperationError } from '../utils/errors';\n\nconst ATTRIBUTE_LOCATIONS = Object.freeze({\n    position: 0,\n    texCoord: 1,\n});\n\nconst UNIFORM_SETTERS = Object.freeze({\n    'sampler2D':'uniform1i',\n    'float':    'uniform1f',\n    'int':      'uniform1i',\n    'uint':     'uniform1ui',\n    'bool':     'uniform1i',\n    'vec2':     'uniform2f',\n    'vec3':     'uniform3f',\n    'vec4':     'uniform4f',\n    'ivec2':    'uniform2i',\n    'ivec3':    'uniform3i',\n    'ivec4':    'uniform4i',\n    'uvec2':    'uniform2ui',\n    'uvec3':    'uniform3ui',\n    'uvec4':    'uniform4ui',\n    'bvec2':    'uniform2i',\n    'bvec3':    'uniform3i',\n    'bvec4':    'uniform4i',\n});\n\n// number of pixel buffer objects\n// used to get a performance boost in gl.readPixels()\n// (1 seems to perform better on mobile, 2 on the PC?)\nconst PBO_COUNT = 1;\n\n// cache program geometry\nconst geometryCache = new WeakMap();\n\n\n/**\n * A SpeedyProgram is a Function that\n * runs GPU-accelerated GLSL code\n */\nexport class SpeedyProgram extends Function\n{\n    /**\n     * Creates a new SpeedyProgram\n     * @param {WebGL2RenderingContext} gl WebGL context\n     * @param {ShaderDeclaration} shaderdecl Shader declaration\n     * @param {object} [options] user options\n     */\n    constructor(gl, shaderdecl, options = { })\n    {\n        super('...args', 'return this._self._call(...args)');\n        this._self = this.bind(this);\n        this._self._init(gl, shaderdecl, options);\n        return this._self;\n    }\n\n    /**\n     * Initialize the SpeedyProgram\n     * @param {WebGL2RenderingContext} gl WebGL context\n     * @param {ShaderDeclaration} shaderdecl Shader declaration\n     * @param {object} options user options\n     */\n    _init(gl, shaderdecl, options)\n    {\n        /** @type {WebGL2RenderingContext} */\n        this._gl = gl;\n\n        /** @type {WebGLProgram} */\n        this._program = GLUtils.createProgram(gl, shaderdecl.vertexSource, shaderdecl.fragmentSource);\n\n        /** @type {ProgramGeometry} this is a quad */\n        this._geometry = this._createGeometry(gl);\n\n        /** @type {string[]} names of the arguments of the SpeedyProgram */\n        this._argnames = shaderdecl.arguments;\n\n        /** @type {boolean[]} tells whether the i-th argument of the SpeedyProgram is an array or not */\n        this._argIsArray = (new Array(this._argnames.length)).fill(false);\n\n        /** @type {object} user options */\n        this._options = Object.freeze({\n            output: [ gl.drawingBufferWidth, gl.drawingBufferHeight ], // size of the output texture\n            renderToTexture: true, // render results to a texture?\n            recycleTexture: true, // recycle output texture? If false, you must manually destroy the output texture\n            pingpong: false, // alternate output texture between calls\n            ...options // user-defined options\n        });\n\n        /** @type {number} width of the output texture */\n        this._width = Math.max(1, this._options.output[0] | 0);\n\n        /** @type {number} height of the output texture */\n        this._height = Math.max(1, this._options.output[1] | 0);\n\n        /** @type {boolean} flag indicating the need to update the texSize uniform */\n        this._dirtySize = true;\n\n        /** @type {Map<string,ProgramUniform>} uniform variables */\n        this._uniform = new Map();\n\n        /** @type {UBOHelper} UBO helper */\n        this._ubo = null;\n\n        /** @type {SpeedyTexture[]} output texture(s) */\n        this._texture = !this._options.renderToTexture ? [] :\n            (new Array(this._options.pingpong ? 2 : 1)).fill(null);\n\n        /** @type {WebGLFramebuffer[]} framebuffer object(s) */\n        this._fbo = !this._options.renderToTexture ? [] :\n            (new Array(this._options.pingpong ? 2 : 1)).fill(null);\n\n        /** @type {number} used for pingpong rendering */\n        this._textureIndex = 0;\n\n        /** @type {Uint8Array[]} pixel buffers for data transfers */\n        this._pixelBuffer = (new Array(PBO_COUNT)).fill(null);\n\n        /** @type {number[]} [width, height] of the pixel buffers */\n        this._pixelBufferSize = [0, 0];\n\n        /** @type {number[]} for async data transfers */\n        this._pboConsumerQueue = (new Array(PBO_COUNT)).fill(0).map((_, i) => i);\n\n        /** @type {number[]} for async data transfers */\n        this._pboProducerQueue = [];\n\n\n\n        // validate options\n        if(this._options.pingpong && !this._options.renderToTexture)\n            throw new IllegalOperationError(`Pingpong rendering can only be used when rendering to textures`);\n\n        // not a valid context?\n        if(gl.isContextLost())\n            throw new IllegalOperationError(`Can't initialize SpeedyProgram: lost context`);\n\n        // need to resize the canvas?\n        const canvas = gl.canvas;\n        if(this._width > canvas.width)\n            canvas.width = this._width;\n        if(this._height > canvas.height)\n            canvas.height = this._height;\n\n        // setup attributes of the vertex shader\n        gl.bindAttribLocation(this._program, ATTRIBUTE_LOCATIONS.position, shaderdecl.attributes.position);\n        gl.bindAttribLocation(this._program, ATTRIBUTE_LOCATIONS.texCoord, shaderdecl.attributes.texCoord);\n\n        // create framebuffer(s)\n        for(let i = 0; i < this._texture.length; i++) {\n            this._texture[i] = new SpeedyTexture(gl, this._width, this._height);\n            this._fbo[i] = GLUtils.createFramebuffer(gl, this._texture[i].glTexture);\n        }\n\n        // autodetect uniforms\n        gl.useProgram(this._program);\n        for(const name of shaderdecl.uniforms) {\n            const type = shaderdecl.uniformType(name);\n            const location = gl.getUniformLocation(this._program, name);\n            this._uniform.set(name, new ProgramUniform(type, location));\n        }\n\n        // match arguments & uniforms\n        for(let j = 0; j < this._argnames.length; j++) {\n            const argname = this._argnames[j];\n            if(!this._uniform.has(argname)) {\n                this._argIsArray[j] = this._uniform.has(argname + '[0]');\n                if(!this._argIsArray[j])\n                    throw new IllegalOperationError(`Expected uniform \"${argname}\", as declared in the argument list`);\n            }\n        }\n    }\n\n    /**\n     * Run the SpeedyProgram\n     * @param  {...number} args\n     * @returns {SpeedyTexture}\n     */\n    _call(...args)\n    {\n        const gl = this._gl;\n        const options = this._options;\n        const argnames = this._argnames;\n\n        // matching arguments?\n        if(args.length != argnames.length)\n            throw new IllegalArgumentError(`Can't run shader: incorrect number of arguments`);\n\n        // skip things\n        if(gl.isContextLost())\n            return this._texture[this._textureIndex];\n\n        // use program\n        gl.useProgram(this._program);\n\n        // we need to update the texSize uniform (e.g., if the program was resized)\n        if(this._dirtySize) {\n            const texSize = this._uniform.get('texSize');\n            gl.uniform2f(texSize.location, this._width, this._height);\n            this._dirtySize = false;\n        }\n\n        // set uniforms[i] to args[i]\n        for(let i = 0, texNo = 0; i < args.length; i++) {\n            const argname = argnames[i];\n\n            if(!this._argIsArray[i]) {\n                // uniform variable matches argument name\n                const uniform = this._uniform.get(argname);\n                texNo = this._setUniform(uniform, args[i], texNo);\n            }\n            else {\n                // uniform array matches argument name\n                const array = args[i];\n                if(this._uniform.has(`${argname}[${array.length}]`))\n                    throw new IllegalArgumentError(`Can't run shader: too few elements in the \"${argname}\" array`);\n                for(let j = 0, uniform = undefined; (uniform = this._uniform.get(`${argname}[${j}]`)) !== undefined; j++)\n                    texNo = this._setUniform(uniform, array[j], texNo);\n            }\n        }\n\n        // set Uniform Buffer Objects (if any)\n        if(this._ubo !== null)\n            this._ubo.update();\n\n        // draw call\n        const fbo = options.renderToTexture ? this._fbo[this._textureIndex] : null;\n        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n        gl.viewport(0, 0, this._width, this._height);\n        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4); // mode, offset, count\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n        // are we rendering to a texture?\n        if(fbo !== null) {\n            const texture = this._texture[this._textureIndex];\n\n            // we've just changed the contents of the internal texture\n            texture.discardPyramid(); // discard its pyramid\n\n            // should we return the internal texture?\n            let outputTexture = texture;\n            if(!options.recycleTexture) {\n                // no; we must clone the intenal texture\n                outputTexture = new SpeedyTexture(gl, this._width, this._height);\n                GLUtils.copyToTexture(gl, fbo, outputTexture.glTexture, 0, 0, this._width, this._height);\n            }\n\n            // ping-pong rendering\n            this._pingpong();\n\n            // done!\n            return outputTexture;\n        }\n\n        // we're not rendering to a texture\n        return null;\n    }\n\n    /**\n     * Resize the output texture\n     * @param {number} width \n     * @param {number} height \n     */\n    resize(width, height)\n    {\n        const gl = this._gl;\n        const oldWidth = this._width;\n        const oldHeight = this._height;\n\n        // lost context?\n        if(gl.isContextLost())\n            return;\n\n        // get size\n        width = Math.max(1, width | 0);\n        height = Math.max(1, height | 0);\n\n        // no need to resize?\n        if(width === this._width && height === this._height)\n            return;\n\n        // update size\n        this._width = width;\n        this._height = height;\n        this._dirtySize = true;\n\n        // reallocate buffers for reading pixels\n        this._reallocatePixelBuffers(width, height);\n\n        // resize the internal texture(s)\n        const n = this._texture.length;\n        const zeros = n > 0 ? new Uint8Array(width * height * 4) : null;\n        for(let i = 0; i < n; i++) {\n            // create new texture\n            const newTexture = new SpeedyTexture(gl, width, height);\n\n            // initialize the new texture with zeros to avoid a\n            // warning when calling copyTexSubImage2D() on Firefox\n            newTexture.upload(zeros); // may not be very efficient?\n\n            // copy old content\n            GLUtils.copyToTexture(gl, this._fbo[i], newTexture.glTexture, 0, 0, Math.min(width, oldWidth), Math.min(height, oldHeight));\n\n            // attach the new texture to the existing framebuffer\n            gl.bindFramebuffer(gl.FRAMEBUFFER, this._fbo[i]);\n            gl.framebufferTexture2D(gl.FRAMEBUFFER,         // target\n                                    gl.COLOR_ATTACHMENT0,   // color buffer\n                                    gl.TEXTURE_2D,          // tex target\n                                    newTexture.glTexture,   // texture\n                                    0);                     // mipmap level\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n            // release old texture & replace it\n            this._texture[i].release();\n            this._texture[i] = newTexture;\n        }\n\n        //console.log(`Resized SpeedyProgram to ${width} x ${height}`);\n    }\n\n    /**\n     * Clear the internal textures to a color\n     * @param {number} [r] in [0,1]\n     * @param {number} [g] in [0,1]\n     * @param {number} [b] in [0,1]\n     * @param {number} [a] in [0,1]\n     * @returns {SpeedyTexture}\n     */\n    clear(r = 0, g = 0, b = 0, a = 0)\n    {\n        const gl = this._gl;\n        const texture = this._texture[this._textureIndex];\n\n        // skip things\n        if(gl.isContextLost())\n            return texture;\n\n        // clear internal textures\n        for(let i = 0; i < this._fbo.length; i++) {\n            gl.bindFramebuffer(gl.FRAMEBUFFER, this._fbo[i]);\n            gl.viewport(0, 0, this._width, this._height);\n            gl.clearColor(r, g, b, a);\n            gl.clear(gl.COLOR_BUFFER_BIT);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        }\n\n        // ping-pong rendering\n        this._pingpong();\n\n        // done!\n        return texture;\n    }\n\n    /**\n     * Read pixels from the output texture synchronously.\n     * You may optionally specify a (x,y,width,height) sub-rectangle.\n     * @param {number} [x]\n     * @param {number} [y] \n     * @param {number} [width]\n     * @param {number} [height]\n     * @returns {Uint8Array} pixels in the RGBA format\n     */\n    readPixelsSync(x = 0, y = 0, width = this._width, height = this._height)\n    {\n        const gl = this._gl;\n\n        // can't read pixels if we're not rendering to a texture (i.e., no framebuffer)\n        if(!this._options.renderToTexture)\n            throw new IllegalOperationError(`Can't read pixels from a SpeedyProgram that doesn't render to an internal texture`);\n\n        // lost context?\n        if(gl.isContextLost())\n            return this._pixelBuffer[0];\n\n        // clamp values\n        width = Math.max(0, Math.min(width, this._width));\n        height = Math.max(0, Math.min(height, this._height));\n        x = Math.max(0, Math.min(x, width - 1));\n        y = Math.max(0, Math.min(y, height - 1));\n\n        // allocate the pixel buffers\n        if(this._pixelBuffer[0] == null)\n            this._reallocatePixelBuffers(this._width, this._height);\n\n        // read pixels\n        gl.bindFramebuffer(gl.FRAMEBUFFER, this._fbo[this._textureIndex]);\n        gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, this._pixelBuffer[0]);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n        // done!\n        return this._pixelBuffer[0];\n    }\n\n    /**\n     * Read pixels from the output texture asynchronously with PBOs.\n     * You may optionally specify a (x,y,width,height) sub-rectangle.\n     * @param {boolean} [useBufferedDownloads] optimize downloads?\n     * @param {number} [x]\n     * @param {number} [y] \n     * @param {number} [width]\n     * @param {number} [height]\n     * @returns {SpeedyPromise<Uint8Array>} resolves to an array of pixels in the RGBA format\n     */\n    readPixelsAsync(useBufferedDownloads = true, x = 0, y = 0, width = this._width, height = this._height)\n    {\n        const gl = this._gl;\n\n        // can't read pixels if we're not rendering to a texture (i.e., no framebuffer)\n        if(!this._options.renderToTexture)\n            throw new IllegalOperationError(`Can't read pixels from a SpeedyProgram that doesn't render to an internal texture`);\n\n        // lost context?\n        if(gl.isContextLost())\n            return SpeedyPromise.resolve(this._pixelBuffer[0]);\n\n        // clamp values\n        width = Math.max(0, Math.min(width, this._width));\n        height = Math.max(0, Math.min(height, this._height));\n        x = Math.max(0, Math.min(x, width - 1));\n        y = Math.max(0, Math.min(y, height - 1));\n\n        // allocate the pixel buffers\n        if(this._pixelBuffer[0] == null)\n            this._reallocatePixelBuffers(this._width, this._height);\n\n        // do not optimize?\n        if(!useBufferedDownloads) {\n            return GLUtils.readPixelsViaPBO(gl, this._pixelBuffer[0], x, y, width, height, this._fbo[this._textureIndex]).then(() => {\n                return this._pixelBuffer[0];\n            });\n        }\n\n        // GPU needs to produce data\n        if(this._pboProducerQueue.length > 0) {\n            const nextPBO = this._pboProducerQueue.shift();\n            GLUtils.readPixelsViaPBO(gl, this._pixelBuffer[nextPBO], x, y, width, height, this._fbo[this._textureIndex]).then(() => {\n                this._pboConsumerQueue.push(nextPBO);\n            });\n        }\n        else this._waitForQueueNotEmpty(this._pboProducerQueue).then(() => {\n            const nextPBO = this._pboProducerQueue.shift();\n            GLUtils.readPixelsViaPBO(gl, this._pixelBuffer[nextPBO], x, y, width, height, this._fbo[this._textureIndex]).then(() => {\n                this._pboConsumerQueue.push(nextPBO);\n            });\n        }).turbocharge();\n\n        // CPU needs to consume data\n        if(this._pboConsumerQueue.length > 0) {\n            const readyPBO = this._pboConsumerQueue.shift();\n            return new SpeedyPromise(resolve => {\n                resolve(this._pixelBuffer[readyPBO]);\n                this._pboProducerQueue.push(readyPBO); // enqueue AFTER resolve()\n            });\n        }\n        else return new SpeedyPromise(resolve => {\n            this._waitForQueueNotEmpty(this._pboConsumerQueue).then(() => {\n                const readyPBO = this._pboConsumerQueue.shift();\n                resolve(this._pixelBuffer[readyPBO]);\n                this._pboProducerQueue.push(readyPBO); // enqueue AFTER resolve()\n            }).turbocharge();\n        });\n    }\n\n    /**\n     * Set data using a Uniform Buffer Object\n     * @param {string} blockName uniform block name\n     * @param {ArrayBufferView} data\n     */\n    setUBO(blockName, data)\n    {\n        if(this._ubo === null)\n            this._ubo = new UBOHelper(this._gl, this._program);\n\n        this._ubo.set(blockName, data);\n    }\n\n    /**\n     * Copy the output of this program to a texture\n     * @param {SpeedyTexture} texture target texture\n     * @param {number} [lod] level-of-detail of the target texture\n     */\n    exportTo(texture, lod = 0)\n    {\n        const gl = this._gl;\n        const fbo = this._fbo[this._textureIndex];\n\n        // compute texture size as max(1, floor(size / 2^lod)),\n        // in accordance to the OpenGL ES 3.0 spec sec 3.8.10.4\n        // (Mipmapping)\n        const pot = 1 << (lod |= 0);\n        const expectedWidth = Math.max(1, Math.floor(texture.width / pot));\n        const expectedHeight = Math.max(1, Math.floor(texture.height / pot));\n\n        // validate\n        Utils.assert(this._width === expectedWidth && this._height === expectedHeight);\n        if(this._options.pingpong)\n            throw new NotSupportedError(`Can't copy the output of a pingpong-enabled SpeedyProgram`);\n\n        // copy to texture\n        GLUtils.copyToTexture(gl, fbo, texture.glTexture, 0, 0, this._width, this._height, lod);\n    }\n\n    /**\n     * Width of the internal texture, in pixels\n     * @returns {number}\n     */\n    get width()\n    {\n        return this._width;\n    }\n\n    /**\n     * Height of the internal texture, in pixels\n     * @returns {number}\n     */\n    get height()\n    {\n        return this._height;\n    }\n\n    /**\n     * Helper method for pingpong rendering: alternates\n     * the texture index from 0 to 1 and vice-versa\n     */\n    _pingpong()\n    {\n        if(this._options.pingpong)\n            this._textureIndex = 1 - this._textureIndex;\n    }\n\n    /**\n     * Set the value of a uniform variable\n     * @param {ProgramUniform} uniform\n     * @param {SpeedyTexture|number|number[]|boolean|boolean[]} value\n     * @param {number} texNo current texture index\n     * @returns {number} new texture index\n     */\n    _setUniform(uniform, value, texNo)\n    {\n        const gl = this._gl;\n\n        if(uniform.type == 'sampler2D') {\n            // set texture\n            if(texNo > gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS)\n                throw new NotSupportedError(`Can't bind ${texNo} textures to a program: max is ${gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS}`);\n            else if(value === this._texture[this._textureIndex])\n                throw new NotSupportedError(`Can't run shader: cannot use its output texture as an input to itself`);\n            else if(value == null)\n                throw new IllegalArgumentError(`Can't run shader: cannot use null as an input texture`);\n\n            gl.activeTexture(gl.TEXTURE0 + texNo);\n            gl.bindTexture(gl.TEXTURE_2D, value.glTexture);\n            gl.uniform1i(uniform.location, texNo);\n            texNo++;\n        }\n        else {\n            // set value\n            if(typeof value == 'number' || typeof value == 'boolean')\n                (gl[uniform.setter])(uniform.location, value);\n            else if(Array.isArray(value) && value.length === uniform.length)\n                (gl[uniform.setter])(uniform.location, ...value);\n            else\n                throw new IllegalArgumentError(`Can't run shader: unrecognized argument \"${value}\"`);\n        }\n\n        return texNo;\n    }\n\n    /**\n     * Create a quad to be passed to the vertex shader\n     * (this is crafted for image processing)\n     * @param {WebGL2RenderingContext} gl\n     * @returns {ProgramGeometry}\n     */\n    _createGeometry(gl)\n    {\n        // got cached values for this WebGL context?\n        if(geometryCache.has(gl))\n            return geometryCache.get(gl);\n\n        // configure the attributes of the vertex shader\n        const vao = gl.createVertexArray(); // vertex array object\n        const vbo = [ gl.createBuffer(), gl.createBuffer() ]; // vertex buffer objects\n        gl.bindVertexArray(vao);\n\n        // set the a_position attribute\n        // using the current vbo\n        gl.bindBuffer(gl.ARRAY_BUFFER, vbo[0]);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n            // clip coordinates\n            -1, -1,\n            1, -1,\n            -1, 1,\n            1, 1,\n        ]), gl.STATIC_DRAW);\n        gl.enableVertexAttribArray(ATTRIBUTE_LOCATIONS.position);\n        gl.vertexAttribPointer(ATTRIBUTE_LOCATIONS.position, // attribute location\n                               2,          // 2 components per vertex (x,y)\n                               gl.FLOAT,   // type\n                               false,      // don't normalize\n                               0,          // default stride (tightly packed)\n                               0);         // offset\n\n        // set the a_texCoord attribute\n        // using the current vbo\n        gl.bindBuffer(gl.ARRAY_BUFFER, vbo[1]);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n            // texture coordinates\n            0, 0,\n            1, 0,\n            0, 1,\n            1, 1,\n        ]), gl.STATIC_DRAW);\n        gl.enableVertexAttribArray(ATTRIBUTE_LOCATIONS.texCoord);\n        gl.vertexAttribPointer(ATTRIBUTE_LOCATIONS.texCoord, // attribute location\n                               2,          // 2 components per vertex (x,y)\n                               gl.FLOAT,   // type\n                               false,      // don't normalize\n                               0,          // default stride (tightly packed)\n                               0);         // offset\n\n        // unbind\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n\n        // cache & return\n        const result = new ProgramGeometry(vao, vbo[0], vbo[1]);\n        geometryCache.set(gl, result);\n        return result;\n    }\n\n    /**\n     * Reallocate pixel buffers, so that they can hold width x height RGBA pixels\n     * @param {number} width\n     * @param {number} height\n     */\n    _reallocatePixelBuffers(width, height)\n    {\n        // skip realloc\n        if(width * height <= this._pixelBufferSize[0] * this._pixelBufferSize[1])\n            return;\n\n        // update size\n        this._pixelBufferSize[0] = width;\n        this._pixelBufferSize[1] = height;\n\n        // reallocate pixels array\n        for(let i = 0; i < PBO_COUNT; i++) {\n            const oldBuffer = this._pixelBuffer[i];\n            this._pixelBuffer[i] = new Uint8Array(width * height * 4);\n            this._pixelBuffer[i].fill(255, 0, 4); // will be recognized as empty... needed?\n\n            if(oldBuffer) {\n                if(oldBuffer.length > this._pixelBuffer[i].length)\n                    this._pixelBuffer[i].set(oldBuffer.slice(0, this._pixelBuffer[i].length));\n                else\n                    this._pixelBuffer[i].set(oldBuffer);\n            }\n        }\n    }\n\n    /**\n     * Wait for a queue to be not empty\n     * @param {Array} queue\n     * @returns {SpeedyPromise}\n     */\n    _waitForQueueNotEmpty(queue)\n    {\n        return new SpeedyPromise(resolve => {\n            //const start = performance.now();\n            function wait() {\n                if(queue.length > 0)\n                    resolve(); //resolve(performance.now() - start);\n                else\n                    setTimeout(wait, 0); // Utils.setZeroTimeout may hinder performance (GLUtils already calls it)\n                    //Utils.setZeroTimeout(wait);\n            }\n            wait();\n        });\n    }\n}\n\n\n\n//\n// Helpers\n//\n\n/**\n * Storage for VAO & VBOs (vertex shader)\n * @param {WebGLVertexArrayObject} vao vertex array object\n * @param {WebGLBuffer} vboPosition buffer associated with the position attribute\n * @param {WebGLBuffer} vboTexCoord buffer associated with the texCoord attribute\n */\nfunction ProgramGeometry(vao, vboPosition, vboTexCoord)\n{\n    this.vao = vao;\n    this.vbo = Object.freeze({\n        position: vboPosition,\n        texCoord: vboTexCoord\n    });\n\n    return Object.freeze(this);\n}\n\n/**\n * Helper class for storing data related to GLSL uniform variables\n * @param {string} type\n * @param {WebGLUniformLocation} location\n */\nfunction ProgramUniform(type, location)\n{\n    /** @type {string} GLSL data type */\n    this.type = String(type);\n    if(!Object.prototype.hasOwnProperty.call(UNIFORM_SETTERS, this.type))\n        throw new NotSupportedError(`Unsupported uniform type: ${this.type}`);\n\n    /** @type {WebGLUniformLocation} uniform location in a WebGL program */\n    this.location = location;\n\n    /** @type {string} setter function */\n    this.setter = UNIFORM_SETTERS[this.type];\n\n    /** @type {number} vector size */\n    this.length = ((this.setter.match(/^uniform(\\d)/))[1]) | 0;\n\n    // done!\n    return Object.freeze(this);\n}\n\n/**\n * A helper class for handling Uniform Buffer Objects (UBOs)\n * @param {WebGL2RenderingContext} gl\n * @param {WebGLProgram} program\n */\nfunction UBOHelper(gl, program)\n{\n    this._gl = gl;\n    this._program = program;\n    this._nextIndex = 0;\n    this._ubo = Object.create(null);\n}\n\n/**\n * Set Uniform Buffer Object data\n * (the buffer will be uploaded when the program is executed)\n * @param {string} name uniform block name\n * @param {ArrayBufferView} data\n */\nUBOHelper.prototype.set = function(name, data)\n{\n    const gl = this._gl;\n\n    // create UBO entry\n    if(this._ubo[name] === undefined) {\n        this._ubo[name] = {\n            buffer: gl.createBuffer(),\n            blockBindingIndex: this._nextIndex++, // \"global\" binding index\n            blockIndex: null, // UBO \"location\" in the program\n            data: null\n        };\n    }\n\n    // get UBO entry for the given block name\n    const ubo = this._ubo[name];\n\n    // read block index & assign binding point\n    if(ubo.blockIndex === null) {\n        const blockIndex = gl.getUniformBlockIndex(this._program, name);\n        gl.uniformBlockBinding(this._program, blockIndex, ubo.blockBindingIndex);\n        ubo.blockIndex = blockIndex;\n    }\n\n    // store the data - we'll upload it later\n    ubo.data = data;\n}\n\n/**\n * Update UBO data\n * Called when we're using the appropriate WebGLProgram\n */\nUBOHelper.prototype.update = function()\n{\n    const gl = this._gl;\n\n    for(const name in this._ubo) {\n        const ubo = this._ubo[name];\n\n        gl.bindBuffer(gl.UNIFORM_BUFFER, ubo.buffer);\n        gl.bufferData(gl.UNIFORM_BUFFER, ubo.data.byteLength, gl.DYNAMIC_DRAW); // buffer orphaning - needed?\n        gl.bufferData(gl.UNIFORM_BUFFER, ubo.data, gl.DYNAMIC_DRAW);\n        gl.bindBufferBase(gl.UNIFORM_BUFFER, ubo.blockBindingIndex, ubo.buffer);\n        gl.bindBuffer(gl.UNIFORM_BUFFER, null);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-texture.js\n * A wrapper around WebGLTexture\n */\n\nimport { SpeedyGPU } from './speedy-gpu';\nimport { GLUtils } from './gl-utils';\nimport { Utils } from '../utils/utils';\nimport { IllegalOperationError } from '../utils/errors';\nimport { PYRAMID_MAX_LEVELS } from '../utils/globals';\n\n/**\n * A wrapper around WebGLTexture\n */\nexport class SpeedyTexture\n{\n    /**\n     * Creates a new texture with the specified dimensions\n     * @param {WebGL2RenderingContext} gl \n     * @param {number} width \n     * @param {number} height \n     */\n    constructor(gl, width, height)\n    {\n        this._gl = gl;\n        this._width = Math.max(1, width | 0);\n        this._height = Math.max(1, height | 0);\n        this._glTexture = GLUtils.createTexture(this._gl, this._width, this._height);\n        this._hasMipmaps = false;\n    }\n\n    /**\n     * Releases the texture\n     * @returns {null}\n     */\n    release()\n    {\n        if(this._glTexture !== null) {\n            this._glTexture = GLUtils.destroyTexture(this._gl, this._glTexture);\n            this._width = this._height = 0;\n            this._hasMipmaps = false;\n        }\n        else\n            throw new IllegalOperationError(`The SpeedyTexture has already been released`);\n\n        return null;\n    }\n\n    /**\n     * Upload pixel data to the texture\n     * @param {ImageBitmap|ImageData|ArrayBufferView|HTMLImageElement|HTMLVideoElement|HTMLCanvasElement} pixels \n     * @return {SpeedyTexture} this\n     */\n    upload(pixels)\n    {\n        this._hasMipmaps = false;\n        GLUtils.uploadToTexture(this._gl, this._glTexture, this._width, this._height, pixels, 0);\n        return this;\n    }\n\n    /**\n     * Generates an image pyramid\n     * @param {SpeedyGPU} gpu\n     * @param {boolean} [gaussian] should we compute a Gaussian pyramid? Recommended!\n     * @returns {SpeedyTexture} this\n     */\n    generatePyramid(gpu, gaussian = true)\n    {\n        // nothing to do\n        if(this._hasMipmaps)\n            return this;\n\n        // validate gpu\n        Utils.assert(gpu.gl === this._gl);\n\n        // let the hardware compute the all levels of the pyramid, up to 1x1\n        // this might be a simple box filter...\n        GLUtils.generateMipmap(this._gl, this._glTexture);\n        this._hasMipmaps = true;\n\n        // compute a few layers of a Gaussian pyramid for better results\n        if(gaussian) {\n            let layer = this, pyramid = null;\n            for(let level = 1; level < PYRAMID_MAX_LEVELS; level++) {\n                pyramid = gpu.programs.pyramids(level-1);\n                layer = pyramid.reduce(layer);\n                pyramid.exportTo(this, level);\n            }\n        }\n\n        // done!\n        return this;\n    }\n\n    /**\n     * Invalidates previously generated pyramid (if any)\n     */\n    discardPyramid()\n    {\n        this._hasMipmaps = false;\n    }\n\n    /**\n     * The internal WebGLTexture\n     * @returns {WebGLTexture}\n     */\n    get glTexture()\n    {\n        return this._glTexture;\n    }\n\n    /**\n     * The width of the texture, in pixels\n     * @returns {number}\n     */\n    get width()\n    {\n        return this._width;\n    }\n\n    /**\n     * The height of the texture, in pixels\n     * @returns {number}\n     */\n    get height()\n    {\n        return this._height;\n    }\n\n    /**\n     * The WebGL Context\n     * @returns {WebGL2RenderingContext}\n     */\n    get gl()\n    {\n        return this._gl;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * index.js\n * The entry point of the library\n */\n\nmodule.exports = require('./core/speedy').Speedy;","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * errors.js\n * Error classes\n */\n\n/**\n * Generic error class for Speedy\n */\nexport class SpeedyError extends Error\n{\n    /**\n     * Class constructor\n     * @param {string} message message text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message, cause = null)\n    {\n        super([\n            message,\n            cause ? cause.toString() : '[speedy-vision.js]'\n        ].join('\\n-> '));\n        this._cause = cause;\n    }\n\n    /**\n     * Error name\n     * @returns {string}\n     */\n    get name()\n    {\n        return this.constructor.name;\n    }\n\n    /**\n     * Set error name (ignored)\n     * @param {string} _ ignored\n     */\n    set name(_)\n    {\n        ;\n    }\n\n    /**\n     * Get the cause of the error. Available if\n     * it has been specified in the constructor\n     * @returns {SpeedyError|null}\n     */\n    get cause()\n    {\n        return this._cause;\n    }\n}\n\n/**\n * Unsupported operation error\n * The requested operation is not supported\n */\nexport class NotSupportedError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Unsupported operation. ${message}`, cause);\n    }\n}\n\n/**\n * Not implemented error\n * The called method is not implemented\n */\nexport class NotImplementedError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Method not implemented. ${message}`, cause);\n    }\n}\n\n/**\n * WebGL error\n */\nexport class GLError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`WebGL error. ${message}`, cause);\n    }\n}\n\n/**\n * AbstractMethodError\n * Thrown when one tries to call an abstract method\n */\nexport class AbstractMethodError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Can't call abstract method. ${message}`, cause);\n    }\n}\n\n/**\n * Illegal argument error\n * A method has received one or more illegal arguments\n */\nexport class IllegalArgumentError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Illegal argument. ${message}`, cause);\n    }\n}\n\n/**\n * Illegal operation error\n * The method arguments are valid, but the method can't\n * be called due to the current the state of the object\n */\nexport class IllegalOperationError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Illegal operation. ${message}`, cause);\n    }\n}\n\n/**\n * File not found error\n */\nexport class FileNotFoundError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`File not found. ${message}`, cause);\n    }\n}\n\n/**\n * Timeout error\n */\nexport class TimeoutError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Timeout error. ${message}`, cause);\n    }\n}\n\n/**\n * Parse error\n */\nexport class ParseError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Parse error. ${message}`, cause);\n    }\n}\n\n/**\n * Assertion error\n */\nexport class AssertionError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Assertion failed. ${message}`, cause);\n    }\n}\n\n/**\n * Access denied\n */\nexport class AccessDeniedError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Access denied. ${message}`, cause);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * fps-counter.js\n * A FPS counter\n */\n\nimport { IllegalOperationError } from './errors';\n\nlet instance = null;\nconst UPDATE_INTERVAL = 500; // in ms\n\nexport class FPSCounter\n{\n    /**\n     * Creates a new FPSCounter\n     */\n    /* private */ constructor()\n    {\n        this._fps = 60;\n        this._frames = 0;\n        this._updateInterval = UPDATE_INTERVAL;\n        this._lastUpdate = performance.now();\n        this._boundUpdate = this._update.bind(this);\n\n        // this should never happen...\n        if(instance !== null)\n            throw new IllegalOperationError(`Can't have multiple instances of FPSCounter`);\n\n        // start FPS counter\n        this._boundUpdate();\n    }\n\n    /**\n     * Gets an instance of the FPS counter.\n     * We use lazy loading, i.e., we will not\n     * create a FPS counter unless we need to!\n     * @returns {FPSCounter}\n     */\n    static get instance()\n    {\n        if(instance === null)\n            instance = new FPSCounter();\n\n        return instance;\n    }\n\n    /**\n     * Get the FPS rate\n     * @returns {number} frames per second\n     */\n    get fps()\n    {\n        return this._fps;\n    }\n\n    /**\n     * Updates the FPS counter\n     */\n    _update()\n    {\n        const now = performance.now();\n        const deltaTime = now - this._lastUpdate;\n\n        if(deltaTime >= this._updateInterval) {\n            this._fps = Math.round(this._frames / (deltaTime * 0.001));\n            this._frames = 0;\n            this._lastUpdate = now;\n        }\n\n        this._frames++;\n        requestAnimationFrame(this._boundUpdate);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * globals.js\n * Global constants\n */\n\n// -----------------------------------------------------------------\n// IMAGE PYRAMIDS & SCALE-SPACE\n// -----------------------------------------------------------------\n\n// The maximum number of layers of the pyramid (not counting intra-layers)\nexport const PYRAMID_MAX_LEVELS = 7; // scaling factor = 1\n\n// The maximum number of layers of the pyramid (counting intra-layers)\nexport const PYRAMID_MAX_OCTAVES = 2 * PYRAMID_MAX_LEVELS - 1; // default scaling factor = sqrt(2)\n\n// The maximum supported scale for a pyramid layer\nexport const PYRAMID_MAX_SCALE = 2; // preferably a power of 2 (image scale can go up to this value)\n\n// The base-2 logarithm of PYRAMID_MAX_SCALE\nexport const LOG2_PYRAMID_MAX_SCALE = Math.log2(PYRAMID_MAX_SCALE);\n\n\n\n// -----------------------------------------------------------------\n// FIXED-POINT MATH\n// -----------------------------------------------------------------\n\n// How many bits do we use for storing the fractional data\nexport const FIX_BITS = 3; // MAX_TEXTURE_LENGTH depends on this\n\n// Fixed-point resolution\nexport const FIX_RESOLUTION = 1.0 * (1 << FIX_BITS); // float(2^(FIX_BITS))\n\n\n\n// -----------------------------------------------------------------\n// TEXTURE LIMITS\n// -----------------------------------------------------------------\n\n// Maximum texture length\nexport const MAX_TEXTURE_LENGTH = (1 << (16 - FIX_BITS)) - 2; // 2^n - 2 due to keypoint encoding\n\n\n\n// -----------------------------------------------------------------\n// KEYPOINTS\n// -----------------------------------------------------------------\n\n// Maximum size of a descriptor, in bytes (must be divisible by 4)\nexport const MAX_DESCRIPTOR_SIZE = 64;\n\n// Size of a keypoint header, in bytes (must be divisible by 4)\nexport const MIN_KEYPOINT_SIZE = 8;\n\n// Flag: no special flags\nexport const KPF_NONE = 0x0;\n\n// Flag: the keypoint is oriented\nexport const KPF_ORIENTED = 0x1;\n\n// Flag: should the keypoint be discarded? (in the next frame)\nexport const KPF_DISCARD = 0x80;","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * observable.js\n * Observer design pattern\n */\n\n/**\n * Implementation of the Observer design pattern\n */\nexport /* abstract */ class Observable\n{\n    /**\n     * Class constructor\n     */\n    constructor()\n    {\n        this._subscribers = [];\n    }\n\n    /**\n     * Add subscriber\n     * @param {Function} fn callback\n     */\n    subscribe(fn)\n    {\n        if(this._subscribers.indexOf(fn) < 0)\n            this._subscribers.push(fn);\n    }\n\n    /**\n     * Remove subscriber\n     * @param {Function} fn previously added callback\n     */\n    unsubscribe(fn)\n    {\n        this._subscribers = this._subscribers.filter(subscriber => subscriber !== fn);\n    }\n\n    /**\n     * Notify all subscribers about a state change\n     * @param {any} data generic data\n     */\n    /* protected */ _notify(data)\n    {\n        for(const fn of this._subscribers)\n            fn(data);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-promise.js\n * Speedy Promises: a fast implementation of Promises\n */\n\nconst PENDING = 0;\nconst FULFILLED = 1;\nconst REJECTED = 2;\n\nconst SUSPEND_ASYNC = 1;\nconst DISABLE_ASYNC = 2;\nconst asap = (typeof queueMicrotask !== 'undefined' && queueMicrotask) || // browsers\n             (typeof process !== 'undefined' && process.nextTick) || // node.js\n             (f => Promise.resolve().then(f)); // most compatible\n\n/**\n * SpeedyPromise: Super Fast Promises. SpeedyPromises can\n * interoperate with ES6 Promises. This implementation is\n * based on the Promises/A+ specification.\n * @template\n */\nexport class SpeedyPromise\n{\n    /**\n     * Constructor\n     * @param {Function} callback\n     * @param {boolean} [sync] a hint that you'll be calling turbocharge() after a chain of then()/catch()/finally()\n     */\n    constructor(callback, sync = false)\n    {\n        this._state = PENDING;\n        this._value = undefined;\n\n        this._onFulfillment = null;\n        this._onRejection = null;\n        this._children = 0;\n        this[0] = this;\n        this._parent = undefined;\n        this._flags = sync ? DISABLE_ASYNC : 0;\n\n        this._fulfill = this._fulfill.bind(this);\n        this._reject = this._reject.bind(this);\n        this._resolve = this._resolve.bind(this);\n        this._broadcastIfAsync = this._broadcastIfAsync.bind(this);\n\n        callback(this._fulfill, this._reject);\n    }\n\n    /**\n     * Setup handlers\n     * @param {Function} onFulfillment called when the SpeedyPromise is fulfilled\n     * @param {Function} [onRejection] called when the SpeedyPromise is rejected\n     * @returns {SpeedyPromise}\n     */\n    then(onFulfillment, onRejection = null)\n    {\n        const child = new SpeedyPromise(this._nop);\n        child._onFulfillment = typeof onFulfillment === 'function' && onFulfillment;\n        child._onRejection = typeof onRejection === 'function' && onRejection;\n        child._parent = this;\n\n        this[this._children++] = child; // attach child\n        this._flags &= ~SUSPEND_ASYNC; // restore the async behavior\n        this._notify();\n\n        return child;\n    }\n\n    /**\n     * Setup rejection handler\n     * @param {Function} onRejection called when the SpeedyPromise is rejected\n     * @returns {SpeedyPromise}\n     */\n    catch(onRejection)\n    {\n        return this.then(null, onRejection);\n    }\n\n    /**\n     * Execute a callback when the promise is settled\n     * (i.e., fulfilled or rejected)\n     * @param {Function} onFinally\n     * @returns {SpeedyPromise}\n     */\n    finally(onFinally)\n    {\n        const fn = val => { onFinally(); return val; };\n        return this.then(fn, fn);\n    }\n\n    /**\n     * Start the computation immediately, synchronously.\n     * Can't afford to spend any time at all waiting for micro-tasks, etc.\n     * @returns {SpeedyPromise} this\n     */\n    turbocharge()\n    {\n        let my = this;\n\n        // suspend the async behavior\n        this._flags |= SUSPEND_ASYNC;\n        while(my._parent !== undefined) {\n            my = my._parent;\n            my._flags |= SUSPEND_ASYNC;\n        }\n\n        // notify the children of the root\n        my._notify(); // will be synchronous\n\n        // return this SpeedyPromise\n        return this;\n    }\n\n    /**\n     * Convert to string\n     * @returns {string}\n     */\n    toString()\n    {\n        switch(this._state) {\n            case PENDING:\n                return `SpeedyPromise { <pending> }`;\n            case FULFILLED:\n                return `SpeedyPromise { <fulfilled> ${this._value} }`;\n            case REJECTED:\n                return `SpeedyPromise { <rejected> ${this._value} }`;\n            default:\n                return '';\n        }\n    }\n\n    /**\n     * Creates a resolved SpeedyPromise\n     * @param {any} value\n     * @returns {SpeedyPromise}\n     */\n    static resolve(value)\n    {\n        const promise = new SpeedyPromise(this._snop);\n\n        if((typeof value === 'object' && value !== null && 'then' in value) || (typeof value === 'function' && 'then' in value)) {\n            // resolve asynchronously\n            promise._resolve(value);\n        }\n        else {\n            // fulfill synchronously\n            promise._value = value;\n            promise._state = FULFILLED;\n        }\n\n        return promise;\n    }\n\n    /**\n     * Creates a rejected SpeedyPromise\n     * @param {any} reason usually an instance of Error\n     * @returns {SpeedyPromise}\n     */\n    static reject(reason)\n    {\n        const promise = new SpeedyPromise(this._snop);\n        promise._value = reason;\n        promise._state = REJECTED;\n        return promise;\n    }\n\n    /**\n     * Returns a SpeedyPromise that resolves to an array\n     * containing the results of the input promises/values,\n     * in their given order. The returned SpeedyPromise will\n     * resolve if all input promises resolve, or reject if\n     * any input promise rejects.\n     * @param {iterable} iterable e.g., a SpeedyPromise[]\n     * @returns {SpeedyPromise}\n     */\n    static all(iterable)\n    {\n        return new SpeedyPromise((resolve, reject) => {\n            const input = [];\n\n            // get elements\n            for(const element of iterable)\n                input.push(element);\n\n            // resolve synchronously if there are no elements\n            const length = input.length;\n            if(length == 0) {\n                resolve([]);\n                return;\n            }\n\n            // resolve asynchronously\n            let counter = length;\n            const output = new Array(length);\n            const partialResolve = i => (val => { output[i] = val; if(0 == --counter) resolve(output); });\n            for(let i = 0; i < length; i++) {\n                const element = input[i];\n                if(element.__proto__ === SpeedyPromise.prototype || element.__proto__ === Promise.prototype)\n                    element.then(partialResolve(i), reject);\n                else\n                    SpeedyPromise.resolve(element).then(partialResolve(i), reject);\n            }\n        });\n    }\n\n    /**\n     * Returns a promise that gets fulfilled or rejected as soon\n     * as the first promise in the iterable gets fulfilled or\n     * rejected (with its value/reason).\n     * @param {iterable} iterable e.g., a SpeedyPromise[]\n     * @returns {SpeedyPromise}\n     */\n    static race(iterable)\n    {\n        return new SpeedyPromise((resolve, reject) => {\n            const input = [];\n\n            // get elements\n            for(const element of iterable)\n                input.push(element);\n\n            // if the iterable is empty, the promise\n            // will be pending forever...\n\n            // resolve asynchronously\n            const length = input.length;\n            for(let i = 0; i < length; i++) {\n                const element = input[i];\n                if(element.__proto__ === SpeedyPromise.prototype || element.__proto__ === Promise.prototype)\n                    element.then(resolve, reject);\n                else\n                    SpeedyPromise.resolve(element).then(resolve, reject);\n            }\n        });\n    }\n\n    /**\n     * Fulfill this promise with a value\n     * @param {any} value\n     */\n    _fulfill(value)\n    {\n        this._setState(FULFILLED, value);\n    }\n\n    /**\n     * Reject this promise with a reason\n     * @param {any} reason\n     */\n    _reject(reason)\n    {\n        this._setState(REJECTED, reason);\n    }\n\n    /**\n     * Set the state and the value of this promise\n     * @param {number} state\n     * @param {any} value\n     */\n    _setState(state, value)\n    {\n        // the promise is already fulfilled or rejected\n        if(this._state != PENDING)\n            return;\n\n        // set the new state\n        this._state = state;\n        this._value = value;\n        this._notify();\n    }\n\n    /**\n     * Notify my children that this promise is no\n     * longer pending. This is an async operation:\n     * my childen will be notified \"as soon\n     * as possible\" (it will be scheduled).\n     * We may force this to be synchronous, though\n     */\n    _notify()\n    {\n        // nothing to do\n        if(this._state == PENDING)\n            return;\n\n        // have we turbocharged this promise?\n        if(this._flags & SUSPEND_ASYNC) {\n            this._broadcast(); // execute synchronously\n            return;\n        }\n\n        // install a timer (default behavior)\n        if(!(this._flags & DISABLE_ASYNC))\n            asap(this._broadcastIfAsync);\n    }\n\n    /**\n     * Helper method\n     */\n    _broadcastIfAsync()\n    {\n        // we may have installed a timer at some\n        // point, but turbocharged the promise later\n        if(!(this._flags & SUSPEND_ASYNC))\n            this._broadcast();\n    }\n\n    /**\n     * Tell my children that this promise\n     * is either fulfilled or rejected.\n     * This is a synchronous operation\n     */\n    _broadcast()\n    {\n        const children = this._children;\n        const state = this._state;\n\n        if(state === FULFILLED) {\n            for(let i = 0; i < children; i++) {\n                const child = this[i];\n                const callback = child._onFulfillment;\n\n                try {\n                    if(callback) {\n                        if(callback !== child._nop) {\n                            child._resolve(callback(this._value)); // promise resolution procedure\n                            child._onFulfillment = child._nop; // will not be called again\n                        }\n                    }\n                    else\n                        child._fulfill(this._value);\n                }\n                catch(e) {\n                    child._reject(e);\n                }\n            }\n        }\n        else if(state === REJECTED) {\n            for(let i = 0; i < children; i++) {\n                const child = this[i];\n                const callback = child._onRejection;\n\n                try {\n                    if(callback) {\n                        if(callback !== child._nop) {\n                            child._resolve(callback(this._value)); // promise resolution procedure\n                            child._onRejection = child._nop; // will not be called again\n                        }\n                    }\n                    else\n                        child._reject(this._value);\n                }\n                catch(e) {\n                    child._reject(e);\n                }\n            }\n        }\n    }\n\n    /**\n     * Promise Resolution Procedure\n     * based on the Promises/A+ spec\n     * @param {any} x\n     */\n    _resolve(x)\n    {\n        if((typeof x !== 'object' && typeof x !== 'function') || (x === null)) { // if(x !== Object(x))\n            this._fulfill(x);\n            return;\n        }\n\n        if(x === this)\n            throw new TypeError(); // Circular reference\n\n        if(x.__proto__ === SpeedyPromise.prototype || x.__proto__ === Promise.prototype) {\n            x.then(this._resolve, this._reject);\n            return;\n        }\n\n        try {\n            const then = x.then;\n            if(typeof then === 'function') {\n                let resolve = this._resolve, reject = this._reject;\n                try {\n                    then.call(x,\n                        y => { resolve(y); resolve = reject = this._nop; },\n                        r => { reject(r); resolve = reject = this._nop; }\n                    );\n                }\n                catch(e) {\n                    if(resolve !== this._nop && reject !== this._nop)\n                        this._reject(e);\n                }\n            }\n            else {\n                this._fulfill(x);\n            }\n        }\n        catch(e) {\n            this._reject(e);\n        }\n    }\n\n    /**\n     * No-operation\n     */\n    _nop()\n    {\n    }\n\n    /**\n     * Static no-operation\n     */\n    static _snop()\n    {\n    }\n}\n\n//module.exports = { SpeedyPromise };\n\n/*\n// Uncomment to test performance with regular Promises\nmodule.exports = { SpeedyPromise: Promise };\nPromise.prototype.turbocharge = function() { return this };\n*/","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * types.js\n * Types & formats\n */\n\nimport { Utils } from './utils';\n\nexport const MediaType = Utils.enum(\n    'Image',\n    'Video',\n    'Canvas',\n    'Bitmap'\n);\n\nexport const ColorFormat = Utils.enum(\n    'RGB',\n    'Greyscale',\n    'Binary'\n);\n\nexport const PixelComponent = Object.freeze({\n    RED:   1,\n    GREEN: 2,\n    BLUE:  4,\n    ALPHA: 8,\n    ALL:   15 // = RED | GREEN | BLUE | ALPHA\n});\n\nexport const ColorComponentId = Object.freeze({\n    [PixelComponent.RED]:   0,\n    [PixelComponent.GREEN]: 1,\n    [PixelComponent.BLUE]:  2,\n    [PixelComponent.ALPHA]: 3\n});","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * utils.js\n * Generic utilities\n */\n\nimport { IllegalArgumentError, ParseError, AssertionError, AccessDeniedError, NotSupportedError } from './errors'\nimport { SpeedyPromise } from './speedy-promise';\n\n/**\n * Generic utilities\n */\nexport class Utils\n{\n    /**\n     * Generates a warning\n     * @param {string} text message text\n     * @param  {...string} [args] optional text\n     * @returns {string} the message text\n     */\n    static warning(text, ...args)\n    {\n        const message = [ text, ...args ].join(' ');\n        console.warn('[speedy-vision.js]', message);\n        return message;\n    }\n\n    /**\n     * Logs a message\n     * @param {string} text message text\n     * @param  {...string} [args] optional text\n     * @returns {string} the message text\n     */\n    static log(text, ...args)\n    {\n        const message = [ text, ...args ].join(' ');\n        if(__SPEEDY_DEVELOPMENT_MODE__)\n            console.log('[speedy-vision.js]', message);\n        return message;\n    }\n\n    /**\n     * Assertion\n     * @param {boolean} expr expression\n     * @param {string} [text] error message\n     * @throws {AssertionError}\n     */\n    static assert(expr, text = '')\n    {\n        if(!expr)\n            throw new AssertionError(text);\n    }\n\n    /**\n     * Generates an enumeration\n     * @param {...string} values enumeration options\n     * @returns {object} enum object\n     */\n    static enum(...values)\n    {\n        return Object.freeze(\n            values.reduce((acc, cur) => ((acc[cur] = Symbol(cur)), acc), { })\n        );\n    }\n\n    /**\n     * Similar to setTimeout(fn, 0), but without the ~4ms delay.\n     * Although much faster than setTimeout, this may be resource-hungry\n     * (heavy on battery) if used in a loop. Use with caution.\n     * Implementation based on David Baron's, but adapted for ES6 classes\n     * @param {Function} fn\n     */\n    //static setZeroTimeout(fn) { setTimeout(fn, 0); } // easier on the CPU\n    static setZeroTimeout(fn)\n    {\n        const ctx = (Utils._setZeroTimeoutContext = Utils._setZeroTimeoutContext || (Utils._setZeroTimeoutContext = {\n            callbacks: new Map(),\n            _setup: window.addEventListener('message', ev => {\n                if(ev.source === window) {\n                    const ctx = Utils._setZeroTimeoutContext;\n                    const msgId = ev.data;\n                    const fn = ctx.callbacks.get(msgId);\n                    if(fn !== undefined) {\n                        ev.stopPropagation();\n                        fn.call(window);\n                        ctx.callbacks.delete(msgId);\n                    }\n                }\n            }, true)\n        }));\n\n        const msgId = '0%' + Math.random();\n        ctx.callbacks.set(msgId, fn);\n        window.postMessage(msgId, '*');\n    }\n\n    /**\n     * Gets the names of the arguments of the specified function\n     * @param {Function} fun \n     * @returns {Array<string>}\n     */\n    static functionArguments(fun)\n    {\n        const code = fun.toString();\n        const regex = code.startsWith('function') ? 'function\\\\s.*\\\\(([^)]*)\\\\)' :\n                     (code.startsWith('(') ? '\\\\(([^)]*)\\\\).*=>' : '([^=]+).*=>');\n        const match = new RegExp(regex).exec(code);\n\n        if(match !== null) {\n            const args = match[1].replace(/\\/\\*.*?\\*\\//g, ''); // remove comments\n            return args.split(',').map(argname =>\n                argname.replace(/=.*$/, '').trim() // remove default params & trim\n            ).filter(argname =>\n                argname // handle trailing commas\n            );\n        }\n        else\n            throw new ParseError(`Can't detect function arguments of ${code}`);\n\n        return [];\n    }\n\n    /**\n     * Get all property descriptors from an object,\n     * traversing its entire prototype chain\n     * @param {object} obj \n     * @returns {object}\n     */\n    static getAllPropertyDescriptors(obj)\n    {\n        if(obj) {\n            const proto = Object.getPrototypeOf(obj);\n\n            return {\n                ...(Utils.getAllPropertyDescriptors(proto)),\n                ...Object.getOwnPropertyDescriptors(obj)\n            };\n        }\n        else\n            return Object.create(null);\n    }\n\n    /**\n     * Are we in a little-endian platform?\n     * @returns {boolean}\n     */\n    static isLittleEndian()\n    {\n        if(Utils._isLittleEndian !== undefined)\n            return Utils._isLittleEndian;\n\n        const buf = new ArrayBuffer(2);\n        const u8 = new Uint8Array(buf);\n        const u16 = new Uint16Array(buf);\n\n        u8[1] = 0xCA; u8[0] = 0xFE;\n\n        return Utils._isLittleEndian = (u16[0] == 0xCAFE);\n    }\n\n    /**\n     * Creates a HTMLCanvasElement with the given dimensions\n     * @param {number} width in pixels\n     * @param {number} height in pixels\n     * @returns {HTMLCanvasElement}\n     */\n    static createCanvas(width, height)\n    {\n        const canvas = document.createElement('canvas');\n        canvas.width = width;\n        canvas.height = height;\n        return canvas;\n    }\n\n    /**\n     * Generates a random number with\n     * Gaussian distribution (mu, sigma)\n     * @param {number} mu mean\n     * @param {number} sigma standard deviation\n     * @returns {number} random number\n     */\n    static gaussianNoise(mu = 0, sigma = 1)\n    {\n        // Box-Muller transformation\n        const TWO_PI = 2.0 * Math.PI;\n        \n        let a, b = Math.random();\n        do { a = Math.random(); } while(a <= Number.EPSILON);\n        let z = Math.sqrt(-2 * Math.log(a)) * Math.sin(TWO_PI * b);\n\n        return z * sigma + mu;\n    }\n\n    /**\n     * Generate a 1D gaussian kernel with custom sigma\n     * Tip: use kernelSize >= (5 * sigma), kernelSize odd\n     * @param {number} sigma gaussian sigma\n     * @param {number} [kernelSize] kernel size, odd number\n     * @param {bool} [normalized] normalize entries so that their sum is 1\n     */\n    static gaussianKernel(sigma, kernelSize = -1, normalized = true)\n    {\n        /*\n         * Let G(x) be a Gaussian function centered at 0 with fixed sigma:\n         *\n         * G(x) = (1 / (sigma * sqrt(2 * pi))) * exp(-(x / (sqrt(2) * sigma))^2)\n         * \n         * In addition, let f(p) be a kernel value at pixel p, -k/2 <= p <= k/2:\n         * \n         * f(p) = \\int_{p - 0.5}^{p + 0.5} G(x) dx (integrate around p)\n         *      = \\int_{0}^{p + 0.5} G(x) dx - \\int_{0}^{p - 0.5} G(x) dx\n         * \n         * Setting a constant c := sqrt(2) * sigma, it follows that:\n         * \n         * f(p) = (1 / 2c) * (erf((p + 0.5) / c) - erf((p - 0.5) / c))\n         */\n\n        // default kernel size\n        if(kernelSize < 0) {\n            kernelSize = Math.ceil(5.0 * sigma) | 0;\n            kernelSize += 1 - (kernelSize % 2);\n        }\n\n        // validate input\n        kernelSize |= 0;\n        if(kernelSize < 1 || kernelSize % 2 == 0)\n            throw new IllegalArgumentError(`Invalid kernel size given to gaussianKernel: ${kernelSize} x 1`);\n        else if(sigma <= 0.0)\n            throw new IllegalArgumentError(`Invalid sigma given to gaussianKernel: ${sigma}`);\n\n        // function erf(x) = -erf(-x) can be approximated numerically. See:\n        // https://en.wikipedia.org/wiki/Error_function#Numerical_approximations\n        const kernel = new Array(kernelSize);\n\n        // set constants\n        const N  =  kernelSize >> 1; // integer (floor, div 2)\n        const c  =  (+sigma) * 1.4142135623730951; // sigma * sqrt(2)\n        const m  =  0.3275911;\n        const a1 =  0.254829592;\n        const a2 = -0.284496736;\n        const a3 =  1.421413741;\n        const a4 = -1.453152027;\n        const a5 =  1.061405429;\n\n        // compute the kernel\n        let sum = 0.0;\n        for(let j = 0; j < kernelSize; j++) {\n            let xa = (j - N + 0.5) / c;\n            let xb = (j - N - 0.5) / c;\n            let sa = 1.0, sb = 1.0;\n\n            if(xa < 0.0) { sa = -1.0; xa = -xa; }\n            if(xb < 0.0) { sb = -1.0; xb = -xb; }\n\n            const ta = 1.0 / (1.0 + m * xa);\n            const tb = 1.0 / (1.0 + m * xb);\n            const pa = ((((a5 * ta + a4) * ta + a3) * ta + a2) * ta + a1) * ta;\n            const pb = ((((a5 * tb + a4) * tb + a3) * tb + a2) * tb + a1) * tb;\n            const ya = 1.0 - pa * Math.exp(-xa * xa);\n            const yb = 1.0 - pb * Math.exp(-xb * xb);\n\n            const erfa = sa * ya;\n            const erfb = sb * yb;\n            const fp = (erfa - erfb) / (2.0 * c);\n\n            kernel[j] = fp;\n            sum += fp;\n        }\n\n        // done!\n        return normalized ? kernel.map(k => k / sum) : kernel;\n    }\n\n    /**\n     * Cartesian product a x b: [ [ai, bj] for all i, j ]\n     * @param {Array<number>} a\n     * @param {Array<number>} b\n     * @returns {Array<number[2]>}\n     */\n    static cartesian(a, b)\n    {\n        return [].concat(...a.map(a => b.map(b => [a, b])));\n    }\n\n    /**\n     * Symmetric range\n     * @param {number} n non-negative integer\n     * @returns {Array<number>} [ -n, ..., n ]\n     */\n    static symmetricRange(n)\n    {\n        if((n |= 0) < 0)\n            throw new IllegalArgumentError(`Expected a non-negative integer as input`);\n\n        return [...(Array(2*n + 1).keys())].map(x => x - n);\n    }\n\n    /**\n     * Compute the [0, n) range of integers\n     * @param {number} n positive integer\n     * @returns {Array<number>} [ 0, 1, ..., n-1 ]\n     */\n    static range(n)\n    {\n        if((n |= 0) <= 0)\n            throw new IllegalArgumentError(`Expected a positive integer as input`);\n\n        return [...(Array(n).keys())];\n    }\n\n    /**\n     * Request webcam access (WebRTC)\n     * @param {number} width in pixels\n     * @param {number} height in pixels\n     * @param {object} [options] will be passed to navigator.mediaDevices.getUserMedia() \n     * @returns {SpeedyPromise<HTMLVideoElement>}\n     */\n    static requestCameraStream(width, height, options = {})\n    {\n        Utils.log('Accessing the webcam...');\n\n        if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia)\n            throw new NotSupportedError('Unsupported browser: no mediaDevices.getUserMedia()');\n\n        return new SpeedyPromise((resolve, reject) => {\n            navigator.mediaDevices.getUserMedia({\n                audio: false,\n                video: {\n                    width: { ideal: width },\n                    height: { ideal: height },\n                    aspectRatio: width / height,\n                    //resizeMode: 'crop-and-scale',\n                    facingMode: 'environment',\n                    frameRate: 30,\n                },\n                ...options\n            })\n            .then(stream => {\n                const video = document.createElement('video');\n                video.onloadedmetadata = () => {\n                    video.play();\n                    Utils.log('The camera device is turned on!');\n                    resolve(video);\n                };\n                video.srcObject = stream;\n            })\n            .catch(err => {\n                reject(new AccessDeniedError(\n                    `Please give access to the camera and reload the page`,\n                    err\n                ));\n            });\n        });\n    }\n}"],"sourceRoot":""}