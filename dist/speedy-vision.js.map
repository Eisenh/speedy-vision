{"version":3,"sources":["webpack://Speedy/webpack/bootstrap","webpack://Speedy/./src/core/algorithms/brisk.js","webpack://Speedy/./src/core/algorithms/fast.js","webpack://Speedy/./src/core/feature-detector.js","webpack://Speedy/./src/core/pipeline-operations.js","webpack://Speedy/./src/core/speedy-feature.js","webpack://Speedy/./src/core/speedy-media.js","webpack://Speedy/./src/core/speedy-pipeline.js","webpack://Speedy/./src/gpu/gl-utils.js","webpack://Speedy/./src/gpu/gpu-program-group.js","webpack://Speedy/./src/gpu/program-groups/colors.js","webpack://Speedy/./src/gpu/program-groups/encoders.js","webpack://Speedy/./src/gpu/program-groups/filters.js","webpack://Speedy/./src/gpu/program-groups/keypoints.js","webpack://Speedy/./src/gpu/program-groups/programs/brisk.js","webpack://Speedy/./src/gpu/program-groups/programs/colors.js","webpack://Speedy/./src/gpu/program-groups/programs/convolution.js","webpack://Speedy/./src/gpu/program-groups/programs/encoders.js","webpack://Speedy/./src/gpu/program-groups/programs/fast.js","webpack://Speedy/./src/gpu/program-groups/programs/pyramids.js","webpack://Speedy/./src/gpu/program-groups/programs/utils.js","webpack://Speedy/./src/gpu/program-groups/pyramids.js","webpack://Speedy/./src/gpu/program-groups/utils.js","webpack://Speedy/./src/gpu/shader-preprocessor.js","webpack://Speedy/./src/gpu/shaders/colors/rgb2grey.glsl","webpack://Speedy/./src/gpu/shaders/encoders/encode-keypoint-offsets.glsl","webpack://Speedy/./src/gpu/shaders/encoders/encode-keypoints.glsl","webpack://Speedy/./src/gpu/shaders/include sync ^\\.\\/.*$","webpack://Speedy/./src/gpu/shaders/include/global.glsl","webpack://Speedy/./src/gpu/shaders/include/math.glsl","webpack://Speedy/./src/gpu/shaders/include/pyramids.glsl","webpack://Speedy/./src/gpu/shaders/keypoint-detectors/brisk.glsl","webpack://Speedy/./src/gpu/shaders/keypoint-detectors/fast-score12.glsl","webpack://Speedy/./src/gpu/shaders/keypoint-detectors/fast-score16.glsl","webpack://Speedy/./src/gpu/shaders/keypoint-detectors/fast-score8.glsl","webpack://Speedy/./src/gpu/shaders/keypoint-detectors/fast-suppression.glsl","webpack://Speedy/./src/gpu/shaders/keypoint-detectors/fast5.glsl","webpack://Speedy/./src/gpu/shaders/keypoint-detectors/fast7.glsl","webpack://Speedy/./src/gpu/shaders/keypoint-detectors/fast9lg.glsl","webpack://Speedy/./src/gpu/shaders/keypoint-detectors/fast9pyr.glsl","webpack://Speedy/./src/gpu/shaders/keypoint-detectors/multiscale-suppression.glsl","webpack://Speedy/./src/gpu/shaders/keypoint-detectors/samescale-suppression.glsl","webpack://Speedy/./src/gpu/shaders/pyramids/crop.glsl","webpack://Speedy/./src/gpu/shaders/pyramids/downsample2.glsl","webpack://Speedy/./src/gpu/shaders/pyramids/downsample3.glsl","webpack://Speedy/./src/gpu/shaders/pyramids/merge-keypoints-at-consecutive-levels.glsl","webpack://Speedy/./src/gpu/shaders/pyramids/merge-keypoints.glsl","webpack://Speedy/./src/gpu/shaders/pyramids/normalize-keypoints.glsl","webpack://Speedy/./src/gpu/shaders/pyramids/upsample2.glsl","webpack://Speedy/./src/gpu/shaders/pyramids/upsample3.glsl","webpack://Speedy/./src/gpu/shaders/utils/flip-y.glsl","webpack://Speedy/./src/gpu/shaders/utils/identity.glsl","webpack://Speedy/./src/gpu/speedy-gpu.js","webpack://Speedy/./src/gpu/speedy-program.js","webpack://Speedy/./src/speedy.js","webpack://Speedy/./src/utils/errors.js","webpack://Speedy/./src/utils/fps-counter.js","webpack://Speedy/./src/utils/tuner.js","webpack://Speedy/./src/utils/types.js","webpack://Speedy/./src/utils/utils.js"],"names":[],"mappings":";;;;;;;;;;;;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0C;;AAE1C;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gEAAgE;AAChE,sBAAsB,oBAAoB;AAC1C;AACA,0EAA0E;AAC1E,sBAAsB,yBAAyB;AAC/C;;AAEA;AACA;AACA;AACA,sBAAsB,2BAA2B;AACjD;AACA;AACA,sBAAsB,gCAAgC;AACtD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qCAAqC;AAC3D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wDAAwD,QAAQ;AAChE;AACA,6DAA6D,QAAQ;AACrE;AACA;AACA;AACA;;AAEA;AACA,WAAW,KAAsB,EAAE,EAoC1B;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,8BAA8B;;AAE9B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,yBAAyB;AACzB;;AAEA;AACA,SAAS,qBAAqB;AAC9B,SAAS,wBAAwB;AACjC,SAAS,wBAAwB;AACjC,SAAS,wBAAwB;AACjC,SAAS,wBAAwB;AACjC;AACA;;AAEA;AACA;AACA,IAAI,QAAQ;AACZ,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA,WAAW,UAAU;AACrB;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,OAAO;AACzB,sBAAsB,OAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AChRA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0C;AACG;;AAE7C;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,aAAa;AAC5B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA,QAAQ,kDAAK;AACb;AACA,qCAAqC,EAAE;AACvC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,aAAa;AAC5B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA,QAAQ,kDAAK;AACb;AACA,qCAAqC,EAAE;AACvC;;AAEA;AACA;AACA;AACA;AACA,+BAA+B;;AAE/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ,qDAAO;;AAEf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;;AAE5D;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AChJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsD;AACR;AACe;AACtB;;AAEvC;AACA,qCAAqC;;AAErC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,8BAA8B;AAC/C;AACA,oCAAoC;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,wDAAI;AACrC;AACA,iCAAiC,wDAAI;;AAErC;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,wDAAI;AAC9B;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,8BAA8B;AAC/C;AACA,wCAAwC;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,4DAAQ;AACzC;AACA,iCAAiC,4DAAQ;;AAEzC;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,4DAAQ;AAClC;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,wDAAI;AACrC;AACA,iCAAiC,wDAAI;;AAErC;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,0DAAK;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA,YAAY,kDAAK;AACjB;AACA;;AAEA;AACA;AACA,gBAAgB,6DAAgB,UAAU;AAC1C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;ACpOA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6C;AACN;AACG;;AAEnC,2BAA2B;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,eAAe,YAAY;AAC3B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wDAAW;AAC5C;AACA,sCAAsC,wDAAW;AACjD,YAAY,kDAAK;;AAEjB,6BAA6B,wDAAW;AACxC;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,4BAA4B;AAC5B;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,YAAY,kDAAK,+BAA+B,KAAK;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kDAAK,2BAA2B,OAAO;AACnD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,YAAY,kDAAK;AACjB;AACA,YAAY,kDAAK,sDAAsD,IAAI;;AAE3E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kDAAK;;AAErB;AACA,gBAAgB,qDAAO;AACvB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,qDAAO;AACnB;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC9MA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,QAAQ,GAAG,QAAQ;AACtC;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AClGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE8C;AACS;AACF;AACP;AACP;;AAEvC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,eAAe,4DAA4D;AAC3E,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,qEAAqE,EAAE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wDAAW;;AAE3C;AACA;AACA,sCAAsC,sDAAS;AAC/C,aAAa;;AAEb;AACA,4BAA4B,yDAAS;AACrC,yCAAyC;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,kDAAK;AACjB;;AAEA;AACA;AACA;AACA,eAAe,oDAAoD;AACnE,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA,wCAAwC,EAAE;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kDAAK,kCAAkC,YAAY;AAC3E;AACA;AACA;AACA;AACA;AACA,mCAAmC,yDAAW,kCAAkC,YAAY;AAC5F,iBAAiB;AACjB;AACA;AACA;AACA,2BAA2B,yDAAW,kCAAkC,YAAY;AACpF;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA,yEAAyE,mBAAmB;AAC5F;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,oDAAoD;AACrE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,iBAAiB,sDAAS;AAC1B;;AAEA,iBAAiB,sDAAS;AAC1B;;AAEA,iBAAiB,sDAAS;AAC1B;;AAEA,iBAAiB,sDAAS;AAC1B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,YAAY;AAC7B;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,kDAAK;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sDAAS,0BAA0B,sDAAS;AACzE,2DAA2D;AAC3D;AACA;AACA;;AAEA;AACA;AACA,eAAe,eAAe;AAC9B,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA,YAAY,kDAAK;;AAEjB;AACA,kCAAkC,oBAAoB;AACtD,sBAAsB,sDAAS;AAC/B;AACA;;AAEA;AACA;AACA,eAAe,kBAAkB;AACjC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,eAAe;AACf;AACA;;AAEA;AACA,iBAAiB,sDAAS;AAC1B,iBAAiB,sDAAS;AAC1B,iBAAiB,sDAAS;AAC1B;AACA;;AAEA,iBAAiB,sDAAS;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,8BAA8B;AAC/C;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,YAAY,kDAAK;;AAEjB;AACA,6DAA6D,iEAAe;;AAE5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,YAAY,kDAAK,0BAA0B,OAAO;;AAElD;AACA;AACA;AACA;;AAEA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA,+BAA+B,iDAAiD;AAChF,+BAA+B,6CAA6C;AAC5E,gCAAgC,mCAAmC;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sDAAS;;AAEhC;AACA,uBAAuB,sDAAS;;AAEhC;AACA,uBAAuB,sDAAS;;AAEhC;AACA,uBAAuB,sDAAS;AAChC;AACA;;AAEA,IAAI,kDAAK,sDAAsD,YAAY;AAC3E;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,kDAAK;;AAE1B;AACA;;AAEA;AACA;AACA,qCAAqC,cAAc;AACnD;AACA;;AAEA;AACA,kCAAkC;AAClC;;AAEA;AACA,wDAAwD;AACxD;AACA;AACA,QAAQ,kDAAK;;AAEb;AACA,8BAA8B,yDAAW;;AAEzC;AACA;AACA;AACA,wBAAwB,eAAe;AACvC,yBAAyB,gBAAgB;AACzC,8BAA8B,wBAAwB;AACtD;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gBAAgB,kDAAK;AACrB;AACA;AACA,SAAS;AACT;AACA,uBAAuB,yDAAW;AAClC;AACA,mBAAmB,SAAS,IAAI,YAAY;AAC5C;AACA,SAAS;AACT,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,C;;;;;;;;;;;;AC5cA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0D;AACf;AACG;AACP;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,wBAAwB;AACzC;AACA;AACA;AACA;AACA,oDAAoD,QAAQ;AAC5D;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,wBAAwB;AACvC,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA,8BAA8B,sDAAS;AACvC;AACA;;AAEA;AACA,8BAA8B,6BAA6B;AAC3D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,yDAAW;AACtC,SAAS;AACT;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,eAAe,eAAe;AAC9B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,kDAAK,4BAA4B,SAAS;AAClD;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,oBAAoB,sEAAiB;AACrC;AACA;;AAEA,QAAQ,kDAAK,iDAAiD,WAAW;AACzE;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA,qBAAqB;AACrB;AACA;AACA,gBAAgB,sEAAiB;AACjC;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,gBAAgB,sEAAiB;AACjC;AACA;AACA,C;;;;;;;;;;;;ACpLA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuC;;AAEvC;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,aAAa;AAC5B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,aAAa;AAC5B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,0FAA0F;AACzG,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;;AAEA;AACA,8CAA8C,aAAa,iCAAiC,oCAAoC;;AAEhI,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,aAAa;AAC5B,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,MAAM,IAAI,OAAO;AAC9E;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,iBAAiB;AAChC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,UAAU;AACzB,eAAe,WAAW;AAC1B,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iDAAiD;AACjD,oBAAoB,kDAAK;AACzB;AACA;AACA,mEAAmE;AACnE;AACA,wBAAwB,kDAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,gBAAgB;AAC/B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,sEAAsE,YAAY;AAClF,SAAS;AACT;AACA,SAAS;AACT;AACA,C;;;;;;;;;;;;AClXA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEsB;AACtB;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,iBAAiB,gBAAgB;AACjC;AACA,0DAA0D,EAAE;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;;AAET;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb,SAAS;AACT;;AAEA,yDAAyD,EAAE;AAC3D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,C;;;;;;;;;;;;ACrJA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuD;AACV;;AAE7C;AACA;AACA;AACA;AACO,wBAAwB,kEAAe;AAC9C;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yDAAQ;AACzC;AACA;AACA,C;;;;;;;;;;;;AC5CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuD;AACsB;AACnB;AACN;AACX;;AAEzC;AACA;AACA,+BAA+B;AAC/B,kDAAkD;AAClD,4DAA4D;AAC5D,+BAA+B;AAC/B;AACA,mCAAmC;AACnC;;;AAGA;AACA;AACA;AACA;AACO,0BAA0B,kEAAe;AAChD;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,wEAAqB;AACpE,yCAAyC,kEAAe;AACxD;AACA;AACA,aAAa;AACb;;AAEA;AACA,2CAA2C,kDAAK;AAChD,0BAA0B,4DAAe;AACzC;AACA;AACA;AACA;;;;AAIA;AACA;AACA;;;AAGA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA,gGAAgG;AAChG;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,KAAK;AACpB,iBAAiB,2BAA2B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,kDAAK;AACjB;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,mBAAmB;AACzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,+BAA+B,kEAAa;AAC5C;;AAEA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;ACrMA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuD;AACgF;;AAEvI;AACA;AACA;AACA;AACO,yBAAyB,kEAAe;AAC/C;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oCAAoC,uEAAS;AAC7C,mCAAmC,sEAAQ;AAC3C,oCAAoC,uEAAS;AAC7C,mCAAmC,sEAAQ;AAC3C,oCAAoC,uEAAS;AAC7C,mCAAmC,sEAAQ;;AAE3C;AACA;AACA,kCAAkC,sEAAQ;AAC1C,kCAAkC,sEAAQ;AAC1C;AACA,kCAAkC,sEAAQ;AAC1C,kCAAkC,sEAAQ;AAC1C;AACA,kCAAkC,sEAAQ;AAC1C,kCAAkC,sEAAQ;AAC1C;AACA,kCAAkC,sEAAQ;AAC1C,kCAAkC,sEAAQ;AAC1C;AACA,mCAAmC,sEAAQ;AAC3C,mCAAmC,sEAAQ;;AAE3C;AACA,wCAAwC,4EAAc,MAAM;AAC5D;AACA;AACA,aAAa;AACb,wCAAwC,4EAAc,MAAM;AAC5D;AACA;AACA,aAAa;AACb,wCAAwC,4EAAc,MAAM;AAC5D;AACA;AACA,aAAa;AACb,wCAAwC,4EAAc,MAAM;AAC5D;AACA;AACA,aAAa;AACb,wCAAwC,4EAAc,MAAM;AAC5D;AACA;AACA,aAAa;AACb,wCAAwC,4EAAc,MAAM;AAC5D;AACA;AACA,aAAa;AACb,wCAAwC,4EAAc,MAAM;AAC5D;AACA;AACA,aAAa;AACb,yCAAyC,4EAAc,OAAO;AAC9D;AACA;AACA,aAAa;AACb,oDAAoD;AACpD;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;;;;;AAKb;AACA;AACA,iCAAiC,mEAAK;AACtC;AACA;AACA;AACA,iCAAiC,mEAAK;AACtC;AACA;AACA;AACA,iCAAiC,mEAAK;AACtC;AACA;AACA;AACA,iCAAiC,mEAAK;AACtC;AACA;AACA;AACA,iCAAiC,mEAAK;AACtC;AACA;AACA,iCAAiC,mEAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA,+BAA+B,mEAAK;AACpC;AACA;AACA,+BAA+B,mEAAK;AACpC;AACA;AACA,+BAA+B,mEAAK;AACpC;AACA;AACA,+BAA+B,mEAAK;AACpC;AACA;AACA,+BAA+B,mEAAK;AACpC;AACA;AACA,+BAA+B,mEAAK;AACpC;AACA;AACA,+BAA+B,mEAAK;AACpC;AACA;AACA,+BAA+B,mEAAK;AACpC;AACA;AACA,gCAAgC,mEAAK;AACrC;AACA;AACA,gCAAgC,mEAAK;AACrC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjMA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuD;AAC6G;AAC3H;;AAEzC;AACA;AACA;AACA;AACO,2BAA2B,kEAAe;AACjD;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oDAAK;AACpC,qCAAqC,0DAAW;AAChD,yCAAyC,8DAAe;;AAExD;AACA;AACA,+BAA+B,oDAAK;AACpC,qCAAqC,0DAAW;;AAEhD;AACA;AACA,+BAA+B,oDAAK;AACpC,oCAAoC,yDAAU;;AAE9C;AACA,iCAAiC,uDAAQ;;AAEzC;AACA,8BAA8B,qDAAK;;AAEnC;AACA,8CAA8C,oEAAqB;AACnE,6CAA6C,mEAAoB;AACjE;AACA;AACA;;;;;;;;;;;;;;ACpEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACO,iEAAiE,mBAAO,CAAC,oGAA6C,E;;;;;;;;;;;;AC/B7H;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACO,4BAA4B,mBAAO,CAAC,kFAAoC,E;;;;;;;;;;;;ACtB/E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6C;AAC7C,wEAAwE;AACxE,qEAAqE;;AAErE;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ,kDAAK,kEAAkE,MAAM;AACrF;AACA,QAAQ,kDAAK,2CAA2C,gBAAgB;;AAExE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+CAA+C,OAAO,IAAI,OAAO,aAAa,GAAG;AACjF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACO;AACP;AACA;AACA;;AAEA;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ,kDAAK,kEAAkE,MAAM;AACrF;AACA,QAAQ,kDAAK,sDAAsD,KAAK,IAAI;;AAE5E;AACA;AACA;AACA;AACA;AACA,8CAA8C,MAAM,gBAAgB,GAAG;AACvE;AACA,iDAAiD,MAAM,aAAa,GAAG;AACvE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,IAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,OAAO;AAChB;AACA,uBAAuB,KAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,QAAQ,kDAAK,mDAAmD,WAAW;;AAE3E;AACA;AACA,2BAA2B,wBAAwB;;AAEnD;AACA;AACA;AACA,8BAA8B,WAAW;;AAEzC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,QAAQ,kDAAK,mDAAmD,WAAW;;AAE3E;AACA;AACA,2BAA2B,WAAW;;AAEtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA,8BAA8B;AAC9B;AACA,QAAQ,kDAAK,sFAAsF,WAAW;;AAE9G;AACA;AACA;AACA;;AAEA;AACA,4CAA4C,MAAM,IAAI,MAAM;AAC5D;AACA,+CAA+C,EAAE,IAAI,EAAE;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACO;;AAEP;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,QAAQ,kDAAK,sFAAsF,WAAW;AAC9G;AACA,QAAQ,kDAAK,sEAAsE,KAAK,IAAI;;AAE5F;AACA;AACA;AACA,4CAA4C,MAAM;AAClD;AACA,+CAA+C,EAAE;AACjD;AACA,4CAA4C,MAAM;AAClD;AACA,kDAAkD,EAAE;AACpD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA,C;;;;;;;;;;;;ACzVA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACO,mEAAmE,mBAAO,CAAC,oHAAqD;;AAEvI;AACO,6EAA6E,mBAAO,CAAC,sGAA8C,E;;;;;;;;;;;;ACzB1I;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACO,oCAAoC,mBAAO,CAAC,wGAA+C;;AAElG;AACA;AACO,oGAAoG,mBAAO,CAAC,0GAAgD;;AAEnK;AACA;AACO,oCAAoC,mBAAO,CAAC,oGAA6C;;AAEhG;AACA;AACO,oCAAoC,mBAAO,CAAC,oGAA6C;;AAEhG;AACA;AACO,0CAA0C,mBAAO,CAAC,kHAAoD;;AAE7G;AACA;AACO,0CAA0C,mBAAO,CAAC,kHAAoD;;AAE7G;AACA;AACO,yCAAyC,mBAAO,CAAC,gHAAmD;;AAE3G;AACA;AACO,8CAA8C,mBAAO,CAAC,0HAAwD;;AAErH;AACO,iFAAiF,mBAAO,CAAC,sIAA8D;AACvJ,uEAAuE,mBAAO,CAAC,oIAA6D,E;;;;;;;;;;;;AC7EnJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACO,2BAA2B,mBAAO,CAAC,wFAAuC;AAC1E,6BAA6B,mBAAO,CAAC,4FAAyC;AAC9E,2BAA2B,mBAAO,CAAC,wFAAuC;AAC1E,6BAA6B,mBAAO,CAAC,4FAAyC;;AAErF;AACO,2CAA2C,mBAAO,CAAC,oGAA6C;AAChG,yEAAyE,mBAAO,CAAC,gJAAmE;AACpJ,kDAAkD,mBAAO,CAAC,4GAAiD;;AAElH;AACO,sBAAsB,mBAAO,CAAC,8EAAkC;;AAEvE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qDAAqD,MAAM;AAC3D;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,8CAA8C,MAAM;;AAEpD;AACA;AACA;AACA,C;;;;;;;;;;;;ACrHA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACO,4BAA4B,mBAAO,CAAC,gFAAmC;;AAE9E;AACO,yBAAyB,mBAAO,CAAC,4EAAiC,E;;;;;;;;;;;;ACzBzE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuD;AACd;AACa;AAC+B;AACuB;AAChD;;AAE5D;AACA;AACA;AACA;AACO,0BAA0B,kEAAe;AAChD;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mEAAQ;;AAExC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uCAAuC,iEAAc;AACrD,0DAA0D,oFAAiC;AAC3F,2CAA2C,qEAAkB;;AAE7D;AACA,6BAA6B,uDAAI;;AAEjC;AACA,+BAA+B,qDAAK;AACpC;AACA;AACA,aAAa;;AAEb,gCAAgC,qDAAK;AACrC;AACA;AACA,aAAa;;AAEb,gCAAgC,qDAAK;AACrC;AACA;AACA,aAAa;;;;AAIb;AACA;AACA;AACA,iCAAiC,mEAAK;AACtC;AACA;AACA,iCAAiC,mEAAK;AACtC;AACA;;AAEA;AACA;AACA,kCAAkC,mEAAK;AACvC;AACA;;AAEA,kCAAkC,mEAAK;AACvC;AACA;;AAEA;AACA;AACA,kCAAkC,mEAAK;AACvC;AACA;;AAEA,kCAAkC,mEAAK;AACvC;AACA;;AAEA;AACA,mCAAmC,4DAAS;AAC5C;;AAEA,qCAAqC,8DAAW;AAChD;;AAEA,mCAAmC,4DAAS;AAC5C;;AAEA,qCAAqC,8DAAW;AAChD;;AAEA,uCAAuC,8DAAW;AAClD;;AAEA,uCAAuC,8DAAW;AAClD;;AAEA;AACA,gCAAgC,gEAAK;AACrC;;AAEA,kCAAkC,gEAAK;AACvC;;AAEA,kCAAkC,gEAAK;AACvC;;AAEA,kCAAkC,gEAAK;AACvC;AACA;AACA;AACA,C;;;;;;;;;;;;AChJA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuD;AACJ;;AAEnD;AACA;AACA;AACA;AACO,uBAAuB,kEAAe;AAC7C;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wDAAQ;;AAEzC;AACA,8BAA8B,qDAAK;;AAEnC;AACA,+BAA+B,qDAAK;AACpC;AACA;AACA;AACA,C;;;;;;;;;;;;ACnDA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqC;;AAErC;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,uBAAuB;AAClC,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe,2EAAQ,IAAoB,WAAW,CAAC;;AAEvD,UAAU,iDAAO,iDAAiD,SAAS;AAC3E,C;;;;;;;;;;;AC/DA,uEAAuE,0BAA0B,gBAAgB,kCAAkC,6BAA6B,8BAA8B,GAAG,C;;;;;;;;;;;ACAjN,0CAA0C,0BAA0B,4BAA4B,gBAAgB,kCAAkC,+BAA+B,kBAAkB,yFAAyF,WAAW,oCAAoC,2BAA2B,GAAG,kEAAkE,GAAG,C;;;;;;;;;;;ACA9a,0CAA0C,0BAA0B,4BAA4B,6BAA6B,oEAAoE,mBAAmB,6BAA6B,0BAA0B,IAAI,mCAAmC,sBAAsB,4BAA4B,GAAG,iCAAiC,qDAAqD,GAAG,eAAe,GAAG,gBAAgB,aAAa,iBAAiB,kCAAkC,8CAA8C,iCAAiC,gBAAgB,uCAAuC,2CAA2C,gBAAgB,aAAa,WAAW,4BAA4B,2BAA2B,4EAA4E,QAAQ,GAAG,WAAW,wBAAwB,wBAAwB,4CAA4C,QAAQ,GAAG,YAAY,gBAAgB,QAAQ,GAAG,GAAG,GAAG,GAAG,C;;;;;;;;;;;ACA3iC;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0E;;;;;;;;;;;ACxBA,mT;;;;;;;;;;;ACAA,yPAAyP,0BAA0B,gIAAgI,GAAG,wGAAwG,8FAA8F,GAAG,gE;;;;;;;;;;;ACA/lB,gRAAgR,oEAAoE,GAAG,iFAAiF,yEAAyE,GAAG,C;;;;;;;;;;;ACApf,0DAA0D,uCAAuC,gBAAgB,kCAAkC,wBAAwB,2BAA2B,uCAAuC,uCAAuC,qDAAqD,sEAAsE,sEAAsE,iCAAiC,+CAA+C,+CAA+C,+CAA+C,iCAAiC,+CAA+C,+CAA+C,+CAA+C,kHAAkH,gCAAgC,gDAAgD,gCAAgC,gCAAgC,2IAA2I,2IAA2I,0EAA0E,0EAA0E,uCAAuC,qCAAqC,qCAAqC,uCAAuC,+CAA+C,iCAAiC,oEAAoE,wBAAwB,mFAAmF,kGAAkG,6BAA6B,sCAAsC,qEAAqE,mDAAmD,kDAAkD,+DAA+D,GAAG,C;;;;;;;;;;;ACArwE,0CAA0C,0BAA0B,gBAAgB,kCAAkC,yCAAyC,4CAA4C,iDAAiD,iDAAiD,iDAAiD,iDAAiD,kDAAkD,kDAAkD,kDAAkD,mDAAmD,mDAAmD,kDAAkD,mDAAmD,mDAAmD,iCAAiC,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,4DAA4D,4DAA4D,gDAAgD,qEAAqE,GAAG,C;;;;;;;;;;;ACAxnD,0CAA0C,0BAA0B,mDAAmD,iDAAiD,gBAAgB,kCAAkC,yCAAyC,4CAA4C,koBAAkoB,uMAAuM,2DAA2D,6BAA6B,2BAA2B,6BAA6B,2BAA2B,6BAA6B,2BAA2B,0DAA0D,qEAAqE,GAAG,C;;;;;;;;;;;ACA79C,0CAA0C,0BAA0B,gBAAgB,kCAAkC,yCAAyC,4CAA4C,iDAAiD,iDAAiD,iDAAiD,kDAAkD,kDAAkD,mDAAmD,kDAAkD,kDAAkD,iCAAiC,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,+CAA+C,qEAAqE,GAAG,C;;;;;;;;;;;ACAjsC,0CAA0C,0BAA0B,gBAAgB,iDAAiD,iDAAiD,iDAAiD,kDAAkD,kDAAkD,mDAAmD,kDAAkD,kDAAkD,mFAAmF,kCAAkC,2CAA2C,iCAAiC,GAAG,C;;;;;;;;;;;ACAtqB,0CAA0C,0BAA0B,gBAAgB,kCAAkC,4BAA4B,kCAAkC,gCAAgC,6FAA6F,yCAAyC,oBAAoB,gCAAgC,iDAAiD,iDAAiD,iDAAiD,kDAAkD,kDAAkD,mDAAmD,kDAAkD,kDAAkD,oIAAoI,sBAAsB,2CAA2C,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,8BAA8B,2BAA2B,iCAAiC,YAAY,iCAAiC,YAAY,iCAAiC,YAAY,iCAAiC,YAAY,GAAG,cAAc,2BAA2B,gCAAgC,YAAY,gCAAgC,YAAY,gCAAgC,YAAY,gCAAgC,YAAY,GAAG,cAAc,wDAAwD,GAAG,QAAQ,gCAAgC,GAAG,GAAG,GAAG,GAAG,C;;;;;;;;;;;ACAlrF,0CAA0C,0BAA0B,gBAAgB,kCAAkC,4BAA4B,kCAAkC,gCAAgC,6FAA6F,yCAAyC,oBAAoB,gCAAgC,iDAAiD,iDAAiD,iDAAiD,iDAAiD,kDAAkD,kDAAkD,kDAAkD,mDAAmD,mDAAmD,kDAAkD,mDAAmD,mDAAmD,oIAAoI,sBAAsB,2CAA2C,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,iBAAiB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,eAAe,SAAS,yBAAyB,EAAE,aAAa,EAAE,iBAAiB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,eAAe,SAAS,yBAAyB,EAAE,aAAa,EAAE,8BAA8B,2BAA2B,iCAAiC,YAAY,iCAAiC,YAAY,iCAAiC,YAAY,iCAAiC,YAAY,iCAAiC,YAAY,iCAAiC,YAAY,GAAG,cAAc,2BAA2B,gCAAgC,YAAY,gCAAgC,YAAY,gCAAgC,YAAY,gCAAgC,YAAY,gCAAgC,YAAY,gCAAgC,YAAY,GAAG,cAAc,wDAAwD,GAAG,QAAQ,gCAAgC,GAAG,GAAG,GAAG,GAAG,C;;;;;;;;;;;ACAtnH,0CAA0C,0BAA0B,yCAAyC,gBAAgB,kCAAkC,kCAAkC,4BAA4B,gCAAgC,kEAAkE,yCAAyC,4CAA4C,iDAAiD,iDAAiD,kDAAkD,mDAAmD,gIAAgI,iDAAiD,iDAAiD,iDAAiD,kDAAkD,kDAAkD,kDAAkD,mDAAmD,oDAAoD,oDAAoD,mDAAmD,mDAAmD,mDAAmD,mWAAmW,8vEAA8vE,2CAA2C,GAAG,C;;;;;;;;;;;ACAv8H,sEAAsE,0BAA0B,+BAA+B,8CAA8C,4BAA4B,yCAAyC,mDAAmD,iDAAiD,gBAAgB,kCAAkC,kCAAkC,4BAA4B,yCAAyC,4CAA4C,gCAAgC,oEAAoE,yBAAyB,eAAe,+BAA+B,+BAA+B,mBAAmB,oBAAoB,mOAAmO,oqBAAoqB,uhBAAuhB,8vEAA8vE,8DAA8D,uMAAuM,2DAA2D,6BAA6B,2BAA2B,6BAA6B,2BAA2B,6BAA6B,2BAA2B,0DAA0D,sCAAsC,iDAAiD,oDAAoD,oEAAoE,GAAG,GAAG,C;;;;;;;;;;;ACA/pK,sEAAsE,wBAAwB,8CAA8C,8BAA8B,kGAAkG,kCAAkC,gEAAgE,gBAAgB,8BAA8B,wEAAwE,8CAA8C,8CAA8C,+CAA+C,+CAA+C,gDAAgD,+CAA+C,+CAA+C,6CAA6C,uEAAuE,iFAAiF,8CAA8C,8CAA8C,8CAA8C,8CAA8C,+CAA+C,+CAA+C,+CAA+C,+CAA+C,gDAAgD,iDAAiD,iDAAiD,gDAAgD,gDAAgD,gDAAgD,gDAAgD,mFAAmF,qHAAqH,gFAAgF,8CAA8C,8CAA8C,8CAA8C,+CAA+C,+CAA+C,+CAA+C,gDAAgD,gDAAgD,+CAA+C,gDAAgD,gDAAgD,+CAA+C,+CAA+C,gDAAgD,gDAAgD,mFAAmF,sHAAsH,kEAAkE,4CAA4C,sEAAsE,wEAAwE,mtBAAmtB,+4CAA+4C,84CAA84C,8EAA8E,uGAAuG,kGAAkG,uFAAuF,mHAAmH,8GAA8G,0EAA0E,oDAAoD,mCAAmC,GAAG,C;;;;;;;;;;;ACA3zO,sEAAsE,8CAA8C,8BAA8B,gBAAgB,kCAAkC,kCAAkC,gEAAgE,6BAA6B,gBAAgB,8BAA8B,8CAA8C,8CAA8C,8CAA8C,+CAA+C,+CAA+C,gDAAgD,+CAA+C,+CAA+C,sZAAsZ,0DAA0D,mEAAmE,oDAAoD,mCAAmC,GAAG,C;;;;;;;;;;;ACAp1C,0CAA0C,gBAAgB,kCAAkC,4BAA4B,2BAA2B,wDAAwD,GAAG,C;;;;;;;;;;;ACA9M,0CAA0C,gBAAgB,kCAAkC,yDAAyD,8BAA8B,GAAG,C;;;;;;;;;;;ACAtL,0CAA0C,gBAAgB,kCAAkC,yDAAyD,8BAA8B,GAAG,C;;;;;;;;;;;ACAtL,gDAAgD,iCAAiC,gBAAgB,kCAAkC,+EAA+E,qFAAqF,qGAAqG,GAAG,C;;;;;;;;;;;ACA/Y,2CAA2C,2BAA2B,gBAAgB,+BAA+B,+BAA+B,iDAAiD,GAAG,C;;;;;;;;;;;ACAxM,0CAA0C,2BAA2B,gCAAgC,uDAAuD,kCAAkC,4BAA4B,0DAA0D,0CAA0C,kCAAkC,qDAAqD,mEAAmE,mEAAmE,mEAAmE,yIAAyI,oQAAoQ,yCAAyC,GAAG,C;;;;;;;;;;;ACAvhC,0CAA0C,gBAAgB,kCAAkC,0CAA0C,uFAAuF,GAAG,C;;;;;;;;;;;ACAhO,0CAA0C,gBAAgB,kCAAkC,0CAA0C,yDAAyD,iGAAiG,GAAG,C;;;;;;;;;;;ACAnS,0CAA0C,eAAe,+BAA+B,qCAAqC,8BAA8B,GAAG,C;;;;;;;;;;;ACA9J,0CAA0C,gBAAgB,6BAA6B,GAAG,C;;;;;;;;;;;;ACA1F;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoD;AACZ;AACD;AACW;AACE;AACE;AACI;AACF;AACA;;AAExD;AACA,iCAAiC;AACjC,6BAA6B;AAC7B,4BAA4B;;AAE5B;AACA;AACA;AACA,aAAa,8DAAQ;AACrB,cAAc,gEAAS;AACvB,eAAe,kEAAU;AACzB,iBAAiB,sEAAY;AAC7B,gBAAgB,oEAAW;AAC3B,gBAAgB,oEAAW;AAC3B;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,kDAAK,iDAAiD,YAAY,KAAK,aAAa;AAChG;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,YAAY,kDAAK,iCAAiC,GAAG;;AAErD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,YAAY,kDAAK,uCAAuC,GAAG;;AAE3D;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,0FAA0F;AACzG,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,kDAAK;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,oDAAO;;AAEzB;AACA;AACA;AACA;AACA;AACA,gBAAgB,oDAAO;AACvB;AACA;AACA,YAAY,kDAAK,sCAAsC,MAAM,KAAK,OAAO;AACzE;AACA,gBAAgB,oDAAO;AACvB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ,oDAAO;AACf;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,iBAAiB,cAAc;AAC/B;AACA,yCAAyC,EAAE;AAC3C;AACA;;AAEA,mBAAmB,gEAAa;AAChC;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD,qBAAqB;AACrB;AACA;AACA,8BAA8B;AAC9B,aAAa;AACb;AACA;AACA,kBAAkB,oDAAO;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,kDAAK;AACrB;AACA,SAAS;AACT;AACA;AACA,gBAAgB,kDAAK;AACrB;AACA,SAAS;;AAET;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,oBAAoB;AAC1C,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,oDAAO;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,oDAAO;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,cAAc,oDAAO;;AAErB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,SAAS;AACT;AACA,C;;;;;;;;;;;;ACnaA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE8D;AACtB;AACD;;AAEvC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB;AACA,2CAA2C,EAAE;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,4CAA4C,MAAM,KAAK,OAAO;;AAE9D;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA,0BAA0B,oDAAO,8CAA8C,UAAU;AACzF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,oDAAO;;AAEzB;AACA;;AAEA;AACA,iCAAiC,iBAAiB;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,QAAQ,GAAG,aAAa;AAC7E,0BAA0B,oDAAO,uDAAuD,QAAQ;AAChG,8BAA8B,+BAA+B,QAAQ,GAAG,EAAE,KAAK;AAC/E;AACA;AACA;AACA,sBAAsB,oDAAO,+CAA+C,QAAQ,KAAK,QAAQ;AACjG;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,oDAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,oDAAO,qBAAqB,MAAM,iCAAiC,oCAAoC;AAC7H;AACA,sBAAsB,oDAAO;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oDAAO,mDAAmD,MAAM;AACtF;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sBAAsB,eAAe;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,+CAA+C;AAC/C,yCAAyC;AACzC,sBAAsB;;AAEtB;AACA;AACA;AACA,wFAAwF;AACxF;AACA;AACA;AACA;AACA,0BAA0B,oDAAO,gDAAgD,KAAK;AACtF;AACA,8BAA8B,YAAY;AAC1C,gCAAgC,MAAM,GAAG,EAAE,OAAO;AAClD;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oDAAO,6CAA6C,KAAK;;AAEvE;AACA;;;;;;AAMA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;AAKA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC;AACvC,yDAAyD;AACzD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;;AAEA;AACA;;AAEA;AACA,oBAAoB;AACpB;AACA;AACA;;AAEA;AACA,cAAc;AACd,oFAAoF,EAAE;AACtF;AACA;AACA,mBAAmB,0EAAkB;AACrC,oBAAoB,oDAAO;;AAE3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,oDAAO,gCAAgC,gBAAgB;;AAEzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oDAAO,uCAAuC,MAAM;AAC1E;;AAEA;AACA,YAAY,sCAAsC;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,oDAAO;AAC3B,gBAAgB,oDAAO;;AAEvB;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,QAAQ,oDAAO;AACf;AACA;;AAEA;AACA,QAAQ,oDAAO;AACf;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,WAAW,oDAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL,C;;;;;;;;;;;;AC3tBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkD;AACM;AACP;;AAEjD;AACA;AACA;AACA;AACA,eAAe,oDAAoD;AACnE,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA,0CAA0C,EAAE;AAC5C;AACA,eAAe,8DAAW;AAC1B;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA,+DAA+D,mBAAmB;AAClF;AACA,eAAe,8DAAW;AAC1B;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,oEAAc;AACjC;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,eAAe,OAAkB;AACjC;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,yBAAyB,QAAQ,6DAAU,cAAc;AACzD;AACA;AACA;;AAEO;AACA;AACA;AACA;AACA,uB;;;;;;;;;;;;ACrFP;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC9CA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgC;AAChC;AACA,4BAA4B;;AAErB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,4CAAK;;AAEjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgC;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,4CAAK,gCAAgC,WAAW;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC,aAAa;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAK,8BAA8B,SAAS,GAAG,SAAS;AACpE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,wBAAwB;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,yBAAyB;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA,sDAAsD;;AAEtD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA,wCAAwC,4CAAK;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,4CAAK,yBAAyB;AACrD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC9vBA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgC;;AAEzB,kBAAkB,4CAAK;AAC9B;AACA;AACA;AACA;AACA;;AAEO,oBAAoB,4CAAK;AAChC;AACA;AACA;AACA,E;;;;;;;;;;;;AClCA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsC;;AAE/B;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,UAAU;AAC1B,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA,kBAAkB,mDAAW;AAC7B;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,UAAU;AAC1B,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,UAAU;AAC1B,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,sBAAsB,mDAAW;AACjC;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,0EAA0E,EAAE;AAC5E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA,iCAAiC,mBAAmB,EAAE;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,mBAAmB,EAAE;AACjC;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ,EAAE,QAAQ;AAC1C,wBAAwB,EAAE,EAAE,QAAQ,iBAAiB,EAAE,EAAE,QAAQ;AACjE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wEAAwE,WAAW;AACnF;AACA,kEAAkE,MAAM;;AAExE;AACA;AACA;;AAEA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;;AAEA,0BAA0B,WAAW,UAAU;AAC/C,0BAA0B,WAAW,UAAU;;AAE/C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,C","file":"speedy-vision.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/speedy.js\");\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * brisk.js\n * Modified BRISK algorithm\n */\n\nimport { Utils } from '../../utils/utils';\n\nlet gaussians = null;\nlet shortPairs = null, longPairs = null;\n\n/**\n * BRISK feature detection\n */\nexport class BRISK\n{\n    /**\n     * BRISK feature detection algorithm\n     * @param {SpeedyGPU} gpu\n     * @param {Texture} greyscale Greyscale image\n     * @param {object} settings\n     * @returns {Texture} features in a texture\n     */\n    static run(gpu, greyscale, settings)\n    {\n        const MIN_DEPTH = 1, MAX_DEPTH = gpu.pyramidHeight;\n\n        // clamp settings.depth (height of the image pyramid)\n        settings.depth = Math.max(MIN_DEPTH, Math.min(settings.depth, MAX_DEPTH)) | 0;\n\n        // create the pyramid\n        const pyramid = new Array(settings.depth);\n        const intraPyramid = new Array(pyramid.length + 1);\n        pyramid[0] = gpu.pyramid(0).pyramids.setBase(greyscale); // base of the pyramid\n        for(let i = 1; i < pyramid.length; i++)\n            pyramid[i] = gpu.pyramid(i-1).pyramids.reduce(pyramid[i-1]);\n        intraPyramid[0] = gpu.pyramid(0).pyramids.intraExpand(pyramid[0]); // 1.5 * sizeof(base)\n        for(let i = 1; i < intraPyramid.length; i++)\n            intraPyramid[i] = gpu.intraPyramid(i-1).pyramids.reduce(intraPyramid[i-1]);\n\n        // get FAST corners of all pyramid levels\n        const pyramidCorners = new Array(pyramid.length);\n        const intraPyramidCorners = new Array(intraPyramid.length);\n        for(let j = 0; j < pyramidCorners.length; j++) {\n            pyramidCorners[j] = gpu.pyramid(j).keypoints.fast9(pyramid[j], settings.threshold);\n        }\n        for(let j = 0; j < intraPyramidCorners.length; j++) {\n            intraPyramidCorners[j] = gpu.intraPyramid(j).keypoints.fast9(intraPyramid[j], settings.threshold);\n        }\n\n        // scale space non-maximum suppression & interpolation\n        const lgM = Math.log2(gpu.pyramidMaxScale), h = gpu.pyramidHeight;\n        const suppressedPyramidCorners = new Array(pyramidCorners.length);\n        const suppressedIntraPyramidCorners = new Array(intraPyramidCorners.length);\n        suppressedIntraPyramidCorners[0] = gpu.intraPyramid(0).keypoints.brisk(intraPyramidCorners[0], intraPyramidCorners[0], pyramidCorners[0], 1.0, 2.0 / 3.0, lgM, h);\n        for(let j = 0; j < suppressedPyramidCorners.length; j++) {\n            suppressedPyramidCorners[j] = gpu.pyramid(j).keypoints.brisk(pyramidCorners[j], intraPyramidCorners[j], intraPyramidCorners[j+1], 1.5, 0.75, lgM, h);\n            if(j+1 < suppressedPyramidCorners.length)\n                suppressedIntraPyramidCorners[j+1] = gpu.intraPyramid(j+1).keypoints.brisk(intraPyramidCorners[j+1], pyramidCorners[j], pyramidCorners[j+1], 4.0 / 3.0, 2.0 / 3.0, lgM, h);\n            else\n                suppressedIntraPyramidCorners[j+1] = gpu.intraPyramid(j+1).keypoints.brisk(intraPyramidCorners[j+1], pyramidCorners[j], intraPyramidCorners[j+1], 4.0 / 3.0, 1.0, lgM, h);\n        }\n\n        // merge all keypoints\n        for(let j = suppressedPyramidCorners.length - 2; j >= 0; j--)\n            suppressedPyramidCorners[j] = gpu.pyramid(j).pyramids.mergeKeypointsAtConsecutiveLevels(suppressedPyramidCorners[j], suppressedPyramidCorners[j+1]);\n        for(let j = suppressedIntraPyramidCorners.length - 2; j >= 0; j--)\n            suppressedIntraPyramidCorners[j] = gpu.intraPyramid(j).pyramids.mergeKeypointsAtConsecutiveLevels(suppressedIntraPyramidCorners[j], suppressedIntraPyramidCorners[j+1]);\n        suppressedIntraPyramidCorners[0] = gpu.intraPyramid(0).pyramids.normalizeKeypoints(suppressedIntraPyramidCorners[0], 1.5);\n        suppressedIntraPyramidCorners[0] = gpu.pyramid(0).pyramids.crop(suppressedIntraPyramidCorners[0]);\n        const keypoints = gpu.pyramid(0).pyramids.mergeKeypoints(suppressedPyramidCorners[0], suppressedIntraPyramidCorners[0]);\n\n        // create gaussian kernels for different scales and radii\n        if(0 && gaussians == null) {\n            // work with scales: sqrt(2), 1, 1/sqrt(2), 1/2, ...\n            const quantizedScales = [...Array(pyramid.length + intraPyramid.length).keys()]\n                .map(i => Math.pow(2.0, 0.5 * (1 - i))); // i == 1 - 2 * log2(v[i])\n\n            // for each scale, a brisk pattern produces 5 layers with different radii\n            const scaledPatterns = quantizedScales.map(briskPattern);\n            Utils.assert(\n                scaledPatterns[0].length == 5, // scaledPatterns is a n x 5 array\n                'Invalid BRISK pattern'\n            );\n\n            // create gaussian kernels\n            const kernels = scaledPatterns.map(layers => // 2D array\n                //layers.map(layer => gpu.filters.createGaussianKernel11x1(layer.r))\n                layers.map(layer => 0) // FIXME\n            );\n            const sigmas = scaledPatterns.map(layers =>\n                layers.map(layer => layer.r)\n            );\n            const distancesFromKeypoint = scaledPatterns.map(layers =>\n                layers.map(layer => layer.l)\n            );\n\n            // flatten 2D array\n            const flatten = arr => arr.reduce((v, e) => v.concat(e), []);\n\n            // index:   [ 0 , ... , 4 | 5 , ... , 9 | 10 , ... , 14 | ... ]\n            // scale:       sqrt(2)   |       1     |  1 / sqrt(2)  | ...\n            // sigma:  r1,r10,...,r20 | r1,r10,...  | r1,r10,...    | ...\n            gaussians = {\n                kernel: flatten(kernels),\n                sigma: flatten(sigmas),\n                distanceFromKeypoint: flatten(distancesFromKeypoint),\n            };\n            //console.log(gaussians);\n        }\n\n        // done!\n        return keypoints;\n    }\n\n    /**\n     * Short distance pairings,\n     * for scale = 1.0. Format:\n     * [x1,y1,x2,y2, ...]. Thus,\n     * 4 elements for each pair\n     * @returns {Float32Array<number>} flattened array\n     */\n    static get shortDistancePairs()\n    {\n        return shortPairs || (shortPairs = briskShortDistancePairs());\n    };\n\n    /**\n     * Long distance pairings,\n     * for scale = 1.0. Format:\n     * [x1,y1,x2,y2, ...]. Thus,\n     * 4 elements for each pair\n     * @returns {Float32Array<number>} flattened array\n     */\n    static get longDistancePairs()\n    {\n        return longPairs || (longPairs = briskLongDistancePairs());\n    }\n}\n\n/**\n * (Modified) BRISK pattern for 60 points:\n * 5 layers with k_l colliding circles,\n * each at a distance l_l from the origin\n * with radius r_l. For each layer l=0..4,\n * we have k_l = [1,10,14,15,20] circles\n *\n * @param {number} [scale] pattern scale\n *                 (e.g, 1, 0.5, 0.25...)\n * @returns {Array<object>}\n */\nfunction briskPattern(scale = 1.0)\n{\n    const piOverTwo = Math.PI / 2.0;\n    const baseDistance = 4.21; // innermost layer for scale = 1\n\n    const s10 = Math.sin(piOverTwo / 10);\n    const s14 = Math.sin(piOverTwo / 14);\n    const s15 = Math.sin(piOverTwo / 15);\n    const s20 = Math.sin(piOverTwo / 20);\n\n    const l10 = baseDistance * scale;\n    const r10 = 2 * l10 * s10;\n\n    const r14 = (2 * (l10 + r10) * s14) / (1 - 2 * s14);\n    const l14 = l10 + r10 + r14;\n\n    const r15 = (2 * (l14 + r14) * s15) / (1 - 2 * s15);\n    const l15 = l14 + r14 + r15;\n\n    const r20 = (2 * (l15 + r15) * s20) / (1 - 2 * s20);\n    const l20 = l15 + r15 + r20;\n\n    const r1 = r10 * 0.8; // guess & plot!\n    const l1 = 0.0;\n\n    return [\n        { n: 1, r: r1, l: l1 },\n        { n: 10, r: r10, l: l10 },\n        { n: 14, r: r14, l: l14 },\n        { n: 15, r: r15, l: l15 },\n        { n: 20, r: r20, l: l20 },\n    ];\n}\n\n/**\n * BRISK points given a\n * {n, r, l} BRISK layer\n * @param {object} layer\n * @returns {Array<object>}\n */\nfunction briskPoints(layer)\n{\n    const { n, r, l } = layer;\n    const twoPi = 2.0 * Math.PI;\n\n    return [...Array(n).keys()].map(j => ({\n        x: l * Math.cos(twoPi * j / n),\n        y: l * Math.sin(twoPi * j / n),\n        r, l, j, n,\n    }));\n}\n\n/**\n * BRISK pair of points such that\n * the distance of each is greater\n * than (threshold*scale), or less\n * than (-threshold*scale) if\n * threshold < 0\n * @param {number} threshold\n * @param {number} [scale] pattern scale\n * @returns {Float32Array<number>} format [x1,y1,x2,y2, ...]\n */\nfunction briskPairs(threshold, scale = 1.0)\n{\n    const flatten = arr => arr.reduce((v, e) => v.concat(e), []);\n    const p = flatten(briskPattern(scale).map(briskPoints));\n    const n = p.length, t = +threshold * scale;\n\n    const dist2 = (p, q) => (p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y);\n    const wanted = (t < 0) ? ((p,q) => dist2(p,q) < t*t) : ((p,q) => dist2(p,q) > t*t);\n    const pairs = [];\n\n    for(let i = 1; i < n; i++) {\n        for(let j = 0; j < i; j++) {\n            if(wanted(p[i], p[j])) {\n                pairs.push(p[i].x);\n                pairs.push(p[i].y);\n                pairs.push(p[j].x);\n                pairs.push(p[j].y);\n            }\n        }\n    }\n\n    return new Float32Array(pairs);\n}\n\n/**\n * BRISK short distance pairs\n * @param {number} threshold pick pairs with distance < threshold*scale\n * @param {number} [scale] pattern scale\n * @returns {Float32Array<number>} format [x1,y1,x2,y2, ...]\n */\nfunction briskShortDistancePairs(threshold = 9.75, scale = 1.0)\n{\n    return briskPairs(-threshold, scale);\n}\n\n/**\n * BRISK long distance pairs\n * @param {number} threshold pick pairs with distance > threshold*scale\n * @param {number} [scale] pattern scale\n * @returns {Float32Array<number>} format [x1,y1,x2,y2, ...]\n */\nfunction briskLongDistancePairs(threshold = 13.67, scale = 1.0)\n{\n    return briskPairs(threshold, scale);\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * fast.js\n * FAST corner detection\n */\n\nimport { Utils } from '../../utils/utils';\nimport { GLUtils } from '../../gpu/gl-utils';\n\n/**\n * FAST corner detection\n */\nexport class FAST\n{\n    /**\n     * Run the FAST corner detection algorithm\n     * @param {SpeedyGPU} gpu\n     * @param {WebGLTexture} greyscale Greyscale image\n     * @param {number} n FAST parameter: 9, 7 or 5\n     * @param {object} settings\n     * @returns {WebGLTexture} corners\n     */\n    static run(gpu, greyscale, n, settings)\n    {\n        // validate input\n        Utils.assert(\n            n == 9 || n == 7 || n == 5,\n            `Not implemented: FAST-${n}`\n        );\n\n        // default settings\n        if(!settings.hasOwnProperty('threshold'))\n            settings.threshold = 10;\n\n        // virtual table\n        const vtable = this.run._vtable || (this.run._vtable = {\n            5: gpu => gpu.keypoints.fast5,\n            7: gpu => gpu.keypoints.fast7,\n            9: gpu => gpu.keypoints.fast9,\n        });\n\n        // keypoint detection\n        const fast = (vtable[n])(gpu);\n        return fast(greyscale, settings.threshold);\n    }\n\n    /**\n     * Sensitivity to threshold conversion\n     * sensitivity in [0,1] -> pixel intensity threshold in [0,1]\n     * performs a non-linear conversion (used for FAST)\n     * @param {number} sensitivity\n     * @returns {number} pixel intensity\n     */\n    static sensitivity2threshold(sensitivity)\n    {\n        // the number of keypoints ideally increases linearly\n        // as the sensitivity is increased\n        sensitivity = Math.max(0, Math.min(sensitivity, 1));\n        return 1 - Math.tanh(2.77 * sensitivity);\n    }\n\n    /**\n     * Normalize a threshold\n     * pixel threshold in [0,255] -> normalized threshold in [0,1]\n     * @returns {number} clamped & normalized threshold\n     */\n    static normalizedThreshold(threshold)\n    {\n        threshold = Math.max(0, Math.min(threshold, 255));\n        return threshold / 255;\n    }\n}\n\n/**\n * FAST corner detector augmented with scale & orientation\n */\nexport class FASTPlus extends FAST\n{\n     /**\n     * Run the FAST corner detection algorithm\n     * @param {SpeedyGPU} gpu\n     * @param {WebGLTexture} greyscale Greyscale image\n     * @param {number} n must be 9\n     * @param {object} settings\n     * @returns {WebGLTexture} corners\n     */\n    static run(gpu, greyscale, n, settings)\n    {\n        // validate input\n        Utils.assert(\n            n == 9,\n            `Not implemented: FAST-${n}-plus`\n        );\n\n        // default settings\n        if(!settings.hasOwnProperty('threshold'))\n            settings.threshold = 10;\n        if(!settings.hasOwnProperty('depth'))\n            settings.depth = 3; // how many pyramid levels to check\n\n        // prepare data\n        const MIN_DEPTH = 1, MAX_DEPTH = gpu.pyramidHeight;\n        const depth = Math.max(MIN_DEPTH, Math.min(settings.depth | 0, MAX_DEPTH));\n        const maxLod = depth - 1;\n        const log2PyrMaxScale = Math.log2(gpu.pyramidMaxScale);\n        const pyrMaxLevels = gpu.pyramidHeight;\n\n        // generate pyramid\n        const pyramid = greyscale;\n        GLUtils.generateMipmap(gpu.gl, pyramid);\n\n        // select algorithm\n        const fastPyr = gpu.keypoints.fast9pyr;\n\n        // keypoint detection\n        let multiScaleCorners = fastPyr(pyramid, settings.threshold, 0.0, Math.min(1.0, maxLod), log2PyrMaxScale, pyrMaxLevels, true);\n        if(maxLod > 1.0) {\n            // nao, os dois precisam receber pyramid que tem o mipmap\n            // e fazer merge depois\n            const tmp = gpu.utils.identity(multiScaleCorners);\n            multiScaleCorners = fastPyr(tmp, settings.threshold, 2.0, maxLod, log2PyrMaxScale, pyrMaxLevels, false);\n        }\n        const orientedMultiScaleCorners = multiScaleCorners; // TODO\n\n        // non-maximum suppression\n        const suppressed1 = gpu.keypoints.samescaleSuppression(orientedMultiScaleCorners, log2PyrMaxScale, pyrMaxLevels);\n        const suppressed2 = gpu.keypoints.multiscaleSuppression(suppressed1, 1.0, log2PyrMaxScale, pyrMaxLevels);\n        return suppressed2;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * feature-detector.js\n * Feature detection facade\n */\n\nimport { FAST, FASTPlus } from './algorithms/fast.js';\nimport { BRISK } from './algorithms/brisk.js';\nimport { OnlineErrorTuner, TestTuner } from '../utils/tuner';\nimport { Utils } from '../utils/utils';\n\n// constants\nconst OPTIMIZER_GROWTH_WEIGHT = 0.02; // in [0,1]\n\n/**\n * FeatureDetector encapsulates\n * feature detection algorithms\n */\nexport class FeatureDetector\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {boolean} [optimizeForDynamicUsage] optimize for calling the feature detector continuously\n     */\n    constructor(gpu, optimizeForDynamicUsage)\n    {\n        this._gpu = gpu;\n        this._lastKeypointCount = 0;\n        this._sensitivityTuner = null;\n        this._optimizeForDynamicUsage = optimizeForDynamicUsage;\n    }\n\n    /**\n     * FAST corner detection\n     * @param {SpeedyMedia} media The media\n     * @param {number} [n] We'll run FAST-n, where n must be 9 (default), 7 or 5\n     * @param {object} [settings] Additional settings\n     * @returns {Promise<Array<SpeedyFeature>>} keypoints\n     */\n    fast(media, n = 9, settings = {})\n    {\n        const gpu = this._gpu;\n\n        // default settings\n        settings = {\n            threshold: 10,\n            denoise: true,\n            ...settings\n        };\n\n        // convert the expected number of keypoints,\n        // if defined, into a sensitivity value\n        if(settings.hasOwnProperty('expected'))\n            settings.sensitivity = this._findSensitivity(settings.expected);\n\n        // convert a sensitivity value in [0,1],\n        // if it's defined, to a FAST threshold\n        if(settings.hasOwnProperty('sensitivity'))\n            settings.threshold = FAST.sensitivity2threshold(settings.sensitivity);\n        else\n            settings.threshold = FAST.normalizedThreshold(settings.threshold);\n\n        // pre-processing the image...\n        const source = media._gpu.upload(media.source);\n        const texture = settings.denoise ? gpu.filters.gauss5(source) : source;\n        const greyscale = gpu.colors.rgb2grey(texture);\n\n        // extract features\n        const keypoints = FAST.run(gpu, greyscale, n, settings);\n        return this._extractKeypoints(keypoints, this._optimizeForDynamicUsage);\n    }\n\n    /**\n     * FAST corner detection augmented with scale & orientation\n     * @param {SpeedyMedia} media The media\n     * @param {number} [n] must be 9\n     * @param {object} [settings] Additional settings\n     * @returns {Promise<Array<SpeedyFeature>>} keypoints\n     */\n    fastPlus(media, n = 9, settings = {})\n    {\n        const gpu = this._gpu;\n\n        // default settings\n        settings = {\n            depth: 3,\n            threshold: 10,\n            denoise: true,\n            ...settings\n        };\n\n        // convert the expected number of keypoints,\n        // if defined, into a sensitivity value\n        if(settings.hasOwnProperty('expected'))\n            settings.sensitivity = this._findSensitivity(settings.expected);\n\n        // convert a sensitivity value in [0,1],\n        // if it's defined, to a FAST threshold\n        if(settings.hasOwnProperty('sensitivity'))\n            settings.threshold = FASTPlus.sensitivity2threshold(settings.sensitivity);\n        else\n            settings.threshold = FASTPlus.normalizedThreshold(settings.threshold);\n\n        // pre-processing the image...\n        const source = media._gpu.upload(media.source);\n        const texture = settings.denoise ? gpu.filters.gauss5(source) : source;\n        const greyscale = gpu.colors.rgb2grey(texture);\n\n        // extract features\n        const keypoints = FASTPlus.run(gpu, greyscale, n, settings);\n        return this._extractKeypoints(keypoints, this._optimizeForDynamicUsage);\n    }\n\n    /**\n     * BRISK feature point detection\n     * @param {SpeedyMedia} media The media\n     * @param {object} [settings]\n     * @returns {Promise<Array<SpeedyFeature>>}\n     */\n    brisk(media, settings = {})\n    {\n        const gpu = this._gpu;\n\n        // default settings\n        settings = {\n            threshold: 10,\n            denoise: true,\n            depth: 4,\n            ...settings\n        };\n\n        // convert settings.expected to settings.sensitivity\n        if(settings.hasOwnProperty('expected'))\n            settings.sensitivity = this._findSensitivity(settings.expected);\n\n        // convert settings.sensitivity to settings.threshold\n        if(settings.hasOwnProperty('sensitivity'))\n            settings.threshold = FAST.sensitivity2threshold(settings.sensitivity);\n        else\n            settings.threshold = FAST.normalizedThreshold(settings.threshold);\n\n        // pre-processing the image...\n        const source = media._gpu.upload(media.source);\n        const texture = settings.denoise ? gpu.filters.gauss5(source) : source;\n        const greyscale = gpu.colors.rgb2grey(texture);\n\n        // extract features\n        const keypoints = BRISK.run(gpu, greyscale, settings);\n        return this._extractKeypoints(keypoints, this._optimizeForDynamicUsage);\n    }\n\n    // given a corner-encoded texture, return a Promise\n    // that resolves to an Array of keypoints\n    _extractKeypoints(corners, useAsyncTransfer = true, gpu = this._gpu)\n    {\n        return gpu.encoders.encodeKeypoints(corners, useAsyncTransfer).then(encodedKeypoints => {\n            // when processing a video, we expect that the number of keypoints\n            // in time is a relatively smooth curve\n            const keypoints = gpu.encoders.decodeKeypoints(encodedKeypoints);\n            const currCount = Math.max(keypoints.length, 64); // may explode if abrupt video changes\n            const prevCount = Math.max(this._lastKeypointCount, 64);\n            const newCount = Math.ceil(OPTIMIZER_GROWTH_WEIGHT * currCount + (1.0 - OPTIMIZER_GROWTH_WEIGHT) * prevCount);\n\n            gpu.encoders.optimizeKeypointEncoder(newCount);\n            this._lastKeypointCount = newCount;\n            //document.querySelector('mark').innerHTML = gpu.encoders._keypointEncoderLength;\n\n            // let's cap it if keypoints.length explodes (noise)\n            if(useAsyncTransfer && keypoints.length > newCount)\n                return keypoints.slice(0, newCount);\n            else\n                return keypoints;\n        }).catch(err => {\n            throw err;\n        });\n    }\n\n    // find a sensitivity value in [0,1] such that\n    // the feature detector returns approximately the\n    // number of features you expect - within a\n    // tolerance, i.e., a percentage value\n    _findSensitivity(param)\n    {\n        // grab the parameters\n        const expected = {\n            number: 0, // how many keypoints do you expect?\n            tolerance: 0.10, // percentage relative to the expected number of keypoints\n            ...(typeof param == 'object' ? param : {\n                number: param | 0,\n            })\n        };\n\n        // show warning if static usage\n        if(!this._optimizeForDynamicUsage && !this._findSensitivity._warning) {\n            Utils.warning(`Finding an expected number of features in a media configured for static usage`);\n            this._findSensitivity._warning = true;\n        }\n\n        // spawn the tuner\n        this._sensitivityTuner = this._sensitivityTuner ||\n            new OnlineErrorTuner(0, 1200); // use a slightly wider interval for better stability\n            //new TestTuner(0, 1000);\n        const normalizer = 0.001;\n\n        // update tuner\n        this._sensitivityTuner.tolerance = Math.max(expected.tolerance, 0);\n        this._sensitivityTuner.feedObservation(this._lastKeypointCount, Math.max(expected.number, 0));\n        const sensitivity = this._sensitivityTuner.currentValue() * normalizer;\n\n        // return the new sensitivity\n        return Math.max(0, Math.min(sensitivity, 1));\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * pipeline-operations.js\n * A pipeline operation is an element of a SpeedyPipeline\n */\n\nimport { ColorFormat } from '../utils/types';\nimport { Utils } from '../utils/utils';\nimport { GLUtils } from '../gpu/gl-utils';\n\nexport const PipelineOperation = { };\n\n/**\n * Abstract basic operation\n */\n/* abstract */ class SpeedyPipelineOperation\n{\n    /**\n     * Runs the pipeline operation\n     * @param {Texture} texture\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyMedia} [media]\n     * @returns {Texture}\n     */\n    run(texture, gpu, media)\n    {\n        return texture;\n    }\n\n    /**\n     * Perform any necessary cleanup\n     */\n    release()\n    {\n    }\n}\n\n\n// =====================================================\n//               COLOR CONVERSIONS\n// =====================================================\n\n/**\n * Convert to greyscale\n */\nPipelineOperation.ConvertToGreyscale = class extends SpeedyPipelineOperation\n{\n    run(texture, gpu, media)\n    {\n        if(media._colorFormat == ColorFormat.RGB)\n            texture = gpu.colors.rgb2grey(texture);\n        else if(media._colorFormat != ColorFormat.Greyscale)\n            Utils.fatal(`Can't convert image to greyscale: unknown color format`);\n\n        media._colorFormat = ColorFormat.Greyscale;\n        return texture;\n    }\n}\n\n\n\n// =====================================================\n//               IMAGE FILTERS\n// =====================================================\n\n/**\n * Blur image\n */\nPipelineOperation.Blur = class extends SpeedyPipelineOperation\n{\n    /**\n     * Blur operation\n     * @param {object} [options]\n     */\n    constructor(options = {})\n    {\n        const { filter, size } = (options = {\n            filter: 'gaussian',     // \"gassuian\" | \"box\"\n            size: 5,                // 3 | 5 | 7\n            ...options\n        });\n        super();\n\n        // validate kernel size\n        if(size != 3 && size != 5 && size != 7)\n            Utils.fatal(`Invalid kernel size: ${size}`);\n\n        // select the appropriate filter\n        if(filter == 'gaussian')\n            this._filter = 'gauss' + size;\n        else if(filter == 'box')\n            this._filter = 'box' + size;\n        else\n            Utils.fatal(`Invalid filter: \"${filter}\"`);\n    }\n\n    run(texture, gpu, media)\n    {\n        return gpu.filters[this._filter](texture);\n    }\n}\n\n/**\n * Image convolution\n */\nPipelineOperation.Convolve = class extends SpeedyPipelineOperation\n{\n    /**\n     * Perform a convolution\n     * Must provide a SQUARE kernel with size: 3x3, 5x5 or 7x7\n     * @param {Array<number>} kernel convolution kernel\n     * @param {number} [divisor] divide all kernel entries by this number\n     */\n    constructor(kernel, divisor = 1.0)\n    {\n        let kern = new Float32Array(kernel).map(x => x / divisor);\n        const len = kern.length;\n        const size = Math.sqrt(len) | 0;\n        const method = ({\n            3: ['createKernel3x3', 'texConv2D3'],\n            5: ['createKernel5x5', 'texConv2D5'],\n            7: ['createKernel7x7', 'texConv2D7'],\n        })[size] || null;\n        super();\n\n        // validate kernel\n        if(len == 1)\n            Utils.fatal(`Cannot convolve with a kernel containing a single element`);\n        else if(size * size != len || !method)\n            Utils.fatal(`Cannot convolve with a non-square kernel of ${len} elements`);\n\n        // normalize kernel entries to [0,1]\n        const min = Math.min(...kern), max = Math.max(...kern);\n        const offset = min;\n        const scale = Math.abs(max - min) > 1e-5 ? max - min : 1;\n        kern = kern.map(x => (x - offset) / scale);\n\n        // store the normalized kernel\n        this._method = method;\n        this._scale = scale;\n        this._offset = offset;\n        this._kernel = kern;\n        this._kernelSize = size;\n        this._texKernel = null;\n        this._gl = null;\n    }\n\n    run(texture, gpu, media)\n    {\n        // lost context?\n        if(gpu.gl.isContextLost()) {\n            this._texKernel = null;\n            this._gl = null;\n            // convolve with a null texKernel anyway,\n            // SpeedyProgram handles lost contexts\n        }\n\n        // instantiate the texture kernel\n        else if(this._texKernel == null || (this._gl !== gpu.gl && this._gl !== null)) {\n            // warn about performance\n            if(this._gl !== gpu.gl && this._gl !== null && !this._gl.isContextLost()) {\n                const warn = 'Performance warning: need to recreate the texture kernel. ' +\n                             'Consider duplicating the pipeline when using convolutions ' +\n                             'for different media objects.';\n                Utils.warning(warn);\n\n                // release old texture\n                GLUtils.destroyTexture(this._gl, this._texKernel);\n            }\n\n            this._texKernel = gpu.filters[this._method[0]](this._kernel);\n            this._gl = gpu.gl;\n        }\n\n        // convolve\n        return gpu.filters[this._method[1]](\n            texture,\n            this._texKernel,\n            this._scale,\n            this._offset\n        );\n    }\n\n    release()\n    {\n        if(this._texKernel != null) {\n            GLUtils.destroyTexture(this._gl, this._texKernel);\n            this._texKernel = this._gl = null;\n        }\n        super.release();\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-feature.js\n * SpeedyFeature implementation\n */\n\n/**\n * A SpeedyFeature is a keypoint in an image,\n * with optional scale, rotation and descriptor\n */\nexport class SpeedyFeature\n{\n    /**\n     * Creates a new SpeedyFeature\n     * @param {number} x X position\n     * @param {number} y Y position\n     * @param {number} [scale] Scale\n     * @param {number} [rotation] Rotation in radians\n     * @param {FeatureDescriptor} [descriptor] Feature descriptor\n     */\n    constructor(x, y, scale = 1.0, rotation = 0.0, descriptor = null)\n    {\n        this._x = +x;\n        this._y = +y;\n        this._scale = +scale;\n        this._rotation = +rotation;\n        this._descriptor = descriptor;\n    }\n\n    /**\n     * Converts a SpeedyFeature to a representative string\n     * @returns {string}\n     */\n    toString()\n    {\n        return `(${this._x},${this._y})`;\n    }\n\n    /**\n     * The X position of the feature point\n     * @returns {number} X position\n     */\n    get x()\n    {\n        return this._x;\n    }\n\n    /**\n     * The y position of the feature point\n     * @returns {number} Y position\n     */\n    get y()\n    {\n        return this._y;\n    }\n\n    /**\n     * The scale of the feature point\n     * @returns {number} Scale\n     */\n    get scale()\n    {\n        return this._scale;\n    }\n\n    /**\n     * The rotation of the feature point, in radians\n     * @returns {number} Angle in radians\n     */\n    get rotation()\n    {\n        return this._rotation;\n    }\n\n    /**\n     * The descriptor of the feature point, or null\n     * if there isn't any\n     * @return {FeatureDescriptor|null} feature descriptor\n     */\n    get descriptor()\n    {\n        return this._descriptor;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-media.js\n * SpeedyMedia implementation\n */\n\nimport { SpeedyGPU } from '../gpu/speedy-gpu';\nimport { MediaType, ColorFormat } from '../utils/types'\nimport { FeatureDetector } from './feature-detector';\nimport { SpeedyError } from '../utils/errors';\nimport { Utils } from '../utils/utils';\n\n/**\n * SpeedyMedia encapsulates a media element\n * (e.g., image, video, canvas)\n */\nexport class SpeedyMedia\n{\n    /**\n     * Class constructor\n     * It assumes A VALID (!) media source that is already loaded\n     * @param {HTMLImageElement|HTMLVideoElement|HTMLCanvasElement|Texture} mediaSource An image, video or canvas\n     * @param {number} width media width\n     * @param {number} height media height\n     * @param {object} [options] options object\n     */\n    /* private */ constructor(mediaSource, width, height, options = { })\n    {\n        if(arguments.length > 1) {\n            // store data\n            this._source = mediaSource;\n            this._width = width | 0;\n            this._height = height | 0;\n            this._type = getMediaType(this._source);\n            this._colorFormat = ColorFormat.RGB;\n\n            // set options\n            this._options = buildOptions(options, {\n                usage: (this._type != MediaType.Image) ? 'dynamic' : 'static',\n            });\n\n            // spawn relevant components\n            this._gpu = new SpeedyGPU(this._width, this._height);\n            this._featureDetector = null; // lazy instantiation \n        }\n        else if(arguments.length == 1) {\n            // copy constructor (shallow copy)\n            const media = arguments[0];\n\n            this._source = media._source;\n            this._width = media._width;\n            this._height = media._height;\n            this._type = media._type;\n            this._colorFormat = media._colorFormat;\n\n            this._gpu = media._gpu;\n            this._featureDetector = media._featureDetector;\n        }\n        else\n            Utils.fatal(`Invalid instantiation of SpeedyMedia`);\n    }\n\n    /**\n     * Load a media source\n     * Will wait until the HTML media source is loaded\n     * @param {HTMLImageElement|HTMLVideoElement|HTMLCanvasElement} mediaSource An image, video or canvas\n     * @param {object} [options] options object\n     * @returns {Promise<SpeedyMedia>}\n     */\n    static load(mediaSource, options = { })\n    {\n        return new Promise((resolve, reject) => {\n            const dimensions = getMediaDimensions(mediaSource);\n            if(dimensions != null) {\n                // try to load the media until it's ready\n                (function loadMedia(dimensions, k = 500) {\n                    if(dimensions.width > 0 && dimensions.height > 0) {\n                        const media = new SpeedyMedia(mediaSource, dimensions.width, dimensions.height, options);\n                        Utils.log(`Loaded SpeedyMedia with a ${mediaSource}.`);\n                        resolve(media);\n                    }\n                    else if(k > 0)\n                        setTimeout(() => loadMedia(getMediaDimensions(mediaSource), k-1), 10);\n                    else\n                        reject(new SpeedyError(`Can't load SpeedyMedia with a ${mediaSource}: timeout.`));\n                })(dimensions);\n            }\n            else {\n                // invalid media source\n                reject(new SpeedyError(`Can't load SpeedyMedia with a ${mediaSource}: invalid media source.`));\n            }\n        });\n    }\n\n    /**\n     * Loads a camera stream\n     * @param {number} [width] width of the stream\n     * @param {number} [height] height of the stream\n     * @param {object} [cameraOptions] additional options to pass to getUserMedia()\n     * @param {object} [mediaOptions] additional options for advanced configuration of the SpeedyMedia\n     * @returns {Promise<SpeedyMedia>}\n     */\n    static loadCameraStream(width = 426, height = 240, cameraOptions = {}, mediaOptions = {})\n    {\n        return requestCameraStream(width, height, cameraOptions).then(\n            video => SpeedyMedia.load(createCanvasFromVideo(video), mediaOptions)\n        );\n    }\n\n    /**\n     * The media element (image, video, canvas) encapsulated by this SpeedyMedia object\n     * @returns {HTMLImageElement|HTMLVideoElement|HTMLCanvasElement} the media element\n     */\n    get source()\n    {\n        return this._source;\n    }\n\n    /**\n     * Gets the width of the media\n     * @returns {number} media width\n     */\n    get width()\n    {\n        return this._width;\n    }\n\n    /**\n     * Gets the height of the media\n     * @returns {number} media height\n     */\n    get height()\n    {\n        return this._height;\n    }\n\n    /**\n     * The type of the media attached to this SpeedyMedia object\n     * @returns {string} \"image\" | \"video\" | \"canvas\" | \"internal\"\n     */\n    get type()\n    {\n        switch(this._type) {\n            case MediaType.Image:\n                return 'image';\n\n            case MediaType.Video:\n                return 'video';\n\n            case MediaType.Canvas:\n                return 'canvas';\n\n            case MediaType.Texture: // the result of pipelining\n                return 'internal';\n\n            default: // this shouldn't happen\n                return 'unknown';\n        }\n    }\n\n    /**\n     * Returns a read-only object featuring advanced options\n     * related to this SpeedyMedia object\n     * @returns {object}\n     */\n    get options()\n    {\n        return this._options;\n    }\n\n    /**\n     * Releases resources associated with this media.\n     * You will no longer be able to use it, nor any of its lightweight clones.\n     * @returns {Promise} resolves as soon as the resources are released\n     */\n    release()\n    {\n        if(!this.isReleased()) {\n            this._featureDetector = null;\n            this._gpu.loseWebGLContext();\n            this._gpu = null;\n            this._source = null;\n        }\n\n        return Promise.resolve();\n    }\n\n    /**\n     * Is this SpeedyMedia released?\n     * @returns {bool}\n     */\n    isReleased()\n    {\n        return this._gpu == null;\n    }\n\n    /**\n     * Clones the SpeedyMedia object\n     * @param {object} options options object\n     * @returns {SpeedyMedia} a clone object\n     */\n    clone(options = {})\n    {\n        // Default settings\n        options = {\n            lightweight: false,\n            ...(options)\n        };\n\n        // has the media been released?\n        if(this.isReleased())\n            Utils.fatal('Can\\'t clone a SpeedyMedia that has been released');\n\n        // clone the object\n        if(options.lightweight) {\n            // shallow copy\n            return new SpeedyMedia(this);\n        }\n        else {\n            // deep copy\n            let source = this._source;\n            if(this._type == MediaType.Texture || this._type == MediaType.Canvas)\n                source = createCanvasFromStaticMedia(this); // won't share WebGL context\n            return new SpeedyMedia(source, this._width, this._height);\n        }\n    }\n\n    /**\n     * Runs a pipeline\n     * @param {SpeedyPipeline} pipeline\n     * @returns {Promise<SpeedyMedia>} a promise that resolves to A CLONE of this SpeedyMedia\n     */\n    run(pipeline)\n    {\n        // has the media been released?\n        if(this.isReleased())\n            Utils.fatal('Can\\'t run pipeline: SpeedyMedia has been released');\n\n        // run the pipeline\n        const media = this.clone({ lightweight: true });\n        media._type = MediaType.Texture;\n        return pipeline._run(media);\n    }\n\n    /**\n     * Draws the media to a canvas\n     * @param {HTMLCanvasElement} canvas canvas element\n     * @param {number} [x] x-position\n     * @param {number} [y] y-position\n     * @param {number} [width] desired width\n     * @param {number} [height] desired height\n     */\n    draw(canvas, x = 0, y = 0, width = this.width, height = this.height)\n    {\n        // fail silently if the media been released\n        if(this.isReleased())\n            return;\n\n        // draw\n        const ctx = canvas.getContext('2d');\n\n        x = +x; y = +y;\n        width = Math.max(width, 0);\n        height = Math.max(height, 0);\n\n        switch(this._type) {\n            case MediaType.Image:\n            case MediaType.Video:\n            case MediaType.Canvas:\n                ctx.drawImage(this._source, x, y, width, height);\n                break;\n\n            case MediaType.Texture:\n                ctx.drawImage(this._gpu.canvas, x, y, width, height);\n                break;\n        }\n    }\n\n    /**\n     * Finds image features\n     * @param {object} [settings] Configuration object\n     * @returns {Promise<Array<SpeedyFeature>>} A Promise returning an Array of SpeedyFeature objects\n     */\n    findFeatures(settings = {})\n    {\n        // Default settings\n        settings = Object.assign({\n            method: 'fast',\n        }, settings);\n\n        // has the media been released?\n        if(this.isReleased())\n            Utils.fatal('Can\\'t find features: SpeedyMedia has been released');\n\n        // Lazy instantiation\n        this._featureDetector = this._featureDetector || new FeatureDetector(this._gpu, this.options.usage == 'dynamic');\n\n        // Algorithm table\n        const fn = this._featureDetector._table || (this._featureDetector._table = {\n            'fast' :     (media, settings) => this._featureDetector.fast(media, 9, settings),   // alias for fast9\n            'fast9':     (media, settings) => this._featureDetector.fast(media, 9, settings),   // FAST-9,16 (default)\n            'fast7':     (media, settings) => this._featureDetector.fast(media, 7, settings),   // FAST-7,12\n            'fast5':     (media, settings) => this._featureDetector.fast(media, 5, settings),   // FAST-5,8\n            'fast9plus': (media, settings) => this._featureDetector.fastPlus(media, 9, settings), // FAST-9,16 augmented with scale & orientation\n            'brisk':     (media, settings) => this._featureDetector.brisk(media, settings),     // BRISK\n        });\n\n        // Validate method\n        const method = String(settings.method).toLowerCase();\n        if(!fn.hasOwnProperty(method))\n            Utils.fatal(`Invalid method \"${method}\" for keypoint detection.`);\n\n        // Run the algorithm\n        return (fn[method])(this, settings);\n    }\n}\n\n// get the { width, height } of a certain HTML element (image, video, canvas...)\nfunction getMediaDimensions(mediaSource)\n{\n    if(mediaSource && mediaSource.constructor && mediaSource.constructor.name) {\n        const element = mediaSource.constructor.name, key = {\n            HTMLImageElement: { width: 'naturalWidth', height: 'naturalHeight' },\n            HTMLVideoElement: { width: 'videoWidth', height: 'videoHeight' },\n            HTMLCanvasElement: { width: 'width', height: 'height' },\n        };\n\n        if(key.hasOwnProperty(element)) {\n            return {\n                width: mediaSource[key[element].width],\n                height: mediaSource[key[element].height]\n            };\n        }\n    }\n\n    return null;\n}\n\n// get a string corresponding to the media type (image, video, canvas)\nfunction getMediaType(mediaSource)\n{\n    if(mediaSource && mediaSource.constructor) {\n        switch(mediaSource.constructor.name) {\n            case 'HTMLImageElement':\n                return MediaType.Image;\n\n            case 'HTMLVideoElement':\n                return MediaType.Video;\n\n            case 'HTMLCanvasElement':\n                return MediaType.Canvas;\n\n            default:\n                return MediaType.Texture;\n        }\n    }\n\n    Utils.fatal(`Can't get media type: invalid media source. ${mediaSource}`);\n    return null;\n}\n\n// build & validate options object\nfunction buildOptions(options, defaultOptions)\n{\n    const warn = buildOptions._err || (buildOptions._err = \n        (...args) => Utils.warning(`Invalid option when loading media.`, ...args));\n\n    // build options object\n    options = Object.assign(defaultOptions, options);\n\n    // validate\n    if(options.usage != 'dynamic' && options.usage != 'static') {\n        warn(`Unrecognized usage: \"${options.usage}\"`);\n        options.usage = defaultOptions.usage;\n    }\n\n    // done!\n    return Object.freeze(options); // must be read-only\n}\n\n// webcam access\nfunction requestCameraStream(width, height, options = {})\n{\n    return new Promise((resolve, reject) => {\n        Utils.log('Accessing the webcam...');\n\n        if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia)\n            return reject(new SpeedyError('Unsupported browser: no mediaDevices.getUserMedia()'));\n\n        navigator.mediaDevices.getUserMedia({\n            audio: false,\n            video: {\n                width: { ideal: width },\n                height: { ideal: height },\n                aspectRatio: { ideal: width / height },\n                facingMode: 'environment',\n            },\n            ...(options)\n        })\n        .then(stream => {\n            const video = document.createElement('video');\n            video.srcObject = stream;\n            video.onloadedmetadata = e => {\n                video.play();\n                Utils.log('The camera device is turned on!');\n                resolve(video, stream);\n            };\n        })\n        .catch(err => {\n            reject(new SpeedyError(\n                `Please give access to the camera and reload the page.\\n` +\n                `${err.name}. ${err.message}.`\n            ));\n        });\n    });\n}\n\n// create a HTMLCanvasElement using a HTMLVideoElement\nfunction createCanvasFromVideo(video)\n{\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    \n    canvas.width = video.videoWidth;\n    canvas.height = video.videoHeight;\n\n    function render() {\n        ctx.drawImage(video, 0, 0);\n        requestAnimationFrame(render);\n    }\n    render();\n\n    return canvas;\n}\n\n// create a (static) HTMLCanvasElement using a SpeedyMedia as source\nfunction createCanvasFromStaticMedia(media)\n{\n    const canvas = document.createElement('canvas');\n\n    canvas.width = media.width;\n    canvas.height = media.height;\n    media.draw(canvas);\n\n    return canvas;\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-pipeline.js\n * A pipeline is a sequence of operations that transform the image in some way\n */\n\nimport { PipelineOperation } from './pipeline-operations';\nimport { MediaType } from '../utils/types';\nimport { SpeedyError } from '../utils/errors';\nimport { Utils } from '../utils/utils';\n\n/**\n * A SpeedyPipeline holds a sequence of operations that\n * graphically transform the incoming media in some way\n * \n * SpeedyPipeline's methods are chainable: use them to\n * create your own sequence of image operations\n */\nexport class SpeedyPipeline\n{\n    /* friend class SpeedyMedia */\n\n    /**\n     * Class constructor\n     */\n    constructor()\n    {\n        this._operations = [];\n    }\n\n    /**\n     * The number of the operations of the pipeline\n     * @returns {number}\n     */\n    get length()\n    {\n        return this._operations.length;\n    }\n\n    /**\n     * Cleanup pipeline memory\n     * @returns {Promise<SpeedyPipeline>} resolves as soon as the memory is released\n     */\n    release()\n    {\n        return new Promise((resolve, reject) => {\n            for(let i = this._operations.length - 1; i >= 0; i--)\n                this._operations[i].release();\n            this._operations.length = 0;\n            resolve(this);\n        });\n    }\n\n    /**\n     * Adds a new operation to the end of the pipeline\n     * @param {SpeedyPipelineOperation} operation\n     * @returns {SpeedyPipeline} the pipeline itself\n     */\n    _spawn(operation)\n    {\n        this._operations.push(operation);\n        return this;\n    }\n\n    /**\n     * Runs the pipeline on a target media (it will be modified!)\n     * @param {SpeedyMedia} media media to be modified\n     * @returns {Promise<SpeedyMedia>} a promise that resolves to the provided media\n     */\n    _run(media)\n    {\n        return new Promise((resolve, reject) => {\n            if(media._type == MediaType.Texture) {\n                // upload the media to the GPU\n                let texture = media._gpu.upload(media._source);\n\n                // run the pipeline\n                for(let i = 0; i < this._operations.length; i++)\n                    texture = this._operations[i].run(texture, media._gpu, media);\n\n                // end of the pipeline\n                media._gpu.utils.output(texture);\n                media._source = media._gpu.canvas;\n\n                // done!\n                resolve(media);\n            }\n            else\n                reject(new SpeedyError(`Can't run a pipeline on a media that is not a texture`));\n        });\n    }\n\n\n    // =====================================================\n    //                    GENERIC\n    // =====================================================\n\n    /**\n     * Concatenates another pipeline into this one\n     * @param {SpeedyPipeline} pipeline\n     * @returns {SpeedyPipeline}\n     */\n    concat(pipeline)\n    {\n        if(pipeline instanceof SpeedyPipeline) {\n            this._operations = this._operations.concat(pipeline._operations);\n            return this;\n        }\n\n        Utils.fatal(`Invalid argument \"${pipeline}\" given to SpeedyPipeline.concatenate()`);\n        return this;\n    }\n\n\n    // =====================================================\n    //               COLOR CONVERSIONS\n    // =====================================================\n\n    /**\n     * Convert to a color space\n     * @param {string} [colorSpace] 'greyscale' | 'grayscale'\n     * @returns {SpeedyPipeline}\n     */\n    convertTo(colorSpace = null)\n    {\n        if(colorSpace == 'greyscale' || colorSpace == 'grayscale') {\n            return this._spawn(\n                new PipelineOperation.ConvertToGreyscale()\n            );\n        }\n\n        Utils.fatal(`Can't convert to unknown color space: \"${colorSpace}\"`);\n        return this;\n    }\n\n\n\n    // =====================================================\n    //               IMAGE FILTERING\n    // =====================================================\n\n    /**\n     * Image smoothing\n     * @param {object} [options]\n     * @returns {SpeedyPipeline}\n     */\n    blur(options = {})\n    {\n        return this._spawn(\n            new PipelineOperation.Blur(options)\n        );\n    }\n\n    /**\n     * Image convolution\n     * @param {Array<number>} kernel\n     * @param {number} [divisor]\n     * @returns {SpeedyPipeline}\n     */\n    convolve(kernel, divisor = 1.0)\n    {\n        return this._spawn(\n            new PipelineOperation.Convolve(kernel, divisor)\n        );\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * gl-utils.js\n * WebGL utilities\n */\n\nimport { Utils } from '../utils/utils';\n\n/**\n * WebGL-related error\n */\nexport class GLError extends Error\n{\n    /**\n     * Class constructor\n     * @param {string} message \n     */\n    constructor(message)\n    {\n        super(`[GLError] ${message}`);\n        this.name = this.constructor.name;\n    }\n}\n\n/**\n * WebGL Utilities\n */\nexport class GLUtils\n{\n    /**\n     * Create a new GLError object\n     * @param {string} message \n     */\n    static Error(message)\n    {\n        return new GLError(message);\n    }\n\n    /**\n     * Get a GLError error object describing the latest WebGL error\n     * @param {WebGL2RenderingContext} gl \n     * @returns {string}\n     */\n    static getError(gl)\n    {\n        const recognizedErrors = [\n            'NO_ERROR',\n            'INVALID_ENUM',\n            'INVALID_VALUE',\n            'INVALID_OPERATION',\n            'INVALID_FRAMEBUFFER_OPERATION',\n            'OUT_OF_MEMORY',\n            'CONTEXT_LOST_WEBGL',\n        ];\n\n        const glError = gl.getError();\n        const message = recognizedErrors.find(error => gl[error] == glError) || 'Unknown';\n        return new GLError(message);\n    }\n\n    /**\n     * Create a shader\n     * @param {WebGL2RenderingContext} gl\n     * @param {number} type\n     * @param {string} source\n     * @returns {WebGLShader}\n     */\n    static createShader(gl, type, source)\n    {\n        const shader = gl.createShader(type);\n\n        gl.shaderSource(shader, source);\n        gl.compileShader(shader);\n\n        return shader;\n    }\n\n    /**\n     * Create a vertex-shader + fragment-shader program\n     * @param {WebGL2RenderingContext} gl\n     * @param {string} vertexShaderSource\n     * @param {string} fragmentShaderSource\n     * @returns {WebGLProgram}\n     */\n    static createProgram(gl, vertexShaderSource, fragmentShaderSource)\n    {\n        const program = gl.createProgram();\n        const vertexShader = GLUtils.createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n        const fragmentShader = GLUtils.createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n\n        gl.attachShader(program, vertexShader);\n        gl.attachShader(program, fragmentShader);\n        gl.linkProgram(program);\n\n        // error?\n        if(!gl.getProgramParameter(program, gl.LINK_STATUS) && !gl.isContextLost()) {\n            const errors = [\n                gl.getShaderInfoLog(fragmentShader),\n                gl.getShaderInfoLog(vertexShader),\n                gl.getProgramInfoLog(program),\n            ];\n\n            const spaces = i => Math.max(0, 2 - Math.floor(Math.log10(i)));\n            const col = k => Array(spaces(k)).fill(' ').join('') + k + '. ';\n            const formattedSource = fragmentShaderSource.split('\\n')\n                .map((line, no) => col(1+no) + line)\n                .join('\\n');\n\n            gl.deleteProgram(program);\n            gl.deleteShader(fragmentShader);\n            gl.deleteShader(vertexShader);\n\n            throw GLUtils.Error(\n                `Can't create shader program.\\n\\n` +\n                `---------- ERROR ----------\\n` +\n                errors.join('\\n') + '\\n\\n' +\n                `---------- SOURCE CODE ----------\\n` +\n                formattedSource\n            );\n        }\n\n        return program;\n    }\n\n    /**\n     * Create a WebGL texture\n     * @param {WebGL2RenderingContext} gl \n     * @param {number} width in pixels\n     * @param {number} height in pixels\n     * @returns {WebGLTexture}\n     */\n    static createTexture(gl, width, height)\n    {\n        // validate dimensions\n        if(width <= 0 || height <= 0)\n            throw GLUtils.Error(`Invalid dimensions given to createTexture()`);\n\n        // create texture\n        const texture = gl.createTexture();\n\n        // setup texture\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT);\n        //gl.texStorage2D(gl.TEXTURE_2D, 1, gl.RGBA8, width, height);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA8, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n\n        // unbind & return\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        return texture;\n    }\n\n    /**\n     * Destroys a WebGL texture\n     * @param {WebGL2RenderingContext} gl \n     * @param {WebGLTexture} texture \n     * @returns {null}\n     */\n    static destroyTexture(gl, texture)\n    {\n        gl.deleteTexture(texture);\n        return null;\n    }\n\n    /**\n     * Upload pixel data to a WebGL texture\n     * @param {WebGL2RenderingContext} gl \n     * @param {WebGLTexture} texture \n     * @param {GLsizei} width texture width\n     * @param {GLsizei} height texture height\n     * @param {ImageBitmap|ImageData|ArrayBufferView|HTMLImageElement|HTMLVideoElement|HTMLCanvasElement} pixels \n     * @returns {WebGLTexture} texture\n     */\n    static uploadToTexture(gl, texture, width, height, pixels)\n    {\n        // Prefer calling uploadToTexture() before gl.useProgram() to avoid the\n        // needless switching of GL programs internally. See also:\n        // https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        /*\n        // slower than texImage2D, unlike the spec?\n        gl.texSubImage2D(gl.TEXTURE_2D,     // target\n                         0,                 // mip level\n                         0,                 // x-offset\n                         0,                 // y-offset\n                         width,             // texture width\n                         height,            // texture height\n                         gl.RGBA,           // source format\n                         gl.UNSIGNED_BYTE,  // source type\n                         pixels);           // source data\n        */\n        gl.texImage2D(gl.TEXTURE_2D,        // target\n                      0,                    // mip level\n                      gl.RGBA8,             // internal format\n                      //width,                // texture width\n                      //height,               // texture height\n                      //0,                    // border\n                      gl.RGBA,              // source format\n                      gl.UNSIGNED_BYTE,     // source type\n                      pixels);              // source data\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        return texture;\n    }\n\n    /**\n     * Generate texture mipmap with bilinear interpolation\n     * @param {WebGL2RenderingContext} gl \n     * @param {WebGLTexture} texture \n     */\n    static generateMipmap(gl, texture)\n    {\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);\n        gl.generateMipmap(gl.TEXTURE_2D);\n        gl.bindTexture(gl.TEXTURE_2D, null);\n    }\n\n    // bind the textures and assign their numbers\n    // textureMap: { 'textureName': <texture> , ... }\n    // locationMap: { 'textureName': <uniformLocation> , ... }\n    static bindTextures(gl, textureMap, locationMap)\n    {\n        const names = Object.keys(textureMap);\n\n        if(gl.isContextLost())\n            return;\n\n        if(names.length > gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS)\n            throw GLUtils.Error(`Can't bind ${names.length} textures to a program: max is ${gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS}`);\n\n        for(let i = 0; i < names.length; i++) {\n            gl.activeTexture(gl.TEXTURE0 + i);\n            gl.bindTexture(gl.TEXTURE_2D, textureMap[names[i]]);\n            gl.uniform1i(locationMap[names[i]], i);\n        }\n    }\n\n    /**\n     * Creates a framebuffer object (FBO) associated with an existing texture\n     * @param {WebGL2RenderingContext} gl \n     * @param {WebGLTexture} texture \n     * @returns {WebGLFramebuffer}\n     */\n    static createFramebuffer(gl, texture)\n    {\n        const fbo = gl.createFramebuffer();\n\n        // setup framebuffer\n        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n        gl.framebufferTexture2D(gl.FRAMEBUFFER,         // target\n                                gl.COLOR_ATTACHMENT0,   // color buffer\n                                gl.TEXTURE_2D,          // tex target\n                                texture,                // texture\n                                0);                     // mipmap level\n\n        // check for errors\n        const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n        if(status != gl.FRAMEBUFFER_COMPLETE) {\n            const error = (() => (([\n                'FRAMEBUFFER_UNSUPPORTED',\n                'FRAMEBUFFER_INCOMPLETE_ATTACHMENT',\n                'FRAMEBUFFER_INCOMPLETE_DIMENSIONS',\n                'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT',\n                'FRAMEBUFFER_INCOMPLETE_MULTISAMPLE'\n            ].filter(err => gl[err] === status))[0] || 'unknown error'))();\n            throw GLUtils.Error(`Can't create framebuffer: ${error} (${status})`);\n        }\n\n        // unbind & return\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        return fbo;\n    }\n\n    /**\n     * Destroys a framebuffer object (FBO)\n     * @param {WebGL2RenderingContext} gl\n     * @param {WebGLFramebuffer} fbo \n     * @returns {null}\n     */\n    static destroyFramebuffer(gl, fbo)\n    {\n        gl.deleteFramebuffer(fbo);\n        return null;\n    }\n\n    /**\n     * Waits for a sync object to become signaled\n     * @param {WebGL2RenderingContext} gl\n     * @param {WebGLSync} sync sync object\n     * @param {GLbitfield} [flags] may be gl.SYNC_FLUSH_COMMANDS_BIT or 0\n     * @returns {Promise} a promise that resolves as soon as the sync object becomes signaled\n     */\n    static clientWaitAsync(gl, sync, flags = 0)\n    {\n        return new Promise((resolve, reject) => {\n            const isFirefox = navigator.userAgent.includes('Firefox');\n\n            function checkStatus() {\n                const status = gl.clientWaitSync(sync, flags, 0);\n                if(status == gl.TIMEOUT_EXPIRED) {\n                    //setTimeout(checkStatus, 0); // easier on the CPU\n                    Utils.setZeroTimeout(checkStatus);\n                }\n                else if(status == gl.WAIT_FAILED) {\n                    if(isFirefox && gl.getError() == gl.NO_ERROR) { // firefox bug?\n                        //setTimeout(checkStatus, 0);\n                        Utils.setZeroTimeout(checkStatus);\n                    }\n                    else {\n                        reject(GLUtils.getError(gl));\n                    }\n                }\n                else {\n                    resolve();\n                }\n            }\n\n            checkStatus();\n        });\n    }\n\n    /**\n     * Reads data from a WebGLBuffer into an ArrayBufferView\n     * This is like gl.getBufferSubData(), but async\n     * @param {WebGL2RenderingContext} gl\n     * @param {WebGLBuffer} glBuffer will be bound to target\n     * @param {GLenum} target\n     * @param {GLintptr} srcByteOffset usually 0\n     * @param {ArrayBufferView} destBuffer\n     * @param {GLuint} [destOffset]\n     * @param {GLuint} [length]\n     * @returns {Promise<Number>} a promise that resolves to the time it took to read the data (in ms)\n     */\n    static getBufferSubDataAsync(gl, glBuffer, target, srcByteOffset, destBuffer, destOffset = 0, length = 0)\n    {\n        const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);\n        const start = performance.now();\n\n        // empty internal command queues and send them to the GPU asap\n        gl.flush(); // make sure the sync command is read\n\n        // wait for the commands to be processed by the GPU\n        return GLUtils.clientWaitAsync(gl, sync).then(() => {\n            gl.bindBuffer(target, glBuffer);\n            gl.getBufferSubData(target, srcByteOffset, destBuffer, destOffset, length);\n            gl.bindBuffer(target, null);\n            return performance.now() - start;\n        }).catch(err => {\n            throw GLUtils.Error(`Can't getBufferSubDataAsync(): got ${err.message} in clientWaitAsync()`);\n        }).finally(() => {\n            gl.deleteSync(sync);\n        });\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * gpu-program-group.js\n * An abstract group of programs that run on the GPU\n */\n\n/**\n * GPUProgramGroup\n * A semantically correlated group\n * of programs that run on the GPU\n */\n\nexport /* abstract */ class GPUProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} width Texture width (depends on the pyramid layer)\n     * @param {number} height Texture height (depends on the pyramid layer)\n     */\n    /* protected */ constructor(gpu, width, height)\n    {\n        this._gpu = gpu;\n        this._width = width;\n        this._height = height;\n    }\n\n    /**\n     * Declare a program\n     * @param {string} name Program name\n     * @param {Function} shaderdecl Program params => code\n     * @param {object} settings Program settings\n     * @returns {GPUProgramGroup} This object\n     */\n    /* protected */ declare(name, shaderdecl, settings = { })\n    {\n        // lazy instantiation of kernels\n        Object.defineProperty(this, name, {\n            get: (() => {\n                const key = '__k_' + name;\n                return (function() {\n                    return this[key] || (this[key] = this._createProgram(shaderdecl, settings));\n                }).bind(this);\n            })()\n        });\n\n        return this;\n    }\n\n    /**\n     * Multi-pass composition\n     * @param {string} name Program name\n     * @param {string} fn Other programs\n     * @returns {GPUProgramGroup} This object\n     */\n    /* protected */ compose(name, ...fn)\n    {\n        // function composition: functions are called in the order they are specified\n        // e.g., compose('h', 'f', 'g') means h(x) = g(f(x))\n        Object.defineProperty(this, name, {\n            get: (() => {\n                const key = '__c_' + name;\n                return (function() {\n                    return this[key] || (this[key] = (fn.length == 2) ? (() => {\n                        fn = fn.map(fi => this[fi]);\n                        return function compose(image, ...args) {\n                            return (fn[1])((fn[0])(image, ...args), ...args);\n                        };\n                    })() : ((fn.length == 3) ? (() => {\n                        fn = fn.map(fi => this[fi]);\n                        return function compose(image, ...args) {\n                            return (fn[2])((fn[1])((fn[0])(image, ...args), ...args), ...args);\n                        };\n                    })() : ((fn.length == 4) ? (() => {\n                        fn = fn.map(fi => this[fi]);\n                        return function compose(image, ...args) {\n                            return (fn[3])((fn[2])((fn[1])((fn[0])(image, ...args), ...args), ...args), ...args);\n                        };\n                    })() : (() => {\n                        fn = fn.map(fi => this[fi]);\n                        return function compose(image, ...args) {\n                            return fn.reduce((img, fi) => fi(img, ...args), image);\n                        };\n                    })())));\n                }).bind(this);\n            })()\n        });\n\n        return this;\n    }\n\n    /**\n     * Neat helpers to be used\n     * when defining programs\n     */\n    get program()\n    {\n        return this._helpers || (this.helpers = {\n\n            // Set texture input/output size\n            // Dimensions are converted to integers\n            hasTextureSize(width, height) {\n                return {\n                    output: [ width|0, height|0 ]\n                };\n            },\n\n            // Render to canvas\n            // Use it when we're supposed to see the texture\n            displaysGraphics() {\n                return {\n                    renderToTexture: false\n                };\n            },\n\n            // Use this when we want to keep the kernel\n            // texture (they are recycled by default)\n            doesNotRecycleTextures() {\n                return {\n                    recycleTexture: false\n                };\n            },\n\n        });\n    }\n\n    /* private */ _createProgram(shaderdecl, settings = { })\n    {\n        return this._gpu.createProgram(shaderdecl, {\n            // default settings\n            output: [ this._width, this._height ],\n            ...settings\n        });\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * gpu-colors.js\n * Color conversion algorithms\n */\n\nimport { GPUProgramGroup } from '../gpu-program-group';\nimport { rgb2grey } from './programs/colors';\n\n/**\n * GPUColors\n * Color conversions\n */\nexport class GPUColors extends GPUProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            // convert to greyscale\n            .declare('rgb2grey', rgb2grey)\n        ;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * gpu-encoders.js\n * Texture encoders\n */\n\nimport { GPUProgramGroup } from '../gpu-program-group';\nimport { encodeKeypointOffsets, encodeKeypoints } from './programs/encoders';\nimport { SpeedyFeature } from '../../core/speedy-feature';\nimport { StochasticTuner } from '../../utils/tuner';\nimport { Utils } from '../../utils/utils'\n\n// We won't admit more than MAX_KEYPOINTS per media.\n// The larger this value is, the more data we need to transfer from the GPU.\nconst MAX_DESCRIPTOR_SIZE = 64; // in bytes, must be divisible by 4\nconst MAX_KEYPOINT_SIZE = 8 + MAX_DESCRIPTOR_SIZE; // in bytes, must be divisible by 4\nconst MAX_PIXELS_PER_KEYPOINT = (MAX_KEYPOINT_SIZE / 4) | 0; // in pixels\nconst MAX_ENCODER_LENGTH = 300; // in pixels (if too large, WebGL may lose context - so be careful!)\nconst MAX_KEYPOINTS = ((MAX_ENCODER_LENGTH * MAX_ENCODER_LENGTH) / MAX_PIXELS_PER_KEYPOINT) | 0;\nconst INITIAL_ENCODER_LENGTH = 128; // pick a large value <= MAX (useful on static images when no encoder optimization is performed beforehand)\nconst TWO_PI = 2.0 * Math.PI;\n\n\n/**\n * GPUEncoders\n * Texture encoding\n */\nexport class GPUEncoders extends GPUProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            // Keypoint encoding\n            .declare('_encodeKeypointOffsets', encodeKeypointOffsets)\n            .declare('_encodeKeypoints', encodeKeypoints, {\n                output: [INITIAL_ENCODER_LENGTH, INITIAL_ENCODER_LENGTH],\n                renderToTexture: false\n            })\n        ;\n\n        // setup internal data\n        let neighborFn = (s) => Math.round(Utils.gaussianNoise(s, 64)) % 256;\n        this._tuner = new StochasticTuner(48, 32, 48/*255*/, 0.2, 8, 60, neighborFn);\n        this._keypointEncoderLength = INITIAL_ENCODER_LENGTH;\n        this._descriptorSize = 0;\n        this._spawnedAt = performance.now();\n    }\n\n\n\n    // -------------------------------------------------------------------------\n    //                       KEYPOINT ENCODING\n    // -------------------------------------------------------------------------\n\n\n    /**\n     * Optimizes the keypoint encoder for an expected number of keypoints\n     * @param {number} keypointCount expected number of keypoints\n     * @returns {number} nonzero if the encoder has been optimized\n     */\n    optimizeKeypointEncoder(keypointCount)\n    {\n        const clampedKeypointCount = Math.max(0, Math.min(Math.ceil(keypointCount), MAX_KEYPOINTS));\n        const pixelsPerKeypoint = Math.ceil(2 + this._descriptorSize / 4);\n        const len = Math.ceil(Math.sqrt((4 + clampedKeypointCount * 1.05) * pixelsPerKeypoint)); // add some slack\n        const newEncoderLength = Math.max(1, Math.min(len, MAX_ENCODER_LENGTH));\n        const oldEncoderLength = this._keypointEncoderLength;\n\n        if(newEncoderLength != oldEncoderLength) {\n            this._keypointEncoderLength = newEncoderLength;\n            this._encodeKeypoints.resize(newEncoderLength, newEncoderLength);\n        }\n\n        return newEncoderLength - oldEncoderLength;\n    }\n\n    /**\n     * Encodes the keypoints of an image - this is a bottleneck!\n     * @param {WebGLTexture} corners texture with encoded corners\n     * @param {bool} [useAsyncTransfer] transfer data from the GPU without blocking the CPU\n     * @returns {Promise<Array<Uint8Array>>} pixels in the [r,g,b,a, ...] format\n     */\n    async encodeKeypoints(corners, useAsyncTransfer = true)\n    {\n        // parameters\n        const encoderLength = this._keypointEncoderLength;\n        const descriptorSize = this._descriptorSize;\n        const imageSize = [ this._width, this._height ];\n        const maxIterations = this._tuner.currentValue();\n\n        // encode keypoints\n        try {\n            // encode offsets\n            let encodingTime = performance.now();\n            const offsets = this._encodeKeypointOffsets(corners, imageSize, maxIterations);\n            this._encodeKeypoints(offsets, imageSize, encoderLength, descriptorSize);\n            encodingTime = performance.now() - encodingTime;\n\n            // read data from the GPU\n            let pixels, transferTime;\n            if(useAsyncTransfer) {\n                transferTime = performance.now();\n                pixels = await this._encodeKeypoints.readPixelsAsync(0, 0, -1, -1);\n                transferTime = performance.now() - transferTime;\n            }\n            else {\n                transferTime = performance.now();\n                pixels = this._encodeKeypoints.readPixelsSync(); // bottleneck\n                transferTime = performance.now() - transferTime;\n            }\n\n            // tuner: drop noisy feedback when the page loads\n            if(performance.now() >= this._spawnedAt + 2000) {\n                const time = encodingTime + transferTime;\n                this._tuner.feedObservation(time);\n            }\n\n            // debug\n            /*\n            window._p = window._p || 0;\n            window._m = window._m || 0;\n            window._m = 0.9 * window._m + 0.1 * (encodingTime + transferTime);\n            if(window._p++ % 50 == 0)\n                console.log(window._m, ' | ', maxIterations);\n            //console.log(JSON.stringify(this._tuner.info()));\n            */\n\n            // done!\n            return pixels;\n        }\n        catch(err) {\n            Utils.fatal(err);\n        }\n    }\n\n    /**\n     * Decodes the keypoints, given a flattened image of encoded pixels\n     * @param {Array<number>} pixels pixels in the [r,g,b,a,...] format\n     * @returns {Array<SpeedyFeature>} keypoints\n     */\n    decodeKeypoints(pixels)\n    {\n        const [ w, h ] = [ this._width, this._height ];\n        const hasRotation = this._descriptorSize > 0;\n        const pixelsPerKeypoint = 2 + this._descriptorSize / 4;\n        const lgM = Math.log2(this._gpu.pyramidMaxScale);\n        const pyrHeight = this._gpu.pyramidHeight;\n        const keypoints = [];\n        let x, y, scale, rotation;\n\n        for(let i = 0; i < pixels.length; i += 4 * pixelsPerKeypoint) {\n            x = (pixels[i+1] << 8) | pixels[i];\n            y = (pixels[i+3] << 8) | pixels[i+2];\n            if(x >= w || y >= h)\n                break;\n\n            scale = pixels[i+4] == 255 ? 1.0 :\n                Math.pow(2.0, -lgM + (lgM + pyrHeight) * pixels[i+4] / 255.0);\n\n            rotation = !hasRotation ? 0.0 :\n                pixels[i+5] * TWO_PI / 255.0;\n\n            keypoints.push(new SpeedyFeature(x, y, scale, rotation));\n        }\n\n        // developer's secret ;)\n        // reset the tuner\n        if(keypoints.length == 0) {\n            if(this._tuner.finished())\n                this._tuner.reset();\n        }\n\n        // done!\n        return keypoints;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * gpu-filters.js\n * Image filtering on the GPU\n */\n\nimport { GPUProgramGroup } from '../gpu-program-group';\nimport { conv2D, convX, convY, texConvX, texConvY, texConv2D, idConv2D, createKernel2D, createKernel1D } from './programs/convolution';\n\n/**\n * GPUFilters\n * Image filtering\n */\nexport class GPUFilters extends GPUProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            // gaussian approximation (sigma approx. 1.0)\n            .compose('gauss5', '_gauss5x', '_gauss5y') // size: 5x5\n            .compose('gauss3', '_gauss3x', '_gauss3y') // size: 3x3\n            .compose('gauss7', '_gauss7x', '_gauss7y') // size: 7x7\n\n            // box filters\n            .compose('box5', '_box5x', '_box5y') // size: 5x5\n            .compose('box3', '_box3x', '_box3y') // size: 3x3\n            .compose('box7', '_box7x', '_box7y') // size: 7x7\n            .compose('box9', '_box9x', '_box9y') // size: 9x9\n            .compose('box11', '_box11x', '_box11y') // size: 11x11\n\n            // texture-based convolutions\n            .compose('texConv2D3', '_idConv2D3', '_texConv2D3') // 2D texture-based 3x3 convolution\n            .compose('texConv2D5', '_idConv2D5', '_texConv2D5') // 2D texture-based 5x5 convolution\n            .compose('texConv2D7', '_idConv2D7', '_texConv2D7') // 2D texture-based 7x7 convolution\n\n            .declare('_texConv2D3', texConv2D(3)) // 3x3 convolution with a texture (not chainable)\n            .declare('_idConv2D3', idConv2D(3)) // identity operation (enables chaining)\n            .declare('_texConv2D5', texConv2D(5)) // 5x5 convolution with a texture (not chainable)\n            .declare('_idConv2D5', idConv2D(5)) // identity operation (enables chaining)\n            .declare('_texConv2D7', texConv2D(7)) // 7x7 convolution with a texture (not chainable)\n            .declare('_idConv2D7', idConv2D(7)) // identity operation (enables chaining)\n\n            // texture-based separable convolutions\n            .compose('texConvXY3', 'texConvX3', 'texConvY3') // 2D convolution with same 1D separable kernel in both axes\n            .declare('texConvX3', texConvX(3)) // 3x1 convolution, x-axis\n            .declare('texConvY3', texConvY(3)) // 1x3 convolution, y-axis\n            .compose('texConvXY5', 'texConvX5', 'texConvY5') // 2D convolution with same 1D separable kernel in both axes\n            .declare('texConvX5', texConvX(5)) // 5x1 convolution, x-axis\n            .declare('texConvY5', texConvY(5)) // 1x5 convolution, y-axis\n            .compose('texConvXY7', 'texConvX7', 'texConvY7') // 2D convolution with same 1D separable kernel in both axes\n            .declare('texConvX7', texConvX(7)) // 7x1 convolution, x-axis\n            .declare('texConvY7', texConvY(7)) // 1x7 convolution, y-axis\n            .compose('texConvXY9', 'texConvX9', 'texConvY9') // 2D convolution with same 1D separable kernel in both axes\n            .declare('texConvX9', texConvX(9)) // 9x1 convolution, x-axis\n            .declare('texConvY9', texConvY(9)) // 1x9 convolution, y-axis\n            .compose('texConvXY11', 'texConvX11', 'texConvY11') // 2D convolution with same 1D separable kernel in both axes\n            .declare('texConvX11', texConvX(11)) // 11x1 convolution, x-axis\n            .declare('texConvY11', texConvY(11)) // 1x11 convolution, y-axis\n\n            // create custom convolution kernels\n            .declare('createKernel3x3', createKernel2D(3), { // 3x3 texture kernel\n                ...(this.program.hasTextureSize(3, 3)),\n                ...(this.program.doesNotRecycleTextures())\n            })\n            .declare('createKernel5x5', createKernel2D(5), { // 5x5 texture kernel\n                ...(this.program.hasTextureSize(5, 5)),\n                ...(this.program.doesNotRecycleTextures())\n            })\n            .declare('createKernel7x7', createKernel2D(7), { // 7x7 texture kernel\n                ...(this.program.hasTextureSize(7, 7)),\n                ...(this.program.doesNotRecycleTextures())\n            })\n            .declare('createKernel3x1', createKernel1D(3), { // 3x1 texture kernel\n                ...(this.program.hasTextureSize(3, 1)),\n                ...(this.program.doesNotRecycleTextures())\n            })\n            .declare('createKernel5x1', createKernel1D(5), { // 5x1 texture kernel\n                ...(this.program.hasTextureSize(5, 1)),\n                ...(this.program.doesNotRecycleTextures())\n            })\n            .declare('createKernel7x1', createKernel1D(7), { // 7x1 texture kernel\n                ...(this.program.hasTextureSize(7, 1)),\n                ...(this.program.doesNotRecycleTextures())\n            })\n            .declare('createKernel9x1', createKernel1D(9), { // 9x1 texture kernel\n                ...(this.program.hasTextureSize(9, 1)),\n                ...(this.program.doesNotRecycleTextures())\n            })\n            .declare('createKernel11x1', createKernel1D(11), { // 11x1 texture kernel\n                ...(this.program.hasTextureSize(11, 1)),\n                ...(this.program.doesNotRecycleTextures())\n            })\n            /*.declare('_readKernel3x3', identity, { // for testing\n                ...(this.program.hasTextureSize(3, 3)),\n                ...(this.program.displaysGraphics())\n            })\n            .declare('_readKernel3x1', identity, {\n                ...(this.program.hasTextureSize(3, 1)),\n                ...(this.program.displaysGraphics())\n            })*/\n\n\n\n\n            // separable kernels (Gaussian)\n            // see also: http://dev.theomader.com/gaussian-kernel-calculator/\n            .declare('_gauss5x', convX([\n                0.05, 0.25, 0.4, 0.25, 0.05\n                //0.006, 0.061, 0.242, 0.383, 0.242, 0.061, 0.006\n            ]))\n            .declare('_gauss5y', convY([\n                0.05, 0.25, 0.4, 0.25, 0.05\n                //0.006, 0.061, 0.242, 0.383, 0.242, 0.061, 0.006\n            ]))\n            .declare('_gauss3x', convX([\n                0.25, 0.5, 0.25\n                //0.27901, 0.44198, 0.27901\n            ]))\n            .declare('_gauss3y', convY([\n                0.25, 0.5, 0.25\n                //0.27901, 0.44198, 0.27901\n            ]))\n            .declare('_gauss7x', convX([\n                0.00598, 0.060626, 0.241843, 0.383103, 0.241843, 0.060626, 0.00598\n            ]))\n            .declare('_gauss7y', convY([\n                0.00598, 0.060626, 0.241843, 0.383103, 0.241843, 0.060626, 0.00598\n            ]))\n            /*.declare('_gauss5', conv2D([ // for testing\n                1, 4, 7, 4, 1,\n                4, 16, 26, 16, 4,\n                7, 26, 41, 26, 7,\n                4, 16, 26, 16, 4,\n                1, 4, 7, 4, 1,\n            ], 1 / 237))*/\n\n\n\n            // separable kernels (Box filter)\n            .declare('_box3x', convX([\n                1, 1, 1\n            ], 1 / 3))\n            .declare('_box3y', convY([\n                1, 1, 1\n            ], 1 / 3))\n            .declare('_box5x', convX([\n                1, 1, 1, 1, 1\n            ], 1 / 5))\n            .declare('_box5y', convY([\n                1, 1, 1, 1, 1\n            ], 1 / 5))\n            .declare('_box7x', convX([\n                1, 1, 1, 1, 1, 1, 1\n            ], 1 / 7))\n            .declare('_box7y', convY([\n                1, 1, 1, 1, 1, 1, 1\n            ], 1 / 7))\n            .declare('_box9x', convX([\n                1, 1, 1, 1, 1, 1, 1, 1, 1\n            ], 1 / 9))\n            .declare('_box9y', convY([\n                1, 1, 1, 1, 1, 1, 1, 1, 1\n            ], 1 / 9))\n            .declare('_box11x', convX([\n                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\n            ], 1 / 11))\n            .declare('_box11y', convY([\n                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\n            ], 1 / 11))\n        ;\n    }\n}\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * gpu-keypoints.js\n * Facade for various keypoint detection algorithms\n */\n\nimport { GPUProgramGroup } from '../gpu-program-group';\nimport { fast5, fast7, fast9, fast9pyr, fastScore8, fastScore12, fastScore16, fastSuppression, multiscaleSuppression, samescaleSuppression } from './programs/fast';\nimport { brisk } from './programs/brisk';\n\n/**\n * GPUKeypoints\n * Keypoint detection\n */\nexport class GPUKeypoints extends GPUProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            // FAST-9,16\n            .compose('fast9', '_fast9', '_fastScore16', '_fastSuppression')\n            .declare('_fast9', fast9) // find corners\n            .declare('_fastScore16', fastScore16) // compute scores\n            .declare('_fastSuppression', fastSuppression) // non-maximum suppression\n\n            // FAST-7,12\n            .compose('fast7', '_fast7', '_fastScore12', '_fastSuppression')\n            .declare('_fast7', fast7)\n            .declare('_fastScore12', fastScore12)\n\n            // FAST-5,8\n            .compose('fast5', '_fast5', '_fastScore8', '_fastSuppression')\n            .declare('_fast5', fast5)\n            .declare('_fastScore8', fastScore8)\n\n            // FAST-9,16 plus\n            .declare('fast9pyr', fast9pyr)\n\n            // BRISK Scale-Space Non-Maximum Suppression & Interpolation\n            .declare('brisk', brisk)\n\n            // Generic multi-scale non-maximum suppression\n            .declare('multiscaleSuppression', multiscaleSuppression)\n            .declare('samescaleSuppression', samescaleSuppression)\n        ;\n    }\n}\n\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * brisk.js\n * BRISK feature detection\n */\n\n/*\n * This implements a MODIFIED, GPU-based version\n * of the BRISK [1] feature detection algorithm\n * \n * Reference:\n * \n * [1] Leutenegger, Stefan; Chli, Margarita; Siegwart, Roland Y.\n *     \"BRISK: Binary robust invariant scalable keypoints\"\n *     International Conference on Computer Vision (ICCV-2011)\n */\nexport const brisk = (image, layerA, layerB, scaleA, scaleB, lgM, h) => require('../../shaders/keypoint-detectors/brisk.glsl');","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * colors.js\n * Color conversions\n */\n\n// Convert to greyscale\nexport const rgb2grey = (image) => require('../../shaders/colors/rgb2grey.glsl');","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * convolution.js\n * Convolution function generator\n */\n\nimport { Utils } from \"../../../utils/utils\";\nconst cartesian = (a, b) => [].concat(...a.map(a => b.map(b => [a,b]))); // [a] x [b]\nconst symmetricRange = n => [...Array(2*n + 1).keys()].map(x => x-n);    // [-n, ..., n]\n\n// Generate a 2D convolution with a square kernel\nexport function conv2D(kernel, normalizationConstant = 1.0)\n{\n    const kernel32 = new Float32Array(kernel.map(x => (+x) * (+normalizationConstant)));\n    const kSize = Math.sqrt(kernel32.length) | 0;\n    const N = (kSize / 2) | 0;\n\n    // validate input\n    if(kSize < 1 || kSize % 2 == 0)\n        Utils.fatal(`Can't perform a 2D convolution with an invalid kSize of ${kSize}`);\n    else if(kSize * kSize != kernel32.length)\n        Utils.fatal(`Invalid 2D convolution kernel of ${kernel32.length} elements (expected: square)`);\n\n    // code generator\n    const foreachKernelElement = fn => cartesian(symmetricRange(N), symmetricRange(N)).map(\n        cur => fn(\n            kernel32[(cur[0] + N) * kSize + (cur[1] + N)],\n            cur[0], cur[1]\n        )\n    ).join('\\n');\n\n    const generateCode = (k, dy, dx) => `\n        result += pixelAtOffset(image, ivec2(${dx | 0}, ${dy | 0})) * float(${+k});\n    `;\n\n    // shader\n    const shader = `\n    uniform sampler2D image;\n\n    void main()\n    {\n        float alpha = threadPixel(image).a;\n        vec4 result = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n\n        ${foreachKernelElement(generateCode)}\n\n        color = vec4(result.rgb, alpha);\n    }\n    `;\n\n    // done!\n    return (image) => shader;\n}\n\n// Generate a 1D convolution function on the x-axis\nexport function convX(kernel, normalizationConstant = 1.0)\n{\n    return conv1D('x', kernel, normalizationConstant);\n}\n\n// Generate a 1D convolution function on the y-axis\nexport function convY(kernel, normalizationConstant = 1.0)\n{\n    return conv1D('y', kernel, normalizationConstant);\n}\n\n// 1D convolution function generator\nfunction conv1D(axis, kernel, normalizationConstant)\n{\n    const kernel32 = new Float32Array(kernel.map(x => (+x) * (+normalizationConstant)));\n    const kSize = kernel32.length;\n    const N = (kSize / 2) | 0;\n\n    // validate input\n    if(kSize < 1 || kSize % 2 == 0)\n        Utils.fatal(`Can't perform a 1D convolution with an invalid kSize of ${kSize}`);\n    else if(axis != 'x' && axis != 'y')\n        Utils.fatal(`Can't perform 1D convolution: invalid axis \"${axis}\"`); // this should never happen\n\n    // code generator\n    const foreachKernelElement = fn => symmetricRange(N).reduce(\n        (acc, cur) => acc + fn(kernel32[cur + N], cur),\n    '');\n    const generateCode = (k, i) => ((axis == 'x') ? `\n        pixel += pixelAtOffset(image, ivec2(${i | 0}, 0)) * float(${+k});\n    ` : `\n        pixel += pixelAtOffset(image, ivec2(0, ${i | 0})) * float(${+k});\n    `);\n\n    // shader\n    const shader = `\n    uniform sampler2D image;\n\n    void main()\n    {\n        float alpha = threadPixel(image).a;\n        vec4 pixel = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n\n        ${foreachKernelElement(generateCode)}\n\n        color = vec4(pixel.rgb, alpha);\n    }\n    `;\n\n    // done!\n    return (image) => shader;\n}\n\n/*\n * ------------------------------------------------------------------\n * Texture Encoding\n * Encoding a float in [0,1] into RGB[A]\n * ------------------------------------------------------------------\n * Define frac(x) := x - floor(x)\n * Of course, 0 <= frac(x) < 1.\n * \n * Given: x in [0,1]\n * \n * Define e0 := floor(x),\n *        e1 := 256 frac(x)\n *        e2 := 256 frac(e1) = 256 frac(256 frac(x))\n *        e3 := 256 frac(e2) = 256 frac(256 frac(e1)) = 256 frac(256 frac(256 frac(x))),\n *        ...\n *        more generally,\n *        ej := 256 frac(e_{j-1}), j >= 2\n * \n * Since x = frac(x) + floor(x), it follows that\n * x = floor(x) + 256 frac(x) / 256 = e0 + e1 / 256 = e0 + (frac(e1) + floor(e1)) / 256 =\n * e0 + (256 frac(e1) + 256 floor(e1)) / (256^2) = e0 + (e2 + 256 floor(e1)) / (256^2) =\n * e0 + ((256 frac(e2) + 256 floor(e2)) + 256^2 floor(e1)) / (256^3) =\n * e0 + (e3 + 256 floor(e2) + 256^2 floor(e1)) / (256^3) = \n * floor(e0) + floor(e1) / 256 + floor(e2) / (256^2) + e3 / (256^3) = ... =\n * floor(e0) + floor(e1) / 256 + floor(e2) / (256^2) + floor(e3) / (256^3) + e4 / (256^4) = ... ~\n * \\sum_{i >= 0} floor(e_i) / 256^i\n * \n * Observe that e0 in {0, 1} and, for j >= 1, 0 <= e_j < 256, meaning that\n * e0 and (e_j / 256) can be stored in a 8-bit color channel.\n * \n * We now have approximations for x:\n * x ~ x0 <-- first order\n * x ~ x0 + x1 / 256 <-- second order\n * x ~ x0 + x1 / 256 + x2 / (256^2) <-- third order (RGB)\n * x ~ x0 + x1 / 256 + x2 / (256^2) + x3 / (256^3) <-- fourth order (RGBA)\n * where x_i = floor(e_i).\n */\n\n// Generate a texture-based 2D convolution kernel\n// of size (kernelSize x kernelSize), where all\n// entries belong to the [0, 1] range\nexport function createKernel2D(kernelSize)\n{\n    // validate input\n    kernelSize |= 0;\n    if(kernelSize < 1 || kernelSize % 2 == 0)\n        Utils.fatal(`Can't create a 2D texture kernel of size ${kernelSize}`);\n\n    // encode float in the [0,1] range to RGBA\n    const shader = `\n    uniform float kernel[${kernelSize * kernelSize}];\n\n    void main()\n    {\n        ivec2 thread = threadLocation();\n        float val = kernel[(${kernelSize}) * thread.y + thread.x];\n\n        float e0 = floor(val);\n        float e1 = 256.0f * fract(val);\n        float e2 = 256.0f * fract(e1);\n        float e3 = 256.0f * fract(e2);\n\n        color = vec4(e0, floor(e1) / 256.0f, floor(e2) / 256.0f, floor(e3) / 256.0f);\n    }\n    `;\n\n    // IMPORTANT: all entries of the input kernel\n    // are assumed to be in the [0, 1] range AND\n    // kernel.length >= kernelSize * kernelSize\n    //return new Function('arr', body);\n    return (kernel) => shader;\n}\n\n// Generate a texture-based 1D convolution kernel\n// of size (kernelSize x 1), where all entries\n// belong to the [0, 1] range\nexport function createKernel1D(kernelSize)\n{\n    // validate input\n    kernelSize |= 0;\n    if(kernelSize < 1 || kernelSize % 2 == 0)\n        Utils.fatal(`Can't create a 1D texture kernel of size ${kernelSize}`);\n\n    // encode float in the [0,1] range to RGBA\n    const shader = `\n    uniform float kernel[${kernelSize}];\n\n    void main()\n    {\n        ivec2 thread = threadLocation();\n        float val = kernel[thread.x];\n\n        float e0 = floor(val);\n        float e1 = 256.0f * fract(val);\n        float e2 = 256.0f * fract(e1);\n        float e3 = 256.0f * fract(e2);\n\n        color = vec4(e0, floor(e1) / 256.0f, floor(e2) / 256.0f, floor(e3) / 256.0f);\n    }\n    `;\n\n    // IMPORTANT: all entries of the input kernel\n    // are assumed to be in the [0, 1] range AND\n    // kernel.length >= kernelSize\n    //return new Function('arr', body);\n    return (kernel) => shader;\n}\n\n// 2D convolution with a texture-based kernel of size\n// kernelSize x kernelSize, with optional scale & offset\n// By default, scale and offset are 1 and 0, respectively\nexport function texConv2D(kernelSize)\n{\n    // validate input\n    const N = kernelSize >> 1; // idiv 2\n    if(kernelSize < 1 || kernelSize % 2 == 0)\n        Utils.fatal(`Can't perform a texture-based 2D convolution with an invalid kernel size of ${kernelSize}`);\n\n    // utilities\n    const foreachKernelElement = fn => cartesian(symmetricRange(N), symmetricRange(N)).map(\n        ij => fn(ij[0], ij[1])\n    ).join('\\n');\n\n    const generateCode = (i, j) => `\n        kernel = pixelAt(texKernel, ivec2(${i + N}, ${j + N}));\n        value = dot(kernel, magic) * scale + offset;\n        result += pixelAtOffset(image, ivec2(${i}, ${j})) * value;\n    `;\n\n    // image: target image\n    // texKernel: convolution kernel (all entries in [0,1])\n    // scale: multiply the kernel entries by a number (like 1.0)\n    // offset: add a number to all kernel entries (like 0.0)\n    const shader = `\n    const vec4 magic = vec4(1.0f, 1.0f, 1.0f / 256.0f, 1.0f / 65536.0f);\n    uniform sampler2D image, texKernel;\n    uniform float scale, offset;\n\n    void main()\n    {\n        vec4 kernel = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n        vec4 result = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n        float alpha = threadPixel(image).a;\n        float value = 0.0f;\n\n        ${foreachKernelElement(generateCode)}\n\n        result = clamp(result, 0.0f, 1.0f);\n        color = vec4(result.rgb, alpha);\n    }\n    `;\n\n    return (image, texKernel, scale, offset) => shader;\n}\n\n// identity operation with the same parameters as texConv2D()\nexport function idConv2D(kernelSize)\n{\n    return (image, texKernel, scale, offset) => `\n    uniform sampler2D image, texKernel;\n    uniform float scale, offset;\n\n    void main()\n    {\n        color = threadPixel(image);\n    }\n    `;\n}\n\n// Texture-based 1D convolution on the x-axis\nexport const texConvX = kernelSize => texConv1D(kernelSize, 'x');\n\n// Texture-based 1D convolution on the x-axis\nexport const texConvY = kernelSize => texConv1D(kernelSize, 'y');\n\n// texture-based 1D convolution function generator\n// (the convolution kernel is stored in a texture)\nfunction texConv1D(kernelSize, axis)\n{\n    // validate input\n    const N = kernelSize >> 1; // idiv 2\n    if(kernelSize < 1 || kernelSize % 2 == 0)\n        Utils.fatal(`Can't perform a texture-based 2D convolution with an invalid kernel size of ${kernelSize}`);\n    else if(axis != 'x' && axis != 'y')\n        Utils.fatal(`Can't perform a texture-based 1D convolution: invalid axis \"${axis}\"`); // this should never happen\n\n    // utilities\n    const foreachKernelElement = fn => symmetricRange(N).map(fn).join('\\n');\n    const generateCode = i => ((axis == 'x') ? `\n        kernel = pixelAt(texKernel, ivec2(${i + N}, 0));\n        value = dot(kernel, magic) * scale + offset;\n        result += pixelAtOffset(image, ivec2(${i}, 0)) * value;\n    ` : `\n        kernel = pixelAt(texKernel, ivec2(${i + N}, 0));\n        value = dot(kernel, magic) * scale + offset;\n        result += pixelAtOffset(image, ivec2(0, ${i})) * value;\n    `);\n\n    // image: target image\n    // texKernel: convolution kernel (all entries in [0,1])\n    // scale: multiply the kernel entries by a number (like 1.0)\n    // offset: add a number to all kernel entries (like 0.0)\n    const shader = `\n    const vec4 magic = vec4(1.0f, 1.0f, 1.0f / 256.0f, 1.0f / 65536.0f);\n    uniform sampler2D image, texKernel;\n    uniform float scale, offset;\n\n    void main()\n    {\n        vec4 kernel = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n        vec4 result = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n        float alpha = threadPixel(image).a;\n        float value = 0.0f;\n\n        ${foreachKernelElement(generateCode)}\n\n        result = clamp(result, 0.0f, 1.0f);\n        color = vec4(result.rgb, alpha);\n    }\n    `;\n\n    return (image, texKernel, scale, offset) => shader;\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * encoders.js\n * Speedy image encoding algorithms\n */\n\n// encode keypoint offsets: maxIterations is an integer in [1,255], determined experimentally\nexport const encodeKeypointOffsets = (image, imageSize, maxIterations) => require('../../shaders/encoders/encode-keypoint-offsets.glsl');\n\n// encode keypoints\nexport const encodeKeypoints = (image, imageSize, encoderLength, descriptorSize) => require('../../shaders/encoders/encode-keypoints.glsl');","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * fast.js\n * FAST corner detection\n */\n\n/*\n * This is a GPU implementation of FAST,\n * \"Features from Accelerated Segment Test\" [1]\n *\n * Reference:\n *\n * [1] Rosten, Edward; Drummond, Tom.\n *     \"Machine learning for high-speed corner detection\"\n *     European Conference on Computer Vision (ECCV-2006)\n *\n */\n\n/*\n * Pixels are encoded as follows:\n *\n * R: \"cornerness\" score IF the pixel is a corner, 0 otherwise\n * G: pixel intensity (left untouched)\n * B: \"cornerness\" score regardless if the pixel is a corner or not\n *    (useful for other algorithms)\n * A: left untouched\n */\n\n// FAST-9_16: requires 9 contiguous pixels\n// on a circumference of 16 pixels\nexport const fast9 = (image, threshold) => require('../../shaders/keypoint-detectors/fast9lg.glsl');\n\n// FAST-9_16 on scale-space\n// Requires image mipmap\nexport const fast9pyr = (image, threshold, minLod, maxLod, log2PyrMaxScale, pyrMaxLevels, resetCorners) => require('../../shaders/keypoint-detectors/fast9pyr.glsl');\n\n// FAST-7_12: requires 7 contiguous pixels\n// on a circumference of 12 pixels\nexport const fast7 = (image, threshold) => require('../../shaders/keypoint-detectors/fast7.glsl');\n\n// FAST-5_8: requires 5 contiguous pixels\n// on a circumference of 8 pixels\nexport const fast5 = (image, threshold) => require('../../shaders/keypoint-detectors/fast5.glsl');\n\n// compute corner score considering a\n// neighboring circumference of 16 pixels\nexport const fastScore16 = (image, threshold) => require('../../shaders/keypoint-detectors/fast-score16.glsl');\n\n// compute corner score considering a\n// neighboring circumference of 12 pixels\nexport const fastScore12 = (image, threshold) => require('../../shaders/keypoint-detectors/fast-score12.glsl');\n\n// compute corner score considering a\n// neighboring circumference of 8 pixels\nexport const fastScore8 = (image, threshold) => require('../../shaders/keypoint-detectors/fast-score8.glsl');\n\n// non-maximum suppression on 8-neighborhood based\n// on the corner score stored on the red channel\nexport const fastSuppression = (image, threshold) => require('../../shaders/keypoint-detectors/fast-suppression.glsl');\n\n// generic scale-space non-maximum suppression\nexport const multiscaleSuppression = (image, lodJump, log2PyrMaxScale, pyrMaxLevels) => require('../../shaders/keypoint-detectors/multiscale-suppression.glsl');\nexport const samescaleSuppression = (image, log2PyrMaxScale, pyrMaxLevels) => require('../../shaders/keypoint-detectors/samescale-suppression.glsl');","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * pyramids.js\n * Image pyramids & scale-space utilities\n */\n\n// pyramid generation\nexport const upsample2 = image => require('../../shaders/pyramids/upsample2.glsl');\nexport const downsample2 = image => require('../../shaders/pyramids/downsample2.glsl');\nexport const upsample3 = image => require('../../shaders/pyramids/upsample3.glsl');\nexport const downsample3 = image => require('../../shaders/pyramids/downsample3.glsl');\n\n// utilities for merging keypoints across multiple scales\nexport const mergeKeypoints = (target, source) => require('../../shaders/pyramids/merge-keypoints.glsl');\nexport const mergeKeypointsAtConsecutiveLevels = (largerImage, smallerImage) => require('../../shaders/pyramids/merge-keypoints-at-consecutive-levels.glsl');\nexport const normalizeKeypoints = (image, imageScale) => require('../../shaders/pyramids/normalize-keypoints.glsl');\n\n// misc\nexport const crop = image => require('../../shaders/pyramids/crop.glsl');\n\n// image scale\n\n/*\n * Image scale is encoded in the alpha channel (a)\n * according to the following model:\n *\n * a(x) = (log2(M) - log2(x)) / (log2(M) + h)\n *\n * where x := scale of the image in the pyramid\n *            it may be 1, 0.5, 0.25, 0.125...\n *            also sqrt(2)/2, sqrt(2)/4... (intra-layers)\n *            (note that lod = -log2(x))\n *\n *       h := height (depth) of the pyramid, an integer\n *            (this is gpu.pyramidHeight)\n *\n *       M := scale upper bound: the maximum supported\n *            scale x for a pyramid layer, a constant\n *            that is preferably a power of two\n *            (this is gpu.pyramidMaxScale)\n *\n *\n *\n * This model has neat properties:\n *\n * Scale image by factor s:\n * a(s*x) = a(x) - log2(s) / (log2(M) + h)\n *\n * Log of scale (scale-axis):\n * log2(x) = log2(M) - (log2(M) + h) * a(x)\n *\n * Bounded output:\n * 0 <= a(x) < 1\n *\n * Since x <= M, it follows that a(x) >= 0 for all x\n * Since x > 1/2^h, it follows that a(x) < 1 for all x\n * Thus, if alpha channel = 1.0, we have no scale data\n *\n *\n *\n * A note on image scale:\n *\n * scale = 1 means an image with its original size\n * scale = 2 means double the size (4x the area)\n * scale = 0.5 means half the size (1/4 the area)\n * and so on...\n */\n\nexport function setScale(scale, pyramidHeight, pyramidMaxScale)\n{\n    const lgM = Math.log2(pyramidMaxScale), eps = 1e-5;\n    const pyramidMinScale = Math.pow(2, -pyramidHeight) + eps;\n    const x = Math.max(pyramidMinScale, Math.min(scale, pyramidMaxScale));\n    const alpha = (lgM - Math.log2(x)) / (lgM + pyramidHeight);\n\n    return (image) => `\n    uniform sampler2D image;\n\n    void main()\n    {\n        color = vec4(threadPixel(image).rgb, float(${alpha}));\n    }\n    `;\n}\n\nexport function scale(scaleFactor, pyramidHeight, pyramidMaxScale)\n{\n    const lgM = Math.log2(pyramidMaxScale);\n    const s = Math.max(1e-5, scaleFactor);\n    const delta = -Math.log2(s) / (lgM + pyramidHeight);\n\n    return (image) => `\n    uniform sampler2D image;\n\n    void main()\n    {\n        vec4 pixel = threadPixel(image);\n        float alpha = clamp(pixel.a + float(${delta}), 0.0f, 1.0f);\n\n        color = vec4(pixel.rgb, alpha);\n    }\n    `;\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * utils.js\n * Utility shaders\n */\n\n// Identity shader: no-operation\nexport const identity = (image) => require('../../shaders/utils/identity.glsl');\n\n// Flip y-axis for output\nexport const flipY = (image) => require('../../shaders/utils/flip-y.glsl');","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * gpu-pyramids.js\n * Image pyramids\n */\n\nimport { GPUProgramGroup } from '../gpu-program-group';\nimport { flipY } from './programs/utils';\nimport { convX, convY } from './programs/convolution';\nimport { upsample2, downsample2, upsample3, downsample3 } from './programs/pyramids';\nimport { mergeKeypoints, mergeKeypointsAtConsecutiveLevels, normalizeKeypoints } from './programs/pyramids';\nimport { setScale, scale, crop } from './programs/pyramids';\n\n/**\n * GPUPyramids\n * Image pyramids\n */\nexport class GPUPyramids extends GPUProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            // initialize pyramid\n            .declare('setBase', setScale(1.0, gpu.pyramidHeight, gpu.pyramidMaxScale))\n \n            // pyramid operations\n            .compose('reduce', '_smoothX', '_smoothY', '_downsample2', '_scale1/2')\n            .compose('expand', '_upsample2', '_smoothX2', '_smoothY2', '_scale2')\n           \n            // intra-pyramid operations (between two pyramid levels)\n            .compose('intraReduce', '_upsample2', '_smoothX2', '_smoothY2', '_downsample3/2', '_scale2/3')\n            .compose('intraExpand', '_upsample3', '_smoothX3', '_smoothY3', '_downsample2/3', '_scale3/2')\n\n            // Merge keypoints across multiple scales\n            .declare('mergeKeypoints', mergeKeypoints)\n            .declare('mergeKeypointsAtConsecutiveLevels', mergeKeypointsAtConsecutiveLevels)\n            .declare('normalizeKeypoints', normalizeKeypoints)\n\n            // Crop texture to width x height of the current pyramid level\n            .declare('crop', crop)\n\n            // kernels for debugging\n            .declare('output', flipY, {\n                ...this.program.hasTextureSize(this._width, this._height),\n                ...this.program.displaysGraphics()\n            })\n\n            .declare('output2', flipY, {\n                ...this.program.hasTextureSize(2 * this._width, 2 * this._height),\n                ...this.program.displaysGraphics()\n            })\n\n            .declare('output3', flipY, {\n                ...this.program.hasTextureSize(3 * this._width, 3 * this._height),\n                ...this.program.displaysGraphics()\n            })\n\n\n            \n            // separable kernels for gaussian smoothing\n            // use [c, b, a, b, c] where a+2c = 2b and a+2b+2c = 1\n            // pick a = 0.4 for gaussian approximation\n            .declare('_smoothX', convX([\n                0.05, 0.25, 0.4, 0.25, 0.05\n            ]))\n            .declare('_smoothY', convY([\n                0.05, 0.25, 0.4, 0.25, 0.05\n            ]))\n\n            // smoothing for 2x image\n            // same rules as above with sum(k) = 2\n            .declare('_smoothX2', convX([\n                0.1, 0.5, 0.8, 0.5, 0.1\n            ]), this.program.hasTextureSize(2 * this._width, 2 * this._height))\n\n            .declare('_smoothY2', convY([\n                0.1, 0.5, 0.8, 0.5, 0.1\n            ], 1.0 / 2.0), this.program.hasTextureSize(2 * this._width, 2 * this._height))\n\n            // smoothing for 3x image\n            // use [1-b, b, 1, b, 1-b], where 0 < b < 1\n            .declare('_smoothX3', convX([\n                0.2, 0.8, 1.0, 0.8, 0.2\n            ]), this.program.hasTextureSize(3 * this._width, 3 * this._height))\n\n            .declare('_smoothY3', convY([\n                0.2, 0.8, 1.0, 0.8, 0.2\n            ], 1.0 / 3.0), this.program.hasTextureSize(3 * this._width, 3 * this._height))\n\n            // upsampling & downsampling\n            .declare('_upsample2', upsample2,\n                this.program.hasTextureSize(2 * this._width, 2 * this._height))\n\n            .declare('_downsample2', downsample2,\n                this.program.hasTextureSize((1 + this._width) / 2, (1 + this._height) / 2))\n\n            .declare('_upsample3', upsample3,\n                this.program.hasTextureSize(3 * this._width, 3 * this._height))\n\n            .declare('_downsample3', downsample3,\n                this.program.hasTextureSize((2 + this._width) / 3, (2 + this._height) / 3))\n\n            .declare('_downsample2/3', downsample2,\n                this.program.hasTextureSize(3 * this._width / 2, 3 * this._height / 2))\n\n            .declare('_downsample3/2', downsample3,\n                this.program.hasTextureSize(2 * this._width / 3, 2 * this._height / 3))\n\n            // adjust the scale coefficients\n            .declare('_scale2', scale(2.0, gpu.pyramidHeight, gpu.pyramidMaxScale),\n                this.program.hasTextureSize(2 * this._width, 2 * this._height))\n\n            .declare('_scale1/2', scale(0.5, gpu.pyramidHeight, gpu.pyramidMaxScale),\n                this.program.hasTextureSize((1 + this._width) / 2, (1 + this._height) / 2))\n\n            .declare('_scale3/2', scale(1.5, gpu.pyramidHeight, gpu.pyramidMaxScale),\n                this.program.hasTextureSize(3 * this._width / 2, 3 * this._height / 2))\n\n            .declare('_scale2/3', scale(2.0 / 3.0, gpu.pyramidHeight, gpu.pyramidMaxScale),\n                this.program.hasTextureSize(2 * this._width / 3, 2 * this._height / 3))\n        ;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * gpu-utils.js\n * GPU utilities\n */\n\nimport { GPUProgramGroup } from '../gpu-program-group';\nimport { identity, flipY } from './programs/utils';\n\n/**\n * GPUUtils\n * Utility operations\n */\nexport class GPUUtils extends GPUProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            // no-operation\n            .declare('identity', identity)\n\n            // flip y-axis\n            .declare('flipY', flipY)\n\n            // output a texture from a pipeline\n            .declare('output', flipY,\n                this.program.displaysGraphics())\n        ;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * shader-preprocessor.js\n * Custom preprocessor for shaders\n */\n\nimport { GLUtils } from './gl-utils';\n\n/**\n * Custom preprocessor for shaders\n */\nexport class ShaderPreprocessor\n{\n    /**\n     * Runs the preprocessor\n     * @param {WebGL2RenderingContext} gl\n     * @param {string} code \n     * @returns {string} preprocessed code\n     */\n    static run(gl, code)\n    {\n        ShaderPreprocessor._includeRegex = ShaderPreprocessor._includeRegex ||\n            (ShaderPreprocessor._includeRegex = /^\\s*@\\s*include\\s+\"(.*?)\"/gm);\n\n        ShaderPreprocessor._commentsRegex = ShaderPreprocessor._commentsRegex ||\n            (ShaderPreprocessor._commentsRegex = [ /\\/\\*(.|\\s)*?\\*\\//g , /\\/\\/.*$/gm ]);\n\n        // remove comments and run the preprocessor\n        return String(code).replace(ShaderPreprocessor._commentsRegex[0], '')\n                           .replace(ShaderPreprocessor._commentsRegex[1], '')\n                           .replace(ShaderPreprocessor._includeRegex,\n                                (_, filename) => readfileSync(gl, filename)\n                            );\n    }\n}\n\n /**\n * Reads a shader from the shaders/include/ folder\n * @param {WebGL2RenderingContext} gl\n * @param {string} filename\n * @returns {string}\n */\nfunction readfileSync(gl, filename)\n{\n    if(String(filename).match(/^[a-zA-Z0-9_\\-]+\\.glsl$/))\n        return require('./shaders/include/' + filename);\n\n    throw GLUtils.Error(`Shader preprocessor: can't read file \\\"${filename}\\\"`);\n}","module.exports = \"const vec4 grey = vec4(0.299f, 0.587f, 0.114f, 0.0f);\\nuniform sampler2D image;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nfloat g = dot(pixel, grey);\\ncolor = vec4(g, g, g, 1.0f);\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform ivec2 imageSize;\\nuniform int maxIterations;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nivec2 pos = threadLocation();\\nint offset = -1;\\nwhile(offset < maxIterations && pos.y < imageSize.y && pixelAt(image, pos).r == 0.0f) {\\n++offset;\\npos.x = (pos.x + 1) % imageSize.x;\\npos.y += int(pos.x == 0);\\n}\\ncolor = vec4(pixel.rg, float(max(0, offset)) / 255.0f, pixel.a);\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform ivec2 imageSize;\\nuniform int encoderLength;\\nuniform int descriptorSize;\\nbool findQthKeypoint(int q, out ivec2 position, out vec4 pixel)\\n{\\nint i = 0, p = 0;\\nfor(position = ivec2(0, 0); position.y < imageSize.y; ) {\\npixel = pixelAt(image, position);\\nif(pixel.r > 0.0f) {\\nif(p++ == q)\\nreturn true;\\n}\\ni += 1 + int(pixel.b * 255.0f);\\nposition = ivec2(i % imageSize.x, i / imageSize.x);\\n}\\nreturn false;\\n}\\nvoid main()\\n{\\nvec4 pixel;\\nivec2 position;\\nivec2 thread = threadLocation();\\nint p = encoderLength * thread.y + thread.x;\\nint d = 2 + descriptorSize / 4;\\nint q = p / d;\\ncolor = vec4(1.0f, 1.0f, 1.0f, 1.0f);\\nif(findQthKeypoint(q, position, pixel)) {\\nint r = p % d;\\nswitch(r) {\\ncase 0: {\\nivec2 lo = position & 255;\\nivec2 hi = position >> 8;\\ncolor = vec4(float(lo.x), float(hi.x), float(lo.y), float(hi.y)) / 255.0f;\\nbreak;\\n}\\ncase 1: {\\nfloat scale = pixel.a;\\nfloat rotation = 0.0f;\\ncolor = vec4(scale, rotation, 0.0f, 0.0f);\\nbreak;\\n}\\ndefault: {\\nint i = r - 2;\\nbreak;\\n}\\n}\\n}\\n}\"","var map = {\n\t\"./global.glsl\": \"./src/gpu/shaders/include/global.glsl\",\n\t\"./math.glsl\": \"./src/gpu/shaders/include/math.glsl\",\n\t\"./pyramids.glsl\": \"./src/gpu/shaders/include/pyramids.glsl\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./src/gpu/shaders/include sync recursive ^\\\\.\\\\/.*$\";","module.exports = \"#define threadLocation() ivec2(texCoord * texSize)\\n#define outputSize() ivec2(texSize)\\n#define threadPixel(img) textureLod((img), texCoord, 0.0f)\\n#define pixelAt(img, pos) texelFetch((img), (pos), 0)\\n#define pixelAtOffset(img, offset) textureLodOffset((img), texCoord, 0.0f, (offset))\"","module.exports = \"#ifndef _MATH_GLSL\\n#define _MATH_GLSL\\n#define PI              3.14159265359f\\n#define PI_OVER_2       1.57079632679f\\n#define PI_OVER_4       0.78539816339f\\n#define USE_FAST_ATAN\\n#ifdef USE_FAST_ATAN\\nfloat fastAtan(float x)\\n{\\nfloat w = 1.0f - abs(x);\\nreturn (w >= 0.0f) ?\\n(PI_OVER_4 + 0.273f * w) * x :\\nsign(x) * PI_OVER_2 - (PI_OVER_4 + 0.273f * (1.0f - abs(1.0f / x))) / x;\\n}\\n#else\\n#define fastAtan(x) atan(x)\\n#endif\\n#ifdef USE_FAST_ATAN\\nfloat fastAtan2(float y, float x)\\n{\\nreturn (x == 0.0f) ? PI_OVER_2 * sign(y) : fastAtan(y / x) + float(x < 0.0f) * PI * sign(y);\\n}\\n#else\\n#define fastAtan2(y, x) atan((y), (x))\\n#endif\\n#endif\"","module.exports = \"#define pyrPixel(img, lod) textureLod((img), texCoord, (lod))\\n#define pyrPixelAtOffset(img, lod, pot, offset) textureLod((img), texCoord + ((pot) * vec2(offset)) / texSize, (lod))\\nfloat encodeLod(float lod, float log2PyrMaxScale, float pyrMaxLevels)\\n{\\nreturn (log2PyrMaxScale + lod) / (log2PyrMaxScale + pyrMaxLevels);\\n}\\nfloat decodeLod(float encodedLod, float log2PyrMaxScale, float pyrMaxLevels)\\n{\\nreturn encodedLod * (log2PyrMaxScale + pyrMaxLevels) - log2PyrMaxScale;\\n}\"","module.exports = \"uniform sampler2D image, layerA, layerB;\\nuniform float scaleA, scaleB, lgM, h;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nfloat score = pixel.r;\\nivec2 zero = ivec2(0, 0);\\nivec2 sizeA = textureSize(layerA, 0);\\nivec2 sizeB = textureSize(layerB, 0);\\nvec2 mid = (texCoord * texSize) + vec2(0.5f, 0.5f);\\nivec2 pa = clamp(ivec2(ceil(mid * scaleA - 1.0f)), zero, sizeA - 2);\\nivec2 pb = clamp(ivec2(ceil(mid * scaleB - 1.0f)), zero, sizeB - 2);\\nvec4 a00 = pixelAt(layerA, pa);\\nvec4 a10 = pixelAt(layerA, pa + ivec2(1, 0));\\nvec4 a01 = pixelAt(layerA, pa + ivec2(0, 1));\\nvec4 a11 = pixelAt(layerA, pa + ivec2(1, 1));\\nvec4 b00 = pixelAt(layerB, pb);\\nvec4 b10 = pixelAt(layerB, pb + ivec2(1, 0));\\nvec4 b01 = pixelAt(layerB, pb + ivec2(0, 1));\\nvec4 b11 = pixelAt(layerB, pb + ivec2(1, 1));\\nfloat maxScore = max(\\nmax(max(a00.r, a10.r), max(a01.r, a11.r)),\\nmax(max(b00.r, b10.r), max(b01.r, b11.r))\\n);\\ncolor = vec4(0.0f, pixel.gba);\\nif(score < maxScore || score == 0.0f)\\nreturn;\\nvec2 ea = fract(mid * scaleA);\\nvec2 eb = fract(mid * scaleB);\\nfloat isa = a00.b * (1.0f - ea.x) * (1.0f - ea.y) +\\na10.b * ea.x * (1.0f - ea.y) +\\na01.b * (1.0f - ea.x) * ea.y +\\na11.b * ea.x * ea.y;\\nfloat isb = b00.b * (1.0f - eb.x) * (1.0f - eb.y) +\\nb10.b * eb.x * (1.0f - eb.y) +\\nb01.b * (1.0f - eb.x) * eb.y +\\nb11.b * eb.x * eb.y;\\ncolor = (isa > score && isa > isb) ? vec4(isa, pixel.gb, a00.a) : pixel;\\ncolor = (isb > score && isb > isa) ? vec4(isb, pixel.gb, b00.a) : pixel;\\nfloat y1 = isa, y2 = isb, y3 = score;\\nfloat x1 = lgM - (lgM + h) * a00.a;\\nfloat x2 = lgM - (lgM + h) * b00.a;\\nfloat x3 = lgM - (lgM + h) * pixel.a;\\nfloat dn = (x1 - x2) * (x1 - x3) * (x2 - x3);\\nif(abs(dn) < 0.00001f)\\nreturn;\\nfloat a = (x3 * (y2 - y1) + x2 * (y1 - y3) + x1 * (y3 - y2)) / dn;\\nif(a >= 0.0f)\\nreturn;\\nfloat b = (x3 * x3 * (y1 - y2) + x2 * x2 * (y3 - y1) + x1 * x1 * (y2 - y3)) / dn;\\nfloat c = (x2 * x3 * (x2 - x3) * y1 + x3 * x1 * (x3 - x1) * y2 + x1 * x2 * (x1 - x2) * y3) / dn;\\nfloat xv = -b / (2.0f * a);\\nfloat yv = c - (b * b) / (4.0f * a);\\nif(xv < min(x1, min(x2, x3)) || xv > max(x1, max(x2, x3)))\\nreturn;\\nfloat interpolatedScale = (lgM - xv) / (lgM + h);\\nfloat interpolatedScore = clamp(yv, 0.0f, 1.0f);\\ncolor = vec4(interpolatedScore, pixel.gb, interpolatedScale);\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform float threshold;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nfloat t = clamp(threshold, 0.0f, 1.0f);\\nfloat ct = pixel.g + t, c_t = pixel.g - t;\\nfloat p0 = pixelAtOffset(image, ivec2(0, 2)).g;\\nfloat p1 = pixelAtOffset(image, ivec2(1, 2)).g;\\nfloat p2 = pixelAtOffset(image, ivec2(2, 1)).g;\\nfloat p3 = pixelAtOffset(image, ivec2(2, 0)).g;\\nfloat p4 = pixelAtOffset(image, ivec2(2, -1)).g;\\nfloat p5 = pixelAtOffset(image, ivec2(1, -2)).g;\\nfloat p6 = pixelAtOffset(image, ivec2(0, -2)).g;\\nfloat p7 = pixelAtOffset(image, ivec2(-1, -2)).g;\\nfloat p8 = pixelAtOffset(image, ivec2(-2, -1)).g;\\nfloat p9 = pixelAtOffset(image, ivec2(-2, 0)).g;\\nfloat p10 = pixelAtOffset(image, ivec2(-2, 1)).g;\\nfloat p11 = pixelAtOffset(image, ivec2(-1, 2)).g;\\nvec2 scores = vec2(0.0f, 0.0f);\\nscores += vec2(max(c_t - p0, 0.0f), max(p0 - ct, 0.0f));\\nscores += vec2(max(c_t - p1, 0.0f), max(p1 - ct, 0.0f));\\nscores += vec2(max(c_t - p2, 0.0f), max(p2 - ct, 0.0f));\\nscores += vec2(max(c_t - p3, 0.0f), max(p3 - ct, 0.0f));\\nscores += vec2(max(c_t - p4, 0.0f), max(p4 - ct, 0.0f));\\nscores += vec2(max(c_t - p5, 0.0f), max(p5 - ct, 0.0f));\\nscores += vec2(max(c_t - p6, 0.0f), max(p6 - ct, 0.0f));\\nscores += vec2(max(c_t - p7, 0.0f), max(p7 - ct, 0.0f));\\nscores += vec2(max(c_t - p8, 0.0f), max(p8 - ct, 0.0f));\\nscores += vec2(max(c_t - p9, 0.0f), max(p9 - ct, 0.0f));\\nscores += vec2(max(c_t - p10, 0.0f), max(p10 - ct, 0.0f));\\nscores += vec2(max(c_t - p11, 0.0f), max(p11 - ct, 0.0f));\\nfloat score = max(scores.x, scores.y) / 12.0f;\\ncolor = vec4(score * step(1.0f, pixel.r), pixel.g, score, pixel.a);\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform float threshold;\\nconst vec4 zeroes = vec4(0.0f, 0.0f, 0.0f, 0.0f);\\nconst vec4 ones = vec4(1.0f, 1.0f, 1.0f, 1.0f);\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nfloat t = clamp(threshold, 0.0f, 1.0f);\\nfloat ct = pixel.g + t, c_t = pixel.g - t;\\nmat4 mp = mat4(\\npixelAtOffset(image, ivec2(0, 3)).g,\\npixelAtOffset(image, ivec2(1, 3)).g,\\npixelAtOffset(image, ivec2(2, 2)).g,\\npixelAtOffset(image, ivec2(3, 1)).g,\\npixelAtOffset(image, ivec2(3, 0)).g,\\npixelAtOffset(image, ivec2(3, -1)).g,\\npixelAtOffset(image, ivec2(2, -2)).g,\\npixelAtOffset(image, ivec2(1, -3)).g,\\npixelAtOffset(image, ivec2(0, -3)).g,\\npixelAtOffset(image, ivec2(-1, -3)).g,\\npixelAtOffset(image, ivec2(-2, -2)).g,\\npixelAtOffset(image, ivec2(-3, -1)).g,\\npixelAtOffset(image, ivec2(-3, 0)).g,\\npixelAtOffset(image, ivec2(-3, 1)).g,\\npixelAtOffset(image, ivec2(-2, 2)).g,\\npixelAtOffset(image, ivec2(-1, 3)).g\\n);\\nmat4 mct = mp - mat4(\\nct, ct, ct, ct,\\nct, ct, ct, ct,\\nct, ct, ct, ct,\\nct, ct, ct, ct\\n), mc_t = mat4(\\nc_t, c_t, c_t, c_t,\\nc_t, c_t, c_t, c_t,\\nc_t, c_t, c_t, c_t,\\nc_t, c_t, c_t, c_t\\n) - mp;\\nvec4 bs = max(mc_t[0], zeroes), ds = max(mct[0], zeroes);\\nbs += max(mc_t[1], zeroes); ds += max(mct[1], zeroes);\\nbs += max(mc_t[2], zeroes); ds += max(mct[2], zeroes);\\nbs += max(mc_t[3], zeroes); ds += max(mct[3], zeroes);\\nfloat score = max(dot(bs, ones), dot(ds, ones)) / 16.0f;\\ncolor = vec4(score * step(1.0f, pixel.r), pixel.g, score, pixel.a);\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform float threshold;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nfloat t = clamp(threshold, 0.0f, 1.0f);\\nfloat ct = pixel.g + t, c_t = pixel.g - t;\\nfloat p0 = pixelAtOffset(image, ivec2(0, 1)).g;\\nfloat p1 = pixelAtOffset(image, ivec2(1, 1)).g;\\nfloat p2 = pixelAtOffset(image, ivec2(1, 0)).g;\\nfloat p3 = pixelAtOffset(image, ivec2(1, -1)).g;\\nfloat p4 = pixelAtOffset(image, ivec2(0, -1)).g;\\nfloat p5 = pixelAtOffset(image, ivec2(-1, -1)).g;\\nfloat p6 = pixelAtOffset(image, ivec2(-1, 0)).g;\\nfloat p7 = pixelAtOffset(image, ivec2(-1, 1)).g;\\nvec2 scores = vec2(0.0f, 0.0f);\\nscores += vec2(max(c_t - p0, 0.0f), max(p0 - ct, 0.0f));\\nscores += vec2(max(c_t - p1, 0.0f), max(p1 - ct, 0.0f));\\nscores += vec2(max(c_t - p2, 0.0f), max(p2 - ct, 0.0f));\\nscores += vec2(max(c_t - p3, 0.0f), max(p3 - ct, 0.0f));\\nscores += vec2(max(c_t - p4, 0.0f), max(p4 - ct, 0.0f));\\nscores += vec2(max(c_t - p5, 0.0f), max(p5 - ct, 0.0f));\\nscores += vec2(max(c_t - p6, 0.0f), max(p6 - ct, 0.0f));\\nscores += vec2(max(c_t - p7, 0.0f), max(p7 - ct, 0.0f));\\nfloat score = max(scores.x, scores.y) / 8.0f;\\ncolor = vec4(score * step(1.0f, pixel.r), pixel.g, score, pixel.a);\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform float threshold;\\nvoid main()\\n{\\nfloat p0 = pixelAtOffset(image, ivec2(0, 1)).r;\\nfloat p1 = pixelAtOffset(image, ivec2(1, 1)).r;\\nfloat p2 = pixelAtOffset(image, ivec2(1, 0)).r;\\nfloat p3 = pixelAtOffset(image, ivec2(1, -1)).r;\\nfloat p4 = pixelAtOffset(image, ivec2(0, -1)).r;\\nfloat p5 = pixelAtOffset(image, ivec2(-1, -1)).r;\\nfloat p6 = pixelAtOffset(image, ivec2(-1, 0)).r;\\nfloat p7 = pixelAtOffset(image, ivec2(-1, 1)).r;\\nfloat m = max(\\nmax(max(p0, p1), max(p2, p3)),\\nmax(max(p4, p5), max(p6, p7))\\n);\\nvec4 pixel = threadPixel(image);\\nfloat score = step(m, pixel.r) * pixel.r;\\ncolor = vec4(score, pixel.gba);\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform float threshold;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nivec2 size = outputSize();\\nvec4 pixel = threadPixel(image);\\ncolor = vec4(0.0f, pixel.gba);\\nif(\\nthread.x >= 3 && thread.x < size.x - 3 &&\\nthread.y >= 3 && thread.y < size.y - 3\\n) {\\nfloat t = clamp(threshold, 0.0f, 1.0f);\\nfloat c = pixel.g;\\nfloat ct = c + t, c_t = c - t;\\nfloat p0 = pixelAtOffset(image, ivec2(0, 1)).g;\\nfloat p1 = pixelAtOffset(image, ivec2(1, 1)).g;\\nfloat p2 = pixelAtOffset(image, ivec2(1, 0)).g;\\nfloat p3 = pixelAtOffset(image, ivec2(1, -1)).g;\\nfloat p4 = pixelAtOffset(image, ivec2(0, -1)).g;\\nfloat p5 = pixelAtOffset(image, ivec2(-1, -1)).g;\\nfloat p6 = pixelAtOffset(image, ivec2(-1, 0)).g;\\nfloat p7 = pixelAtOffset(image, ivec2(-1, 1)).g;\\nbool possibleCorner =\\n((c_t > p1 || c_t > p5) && (c_t > p3 || c_t > p7)) ||\\n((ct < p1  || ct < p5)  && (ct < p3  || ct < p7))  ;\\nif(possibleCorner) {\\nint bright = 0, dark = 0, bc = 0, dc = 0;\\nif(c_t > p0) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p0) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p1) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p1) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p2) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p2) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p3) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p3) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p4) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p4) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p5) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p5) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p6) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p6) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p7) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p7) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(bright < 5 && dark < 5) {\\nif(bc > 0 && bc < 5) do {\\nif(c_t > p0)           bc += 1; else break;\\nif(c_t > p1 && bc < 5) bc += 1; else break;\\nif(c_t > p2 && bc < 5) bc += 1; else break;\\nif(c_t > p3 && bc < 5) bc += 1; else break;\\n} while(false);\\nif(dc > 0 && dc < 5) do {\\nif(ct < p0)           dc += 1; else break;\\nif(ct < p1 && dc < 5) dc += 1; else break;\\nif(ct < p2 && dc < 5) dc += 1; else break;\\nif(ct < p3 && dc < 5) dc += 1; else break;\\n} while(false);\\nif(bc >= 5 || dc >= 5)\\ncolor = vec4(1.0f, pixel.gba);\\n}\\nelse {\\ncolor = vec4(1.0f, pixel.gba);\\n}\\n}\\n}\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform float threshold;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nivec2 size = outputSize();\\nvec4 pixel = threadPixel(image);\\ncolor = vec4(0.0f, pixel.gba);\\nif(\\nthread.x >= 3 && thread.x < size.x - 3 &&\\nthread.y >= 3 && thread.y < size.y - 3\\n) {\\nfloat t = clamp(threshold, 0.0f, 1.0f);\\nfloat c = pixel.g;\\nfloat ct = c + t, c_t = c - t;\\nfloat p0 = pixelAtOffset(image, ivec2(0, 2)).g;\\nfloat p1 = pixelAtOffset(image, ivec2(1, 2)).g;\\nfloat p2 = pixelAtOffset(image, ivec2(2, 1)).g;\\nfloat p3 = pixelAtOffset(image, ivec2(2, 0)).g;\\nfloat p4 = pixelAtOffset(image, ivec2(2, -1)).g;\\nfloat p5 = pixelAtOffset(image, ivec2(1, -2)).g;\\nfloat p6 = pixelAtOffset(image, ivec2(0, -2)).g;\\nfloat p7 = pixelAtOffset(image, ivec2(-1, -2)).g;\\nfloat p8 = pixelAtOffset(image, ivec2(-2, -1)).g;\\nfloat p9 = pixelAtOffset(image, ivec2(-2, 0)).g;\\nfloat p10 = pixelAtOffset(image, ivec2(-2, 1)).g;\\nfloat p11 = pixelAtOffset(image, ivec2(-1, 2)).g;\\nbool possibleCorner =\\n((c_t > p0 || c_t > p6) && (c_t > p3 || c_t > p9)) ||\\n((ct < p0  || ct < p6)  && (ct < p3  || ct < p9))  ;\\nif(possibleCorner) {\\nint bright = 0, dark = 0, bc = 0, dc = 0;\\nif(c_t > p0) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p0) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p1) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p1) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p2) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p2) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p3) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p3) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p4) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p4) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p5) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p5) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p6) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p6) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p7) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p7) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p8) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p8) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p9) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p9) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p10) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p10) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p11) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p11) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(bright < 7 && dark < 7) {\\nif(bc > 0 && bc < 7) do {\\nif(c_t > p0)           bc += 1; else break;\\nif(c_t > p1 && bc < 7) bc += 1; else break;\\nif(c_t > p2 && bc < 7) bc += 1; else break;\\nif(c_t > p3 && bc < 7) bc += 1; else break;\\nif(c_t > p4 && bc < 7) bc += 1; else break;\\nif(c_t > p5 && bc < 7) bc += 1; else break;\\n} while(false);\\nif(dc > 0 && dc < 7) do {\\nif(ct < p0)           dc += 1; else break;\\nif(ct < p1 && dc < 7) dc += 1; else break;\\nif(ct < p2 && dc < 7) dc += 1; else break;\\nif(ct < p3 && dc < 7) dc += 1; else break;\\nif(ct < p4 && dc < 7) dc += 1; else break;\\nif(ct < p5 && dc < 7) dc += 1; else break;\\n} while(false);\\nif(bc >= 7 || dc >= 7)\\ncolor = vec4(1.0f, pixel.gba);\\n}\\nelse {\\ncolor = vec4(1.0f, pixel.gba);\\n}\\n}\\n}\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform float threshold;\\nconst ivec4 margin = ivec4(3, 3, 4, 4);\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nivec2 thread = threadLocation();\\nivec2 size = outputSize();\\ncolor = vec4(0.0f, pixel.gba);\\nif(any(lessThan(ivec4(thread, size - thread), margin)))\\nreturn;\\nfloat t = clamp(threshold, 0.0f, 1.0f);\\nfloat ct = pixel.g + t, c_t = pixel.g - t;\\nfloat p0 = pixelAtOffset(image, ivec2(0, 3)).g;\\nfloat p4 = pixelAtOffset(image, ivec2(3, 0)).g;\\nfloat p8 = pixelAtOffset(image, ivec2(0, -3)).g;\\nfloat p12 = pixelAtOffset(image, ivec2(-3, 0)).g;\\nif(!(\\n((c_t > p0 || c_t > p8) && (c_t > p4 || c_t > p12)) ||\\n((ct < p0  || ct < p8)  && (ct < p4  || ct < p12))\\n))\\nreturn;\\nfloat p1 = pixelAtOffset(image, ivec2(1, 3)).g;\\nfloat p2 = pixelAtOffset(image, ivec2(2, 2)).g;\\nfloat p3 = pixelAtOffset(image, ivec2(3, 1)).g;\\nfloat p5 = pixelAtOffset(image, ivec2(3, -1)).g;\\nfloat p6 = pixelAtOffset(image, ivec2(2, -2)).g;\\nfloat p7 = pixelAtOffset(image, ivec2(1, -3)).g;\\nfloat p9 = pixelAtOffset(image, ivec2(-1, -3)).g;\\nfloat p10 = pixelAtOffset(image, ivec2(-2, -2)).g;\\nfloat p11 = pixelAtOffset(image, ivec2(-3, -1)).g;\\nfloat p13 = pixelAtOffset(image, ivec2(-3, 1)).g;\\nfloat p14 = pixelAtOffset(image, ivec2(-2, 2)).g;\\nfloat p15 = pixelAtOffset(image, ivec2(-1, 3)).g;\\nbool A=(p0>ct),B=(p1>ct),C=(p2>ct),D=(p3>ct),E=(p4>ct),F=(p5>ct),G=(p6>ct),H=(p7>ct),I=(p8>ct),J=(p9>ct),K=(p10>ct),L=(p11>ct),M=(p12>ct),N=(p13>ct),O=(p14>ct),P=(p15>ct),a=(p0<c_t),b=(p1<c_t),c=(p2<c_t),d=(p3<c_t),e=(p4<c_t),f=(p5<c_t),g=(p6<c_t),h=(p7<c_t),i=(p8<c_t),j=(p9<c_t),k=(p10<c_t),l=(p11<c_t),m=(p12<c_t),n=(p13<c_t),o=(p14<c_t),p=(p15<c_t);\\nbool isCorner=A&&(B&&(K&&L&&J&&(M&&N&&O&&P||G&&H&&I&&(M&&N&&O||F&&(M&&N||E&&(M||D))))||C&&(K&&L&&M&&(N&&O&&P||G&&H&&I&&J&&(N&&O||F&&(N||E)))||D&&(N&&(L&&M&&(K&&G&&H&&I&&J&&(O||F)||O&&P)||k&&l&&m&&e&&f&&g&&h&&i&&j)||E&&(O&&(M&&N&&(K&&L&&G&&H&&I&&J||P)||k&&l&&m&&n&&f&&g&&h&&i&&j)||F&&(P&&(N&&O||k&&l&&m&&n&&o&&g&&h&&i&&j)||G&&(O&&P||H&&(P||I)||k&&l&&m&&n&&o&&p&&h&&i&&j)||k&&l&&m&&n&&o&&h&&i&&j&&(p||g))||k&&l&&m&&n&&h&&i&&j&&(o&&(p||g)||f&&(o&&p||g)))||k&&l&&m&&h&&i&&j&&(n&&(o&&p||g&&(o||f))||e&&(n&&o&&p||g&&(n&&o||f))))||k&&l&&h&&i&&j&&(m&&(n&&o&&p||g&&(n&&o||f&&(n||e)))||d&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e)))))||k&&h&&i&&j&&(l&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d))))))||K&&I&&J&&(L&&M&&N&&O&&P||G&&H&&(L&&M&&N&&O||F&&(L&&M&&N||E&&(L&&M||D&&(L||C)))))||h&&i&&j&&(b&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c)))))||k&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c)))))))||B&&(H&&I&&J&&(K&&L&&M&&N&&O&&P&&a||G&&(K&&L&&M&&N&&O&&a||F&&(K&&L&&M&&N&&a||E&&(K&&L&&M&&a||D&&(K&&L&&a||C)))))||a&&k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||C&&(K&&H&&I&&J&&(L&&M&&N&&O&&P&&a&&b||G&&(L&&M&&N&&O&&a&&b||F&&(L&&M&&N&&a&&b||E&&(L&&M&&a&&b||D))))||a&&b&&k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d)))))||D&&(K&&L&&H&&I&&J&&(M&&N&&O&&P&&a&&b&&c||G&&(M&&N&&O&&a&&b&&c||F&&(M&&N&&a&&b&&c||E)))||a&&b&&k&&l&&m&&c&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e))))||E&&(K&&L&&M&&H&&I&&J&&(N&&O&&P&&a&&b&&c&&d||G&&(N&&O&&a&&b&&c&&d||F))||a&&b&&l&&m&&n&&c&&d&&(k&&g&&h&&i&&j&&(o||f)||o&&p))||F&&(K&&L&&M&&N&&H&&I&&J&&(O&&P&&a&&b&&c&&d&&e||G)||a&&b&&m&&n&&o&&c&&d&&e&&(k&&l&&g&&h&&i&&j||p))||G&&(K&&L&&M&&N&&O&&H&&I&&J||a&&b&&n&&o&&p&&c&&d&&e&&f)||H&&(K&&L&&M&&N&&O&&P&&I&&J||a&&b&&o&&p&&c&&d&&e&&f&&g)||a&&(b&&(k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(k&&l&&m&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e)))||d&&(l&&m&&n&&(k&&g&&h&&i&&j&&(o||f)||o&&p)||e&&(m&&n&&o&&(k&&l&&g&&h&&i&&j||p)||f&&(n&&o&&p||g&&(o&&p||h&&(p||i)))))))||k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||h&&i&&j&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c&&(b||k))))));\\ncolor = vec4(float(isCorner), pixel.gba);\\n}\"","module.exports = \"@include \\\"pyramids.glsl\\\"\\nuniform sampler2D image;\\nuniform float threshold;\\nuniform float minLod, maxLod;\\nuniform float log2PyrMaxScale, pyrMaxLevels;\\nuniform bool resetCorners;\\nconst ivec4 margin = ivec4(3, 3, 4, 4);\\nconst vec4 zeroes = vec4(0.0f, 0.0f, 0.0f, 0.0f);\\nconst vec4 ones = vec4(1.0f, 1.0f, 1.0f, 1.0f);\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nivec2 thread = threadLocation();\\nivec2 size = outputSize();\\nfloat t = clamp(threshold, 0.0f, 1.0f);\\nfloat ct = pixel.g + t, c_t = pixel.g - t;\\nfloat pot = pow(2.0f, minLod);\\ncolor = resetCorners ? vec4(0.0f, pixel.g, 0.0f, pixel.a) : pixel;\\nfor(float lod = minLod; lod <= maxLod; (lod += 1.0f), (pot += pot)) {\\npixel = pyrPixel(image, lod);\\nct = pixel.g + t;\\nc_t = pixel.g - t;\\nvec4 p4k = vec4(\\npyrPixelAtOffset(image, lod, pot, ivec2(0, 3)).g,\\npyrPixelAtOffset(image, lod, pot, ivec2(3, 0)).g,\\npyrPixelAtOffset(image, lod, pot, ivec2(0, -3)).g,\\npyrPixelAtOffset(image, lod, pot, ivec2(-3, 0)).g\\n);\\nmat4 mp = mat4(\\np4k.x,\\np4k.y,\\np4k.z,\\np4k.w,\\npyrPixelAtOffset(image, lod, pot, ivec2(1, 3)).g,\\npyrPixelAtOffset(image, lod, pot, ivec2(3, -1)).g,\\npyrPixelAtOffset(image, lod, pot, ivec2(-1, -3)).g,\\npyrPixelAtOffset(image, lod, pot, ivec2(-3, 1)).g,\\npyrPixelAtOffset(image, lod, pot, ivec2(2, 2)).g,\\npyrPixelAtOffset(image, lod, pot, ivec2(2, -2)).g,\\npyrPixelAtOffset(image, lod, pot, ivec2(-2, -2)).g,\\npyrPixelAtOffset(image, lod, pot, ivec2(-2, 2)).g,\\npyrPixelAtOffset(image, lod, pot, ivec2(3, 1)).g,\\npyrPixelAtOffset(image, lod, pot, ivec2(1, -3)).g,\\npyrPixelAtOffset(image, lod, pot, ivec2(-3, -1)).g,\\npyrPixelAtOffset(image, lod, pot, ivec2(-1, 3)).g\\n);\\nbool A=(mp[0][0]>ct),B=(mp[1][0]>ct),C=(mp[2][0]>ct),D=(mp[3][0]>ct),E=(mp[0][1]>ct),F=(mp[1][1]>ct),G=(mp[2][1]>ct),H=(mp[3][1]>ct),I=(mp[0][2]>ct),J=(mp[1][2]>ct),K=(mp[2][2]>ct),L=(mp[3][2]>ct),M=(mp[0][3]>ct),N=(mp[1][3]>ct),O=(mp[2][3]>ct),P=(mp[3][3]>ct),a=(mp[0][0]<c_t),b=(mp[1][0]<c_t),c=(mp[2][0]<c_t),d=(mp[3][0]<c_t),e=(mp[0][1]<c_t),f=(mp[1][1]<c_t),g=(mp[2][1]<c_t),h=(mp[3][1]<c_t),i=(mp[0][2]<c_t),j=(mp[1][2]<c_t),k=(mp[2][2]<c_t),l=(mp[3][2]<c_t),m=(mp[0][3]<c_t),n=(mp[1][3]<c_t),o=(mp[2][3]<c_t),p=(mp[3][3]<c_t);\\nbool isCorner=A&&(B&&(K&&L&&J&&(M&&N&&O&&P||G&&H&&I&&(M&&N&&O||F&&(M&&N||E&&(M||D))))||C&&(K&&L&&M&&(N&&O&&P||G&&H&&I&&J&&(N&&O||F&&(N||E)))||D&&(N&&(L&&M&&(K&&G&&H&&I&&J&&(O||F)||O&&P)||k&&l&&m&&e&&f&&g&&h&&i&&j)||E&&(O&&(M&&N&&(K&&L&&G&&H&&I&&J||P)||k&&l&&m&&n&&f&&g&&h&&i&&j)||F&&(P&&(N&&O||k&&l&&m&&n&&o&&g&&h&&i&&j)||G&&(O&&P||H&&(P||I)||k&&l&&m&&n&&o&&p&&h&&i&&j)||k&&l&&m&&n&&o&&h&&i&&j&&(p||g))||k&&l&&m&&n&&h&&i&&j&&(o&&(p||g)||f&&(o&&p||g)))||k&&l&&m&&h&&i&&j&&(n&&(o&&p||g&&(o||f))||e&&(n&&o&&p||g&&(n&&o||f))))||k&&l&&h&&i&&j&&(m&&(n&&o&&p||g&&(n&&o||f&&(n||e)))||d&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e)))))||k&&h&&i&&j&&(l&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d))))))||K&&I&&J&&(L&&M&&N&&O&&P||G&&H&&(L&&M&&N&&O||F&&(L&&M&&N||E&&(L&&M||D&&(L||C)))))||h&&i&&j&&(b&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c)))))||k&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c)))))))||B&&(H&&I&&J&&(K&&L&&M&&N&&O&&P&&a||G&&(K&&L&&M&&N&&O&&a||F&&(K&&L&&M&&N&&a||E&&(K&&L&&M&&a||D&&(K&&L&&a||C)))))||a&&k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||C&&(K&&H&&I&&J&&(L&&M&&N&&O&&P&&a&&b||G&&(L&&M&&N&&O&&a&&b||F&&(L&&M&&N&&a&&b||E&&(L&&M&&a&&b||D))))||a&&b&&k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d)))))||D&&(K&&L&&H&&I&&J&&(M&&N&&O&&P&&a&&b&&c||G&&(M&&N&&O&&a&&b&&c||F&&(M&&N&&a&&b&&c||E)))||a&&b&&k&&l&&m&&c&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e))))||E&&(K&&L&&M&&H&&I&&J&&(N&&O&&P&&a&&b&&c&&d||G&&(N&&O&&a&&b&&c&&d||F))||a&&b&&l&&m&&n&&c&&d&&(k&&g&&h&&i&&j&&(o||f)||o&&p))||F&&(K&&L&&M&&N&&H&&I&&J&&(O&&P&&a&&b&&c&&d&&e||G)||a&&b&&m&&n&&o&&c&&d&&e&&(k&&l&&g&&h&&i&&j||p))||G&&(K&&L&&M&&N&&O&&H&&I&&J||a&&b&&n&&o&&p&&c&&d&&e&&f)||H&&(K&&L&&M&&N&&O&&P&&I&&J||a&&b&&o&&p&&c&&d&&e&&f&&g)||a&&(b&&(k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(k&&l&&m&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e)))||d&&(l&&m&&n&&(k&&g&&h&&i&&j&&(o||f)||o&&p)||e&&(m&&n&&o&&(k&&l&&g&&h&&i&&j||p)||f&&(n&&o&&p||g&&(o&&p||h&&(p||i)))))))||k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||h&&i&&j&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c&&(b||k))))));\\nfloat scale = encodeLod(lod, log2PyrMaxScale, pyrMaxLevels);\\nmat4 mct = mp - mat4(\\nct, ct, ct, ct,\\nct, ct, ct, ct,\\nct, ct, ct, ct,\\nct, ct, ct, ct\\n), mc_t = mat4(\\nc_t, c_t, c_t, c_t,\\nc_t, c_t, c_t, c_t,\\nc_t, c_t, c_t, c_t,\\nc_t, c_t, c_t, c_t\\n) - mp;\\nvec4 bs = max(mc_t[0], zeroes), ds = max(mct[0], zeroes);\\nbs += max(mc_t[1], zeroes); ds += max(mct[1], zeroes);\\nbs += max(mc_t[2], zeroes); ds += max(mct[2], zeroes);\\nbs += max(mc_t[3], zeroes); ds += max(mct[3], zeroes);\\nfloat score = max(dot(bs, ones), dot(ds, ones)) / 16.0f;\\nivec2 remainder = thread % int(pot);\\nscore *= float(remainder.x + remainder.y == 0);\\nbool isBestCorner = isCorner && (score > color.r);\\ncolor = isBestCorner ? vec4(score, color.g, score, scale) : color;\\n}\\n}\"","module.exports = \"@include \\\"pyramids.glsl\\\"\\nuniform sampler2D image;\\nuniform float lodJump;\\nuniform float log2PyrMaxScale, pyrMaxLevels;\\nconst float scaleEps = 1e-5;\\n#define ENABLE_INNER_RING\\n#define ENABLE_MIDDLE_RING\\n#define ENABLE_OUTER_RING\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nfloat lod = decodeLod(pixel.a, log2PyrMaxScale, pyrMaxLevels);\\ncolor = pixel;\\nif(pixel.r == 0.0f)\\nreturn;\\n#ifdef ENABLE_INNER_RING\\nvec4 p0 = pixelAtOffset(image, ivec2(0, 1));\\nvec4 p1 = pixelAtOffset(image, ivec2(1, 1));\\nvec4 p2 = pixelAtOffset(image, ivec2(1, 0));\\nvec4 p3 = pixelAtOffset(image, ivec2(1, -1));\\nvec4 p4 = pixelAtOffset(image, ivec2(0, -1));\\nvec4 p5 = pixelAtOffset(image, ivec2(-1, -1));\\nvec4 p6 = pixelAtOffset(image, ivec2(-1, 0));\\nvec4 p7 = pixelAtOffset(image, ivec2(-1, 1));\\n#else\\nvec4 p0, p1, p2, p3, p4, p5, p6, p7;\\np0 = p1 = p2 = p3 = p4 = p5 = p6 = p7 = vec4(0.0f, 0.0f, 0.0f, 1.0f);\\n#endif\\n#ifdef ENABLE_MIDDLE_RING\\nvec4 q0 = pixelAtOffset(image, ivec2(0, 2));\\nvec4 q1 = pixelAtOffset(image, ivec2(1, 2));\\nvec4 q2 = pixelAtOffset(image, ivec2(2, 2));\\nvec4 q3 = pixelAtOffset(image, ivec2(2, 1));\\nvec4 q4 = pixelAtOffset(image, ivec2(2, 0));\\nvec4 q5 = pixelAtOffset(image, ivec2(2, -1));\\nvec4 q6 = pixelAtOffset(image, ivec2(2, -2));\\nvec4 q7 = pixelAtOffset(image, ivec2(1, -2));\\nvec4 q8 = pixelAtOffset(image, ivec2(0, -2));\\nvec4 q9 = pixelAtOffset(image, ivec2(-1, -2));\\nvec4 q10 = pixelAtOffset(image, ivec2(-2, -2));\\nvec4 q11 = pixelAtOffset(image, ivec2(-2, -1));\\nvec4 q12 = pixelAtOffset(image, ivec2(-2, 0));\\nvec4 q13 = pixelAtOffset(image, ivec2(-2, 1));\\nvec4 q14 = pixelAtOffset(image, ivec2(-2, 2));\\nvec4 q15 = pixelAtOffset(image, ivec2(-1, 2));\\n#else\\nvec4 q0, q1, q2, q3, q4, q5, q6, q7, q8, q9, q10, q11, q12, q13, q14, q15;\\nq0 = q1 = q2 = q3 = q4 = q5 = q6 = q7 = q8 = q9 = q10 =\\nq11 = q12 = q13 = q14 = q15= vec4(0.0f, 0.0f, 0.0f, 1.0f);\\n#endif\\n#ifdef ENABLE_OUTER_RING\\nvec4 r0 = pixelAtOffset(image, ivec2(0, 3));\\nvec4 r1 = pixelAtOffset(image, ivec2(1, 3));\\nvec4 r2 = pixelAtOffset(image, ivec2(3, 1));\\nvec4 r3 = pixelAtOffset(image, ivec2(3, 0));\\nvec4 r4 = pixelAtOffset(image, ivec2(3, -1));\\nvec4 r5 = pixelAtOffset(image, ivec2(1, -3));\\nvec4 r6 = pixelAtOffset(image, ivec2(0, -3));\\nvec4 r7 = pixelAtOffset(image, ivec2(-1, -3));\\nvec4 r8 = pixelAtOffset(image, ivec2(-3, -1));\\nvec4 r9 = pixelAtOffset(image, ivec2(-3, 0));\\nvec4 r10 = pixelAtOffset(image, ivec2(-3, 1));\\nvec4 r11 = pixelAtOffset(image, ivec2(-1, 3));\\nvec4 r12 = pixelAtOffset(image, ivec2(0, 4));\\nvec4 r13 = pixelAtOffset(image, ivec2(4, 0));\\nvec4 r14 = pixelAtOffset(image, ivec2(0, -4));\\nvec4 r15 = pixelAtOffset(image, ivec2(-4, 0));\\n#else\\nvec4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15;\\nr0 = r1 = r2 = r3 = r4 = r5 = r6 = r7 = r8 = r9 = r10 =\\nr11 = r12 = r13 = r14 = r15 = vec4(0.0f, 0.0f, 0.0f, 1.0f);\\n#endif\\nfloat lodPlus = min(lod + lodJump, pyrMaxLevels - 1.0f);\\nfloat lodMinus = max(lod - lodJump, 0.0f);\\nfloat alphaPlus = encodeLod(lodPlus, log2PyrMaxScale, pyrMaxLevels);\\nfloat alphaMinus = encodeLod(lodMinus, log2PyrMaxScale, pyrMaxLevels);\\nmat3 innerScore = mat3(\\np0.r * float(abs(p0.a - alphaPlus) < scaleEps || abs(p0.a - alphaMinus) < scaleEps),\\np1.r * float(abs(p1.a - alphaPlus) < scaleEps || abs(p1.a - alphaMinus) < scaleEps),\\np2.r * float(abs(p2.a - alphaPlus) < scaleEps || abs(p2.a - alphaMinus) < scaleEps),\\np3.r * float(abs(p3.a - alphaPlus) < scaleEps || abs(p3.a - alphaMinus) < scaleEps),\\np4.r * float(abs(p4.a - alphaPlus) < scaleEps || abs(p4.a - alphaMinus) < scaleEps),\\np5.r * float(abs(p5.a - alphaPlus) < scaleEps || abs(p5.a - alphaMinus) < scaleEps),\\np6.r * float(abs(p6.a - alphaPlus) < scaleEps || abs(p6.a - alphaMinus) < scaleEps),\\np7.r * float(abs(p7.a - alphaPlus) < scaleEps || abs(p7.a - alphaMinus) < scaleEps),\\n0.0f\\n);\\nmat4 middleScore = mat4(\\nq0.r * float(abs(q0.a - alphaPlus) < scaleEps || abs(q0.a - alphaMinus) < scaleEps),\\nq1.r * float(abs(q1.a - alphaPlus) < scaleEps || abs(q1.a - alphaMinus) < scaleEps),\\nq2.r * float(abs(q2.a - alphaPlus) < scaleEps || abs(q2.a - alphaMinus) < scaleEps),\\nq3.r * float(abs(q3.a - alphaPlus) < scaleEps || abs(q3.a - alphaMinus) < scaleEps),\\nq4.r * float(abs(q4.a - alphaPlus) < scaleEps || abs(q4.a - alphaMinus) < scaleEps),\\nq5.r * float(abs(q5.a - alphaPlus) < scaleEps || abs(q5.a - alphaMinus) < scaleEps),\\nq6.r * float(abs(q6.a - alphaPlus) < scaleEps || abs(q6.a - alphaMinus) < scaleEps),\\nq7.r * float(abs(q7.a - alphaPlus) < scaleEps || abs(q7.a - alphaMinus) < scaleEps),\\nq8.r * float(abs(q8.a - alphaPlus) < scaleEps || abs(q8.a - alphaMinus) < scaleEps),\\nq9.r * float(abs(q9.a - alphaPlus) < scaleEps || abs(q9.a - alphaMinus) < scaleEps),\\nq10.r * float(abs(q10.a - alphaPlus) < scaleEps || abs(q10.a - alphaMinus) < scaleEps),\\nq11.r * float(abs(q11.a - alphaPlus) < scaleEps || abs(q11.a - alphaMinus) < scaleEps),\\nq12.r * float(abs(q12.a - alphaPlus) < scaleEps || abs(q12.a - alphaMinus) < scaleEps),\\nq13.r * float(abs(q13.a - alphaPlus) < scaleEps || abs(q13.a - alphaMinus) < scaleEps),\\nq14.r * float(abs(q14.a - alphaPlus) < scaleEps || abs(q14.a - alphaMinus) < scaleEps),\\nq15.r * float(abs(q15.a - alphaPlus) < scaleEps || abs(q15.a - alphaMinus) < scaleEps)\\n);\\nmat4 outerScore = mat4(\\nr0.r * float(abs(r0.a - alphaPlus) < scaleEps || abs(r0.a - alphaMinus) < scaleEps),\\nr1.r * float(abs(r1.a - alphaPlus) < scaleEps || abs(r1.a - alphaMinus) < scaleEps),\\nr2.r * float(abs(r2.a - alphaPlus) < scaleEps || abs(r2.a - alphaMinus) < scaleEps),\\nr3.r * float(abs(r3.a - alphaPlus) < scaleEps || abs(r3.a - alphaMinus) < scaleEps),\\nr4.r * float(abs(r4.a - alphaPlus) < scaleEps || abs(r4.a - alphaMinus) < scaleEps),\\nr5.r * float(abs(r5.a - alphaPlus) < scaleEps || abs(r5.a - alphaMinus) < scaleEps),\\nr6.r * float(abs(r6.a - alphaPlus) < scaleEps || abs(r6.a - alphaMinus) < scaleEps),\\nr7.r * float(abs(r7.a - alphaPlus) < scaleEps || abs(r7.a - alphaMinus) < scaleEps),\\nr8.r * float(abs(r8.a - alphaPlus) < scaleEps || abs(r8.a - alphaMinus) < scaleEps),\\nr9.r * float(abs(r9.a - alphaPlus) < scaleEps || abs(r9.a - alphaMinus) < scaleEps),\\nr10.r * float(abs(r10.a - alphaPlus) < scaleEps || abs(r10.a - alphaMinus) < scaleEps),\\nr11.r * float(abs(r11.a - alphaPlus) < scaleEps || abs(r11.a - alphaMinus) < scaleEps),\\nr12.r * float(abs(r12.a - alphaPlus) < scaleEps || abs(r12.a - alphaMinus) < scaleEps),\\nr13.r * float(abs(r13.a - alphaPlus) < scaleEps || abs(r13.a - alphaMinus) < scaleEps),\\nr14.r * float(abs(r14.a - alphaPlus) < scaleEps || abs(r14.a - alphaMinus) < scaleEps),\\nr15.r * float(abs(r15.a - alphaPlus) < scaleEps || abs(r15.a - alphaMinus) < scaleEps)\\n);\\nvec3 maxInnerScore3 = max(innerScore[0], max(innerScore[1], innerScore[2]));\\nvec4 maxMiddleScore4 = max(max(middleScore[0], middleScore[1]), max(middleScore[2], middleScore[3]));\\nvec4 maxOuterScore4 = max(max(outerScore[0], outerScore[1]), max(outerScore[2], outerScore[3]));\\nfloat maxInnerScore = max(maxInnerScore3.x, max(maxInnerScore3.y, maxInnerScore3.z));\\nfloat maxMiddleScore = max(max(maxMiddleScore4.x, maxMiddleScore4.y), max(maxMiddleScore4.z, maxMiddleScore4.w));\\nfloat maxOuterScore = max(max(maxOuterScore4.x, maxOuterScore4.y), max(maxOuterScore4.z, maxOuterScore4.w));\\nfloat maxScore = max(maxInnerScore, max(maxMiddleScore, maxOuterScore));\\nfloat myScore = step(maxScore, pixel.r) * pixel.r;\\ncolor = vec4(myScore, pixel.gba);\\n}\"","module.exports = \"@include \\\"pyramids.glsl\\\"\\nuniform sampler2D image;\\nuniform float log2PyrMaxScale, pyrMaxLevels;\\nconst float scaleEps = 1e-5;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nivec2 thread = threadLocation();\\nfloat lod = decodeLod(pixel.a, log2PyrMaxScale, pyrMaxLevels);\\nfloat pot = pow(2.0f, lod);\\ncolor = pixel;\\nif(pixel.r == 0.0f)\\nreturn;\\nvec4 p0 = pixelAtOffset(image, ivec2(0, 1));\\nvec4 p1 = pixelAtOffset(image, ivec2(1, 1));\\nvec4 p2 = pixelAtOffset(image, ivec2(1, 0));\\nvec4 p3 = pixelAtOffset(image, ivec2(1, -1));\\nvec4 p4 = pixelAtOffset(image, ivec2(0, -1));\\nvec4 p5 = pixelAtOffset(image, ivec2(-1, -1));\\nvec4 p6 = pixelAtOffset(image, ivec2(-1, 0));\\nvec4 p7 = pixelAtOffset(image, ivec2(-1, 1));\\nmat3 score = mat3(\\np0.r * float(abs(p0.a - pixel.a) < scaleEps),\\np1.r * float(abs(p1.a - pixel.a) < scaleEps),\\np2.r * float(abs(p2.a - pixel.a) < scaleEps),\\np3.r * float(abs(p3.a - pixel.a) < scaleEps),\\np4.r * float(abs(p4.a - pixel.a) < scaleEps),\\np5.r * float(abs(p5.a - pixel.a) < scaleEps),\\np6.r * float(abs(p6.a - pixel.a) < scaleEps),\\np7.r * float(abs(p7.a - pixel.a) < scaleEps),\\n0.0f\\n);\\nvec3 maxScore3 = max(score[0], max(score[1], score[2]));\\nfloat maxScore = max(maxScore3.x, max(maxScore3.y, maxScore3.z));\\nfloat myScore = step(maxScore, pixel.r) * pixel.r;\\ncolor = vec4(myScore, pixel.gba);\\n}\"","module.exports = \"uniform sampler2D image;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nivec2 size = outputSize();\\nivec2 zero = ivec2(0, 0);\\ncolor = pixelAt(image, clamp(thread, zero, size - 1));\\n}\"","module.exports = \"uniform sampler2D image;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nivec2 pos = min(thread * 2, textureSize(image, 0) - 1);\\ncolor = pixelAt(image, pos);\\n}\"","module.exports = \"uniform sampler2D image;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nivec2 pos = min(thread * 3, textureSize(image, 0) - 1);\\ncolor = pixelAt(image, pos);\\n}\"","module.exports = \"uniform sampler2D largerImage;\\nuniform sampler2D smallerImage;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nvec4 lg = pixelAt(largerImage, min(thread, textureSize(largerImage, 0) - 1));\\nvec4 sm = pixelAt(smallerImage, min(thread / 2, textureSize(smallerImage, 0) - 1));\\ncolor = ((((thread.x & 1) + (thread.y & 1)) == 0) && (sm.r > lg.r)) ? vec4(sm.r, lg.gb, sm.a) : lg;\\n}\"","module.exports = \"uniform sampler2D target;\\nuniform sampler2D source;\\nvoid main()\\n{\\nvec4 a = threadPixel(target);\\nvec4 b = threadPixel(source);\\ncolor = (b.r > a.r) ? vec4(b.r, a.gb, b.a) : a;\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform float imageScale;\\nconst ivec2 one = ivec2(1, 1);\\n#define B2(expr) bvec2((expr),(expr))\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nivec2 size = outputSize();\\nivec2 scaled = ivec2((texCoord * texSize) * imageScale);\\nivec2 imageSize = textureSize(image, 0);\\nvec4 pixel = threadPixel(image);\\nvec4 p0 = pixelAt(image, min(scaled, imageSize-1));\\nvec4 p1 = pixelAt(image, min(scaled + ivec2(0, 1), imageSize-1));\\nvec4 p2 = pixelAt(image, min(scaled + ivec2(1, 0), imageSize-1));\\nvec4 p3 = pixelAt(image, min(scaled + ivec2(1, 1), imageSize-1));\\nbool gotCorner = ((thread.x & 1) + (thread.y & 1) == 0) &&\\n(all(lessThan(scaled + one, size))) &&\\n(p0.r + p1.r + p2.r + p3.r > 0.0f);\\nvec2 best = mix(\\nvec2(0.0f, pixel.a),\\nmix(\\nmix(\\np1.r > p3.r ? p1.ra : p3.ra,\\np1.r > p2.r ? p1.ra : p2.ra,\\nB2(p2.r > p3.r)\\n),\\nmix(\\np0.r > p3.r ? p0.ra : p3.ra,\\np0.r > p2.r ? p0.ra : p2.ra,\\nB2(p2.r > p3.r)\\n),\\nB2(p0.r > p1.r)\\n),\\nB2(gotCorner)\\n);\\ncolor = vec4(best.x, pixel.gb, best.y);\\n}\"","module.exports = \"uniform sampler2D image;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nvec4 pixel = pixelAt(image, thread / 2);\\ncolor = (((thread.x + thread.y) & 1) == 0) ? pixel : vec4(0.0f, 0.0f, 0.0f, pixel.a);\\n}\"","module.exports = \"uniform sampler2D image;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nvec4 pixel = pixelAt(image, thread / 3);\\nbool cond = ((thread.x - (thread.y % 3) + 3) % 3) == 0;\\ncolor = (((thread.x - (thread.y % 3) + 3) % 3) == 0) ? pixel : vec4(0.0f, 0.0f, 0.0f, pixel.a);\\n}\"","module.exports = \"uniform sampler2D image;\\nvoid main() {\\nivec2 pos = threadLocation();\\npos.y = int(texSize.y) - 1 - pos.y;\\ncolor = pixelAt(image, pos);\\n}\"","module.exports = \"uniform sampler2D image;\\nvoid main()\\n{\\ncolor = threadPixel(image);\\n}\"","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-gpu.js\n * GPU routines for accelerated computer vision\n */\n\nimport { SpeedyProgram } from './speedy-program.js';\nimport { GLUtils } from './gl-utils.js';\nimport { Utils } from '../utils/utils';\nimport { GPUUtils } from './program-groups/utils';\nimport { GPUColors } from './program-groups/colors';\nimport { GPUFilters } from './program-groups/filters';\nimport { GPUKeypoints } from './program-groups/keypoints';\nimport { GPUEncoders } from './program-groups/encoders';\nimport { GPUPyramids } from './program-groups/pyramids';\n\n// Limits\nconst MAX_TEXTURE_LENGTH = 65534; // 2^n - 2 due to encoding\nconst PYRAMID_MAX_LEVELS = 4; // max depth in scale-space\nconst PYRAMID_MAX_SCALE = 2; // preferably a power of 2 (image scale can go up to this)\n\n// Available program groups\n// (maps group name to class name)\nconst PROGRAM_GROUPS = {\n    'utils': GPUUtils,\n    'colors': GPUColors,\n    'filters': GPUFilters,\n    'keypoints': GPUKeypoints,\n    'encoders': GPUEncoders,\n    'pyramids': GPUPyramids,\n};\n\n/**\n * GPU routines for\n * accelerated computer vision\n */\nexport class SpeedyGPU\n{\n    /**\n     * Class constructor\n     * @param {number} width Texture width\n     * @param {number} height Texture height\n     */\n    constructor(width, height)\n    {\n        // does the browser support WebGL2?\n        checkWebGL2Availability();\n\n        // read & validate texture size\n        this._width = Math.max(1, width | 0);\n        this._height = Math.max(1, height | 0);\n        if(this._width > MAX_TEXTURE_LENGTH || this._height > MAX_TEXTURE_LENGTH) {\n            Utils.warning(`Maximum texture size exceeded (using ${this._width} x ${this._height}).`);\n            this._width = Math.min(this._width, MAX_TEXTURE_LENGTH);\n            this._height = Math.min(this._height, MAX_TEXTURE_LENGTH);\n        }\n\n        // setup WebGL\n        this._setupWebGL();\n    }\n\n    /**\n     * Texture width\n     * @returns {number}\n     */\n    get width()\n    {\n        return this._width;\n    }\n\n    /**\n     * Texture height\n     * @returns {number}\n     */\n    get height()\n    {\n        return this._height;\n    }\n\n    /**\n     * Access the program groups of a pyramid level\n     * sizeof(pyramid(i)) = sizeof(pyramid(0)) / 2^i\n     * @param {number} level a number in 0, 1, ..., PYRAMID_MAX_LEVELS - 1\n     * @returns {Array}\n     */\n    pyramid(level)\n    {\n        const lv = level | 0;\n\n        if(lv < 0 || lv >= PYRAMID_MAX_LEVELS)\n            Utils.fatal(`Invalid pyramid level: ${lv}`);\n\n        return this._pyramid[lv];\n    }\n\n    /**\n     * Access the program groups of an intra-pyramid level\n     * The intra-pyramid encodes layers between pyramid layers\n     * sizeof(intraPyramid(0)) = 1.5 * sizeof(pyramid(0))\n     * sizeof(intraPyramid(1)) = 1.5 * sizeof(pyramid(1))\n     * @param {number} level a number in 0, 1, ..., PYRAMID_MAX_LEVELS\n     * @returns {Array}\n     */\n    intraPyramid(level)\n    {\n        const lv = level | 0;\n\n        if(lv < 0 || lv >= PYRAMID_MAX_LEVELS + 1)\n            Utils.fatal(`Invalid intra-pyramid level: ${lv}`);\n\n        return this._intraPyramid[lv];\n    }\n\n    /**\n     * The number of layers of the pyramid\n     * @returns {number}\n     */\n    get pyramidHeight()\n    {\n        return PYRAMID_MAX_LEVELS;\n    }\n\n    /**\n     * The maximum supported scale for a pyramid layer\n     * @returns {number}\n     */\n    get pyramidMaxScale()\n    {\n        return PYRAMID_MAX_SCALE;\n    }\n\n    /**\n     * WebGL context\n     * Be careful when caching this, as the context may be lost!\n     * @returns {WebGL2RenderingContext}\n     */\n    get gl()\n    {\n        return this._gl;\n    }\n\n    /**\n     * Internal canvas\n     * @returns {HTMLCanvasElement|OffscreenCanvas}\n     */\n    get canvas()\n    {\n        return this._canvas;\n    }\n\n    /**\n     * Upload data to the GPU\n     * @param {ImageBitmap|ImageData|ArrayBufferView|HTMLImageElement|HTMLVideoElement|HTMLCanvasElement} data \n     * @param {number} [width]\n     * @param {number} [height] \n     * @returns {WebGLTexture}\n     */\n    upload(data, width = -1, height = -1)\n    {\n        const gl = this._gl;\n\n        // lost GL context?\n        if(gl.isContextLost()) {\n            Utils.warning(`Can't upload texture without a WebGL context`);\n            return (this._inputTexture = null);\n        }\n\n        // default values\n        if(width < 0)\n            width = gl.canvas.width;\n        if(height < 0)\n            height = gl.canvas.height;\n\n        // invalid dimensions?\n        if(width == 0 || height == 0)\n            throw GLUtils.Error(`Can't upload an image of area 0`);\n\n        // create or recreate & size texture\n        if(this._inputTexture === null) {\n            gl.canvas.width = Math.max(gl.canvas.width, width);\n            gl.canvas.height = Math.max(gl.canvas.height, height);\n            this._inputTexture = Array(2).fill(null).map(_ =>\n                GLUtils.createTexture(gl, gl.canvas.width, gl.canvas.height));\n        }\n        else if(width > gl.canvas.width || height > gl.canvas.height) {\n            Utils.warning(`Resizing input texture to ${width} x ${height}`)\n            this._inputTexture.forEach(inputTexture =>\n                GLUtils.destroyTexture(gl, inputTexture));\n            return this.upload(data, width, height);\n        }\n\n        // use round-robin to mitigate WebGL's implicit synchronization\n        // and maybe minimize texture upload times\n        this._inputTextureIndex = 1 - this._inputTextureIndex;\n\n        // done! note: the input texture is upside-down, i.e.,\n        // flipped on the y-axis. We need to unflip it on the\n        // output, so that (0,0) becomes the top-left corner\n        GLUtils.uploadToTexture(gl, this._inputTexture[this._inputTextureIndex], width, height, data);\n        return this._inputTexture[this._inputTextureIndex];\n    }\n\n    /**\n     * Create a SpeedyProgram that runs on the GPU\n     * @param {Function} shaderdecl A function that returns GLSL code\n     * @param {object} [options] SpeedyProgram options\n     * @returns {SpeedyProgram} new instance\n     */\n    createProgram(shaderdecl, options = { })\n    {\n        const gl = this._gl;\n\n        return new SpeedyProgram(gl, shaderdecl, {\n            output: [ gl.canvas.width, gl.canvas.height ],\n            ...options\n        });\n    }\n\n    /**\n     * Clear the internal canvas\n     */\n    /*clearCanvas()\n    {\n        const gl = this._gl;\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n        gl.clearColor(0, 0, 0, 1);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n    }*/\n\n    /**\n     * Lose & restore the WebGL context\n     * @param {number} [timeToRestore] in seconds\n     * @return {Promise} resolves as soon as the context is restored,\n     *                   or as soon as it is lost if timeToRestore is Infinity\n     */\n    loseAndRestoreWebGLContext(timeToRestore = 1.0)\n    {\n        const gl = this._gl;\n\n        if(gl.isContextLost())\n            return Promise.reject('Context already lost');\n\n        const ext = gl.getExtension('WEBGL_lose_context');\n\n        if(ext) {\n            ext.loseContext();\n            return new Promise(resolve => {\n                if(isFinite(timeToRestore)) {\n                    setTimeout(() => {\n                        ext.restoreContext();\n                        setTimeout(() => resolve(), 0); // next frame\n                    }, Math.max(timeToRestore, 0) * 1000.0);\n                }\n                else\n                    resolve(); // won't restore\n            });\n        }\n        else\n            throw GLUtils.Error('WEBGL_lose_context is unavailable');\n    }\n\n    /**\n     * Lose the WebGL context.\n     * This is a way to manually free resources.\n     */\n    loseWebGLContext()\n    {\n        this._omitGLContextWarning = true;\n        return this.loseAndRestoreWebGLContext(Infinity);\n    }\n\n    // setup WebGL\n    _setupWebGL()\n    {\n        const width = this._width;\n        const height = this._height;\n\n        // initializing\n        this._pyramid = null;\n        this._intraPyramid = null;\n        this._inputTexture = null;\n        this._inputTextureIndex = 0;\n        this._omitGLContextWarning = false;\n        if(this._canvas !== undefined)\n            delete this._canvas;\n\n        // create canvas\n        this._canvas = createCanvas(width, height);\n        this._canvas.addEventListener('webglcontextlost', ev => {\n            if(!this._omitGLContextWarning)\n                Utils.warning('Lost WebGL context');\n            ev.preventDefault();\n        }, false);\n        this._canvas.addEventListener('webglcontextrestored', ev => {\n            if(!this._omitGLContextWarning)\n                Utils.warning('Restoring WebGL context...');\n            this._setupWebGL();\n        }, false);\n\n        // create WebGL context\n        this._gl = createWebGLContext(this._canvas);\n\n        // spawn program groups\n        spawnProgramGroups.call(this, this, width, height);\n\n        // spawn pyramids of program groups\n        this._pyramid = this._buildPyramid(width, height, 1.0, PYRAMID_MAX_LEVELS);\n        this._intraPyramid = this._buildPyramid(width, height, 1.5, PYRAMID_MAX_LEVELS + 1);\n    }\n\n    // build a pyramid, where each level stores the program groups\n    _buildPyramid(imageWidth, imageHeight, baseScale, numLevels)\n    {\n        let scale = +baseScale;\n        let width = (imageWidth * scale) | 0, height = (imageHeight * scale) | 0;\n        let pyramid = new Array(numLevels);\n\n        for(let i = 0; i < pyramid.length; i++) {\n            pyramid[i] = { width, height, scale };\n            spawnProgramGroups.call(pyramid[i], this, width, height);\n            width = ((1 + width) / 2) | 0;\n            height = ((1 + height) / 2) | 0;\n            scale /= 2;\n        }\n\n        return pyramid;\n    }\n}\n\n// Create a canvas\nfunction createCanvas(width, height)\n{\n    const inWorker = (typeof importScripts === 'function') && (typeof WorkerGlobalScope !== 'undefined');\n\n    if(inWorker) {\n        if(typeof OffscreenCanvas !== 'function')\n            throw GLUtils.Error('OffscreenCanvas is not available in your browser. Please upgrade.');\n\n        return new OffscreenCanvas(width, height);\n    }\n    else {\n        const canvas = document.createElement('canvas');\n        canvas.width = width;\n        canvas.height = height;\n        return canvas;\n    }\n}\n\n// Checks if the browser supports WebGL2\nfunction checkWebGL2Availability()\n{\n    if(typeof WebGL2RenderingContext === 'undefined')\n        throw GLUtils.Error('WebGL2 is required by this application, but it\\'s not available in your browser. Please use a different browser.');\n}\n\n// Create a WebGL2 context\nfunction createWebGLContext(canvas)\n{\n    const gl = canvas.getContext('webgl2', {\n        premultipliedAlpha: false,\n        preserveDrawingBuffer: false,\n        //preferLowPowerToHighPerformance: false,\n        alpha: true,\n        antialias: false,\n        depth: false,\n        stencil: false,\n    });\n\n    if(!gl)\n        throw GLUtils.Error('Can\\'t create WebGL2 context. Try in a different browser.');\n\n    return gl;\n}\n\n// Spawn program groups\nfunction spawnProgramGroups(gpu, width, height)\n{\n    // counter for handling lost WebGL context\n    if(spawnProgramGroups._cnt === undefined)\n        spawnProgramGroups._cnt = 0;\n    if(gpu == this) // false on pyramids\n        ++spawnProgramGroups._cnt;\n    const cnt = spawnProgramGroups._cnt;\n\n    // all program groups are available via getters\n    for(let g in PROGRAM_GROUPS) {\n        Object.defineProperty(this, g, {\n            get: (() => {\n                const grp = ('_' + g) + cnt, prevGrp = ('_' + g) + (cnt - 1);\n\n                // remove old groups (GL context lost)\n                if(this.hasOwnProperty(prevGrp))\n                    delete this[prevGrp];\n\n                // lazy instantiation\n                return (function() {\n                    return this[grp] || (this[grp] = new (PROGRAM_GROUPS[g])(gpu, width, height));\n                }).bind(this);\n            })(),\n            configurable: true // WebGL context may be lost\n        });\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-program.js\n * SpeedyProgram class\n */\n\nimport { ShaderPreprocessor } from './shader-preprocessor.js';\nimport { GLUtils } from './gl-utils.js';\nimport { Utils } from '../utils/utils';\n\nconst LOCATION_ATTRIB_POSITION = 0;\nconst LOCATION_ATTRIB_TEXCOORD = 1;\n\nconst DEFAULT_VERTEX_SHADER = `#version 300 es\nin vec2 a_position;\nin vec2 a_texCoord;\nout vec2 texCoord;\n \nvoid main() {\n    gl_Position = vec4(a_position, 0, 1);\n    texCoord = a_texCoord;\n}`;\n\nconst DEFAULT_FRAGMENT_SHADER_PREFIX = `#version 300 es\nprecision highp float;\nprecision highp int;\nprecision mediump sampler2D;\n \nout vec4 color;\nin vec2 texCoord;\nuniform vec2 texSize;\n\n@include \"global.glsl\"\\n`;\n\nconst UNIFORM_TYPES = {\n    'sampler2D':'uniform1i',\n    'float':    'uniform1f',\n    'int':      'uniform1i',\n    'uint':     'uniform1ui',\n    'bool':     'uniform1i',\n    'vec2':     'uniform2f',\n    'vec3':     'uniform3f',\n    'vec4':     'uniform4f',\n    'ivec2':    'uniform2i',\n    'ivec3':    'uniform3i',\n    'ivec4':    'uniform4i',\n    'uvec2':    'uniform2ui',\n    'uvec3':    'uniform3ui',\n    'uvec4':    'uniform4ui',\n    'bvec2':    'uniform2i',\n    'bvec3':    'uniform3i',\n    'bvec4':    'uniform4i',\n};\n\n// number of pixel buffer objects\n// used to get a performance boost in gl.readPixels()\n// (1 seems to perform better on mobile, 2 on the PC?)\nconst PBO_COUNT = 1;\n\n/**\n * A SpeedyProgram is a Function that\n * runs GPU-accelerated GLSL code\n */\nexport class SpeedyProgram extends Function\n{\n    /**\n     * Creates a new SpeedyProgram\n     * @param {WebGL2RenderingContext} gl WebGL context\n     * @param {Function} shaderdecl shader declaration\n     * @param {object} [options] user options\n     */\n    constructor(gl, shaderdecl, options = { })\n    {\n        super('...args', 'return this._self._call(...args)');\n        this._self = this.bind(this);\n        this._self._init(gl, shaderdecl, options);\n        return this._self;\n    }\n\n    /**\n     * Resize the output texture\n     * @param {number} width \n     * @param {number} height \n     */\n    resize(width, height)\n    {\n        const gl = this._gl;\n        const options = this._options;\n\n        // lost context?\n        if(gl.isContextLost())\n            return;\n\n        // no need to resize?\n        if(width === this._stdprog.width && height === this._stdprog.height)\n            return;\n\n        // get size\n        width = Math.max(1, width | 0);\n        height = Math.max(1, height | 0);\n\n        // update options.output\n        options.output[0] = width;\n        options.output[1] = height;\n\n        // resize stdprog\n        //if(options.renderToTexture)\n        //    this._stdprog = detachFBO(this._stdprog);\n\n        this._stdprog.width = width;\n        this._stdprog.height = height;\n\n        //if(options.renderToTexture)\n        //    this._stdprog = attachFBO(this._stdprog);\n\n        // update texSize uniform\n        const uniform = this._stdprog.uniform.texSize;\n        (gl[UNIFORM_TYPES[uniform.type]])(uniform.location, width, height);\n        //console.log(`Resized program to ${width} x ${height}`);\n\n        // reallocate pixel buffers\n        this._reallocatePixelBuffers(width, height);\n    }\n\n    /**\n     * Read pixels from the output texture.\n     * You may optionally specify a (x,y,width,height) sub-rectangle.\n     * @param {number} [x]\n     * @param {number} [y] \n     * @param {number} [width]\n     * @param {number} [height]\n     * @returns {Uint8Array} pixels in the RGBA format\n     */\n    readPixelsSync(x = 0, y = 0, width = -1, height = -1)\n    {\n        const gl = this._gl;\n\n        // lost context?\n        if(gl.isContextLost())\n            return this._pixelBuffer[0];\n\n        // default values\n        if(width < 0)\n            width = this._stdprog.width;\n        if(height < 0)\n            height = this._stdprog.height;\n\n        // clamp values\n        width = Math.min(width, this._stdprog.width);\n        height = Math.min(height, this._stdprog.height);\n        x = Math.max(0, Math.min(x, width - 1));\n        y = Math.max(0, Math.min(y, height - 1));\n\n        // allocate the pixel buffers\n        if(this._pixelBuffer[0] == null)\n            this._reallocatePixelBuffers(this._stdprog.width, this._stdprog.height);\n\n        // read pixels\n        if(this._stdprog.hasOwnProperty('fbo')) {\n            gl.bindFramebuffer(gl.FRAMEBUFFER, this._stdprog.fbo);\n            gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, this._pixelBuffer[0]);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        }\n        else\n            gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, this._pixelBuffer[0]);\n\n        // done!\n        return this._pixelBuffer[0];\n    }\n\n    /**\n     * Read pixels from the output texture asynchronously with PBOs.\n     * You may optionally specify a (x,y,width,height) sub-rectangle.\n     * @param {number} [x]\n     * @param {number} [y] \n     * @param {number} [width]\n     * @param {number} [height]\n     * @returns {Promise<Uint8Array>} resolves to an array of pixels in the RGBA format\n     */\n    readPixelsAsync(x = 0, y = 0, width = -1, height = -1)\n    {\n        const gl = this._gl;\n\n        // lost context?\n        if(gl.isContextLost())\n            return Promise.resolve(this._pixelBuffer[0]);\n\n        // default values\n        if(width < 0)\n            width = this._stdprog.width;\n        if(height < 0)\n            height = this._stdprog.height;\n\n        // clamp values\n        width = Math.min(width, this._stdprog.width);\n        height = Math.min(height, this._stdprog.height);\n        x = Math.max(0, Math.min(x, width - 1));\n        y = Math.max(0, Math.min(y, height - 1));\n\n        // allocate the pixel buffers\n        if(this._pixelBuffer[0] == null)\n            this._reallocatePixelBuffers(this._stdprog.width, this._stdprog.height);\n\n        // GPU needs to produce data\n        if(this._pboProducerQueue.length > 0) {\n            const nextPBO = this._pboProducerQueue.shift();\n            downloadDMA(gl, this._pixelBuffer[nextPBO], x, y, width, height, this._stdprog.fbo).then(downloadTime => {\n                this._pboConsumerQueue.push(nextPBO);\n            });\n        }\n        else waitForQueueNotEmpty(this._pboProducerQueue).then(waitTime => {\n            const nextPBO = this._pboProducerQueue.shift();\n            downloadDMA(gl, this._pixelBuffer[nextPBO], x, y, width, height, this._stdprog.fbo).then(downloadTime => {\n                this._pboConsumerQueue.push(nextPBO);\n            });\n        });\n\n        // CPU needs to consume data\n        if(this._pboConsumerQueue.length > 0) {\n            const readyPBO = this._pboConsumerQueue.shift();\n            return new Promise(resolve => {\n                resolve(this._pixelBuffer[readyPBO]);\n                this._pboProducerQueue.push(readyPBO); // enqueue AFTER resolve()\n            });\n        }\n        else return new Promise(resolve => {\n            waitForQueueNotEmpty(this._pboConsumerQueue).then(waitTime => {\n                const readyPBO = this._pboConsumerQueue.shift();\n                resolve(this._pixelBuffer[readyPBO]);\n                this._pboProducerQueue.push(readyPBO); // enqueue AFTER resolve()\n            });\n        });\n    }\n\n    /**\n     * Read uniforms of the program (metadata)\n     * @returns {object}\n     */\n    get uniforms()\n    {\n        return this._stdprog.uniform;\n    }\n\n    // Prepare the shader\n    _init(gl, shaderdecl, options)\n    {\n        // default options\n        options = {\n            output: [ gl.drawingBufferWidth, gl.drawingBufferHeight ], // size of the output texture\n            uniforms: { }, // user-defined constants (as uniforms)\n            renderToTexture: true, // render results to a texture?\n            recycleTexture: true, // recycle output texture? If false, you must manually destroy the output texture\n            ...options // user-defined options\n        };\n\n        // get size\n        let width = Math.max(1, options.output[0] | 0);\n        let height = Math.max(1, options.output[1] | 0);\n        options.output = [ width, height ];\n\n        // need to resize the canvas?\n        const canvas = gl.canvas;\n        if(width > canvas.width)\n            canvas.width = width;\n        if(height > canvas.height)\n            canvas.height = height;\n\n        // if(gl.isContextLost()) ...\n\n        // create shader\n        const source = shaderdecl();\n        let stdprog = createStandardProgram(gl, width, height, source, options.uniforms);\n        if(options.renderToTexture)\n            stdprog = attachFBO(stdprog);\n\n        // validate arguments\n        const params = functionArguments(shaderdecl);\n        for(let j = 0; j < params.length; j++) {\n            if(!stdprog.uniform.hasOwnProperty(params[j])) {\n                if(!stdprog.uniform.hasOwnProperty(params[j] + '[0]'))\n                    throw GLUtils.Error(`Can't run shader: expected uniform \"${params[j]}\"`);\n            }\n        }\n\n        // store context\n        this._gl = gl;\n        this._source = source;\n        this._options = options;\n        this._stdprog = stdprog;\n        this._params = params;\n        this._initPixelBuffers();\n    }\n\n    // Run the SpeedyProgram\n    _call(...args)\n    {\n        const gl = this._gl;\n        const options = this._options;\n        const stdprog = this._stdprog;\n        const params = this._params;\n\n        // skip things\n        if(gl.isContextLost())\n            return stdprog.texture || null;\n        \n        // matching arguments?\n        if(args.length != params.length)\n            throw GLUtils.Error(`Can't run shader: incorrect number of arguments`);\n\n        // use program\n        gl.useProgram(stdprog.program);\n\n        // set uniforms[i] to args[i]\n        for(let i = 0, texNo = 0; i < args.length; i++) {\n            const argname = params[i];\n            let uniform = stdprog.uniform[argname];\n\n            if(uniform) {\n                // uniform variable matches parameter name\n                texNo = this._setUniform(uniform, args[i], texNo);\n            }\n            else if(stdprog.uniform.hasOwnProperty(argname + '[0]')) {\n                // uniform array matches parameter name\n                const array = args[i];\n                if(stdprog.uniform.hasOwnProperty(`${argname}[${array.length}]`))\n                    throw GLUtils.Error(`Can't run shader: too few elements in array \"${argname}\"`);\n                for(let j = 0; (uniform = stdprog.uniform[`${argname}[${j}]`]); j++)\n                    texNo = this._setUniform(uniform, array[j], texNo);\n            }\n            else\n                throw GLUtils.Error(`Can't run shader: unknown parameter \"${argname}\": ${args[i]}`);\n        }\n\n        // render\n        if(options.renderToTexture)\n            gl.bindFramebuffer(gl.FRAMEBUFFER, stdprog.fbo);\n        else\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n        gl.viewport(0, 0, stdprog.width, stdprog.height);\n        gl.drawArrays(gl.TRIANGLE_STRIP,\n                      0,        // offset\n                      4);       // count       \n\n        // output texture\n        let outputTexture = null;\n        if(options.renderToTexture) {\n            outputTexture = stdprog.texture;\n            if(!options.recycleTexture) {\n                // clone outputTexture using the current framebuffer\n                const cloneTexture = GLUtils.createTexture(gl, stdprog.width, stdprog.height);\n                gl.activeTexture(gl.TEXTURE0);\n                gl.bindTexture(gl.TEXTURE_2D, cloneTexture);\n                gl.copyTexSubImage2D(gl.TEXTURE_2D,     // target\n                                     0,                 // mipmap level\n                                     0,                 // xoffset\n                                     0,                 // yoffset\n                                     0,                 // x\n                                     0,                 // y\n                                     stdprog.width,     // width\n                                     stdprog.height);   // height\n                gl.bindTexture(gl.TEXTURE_2D, null);\n                outputTexture = cloneTexture;\n            }\n        }\n\n        // return texture (if available)\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        return outputTexture;\n    }\n\n    // set uniform to value\n    // arrays of arbitrary size are not supported, only fixed-size vectors (vecX, ivecX, etc.)\n    _setUniform(uniform, value, texNo)\n    {\n        const gl = this._gl;\n\n        if(uniform.type == 'sampler2D') {\n            // set texture\n            if(texNo > gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS)\n                throw GLUtils.Error(`Can't bind ${texNo} textures to a program: max is ${gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS}`);\n            else if(value === this._stdprog.texture)\n                throw GLUtils.Error(`Can't run shader: cannot use its output texture as an input to itself`);\n\n            gl.activeTexture(gl.TEXTURE0 + texNo);\n            gl.bindTexture(gl.TEXTURE_2D, value);\n            gl.uniform1i(uniform.location, texNo);\n            texNo++;\n        }\n        else {\n            // set value\n            if(typeof value == 'number' || typeof value == 'boolean')\n                (gl[UNIFORM_TYPES[uniform.type]])(uniform.location, value);\n            else if(Array.isArray(value))\n                (gl[UNIFORM_TYPES[uniform.type]])(uniform.location, ...value);\n            else\n                throw GLUtils.Error(`Can't run shader: unrecognized argument \"${value}\"`);\n        }\n\n        return texNo;\n    }\n\n    // initialize pixel buffers\n    _initPixelBuffers()\n    {\n        this._pixelBuffer = Array(PBO_COUNT).fill(null);\n        this._pixelBufferSize = [0, 0];\n        this._pboConsumerQueue = Array(PBO_COUNT).fill(0).map((_, i) => i);\n        this._pboProducerQueue = [];\n    }\n\n    // resize pixel buffers\n    _reallocatePixelBuffers(width, height)\n    {\n        // skip realloc\n        if(width * height <= this._pixelBufferSize[0] * this._pixelBufferSize[1])\n            return;\n\n        // update size\n        this._pixelBufferSize[0] = width;\n        this._pixelBufferSize[1] = height;\n\n        // reallocate pixels array\n        for(let i = 0; i < PBO_COUNT; i++) {\n            const oldBuffer = this._pixelBuffer[i];\n            this._pixelBuffer[i] = createPixelBuffer(width, height);\n\n            if(oldBuffer) {\n                if(oldBuffer.length > this._pixelBuffer[i].length)\n                    this._pixelBuffer[i].set(oldBuffer.slice(0, this._pixelBuffer[i].length));\n                else\n                    this._pixelBuffer[i].set(oldBuffer);\n            }\n        }\n    }\n}\n\n// =============================================================\n\n//\n// Parsing\n//\n\n// a dictionary specifying the types of all uniforms in the code\nfunction autodetectUniforms(shaderSource)\n{\n    const sourceWithoutComments = shaderSource; // assume we've preprocessed the source already\n    const regex = /uniform\\s+(\\w+)\\s+([^;]+)/g;\n    const uniforms = { };\n\n    let match;\n    while((match = regex.exec(sourceWithoutComments)) !== null) {\n        const type = match[1];\n        const names = match[2].split(',').map(name => name.trim()).filter(name => name); // trim & remove empty names\n        for(const name of names) {\n            if(name.endsWith(']')) {\n                // is it an array?\n                if(!(match = name.match(/(\\w+)\\s*\\[\\s*(\\d+)\\s*\\]$/)))\n                    throw GLUtils.Error(`Unspecified array length for uniform \"${name}\" in the shader`);\n                const [ array, length ] = [ match[1], Number(match[2]) ];\n                for(let i = 0; i < length; i++)\n                    uniforms[`${array}[${i}]`] = { type };\n            }\n            else {\n                // regular uniform\n                uniforms[name] = { type };\n            }\n        }\n    }\n\n    return Object.freeze(uniforms);\n}\n\n// names of function arguments\nfunction functionArguments(fun)\n{\n    const code = fun.toString();\n    const regex = code.startsWith('function') ? 'function\\\\s.*\\\\(([^)]*)\\\\)' :\n                 (code.startsWith('(') ? '\\\\(([^)]*)\\\\).*=>' : '([^=]+).*=>');\n    const match = new RegExp(regex).exec(code);\n\n    if(match !== null) {\n        const args = match[1].replace(/\\/\\*.*?\\*\\//g, ''); // remove comments\n        return args.split(',').map(argname =>\n            argname.replace(/=.*$/, '').trim() // remove default params & trim\n        ).filter(argname =>\n            argname // handle trailing commas\n        );\n    }\n    else\n        throw GLUtils.Error(`Can't detect function arguments of ${code}`);\n\n    return [];\n}\n\n\n\n\n\n//\n// Consumer-producer\n//\n\n// wait for a queue to be not empty\nfunction waitForQueueNotEmpty(queue)\n{\n    return new Promise(resolve => {\n        const start = performance.now();\n        function wait() {\n            if(queue.length > 0)\n                resolve(performance.now() - start);\n            else\n                //Utils.setZeroTimeout(wait);\n                setTimeout(wait, 0);\n        }\n        wait();\n    });\n}\n\n\n\n\n//\n// WebGL\n//\n\n// create VAO & VBO\nfunction createStandardGeometry(gl)\n{\n    // got cached values for this WebGL context?\n    const f = createStandardGeometry;\n    const cache = f._cache || (f._cache = new WeakMap());\n    if(cache.has(gl))\n        return cache.get(gl);\n\n    // configure the attributes of the vertex shader\n    const vao = gl.createVertexArray(); // vertex array object\n    const vbo = [ gl.createBuffer(), gl.createBuffer() ]; // vertex buffer objects\n    gl.bindVertexArray(vao);\n\n    // set the a_position attribute\n    // using the current vbo\n    gl.bindBuffer(gl.ARRAY_BUFFER, vbo[0]);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n        // clip coordinates\n        -1, -1,\n        1, -1,\n        -1, 1,\n        1, 1,\n    ]), gl.STATIC_DRAW);\n    gl.vertexAttribPointer(LOCATION_ATTRIB_POSITION, // attribute location\n                           2,          // 2 components per vertex (x,y)\n                           gl.FLOAT,   // type\n                           false,      // don't normalize\n                           0,          // default stride (tightly packed)\n                           0);         // offset\n    gl.enableVertexAttribArray(LOCATION_ATTRIB_POSITION);\n\n    // set the a_texCoord attribute\n    // using the current vbo\n    gl.bindBuffer(gl.ARRAY_BUFFER, vbo[1]);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n        // texture coordinates\n        0, 0,\n        1, 0,\n        0, 1,\n        1, 1,\n    ]), gl.STATIC_DRAW);\n    gl.vertexAttribPointer(LOCATION_ATTRIB_TEXCOORD, // attribute location\n                           2,          // 2 components per vertex (x,y)\n                           gl.FLOAT,   // type\n                           false,      // don't normalize\n                           0,          // default stride (tightly packed)\n                           0);         // offset\n    gl.enableVertexAttribArray(LOCATION_ATTRIB_TEXCOORD);\n\n    // unbind\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n\n    // cache & return\n    const result = { vao, vbo };\n    cache.set(gl, result);\n    return result;\n}\n\n// a standard program runs a shader on an \"image\"\n// uniforms: { 'name': <default_value>, ... }\nfunction createStandardProgram(gl, width, height, fragmentShaderSource, uniforms = { })\n{\n    // compile shaders\n    const source = ShaderPreprocessor.run(gl, DEFAULT_FRAGMENT_SHADER_PREFIX + fragmentShaderSource);\n    const program = GLUtils.createProgram(gl, DEFAULT_VERTEX_SHADER, source);\n\n    // setup geometry\n    gl.bindAttribLocation(program, LOCATION_ATTRIB_POSITION, 'a_position');\n    gl.bindAttribLocation(program, LOCATION_ATTRIB_TEXCOORD, 'a_texCoord');\n    const vertexObjects = createStandardGeometry(gl);\n\n    // define texSize\n    width = Math.max(width | 0, 1);\n    height = Math.max(height | 0, 1);\n    uniforms.texSize = [ width, height ];\n\n    // autodetect uniforms, get their locations,\n    // define their setters and set their default values\n    const uniform = autodetectUniforms(source);\n    gl.useProgram(program);\n    for(const u in uniform) {\n        // get location\n        uniform[u].location = gl.getUniformLocation(program, u);\n\n        // validate type\n        if(!UNIFORM_TYPES.hasOwnProperty(uniform[u].type))\n            throw GLUtils.Error(`Unknown uniform type: ${uniform[u].type}`);\n\n        // must set a default value?\n        if(uniforms.hasOwnProperty(u)) {\n            const value = uniforms[u];\n            if(typeof value == 'number' || typeof value == 'boolean')\n                (gl[UNIFORM_TYPES[uniform[u].type]])(uniform[u].location, value);\n            else if(typeof value == 'object')\n                (gl[UNIFORM_TYPES[uniform[u].type]])(uniform[u].location, ...Array.from(value));\n            else\n                throw GLUtils.Error(`Unrecognized uniform value: \"${value}\"`);\n        }\n\n        // note: to set the default value of array arr, pass\n        // { 'arr[0]': val0, 'arr[1]': val1, ... } to uniforms\n    }\n\n    // done!\n    return {\n        program,\n        gl,\n        uniform,\n        width,\n        height,\n        ...vertexObjects,\n    };\n}\n\n// Attach a framebuffer object to a standard program\nfunction attachFBO(stdprog)\n{\n    const gl = stdprog.gl;\n    const width = stdprog.width;\n    const height = stdprog.height;\n\n    const texture = GLUtils.createTexture(gl, width, height);\n    const fbo = GLUtils.createFramebuffer(gl, texture);\n\n    return Object.assign(stdprog, {\n        texture,\n        fbo\n    });\n}\n\n// Detach a framebuffer object from a standard program\nfunction detachFBO(stdprog)\n{\n    if(stdprog.hasOwnProperty('fbo')) {\n        GLUtils.destroyFramebuffer(stdprog.gl, stdprog.fbo);\n        delete stdprog.fbo;\n    }\n\n    if(stdprog.hasOwnProperty('texture')) {\n        GLUtils.destroyTexture(stdprog.gl, stdprog.texture);\n        delete stdprog.texture;\n    }\n\n    return stdprog;\n}\n\n// create a width x height buffer for RGBA data\nfunction createPixelBuffer(width, height)\n{\n    const pixels = new Uint8Array(width * height * 4);\n    pixels.fill(255, 0, 4); // will be recognized as empty\n    return pixels;\n}\n\n// download data to an Uint8Array using a Pixel Buffer Object (PBO)\n// you may optionally specify a FBO to read pixels from a texture\nfunction downloadDMA(gl, arrayBuffer, x, y, width, height, fbo = null)\n{\n    // create a PBO\n    const pbo = gl.createBuffer();\n    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, pbo);\n    gl.bufferData(gl.PIXEL_PACK_BUFFER, arrayBuffer.byteLength, gl.STREAM_READ);\n\n    // read pixels into PBO\n    if(fbo) {\n        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n        gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, 0);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    }\n    else {\n        gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, 0);\n    }\n\n    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);\n\n    // wait for DMA transfer\n    return GLUtils.getBufferSubDataAsync(gl, pbo,\n        gl.PIXEL_PACK_BUFFER,\n        0,\n        arrayBuffer,\n        0,\n        0\n    ).then(timeInMs => {\n        return timeInMs;\n    }).catch(err => {\n        throw err;\n    }).finally(() => {\n        gl.deleteBuffer(pbo);\n    });\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy.js\n * Speedy's entry point\n */\n\nimport { SpeedyMedia } from './core/speedy-media';\nimport { SpeedyPipeline } from './core/speedy-pipeline';\nimport { FPSCounter } from './utils/fps-counter';\n\nclass Speedy\n{\n    /**\n     * Loads a SpeedyMedia object based on the provided source element\n     * @param {HTMLImageElement|HTMLVideoElement|HTMLCanvasElement} sourceElement The source media\n     * @param {object} [options] Additional options for advanced configuration\n     * @returns {Promise<SpeedyMedia>}\n     */\n    static load(sourceElement, options = { })\n    {\n        return SpeedyMedia.load(sourceElement, options);\n    }\n\n    /**\n     * Loads a camera stream\n     * @param {number} [width] width of the stream\n     * @param {number} [height] height of the stream\n     * @param {object} [cameraOptions] additional options to pass to getUserMedia()\n     * @param {object} [mediaOptions] additional options for advanced configuration of the SpeedyMedia\n     * @returns {Promise<SpeedyMedia>}\n     */\n    static camera(width = 426, height = 240, cameraOptions = {}, mediaOptions = {})\n    {\n        return SpeedyMedia.loadCameraStream(width, height, cameraOptions, mediaOptions);\n    }\n\n    /**\n     * Creates a new pipeline\n     * @returns {SpeedyPipeline}\n     */\n    static pipeline()\n    {\n        return new SpeedyPipeline();\n    }\n\n    /**\n     * The version of the library\n     * @returns {string} The version of the library\n     */\n    static get version()\n    {\n        return __SPEEDY_VERSION__;\n    }\n\n    /**\n     * The FPS rate. Get it as Speedy.fps.value\n     * @returns {number} Frames per second (FPS)\n     */\n    static get fps()\n    {\n        return {\n            get value() { return FPSCounter.instance.fps; }\n        };\n    }\n}\n\nexport const load = Speedy.load;\nexport const camera = Speedy.camera;\nexport const pipeline = Speedy.pipeline;\nexport const version = Speedy.version;\nexport const fps = Speedy.fps;","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * errors.js\n * Error classes\n */\n\n/**\n * Error class for Speedy\n */\nexport class SpeedyError extends Error\n{\n    /**\n     * Class constructor\n     * @param {string} message message text\n     * @param  {...string} [args] additional text\n     */\n    constructor(message, ...args)\n    {\n        const text = [ message, ...args ].join(' ');\n        console.error('[speedy-vision.js]', text);\n        super(text);\n    }\n\n    /**\n     * Error name\n     * @returns {string}\n     */\n    get name()\n    {\n        return this.constructor.name;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * fps-counter.js\n * A FPS counter\n */\n\nimport { Utils } from './utils';\nlet instance = null;\nconst UPDATE_INTERVAL = 500; // in ms\n\nexport class FPSCounter\n{\n    /**\n     * Creates a new FPSCounter\n     */\n    /* private */ constructor()\n    {\n        this._fps = 60;\n        this._frames = 0;\n        this._updateInterval = UPDATE_INTERVAL;\n        this._lastUpdate = performance.now();\n\n        // this should never happen...\n        if(instance !== null)\n            Utils.fatal(`Can't have multiple instances of FPSCounter`);\n\n        // start FPS counter\n        requestAnimationFrame(this._update.bind(this));\n    }\n\n    /**\n     * Gets an instance of the FPS counter.\n     * Using lazy loading, i.e., we will not\n     * create a FPS counter unless we need to!\n     */\n    static get instance()\n    {\n        if(instance === null)\n            instance = new FPSCounter();\n\n        return instance;\n    }\n\n    /**\n     * Get the FPS rate\n     * @returns {number} frames per second\n     */\n    get fps()\n    {\n        return this._fps;\n    }\n\n    // Updates the FPS counter\n    _update()\n    {\n        const now = performance.now();\n        const deltaTime = now - this._lastUpdate;\n\n        if(deltaTime >= this._updateInterval) {\n            this._fps = Math.round(this._frames / (deltaTime * 0.001));\n            this._frames = 0;\n            this._lastUpdate = now;\n        }\n\n        this._frames++;\n        requestAnimationFrame(this._update.bind(this));\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * tuner.js\n * A device designed to minimize the (noisy) output of a unknown system\n */\n\nimport { Utils } from './utils';\n\n/**\n * A Bucket of observations is used to give\n * statistical treatment to (noisy) data\n */\nclass Bucket\n{\n    /**\n     * Class constructor\n     * @param {number} bucketSize It should be a power of two\n     * @param {number} windowSize An odd positive number for filtering\n     */\n    constructor(bucketSize = 32, windowSize = 5)\n    {\n        // validate parameters\n        this._bucketSize = 1 << Math.ceil(Math.log2(bucketSize));\n        this._windowSize = windowSize + (1 - windowSize % 2);\n\n        // bucketSize should be a power of 2\n        if(bucketSize < this._windowSize)\n            Utils.fatal(`Invalid bucketSize of ${bucketSize}`);\n\n        // Bucket is implemented as a circular vector\n        this._head = this._bucketSize - 1;\n        this._rawData = new Float32Array(this._bucketSize).fill(0);\n        this._smoothedData = new Float32Array(this._bucketSize).fill(0);\n        this._average = 0;\n        this._isSmooth = true;\n    }\n\n    /**\n     * Put a value in the bucket\n     * @param {number} value\n     */\n    put(value)\n    {\n        this._head = (this._head + 1) & (this._bucketSize - 1);\n        this._rawData[this._head] = value;\n        this._isSmooth = false;\n    }\n\n    /**\n     * Bucket size\n     * @returns {number}\n     */\n    get size()\n    {\n        return this._bucketSize;\n    }\n\n    /**\n     * Get smoothed average\n     * @returns {number}\n     */\n    get average()\n    {\n        // need to smooth the signal?\n        if(!this._isSmooth)\n            this._smooth();\n\n        // the median filter does not introduce new data to the signal\n        // this._average approaches the mean of the distribution as bucketSize -> inf\n        return this._average;\n    }\n\n    /**\n     * Fill the bucket with a value\n     * @param {number} value\n     */\n    fill(value)\n    {\n        this._rawData.fill(value);\n        this._smoothedData.fill(value);\n        this._average = value;\n        this._isSmooth = true;\n        this._head = this._bucketSize - 1;\n        return this;\n    }\n\n    // Apply the smoothing filter & compute the average\n    _smooth()\n    {\n        // smooth the signal & compute the average\n        this._average = 0;\n        for(let i = 0; i < this._bucketSize; i++) {\n            this._smoothedData[i] = this._median(this._window(i));\n            this._average += this._smoothedData[i];\n        }\n        this._average /= this._bucketSize;\n        //this._average = this._median(this._rawData);\n\n        // the signal has been smoothed\n        this._isSmooth = true;\n    }\n\n    // A window of size w around i\n    _window(i)\n    {\n        const arr = this._rawData;\n        const win = this._win || (this._win = new Float32Array(this._windowSize));\n        const n = arr.length;\n        const w = win.length;\n        const wOver2 = w >> 1;\n        const head = this._head;\n        const tail = (head + 1) & (n - 1);\n\n        for(let j = 0, k = -wOver2; k <= wOver2; k++) {\n            let pos = i + k;\n\n            // boundary conditions:\n            // reflect values\n            if(i <= head){\n                if(pos > head)\n                    pos = head + (head - pos);\n            }\n            else {\n                if(pos < tail)\n                    pos = tail + (tail - pos);\n            }\n            if(pos < 0)\n                pos += n;\n            else if(pos >= n)\n                pos -= n;\n\n            win[j++] = arr[pos];\n        }\n\n        return win;\n    }\n\n    // return the median of a sequence (note: the input is rearranged)\n    _median(v)\n    {\n        // fast median search for fixed length vectors\n        switch(v.length) {\n            case 1:\n                return v[0];\n\n            case 3:\n                //  v0   v1   v2   [ v0  v1  v2 ]\n                //   \\  / \\   /\n                //   node  node    [ min(v0,v1)  min(max(v0,v1),v2)  max(max(v0,v1),v2) ]\n                //      \\   /\n                //      node       [ min(min(v0,v1),min(max(v0,v1),v2))  max(min(...),min(...))  max(v0,v1,v2) ]\n                //       |\n                //     median      [ min(v0,v1,v2)  median  max(v0,v1,v2) ]\n                if(v[0] > v[1]) [v[0], v[1]] = [v[1], v[0]];\n                if(v[1] > v[2]) [v[1], v[2]] = [v[2], v[1]];\n                if(v[0] > v[1]) [v[0], v[1]] = [v[1], v[0]];\n                return v[1];\n\n            case 5:\n                if(v[0] > v[1]) [v[0], v[1]] = [v[1], v[0]];\n                if(v[3] > v[4]) [v[3], v[4]] = [v[4], v[3]];\n                if(v[0] > v[3]) [v[0], v[3]] = [v[3], v[0]];\n                if(v[1] > v[4]) [v[1], v[4]] = [v[4], v[1]];\n                if(v[1] > v[2]) [v[1], v[2]] = [v[2], v[1]];\n                if(v[2] > v[3]) [v[2], v[3]] = [v[3], v[2]];\n                if(v[1] > v[2]) [v[1], v[2]] = [v[2], v[1]];\n                return v[2];\n\n            case 7:\n                if(v[0] > v[5]) [v[0], v[5]] = [v[5], v[0]];\n                if(v[0] > v[3]) [v[0], v[3]] = [v[3], v[0]];\n                if(v[1] > v[6]) [v[1], v[6]] = [v[6], v[1]];\n                if(v[2] > v[4]) [v[2], v[4]] = [v[4], v[2]];\n                if(v[0] > v[1]) [v[0], v[1]] = [v[1], v[0]];\n                if(v[3] > v[5]) [v[3], v[5]] = [v[5], v[3]];\n                if(v[2] > v[6]) [v[2], v[6]] = [v[6], v[2]];\n                if(v[2] > v[3]) [v[2], v[3]] = [v[3], v[2]];\n                if(v[3] > v[6]) [v[3], v[6]] = [v[6], v[3]];\n                if(v[4] > v[5]) [v[4], v[5]] = [v[5], v[4]];\n                if(v[1] > v[4]) [v[1], v[4]] = [v[4], v[1]];\n                if(v[1] > v[3]) [v[1], v[3]] = [v[3], v[1]];\n                if(v[3] > v[4]) [v[3], v[4]] = [v[4], v[3]];\n                return v[3];\n\n            default:\n                v.sort((a, b) => a - b);\n                return (v[(v.length - 1) >> 1] + v[v.length >> 1]) / 2;\n        }\n    }\n}\n\n/**\n * A Tuner is a device designed to find\n * an integer x that minimizes the output\n * of a unknown system y = F(x) with noise\n */\n/* abstract */ class Tuner\n{\n    /**\n     * Class constructor\n     * @param {number} initialState initial guess to input to the unknown system\n     * @param {number} minState minimum integer accepted by the unknown system\n     * @param {number} maxState maximum integer accepted by the unknown system\n     */\n    constructor(initialState, minState, maxState)\n    {\n        // validate parameters\n        if(minState >= maxState)\n            Utils.fatal(`Invalid boundaries [${minState},${maxState}] given to the Tuner`);\n        initialState = Math.max(minState, Math.min(initialState, maxState));\n\n        // setup object\n        this._state = initialState;\n        this._prevState = initialState;\n        this._prevPrevState = initialState;\n        this._initialState = initialState;\n        this._minState = minState;\n        this._maxState = maxState;\n        this._bucket = new Array(maxState - minState + 1).fill(null).map(x => new Bucket(this._bucketSetup().size, this._bucketSetup().window));\n        this._iterations = 0; // number of iterations in the same state\n        this._epoch = 0; // number of state changes\n    }\n\n    /**\n     * The value to input to the unknown system\n     */\n    currentValue()\n    {\n        return this._state;\n    }\n\n    /**\n     * Feed the output y = F(x) of the unknown system\n     * when given an input x = this.currentValue()\n     */\n    feedObservation(y)\n    {\n        const bucket = this._bucketOf(this._state);\n\n        // feed the observation into the bucket of the current state\n        bucket.put(+y);\n\n        // time to change state?\n        if(++this._iterations >= bucket.size) {\n            // initialize buckets\n            if(this._epoch == 0) {\n                this._bucket.forEach(bk => bk.fill(bucket.average));\n                if(!isFinite(this._costOfBestState))\n                    this._costOfBestState = bucket.average;\n            }\n\n            // compute next state\n            const clip = s => Math.max(this._minState, Math.min(s | 0, this._maxState));\n            const prevPrevState = this._prevState;\n            const prevState = this._state;\n            this._state = clip(this._nextState());\n            this._prevState = prevState;\n            this._prevPrevState = prevPrevState;\n\n            // reset iteration counter\n            // and advance epoch number\n            this._iterations = 0;\n            this._epoch++;\n        }\n    }\n\n    /**\n     * Reset the Tuner to its initial state\n     * Useful if you change on-the-fly the unknown system,\n     * so that there is a new target value you want to find\n     */\n    reset()\n    {\n        this._state = this._initialState;\n        this._prevState = this._initialState;\n        this._prevPrevState = this._initialState;\n        this._iterations = 0;\n        this._epoch = 0;\n    }\n\n    /**\n     * Finished optimization?\n     * @returns {boolean}\n     */\n    finished()\n    {\n        return false;\n    }\n\n    // get the bucket of a state\n    _bucketOf(state)\n    {\n        state = Math.max(this._minState, Math.min(state | 0, this._maxState));\n        return this._bucket[state - this._minState];\n    }\n\n    // the bucket may be reconfigured on subclasses\n    _bucketSetup()\n    {\n        return {\n            \"size\": 32,\n            \"window\": 5\n        };\n    }\n\n    // this is magic\n    /* abstract */ _nextState()\n    {\n        // Subclass responsibility\n        return this._state;\n    }\n\n    /**\n     * Let me see stuff\n     * @returns {object}\n     */\n    info()\n    {\n        const bucket = this._bucketOf(this._state);\n        const prevBucket = this._bucketOf(this._prevState);\n\n        return {\n            now: this._state,\n            avg: bucket.average,\n            itr: [ this._iterations, this._epoch ],\n            bkt: bucket._smoothedData,\n            cur: new Array(bucket.size).fill(0).map((x, i) => i == bucket._head ? 1 : 0),\n            prv: [ this._prevState, prevBucket.average ],\n            fim: this.finished(),\n        };\n    }\n}\n\n/**\n * A Tuner created for testing purposes\n */\nexport class TestTuner extends Tuner\n{\n    /**\n     * Class constructor\n     * @param {number} minState minimum integer accepted by the unknown system\n     * @param {number} maxState maximum integer accepted by the unknown system\n     */\n    constructor(minState, maxState)\n    {\n        super(minState, minState, maxState);\n    }\n\n    // where should I go next?\n    _nextState()\n    {\n        //console.log(this.info());\n        const nextState = this._state + 1;\n        return nextState > this._maxState ? this._minState : nextState;\n    }\n\n    // bucket setup\n    _bucketSetup()\n    {\n        return {\n            \"size\": 4,\n            \"window\": 3\n        };\n    }\n\n    // let me see stuff\n    info()\n    {\n        return {\n            state: [ this._state, this._bucketOf(this._state).average ],\n            data: JSON.stringify(this._bucket.map(b => b.average)),\n        };\n    }\n}\n\n/*\n * Implementation of Simulated Annealing\n */\nexport class StochasticTuner extends Tuner\n{\n    /**\n     * Class constructor\n     * @param {number} initialState initial guess to input to the unknown system\n     * @param {number} minState minimum integer accepted by the unknown system\n     * @param {number} maxState maximum integer accepted by the unknown system\n     * @param {number} [alpha] geometric decrease rate of the temperature\n     * @param {number} [maxIterationsPerTemperature] number of iterations before cooling down by alpha\n     * @param {number} [initialTemperature] initial temperature\n     * @param {Function<number,number?>} [neighborFn] neighbor picking function: state[,F(state)] -> state\n     */\n    constructor(initialState, minState, maxState, alpha = 0.5, maxIterationsPerTemperature = 8, initialTemperature = 100, neighborFn = null)\n    {\n        super(initialState, minState, maxState);\n\n        this._bestState = this._initialState;\n        this._costOfBestState = Infinity;\n        this._initialTemperature = Math.max(0, initialTemperature);\n        this._temperature = this._initialTemperature;\n        this._numIterations = 0; // no. of iterations in the current temperature\n        this._maxIterationsPerTemperature = Math.max(1, maxIterationsPerTemperature);\n        this._alpha = Math.max(0, Math.min(alpha, 1)); // geometric decrease rate\n\n        if(!neighborFn)\n            neighborFn = (s) => this._minState + Math.floor(Math.random() * (this._maxState - this._minState + 1))\n        this._pickNeighbor = neighborFn;\n    }\n\n    /**\n     * Reset the Tuner\n     */\n    reset()\n    {\n        this._temperature = this._initialTemperature;\n        this._numIterations = 0;\n        // we shall not reset the best state...\n    }\n\n    /**\n     * Finished optimization?\n     * @returns {boolean}\n     */\n    finished()\n    {\n        return this._temperature <= 1e-5;\n    }\n\n    // Pick the next state\n    // Simulated Annealing\n    _nextState()\n    {\n        // finished simulation?\n        if(this.finished())\n            return this._bestState;\n\n        // pick a neighbor\n        const f = (s) => this._bucketOf(s).average;\n        let nextState = this._state;\n        let neighbor = this._pickNeighbor(this._state, f(this._state)) | 0;\n        neighbor = Math.max(this._minState, Math.min(neighbor, this._maxState));\n\n        // evaluate the neighbor\n        if(f(neighbor) < f(this._state)) {\n            // the neighbor is better than the current state\n            nextState = neighbor;\n        }\n        else {\n            // the neighbor is not better than the current state,\n            // but we may admit it with a certain probability\n            if(Math.random() < Math.exp((f(this._state) - f(neighbor)) / this._temperature))\n                nextState = neighbor;\n        }\n\n        // update the best state\n        if(f(nextState) < this._costOfBestState) {\n            this._bestState = nextState;\n            this._costOfBestState = f(nextState);\n        }\n\n        // cool down\n        if(++this._numIterations >= this._maxIterationsPerTemperature) {\n            this._temperature *= this._alpha;\n            this._numIterations = 0;\n        }\n\n        // done\n        return nextState;\n    }\n\n    // bucket setup\n    _bucketSetup()\n    {\n        return {\n            \"size\": 4,\n            \"window\": 3\n        };\n    }\n\n    // let me see stuff\n    info()\n    {\n        return {\n            best: [ this._bestState, this._costOfBestState ],\n            state: [ this._state, this._bucketOf(this._state).average ],\n            iterations: [ this._numIterations, this._maxIterationsPerTemperature ],\n            temperature: this._temperature,\n            alpha: this._alpha,\n            cool: this.finished(),\n        };\n    }\n}\n\n/**\n * Golden Section Search\n */\nexport class GoldenSectionTuner extends Tuner\n{\n    /**\n     * Class constructor\n     * @param {number} minState minimum INTEGER accepted by the quadratic error system\n     * @param {number} maxState maximum INTEGER accepted by the quadratic error system\n     * @param {number} tolerance terminating condition (interval size)\n     */\n    constructor(minState, maxState, tolerance = 0.001)\n    {\n        super(minState, minState, maxState);\n        this._invphi = (Math.sqrt(5.0) - 1.0) / 2.0; // 1 / phi\n        this._tolerance = Math.max(0, tolerance);\n        this.reset();\n    }\n\n    /**\n     * Reset the tuner\n     */\n    reset()\n    {\n        this._xlo = Math.max(xlo, this._minState);\n        this._xhi = Math.min(xhi, this._maxState);\n        this._x1 = this._xhi - this._invphi * (this._xhi - this._xlo);\n        this._x2 = this._xlo + this._invphi * (this._xhi - this._xlo);\n\n        this._state = Math.floor(this._x1);\n        this._bestState = this._state;\n    }\n\n    /**\n     * Finished optimizing?\n     * @returns {boolean}\n     */\n    finished()\n    {\n        return this._xhi - this._xlo <= this._tolerance;\n    }\n\n    // Where should I go next?\n    _nextState()\n    {\n        const f = (s) => this._bucketOf(s).average;\n\n        // best state so far\n        if(f(this._state) < f(this._bestState))\n            this._bestState = this._state;\n\n        // finished?\n        if(this.finished())\n            return this._bestState;\n\n        // initial search\n        if(this._epoch == 0)\n            return Math.ceil(this._x2);\n\n        // evaluate the current interval\n        if(f(Math.floor(this._x1)) < f(Math.ceil(this._x2))) {\n            this._xhi = this._x2;\n            this._x2 = this._x1;\n            this._x1 = this._xhi - this._invphi * (this._xhi - this._xlo);\n            return Math.floor(this._x1);\n        }\n        else {\n            this._xlo = this._x1;\n            this._x1 = this._x2;\n            this._x2 = this._xlo + this._invphi * (this._xhi - this._xlo);\n            return Math.ceil(this._x2);\n        }\n    }\n\n    // Bucket setup\n    _bucketSetup()\n    {\n        return {\n            \"size\": 4,\n            \"window\": 3\n        };\n    }\n\n    // let me see stuff\n    info()\n    {\n        return {\n            now: this._state,\n            avg: this._bucketOf(this._state).average,\n            itr: [ this._iterations, this._epoch ],\n            int: [ this._xlo, this._xhi ],\n            sub: [ this._x1, this._x2 ],\n            done: this.finished(),\n        };\n    }\n}\n\n/**\n * A Tuner for minimizing errors between observed and expected values\n * \n * It should be an Online Tuner, that is, it should learn the\n * best responses in real-time, as it goes\n * \n * This is sort of a hill climbing / gradient descent algorithm\n * with random elements and adapted for discrete space\n */\nexport class OnlineErrorTuner extends Tuner\n{\n    /**\n     * Class constructor\n     * @param {number} minState minimum INTEGER accepted by the quadratic error system\n     * @param {number} maxState maximum INTEGER accepted by the quadratic error system\n     * @param {number} tolerance percentage relative to the expected observation\n     * @param {number} learningRate hyperparameter\n     */\n    constructor(minState, maxState, tolerance = 0.1, learningRate = 0.05)\n    {\n        const initialState = Math.round(Utils.gaussianNoise((minState + maxState) / 2, 5));\n        super(initialState, minState, maxState);\n        this._tolerance = Math.max(0, tolerance);\n        this._bestState = this._initialState;\n        this._expected = null;\n        this._learningRate = Math.max(0, learningRate);\n    }\n\n    /**\n     * Reset the tuner\n     */\n    reset()\n    {\n        super.reset();\n        this._expected = null;\n    }\n\n    /**\n     * Feed an observed value and an expected value\n     * @param {number} observedValue\n     * @param {number} expectedValue\n     */\n    feedObservation(observedValue, expectedValue)\n    {\n        const obs = +observedValue;\n        const expected = +expectedValue;\n\n        // must reset the tuner?\n        if(expected !== this._expected)\n            this.reset();\n        this._expected = expected;\n\n        // feed an error measurement to the appropriate bucket\n        const err = ((obs - expected) * (obs - expected)) / (expected * expected);\n        super.feedObservation(err);\n    }\n\n    /**\n     * Finished optimizing?\n     * -- for now, that is...\n     *    it's an online tuner!\n     * @returns {boolean}\n     */\n    finished()\n    {\n        // error function\n        const E = (s) => Math.sqrt(this._bucketOf(s).average) * Math.abs(this._expected);\n\n        // compute values\n        const err = E(this._bestState);\n        const tol = this._tolerance;\n        const exp = this._expected;\n        //console.log('ERR', err, tol * exp);\n\n        // acceptable condition\n        return err <= tol * exp;\n    }\n\n    /**\n     * Tolerance value, a percentage relative\n     * to the expected value that we want\n     * @returns {boolean}\n     */\n    get tolerance()\n    {\n        return this._tolerance;\n    }\n\n    /**\n     * Set the tolerance, a percentage relative\n     * to the expected value that we want\n     */\n    set tolerance(value)\n    {\n        this._tolerance = Math.max(0, value);\n    }\n\n    // Where should I go next?\n    _nextState()\n    {\n        // finished?\n        if(this.finished())\n            return this._bestState;\n\n        // error function\n        const E = (s) => Math.sqrt(this._bucketOf(s).average) * Math.abs(this._expected);\n\n        // best state\n        if(E(this._state) < E(this._bestState))\n            this._bestState = this._state;\n\n        // the algorithm should avoid long hops, as this\n        // would cause discontinuities for the end-user\n        //const stepSize = this._learningRate * E(this._state);\n        const worldScale = Math.abs(this._maxState);\n        const G = (s) => Math.sqrt(this._bucketOf(s).average) * worldScale;\n        const stepSize = this._learningRate * G(this._state);\n\n        // move in the opposite direction of the error or in\n        // the direction of the error with a small probability\n        const sign = x => (x >= 0) - (x < 0); // -1 or 1\n        const direction = (\n            sign(E(this._state) - E(this._prevState)) *\n           -sign(this._state - this._prevState) *\n            sign(Math.random() - 0.15)\n        );\n        //console.warn(\"at state\", this._state, direction > 0 ? '-->' : '<--');\n\n        // pick the next state\n        const weight = Utils.gaussianNoise(1.0, 0.1); // dodge local mimina\n        let newState = Math.round(this._state + direction * weight * stepSize);\n\n        // outside bounds?\n        if(newState > this._maxState)\n            newState = this._bestState;\n        else if(newState < this._minState)\n            newState = this._bestState;\n\n        // done\n        return newState;\n    }\n\n    // Bucket setup\n    _bucketSetup()\n    {\n        return {\n            \"size\": 4,\n            \"window\": 3\n        };\n    }\n\n    // let me see stuff\n    info()\n    {\n        return {\n            now: [ this._state, this._prevState ],\n            bkt: this._bucketOf(this._state)._rawData,\n            cur: this._bucketOf(this._state)._head,\n            err: [ this._bucketOf(this._state).average, this._bucketOf(this._prevState).average ],\n            sqt: Math.sqrt(this._bucketOf(this._state).average),\n            done: this.finished(),\n        };\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * types.js\n * Types & formats\n */\n\nimport { Utils } from './utils';\n\nexport const MediaType = Utils.enum(\n    'Image',\n    'Video',\n    'Canvas',\n    'Texture'\n);\n\nexport const ColorFormat = Utils.enum(\n    'RGB',\n    'Greyscale',\n    'Binary'\n);","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * utils.js\n * Generic utilities\n */\n\nimport { SpeedyError } from './errors'\n\nexport class Utils\n{\n    /**\n     * Displays a fatal error\n     * @param {string} text message text\n     * @param  {...string} [args] optional text\n     * @throws {SpeedyError} an error object containing the message text\n     */\n    static fatal(text, ...args)\n    {\n        throw new SpeedyError(text, ...args);\n    }\n\n    /**\n     * Generates a warning\n     * @param {string} text message text\n     * @param  {...string} [args] optional text\n     * @returns {string} the message text\n     */\n    static warning(text, ...args)\n    {\n        const message = [ text, ...args ].join(' ');\n        console.warn('[speedy-vision.js]', message);\n        return message;\n    }\n\n    /**\n     * Logs a message\n     * @param {string} text message text\n     * @param  {...string} [args] optional text\n     * @returns {string} the message text\n     */\n    static log(text, ...args)\n    {\n        const message = [ text, ...args ].join(' ');\n        console.log('[speedy-vision.js]', message);\n        return message;\n    }\n\n    /**\n     * Assertion\n     * @param {boolean} expr expression\n     * @param {string} [text] error message\n     * @throws {SpeedyError}\n     */\n    static assert(expr, text = '')\n    {\n        if(!expr)\n            throw new SpeedyError('Assertion failed.', text);\n    }\n\n    /**\n     * Generates an enumeration\n     * @param {...string} values enumeration options\n     * @returns {object} enum object\n     */\n    static enum(...values)\n    {\n        return Object.freeze(\n            values.reduce((acc, cur) => ((acc[cur] = Symbol(cur)), acc), { })\n        );\n    }\n\n    /**\n     * Similar to setTimeout(fn, 0), but without the ~4ms delay.\n     * Although much faster than setTimeout, this may be resource-hungry\n     * (heavy on battery) if used in a loop. Use with caution.\n     * Implementation based on David Baron's, but adapted for ES6 classes\n     * @param {Function} fn\n     */\n    //static setZeroTimeout(fn) { setTimeout(fn, 0); } // easier on the CPU\n    static get setZeroTimeout()\n    {\n        return this._setZeroTimeout || (this._setZeroTimeout = (() => {\n            const msgId = '0%' + Math.random().toString(36).slice(2);\n            const queue = [];\n\n            window.addEventListener('message', ev => {\n                if(ev.source === window && ev.data === msgId) {\n                    event.stopPropagation();\n                    queue.shift().call(window);\n                }\n            }, true);\n\n            // make it efficient\n            return function setZeroTimeout(fn) {\n                queue.push(fn);\n                window.postMessage(msgId, '*');\n            }\n        })());\n    }\n\n    /**\n     * Generates a random number with\n     * Gaussian distribution (mu, sigma)\n     * @param {number} mu mean\n     * @param {number} sigma standard deviation\n     * @returns {number} random number\n     */\n    static gaussianNoise(mu = 0, sigma = 1)\n    {\n        // Box-Muller transformation\n        const TWO_PI = 2.0 * Math.PI;\n        \n        let a, b = Math.random();\n        do { a = Math.random(); } while(a <= Number.EPSILON);\n        let z = Math.sqrt(-2 * Math.log(a)) * Math.sin(TWO_PI * b);\n\n        return z * sigma + mu;\n    }\n\n    /**\n     * Generate a 1D gaussian kernel with custom sigma\n     * Tip: use kernelSize = (5 * sigma), kernelSize odd\n     * @param {number} sigma gaussian sigma\n     * @param {number} [kernelSize] kernel size, odd number\n     * @param {bool} [normalized] normalize entries so that their sum is 1\n     */\n    static gaussianKernel(sigma, kernelSize = -1, normalized = true)\n    {\n        /*\n         * Let G(x) be a Gaussian function centered at 0 with fixed sigma:\n         *\n         * G(x) = (1 / (sigma * sqrt(2 * pi))) * exp(-(x / (sqrt(2) * sigma))^2)\n         * \n         * In addition, let f(p) be a kernel value at pixel p, -k/2 <= p <= k/2:\n         * \n         * f(p) = \\int_{p - 0.5}^{p + 0.5} G(x) dx (integrate around p)\n         *      = \\int_{0}^{p + 0.5} G(x) dx - \\int_{0}^{p - 0.5} G(x) dx\n         * \n         * Setting a constant c := sqrt(2) * sigma, it follows that:\n         * \n         * f(p) = (1 / 2c) * (erf((p + 0.5) / c) - erf((p - 0.5) / c))\n         */\n\n        // default kernel size\n        if(kernelSize < 0) {\n            kernelSize = Math.ceil(5.0 * sigma) | 0;\n            kernelSize += 1 - (kernelSize % 2);\n        }\n\n        // validate input\n        kernelSize |= 0;\n        if(kernelSize < 1 || kernelSize % 2 == 0)\n            Utils.fatal(`Invalid kernel size given to gaussianKernel: ${kernelSize} x 1`);\n        else if(sigma <= 0.0)\n            Utils.fatal(`Invalid sigma given to gaussianKernel: ${sigma}`);\n\n        // function erf(x) = -erf(-x) can be approximated numerically. See:\n        // https://en.wikipedia.org/wiki/Error_function#Numerical_approximations\n        const kernel = new Array(kernelSize);\n\n        // set constants\n        const N  =  kernelSize >> 1; // integer (floor, div 2)\n        const c  =  (+sigma) * Math.sqrt(2);\n        const m  =  0.3275911;\n        const a1 =  0.254829592;\n        const a2 = -0.284496736;\n        const a3 =  1.421413741;\n        const a4 = -1.453152027;\n        const a5 =  1.061405429;\n\n        // compute the kernel\n        let sum = 0.0;\n        for(let j = 0; j < kernelSize; j++) {\n            let xa = (j - N + 0.5) / c;\n            let xb = (j - N - 0.5) / c;\n            let sa = 1.0, sb = 1.0;\n\n            if(xa < 0.0) { sa = -1.0; xa = -xa; }\n            if(xb < 0.0) { sb = -1.0; xb = -xb; }\n\n            const ta = 1.0 / (1.0 + m * xa);\n            const tb = 1.0 / (1.0 + m * xb);\n            const pa = ((((a5 * ta + a4) * ta + a3) * ta + a2) * ta + a1) * ta;\n            const pb = ((((a5 * tb + a4) * tb + a3) * tb + a2) * tb + a1) * tb;\n            const ya = 1.0 - pa * Math.exp(-xa * xa);\n            const yb = 1.0 - pb * Math.exp(-xb * xb);\n\n            const erfa = sa * ya;\n            const erfb = sb * yb;\n            const fp = (erfa - erfb) / (2.0 * c);\n\n            kernel[j] = fp;\n            sum += fp;\n        }\n\n        // done!\n        return normalized ? kernel.map(k => k / sum) : kernel;\n    }\n}"],"sourceRoot":""}