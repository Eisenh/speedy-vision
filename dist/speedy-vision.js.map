{"version":3,"sources":["webpack://Speedy/webpack/bootstrap","webpack://Speedy/./src/core/features/algorithms/brisk.js","webpack://Speedy/./src/core/features/algorithms/fast.js","webpack://Speedy/./src/core/features/algorithms/harris.js","webpack://Speedy/./src/core/features/algorithms/orb.js","webpack://Speedy/./src/core/features/automatic-sensitivity.js","webpack://Speedy/./src/core/features/features-algorithm.js","webpack://Speedy/./src/core/features/features-downloader.js","webpack://Speedy/./src/core/pipeline-operations.js","webpack://Speedy/./src/core/speedy-descriptor.js","webpack://Speedy/./src/core/speedy-feature.js","webpack://Speedy/./src/core/speedy-media.js","webpack://Speedy/./src/core/speedy-pipeline.js","webpack://Speedy/./src/core/tuners/sensitivity-tuner.js","webpack://Speedy/./src/core/tuners/stochastic-tuner.js","webpack://Speedy/./src/core/tuners/test-tuner.js","webpack://Speedy/./src/core/tuners/tuner.js","webpack://Speedy/./src/gpu/gl-utils.js","webpack://Speedy/./src/gpu/programs/colors.js","webpack://Speedy/./src/gpu/programs/descriptors.js","webpack://Speedy/./src/gpu/programs/encoders.js","webpack://Speedy/./src/gpu/programs/filters.js","webpack://Speedy/./src/gpu/programs/keypoints.js","webpack://Speedy/./src/gpu/programs/pyramids.js","webpack://Speedy/./src/gpu/programs/utils.js","webpack://Speedy/./src/gpu/shader-declaration.js","webpack://Speedy/./src/gpu/shader-preprocessor.js","webpack://Speedy/./src/gpu/shaders sync ^\\.\\/.*$","webpack://Speedy/./src/gpu/shaders/colors/rgb2grey.glsl","webpack://Speedy/./src/gpu/shaders/descriptors/orb.glsl","webpack://Speedy/./src/gpu/shaders/encoders/encode-keypoint-offsets.glsl","webpack://Speedy/./src/gpu/shaders/encoders/encode-keypoints.glsl","webpack://Speedy/./src/gpu/shaders/encoders/orient-encoded-keypoints.glsl","webpack://Speedy/./src/gpu/shaders/filters/convolution.js","webpack://Speedy/./src/gpu/shaders/include sync ^\\.\\/.*$","webpack://Speedy/./src/gpu/shaders/include/colors.glsl","webpack://Speedy/./src/gpu/shaders/include/global.glsl","webpack://Speedy/./src/gpu/shaders/include/math.glsl","webpack://Speedy/./src/gpu/shaders/include/orientation.glsl","webpack://Speedy/./src/gpu/shaders/include/pyramids.glsl","webpack://Speedy/./src/gpu/shaders/include/sobel.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/brisk.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/fast-score12.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/fast-score16.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/fast-score8.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/fast5.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/fast7.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/fast9lg.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/harris-cutoff.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/multiscale-fast.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/multiscale-harris.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/multiscale-sobel.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/multiscale-suppression.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/nonmax-suppression.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/samescale-suppression.glsl","webpack://Speedy/./src/gpu/shaders/pyramids/crop.glsl","webpack://Speedy/./src/gpu/shaders/pyramids/downsample2.glsl","webpack://Speedy/./src/gpu/shaders/pyramids/downsample3.glsl","webpack://Speedy/./src/gpu/shaders/pyramids/merge-keypoints-at-consecutive-levels.glsl","webpack://Speedy/./src/gpu/shaders/pyramids/merge-keypoints.glsl","webpack://Speedy/./src/gpu/shaders/pyramids/normalize-keypoints.glsl","webpack://Speedy/./src/gpu/shaders/pyramids/upsample2.glsl","webpack://Speedy/./src/gpu/shaders/pyramids/upsample3.glsl","webpack://Speedy/./src/gpu/shaders/utils/copy-components.glsl","webpack://Speedy/./src/gpu/shaders/utils/fill-components.glsl","webpack://Speedy/./src/gpu/shaders/utils/fill.glsl","webpack://Speedy/./src/gpu/shaders/utils/flip-y.glsl","webpack://Speedy/./src/gpu/shaders/utils/identity.glsl","webpack://Speedy/./src/gpu/shaders/utils/normalize-image.glsl","webpack://Speedy/./src/gpu/shaders/utils/scan-minmax2d.glsl","webpack://Speedy/./src/gpu/speedy-gpu.js","webpack://Speedy/./src/gpu/speedy-program-center.js","webpack://Speedy/./src/gpu/speedy-program-group.js","webpack://Speedy/./src/gpu/speedy-program.js","webpack://Speedy/./src/speedy.js","webpack://Speedy/./src/utils/errors.js","webpack://Speedy/./src/utils/fps-counter.js","webpack://Speedy/./src/utils/globals.js","webpack://Speedy/./src/utils/observable.js","webpack://Speedy/./src/utils/types.js","webpack://Speedy/./src/utils/utils.js"],"names":[],"mappings":";;;;;;;;;;;;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0D;AACwB;AAC9B;AACQ;;AAE5D;AACA,2BAA2B;AAC3B,wBAAwB;AACxB,oBAAoB;AACpB,kBAAkB,iEAAkB,CAAC;;AAErC;AACA;;;AAGA;AACA;AACA;AACO,4BAA4B,qEAAiB;AACpD;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB,mBAAmB,MAAM;;AAEnE;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,aAAa;AAC5B,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,8BAA8B;;AAE9B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,yBAAyB;AACzB;;AAEA;AACA,SAAS,qBAAqB;AAC9B,SAAS,wBAAwB;AACjC,SAAS,wBAAwB;AACjC,SAAS,wBAAwB;AACjC,SAAS,wBAAwB;AACjC;AACA;;AAEA;AACA;AACA,IAAI,QAAQ;AACZ,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA,WAAW,UAAU;AACrB;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,OAAO;AACzB,sBAAsB,OAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACpPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoD;AACM;AACsB;AACpB;;AAE5D;AACA,oBAAoB;AACpB,6BAA6B;AAC7B,wBAAwB;AACxB,oBAAoB;AACpB,kBAAkB,iEAAkB,CAAC;AACrC,2CAA2C;;AAE3C;AACA;AACA;AACO,2BAA2B,qEAAiB;AACnD;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,K;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO,mBAAmB,iBAAiB;AAC1D;AACA;AACA;AACA;AACA,sBAAsB,+DAAiB,4BAA4B,EAAE;;AAErE;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB,mBAAmB,MAAM;;AAEnE;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,sBAAsB,+DAAiB;;AAEvC;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACjPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoD;AACM;AACJ;AACO;AACD;;AAE5D;AACA,4BAA4B;AAC5B,wBAAwB;AACxB,oBAAoB;AACpB,kBAAkB,iEAAkB,CAAC;AACrC,8BAA8B;AAC9B,0BAA0B;AAC1B,0BAA0B;AAC1B,2CAA2C;AAC3C,+BAA+B,iEAAkB,KAAK;;AAEtD;AACA;AACA;AACO,6BAA6B,qEAAiB;AACrD;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA,K;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,6DAA6D,2DAAc;;AAE3E;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB,mBAAmB,MAAM;;AAEnE;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,qBAAqB;AAC3C;;AAEA;AACA;;AAEA;AACA,sBAAsB,6BAA6B;AACnD;;AAEA;AACA,6DAA6D,2DAAc;;AAE3E;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACjNA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoD;AACA;;AAEpD;AACA,2BAA2B;;AAE3B;AACA;AACA;AACO,0BAA0B,gEAAwB;AACzD;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,aAAa;AAC5B,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC/EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoD;AACF;AACS;AACI;AACd;;AAEjD;AACA,+BAA+B;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,mCAAmC,4DAAU;AACpD;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE;;AAEzE;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA,iCAAiC;;AAEjC;AACA;AACA,mDAAmD;AACnD,8BAA8B,0EAAgB,UAAU;AACxD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;AC/JA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE+E;AAChB;AACJ;AACT;AACD;;AAEjD;AACA;AACA;AACA;AACsB;AACtB;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA,+BAA+B,uEAAkB;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,aAAa;AAC5B,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,wBAAwB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,2EAAoB;AACrE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACzNA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2D;AACP;AACF;AACD;;AAEjD;AACA,2CAA2C;AAC3C,yCAAyC;;AAEzC;AACA;AACA;AACA;AACO,iCAAiC,4DAAU;AAClD;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT,sBAAsB,mEAAqB;AAC3C,SAAS;AACT;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC3GA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6C;AACN;AACG;AACgC;;AAEnE,2BAA2B;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,eAAe,YAAY;AAC3B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wDAAW;AAC5C;AACA,sCAAsC,wDAAW;AACjD,sBAAsB,+DAAiB;;AAEvC,6BAA6B,wDAAW;AACxC;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,4BAA4B;AAC5B;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,sBAAsB,kEAAoB,yBAAyB,KAAK;;AAExE;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB,qBAAqB,OAAO;AACtE;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,sBAAsB,kEAAoB;AAC1C;AACA,sBAAsB,kEAAoB,gDAAgD,IAAI;;AAE9F;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kDAAK;;AAErB;AACA,gBAAgB,qDAAO;AACvB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,qDAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,4BAA4B;AAC5B;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,wDAAW;AAC5C;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC/OA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsD;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC7FA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqD;;AAErD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,iEAAc;AACnE;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,QAAQ,GAAG,QAAQ;AACtC;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC9GA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE8C;AACS;AAChB;AACoE;AACzB;AACM;AAChC;AACI;;AAE5D;AACA;AACA,YAAY,sEAAY;AACxB,uBAAuB,gFAAsB;AAC7C,cAAc,0EAAc;AAC5B,yBAAyB,oFAAwB;AACjD,WAAW,oEAAW;AACtB,aAAa,wEAAa;AAC1B;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,eAAe,4DAA4D;AAC3E,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,qEAAqE,EAAE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wDAAW;;AAE3C;AACA;AACA,sCAAsC,sDAAS;AAC/C,aAAa;;AAEb;AACA,4BAA4B,yDAAS;AACrC,2CAA2C;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB;AAC1C;;AAEA;AACA;AACA;AACA,eAAe,oDAAoD;AACnE,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA,wCAAwC,EAAE;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kDAAK,kCAAkC,YAAY;AAC3E;AACA;AACA;AACA;AACA;AACA,mCAAmC,0DAAY,kCAAkC,YAAY;AAC7F,iBAAiB;AACjB;AACA;AACA;AACA,2BAA2B,kEAAoB,kCAAkC,YAAY;AAC7F;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA,yEAAyE,mBAAmB;AAC5F;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,oDAAoD;AACrE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,iBAAiB,sDAAS;AAC1B;;AAEA,iBAAiB,sDAAS;AAC1B;;AAEA,iBAAiB,sDAAS;AAC1B;;AAEA,iBAAiB,sDAAS;AAC1B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,YAAY;AAC7B;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sDAAS,0BAA0B,sDAAS;AACzE,2DAA2D;AAC3D;AACA;AACA;;AAEA;AACA;AACA,eAAe,eAAe;AAC9B,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC,oBAAoB;AACtD,sBAAsB,sDAAS;AAC/B;AACA;;AAEA;AACA;AACA,eAAe,kBAAkB;AACjC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,eAAe;AACf;AACA;;AAEA;AACA,iBAAiB,sDAAS;AAC1B,iBAAiB,sDAAS;AAC1B,iBAAiB,sDAAS;AAC1B;AACA;;AAEA,iBAAiB,sDAAS;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,yBAAyB;AAC1C;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,kEAAoB,oBAAoB,OAAO;;AAErE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wDAAW;AAC5C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA,+BAA+B,iDAAiD;AAChF,+BAA+B,6CAA6C;AAC5E,gCAAgC,mCAAmC;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sDAAS;;AAEhC;AACA,uBAAuB,sDAAS;;AAEhC;AACA,uBAAuB,sDAAS;;AAEhC;AACA,uBAAuB,sDAAS;AAChC;AACA;;AAEA,cAAc,kEAAoB,gDAAgD,YAAY;AAC9F;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,kDAAK;;AAE1B;AACA;;AAEA;AACA;AACA,qCAAqC,cAAc;AACnD;AACA;;AAEA;AACA,kCAAkC;AAClC;;AAEA;AACA,wDAAwD;AACxD;AACA;AACA,QAAQ,kDAAK;;AAEb;AACA,8BAA8B,+DAAiB;;AAE/C;AACA;AACA;AACA,wBAAwB,eAAe;AACvC,yBAAyB,gBAAgB;AACzC,8BAA8B,wBAAwB;AACtD;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gBAAgB,kDAAK;AACrB;AACA;AACA,SAAS;AACT;AACA,uBAAuB,+DAAiB;AACxC;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,C;;;;;;;;;;;;ACveA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0D;AACf;AACa;AACD;;;AAGvD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,wBAAwB;AACzC;AACA;AACA;AACA;AACA,oDAAoD,QAAQ;AAC5D;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,wBAAwB;AACvC,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA,8BAA8B,sDAAS;AACvC;AACA;;AAEA;AACA,8BAA8B,6BAA6B;AAC3D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,mEAAqB;AAChD,SAAS;AACT;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,eAAe,eAAe;AAC9B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,kEAAoB,sBAAsB,SAAS;AACrE;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,oBAAoB,sEAAiB;AACrC;AACA;;AAEA,kBAAkB,kEAAoB,2CAA2C,WAAW;AAC5F;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA,qBAAqB;AACrB;AACA;AACA,gBAAgB,sEAAiB;AACjC;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,gBAAgB,sEAAiB;AACjC;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA,0BAA0B;AAC1B;AACA;AACA,gBAAgB,sEAAiB;AACjC;AACA;AACA,C;;;;;;;;;;;;AC/LA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0C;AACV;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,+BAA+B,4CAAK;AAC3C;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA,wCAAwC,kDAAK;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,kDAAK,yBAAyB;AACrD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC1MA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgC;;AAEhC;AACA;AACA;AACO,8BAA8B,4CAAK;AAC1C;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,yBAAyB;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA,sDAAsD;;AAEtD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtIA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgC;;AAEhC;AACA;AACA;AACO,wBAAwB,4CAAK;AACpC;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACtDA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE+E;;AAE/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,kEAAoB,0BAA0B,WAAW;;AAE/E;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC,aAAa;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACsB;AACtB;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,sBAAsB,iEAAmB;;AAEzC;AACA;AACA,sBAAsB,kEAAoB,wBAAwB,SAAS,GAAG,SAAS;AACvF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,wBAAwB;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACvXA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuC;AACgD;;AAEvF;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,qDAAO;AAC1B;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,qDAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C;AAC3C,6DAA6D;AAC7D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;;AAEA;AACA;;AAEA;AACA,wBAAwB;AACxB;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB;;AAE1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,aAAa;AAC5B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,aAAa;AAC5B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,0FAA0F;AACzG,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAsB,qDAAO,eAAe,aAAa,iCAAiC,oCAAoC;;AAE9H,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,aAAa;AAC5B,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qDAAO,8BAA8B,MAAM,IAAI,OAAO;AAC5E;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,iBAAiB;AAChC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,UAAU;AACzB,eAAe,WAAW;AAC1B,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,kDAAK,6BAA6B;AACtD,iDAAiD;AACjD;AACA;AACA,mEAAmE;AACnE,wBAAwB,kDAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,gBAAgB;AAC/B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,sBAAsB,mEAAqB;AAC3C,SAAS;AACT;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,YAAY;AAC3B,eAAe,WAAW;AAC1B,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,iBAAiB;AAChC,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB;;AAE1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,sBAAsB,mEAAqB;AAC3C,SAAS;AACT;AACA,C;;;;;;;;;;;;AChdA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6D;AACR;;;;AAIrD;AACA;AACA;;AAEA;AACA,iBAAiB,wEAAY;;;;;AAK7B;AACA;AACA;AACA;AACO,wBAAwB,wEAAkB;AACjD;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACxDA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6D;AACR;;;;AAIrD;AACA;AACA;;AAEA;AACA,YAAY,wEAAY;;;;;AAKxB;AACA;AACA;AACA;AACO,6BAA6B,wEAAkB;AACtD;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,aAAa;AAC5B,eAAe,OAAO;AACtB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACrEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6D;AACR;AACK;AACM;AACK;AAC5B;AACkB;;AAE3D;AACA;AACA,+BAA+B;AAC/B,kDAAkD;AAClD,4DAA4D;AAC5D,+BAA+B;AAC/B;AACA,mCAAmC;AACnC;;;;AAIA;AACA;AACA;;AAEA;AACA,8BAA8B,wEAAY;;AAE1C;AACA,wBAAwB,wEAAY;;AAEpC;AACA,+BAA+B,wEAAY;;AAE3C;AACA,0BAA0B,wEAAY;;;;;AAKtC;AACA;AACA;AACA;AACO,0BAA0B,wEAAkB;AACnD;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;;AAEA;AACA,2CAA2C,kDAAK;AAChD,0BAA0B,6EAAe;AACzC;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA,gGAAgG;AAChG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,OAAO;AACtB,eAAe,aAAa;AAC5B,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,OAAO;AACtB,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,mBAAmB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mCAAmC;AACnC;AACA;;AAEA;;AAEA;AACA;AACA,uCAAuC,wEAAgB;AACvD,mCAAmC,kEAAa;AAChD;AACA;AACA,mCAAmC,kEAAa;AAChD;;AAEA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,KAAK;AACpB,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB;AAC3C;AACA;AACA,C;;;;;;;;;;;;AC5PA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6D;AACgE;;AAE7H;AACA;AACA;AACA;AACO,yBAAyB,wEAAkB;AAClD;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,8EAAS,MAAM;AAClD;AACA,aAAa;AACb,mCAAmC,8EAAS,MAAM;AAClD;AACA,aAAa;AACb,mCAAmC,8EAAS,MAAM;AAClD;AACA,aAAa;;AAEb;AACA;AACA,kCAAkC,6EAAQ;AAC1C,kCAAkC,6EAAQ;AAC1C;AACA,kCAAkC,6EAAQ;AAC1C,kCAAkC,6EAAQ;AAC1C;AACA,kCAAkC,6EAAQ;AAC1C,kCAAkC,6EAAQ;AAC1C;AACA,kCAAkC,6EAAQ;AAC1C,kCAAkC,6EAAQ;AAC1C;AACA,mCAAmC,6EAAQ;AAC3C,mCAAmC,6EAAQ;;AAE3C;AACA,wCAAwC,mFAAc,MAAM;AAC5D;AACA;AACA,aAAa;AACb,wCAAwC,mFAAc,MAAM;AAC5D;AACA;AACA,aAAa;AACb,wCAAwC,mFAAc,MAAM;AAC5D;AACA;AACA,aAAa;AACb,wCAAwC,mFAAc,MAAM;AAC5D;AACA;AACA,aAAa;AACb,wCAAwC,mFAAc,MAAM;AAC5D;AACA;AACA,aAAa;AACb,wCAAwC,mFAAc,MAAM;AAC5D;AACA;AACA,aAAa;AACb,wCAAwC,mFAAc,MAAM;AAC5D;AACA;AACA,aAAa;AACb,yCAAyC,mFAAc,OAAO;AAC9D;AACA;AACA,aAAa;AACb,oDAAoD;AACpD;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;;;;;AAKb;AACA;AACA,iCAAiC,0EAAK;AACtC;AACA;AACA;AACA,iCAAiC,0EAAK;AACtC;AACA;AACA;AACA,iCAAiC,0EAAK;AACtC;AACA;AACA;AACA,iCAAiC,0EAAK;AACtC;AACA;AACA;AACA,iCAAiC,0EAAK;AACtC;AACA;AACA,iCAAiC,0EAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA,+BAA+B,0EAAK;AACpC;AACA;AACA,+BAA+B,0EAAK;AACpC;AACA;AACA,+BAA+B,0EAAK;AACpC;AACA;AACA,+BAA+B,0EAAK;AACpC;AACA;AACA,+BAA+B,0EAAK;AACpC;AACA;AACA,+BAA+B,0EAAK;AACpC;AACA;AACA,+BAA+B,0EAAK;AACpC;AACA;AACA,+BAA+B,0EAAK;AACpC;AACA;AACA,gCAAgC,0EAAK;AACrC;AACA;AACA,gCAAgC,0EAAK;AACrC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChMA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6D;AACR;;;;AAIrD;AACA;AACA;;AAEA;AACA;AACA,cAAc,wEAAY;;AAE1B;AACA;AACA,cAAc,wEAAY;;AAE1B;AACA;AACA,cAAc,wEAAY;;AAE1B;AACA;AACA,oBAAoB,wEAAY;;AAEhC;AACA;AACA,oBAAoB,wEAAY;;AAEhC;AACA;AACA,mBAAmB,wEAAY;;AAE/B;AACA;AACA,uBAAuB,wEAAY;AACnC;;AAEA;AACA;AACA,iCAAiC,wEAAY;AAC7C;AACA;AACA;AACA,iCAAiC;;;;AAIjC;AACA;AACA;;AAEA;AACA,yBAAyB,wEAAY;AACrC;;AAEA;AACA,qBAAqB,wEAAY;;;AAGjC;AACA;AACA;AACA,cAAc,wEAAY;AAC1B;;;;AAIA;AACA;AACA;;AAEA;AACA,0BAA0B,wEAAY;AACtC,8BAA8B,wEAAY;AAC1C,6BAA6B,wEAAY;;AAEzC;AACA,wBAAwB,wEAAY;;;;;AAKpC;AACA;AACA;AACA;AACO,2BAA2B,wEAAkB;AACpD;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;;;;;;;;;;;;;AC7JA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6D;AACM;AACS;AACd;;;;AAI9D;AACA;AACA;;AAEA;AACA,kBAAkB,wEAAY;AAC9B,oBAAoB,wEAAY;AAChC,kBAAkB,wEAAY;AAC9B,oBAAoB,wEAAY;;AAEhC;AACA,uBAAuB,wEAAY;AACnC,0CAA0C,wEAAY;AACtD,2BAA2B,wEAAY;;AAEvC;AACA,aAAa,wEAAY;AACzB,cAAc,wEAAY;;;;AAI1B;AACA;AACA;AACA;AACO,0BAA0B,wEAAkB;AACnD;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;;;AAIb;AACA;AACA;AACA,iCAAiC,0EAAK;AACtC;AACA;AACA,iCAAiC,0EAAK;AACtC;AACA;;AAEA;AACA;AACA,kCAAkC,0EAAK;AACvC;AACA;;AAEA,kCAAkC,0EAAK;AACvC;AACA;;AAEA;AACA;AACA,kCAAkC,0EAAK;AACvC;AACA;;AAEA,kCAAkC,0EAAK;AACvC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,gEAAiB;AAC3C,yCAAyC,iEAAkB;AAC3D,wDAAwD,gEAAiB;AACzE,gDAAgD,iEAAkB;;AAElE;AACA;;AAEA;AACA;AACA,qDAAqD,MAAM;AAC3D;AACA;;AAEA,WAAW,wEAAY;AACvB;;AAEA;AACA;AACA;AACA,0BAA0B,gEAAiB;AAC3C;AACA,yCAAyC,iEAAkB;;AAE3D;AACA;;AAEA;AACA;AACA;AACA,8CAA8C,MAAM;;AAEpD;AACA;AACA;;AAEA,WAAW,wEAAY;AACvB,C;;;;;;;;;;;;AChQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6D;AACR;AACf;AAC+B;AACX;;;;AAI1D;AACA;AACA;;AAEA;AACA,iBAAiB,wEAAY;;AAE7B;AACA,cAAc,wEAAY;;AAE1B;AACA,aAAa,wEAAY;;AAEzB;AACA,uBAAuB,wEAAY;;AAEnC;AACA,uBAAuB,wEAAY;;AAEnC;AACA;;AAEA;AACA,qBAAqB,wEAAY;;AAEjC;AACA,gCAAgC,wEAAY;AAC5C;AACA;AACA;AACA,gCAAgC;;AAEhC;AACA,8BAA8B,wEAAY;AAC1C;;;;AAIA;AACA;AACA;AACA;AACO,uBAAuB,wEAAkB;AAChD;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,iDAAO;AACtB;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA,QAAQ,iDAAO;AACf;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,OAAO;AACtB,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA,oEAAoE,2DAAc;AAClF;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,OAAO;AACtB,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA,oEAAoE,2DAAc;AAClF;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,aAAa;AAC5B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA,YAAY,6DAAgB;AAC5B,sBAAsB,kEAAoB,0BAA0B,aAAa;;AAEjF,+BAA+B,6DAAgB;AAC/C;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA,iDAAiD,2DAAc;AAC/D;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,yDAAyD,2DAAc;AACvE,yDAAyD,2DAAc;AACvE,8CAA8C,2DAAc;;AAE5D;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,OAAO;AACtB,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,2DAAc;;AAEtE,sBAAsB,mBAAmB;AACzC;;AAEA;AACA;AACA,C;;;;;;;;;;;;ACpPA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2D;AAC2B;;AAEtF;AACA;;AAEA;AACA,UAAU;AACV,UAAU;AACV;;AAEA;AACA,yBAAyB,gBAAgB;AACzC,iBAAiB;AACjB,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mEAAQ,IAAY,WAAW,CAAC;;AAElE;AACA,+BAA+B,uEAAkB;AACjD,6BAA6B,uEAAkB;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,+DAAiB,0BAA0B,SAAS;;AAE1E,sCAAsC,WAAW;AACjD;;AAEA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B,kEAAoB,cAAc,QAAQ;AACxE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,IAAI,GAAG,aAAa;;AAErD;AACA;AACA,+BAA+B,uEAAkB;;AAEjD;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB,oCAAoC,KAAK;;AAEnF;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,yDAAyD;AACzD,2EAA2E;AAC3E,0BAA0B;;AAE1B;AACA;AACA;AACA,4FAA4F;;AAE5F;AACA;AACA;AACA;AACA,kCAAkC,wDAAU,0CAA0C,KAAK;AAC3F;AACA,kCAAkC,YAAY;AAC9C,oCAAoC,MAAM,GAAG,EAAE;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;AACA;AACA,C;;;;;;;;;;;;AC1PA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE8F;AAC9C;AACI;;AAEpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,iEAAkB;AAC5C,wCAAwC,gEAAiB;AACzD,2BAA2B,kEAAmB;;AAE9C;AACA,0BAA0B,2DAAc;AACxC,4BAA4B,2DAAc;AAC1C,2BAA2B,2DAAc;AACzC,4BAA4B,2DAAc;AAC1C;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe,2EAAQ,IAAoB,WAAW,CAAC;;AAEvD,cAAc,+DAAiB,2CAA2C,SAAS;AACnF,C;;;;;;;;;;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kE;;;;;;;;;;;AC/DA,uEAAuE,0BAA0B,gBAAgB,kCAAkC,6BAA6B,8BAA8B,GAAG,C;;;;;;;;;;;ACAjN,sIAAsI,4BAA4B,4BAA4B,gCAAgC,mCAAmC,ikKAAikK,8EAA8E,4BAA4B,0BAA0B,0BAA0B,gFAAgF,gFAAgF,GAAG,sBAAsB,iBAAiB,oBAAoB,YAAY,IAAI,gBAAgB,sBAAsB,2CAA2C,kCAAkC,yDAAyD,yDAAyD,4DAA4D,gBAAgB,iCAAiC,oDAAoD,4FAA4F,yFAAyF,6HAA6H,0DAA0D,kGAAkG,4EAA4E,gEAAgE,gDAAgD,iCAAiC,sCAAsC,yCAAyC,yCAAyC,iDAAiD,yCAAyC,yCAAyC,gBAAgB,OAAO,OAAO,iBAAiB,aAAa,YAAY,gBAAgB,gBAAgB,OAAO,OAAO,kDAAkD,kFAAkF,kFAAkF,+BAA+B,GAAG,iBAAiB,GAAG,mHAAmH,GAAG,C;;;;;;;;;;;ACAl/O,0CAA0C,0BAA0B,4BAA4B,gBAAgB,kCAAkC,+BAA+B,kBAAkB,yFAAyF,WAAW,oCAAoC,2BAA2B,GAAG,kEAAkE,GAAG,C;;;;;;;;;;;ACA9a,yEAAyE,0BAA0B,4BAA4B,6BAA6B,oEAAoE,mBAAmB,6BAA6B,0BAA0B,IAAI,yCAAyC,sBAAsB,4BAA4B,GAAG,iCAAiC,qDAAqD,GAAG,eAAe,GAAG,gBAAgB,aAAa,iBAAiB,kCAAkC,8CAA8C,iCAAiC,gBAAgB,uCAAuC,2CAA2C,gBAAgB,aAAa,WAAW,4BAA4B,2BAA2B,4EAA4E,QAAQ,GAAG,WAAW,wBAAwB,wBAAwB,2CAA2C,6CAA6C,QAAQ,GAAG,YAAY,qBAAqB,QAAQ,GAAG,GAAG,GAAG,GAAG,C;;;;;;;;;;;ACAjoC,+HAA+H,0BAA0B,qCAAqC,4BAA4B,6BAA6B,mEAAmE,wEAAwE,mpMAAmpM,iCAAiC,iCAAiC,gBAAgB,6CAA6C,kCAAkC,yDAAyD,iDAAiD,yDAAyD,sDAAsD,gBAAgB,gCAAgC,oDAAoD,4FAA4F,2FAA2F,kIAAkI,iCAAiC,wBAAwB,sBAAsB,8CAA8C,yDAAyD,uEAAuE,iCAAiC,sCAAsC,gBAAgB,WAAW,OAAO,2CAA2C,iEAAiE,sEAAsE,6BAA6B,GAAG,oCAAoC,qCAAqC,GAAG,C;;;;;;;;;;;;ACAh7P;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwD;AACK;;AAE7D;AACA,wEAAwE;AACxE,qEAAqE;;;;AAIrE;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,kEAAoB,4DAA4D,MAAM;AACxG;AACA,kBAAkB,kEAAoB,qCAAqC,gBAAgB;;AAE3F;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+CAA+C,OAAO,IAAI,OAAO,aAAa,GAAG;AACjF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA,WAAW,wEAAY;AACvB;;;;;AAKA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB;AACO;AACP;AACA;AACA;;;;;AAKA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB;AACO;AACP;AACA;AACA;;;;;AAKA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,kEAAoB,4DAA4D,MAAM;AACxG;AACA,kBAAkB,kEAAoB,gDAAgD,KAAK,IAAI;;AAE/F;AACA;AACA;AACA;AACA;AACA,8CAA8C,MAAM,gBAAgB,GAAG;AACvE;AACA,iDAAiD,MAAM,aAAa,GAAG;AACvE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA,WAAW,wEAAY;AACvB;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,IAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,OAAO;AAChB;AACA,uBAAuB,KAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACO;AACP;AACA;AACA;AACA;AACA,kBAAkB,kEAAoB,6CAA6C,WAAW;;AAE9F;AACA;AACA,2BAA2B,wBAAwB;;AAEnD;AACA;AACA;AACA,8BAA8B,WAAW;;AAEzC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,wEAAY;AACvB;;;;;AAKA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACO;AACP;AACA;AACA;AACA;AACA,kBAAkB,kEAAoB,6CAA6C,WAAW;;AAE9F;AACA;AACA,2BAA2B,WAAW;;AAEtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,wEAAY;AACvB;;;;;AAKA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACO;AACP;AACA;AACA,8BAA8B;AAC9B;AACA,kBAAkB,kEAAoB,gFAAgF,WAAW;;AAEjI;AACA;AACA;AACA;;AAEA;AACA,4CAA4C,MAAM,IAAI,MAAM;AAC5D;AACA,+CAA+C,EAAE,IAAI,EAAE;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA,WAAW,wEAAY;AACvB;;;;;AAKA;AACA;AACA,WAAW,OAAO;AAClB;AACO;;;;AAIP;AACA;AACA,WAAW,OAAO;AAClB;AACO;;;;;AAKP;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,kBAAkB,kEAAoB,gFAAgF,WAAW;AACjI;AACA,kBAAkB,kEAAoB,gEAAgE,KAAK,IAAI;;AAE/G;AACA;AACA;AACA,4CAA4C,MAAM;AAClD;AACA,+CAA+C,EAAE;AACjD;AACA,4CAA4C,MAAM;AAClD;AACA,kDAAkD,EAAE;AACpD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA,WAAW,wEAAY;AACvB,C;;;;;;;;;;;ACjZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0E;;;;;;;;;;;AC3BA,sR;;;;;;;;;;;ACAA,iLAAiL,+CAA+C,QAAQ,EAAE,+N;;;;;;;;;;;ACA1O,8UAA8U,0BAA0B,gIAAgI,GAAG,wGAAwG,8FAA8F,GAAG,gE;;;;;;;;;;;ACAprB,yO;;;;;;;;;;;ACAA,wqBAAwqB,wFAAwF,GAAG,sCAAsC,+HAA+H,GAAG,uKAAuK,S;;;;;;;;;;;ACAllC,wFAAwF,iCAAiC,+BAA+B,8BAA8B,gCAAgC,GAAG,wCAAwC,+BAA+B,wCAAwC,GAAG,S;;;;;;;;;;;ACA3U,0DAA0D,uCAAuC,gBAAgB,kCAAkC,wBAAwB,2BAA2B,uCAAuC,uCAAuC,qDAAqD,sEAAsE,sEAAsE,iCAAiC,+CAA+C,+CAA+C,+CAA+C,iCAAiC,+CAA+C,+CAA+C,+CAA+C,kHAAkH,gCAAgC,gDAAgD,gCAAgC,gCAAgC,2IAA2I,2IAA2I,0EAA0E,0EAA0E,uCAAuC,qCAAqC,qCAAqC,uCAAuC,+CAA+C,iCAAiC,oEAAoE,wBAAwB,mFAAmF,kGAAkG,6BAA6B,sCAAsC,qEAAqE,mDAAmD,kDAAkD,+DAA+D,GAAG,C;;;;;;;;;;;ACArwE,0CAA0C,0BAA0B,gBAAgB,kCAAkC,yCAAyC,4CAA4C,iDAAiD,iDAAiD,iDAAiD,iDAAiD,kDAAkD,kDAAkD,kDAAkD,mDAAmD,mDAAmD,kDAAkD,mDAAmD,mDAAmD,iCAAiC,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,4DAA4D,4DAA4D,gDAAgD,qEAAqE,GAAG,C;;;;;;;;;;;ACAxnD,0CAA0C,0BAA0B,mDAAmD,iDAAiD,gBAAgB,kCAAkC,yCAAyC,4CAA4C,koBAAkoB,uMAAuM,2DAA2D,6BAA6B,2BAA2B,6BAA6B,2BAA2B,6BAA6B,2BAA2B,0DAA0D,qEAAqE,GAAG,C;;;;;;;;;;;ACA79C,0CAA0C,0BAA0B,gBAAgB,kCAAkC,yCAAyC,4CAA4C,iDAAiD,iDAAiD,iDAAiD,kDAAkD,kDAAkD,mDAAmD,kDAAkD,kDAAkD,iCAAiC,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,+CAA+C,qEAAqE,GAAG,C;;;;;;;;;;;ACAjsC,0CAA0C,0BAA0B,gBAAgB,kCAAkC,4BAA4B,kCAAkC,gCAAgC,6FAA6F,yCAAyC,oBAAoB,gCAAgC,iDAAiD,iDAAiD,iDAAiD,kDAAkD,kDAAkD,mDAAmD,kDAAkD,kDAAkD,oIAAoI,sBAAsB,2CAA2C,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,8BAA8B,2BAA2B,iCAAiC,YAAY,iCAAiC,YAAY,iCAAiC,YAAY,iCAAiC,YAAY,GAAG,cAAc,2BAA2B,gCAAgC,YAAY,gCAAgC,YAAY,gCAAgC,YAAY,gCAAgC,YAAY,GAAG,cAAc,wDAAwD,GAAG,QAAQ,gCAAgC,GAAG,GAAG,GAAG,GAAG,C;;;;;;;;;;;ACAlrF,0CAA0C,0BAA0B,gBAAgB,kCAAkC,4BAA4B,kCAAkC,gCAAgC,6FAA6F,yCAAyC,oBAAoB,gCAAgC,iDAAiD,iDAAiD,iDAAiD,iDAAiD,kDAAkD,kDAAkD,kDAAkD,mDAAmD,mDAAmD,kDAAkD,mDAAmD,mDAAmD,oIAAoI,sBAAsB,2CAA2C,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,iBAAiB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,eAAe,SAAS,yBAAyB,EAAE,aAAa,EAAE,iBAAiB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,eAAe,SAAS,yBAAyB,EAAE,aAAa,EAAE,8BAA8B,2BAA2B,iCAAiC,YAAY,iCAAiC,YAAY,iCAAiC,YAAY,iCAAiC,YAAY,iCAAiC,YAAY,iCAAiC,YAAY,GAAG,cAAc,2BAA2B,gCAAgC,YAAY,gCAAgC,YAAY,gCAAgC,YAAY,gCAAgC,YAAY,gCAAgC,YAAY,gCAAgC,YAAY,GAAG,cAAc,wDAAwD,GAAG,QAAQ,gCAAgC,GAAG,GAAG,GAAG,GAAG,C;;;;;;;;;;;ACAtnH,0CAA0C,0BAA0B,yCAAyC,gBAAgB,kCAAkC,kCAAkC,4BAA4B,gCAAgC,kEAAkE,yCAAyC,4CAA4C,iDAAiD,iDAAiD,kDAAkD,mDAAmD,gIAAgI,iDAAiD,iDAAiD,iDAAiD,kDAAkD,kDAAkD,kDAAkD,mDAAmD,oDAAoD,oDAAoD,mDAAmD,mDAAmD,mDAAmD,mWAAmW,8vEAA8vE,2CAA2C,GAAG,C;;;;;;;;;;;ACAv8H,4CAA4C,6BAA6B,wBAAwB,gBAAgB,oCAAoC,yEAAyE,mDAAmD,iCAAiC,GAAG,C;;;;;;;;;;;ACArT,wEAAwE,0BAA0B,8BAA8B,yCAAyC,mDAAmD,iDAAiD,gBAAgB,oCAAoC,kCAAkC,4BAA4B,yCAAyC,4CAA4C,kCAAkC,oRAAoR,sBAAsB,gBAAgB,yBAAyB,OAAO,8BAA8B,wBAAwB,+DAA+D,6CAA6C,8DAA8D,6CAA6C,8DAA8D,6CAA6C,8DAA8D,6CAA6C,6DAA6D,6CAA6C,6DAA6D,6CAA6C,8DAA8D,6CAA6C,6DAA6D,6CAA6C,6DAA6D,6CAA6C,GAAG,qDAAqD,+BAA+B,qBAAqB,0BAA0B,qCAAqC,iCAAiC,mBAAmB,oBAAoB,2OAA2O,4rBAA4rB,uhBAAuhB,8vEAA8vE,qBAAqB,0DAA0D,8MAA8M,uBAAuB,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,mGAAmG,mBAAmB,8MAA8M,2DAA2D,6BAA6B,2BAA2B,6BAA6B,2BAA2B,6BAA6B,2BAA2B,oDAAoD,mCAAmC,sCAAsC,iDAAiD,+BAA+B,sDAAsD,GAAG,uBAAuB,GAAG,C;;;;;;;;;;;ACA13O,iGAAiG,2BAA2B,8BAA8B,4DAA4D,uDAAuD,iBAAiB,2FAA2F,2FAA2F,2FAA2F,2FAA2F,2FAA2F,2FAA2F,2FAA2F,2FAA2F,GAAG,GAAG,gBAAgB,kCAAkC,oCAAoC,kCAAkC,qBAAqB,0BAA0B,YAAY,kCAAkC,4BAA4B,mBAAmB,OAAO,4BAA4B,mBAAmB,OAAO,mEAAmE,mDAAmD,GAAG,GAAG,2FAA2F,2CAA2C,mCAAmC,+BAA+B,sDAAsD,GAAG,yCAAyC,GAAG,C;;;;;;;;;;;ACAtuD,iGAAiG,oBAAoB,oGAAoG,gGAAgG,2CAA2C,gBAAgB,wBAAwB,8fAA8f,4DAA4D,0DAA0D,kHAAkH,0BAA0B,GAAG,C;;;;;;;;;;;ACA/oC,sEAAsE,kGAAkG,kCAAkC,iCAAiC,uBAAuB,gBAAgB,8BAA8B,wEAAwE,8CAA8C,8CAA8C,+CAA+C,+CAA+C,gDAAgD,+CAA+C,+CAA+C,6CAA6C,uEAAuE,iFAAiF,8CAA8C,8CAA8C,8CAA8C,8CAA8C,+CAA+C,+CAA+C,+CAA+C,+CAA+C,gDAAgD,iDAAiD,iDAAiD,gDAAgD,gDAAgD,gDAAgD,gDAAgD,mFAAmF,qHAAqH,gFAAgF,8CAA8C,8CAA8C,8CAA8C,+CAA+C,+CAA+C,+CAA+C,gDAAgD,gDAAgD,+CAA+C,gDAAgD,gDAAgD,+CAA+C,+CAA+C,gDAAgD,gDAAgD,mFAAmF,sHAAsH,wEAAwE,4CAA4C,uCAAuC,yCAAyC,muBAAmuB,+6CAA+6C,86CAA86C,8EAA8E,uGAAuG,kGAAkG,uFAAuF,mHAAmH,8GAA8G,0EAA0E,oDAAoD,mCAAmC,GAAG,C;;;;;;;;;;;ACAvuO,0CAA0C,gBAAgB,iDAAiD,iDAAiD,iDAAiD,kDAAkD,kDAAkD,mDAAmD,kDAAkD,kDAAkD,mFAAmF,kCAAkC,2CAA2C,iCAAiC,GAAG,C;;;;;;;;;;;ACA5oB,sEAAsE,gBAAgB,kCAAkC,kCAAkC,iCAAiC,wBAAwB,gBAAgB,8BAA8B,8CAA8C,8CAA8C,8CAA8C,+CAA+C,+CAA+C,gDAAgD,+CAA+C,+CAA+C,8ZAA8Z,0DAA0D,mEAAmE,oDAAoD,mCAAmC,GAAG,C;;;;;;;;;;;ACA5uC,0CAA0C,gBAAgB,kCAAkC,4BAA4B,2BAA2B,wDAAwD,GAAG,C;;;;;;;;;;;ACA9M,0CAA0C,gBAAgB,kCAAkC,yDAAyD,8BAA8B,GAAG,C;;;;;;;;;;;ACAtL,0CAA0C,gBAAgB,kCAAkC,yDAAyD,8BAA8B,GAAG,C;;;;;;;;;;;ACAtL,gDAAgD,iCAAiC,gBAAgB,kCAAkC,+EAA+E,qFAAqF,qGAAqG,GAAG,C;;;;;;;;;;;ACA/Y,2CAA2C,2BAA2B,gBAAgB,+BAA+B,+BAA+B,8BAA8B,GAAG,C;;;;;;;;;;;ACArL,0CAA0C,2BAA2B,gCAAgC,uDAAuD,kCAAkC,4BAA4B,0DAA0D,0CAA0C,kCAAkC,qDAAqD,mEAAmE,mEAAmE,mEAAmE,yIAAyI,oQAAoQ,yCAAyC,GAAG,C;;;;;;;;;;;ACAvhC,0CAA0C,gBAAgB,kCAAkC,0CAA0C,uFAAuF,GAAG,C;;;;;;;;;;;ACAhO,0CAA0C,gBAAgB,kCAAkC,0CAA0C,yDAAyD,iGAAiG,GAAG,C;;;;;;;;;;;ACAnS,wEAAwE,6BAA6B,6BAA6B,gBAAgB,qCAAqC,mCAAmC,kNAAkN,gEAAgE,GAAG,C;;;;;;;;;;;ACA/e,oEAAoE,8BAA8B,sBAAsB,gBAAgB,kCAAkC,sNAAsN,yCAAyC,GAAG,C;;;;;;;;;;;ACA5a,sCAAsC,gBAAgB,sBAAsB,GAAG,C;;;;;;;;;;;ACA/E,0CAA0C,eAAe,+BAA+B,qCAAqC,8BAA8B,GAAG,C;;;;;;;;;;;ACA9J,0CAA0C,gBAAgB,6BAA6B,GAAG,C;;;;;;;;;;;ACA1F,+DAA+D,0CAA0C,iCAAiC,yBAAyB,kCAAkC,gBAAgB,uEAAuE,+BAA+B,4CAA4C,sDAAsD,uDAAuD,kDAAkD,kIAAkI,qFAAqF,yFAAyF,mFAAmF,6EAA6E,uBAAuB,GAAG,C;;;;;;;;;;;ACAh/B,0CAA0C,8BAA8B,gBAAgB,kCAAkC,uCAAuC,oCAAoC,gCAAgC,sCAAsC,qFAAqF,oFAAoF,oFAAoF,uFAAuF,yCAAyC,mDAAmD,mDAAmD,mDAAmD,4CAA4C,4CAA4C,sDAAsD,GAAG,C;;;;;;;;;;;;ACAl7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwC;AACD;AACuB;AAC+B;AACnB;;AAE1E;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB,iEAAkB,mBAAmB,iEAAkB;AAChF,YAAY,kDAAK,iDAAiD,YAAY,KAAK,aAAa;AAChG,gDAAgD,iEAAkB;AAClE,kDAAkD,iEAAkB;AACpE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA,2BAA2B,iEAAkB;AAC7C,sBAAsB,kEAAoB,2BAA2B,GAAG;;AAExE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA,2BAA2B,iEAAkB;AAC7C,sBAAsB,kEAAoB,iCAAiC,GAAG;;AAE9E;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,iEAAkB;AACjC;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,gEAAiB;AAChC;;AAEA;AACA;AACA,eAAe,0FAA0F;AACzG,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,kDAAK;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,kEAAoB;;AAE1C;AACA;AACA;AACA;AACA;AACA,gBAAgB,oDAAO;AACvB;AACA;AACA,YAAY,kDAAK,sCAAsC,MAAM,KAAK,OAAO;AACzE;AACA,gBAAgB,oDAAO;AACvB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ,oDAAO;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD,qBAAqB;AACrB;AACA;AACA,8BAA8B;AAC9B,aAAa;AACb;AACA;AACA,sBAAsB,+DAAiB;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,kDAAK;AACrB;AACA,SAAS;AACT;AACA;AACA,gBAAgB,kDAAK;AACrB;AACA,SAAS;;AAET;AACA;;AAEA;AACA,6BAA6B,0EAAmB;;AAEhD;AACA,+DAA+D,iEAAkB;AACjF,oEAAoE,iEAAkB;AACtF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,oBAAoB;AAC1C,6BAA6B,0EAAmB;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,+DAAiB;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,+DAAiB;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,kBAAkB,+DAAiB;;AAEnC;AACA,C;;;;;;;;;;;;ACpWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4C;AACE;AACE;AACI;AACF;AACM;AACN;;AAElD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iDAAiD,wDAAQ;AACzD;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mDAAmD,0DAAS;AAC5D;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,qDAAqD,4DAAU;AAC/D;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yDAAyD,gEAAY;AACrE;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,uDAAuD,8DAAW;AAClE;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,6DAA6D,oEAAc;AAC3E;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,uDAAuD,8DAAW;AAClE;AACA,C;;;;;;;;;;;;AC3IA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiD;;AAEjD;AACA;AACA;AACA;AACA;;AAEsB;AACtB;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,kBAAkB;AACjC,eAAe,OAAO;AACtB,iBAAiB,mBAAmB;AACpC;AACA,0DAA0D,EAAE;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;;AAET;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb,SAAS;AACT;;AAEA,yDAAyD,EAAE;AAC3D;AACA,mBAAmB,6DAAa;AAChC;AACA;AACA;AACA,SAAS;AACT;AACA,C;;;;;;;;;;;;ACjKA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwC;AACyD;;AAEjG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,kBAAkB;AACjC,eAAe,OAAO;AACtB;AACA,2CAA2C,EAAE;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,oDAAO;AACnB;AACA,aAAa;AACb;AACA;AACA;AACA,YAAY,oDAAO;AACnB;AACA,aAAa;AACb,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA,8BAA8B,mEAAqB,wCAAwC,UAAU;AACrG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,kEAAoB;;AAE1C;AACA;;AAEA;AACA,+BAA+B;AAC/B;AACA;AACA;;AAEA;AACA,iCAAiC,iBAAiB;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,QAAQ,GAAG,aAAa;AAC7E,8BAA8B,kEAAoB,iDAAiD,QAAQ;AAC3G,8BAA8B,+BAA+B,QAAQ,GAAG,EAAE,KAAK;AAC/E;AACA;AACA;AACA,0BAA0B,kEAAoB,yCAAyC,QAAQ,KAAK,QAAQ;AAC5G;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC,oDAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,+DAAiB,eAAe,MAAM,iCAAiC,oCAAoC;AACrI;AACA,0BAA0B,+DAAiB;AAC3C;AACA,0BAA0B,kEAAoB;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kEAAoB,6CAA6C,MAAM;AACjG;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sBAAsB,eAAe;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA,cAAc;AACd,oEAAoE,EAAE;AACtE;AACA;AACA,oBAAoB,oDAAO;;AAE3B;AACA;AACA;AACA,0BAA0B,oDAAO;;AAEjC;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,+DAAiB,0BAA0B,gBAAgB;;AAEjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kEAAoB,iCAAiC,MAAM;AACrF;;AAEA;AACA,YAAY,sCAAsC;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC,2BAA2B,oDAAO;AAClC,uBAAuB,oDAAO;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,oDAAO;AACnB;AACA;;AAEA;AACA;AACA,YAAY,oDAAO;AACnB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,iBAAiB;AACvC,4BAA4B,oDAAO;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;;AAEA,wBAAwB,oDAAO;AAC/B;;AAEA;AACA;AACA,YAAY,oDAAO;;AAEnB;AACA,YAAY,oDAAO;;AAEnB;AACA;AACA;AACA;;AAEA,wCAAwC,MAAM,KAAK,OAAO;AAC1D;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA,KAAK;AACL,C;;;;;;;;;;;;ACpoBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkD;AACM;AACP;;AAEjD;AACA;AACA;AACA;AACA,eAAe,oDAAoD;AACnE,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA,0CAA0C,EAAE;AAC5C;AACA,eAAe,8DAAW;AAC1B;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA,+DAA+D,mBAAmB;AAClF;AACA,eAAe,8DAAW;AAC1B;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,oEAAc;AACjC;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,eAAe,WAAkB;AACjC;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,yBAAyB,QAAQ,6DAAU,cAAc;AACzD;AACA;AACA;;AAEO;AACA;AACA;AACA;AACA,uB;;;;;;;;;;;;ACrFP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,8BAA8B,QAAQ;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,8BAA8B,QAAQ;AACtC;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA,C;;;;;;;;;;;;ACzPA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgC;AACiB;;AAEjD;AACA,4BAA4B;;AAErB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,6DAAqB;;AAE3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;ACpFA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACO,iCAAiC;;;;AAIxC;AACA;AACA;;AAEA;AACO,6BAA6B;;AAEpC;AACO,uDAAuD;;AAE9D;AACO,4BAA4B,iE;;;;;;;;;;;;ACzCnC;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,IAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC9DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgC;;AAEzB,kBAAkB,4CAAK;AAC9B;AACA;AACA;AACA;AACA;;AAEO,oBAAoB,4CAAK;AAChC;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC;;AAEM;AACP;AACA;AACA;AACA;AACA,CAAC,E;;;;;;;;;;;;ACjDD;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2E;;AAEpE;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,UAAU;AAC1B,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,UAAU;AAC1B,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,sBAAsB,sDAAc;AACpC;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,0EAA0E,EAAE;AAC5E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA,iCAAiC,mBAAmB,EAAE;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kDAAU,uCAAuC,KAAK;;AAE5E;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,mBAAmB,EAAE;AACjC;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ,EAAE,QAAQ;AAC1C,wBAAwB,EAAE,EAAE,QAAQ,iBAAiB,EAAE,EAAE,QAAQ;AACjE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,4DAAoB,iDAAiD,WAAW;AACtG;AACA,sBAAsB,4DAAoB,2CAA2C,MAAM;;AAE3F;AACA;AACA;;AAEA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;;AAEA,0BAA0B,WAAW,UAAU;AAC/C,0BAA0B,WAAW,UAAU;;AAE/C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,C","file":"speedy-vision.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/speedy.js\");\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * brisk.js\n * BRISK feature detector & descriptor\n */\n\nimport { FeaturesAlgorithm } from '../features-algorithm';\nimport { IllegalArgumentError, NotImplementedError } from '../../../utils/errors';\nimport { SpeedyGPU } from '../../../gpu/speedy-gpu';\nimport { PYRAMID_MAX_LEVELS } from '../../../utils/globals';\n\n// constants\nconst DESCRIPTOR_SIZE = 64; // 512 bits\nconst DEFAULT_DEPTH = 4; // will check 4 pyramid layers (7 octaves)\nconst MIN_DEPTH = 1; // minimum depth level\nconst MAX_DEPTH = PYRAMID_MAX_LEVELS; // maximum depth level\n\n// static data\nlet shortPairs = null, longPairs = null;\n\n\n/**\n * BRISK feature detector & descriptor\n */\nexport class BRISKFeatures extends FeaturesAlgorithm\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu \n     */\n    constructor(gpu)\n    {\n        super(gpu);\n\n        // default settings\n        this._depth = DEFAULT_DEPTH;\n    }\n\n    /**\n     * Descriptor size for BRISK\n     * @returns {number} in bytes\n     */\n    get descriptorSize()\n    {\n        return DESCRIPTOR_SIZE;\n    }\n\n    /**\n     * Get the depth of the algorithm: how many pyramid layers will be scanned\n     * @returns {number}\n     */\n    get depth()\n    {\n        return this._depth;\n    }\n\n    /**\n     * Set the depth of the algorithm: how many pyramid layers will be scanned\n     * @param {number} depth\n     */\n    set depth(depth)\n    {\n        if(depth < MIN_DEPTH || depth > MAX_DEPTH)\n            throw new IllegalArgumentError(`Invalid depth: ${depth}`);\n\n        this._depth = depth | 0;\n    }\n\n    /**\n     * Detect BRISK features\n     * @param {WebGLTexture} inputTexture pre-processed greyscale image\n     * @returns {WebGLTexture} encoded keypoints\n     */\n    detect(inputTexture)\n    {\n        // TODO\n        throw new NotImplementedError();\n    }\n\n    /**\n     * Compute BRISK descriptors\n     * @param {WebGLTexture} inputTexture pre-processed greyscale image\n     * @param {WebGLTexture} encodedKeypoints encoded, oriented and multi-scale\n     * @returns {WebGLTexture} encoded keypoints with descriptors\n     */\n    describe(inputTexture, encodedKeypoints)\n    {\n        // TODO\n        return encodedKeypoints;\n    }\n\n    /**\n     * Short distance pairings, for scale = 1.0. Format:\n     * [x1,y1,x2,y2, ...]. Thus, 4 elements for each pair\n     * @returns {Float32Array<number>} flattened array\n     */\n    static get shortDistancePairs()\n    {\n        return shortPairs || (shortPairs = briskShortDistancePairs());\n    };\n\n    /**\n     * Long distance pairings, for scale = 1.0. Format:\n     * [x1,y1,x2,y2, ...]. Thus, 4 elements for each pair\n     * @returns {Float32Array<number>} flattened array\n     */\n    static get longDistancePairs()\n    {\n        return longPairs || (longPairs = briskLongDistancePairs());\n    }\n}\n\n/**\n * (Modified) BRISK pattern for 60 points:\n * 5 layers with k_l colliding circles,\n * each at a distance l_l from the origin\n * with radius r_l. For each layer l=0..4,\n * we have k_l = [1,10,14,15,20] circles\n *\n * @param {number} [scale] pattern scale\n *                 (e.g, 1, 0.5, 0.25...)\n * @returns {Array<object>}\n */\nfunction briskPattern(scale = 1.0)\n{\n    const piOverTwo = Math.PI / 2.0;\n    const baseDistance = 4.21; // innermost layer for scale = 1\n\n    const s10 = Math.sin(piOverTwo / 10);\n    const s14 = Math.sin(piOverTwo / 14);\n    const s15 = Math.sin(piOverTwo / 15);\n    const s20 = Math.sin(piOverTwo / 20);\n\n    const l10 = baseDistance * scale;\n    const r10 = 2 * l10 * s10;\n\n    const r14 = (2 * (l10 + r10) * s14) / (1 - 2 * s14);\n    const l14 = l10 + r10 + r14;\n\n    const r15 = (2 * (l14 + r14) * s15) / (1 - 2 * s15);\n    const l15 = l14 + r14 + r15;\n\n    const r20 = (2 * (l15 + r15) * s20) / (1 - 2 * s20);\n    const l20 = l15 + r15 + r20;\n\n    const r1 = r10 * 0.8; // guess & plot!\n    const l1 = 0.0;\n\n    return [\n        { n: 1, r: r1, l: l1 },\n        { n: 10, r: r10, l: l10 },\n        { n: 14, r: r14, l: l14 },\n        { n: 15, r: r15, l: l15 },\n        { n: 20, r: r20, l: l20 },\n    ];\n}\n\n/**\n * BRISK points given a\n * {n, r, l} BRISK layer\n * @param {object} layer\n * @returns {Array<object>}\n */\nfunction briskPoints(layer)\n{\n    const { n, r, l } = layer;\n    const twoPi = 2.0 * Math.PI;\n\n    return [...Array(n).keys()].map(j => ({\n        x: l * Math.cos(twoPi * j / n),\n        y: l * Math.sin(twoPi * j / n),\n        r, l, j, n,\n    }));\n}\n\n/**\n * BRISK pair of points such that\n * the distance of each is greater\n * than (threshold*scale), or less\n * than (-threshold*scale) if\n * threshold < 0\n * @param {number} threshold\n * @param {number} [scale] pattern scale\n * @returns {Float32Array<number>} format [x1,y1,x2,y2, ...]\n */\nfunction briskPairs(threshold, scale = 1.0)\n{\n    const flatten = arr => arr.reduce((v, e) => v.concat(e), []);\n    const p = flatten(briskPattern(scale).map(briskPoints));\n    const n = p.length, t = +threshold * scale;\n\n    const dist2 = (p, q) => (p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y);\n    const wanted = (t < 0) ? ((p,q) => dist2(p,q) < t*t) : ((p,q) => dist2(p,q) > t*t);\n    const pairs = [];\n\n    for(let i = 1; i < n; i++) {\n        for(let j = 0; j < i; j++) {\n            if(wanted(p[i], p[j])) {\n                pairs.push(p[i].x);\n                pairs.push(p[i].y);\n                pairs.push(p[j].x);\n                pairs.push(p[j].y);\n            }\n        }\n    }\n\n    return new Float32Array(pairs);\n}\n\n/**\n * BRISK short distance pairs\n * @param {number} threshold pick pairs with distance < threshold*scale\n * @param {number} [scale] pattern scale\n * @returns {Float32Array<number>} format [x1,y1,x2,y2, ...]\n */\nfunction briskShortDistancePairs(threshold = 9.75, scale = 1.0)\n{\n    return briskPairs(-threshold, scale);\n}\n\n/**\n * BRISK long distance pairs\n * @param {number} threshold pick pairs with distance > threshold*scale\n * @param {number} [scale] pattern scale\n * @returns {Float32Array<number>} format [x1,y1,x2,y2, ...]\n */\nfunction briskLongDistancePairs(threshold = 13.67, scale = 1.0)\n{\n    return briskPairs(threshold, scale);\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * fast.js\n * FAST corner detector\n */\n\nimport { SpeedyGPU } from '../../../gpu/speedy-gpu';\nimport { FeaturesAlgorithm } from '../features-algorithm';\nimport { NotSupportedError, IllegalArgumentError } from '../../../utils/errors';\nimport { PYRAMID_MAX_LEVELS } from '../../../utils/globals';\n\n// constants\nconst DEFAULT_N = 9; // use FAST-9,16 by default\nconst DEFAULT_THRESHOLD = 10; // default FAST threshold\nconst DEFAULT_DEPTH = 3; // for multiscale: will check 3 pyramid levels (LODs: 0, 0.5, 1, 1.5, 2)\nconst MIN_DEPTH = 1; // minimum depth level\nconst MAX_DEPTH = PYRAMID_MAX_LEVELS; // maximum depth level\nconst DEFAULT_ORIENTATION_PATCH_RADIUS = 7; // for computing keypoint orientation\n\n/**\n * FAST corner detector\n */\nexport class FASTFeatures extends FeaturesAlgorithm\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu \n     */\n    constructor(gpu)\n    {\n        super(gpu);\n\n        // default settings\n        this._n = DEFAULT_N;\n        this._threshold = DEFAULT_THRESHOLD;\n    }   \n\n    /**\n     * The current type of FAST (9, 7 or 5)\n     * @returns {number}\n     */\n    get n()\n    {\n        return this._n;\n    }\n\n    /**\n     * Set the type of the algorithm\n     * @param {number} n 9 for FAST-9,16; 7 for FAST-7,12; 5 for FAST-5,8\n     */\n    set n(n)\n    {\n        if(!(n == 9 || n == 7 || n == 5))\n            throw new NotSupportedError(`Can't run FAST with n = ${n}`);\n\n        this._n = n | 0;\n    }\n\n    /**\n     * Get FAST threshold\n     * @returns {number} a value in [0,255]\n     */\n    get threshold()\n    {\n        return this._threshold;\n    }\n\n    /**\n     * Set FAST threshold\n     * @param {number} threshold a value in [0,255]\n     */\n    set threshold(threshold)\n    {\n        this._threshold = Math.max(0, Math.min(threshold | 0, 255));\n    }\n\n    /**\n     * Convert a normalized sensitivity to a FAST threshold\n     * @param {number} sensitivity \n     */\n    _onSensitivityChange(sensitivity)\n    {\n        this.threshold = Math.round(255.0 * (1.0 - Math.tanh(2.77 * sensitivity)));\n    }\n\n    /**\n     * FAST has no keypoint descriptor\n     */\n    get descriptorSize()\n    {\n        return 0;\n    }\n\n    /**\n     * Detect feature points\n     * @param {WebGLTexture} inputTexture pre-processed greyscale image\n     * @returns {WebGLTexture} encoded keypoints\n     */\n    detect(inputTexture)\n    {\n        const n = this._n;\n        const gpu = this._gpu;\n        const normalizedThreshold = this._threshold / 255.0;\n        const descriptorSize = this.descriptorSize;\n\n        // find corners\n        let corners = null;\n        if(n == 9)\n            corners = gpu.programs.keypoints.fast9(inputTexture, normalizedThreshold);\n        else if(n == 7)\n            corners = gpu.programs.keypoints.fast7(inputTexture, normalizedThreshold);\n        else if(n == 5)\n            corners = gpu.programs.keypoints.fast5(inputTexture, normalizedThreshold);\n\n        // non-maximum suppression\n        corners = gpu.programs.keypoints.nonmaxSuppression(corners);\n\n        // encode corners\n        return gpu.programs.encoders.encodeKeypoints(corners, descriptorSize);\n    }\n}\n\n/**\n * FAST corner detector in an image pyramid\n */\nexport class MultiscaleFASTFeatures extends FASTFeatures\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu \n     */\n    constructor(gpu)\n    {\n        super(gpu);\n\n        // default settings\n        this._depth = DEFAULT_DEPTH;\n        this._useHarrisScore = false;\n    }\n\n    /**\n     * Get the depth of the algorithm: how many pyramid layers will be scanned\n     * @returns {number}\n     */\n    get depth()\n    {\n        return this._depth;\n    }\n\n    /**\n     * Set the depth of the algorithm: how many pyramid layers will be scanned\n     * @param {number} depth\n     */\n    set depth(depth)\n    {\n        if(depth < MIN_DEPTH || depth > MAX_DEPTH)\n            throw new IllegalArgumentError(`Invalid depth: ${depth}`);\n\n        this._depth = depth | 0;\n    }\n\n    /**\n     * Whether or not we're using an approximation of\n     * Harris corner responses for keypoint scores\n     * @returns {boolean}\n     */\n    get useHarrisScore()\n    {\n        return this._useHarrisScore;\n    }\n\n    /**\n     * Should we use an approximation of Harris corner\n     * responses for keypoint scores?\n     * @param {boolean} useHarris\n     */\n    set useHarrisScore(useHarris)\n    {\n        this._useHarrisScore = Boolean(useHarris);\n    }\n\n    /**\n     * Set the type of the Multiscale FAST\n     * @param {number} n must be 9\n     */\n    set n(n)\n    {\n        // only Multiscale FAST-9 is supported at the moment\n        if(n != 9)\n            throw new NotSupportedError();\n\n        this._n = n | 0;\n    }\n\n    /**\n     * Detect feature points\n     * @param {WebGLTexture} inputTexture pre-processed greyscale image\n     * @returns {WebGLTexture} encoded keypoints\n     */\n    detect(inputTexture)\n    {\n        const gpu = this._gpu;\n        const normalizedThreshold = this._threshold / 255.0;\n        const useHarrisScore = this._useHarrisScore;\n        const descriptorSize = this.descriptorSize;\n        const orientationPatchRadius = DEFAULT_ORIENTATION_PATCH_RADIUS;\n        const numberOfOctaves = 2 * this._depth - 1;\n\n        // generate pyramid\n        const pyramid = gpu.programs.utils.generatePyramid(inputTexture);\n\n        // find corners\n        let corners = null;\n        if(!useHarrisScore)\n            corners = gpu.programs.keypoints.multiscaleFast(pyramid, normalizedThreshold, numberOfOctaves);\n        else\n            corners = gpu.programs.keypoints.multiscaleFastWithHarris(pyramid, normalizedThreshold, numberOfOctaves);\n\n        // non-maximum suppression\n        corners = gpu.programs.keypoints.samescaleSuppression(corners);\n        corners = gpu.programs.keypoints.multiscaleSuppression(corners);\n\n        // encode & orient corners\n        const encodedKeypoints = gpu.programs.encoders.encodeKeypoints(corners, descriptorSize);\n        return gpu.programs.encoders.orientEncodedKeypoints(pyramid, orientationPatchRadius, encodedKeypoints, descriptorSize);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * harris.js\n * Harris corner detector\n */\n\nimport { SpeedyGPU } from '../../../gpu/speedy-gpu';\nimport { FeaturesAlgorithm } from '../features-algorithm';\nimport { PixelComponent } from '../../../utils/types';\nimport { IllegalArgumentError } from '../../../utils/errors';\nimport { PYRAMID_MAX_LEVELS } from '../../../utils/globals';\n\n// constants\nconst DEFAULT_QUALITY = 0.1; // in [0,1]: pick corners having score >= quality * max(score)\nconst DEFAULT_DEPTH = 3; // for multiscale: will check 3 pyramid levels (LODs: 0, 0.5, 1, 1.5, 2)\nconst MIN_DEPTH = 1; // minimum depth level\nconst MAX_DEPTH = PYRAMID_MAX_LEVELS; // maximum depth level\nconst DEFAULT_WINDOW_SIZE = 3; // compute Harris autocorrelation matrix within a 3x3 window\nconst MIN_WINDOW_SIZE = 0; // minimum window size when computing the autocorrelation matrix\nconst MAX_WINDOW_SIZE = 7; // maximum window size when computing the autocorrelation matrix\nconst DEFAULT_ORIENTATION_PATCH_RADIUS = 7; // for computing keypoint orientation\nconst SOBEL_OCTAVE_COUNT = 2 * PYRAMID_MAX_LEVELS - 1; // Sobel derivatives for each pyramid layer\n\n/**\n * Harris corner detector\n */\nexport class HarrisFeatures extends FeaturesAlgorithm\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu \n     */\n    constructor(gpu)\n    {\n        super(gpu);\n\n        // default settings\n        this._quality = DEFAULT_QUALITY;\n    }   \n\n    /**\n     * Get current quality level\n     * @returns {number} a value in [0,1]\n     */\n    get quality()\n    {\n        return this._quality;\n    }\n\n    /**\n     * Set quality level\n     * @param {number} quality a value in [0,1]\n     */\n    set quality(quality)\n    {\n        this._quality = Math.max(0, Math.min(quality, 1));\n    }\n\n    /**\n     * Convert a normalized sensitivity to a quality value\n     * @param {number} sensitivity \n     */\n    _onSensitivityChange(sensitivity)\n    {\n        this.quality = 1.0 - Math.tanh(2.3 * sensitivity);\n    }\n\n    /**\n     * Harris has no keypoint descriptor\n     */\n    get descriptorSize()\n    {\n        return 0;\n    }\n\n    /**\n     * Detect feature points\n     * @param {WebGLTexture} inputTexture pre-processed greyscale image\n     * @returns {WebGLTexture} encoded keypoints\n     */\n    detect(inputTexture)\n    {\n        const gpu = this._gpu;\n        const quality = this._quality;\n        const descriptorSize = this.descriptorSize;\n        const windowRadius = DEFAULT_WINDOW_SIZE >> 1;\n        const lod = 0, numberOfOctaves = 1;\n\n        // compute derivatives\n        const df = gpu.programs.keypoints.multiscaleSobel(inputTexture, lod);\n        const sobelDerivatives = Array(SOBEL_OCTAVE_COUNT).fill(df);\n\n        // corner detection\n        const corners = gpu.programs.keypoints.multiscaleHarris(inputTexture, windowRadius, numberOfOctaves, sobelDerivatives);\n\n        // release derivatives\n        gpu.programs.utils.release(df);\n\n        // find the maximum corner response\n        const maxScore = gpu.programs.utils.scanMax(corners, PixelComponent.RED);\n\n        // discard corners according to quality level\n        const filteredCorners = gpu.programs.keypoints.harrisCutoff(corners, maxScore, quality);\n\n        // non-maximum suppression\n        const suppressedCorners = gpu.programs.keypoints.nonmaxSuppression(filteredCorners);\n\n        // encode corners\n        return gpu.programs.encoders.encodeKeypoints(suppressedCorners, descriptorSize);\n    }\n}\n\n/**\n * Harris corner detector in an image pyramid\n */\nexport class MultiscaleHarrisFeatures extends HarrisFeatures\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu \n     */\n    constructor(gpu)\n    {\n        super(gpu);\n\n        // default settings\n        this._depth = DEFAULT_DEPTH;\n    }\n\n    /**\n     * Get the depth of the algorithm: how many pyramid layers will be scanned\n     * @returns {number}\n     */\n    get depth()\n    {\n        return this._depth;\n    }\n\n    /**\n     * Set the depth of the algorithm: how many pyramid layers will be scanned\n     * @param {number} depth a number between 1 and PYRAMID_MAX_LEVELS, inclusive\n     */\n    set depth(depth)\n    {\n        if(depth < MIN_DEPTH || depth > MAX_DEPTH)\n            throw new IllegalArgumentError(`Invalid depth: ${depth}`);\n\n        this._depth = depth | 0;\n    }\n\n    /**\n     * Detect feature points\n     * @param {WebGLTexture} inputTexture pre-processed greyscale image\n     * @returns {WebGLTexture} encoded keypoints\n     */\n    detect(inputTexture)\n    {\n        const gpu = this._gpu;\n        const quality = this._quality;\n        const descriptorSize = this.descriptorSize;\n        const orientationPatchRadius = DEFAULT_ORIENTATION_PATCH_RADIUS;\n        const windowRadius = DEFAULT_WINDOW_SIZE >> 1;\n        const numberOfOctaves = 2 * this._depth - 1;\n\n        // generate pyramid\n        const pyramid = gpu.programs.utils.generatePyramid(inputTexture);\n\n        // compute derivatives\n        const df = gpu.programs.keypoints.multiscaleSobel(pyramid, 0.0);\n        const sobelDerivatives = Array(SOBEL_OCTAVE_COUNT).fill(df);\n        for(let j = 1; j < numberOfOctaves; j++)\n            sobelDerivatives[j] = gpu.programs.keypoints.multiscaleSobel(pyramid, j * 0.5);\n\n        // corner detection\n        const corners = gpu.programs.keypoints.multiscaleHarris(pyramid, windowRadius, numberOfOctaves, sobelDerivatives);\n\n        // release derivatives\n        for(let i = 0; i < sobelDerivatives.length; i++)\n            sobelDerivatives[i] = gpu.programs.utils.release(sobelDerivatives[i]);\n\n        // find the maximum corner response\n        const maxScore = gpu.programs.utils.scanMax(corners, PixelComponent.RED);\n\n        // discard corners according to quality level\n        const filteredCorners = gpu.programs.keypoints.harrisCutoff(corners, maxScore, quality);\n\n        // non-maximum suppression\n        const suppressed1 = gpu.programs.keypoints.samescaleSuppression(filteredCorners);\n        const suppressed2 = gpu.programs.keypoints.multiscaleSuppression(suppressed1);\n\n        // encode & orient corners\n        const encodedKeypoints = gpu.programs.encoders.encodeKeypoints(suppressed2, descriptorSize);\n        return gpu.programs.encoders.orientEncodedKeypoints(pyramid, orientationPatchRadius, encodedKeypoints, descriptorSize);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * orb.js\n * ORB features\n */\n\nimport { SpeedyGPU } from '../../../gpu/speedy-gpu';\nimport { MultiscaleHarrisFeatures } from './harris';\n\n// constants\nconst DESCRIPTOR_SIZE = 32; // 256 bits\n\n/**\n * ORB features\n */\nexport class ORBFeatures extends MultiscaleHarrisFeatures\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu \n     */\n    constructor(gpu)\n    {\n        super(gpu);\n    }\n\n    /**\n     * Descriptor size for ORB\n     * @returns {number} in bytes\n     */\n    get descriptorSize()\n    {\n        return DESCRIPTOR_SIZE;\n    }\n\n    /**\n     * Detect feature points for ORB\n     * @param {WebGLTexture} inputTexture pre-processed greyscale image\n     * @returns {WebGLTexture} encoded keypoints\n     */\n    detect(inputTexture)\n    {\n        // Multiscale Harris gives us nice corners in scale-space\n        return super.detect(inputTexture);\n    }\n\n    /**\n     * Compute ORB feature descriptors\n     * @param {WebGLTexture} inputTexture pre-processed greyscale image\n     * @param {WebGLTexture} encodedKeypoints encoded, oriented and multi-scale\n     * @returns {WebGLTexture} encoded keypoints with descriptors\n     */\n    describe(inputTexture, encodedKeypoints)\n    {\n        const gpu = this._gpu;\n\n        // smooth the image before computing the descriptors\n        const smoothTexture = gpu.programs.filters.gauss7(inputTexture);\n        const smoothPyramid = gpu.programs.utils.generatePyramid(smoothTexture);\n\n        // compute ORB feature descriptors\n        const encoderLength = gpu.programs.encoders.encoderLength;\n        return gpu.programs.descriptors.orb(smoothPyramid, encodedKeypoints, encoderLength);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * automatic-sensitivity.js\n * Automatic sensitivity component\n */\n\nimport { Observable } from '../../utils/observable';\nimport { SpeedyFeature } from '../speedy-feature';\nimport { FeaturesDownloader } from './features-downloader';\nimport { SensitivityTuner } from '../tuners/sensitivity-tuner';\nimport { TestTuner } from '../tuners/test-tuner';\n\n// constants\nconst DEFAULT_TOLERANCE = 0.10; // 10% on the expected number of keypoints\n\n/**\n * This component adds automatic sensitivity\n * support to a feature detector.\n * \n * Give it an expected number of keypoints &\n * an optional tolerance margin. It will\n * predict a value in [0,1] called sensitivity\n * that gives you, approximately, the number\n * of keypoints you have asked for.\n * \n * The feature detector must support reading\n * sensitivity values for this to work - i.e.,\n * translating sensitivity to some sort of\n * detector-specific threshold. It's ideal if\n * the number of keypoints and the sensitivity\n * value are (roughly) proportional.\n */\nexport class AutomaticSensitivity extends Observable\n{\n    /**\n     * Class constructor\n     * @param {FeaturesDownloader} downloader\n     */\n    constructor(downloader)\n    {\n        super();\n        this._sensitivity = 0;\n        this._expected = 0;\n        this._tolerance = DEFAULT_TOLERANCE;\n        this._tuner = null;\n        this._downloader = downloader;\n        this._onDownloadKeypoints = this._onDownloadKeypoints.bind(this); // subscriber\n\n        // enable the AI\n        this.enable();\n    }\n\n    /**\n     * Get the current predicted sensitivity value\n     * @returns {number} a value in [0,1]\n     */\n    get sensitivity()\n    {\n        return this._sensitivity;\n    }\n\n    /**\n     * Get the expected number of keypoints\n     * @returns {number}\n     */\n    get expected()\n    {\n        return this._expected;\n    }\n\n    /**\n     * Set the expected number of keypoints\n     * @param {number} numberOfKeypoints\n     */\n    set expected(numberOfKeypoints)\n    {\n        this._expected = Math.max(0, numberOfKeypoints | 0);\n    }\n\n    /**\n     * Get the acceptable relative error tolerance used when finding\n     * a sensitivity value for an expected number of keypoints\n     * @returns {number}\n     */\n    get tolerance()\n    {\n        return this._tolerance;\n    }\n\n    /**\n     * Set the acceptable relative error tolerance used when finding\n     * a sensitivity value for an expected number of keypoints\n     * @param {number} percentage a value such as 0.10 (10%)\n     */\n    set tolerance(percentage)\n    {\n        this._tolerance = Math.max(0, +percentage);\n    }\n\n    /**\n     * Enable Automatic Sensitivity\n     */\n    enable()\n    {\n        this._downloader.subscribe(this._onDownloadKeypoints);\n    }\n\n    /**\n     * Disable Automatic Sensitivity\n     */\n    disable()\n    {\n        this._downloader.unsubscribe(this._onDownloadKeypoints);\n    }\n\n    /**\n     * Called whenever the feature detector finds new keypoints\n     * This routine updates the sensitivity value\n     * @param {SpeedyFeature[]} keypoints \n     */\n    _onDownloadKeypoints(keypoints)\n    {\n        const normalizer = 0.001; // convert from discrete state space\n\n        // tuner: lazy spawn\n        if(this._tuner == null) {\n            //this._tuner = new TestTuner(0, 1000); // debug\n            this._tuner = new SensitivityTuner(0, 1200); // use a slightly wider interval for better stability\n        }\n\n        // compute prediction\n        this._tuner.tolerance = this._tolerance;\n        this._tuner.feedObservation(keypoints.length, this._expected);\n        const prediction = this._tuner.currentValue();\n\n        // update sensitivity\n        this._sensitivity = Math.max(0, Math.min(prediction * normalizer, 1));\n\n        // debug\n        //console.log(JSON.stringify(this._tuner.info()));\n\n        // notify observers\n        this._notify(this._sensitivity);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * feature-algorithm.js\n * Feature detection & description: abstract class\n */\n\nimport { AbstractMethodError, IllegalArgumentError } from '../../utils/errors';\nimport { AutomaticSensitivity } from './automatic-sensitivity';\nimport { FeaturesDownloader } from './features-downloader';\nimport { SpeedyFeature } from '../speedy-feature';\nimport { SpeedyGPU } from '../../gpu/speedy-gpu';\n\n/**\n * An abstract class for feature\n * detection & description\n */\nexport /* abstract */ class FeaturesAlgorithm\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     */\n    constructor(gpu)\n    {\n        this._gpu = gpu;\n        this._downloader = new FeaturesDownloader(this._gpu, this.descriptorSize);\n        this._sensitivity = 0;\n        this._automaticSensitivity = null;\n    }\n\n    /**\n     * The size in bytes of the feature descriptor\n     * This method may be overridden in subclasses\n     * \n     * It must return 0 if the algorithm has no\n     * descriptor attached to it\n     * \n     * @returns {number} descriptor size in bytes\n     */\n    get descriptorSize()\n    {\n        // This must be implemented in subclasses\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Convert a normalized sensitivity into an\n     * algorithm-specific value such as a threshold\n     * \n     * Sensitivity is a generic parameter that can be\n     * mapped to different feature detectors. The\n     * higher the sensitivity, the more features\n     * you should get\n     * @param {number} sensitivity a value in [0,1]\n     */\n    _onSensitivityChange(sensitivity)\n    {\n        // This must be implemented in subclasses\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Detect feature points\n     * @param {WebGLTexture} inputTexture pre-processed greyscale image\n     * @returns {WebGLTexture} encoded keypoints\n     */\n    detect(inputTexture)\n    {\n        // This must be implemented in subclasses\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Describe feature points\n     * @param {WebGLTexture} inputTexture pre-processed greyscale image\n     * @param {WebGLTexture} encodedKeypoints tiny texture with appropriate size for the descriptors\n     * @returns {WebGLTexture} encoded keypoints with descriptors\n     */\n    describe(inputTexture, encodedKeypoints)\n    {\n        // No descriptor is computed by default\n        return encodedKeypoints;\n    }\n\n    /**\n     * Detect feature points and compute their descriptors\n     * @param {WebGLTexture} inputTexture pre-processed greyscale image\n     * @returns {WebGLTexture} encoded keypoints with descriptors\n     */\n    detectAndDescribe(inputTexture)\n    {\n        return this.describe(inputTexture, this.detect(inputTexture));\n    }\n\n    /**\n     * Download feature points from the GPU\n     * @param {WebGLTexture} encodedKeypoints tiny texture with encoded keypoints\n     * @param {boolean} [useAsyncTransfer] use DMA\n     * @param {number} [max] cap the number of keypoints to this value\n     * @returns {Promise<SpeedyFeature[]>}\n     */\n    download(encodedKeypoints, useAsyncTransfer = true, max = -1)\n    {\n        return this._downloader.download(encodedKeypoints, useAsyncTransfer, max);\n    }\n\n    /**\n     * Preprocess a texture for feature detection\n     * @param {WebGLTexture} inputTexture a RGB or greyscale image\n     * @param {boolean} [denoise] should we smooth the media a bit?\n     * @param {boolean} [convertToGreyscale] set to true if the texture is not greyscale\n     * @returns {WebGLTexture} pre-processed greyscale image\n     */\n    preprocess(inputTexture, denoise = true, convertToGreyscale = true)\n    {\n        const gpu = this._gpu;\n        let texture = inputTexture;\n\n        if(denoise)\n            texture = gpu.programs.filters.gauss5(texture);\n\n        if(convertToGreyscale)\n            texture = gpu.programs.colors.rgb2grey(texture);\n            \n        return texture;\n    }\n\n    /**\n     * Get the current detector sensitivity\n     * @returns {number} a value in [0,1]\n     */\n    get sensitivity()\n    {\n        return this._sensitivity;\n    }\n\n    /**\n     * Set the sensitivity of the feature detector\n     * The higher the sensitivity, the more features you get\n     * @param {number} sensitivity a value in [0,1]\n     */\n    set sensitivity(sensitivity)\n    {\n        this._sensitivity = Math.max(0, Math.min(+sensitivity, 1));\n        this._onSensitivityChange(this._sensitivity);\n    }\n\n    /**\n     * Automatic sensitivity: expected number of keypoints\n     * @returns {object|undefined}\n     */\n    get expected()\n    {\n        if(this._automaticSensitivity == null) {\n            return {\n                number: this._automaticSensitivity.expected,\n                tolerance: this._automaticSensitivity.tolerance\n            };\n        }\n        else\n            return undefined;\n    }\n\n    /**\n     * Setup automatic sensitivity\n     * @param {number|object|undefined} expected\n     */\n    set expected(expected)\n    {\n        if(expected !== undefined) {\n            // enable automatic sensitivity\n            if(this._automaticSensitivity == null) {\n                this._automaticSensitivity = new AutomaticSensitivity(this._downloader);\n                this._automaticSensitivity.subscribe(value => this.sensitivity = value);\n            }\n\n            // set parameters\n            if(typeof expected === 'object') {\n                if(expected.hasOwnProperty('number'))\n                    this._automaticSensitivity.expected = +(expected.number);\n                if(expected.hasOwnProperty('tolerance'))\n                    this._automaticSensitivity.tolerance = +(expected.tolerance);\n            }\n            else\n                this._automaticSensitivity.expected = +expected;\n        }\n        else {\n            // disable automatic sensitivity\n            if(this._automaticSensitivity != null)\n                this._automaticSensitivity.disable();\n            this._automaticSensitivity = null;\n        }\n    }\n\n    /**\n     * Get SpeedyGPU instance\n     * @returns {SpeedyGPU}\n     */\n    get gpu()\n    {\n        return this._gpu;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * feature-downloader.js\n * Download features from the GPU\n */\n\nimport { IllegalOperationError } from '../../utils/errors';\nimport { Observable } from '../../utils/observable';\nimport { SpeedyFeature } from '../speedy-feature';\nimport { SpeedyGPU } from '../../gpu/speedy-gpu';\n\n// constants\nconst OPTIMIZER_GROWTH_WEIGHT_ASYNC = 0.02; // used when using async downloads\nconst OPTIMIZER_GROWTH_WEIGHT_SYNC = 2.0; // used when using sync downloads\n\n/**\n * The FeaturesDownloader receives a texture of encoded\n * keypoints and returns a corresponding array of keypoints\n */\nexport class FeaturesDownloader extends Observable\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu \n     * @param {number} descriptorSize in bytes (set to zero if there is not descriptor)\n     */\n    constructor(gpu, descriptorSize = 0)\n    {\n        super();\n        this._gpu = gpu;\n        this._descriptorSize = Math.max(0, descriptorSize | 0);\n        this._rawKeypointCount = 0;\n        this._filteredKeypointCount = 0;\n    }\n\n    /**\n     * Download feature points from the GPU\n     * @param {WebGLTexture} encodedKeypoints tiny texture with encoded keypoints\n     * @param {boolean} [useAsyncTransfer] use DMA\n     * @param {number} [max] cap the number of keypoints to this value\n     * @returns {Promise<SpeedyFeature[]>}\n     */\n    download(encodedKeypoints, useAsyncTransfer = true, max = -1)\n    {\n        const gpu = this._gpu;\n\n        return gpu.programs.encoders.downloadEncodedKeypoints(encodedKeypoints, useAsyncTransfer).then(data => {\n            // when processing a video, we expect that the number of keypoints\n            // in time is a relatively smooth curve\n            const keypoints = gpu.programs.encoders.decodeKeypoints(data, this._descriptorSize);\n            const currCount = Math.max(keypoints.length, 64); // may explode with abrupt video changes\n            const prevCount = Math.max(this._filteredKeypointCount, 64);\n            const weight = useAsyncTransfer ? OPTIMIZER_GROWTH_WEIGHT_ASYNC : OPTIMIZER_GROWTH_WEIGHT_SYNC;\n            const newCount = Math.ceil(weight * currCount + (1.0 - weight) * prevCount);\n\n            this._filteredKeypointCount = newCount;\n            this._rawKeypointCount = keypoints.length;\n            gpu.programs.encoders.optimizeKeypointEncoder(newCount, this._descriptorSize);\n            //document.querySelector('mark').innerHTML = gpu.programs.encoders._keypointEncoderLength;\n\n            // sort the data according to cornerness score\n            keypoints.sort(this._compareKeypoints);\n\n            // cap the number of keypoints if requested to do so\n            max = Number(max);\n            if(Number.isFinite(max) && max >= 0)\n                keypoints.splice(max, keypoints.length - max);\n\n            // let's cap it if keypoints.length explodes (noise)\n            if(useAsyncTransfer && newCount < keypoints.length)\n                keypoints.splice(newCount, keypoints.length - newCount);\n\n            // notify observers\n            this._notify(keypoints);\n\n            // done!\n            return keypoints;\n        }).catch(err => {\n            throw new IllegalOperationError(`Can't download keypoints`, err);\n        });\n    }\n\n    /**\n     * Compare two keypoints (higher scores come first)\n     * @param {SpeedyFeature} a \n     * @param {SpeedyFeature} b \n     * @returns {number}\n     */\n    _compareKeypoints(a, b)\n    {\n        return (+(b.score)) - (+(a.score));\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * pipeline-operations.js\n * A pipeline operation is an element of a SpeedyPipeline\n */\n\nimport { ColorFormat } from '../utils/types';\nimport { Utils } from '../utils/utils';\nimport { GLUtils } from '../gpu/gl-utils';\nimport { NotSupportedError, IllegalArgumentError } from '../utils/errors';\n\nexport const PipelineOperation = { };\n\n/**\n * Abstract basic operation\n */\n/* abstract */ class SpeedyPipelineOperation\n{\n    /**\n     * Runs the pipeline operation\n     * @param {Texture} texture\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyMedia} [media]\n     * @returns {Texture}\n     */\n    run(texture, gpu, media)\n    {\n        return texture;\n    }\n\n    /**\n     * Perform any necessary cleanup\n     */\n    release()\n    {\n    }\n}\n\n\n// =====================================================\n//               COLOR CONVERSIONS\n// =====================================================\n\n/**\n * Convert to greyscale\n */\nPipelineOperation.ConvertToGreyscale = class extends SpeedyPipelineOperation\n{\n    run(texture, gpu, media)\n    {\n        if(media._colorFormat == ColorFormat.RGB)\n            texture = gpu.programs.colors.rgb2grey(texture);\n        else if(media._colorFormat != ColorFormat.Greyscale)\n            throw new NotSupportedError(`Can't convert image to greyscale: unknown color format`);\n\n        media._colorFormat = ColorFormat.Greyscale;\n        return texture;\n    }\n}\n\n\n\n// =====================================================\n//               IMAGE FILTERS\n// =====================================================\n\n/**\n * Blur image\n */\nPipelineOperation.Blur = class extends SpeedyPipelineOperation\n{\n    /**\n     * Blur operation\n     * @param {object} [options]\n     */\n    constructor(options = {})\n    {\n        const { filter, size } = (options = {\n            filter: 'gaussian',     // \"gassuian\" | \"box\"\n            size: 5,                // 3 | 5 | 7\n            ...options\n        });\n        super();\n\n        // validate kernel size\n        if(size != 3 && size != 5 && size != 7)\n            throw new IllegalArgumentError(`Invalid kernel size: ${size}`);\n\n        // select the appropriate filter\n        if(filter == 'gaussian')\n            this._filter = 'gauss' + size;\n        else if(filter == 'box')\n            this._filter = 'box' + size;\n        else\n            throw new IllegalArgumentError(`Invalid filter: \"${filter}\"`);\n    }\n\n    run(texture, gpu, media)\n    {\n        return gpu.programs.filters[this._filter](texture);\n    }\n}\n\n/**\n * Image convolution\n */\nPipelineOperation.Convolve = class extends SpeedyPipelineOperation\n{\n    /**\n     * Perform a convolution\n     * Must provide a SQUARE kernel with size: 3x3, 5x5 or 7x7\n     * @param {Array<number>} kernel convolution kernel\n     * @param {number} [divisor] divide all kernel entries by this number\n     */\n    constructor(kernel, divisor = 1.0)\n    {\n        let kern = new Float32Array(kernel).map(x => x / divisor);\n        const len = kern.length;\n        const size = Math.sqrt(len) | 0;\n        const method = ({\n            3: ['createKernel3x3', 'texConv2D3'],\n            5: ['createKernel5x5', 'texConv2D5'],\n            7: ['createKernel7x7', 'texConv2D7'],\n        })[size] || null;\n        super();\n\n        // validate kernel\n        if(len == 1)\n            throw new IllegalArgumentError(`Cannot convolve with a kernel containing a single element`);\n        else if(size * size != len || !method)\n            throw new IllegalArgumentError(`Cannot convolve with a non-square kernel of ${len} elements`);\n\n        // normalize kernel entries to [0,1]\n        const min = Math.min(...kern), max = Math.max(...kern);\n        const offset = min;\n        const scale = Math.abs(max - min) > 1e-5 ? max - min : 1;\n        kern = kern.map(x => (x - offset) / scale);\n\n        // store the normalized kernel\n        this._method = method;\n        this._scale = scale;\n        this._offset = offset;\n        this._kernel = kern;\n        this._kernelSize = size;\n        this._texKernel = null;\n        this._gl = null;\n    }\n\n    run(texture, gpu, media)\n    {\n        // lost context?\n        if(gpu.gl.isContextLost()) {\n            this._texKernel = null;\n            this._gl = null;\n            // convolve with a null texKernel anyway,\n            // SpeedyProgram handles lost contexts\n        }\n\n        // instantiate the texture kernel\n        else if(this._texKernel == null || (this._gl !== gpu.gl && this._gl !== null)) {\n            // warn about performance\n            if(this._gl !== gpu.gl && this._gl !== null && !this._gl.isContextLost()) {\n                const warn = 'Performance warning: need to recreate the texture kernel. ' +\n                             'Consider duplicating the pipeline when using convolutions ' +\n                             'for different media objects.';\n                Utils.warning(warn);\n\n                // release old texture\n                GLUtils.destroyTexture(this._gl, this._texKernel);\n            }\n\n            this._texKernel = gpu.programs.filters[this._method[0]](this._kernel);\n            this._gl = gpu.gl;\n        }\n\n        // convolve\n        return gpu.programs.filters[this._method[1]](\n            texture,\n            this._texKernel,\n            this._scale,\n            this._offset\n        );\n    }\n\n    release()\n    {\n        if(this._texKernel != null) {\n            GLUtils.destroyTexture(this._gl, this._texKernel);\n            this._texKernel = this._gl = null;\n        }\n        super.release();\n    }\n}\n\n/**\n * Normalize image\n */\nPipelineOperation.Normalize = class extends SpeedyPipelineOperation\n{\n    /**\n     * Normalize operation\n     * @param {object} [options]\n     */\n    constructor(options = {})\n    {\n        const { min, max } = (options = {\n            min: 0,     // min. desired pixel intensity: a value in [0,255]\n            max: 255,   // max. desired pixel intensity: a value in [0,255]\n            ...options\n        });\n        super();\n\n        // save data\n        this._min = Math.max(0, Math.min(Math.min(min, max), 255));\n        this._max = Math.max(0, Math.min(Math.max(min, max), 255));\n    }\n\n    run(texture, gpu, media)\n    {\n        if(media._colorFormat == ColorFormat.RGB)\n            return gpu.programs.utils.normalizeColoredImage(texture, this._min, this._max);\n        else\n            return gpu.programs.utils.normalizeGreyscaleImage(texture, this._min, this._max);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-descriptor.js\n * Feature descriptor\n */\n\nimport { AbstractMethodError } from '../utils/errors';\n\n/**\n * Abstract feature descriptor\n */\nclass SpeedyDescriptor\n{\n    /**\n     * Abstract constructor\n     */\n    constructor()\n    {\n        /*if(this.constructor === SpeedyDescriptor)\n            throw new AbstractMethodError();*/\n    }\n    \n    /**\n     * Descriptor data\n     * @returns {null}\n     */\n    get data()\n    {\n        return null;\n    }\n}\n\n/**\n * Null feature descriptor\n */\nexport class NullDescriptor extends SpeedyDescriptor\n{\n    /**\n     * Class constructor\n     */\n    constructor()\n    {\n        super();\n    }\n\n    /**\n     * Descriptor data\n     * @returns {null}\n     */\n    get data()\n    {\n        return null;\n    }\n}\n\n/**\n * Binary feature descriptor\n */\nexport class BinaryDescriptor extends SpeedyDescriptor\n{\n    /**\n     * Class constructor\n     * @param {Uint8Array} bytes descriptor data\n     */\n    constructor(bytes)\n    {\n        super();\n        this._data = bytes;\n    }\n\n    /**\n     * Descriptor data\n     * @returns {Uint8Array}\n     */\n    get data()\n    {\n        return this._data;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-feature.js\n * Feature Point class\n */\n\nimport { NullDescriptor } from './speedy-descriptor';\n\n/**\n * A SpeedyFeature is a keypoint in an image,\n * with optional scale, rotation and descriptor\n */\nexport class SpeedyFeature\n{\n    /**\n     * Creates a new SpeedyFeature\n     * @param {number} x X position\n     * @param {number} y Y position\n     * @param {number} [scale] Scale\n     * @param {number} [rotation] Rotation in radians\n     * @param {number} [score] Cornerness measure\n     * @param {SpeedyDescriptor} [descriptor] Feature descriptor\n     */\n    constructor(x, y, scale = 1.0, rotation = 0.0, score = 0.0, descriptor = null)\n    {\n        this._x = +x;\n        this._y = +y;\n        this._scale = +scale;\n        this._rotation = +rotation;\n        this._score = +score;\n        this._descriptor = descriptor === null ? new NullDescriptor() : descriptor;\n    }\n\n    /**\n     * Converts a SpeedyFeature to a representative string\n     * @returns {string}\n     */\n    toString()\n    {\n        return `(${this._x},${this._y})`;\n    }\n\n    /**\n     * The X position of the feature point\n     * @returns {number} X position\n     */\n    get x()\n    {\n        return this._x;\n    }\n\n    /**\n     * The y position of the feature point\n     * @returns {number} Y position\n     */\n    get y()\n    {\n        return this._y;\n    }\n\n    /**\n     * The scale of the feature point\n     * @returns {number} Scale\n     */\n    get scale()\n    {\n        return this._scale;\n    }\n\n    /**\n     * The rotation of the feature point, in radians\n     * @returns {number} Angle in radians\n     */\n    get rotation()\n    {\n        return this._rotation;\n    }\n\n    /**\n     * Score: a cornerness measure\n     * @returns {number} Score\n     */\n    get score()\n    {\n        return this._score;\n    }\n\n    /**\n     * The descriptor of the feature point\n     * @return {SpeedyDescriptor} feature descriptor\n     */\n    get descriptor()\n    {\n        return this._descriptor;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-media.js\n * SpeedyMedia implementation\n */\n\nimport { SpeedyGPU } from '../gpu/speedy-gpu';\nimport { MediaType, ColorFormat } from '../utils/types'\nimport { Utils } from '../utils/utils';\nimport { TimeoutError, IllegalArgumentError, NotSupportedError, AccessDeniedError } from '../utils/errors';\nimport { FASTFeatures, MultiscaleFASTFeatures } from './features/algorithms/fast';\nimport { HarrisFeatures, MultiscaleHarrisFeatures } from './features/algorithms/harris';\nimport { ORBFeatures } from './features/algorithms/orb';\nimport { BRISKFeatures } from './features/algorithms/brisk';\n\n// map: method string -> feature detector & descriptor class\nconst featuresAlgorithm = {\n    'fast': FASTFeatures,\n    'multiscale-fast': MultiscaleFASTFeatures,\n    'harris': HarrisFeatures,\n    'multiscale-harris': MultiscaleHarrisFeatures,\n    'orb': ORBFeatures,\n    'brisk': BRISKFeatures,\n};\n\n/**\n * SpeedyMedia encapsulates a media element\n * (e.g., image, video, canvas)\n */\nexport class SpeedyMedia\n{\n    /**\n     * Class constructor\n     * It assumes A VALID (!) media source that is already loaded\n     * @param {HTMLImageElement|HTMLVideoElement|HTMLCanvasElement|Texture} mediaSource An image, video or canvas\n     * @param {number} width media width\n     * @param {number} height media height\n     * @param {object} [options] options object\n     */\n    /* private */ constructor(mediaSource, width, height, options = { })\n    {\n        if(arguments.length > 1) {\n            // store data\n            this._source = mediaSource;\n            this._width = width | 0;\n            this._height = height | 0;\n            this._type = getMediaType(this._source);\n            this._colorFormat = ColorFormat.RGB;\n\n            // set options\n            this._options = buildOptions(options, {\n                usage: (this._type != MediaType.Image) ? 'dynamic' : 'static',\n            });\n\n            // spawn relevant components\n            this._gpu = new SpeedyGPU(this._width, this._height);\n            this._featuresAlgorithm = null; // lazy instantiation\n        }\n        else if(arguments.length == 1) {\n            // copy constructor (shallow copy)\n            const media = arguments[0];\n\n            this._source = media._source;\n            this._width = media._width;\n            this._height = media._height;\n            this._type = media._type;\n            this._colorFormat = media._colorFormat;\n\n            this._gpu = media._gpu;\n            this._featuresAlgorithm = media._featuresAlgorithm;\n        }\n        else\n            throw new IllegalArgumentError(`Invalid instantiation of SpeedyMedia`);\n    }\n\n    /**\n     * Load a media source\n     * Will wait until the HTML media source is loaded\n     * @param {HTMLImageElement|HTMLVideoElement|HTMLCanvasElement} mediaSource An image, video or canvas\n     * @param {object} [options] options object\n     * @returns {Promise<SpeedyMedia>}\n     */\n    static load(mediaSource, options = { })\n    {\n        return new Promise((resolve, reject) => {\n            const dimensions = getMediaDimensions(mediaSource);\n            if(dimensions != null) {\n                // try to load the media until it's ready\n                (function loadMedia(dimensions, k = 500) {\n                    if(dimensions.width > 0 && dimensions.height > 0) {\n                        const media = new SpeedyMedia(mediaSource, dimensions.width, dimensions.height, options);\n                        Utils.log(`Loaded SpeedyMedia with a ${mediaSource}.`);\n                        resolve(media);\n                    }\n                    else if(k > 0)\n                        setTimeout(() => loadMedia(getMediaDimensions(mediaSource), k-1), 10);\n                    else\n                        reject(new TimeoutError(`Can't load SpeedyMedia with a ${mediaSource}: timeout.`));\n                })(dimensions);\n            }\n            else {\n                // invalid media source\n                reject(new IllegalArgumentError(`Can't load SpeedyMedia with a ${mediaSource}: invalid media source.`));\n            }\n        });\n    }\n\n    /**\n     * Loads a camera stream\n     * @param {number} [width] width of the stream\n     * @param {number} [height] height of the stream\n     * @param {object} [cameraOptions] additional options to pass to getUserMedia()\n     * @param {object} [mediaOptions] additional options for advanced configuration of the SpeedyMedia\n     * @returns {Promise<SpeedyMedia>}\n     */\n    static loadCameraStream(width = 426, height = 240, cameraOptions = {}, mediaOptions = {})\n    {\n        return requestCameraStream(width, height, cameraOptions).then(\n            video => SpeedyMedia.load(createCanvasFromVideo(video), mediaOptions)\n        );\n    }\n\n    /**\n     * The media element (image, video, canvas) encapsulated by this SpeedyMedia object\n     * @returns {HTMLImageElement|HTMLVideoElement|HTMLCanvasElement} the media element\n     */\n    get source()\n    {\n        return this._source;\n    }\n\n    /**\n     * Gets the width of the media\n     * @returns {number} media width\n     */\n    get width()\n    {\n        return this._width;\n    }\n\n    /**\n     * Gets the height of the media\n     * @returns {number} media height\n     */\n    get height()\n    {\n        return this._height;\n    }\n\n    /**\n     * The type of the media attached to this SpeedyMedia object\n     * @returns {string} \"image\" | \"video\" | \"canvas\" | \"internal\"\n     */\n    get type()\n    {\n        switch(this._type) {\n            case MediaType.Image:\n                return 'image';\n\n            case MediaType.Video:\n                return 'video';\n\n            case MediaType.Canvas:\n                return 'canvas';\n\n            case MediaType.Texture: // the result of pipelining\n                return 'internal';\n\n            default: // this shouldn't happen\n                return 'unknown';\n        }\n    }\n\n    /**\n     * Returns a read-only object featuring advanced options\n     * related to this SpeedyMedia object\n     * @returns {object}\n     */\n    get options()\n    {\n        return this._options;\n    }\n\n    /**\n     * Releases resources associated with this media.\n     * You will no longer be able to use it, nor any of its lightweight clones.\n     * @returns {Promise} resolves as soon as the resources are released\n     */\n    release()\n    {\n        if(!this.isReleased()) {\n            this._featuresAlgorithm = null;\n            this._gpu.loseWebGLContext();\n            this._gpu = null;\n            this._source = null;\n        }\n\n        return Promise.resolve();\n    }\n\n    /**\n     * Is this SpeedyMedia released?\n     * @returns {bool}\n     */\n    isReleased()\n    {\n        return this._gpu == null;\n    }\n\n    /**\n     * Clones the SpeedyMedia object\n     * @param {object} options options object\n     * @returns {SpeedyMedia} a clone object\n     */\n    clone(options = {})\n    {\n        // Default settings\n        options = {\n            lightweight: false,\n            ...(options)\n        };\n\n        // has the media been released?\n        if(this.isReleased())\n            throw new IllegalOperationError('Can\\'t clone a SpeedyMedia that has been released');\n\n        // clone the object\n        if(options.lightweight) {\n            // shallow copy\n            return new SpeedyMedia(this);\n        }\n        else {\n            // deep copy\n            let source = this._source;\n            if(this._type == MediaType.Texture || this._type == MediaType.Canvas)\n                source = createCanvasFromStaticMedia(this); // won't share WebGL context\n            return new SpeedyMedia(source, this._width, this._height);\n        }\n    }\n\n    /**\n     * Runs a pipeline\n     * @param {SpeedyPipeline} pipeline\n     * @returns {Promise<SpeedyMedia>} a promise that resolves to A CLONE of this SpeedyMedia\n     */\n    run(pipeline)\n    {\n        // has the media been released?\n        if(this.isReleased())\n            throw new IllegalOperationError('Can\\'t run pipeline: SpeedyMedia has been released');\n\n        // run the pipeline\n        const media = this.clone({ lightweight: true });\n        media._type = MediaType.Texture;\n        return pipeline._run(media);\n    }\n\n    /**\n     * Draws the media to a canvas\n     * @param {HTMLCanvasElement} canvas canvas element\n     * @param {number} [x] x-position\n     * @param {number} [y] y-position\n     * @param {number} [width] desired width\n     * @param {number} [height] desired height\n     */\n    draw(canvas, x = 0, y = 0, width = this.width, height = this.height)\n    {\n        // fail silently if the media been released\n        if(this.isReleased())\n            return;\n\n        // draw\n        const ctx = canvas.getContext('2d');\n\n        x = +x; y = +y;\n        width = Math.max(width, 0);\n        height = Math.max(height, 0);\n\n        switch(this._type) {\n            case MediaType.Image:\n            case MediaType.Video:\n            case MediaType.Canvas:\n                ctx.drawImage(this._source, x, y, width, height);\n                break;\n\n            case MediaType.Texture:\n                ctx.drawImage(this._gpu.canvas, x, y, width, height);\n                break;\n        }\n    }\n\n    /**\n     * Finds image features\n     * @param {object} [settings] Configuration object\n     * @returns {Promise<SpeedyFeature[]>} A Promise returning an Array of SpeedyFeature objects\n     */\n    findFeatures(settings = {})\n    {\n        // Default settings\n        if(!settings.hasOwnProperty('method'))\n            settings.method = 'fast';\n        if(!settings.hasOwnProperty('denoise'))\n            settings.denoise = true;\n        if(!settings.hasOwnProperty('max'))\n            settings.max = undefined;\n\n        // Has the media been released?\n        if(this.isReleased())\n            throw new IllegalOperationError(`Can't find features: SpeedyMedia has been released`);\n\n        // Validate method\n        const method = String(settings.method);\n        if(!featuresAlgorithm.hasOwnProperty(method))\n            throw new IllegalArgumentError(`Invalid method \"${method}\" for feature detection`);\n\n        // Setup feature detector & descriptor\n        if(this._featuresAlgorithm == null || this._featuresAlgorithm.constructor !== featuresAlgorithm[method])\n            this._featuresAlgorithm = new (featuresAlgorithm[method])(this._gpu);\n\n        // Set custom settings for the selected feature detector & descriptor\n        for(const key in settings) {\n            if(settings.hasOwnProperty(key) && (key in this._featuresAlgorithm))\n                this._featuresAlgorithm[key] = settings[key];\n        }\n\n        // Upload & preprocess media\n        let texture = this._gpu.upload(this._source);\n        texture = this._featuresAlgorithm.preprocess(\n            texture,\n            settings.denoise,\n            this._colorFormat != ColorFormat.Greyscale\n        );\n\n        // Feature detection & description\n        let encodedKeypoints = this._featuresAlgorithm.detectAndDescribe(texture);\n\n        // Download from the GPU\n        return this._featuresAlgorithm.download(\n            encodedKeypoints,\n            this.options.usage == 'dynamic',\n            settings.max\n        );\n    }\n}\n\n// get the { width, height } of a certain HTML element (image, video, canvas...)\nfunction getMediaDimensions(mediaSource)\n{\n    if(mediaSource && mediaSource.constructor && mediaSource.constructor.name) {\n        const element = mediaSource.constructor.name, key = {\n            HTMLImageElement: { width: 'naturalWidth', height: 'naturalHeight' },\n            HTMLVideoElement: { width: 'videoWidth', height: 'videoHeight' },\n            HTMLCanvasElement: { width: 'width', height: 'height' },\n        };\n\n        if(key.hasOwnProperty(element)) {\n            return {\n                width: mediaSource[key[element].width],\n                height: mediaSource[key[element].height]\n            };\n        }\n    }\n\n    return null;\n}\n\n// get a string corresponding to the media type (image, video, canvas)\nfunction getMediaType(mediaSource)\n{\n    if(mediaSource && mediaSource.constructor) {\n        switch(mediaSource.constructor.name) {\n            case 'HTMLImageElement':\n                return MediaType.Image;\n\n            case 'HTMLVideoElement':\n                return MediaType.Video;\n\n            case 'HTMLCanvasElement':\n                return MediaType.Canvas;\n\n            default:\n                return MediaType.Texture;\n        }\n    }\n\n    throw new IllegalArgumentError(`Can't get media type: invalid media source. ${mediaSource}`);\n}\n\n// build & validate options object\nfunction buildOptions(options, defaultOptions)\n{\n    const warn = buildOptions._err || (buildOptions._err = \n        (...args) => Utils.warning(`Invalid option when loading media.`, ...args));\n\n    // build options object\n    options = Object.assign(defaultOptions, options);\n\n    // validate\n    if(options.usage != 'dynamic' && options.usage != 'static') {\n        warn(`Unrecognized usage: \"${options.usage}\"`);\n        options.usage = defaultOptions.usage;\n    }\n\n    // done!\n    return Object.freeze(options); // must be read-only\n}\n\n// webcam access\nfunction requestCameraStream(width, height, options = {})\n{\n    return new Promise((resolve, reject) => {\n        Utils.log('Accessing the webcam...');\n\n        if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia)\n            return reject(new NotSupportedError('Unsupported browser: no mediaDevices.getUserMedia()'));\n\n        navigator.mediaDevices.getUserMedia({\n            audio: false,\n            video: {\n                width: { ideal: width },\n                height: { ideal: height },\n                aspectRatio: { ideal: width / height },\n                facingMode: 'environment',\n            },\n            ...(options)\n        })\n        .then(stream => {\n            const video = document.createElement('video');\n            video.srcObject = stream;\n            video.onloadedmetadata = e => {\n                video.play();\n                Utils.log('The camera device is turned on!');\n                resolve(video, stream);\n            };\n        })\n        .catch(err => {\n            reject(new AccessDeniedError(\n                `Please give access to the camera and reload the page`,\n                err\n            ));\n        });\n    });\n}\n\n// create a HTMLCanvasElement using a HTMLVideoElement\nfunction createCanvasFromVideo(video)\n{\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    \n    canvas.width = video.videoWidth;\n    canvas.height = video.videoHeight;\n\n    function render() {\n        ctx.drawImage(video, 0, 0);\n        requestAnimationFrame(render);\n    }\n    render();\n\n    return canvas;\n}\n\n// create a (static) HTMLCanvasElement using a SpeedyMedia as source\nfunction createCanvasFromStaticMedia(media)\n{\n    const canvas = document.createElement('canvas');\n\n    canvas.width = media.width;\n    canvas.height = media.height;\n    media.draw(canvas);\n\n    return canvas;\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-pipeline.js\n * A pipeline is a sequence of operations that transform the image in some way\n */\n\nimport { PipelineOperation } from './pipeline-operations';\nimport { MediaType } from '../utils/types';\nimport { IllegalOperationError } from '../utils/errors';\nimport { IllegalArgumentError } from '../utils/errors';\n\n\n/**\n * A SpeedyPipeline holds a sequence of operations that\n * graphically transform the incoming media in some way\n * \n * SpeedyPipeline's methods are chainable: use them to\n * create your own sequence of image operations\n */\nexport class SpeedyPipeline\n{\n    /* friend class SpeedyMedia */\n\n    /**\n     * Class constructor\n     */\n    constructor()\n    {\n        this._operations = [];\n    }\n\n    /**\n     * The number of the operations of the pipeline\n     * @returns {number}\n     */\n    get length()\n    {\n        return this._operations.length;\n    }\n\n    /**\n     * Cleanup pipeline memory\n     * @returns {Promise<SpeedyPipeline>} resolves as soon as the memory is released\n     */\n    release()\n    {\n        return new Promise((resolve, reject) => {\n            for(let i = this._operations.length - 1; i >= 0; i--)\n                this._operations[i].release();\n            this._operations.length = 0;\n            resolve(this);\n        });\n    }\n\n    /**\n     * Adds a new operation to the end of the pipeline\n     * @param {SpeedyPipelineOperation} operation\n     * @returns {SpeedyPipeline} the pipeline itself\n     */\n    _spawn(operation)\n    {\n        this._operations.push(operation);\n        return this;\n    }\n\n    /**\n     * Runs the pipeline on a target media (it will be modified!)\n     * @param {SpeedyMedia} media media to be modified\n     * @returns {Promise<SpeedyMedia>} a promise that resolves to the provided media\n     */\n    _run(media)\n    {\n        return new Promise((resolve, reject) => {\n            if(media._type == MediaType.Texture) {\n                // upload the media to the GPU\n                let texture = media._gpu.upload(media._source);\n\n                // run the pipeline\n                for(let i = 0; i < this._operations.length; i++)\n                    texture = this._operations[i].run(texture, media._gpu, media);\n\n                // end of the pipeline\n                media._gpu.programs.utils.output(texture);\n                media._source = media._gpu.canvas;\n\n                // done!\n                resolve(media);\n            }\n            else\n                reject(new IllegalOperationError(`Can't run a pipeline on a media that is not a texture`));\n        });\n    }\n\n\n    // =====================================================\n    //                    GENERIC\n    // =====================================================\n\n    /**\n     * Concatenates another pipeline into this one\n     * @param {SpeedyPipeline} pipeline\n     * @returns {SpeedyPipeline}\n     */\n    concat(pipeline)\n    {\n        if(pipeline instanceof SpeedyPipeline) {\n            this._operations = this._operations.concat(pipeline._operations);\n            return this;\n        }\n\n        throw new IllegalArgumentError(`Invalid argument \"${pipeline}\" given to SpeedyPipeline.concatenate()`);\n    }\n\n\n    // =====================================================\n    //               COLOR CONVERSIONS\n    // =====================================================\n\n    /**\n     * Convert to a color space\n     * @param {string} [colorSpace] 'greyscale' | 'grayscale'\n     * @returns {SpeedyPipeline}\n     */\n    convertTo(colorSpace = null)\n    {\n        if(colorSpace == 'greyscale' || colorSpace == 'grayscale') {\n            return this._spawn(\n                new PipelineOperation.ConvertToGreyscale()\n            );\n        }\n\n        throw new IllegalArgumentError(`Can't convert to unknown color space: \"${colorSpace}\"`);\n    }\n\n\n\n    // =====================================================\n    //               IMAGE FILTERING\n    // =====================================================\n\n    /**\n     * Image smoothing\n     * @param {object} [options]\n     * @returns {SpeedyPipeline}\n     */\n    blur(options = {})\n    {\n        return this._spawn(\n            new PipelineOperation.Blur(options)\n        );\n    }\n\n    /**\n     * Image convolution\n     * @param {Array<number>} kernel\n     * @param {number} [divisor]\n     * @returns {SpeedyPipeline}\n     */\n    convolve(kernel, divisor = 1.0)\n    {\n        return this._spawn(\n            new PipelineOperation.Convolve(kernel, divisor)\n        );\n    }\n\n    /**\n     * Image normalization\n     * @param {object} [options]\n     * @returns {SpeedyPipeline}\n     */\n    normalize(options = {})\n    {\n        return this._spawn(\n            new PipelineOperation.Normalize(options)\n        );\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * sensitivity-tuner.js\n * A tuner designed for automatic sensitivity of keypoint detection\n */\n\nimport { Utils } from '../../utils/utils';\nimport { Tuner } from './tuner';\n\n/**\n * A Tuner for minimizing errors between observed and expected values\n * It's an online tuner: it learns the best responses in real-time\n * \n * This is sort of a hill climbing / gradient descent algorithm\n * with random elements and adapted for discrete space\n * \n * FIXME: currently it's a bit unstable in its results...\n *        Think it over.\n */\nexport class SensitivityTuner extends Tuner\n{\n    /**\n     * Class constructor\n     * @param {number} minState minimum INTEGER accepted by the quadratic error system\n     * @param {number} maxState maximum INTEGER accepted by the quadratic error system\n     * @param {number} tolerance percentage relative to the expected observation\n     * @param {number} learningRate hyperparameter\n     */\n    constructor(minState, maxState, tolerance = 0.1, learningRate = 0.05)\n    {\n        const initialState = Math.round(Utils.gaussianNoise((minState + maxState) / 2, 5));\n        super(initialState, minState, maxState);\n        this._tolerance = Math.max(0, tolerance);\n        this._bestState = this._initialState;\n        this._expected = null;\n        this._learningRate = Math.max(0, learningRate);\n        this._lastObservation = 0;\n    }\n\n    /**\n     * Reset the tuner\n     */\n    reset()\n    {\n        super.reset();\n        this._expected = null;\n    }\n\n    /**\n     * Feed an observed value and an expected value\n     * @param {number} observedValue\n     * @param {number} expectedValue\n     */\n    feedObservation(observedValue, expectedValue)\n    {\n        const obs = +observedValue;\n        const expected = +expectedValue;\n\n        // must reset the tuner?\n        if(expected !== this._expected)\n            this.reset();\n        this._expected = expected;\n\n        // discard noise\n        const possibleNoise = (Math.abs(obs) > 2 * Math.abs(this._lastObservation));\n        this._lastObservation = obs;\n        if(possibleNoise)\n            return;\n\n        // feed an error measurement to the appropriate bucket\n        const err = ((obs - expected) * (obs - expected)) / (expected * expected);\n        super.feedObservation(err);\n    }\n\n    /**\n     * Finished optimizing?\n     * @returns {boolean}\n     */\n    finished()\n    {\n        // error function\n        const E = (s) => Math.sqrt(this._bucketOf(s).average) * Math.abs(this._expected);\n\n        // compute values\n        const err = E(this._bestState);\n        const tol = this._tolerance;\n        const exp = this._expected;\n        //console.log('ERR', err, tol * exp);\n\n        // acceptable condition\n        return err <= tol * exp;\n    }\n\n    /**\n     * Tolerance value, a percentage relative\n     * to the expected value that we want\n     * @returns {boolean}\n     */\n    get tolerance()\n    {\n        return this._tolerance;\n    }\n\n    /**\n     * Set the tolerance, a percentage relative\n     * to the expected value that we want\n     * @param {number} value\n     */\n    set tolerance(value)\n    {\n        this._tolerance = Math.max(0, value);\n    }\n\n    /**\n     * Where should I go next?\n     * @returns {number} next state represented by an integer\n     */\n    _nextState()\n    {\n        // debug\n        /*\n        const dE = (s) => Math.sqrt(this._bucketOf(s).average) * Math.abs(this._expected);\n        let dnewState=(this._prevState+1)%(this._maxState+1)+this._minState;\n        this._arr = this._arr || [];\n        this._arr[dnewState] = dE(dnewState);\n        if(dnewState==this._minState) console.log(JSON.stringify(this._arr));\n        return dnewState;\n        */\n\n        // finished?\n        if(this.finished())\n            return this._bestState;\n\n        // error function\n        const E = (s) => Math.sqrt(this._bucketOf(s).average) * Math.abs(this._expected);\n\n        // best state\n        if(E(this._state) < E(this._bestState))\n            this._bestState = this._state;\n\n        // the algorithm should avoid long hops, as this\n        // would cause discontinuities for the end-user\n        //const stepSize = this._learningRate * E(this._state);\n        const worldScale = Math.abs(this._maxState);\n        const G = (s) => Math.sqrt(this._bucketOf(s).average) * worldScale;\n        const stepSize = this._learningRate * G(this._state);\n\n        // move in the opposite direction of the error or in\n        // the direction of the error with a small probability\n        const sign = x => Number(x >= 0) - Number(x < 0); // -1 or 1\n        const derr = E(this._state) - E(this._prevState);\n        const direction = (\n            sign(derr) *\n            sign(derr != 0 ? -(this._state - this._prevState) : 1) *\n            sign(Math.random() - 0.15)\n        );\n        //console.warn(\"at state\", this._state, direction > 0 ? '-->' : '<--');\n\n        // pick the next state\n        const weight = Utils.gaussianNoise(1.0, 0.1); // dodge local mimina\n        let newState = Math.round(this._state + direction * weight * stepSize);\n\n        // outside bounds?\n        if(newState > this._maxState)\n            newState = this._bestState;\n        else if(newState < this._minState)\n            newState = this._bestState;\n\n        // done\n        return newState;\n    }\n\n    /**\n     * Let me see debugging data\n     * @returns {object}\n     */\n    info()\n    {\n        return {\n            now: [ this._state, this._prevState ],\n            bkt: this._bucketOf(this._state)._rawData,\n            cur: this._bucketOf(this._state)._head,\n            err: [ this._bucketOf(this._state).average, this._bucketOf(this._prevState).average ],\n            sqt: Math.sqrt(this._bucketOf(this._state).average),\n            done: this.finished(),\n        };\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * stochastic-tuner.js\n * A tuner that implements Simulated Annealing\n */\n\nimport { Tuner } from './tuner';\n\n/*\n * A tuner that implements Simulated Annealing\n */\nexport class StochasticTuner extends Tuner\n{\n    /**\n     * Class constructor\n     * @param {number} initialState initial guess to input to the unknown system\n     * @param {number} minState minimum integer accepted by the unknown system\n     * @param {number} maxState maximum integer accepted by the unknown system\n     * @param {number} [alpha] geometric decrease rate of the temperature\n     * @param {number} [maxIterationsPerTemperature] number of iterations before cooling down by alpha\n     * @param {number} [initialTemperature] initial temperature\n     * @param {Function<number,number?>} [neighborFn] neighbor picking function: state[,F(state)] -> state\n     */\n    constructor(initialState, minState, maxState, alpha = 0.5, maxIterationsPerTemperature = 8, initialTemperature = 100, neighborFn = null)\n    {\n        super(initialState, minState, maxState);\n\n        this._bestState = this._initialState;\n        this._costOfBestState = Infinity;\n        this._initialTemperature = Math.max(0, initialTemperature);\n        this._temperature = this._initialTemperature;\n        this._numIterations = 0; // no. of iterations in the current temperature\n        this._maxIterationsPerTemperature = Math.max(1, maxIterationsPerTemperature);\n        this._alpha = Math.max(0, Math.min(alpha, 1)); // geometric decrease rate\n\n        if(!neighborFn)\n            neighborFn = (s) => this._minState + Math.floor(Math.random() * (this._maxState - this._minState + 1))\n        this._pickNeighbor = neighborFn;\n    }\n\n    /**\n     * Reset the Tuner\n     */\n    reset()\n    {\n        this._temperature = this._initialTemperature;\n        this._numIterations = 0;\n        // we shall not reset the best state...\n    }\n\n    /**\n     * Finished optimization?\n     * @returns {boolean}\n     */\n    finished()\n    {\n        return this._temperature <= 1e-5;\n    }\n\n    /**\n     * Pick the next state\n     * Simulated Annealing\n     * @returns {number}\n     */\n    _nextState()\n    {\n        // finished simulation?\n        if(this.finished())\n            return this._bestState;\n\n        // pick a neighbor\n        const f = (s) => this._bucketOf(s).average;\n        let nextState = this._state;\n        let neighbor = this._pickNeighbor(this._state, f(this._state)) | 0;\n        neighbor = Math.max(this._minState, Math.min(neighbor, this._maxState));\n\n        // evaluate the neighbor\n        if(f(neighbor) < f(this._state)) {\n            // the neighbor is better than the current state\n            nextState = neighbor;\n        }\n        else {\n            // the neighbor is not better than the current state,\n            // but we may admit it with a certain probability\n            if(Math.random() < Math.exp((f(this._state) - f(neighbor)) / this._temperature))\n                nextState = neighbor;\n        }\n\n        // update the best state\n        if(f(nextState) < this._costOfBestState) {\n            this._bestState = nextState;\n            this._costOfBestState = f(nextState);\n        }\n\n        // cool down\n        if(++this._numIterations >= this._maxIterationsPerTemperature) {\n            this._temperature *= this._alpha;\n            this._numIterations = 0;\n        }\n\n        // done\n        return nextState;\n    }\n\n    /**\n     * Debugging info\n     * @returns {object}\n     */\n    info()\n    {\n        return {\n            best: [ this._bestState, this._costOfBestState ],\n            state: [ this._state, this._bucketOf(this._state).average ],\n            iterations: [ this._numIterations, this._maxIterationsPerTemperature ],\n            temperature: this._temperature,\n            alpha: this._alpha,\n            cool: this.finished(),\n        };\n    }\n}\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * test-tuner.js\n * A tuner created for testing purposes\n */\n\nimport { Tuner } from './tuner';\n\n/**\n * A Tuner created for testing purposes\n */\nexport class TestTuner extends Tuner\n{\n    /**\n     * Class constructor\n     * @param {number} minState minimum integer accepted by the unknown system\n     * @param {number} maxState maximum integer accepted by the unknown system\n     */\n    constructor(minState, maxState)\n    {\n        super(minState, minState, maxState);\n    }\n\n    // where should I go next?\n    _nextState()\n    {\n        //console.log(this.info());\n        const nextState = this._state + 1;\n        return nextState > this._maxState ? this._minState : nextState;\n    }\n\n    // let me see stuff\n    info()\n    {\n        return {\n            state: [ this._state, this._bucketOf(this._state).average ],\n            data: JSON.stringify(this._bucket.map(b => b.average)),\n        };\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * tuner.js\n * An abstract device designed to minimize the (noisy) output of a unknown system\n */\n\nimport { IllegalArgumentError, AbstractMethodError } from '../../utils/errors';\n\n/**\n * A Bucket of observations is used to give\n * statistical treatment to (noisy) data\n */\nclass Bucket\n{\n    /**\n     * Class constructor\n     * @param {number} bucketSize It should be a power of two\n     * @param {number} windowSize An odd positive number for filtering\n     */\n    constructor(bucketSize = 32, windowSize = 5)\n    {\n        // validate parameters\n        this._bucketSize = 1 << Math.ceil(Math.log2(bucketSize));\n        this._windowSize = windowSize + (1 - windowSize % 2);\n\n        // bucketSize should be a power of 2\n        if(bucketSize < this._windowSize)\n            throw new IllegalArgumentError(`Invalid bucketSize of ${bucketSize}`);\n\n        // Bucket is implemented as a circular vector\n        this._head = this._bucketSize - 1;\n        this._rawData = new Float32Array(this._bucketSize).fill(0);\n        this._smoothedData = new Float32Array(this._bucketSize).fill(0);\n        this._average = 0;\n        this._isSmooth = true;\n    }\n\n    /**\n     * Put a value in the bucket\n     * @param {number} value\n     */\n    put(value)\n    {\n        this._head = (this._head + 1) & (this._bucketSize - 1);\n        this._rawData[this._head] = value;\n        this._isSmooth = false;\n    }\n\n    /**\n     * Bucket size\n     * @returns {number}\n     */\n    get size()\n    {\n        return this._bucketSize;\n    }\n\n    /**\n     * Get smoothed average\n     * @returns {number}\n     */\n    get average()\n    {\n        // need to smooth the signal?\n        if(!this._isSmooth)\n            this._smooth();\n\n        // the median filter does not introduce new data to the signal\n        // this._average approaches the mean of the distribution as bucketSize -> inf\n        return this._average;\n    }\n\n    /**\n     * Fill the bucket with a value\n     * @param {number} value\n     */\n    fill(value)\n    {\n        this._rawData.fill(value);\n        this._smoothedData.fill(value);\n        this._average = value;\n        this._isSmooth = true;\n        this._head = this._bucketSize - 1;\n        return this;\n    }\n\n    /**\n     * Apply the smoothing filter & compute the average\n     */\n    _smooth()\n    {\n        // smooth the signal & compute the average\n        this._average = 0;\n        for(let i = 0; i < this._bucketSize; i++) {\n            this._smoothedData[i] = this._median(this._window(i));\n            this._average += this._smoothedData[i];\n        }\n        this._average /= this._bucketSize;\n        //this._average = this._median(this._rawData);\n\n        // the signal has been smoothed\n        this._isSmooth = true;\n    }\n\n    /**\n     * Give me a window of size this._windowSize around this._rawData[i]\n     * @param {number} i central index\n     * @returns {Float32Array} will reuse the same buffer on each call\n     */\n    _window(i)\n    {\n        const arr = this._rawData;\n        const win = this._win || (this._win = new Float32Array(this._windowSize));\n        const n = arr.length;\n        const w = win.length;\n        const wOver2 = w >> 1;\n        const head = this._head;\n        const tail = (head + 1) & (n - 1);\n\n        for(let j = 0, k = -wOver2; k <= wOver2; k++) {\n            let pos = i + k;\n\n            // boundary conditions:\n            // reflect values\n            if(i <= head){\n                if(pos > head)\n                    pos = head + (head - pos);\n            }\n            else {\n                if(pos < tail)\n                    pos = tail + (tail - pos);\n            }\n            if(pos < 0)\n                pos += n;\n            else if(pos >= n)\n                pos -= n;\n\n            win[j++] = arr[pos];\n        }\n\n        return win;\n    }\n\n    /**\n     * Return the median of a sequence. Do it fast.\n     * Note: the input is rearranged\n     * @param {number[]} v sequence\n     * @returns {number}\n     */\n    _median(v)\n    {\n        // fast median search for fixed length vectors\n        switch(v.length) {\n            case 1:\n                return v[0];\n\n            case 3:\n                //  v0   v1   v2   [ v0  v1  v2 ]\n                //   \\  / \\   /\n                //   node  node    [ min(v0,v1)  min(max(v0,v1),v2)  max(max(v0,v1),v2) ]\n                //      \\   /\n                //      node       [ min(min(v0,v1),min(max(v0,v1),v2))  max(min(...),min(...))  max(v0,v1,v2) ]\n                //       |\n                //     median      [ min(v0,v1,v2)  median  max(v0,v1,v2) ]\n                if(v[0] > v[1]) [v[0], v[1]] = [v[1], v[0]];\n                if(v[1] > v[2]) [v[1], v[2]] = [v[2], v[1]];\n                if(v[0] > v[1]) [v[0], v[1]] = [v[1], v[0]];\n                return v[1];\n\n            case 5:\n                if(v[0] > v[1]) [v[0], v[1]] = [v[1], v[0]];\n                if(v[3] > v[4]) [v[3], v[4]] = [v[4], v[3]];\n                if(v[0] > v[3]) [v[0], v[3]] = [v[3], v[0]];\n                if(v[1] > v[4]) [v[1], v[4]] = [v[4], v[1]];\n                if(v[1] > v[2]) [v[1], v[2]] = [v[2], v[1]];\n                if(v[2] > v[3]) [v[2], v[3]] = [v[3], v[2]];\n                if(v[1] > v[2]) [v[1], v[2]] = [v[2], v[1]];\n                return v[2];\n\n            case 7:\n                if(v[0] > v[5]) [v[0], v[5]] = [v[5], v[0]];\n                if(v[0] > v[3]) [v[0], v[3]] = [v[3], v[0]];\n                if(v[1] > v[6]) [v[1], v[6]] = [v[6], v[1]];\n                if(v[2] > v[4]) [v[2], v[4]] = [v[4], v[2]];\n                if(v[0] > v[1]) [v[0], v[1]] = [v[1], v[0]];\n                if(v[3] > v[5]) [v[3], v[5]] = [v[5], v[3]];\n                if(v[2] > v[6]) [v[2], v[6]] = [v[6], v[2]];\n                if(v[2] > v[3]) [v[2], v[3]] = [v[3], v[2]];\n                if(v[3] > v[6]) [v[3], v[6]] = [v[6], v[3]];\n                if(v[4] > v[5]) [v[4], v[5]] = [v[5], v[4]];\n                if(v[1] > v[4]) [v[1], v[4]] = [v[4], v[1]];\n                if(v[1] > v[3]) [v[1], v[3]] = [v[3], v[1]];\n                if(v[3] > v[4]) [v[3], v[4]] = [v[4], v[3]];\n                return v[3];\n\n            default:\n                v.sort((a, b) => a - b);\n                return (v[(v.length - 1) >> 1] + v[v.length >> 1]) / 2;\n        }\n    }\n}\n\n/**\n * A Tuner is a device designed to find\n * an integer x that minimizes the output\n * of a unknown system y = F(x) with noise\n */\nexport /* abstract */ class Tuner\n{\n    /**\n     * Class constructor\n     * @param {number} initialState initial guess to input to the unknown system\n     * @param {number} minState minimum integer accepted by the unknown system\n     * @param {number} maxState maximum integer accepted by the unknown system\n     */\n    constructor(initialState, minState, maxState)\n    {\n        // you must not spawn an instance of an abstract class!\n        if(this.constructor === Tuner)\n            throw new AbstractMethodError();\n\n        // validate parameters\n        if(minState >= maxState)\n            throw new IllegalArgumentError(`Invalid boundaries [${minState},${maxState}] given to the Tuner`);\n        initialState = Math.max(minState, Math.min(initialState, maxState));\n\n        // setup object\n        this._state = initialState;\n        this._prevState = initialState;\n        this._prevPrevState = initialState;\n        this._initialState = initialState;\n        this._minState = minState;\n        this._maxState = maxState;\n        this._bucket = new Array(maxState - minState + 1).fill(null).map(x => new Bucket(this._bucketSetup().size, this._bucketSetup().window));\n        this._iterations = 0; // number of iterations in the same state\n        this._epoch = 0; // number of state changes\n    }\n\n    /**\n     * The value to input to the unknown system\n     */\n    currentValue()\n    {\n        return this._state;\n    }\n\n    /**\n     * Feed the output y = F(x) of the unknown system\n     * when given an input x = this.currentValue()\n     */\n    feedObservation(y)\n    {\n        const bucket = this._bucketOf(this._state);\n\n        // feed the observation into the bucket of the current state\n        bucket.put(+y);\n\n        // time to change state?\n        if(++this._iterations >= bucket.size) {\n            // initialize buckets\n            if(this._epoch == 0) {\n                this._bucket.forEach(bk => bk.fill(bucket.average));\n                if(!isFinite(this._costOfBestState))\n                    this._costOfBestState = bucket.average;\n            }\n\n            // compute next state\n            const clip = s => Math.max(this._minState, Math.min(s | 0, this._maxState));\n            const prevPrevState = this._prevState;\n            const prevState = this._state;\n            this._state = clip(this._nextState());\n            this._prevState = prevState;\n            this._prevPrevState = prevPrevState;\n\n            // reset iteration counter\n            // and advance epoch number\n            this._iterations = 0;\n            this._epoch++;\n        }\n    }\n\n    /**\n     * Reset the Tuner to its initial state\n     * Useful if you change on-the-fly the unknown system,\n     * so that there is a new target value you want to find\n     */\n    reset()\n    {\n        this._state = this._initialState;\n        this._prevState = this._initialState;\n        this._prevPrevState = this._initialState;\n        this._iterations = 0;\n        this._epoch = 0;\n    }\n\n    /**\n     * Finished optimization?\n     * @returns {boolean}\n     */\n    finished()\n    {\n        return false;\n    }\n\n    /**\n     * Get the bucket of a state\n     * @param {number} state \n     * @returns {Bucket}\n     */\n    _bucketOf(state)\n    {\n        state = Math.max(this._minState, Math.min(state | 0, this._maxState));\n        return this._bucket[state - this._minState];\n    }\n\n    /**\n     * Setup bucket shape. This may\n     * be reconfigured in subclasses.\n     * @returns {object}\n     */\n    _bucketSetup()\n    {\n        return {\n            size: 4,\n            window: 3\n        };\n        /*return {\n            size: 32,\n            window: 5\n        };*/\n    }\n\n    /**\n     * Template method magic\n     * @returns {number} next state\n     */\n    /* abstract */ _nextState()\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Let me see debugging stuff\n     * @returns {object}\n     */\n    info()\n    {\n        const bucket = this._bucketOf(this._state);\n        const prevBucket = this._bucketOf(this._prevState);\n\n        return {\n            now: this._state,\n            avg: bucket.average,\n            itr: [ this._iterations, this._epoch ],\n            bkt: bucket._smoothedData,\n            cur: new Array(bucket.size).fill(0).map((x, i) => i == bucket._head ? 1 : 0),\n            prv: [ this._prevState, prevBucket.average ],\n            fim: this.finished(),\n        };\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * gl-utils.js\n * WebGL utilities\n */\n\nimport { Utils } from '../utils/utils';\nimport { GLError, IllegalArgumentError, IllegalOperationError } from '../utils/errors';\n\n/**\n * WebGL Utilities\n */\nexport class GLUtils\n{\n    /**\n     * Get an error object describing the latest WebGL error\n     * @param {WebGL2RenderingContext} gl \n     * @returns {GLError}\n     */\n    static getError(gl)\n    {\n        const recognizedErrors = [\n            'NO_ERROR',\n            'INVALID_ENUM',\n            'INVALID_VALUE',\n            'INVALID_OPERATION',\n            'INVALID_FRAMEBUFFER_OPERATION',\n            'OUT_OF_MEMORY',\n            'CONTEXT_LOST_WEBGL',\n        ];\n\n        const glError = gl.getError();\n        const message = recognizedErrors.find(error => gl[error] == glError) || 'Unknown';\n        return new GLError(message);\n    }\n\n    /**\n     * Create a shader\n     * @param {WebGL2RenderingContext} gl\n     * @param {number} type\n     * @param {string} source\n     * @returns {WebGLShader}\n     */\n    static createShader(gl, type, source)\n    {\n        const shader = gl.createShader(type);\n\n        gl.shaderSource(shader, source);\n        gl.compileShader(shader);\n\n        return shader;\n    }\n\n    /**\n     * Create a vertex-shader + fragment-shader program\n     * @param {WebGL2RenderingContext} gl\n     * @param {string} vertexShaderSource\n     * @param {string} fragmentShaderSource\n     * @returns {WebGLProgram}\n     */\n    static createProgram(gl, vertexShaderSource, fragmentShaderSource)\n    {\n        const program = gl.createProgram();\n        const vertexShader = GLUtils.createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n        const fragmentShader = GLUtils.createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n\n        gl.attachShader(program, vertexShader);\n        gl.attachShader(program, fragmentShader);\n        gl.linkProgram(program);\n        gl.validateProgram(program);\n\n        // error?\n        if(!gl.getProgramParameter(program, gl.LINK_STATUS) && !gl.isContextLost()) {\n            const errors = [\n                gl.getShaderInfoLog(fragmentShader),\n                gl.getShaderInfoLog(vertexShader),\n                gl.getProgramInfoLog(program),\n            ];\n\n            gl.deleteProgram(program);\n            gl.deleteShader(fragmentShader);\n            gl.deleteShader(vertexShader);\n\n            // display error\n            const spaces = i => Math.max(0, 2 - Math.floor(Math.log10(i)));\n            const col = k => Array(spaces(k)).fill(' ').join('') + k + '. ';\n            const formattedSource = fragmentShaderSource.split('\\n')\n                .map((line, no) => col(1+no) + line)\n                .join('\\n');\n\n            throw new GLError(\n                `Can't create shader.\\n\\n` +\n                `---------- ERROR ----------\\n` +\n                errors.join('\\n') + '\\n\\n' +\n                `---------- SOURCE CODE ----------\\n` +\n                formattedSource\n            );\n        }\n\n        return program;\n    }\n\n    /**\n     * Create the standard geometry for the vertex shader\n     * (i.e., vertices of a rectangle crafted for image processing)\n     * @param {WebGL2RenderingContext} gl\n     * @param {GLint} locationOfPositionAttribute\n     * @param {GLint} locationOfTexcoordAttribute\n     * @returns {object} with keys vao & vbo\n     */\n    static createStandardGeometry(gl, locationOfPositionAttribute, locationOfTexcoordAttribute)\n    {\n        // got cached values for this WebGL context?\n        const f = GLUtils.createStandardGeometry;\n        const cache = f._cache || (f._cache = new WeakMap());\n        if(cache.has(gl))\n            return cache.get(gl);\n\n        // configure the attributes of the vertex shader\n        const vao = gl.createVertexArray(); // vertex array object\n        const vbo = [ gl.createBuffer(), gl.createBuffer() ]; // vertex buffer objects\n        gl.bindVertexArray(vao);\n\n        // set the a_position attribute\n        // using the current vbo\n        gl.bindBuffer(gl.ARRAY_BUFFER, vbo[0]);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n            // clip coordinates\n            -1, -1,\n            1, -1,\n            -1, 1,\n            1, 1,\n        ]), gl.STATIC_DRAW);\n        gl.vertexAttribPointer(locationOfPositionAttribute, // attribute location\n                               2,          // 2 components per vertex (x,y)\n                               gl.FLOAT,   // type\n                               false,      // don't normalize\n                               0,          // default stride (tightly packed)\n                               0);         // offset\n        gl.enableVertexAttribArray(locationOfPositionAttribute);\n\n        // set the a_texCoord attribute\n        // using the current vbo\n        gl.bindBuffer(gl.ARRAY_BUFFER, vbo[1]);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n            // texture coordinates\n            0, 0,\n            1, 0,\n            0, 1,\n            1, 1,\n        ]), gl.STATIC_DRAW);\n        gl.vertexAttribPointer(locationOfTexcoordAttribute, // attribute location\n                               2,          // 2 components per vertex (x,y)\n                               gl.FLOAT,   // type\n                               false,      // don't normalize\n                               0,          // default stride (tightly packed)\n                               0);         // offset\n        gl.enableVertexAttribArray(locationOfTexcoordAttribute);\n\n        // unbind\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n\n        // cache & return\n        const result = { vao, vbo };\n        cache.set(gl, result);\n        return result;\n    }\n\n    /**\n     * Create a WebGL texture\n     * @param {WebGL2RenderingContext} gl \n     * @param {number} width in pixels\n     * @param {number} height in pixels\n     * @returns {WebGLTexture}\n     */\n    static createTexture(gl, width, height)\n    {\n        // validate dimensions\n        if(width <= 0 || height <= 0)\n            throw new IllegalArgumentError(`Invalid dimensions given to createTexture()`);\n\n        // create texture\n        const texture = gl.createTexture();\n\n        // setup texture\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT);\n        //gl.texStorage2D(gl.TEXTURE_2D, 1, gl.RGBA8, width, height);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA8, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n\n        // unbind & return\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        return texture;\n    }\n\n    /**\n     * Destroys a WebGL texture\n     * @param {WebGL2RenderingContext} gl \n     * @param {WebGLTexture} texture \n     * @returns {null}\n     */\n    static destroyTexture(gl, texture)\n    {\n        gl.deleteTexture(texture);\n        return null;\n    }\n\n    /**\n     * Upload pixel data to a WebGL texture\n     * @param {WebGL2RenderingContext} gl \n     * @param {WebGLTexture} texture \n     * @param {GLsizei} width texture width\n     * @param {GLsizei} height texture height\n     * @param {ImageBitmap|ImageData|ArrayBufferView|HTMLImageElement|HTMLVideoElement|HTMLCanvasElement} pixels \n     * @returns {WebGLTexture} texture\n     */\n    static uploadToTexture(gl, texture, width, height, pixels)\n    {\n        // Prefer calling uploadToTexture() before gl.useProgram() to avoid the\n        // needless switching of GL programs internally. See also:\n        // https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        /*\n        // slower than texImage2D, unlike the spec?\n        gl.texSubImage2D(gl.TEXTURE_2D,     // target\n                         0,                 // mip level\n                         0,                 // x-offset\n                         0,                 // y-offset\n                         width,             // texture width\n                         height,            // texture height\n                         gl.RGBA,           // source format\n                         gl.UNSIGNED_BYTE,  // source type\n                         pixels);           // source data\n        */\n        gl.texImage2D(gl.TEXTURE_2D,        // target\n                      0,                    // mip level\n                      gl.RGBA8,             // internal format\n                      //width,                // texture width\n                      //height,               // texture height\n                      //0,                    // border\n                      gl.RGBA,              // source format\n                      gl.UNSIGNED_BYTE,     // source type\n                      pixels);              // source data\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        return texture;\n    }\n\n    /**\n     * Generate texture mipmap with bilinear interpolation\n     * @param {WebGL2RenderingContext} gl \n     * @param {WebGLTexture} texture \n     */\n    static generateMipmap(gl, texture)\n    {\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);\n        gl.generateMipmap(gl.TEXTURE_2D);\n        gl.bindTexture(gl.TEXTURE_2D, null);\n    }\n\n    // bind the textures and assign their numbers\n    // textureMap: { 'textureName': <texture> , ... }\n    // locationMap: { 'textureName': <uniformLocation> , ... }\n    static bindTextures(gl, textureMap, locationMap)\n    {\n        const names = Object.keys(textureMap);\n\n        if(gl.isContextLost())\n            return;\n\n        if(names.length > gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS)\n            throw new GLError(`Can't bind ${names.length} textures to a program: max is ${gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS}`);\n\n        for(let i = 0; i < names.length; i++) {\n            gl.activeTexture(gl.TEXTURE0 + i);\n            gl.bindTexture(gl.TEXTURE_2D, textureMap[names[i]]);\n            gl.uniform1i(locationMap[names[i]], i);\n        }\n    }\n\n    /**\n     * Creates a framebuffer object (FBO) associated with an existing texture\n     * @param {WebGL2RenderingContext} gl \n     * @param {WebGLTexture} texture \n     * @returns {WebGLFramebuffer}\n     */\n    static createFramebuffer(gl, texture)\n    {\n        const fbo = gl.createFramebuffer();\n\n        // setup framebuffer\n        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n        gl.framebufferTexture2D(gl.FRAMEBUFFER,         // target\n                                gl.COLOR_ATTACHMENT0,   // color buffer\n                                gl.TEXTURE_2D,          // tex target\n                                texture,                // texture\n                                0);                     // mipmap level\n\n        // check for errors\n        const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n        if(status != gl.FRAMEBUFFER_COMPLETE) {\n            const error = (() => (([\n                'FRAMEBUFFER_UNSUPPORTED',\n                'FRAMEBUFFER_INCOMPLETE_ATTACHMENT',\n                'FRAMEBUFFER_INCOMPLETE_DIMENSIONS',\n                'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT',\n                'FRAMEBUFFER_INCOMPLETE_MULTISAMPLE'\n            ].filter(err => gl[err] === status))[0] || 'unknown error'))();\n            throw new GLError(`Can't create framebuffer: ${error} (${status})`);\n        }\n\n        // unbind & return\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        return fbo;\n    }\n\n    /**\n     * Destroys a framebuffer object (FBO)\n     * @param {WebGL2RenderingContext} gl\n     * @param {WebGLFramebuffer} fbo \n     * @returns {null}\n     */\n    static destroyFramebuffer(gl, fbo)\n    {\n        gl.deleteFramebuffer(fbo);\n        return null;\n    }\n\n    /**\n     * Waits for a sync object to become signaled\n     * @param {WebGL2RenderingContext} gl\n     * @param {WebGLSync} sync sync object\n     * @param {GLbitfield} [flags] may be gl.SYNC_FLUSH_COMMANDS_BIT or 0\n     * @returns {Promise} a promise that resolves as soon as the sync object becomes signaled\n     */\n    static clientWaitAsync(gl, sync, flags = 0)\n    {\n        return new Promise((resolve, reject) => {\n            const isFirefox = navigator.userAgent.includes('Firefox');\n\n            function checkStatus() {\n                const status = gl.clientWaitSync(sync, flags, 0);\n                if(status == gl.TIMEOUT_EXPIRED) {\n                    Utils.setZeroTimeout(checkStatus); // better performance (preferred)\n                    //setTimeout(checkStatus, 0); // easier on the CPU\n                }\n                else if(status == gl.WAIT_FAILED) {\n                    if(isFirefox && gl.getError() == gl.NO_ERROR) { // firefox bug?\n                        Utils.setZeroTimeout(checkStatus);\n                        //setTimeout(checkStatus, 0);\n                    }\n                    else {\n                        reject(GLUtils.getError(gl));\n                    }\n                }\n                else {\n                    resolve();\n                }\n            }\n\n            checkStatus();\n        });\n    }\n\n    /**\n     * Reads data from a WebGLBuffer into an ArrayBufferView\n     * This is like gl.getBufferSubData(), but async\n     * @param {WebGL2RenderingContext} gl\n     * @param {WebGLBuffer} glBuffer will be bound to target\n     * @param {GLenum} target\n     * @param {GLintptr} srcByteOffset usually 0\n     * @param {ArrayBufferView} destBuffer\n     * @param {GLuint} [destOffset]\n     * @param {GLuint} [length]\n     * @returns {Promise<number>} a promise that resolves to the time it took to read the data (in ms)\n     */\n    static getBufferSubDataAsync(gl, glBuffer, target, srcByteOffset, destBuffer, destOffset = 0, length = 0)\n    {\n        const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);\n        const start = performance.now();\n\n        // empty internal command queues and send them to the GPU asap\n        gl.flush(); // make sure the sync command is read\n\n        // wait for the commands to be processed by the GPU\n        return GLUtils.clientWaitAsync(gl, sync).then(() => {\n            gl.bindBuffer(target, glBuffer);\n            gl.getBufferSubData(target, srcByteOffset, destBuffer, destOffset, length);\n            gl.bindBuffer(target, null);\n            return performance.now() - start;\n        }).catch(err => {\n            throw new IllegalOperationError(`Can't getBufferSubDataAsync(): error in clientWaitAsync()`, err);\n        }).finally(() => {\n            gl.deleteSync(sync);\n        });\n    }\n\n    /**\n     * Read pixels to a Uint8Array using a Pixel Buffer Object (PBO)\n     * You may optionally specify a FBO to read pixels from a texture\n     * @param {WebGL2RenderingContext} gl\n     * @param {WebGLBuffer} pbo\n     * @param {Uint8Array} arrayBuffer with size >= width * height * 4\n     * @param {GLint} x\n     * @param {GLint} y\n     * @param {GLsizei} width\n     * @param {GLsizei} height\n     * @param {WebGLFramebuffer} [fbo]\n     * @returns {Promise<number>} a promise that resolves to the time it took to read the data (in ms)\n     */\n    static readPixelsViaPBO(gl, pbo, arrayBuffer, x, y, width, height, fbo = null)\n    {\n        // validate arrayBuffer\n        if(!(arrayBuffer.byteLength >= width * height * 4))\n            throw new IllegalArgumentError(`Can't read pixels: invalid buffer size`);\n\n        // bind the PBO\n        gl.bindBuffer(gl.PIXEL_PACK_BUFFER, pbo);\n        gl.bufferData(gl.PIXEL_PACK_BUFFER, arrayBuffer.byteLength, gl.STREAM_READ);\n\n        // read pixels into the PBO\n        if(fbo) {\n            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n            gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, 0);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        }\n        else {\n            gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, 0);\n        }\n\n        // unbind the PBO\n        gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);\n\n        // wait for DMA transfer\n        return GLUtils.getBufferSubDataAsync(gl, pbo,\n            gl.PIXEL_PACK_BUFFER,\n            0,\n            arrayBuffer,\n            0,\n            0\n        ).then(timeInMs => {\n            return timeInMs;\n        }).catch(err => {\n            throw new IllegalOperationError(`Can't read pixels`, err);\n        });\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * colors.js\n * Color routines & conversion algorithms\n */\n\nimport { SpeedyProgramGroup } from '../speedy-program-group';\nimport { importShader } from '../shader-declaration';\n\n\n\n//\n// Shaders\n//\n\n// Convert to greyscale\nconst rgb2grey = importShader('colors/rgb2grey.glsl').withArguments('image');\n\n\n\n\n/**\n * GPUColors\n * Color routines & conversion algorithms\n */\nexport class GPUColors extends SpeedyProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            // convert to greyscale\n            .declare('rgb2grey', rgb2grey)\n        ;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * descriptors.js\n * Feature descriptors\n */\n\nimport { SpeedyProgramGroup } from '../speedy-program-group';\nimport { importShader } from '../shader-declaration';\n\n\n\n//\n// Shaders\n//\n\n// ORB\nconst orb = importShader('descriptors/orb.glsl').withArguments('pyramid', 'encodedCorners', 'encoderLength');\n\n\n\n\n/**\n * GPUDescriptors\n * Feature descriptors\n */\nexport class GPUDescriptors extends SpeedyProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            // ORB\n            .declare('_orb', orb)\n        ;\n    }\n\n    /**\n     * Compute ORB descriptor (256 bits)\n     * @param {WebGLTexture} pyramid pre-smoothed on the intensity channel\n     * @param {WebGLTexture} encodedCorners tiny texture\n     * @param {number} encoderLength\n     * @return {WebGLTexture}\n     */\n    orb(pyramid, encodedCorners, encoderLength)\n    {\n        this._orb.resize(encoderLength, encoderLength);\n        return this._orb(pyramid, encodedCorners, encoderLength);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * encoders.js\n * Texture encoders\n */\n\nimport { SpeedyProgramGroup } from '../speedy-program-group';\nimport { importShader } from '../shader-declaration';\nimport { SpeedyFeature } from '../../core/speedy-feature';\nimport { BinaryDescriptor } from '../../core/speedy-descriptor';\nimport { StochasticTuner } from '../../core/tuners/stochastic-tuner';\nimport { Utils } from '../../utils/utils'\nimport { IllegalOperationError } from '../../utils/errors';\n\n// We won't admit more than MAX_KEYPOINTS per media.\n// The larger this value is, the more data we need to transfer from the GPU.\nconst MAX_DESCRIPTOR_SIZE = 64; // in bytes, must be divisible by 4\nconst MAX_KEYPOINT_SIZE = 8 + MAX_DESCRIPTOR_SIZE; // in bytes, must be divisible by 4\nconst MAX_PIXELS_PER_KEYPOINT = (MAX_KEYPOINT_SIZE / 4) | 0; // in pixels\nconst MAX_ENCODER_LENGTH = 300; // in pixels (if too large, WebGL may lose context - so be careful!)\nconst MAX_KEYPOINTS = ((MAX_ENCODER_LENGTH * MAX_ENCODER_LENGTH) / MAX_PIXELS_PER_KEYPOINT) | 0;\nconst INITIAL_ENCODER_LENGTH = 128; // pick a large value <= MAX (useful on static images when no encoder optimization is performed beforehand)\nconst PI = Math.PI;\n\n\n\n//\n// Shaders\n//\n\n// encode keypoint offsets: maxIterations is an integer in [1,255], determined experimentally\nconst encodeKeypointOffsets = importShader('encoders/encode-keypoint-offsets.glsl').withArguments('image', 'imageSize', 'maxIterations');\n\n// encode keypoints\nconst encodeKeypoints = importShader('encoders/encode-keypoints.glsl').withArguments('image', 'imageSize', 'encoderLength', 'descriptorSize');\n\n// find orientation of encoded keypoints\nconst orientEncodedKeypoints = importShader('encoders/orient-encoded-keypoints.glsl').withArguments('pyramid', 'patchRadius', 'encodedKeypoints', 'encoderLength', 'descriptorSize')\n\n// helper for downloading the keypoints\nconst downloadKeypoints = importShader('utils/identity.glsl').withArguments('image');\n\n\n\n\n/**\n * GPUEncoders\n * Keypoint encoding\n */\nexport class GPUEncoders extends SpeedyProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            .declare('_encodeKeypointOffsets', encodeKeypointOffsets)\n            .declare('_encodeKeypoints', encodeKeypoints, {\n                ...this.program.hasTextureSize(INITIAL_ENCODER_LENGTH, INITIAL_ENCODER_LENGTH)\n            })\n            .declare('_downloadKeypoints', downloadKeypoints, {\n                ...this.program.hasTextureSize(INITIAL_ENCODER_LENGTH, INITIAL_ENCODER_LENGTH)\n            })\n            .declare('_orientEncodedKeypoints', orientEncodedKeypoints, {\n                ...this.program.hasTextureSize(INITIAL_ENCODER_LENGTH, INITIAL_ENCODER_LENGTH)\n            })\n        ;\n\n        // setup internal data\n        let neighborFn = (s) => Math.round(Utils.gaussianNoise(s, 64)) % 256;\n        this._tuner = new StochasticTuner(48, 32, 48/*255*/, 0.2, 8, 60, neighborFn);\n        this._keypointEncoderLength = INITIAL_ENCODER_LENGTH;\n        this._spawnedAt = performance.now();\n    }\n\n    /**\n     * Keypoint encoder length\n     * @returns {number}\n     */\n    get encoderLength()\n    {\n        return this._keypointEncoderLength;\n    }\n\n    /**\n     * Optimizes the keypoint encoder for an expected number of keypoints\n     * @param {number} keypointCount expected number of keypoints\n     * @param {number} [descriptorSize] in bytes\n     * @returns {number} nonzero if the encoder has been optimized\n     */\n    optimizeKeypointEncoder(keypointCount, descriptorSize = 0)\n    {\n        const clampedKeypointCount = Math.max(0, Math.min(Math.ceil(keypointCount), MAX_KEYPOINTS));\n        const pixelsPerKeypoint = Math.ceil(2 + descriptorSize / 4);\n        const len = Math.ceil(Math.sqrt((4 + clampedKeypointCount * 1.05) * pixelsPerKeypoint)); // add some slack\n        const newEncoderLength = Math.max(1, Math.min(len, MAX_ENCODER_LENGTH));\n        const oldEncoderLength = this._keypointEncoderLength;\n\n        if(newEncoderLength != oldEncoderLength) {\n            this._keypointEncoderLength = newEncoderLength;\n            this._encodeKeypoints.resize(newEncoderLength, newEncoderLength);\n            this._downloadKeypoints.resize(newEncoderLength, newEncoderLength);\n            this._orientEncodedKeypoints.resize(newEncoderLength, newEncoderLength);\n        }\n\n        return newEncoderLength - oldEncoderLength;\n    }\n\n    /**\n     * Finds the orientation of all keypoints given a texture with encoded keypoints\n     * @param {WebGLTexture} pyramid image pyramid\n     * @param {number} patchRadius radius of a circular patch used to compute the radius when lod = 0 (e.g., 7)\n     * @param {WebGLTexture} encodedKeypoints the result of encodeKeypoints()\n     * @param {number} [descriptorSize] in bytes\n     */\n    orientEncodedKeypoints(pyramid, patchRadius, encodedKeypoints, descriptorSize = 0)\n    {\n        const encoderLength = this._keypointEncoderLength;\n        return this._orientEncodedKeypoints(pyramid, patchRadius, encodedKeypoints, encoderLength, descriptorSize);\n    }\n\n    /**\n     * Encodes the keypoints of an image into a compressed texture\n     * @param {WebGLTexture} corners texture with corners\n     * @param {number} [descriptorSize] in bytes\n     * @returns {WebGLTexture} texture with encoded keypoints\n     */\n    encodeKeypoints(corners, descriptorSize = 0)\n    {\n        // parameters\n        const encoderLength = this._keypointEncoderLength;\n        const imageSize = [ this._width, this._height ];\n        const maxIterations = this._tuner.currentValue();\n\n        // encode keypoints\n        const offsets = this._encodeKeypointOffsets(corners, imageSize, maxIterations);\n        return this._encodeKeypoints(offsets, imageSize, encoderLength, descriptorSize);\n    }\n\n    /**\n     * Decodes the keypoints, given a flattened image of encoded pixels\n     * @param {number[]} pixels pixels in the [r,g,b,a,...] format\n     * @param {number} [descriptorSize] in bytes\n     * @returns {SpeedyFeature[]} keypoints\n     */\n    decodeKeypoints(pixels, descriptorSize = 0)\n    {\n        const [ w, h ] = [ this._width, this._height ];\n        const pixelsPerKeypoint = 2 + descriptorSize / 4;\n        const lgM = Math.log2(this._gpu.pyramidMaxScale);\n        const pyrHeight = this._gpu.pyramidHeight;\n        const keypoints = [];\n        let x, y, scale, rotation, score;\n        let hasScale, hasRotation;\n\n        for(let i = 0; i < pixels.length; i += 4 /* RGBA */ * pixelsPerKeypoint) {\n            x = (pixels[i+1] << 8) | pixels[i];\n            y = (pixels[i+3] << 8) | pixels[i+2];\n            if(x >= w || y >= h)\n                break;\n\n            hasScale = (pixels[i+4] < 255);\n            scale = !hasScale ? 1.0 :\n                Math.pow(2.0, -lgM + (lgM + pyrHeight) * pixels[i+4] / 255.0);\n\n            hasRotation = hasScale; // FIXME get from parameter list?\n            rotation = !hasRotation ? 0.0 :\n                ((2 * pixels[i+5]) / 255.0 - 1.0) * PI;\n\n            score = pixels[i+6] / 255.0;\n\n            if(descriptorSize > 0) {\n                const bytes = new Uint8Array(pixels.slice(i+8, i+8 + descriptorSize));\n                const descriptor = new BinaryDescriptor(bytes);\n                keypoints.push(new SpeedyFeature(x, y, scale, rotation, score, descriptor));\n            }\n            else\n                keypoints.push(new SpeedyFeature(x, y, scale, rotation, score));\n        }\n\n        // developer's secret ;)\n        // reset the tuner\n        if(keypoints.length == 0) {\n            if(this._tuner.finished())\n                this._tuner.reset();\n        }\n\n        // done!\n        return keypoints;\n    }\n\n    /**\n     * Download RAW encoded keypoint data from the GPU - this is a bottleneck!\n     * @param {WebGLTexture} encodedKeypoints texture with keypoints that have already been encoded\n     * @param {bool} [useAsyncTransfer] transfer data from the GPU without blocking the CPU\n     * @returns {Promise<Uint8Array[]>} pixels in the [r,g,b,a, ...] format\n     */\n    async downloadEncodedKeypoints(encodedKeypoints, useAsyncTransfer = true)\n    {\n        try {\n            // helper shader for reading the data\n            this._downloadKeypoints(encodedKeypoints);\n\n            // read data from the GPU\n            let downloadTime = performance.now(), pixels;\n            if(useAsyncTransfer)\n                pixels = await this._downloadKeypoints.readPixelsAsync();\n            else\n                pixels = this._downloadKeypoints.readPixelsSync(); // bottleneck!\n            downloadTime = performance.now() - downloadTime;\n\n            // tuner: drop noisy feedback when the page loads\n            if(performance.now() >= this._spawnedAt + 2000)\n                this._tuner.feedObservation(downloadTime);\n\n            // debug\n            /*\n            window._p = window._p || 0;\n            window._m = window._m || 0;\n            window._m = 0.9 * window._m + 0.1 * downloadTime;\n            if(window._p++ % 50 == 0)\n                console.log(window._m, ' | ', maxIterations);\n            //console.log(JSON.stringify(this._tuner.info()));\n            */\n\n            // done!\n            return pixels;\n        }\n        catch(err) {\n            throw new IllegalOperationError(`Can't download encoded keypoint texture`, err);\n        }\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * filters.js\n * Image filtering on the GPU\n */\n\nimport { SpeedyProgramGroup } from '../speedy-program-group';\nimport { convX, convY, texConvX, texConvY, texConv2D, createKernel2D, createKernel1D } from '../shaders/filters/convolution';\n\n/**\n * GPUFilters\n * Image filtering\n */\nexport class GPUFilters extends SpeedyProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            // gaussian approximation (sigma approx. 1.0)\n            .compose('gauss5', '_gauss5x', '_gauss5y') // size: 5x5\n            .compose('gauss3', '_gauss3x', '_gauss3y') // size: 3x3\n            .compose('gauss7', '_gauss7x', '_gauss7y') // size: 7x7\n\n            // box filters\n            .compose('box5', '_box5x', '_box5y') // size: 5x5\n            .compose('box3', '_box3x', '_box3y') // size: 3x3\n            .compose('box7', '_box7x', '_box7y') // size: 7x7\n            .compose('box9', '_box9x', '_box9y') // size: 9x9\n            .compose('box11', '_box11x', '_box11y') // size: 11x11\n\n            // texture-based convolutions\n            .declare('texConv2D3', texConv2D(3), { // 2D convolution with a 3x3 texture-based kernel\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('texConv2D5', texConv2D(5), { // 2D convolution with a 5x5 texture-based kernel\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('texConv2D7', texConv2D(7), { // 2D convolution with a 7x7 texture-based kernel\n                ...this.program.usesPingpongRendering()\n            })\n\n            // texture-based separable convolutions\n            .compose('texConvXY3', 'texConvX3', 'texConvY3') // 2D convolution with same 1D separable kernel in both axes\n            .declare('texConvX3', texConvX(3)) // 3x1 convolution, x-axis\n            .declare('texConvY3', texConvY(3)) // 1x3 convolution, y-axis\n            .compose('texConvXY5', 'texConvX5', 'texConvY5') // 2D convolution with same 1D separable kernel in both axes\n            .declare('texConvX5', texConvX(5)) // 5x1 convolution, x-axis\n            .declare('texConvY5', texConvY(5)) // 1x5 convolution, y-axis\n            .compose('texConvXY7', 'texConvX7', 'texConvY7') // 2D convolution with same 1D separable kernel in both axes\n            .declare('texConvX7', texConvX(7)) // 7x1 convolution, x-axis\n            .declare('texConvY7', texConvY(7)) // 1x7 convolution, y-axis\n            .compose('texConvXY9', 'texConvX9', 'texConvY9') // 2D convolution with same 1D separable kernel in both axes\n            .declare('texConvX9', texConvX(9)) // 9x1 convolution, x-axis\n            .declare('texConvY9', texConvY(9)) // 1x9 convolution, y-axis\n            .compose('texConvXY11', 'texConvX11', 'texConvY11') // 2D convolution with same 1D separable kernel in both axes\n            .declare('texConvX11', texConvX(11)) // 11x1 convolution, x-axis\n            .declare('texConvY11', texConvY(11)) // 1x11 convolution, y-axis\n\n            // create custom convolution kernels\n            .declare('createKernel3x3', createKernel2D(3), { // 3x3 texture kernel\n                ...(this.program.hasTextureSize(3, 3)),\n                ...(this.program.doesNotRecycleTextures())\n            })\n            .declare('createKernel5x5', createKernel2D(5), { // 5x5 texture kernel\n                ...(this.program.hasTextureSize(5, 5)),\n                ...(this.program.doesNotRecycleTextures())\n            })\n            .declare('createKernel7x7', createKernel2D(7), { // 7x7 texture kernel\n                ...(this.program.hasTextureSize(7, 7)),\n                ...(this.program.doesNotRecycleTextures())\n            })\n            .declare('createKernel3x1', createKernel1D(3), { // 3x1 texture kernel\n                ...(this.program.hasTextureSize(3, 1)),\n                ...(this.program.doesNotRecycleTextures())\n            })\n            .declare('createKernel5x1', createKernel1D(5), { // 5x1 texture kernel\n                ...(this.program.hasTextureSize(5, 1)),\n                ...(this.program.doesNotRecycleTextures())\n            })\n            .declare('createKernel7x1', createKernel1D(7), { // 7x1 texture kernel\n                ...(this.program.hasTextureSize(7, 1)),\n                ...(this.program.doesNotRecycleTextures())\n            })\n            .declare('createKernel9x1', createKernel1D(9), { // 9x1 texture kernel\n                ...(this.program.hasTextureSize(9, 1)),\n                ...(this.program.doesNotRecycleTextures())\n            })\n            .declare('createKernel11x1', createKernel1D(11), { // 11x1 texture kernel\n                ...(this.program.hasTextureSize(11, 1)),\n                ...(this.program.doesNotRecycleTextures())\n            })\n            /*.declare('_readKernel3x3', identity, { // for testing\n                ...(this.program.hasTextureSize(3, 3)),\n                ...(this.program.displaysGraphics())\n            })\n            .declare('_readKernel3x1', identity, {\n                ...(this.program.hasTextureSize(3, 1)),\n                ...(this.program.displaysGraphics())\n            })*/\n\n\n\n\n            // separable kernels (Gaussian)\n            // see also: http://dev.theomader.com/gaussian-kernel-calculator/\n            .declare('_gauss5x', convX([\n                0.05, 0.25, 0.4, 0.25, 0.05\n                //0.006, 0.061, 0.242, 0.383, 0.242, 0.061, 0.006\n            ]))\n            .declare('_gauss5y', convY([\n                0.05, 0.25, 0.4, 0.25, 0.05\n                //0.006, 0.061, 0.242, 0.383, 0.242, 0.061, 0.006\n            ]))\n            .declare('_gauss3x', convX([\n                0.25, 0.5, 0.25\n                //0.27901, 0.44198, 0.27901\n            ]))\n            .declare('_gauss3y', convY([\n                0.25, 0.5, 0.25\n                //0.27901, 0.44198, 0.27901\n            ]))\n            .declare('_gauss7x', convX([\n                0.00598, 0.060626, 0.241843, 0.383103, 0.241843, 0.060626, 0.00598\n            ]))\n            .declare('_gauss7y', convY([\n                0.00598, 0.060626, 0.241843, 0.383103, 0.241843, 0.060626, 0.00598\n            ]))\n            /*.declare('_gauss5', conv2D([ // for testing\n                1, 4, 7, 4, 1,\n                4, 16, 26, 16, 4,\n                7, 26, 41, 26, 7,\n                4, 16, 26, 16, 4,\n                1, 4, 7, 4, 1,\n            ], 1 / 237))*/\n\n\n\n            // separable kernels (Box filter)\n            .declare('_box3x', convX([\n                1, 1, 1\n            ], 1 / 3))\n            .declare('_box3y', convY([\n                1, 1, 1\n            ], 1 / 3))\n            .declare('_box5x', convX([\n                1, 1, 1, 1, 1\n            ], 1 / 5))\n            .declare('_box5y', convY([\n                1, 1, 1, 1, 1\n            ], 1 / 5))\n            .declare('_box7x', convX([\n                1, 1, 1, 1, 1, 1, 1\n            ], 1 / 7))\n            .declare('_box7y', convY([\n                1, 1, 1, 1, 1, 1, 1\n            ], 1 / 7))\n            .declare('_box9x', convX([\n                1, 1, 1, 1, 1, 1, 1, 1, 1\n            ], 1 / 9))\n            .declare('_box9y', convY([\n                1, 1, 1, 1, 1, 1, 1, 1, 1\n            ], 1 / 9))\n            .declare('_box11x', convX([\n                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\n            ], 1 / 11))\n            .declare('_box11y', convY([\n                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\n            ], 1 / 11))\n        ;\n    }\n}\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * keypoints.js\n * Facade for various keypoint detection algorithms\n */\n\nimport { SpeedyProgramGroup } from '../speedy-program-group';\nimport { importShader } from '../shader-declaration';\n\n\n\n//\n// FAST corner detector\n//\n\n// FAST-9_16: requires 9 contiguous pixels\n// on a circumference of 16 pixels\nconst fast9 = importShader('keypoints/fast9lg.glsl').withArguments('image', 'threshold');\n\n// FAST-7_12: requires 7 contiguous pixels\n// on a circumference of 12 pixels\nconst fast7 = importShader('keypoints/fast7.glsl').withArguments('image', 'threshold');\n\n// FAST-5_8: requires 5 contiguous pixels\n// on a circumference of 8 pixels\nconst fast5 = importShader('keypoints/fast5.glsl').withArguments('image', 'threshold');\n\n// compute corner score considering a\n// neighboring circumference of 16 pixels\nconst fastScore16 = importShader('keypoints/fast-score16.glsl').withArguments('image', 'threshold');\n\n// compute corner score considering a\n// neighboring circumference of 12 pixels\nconst fastScore12 = importShader('keypoints/fast-score12.glsl').withArguments('image', 'threshold');\n\n// compute corner score considering a\n// neighboring circumference of 8 pixels\nconst fastScore8 = importShader('keypoints/fast-score8.glsl').withArguments('image', 'threshold');\n\n// FAST-9_16 on scale-space\n// Requires image mipmap\nconst multiscaleFast = importShader('keypoints/multiscale-fast.glsl')\n                      .withArguments('pyramid', 'threshold', 'numberOfOctaves');\n\n// FAST-9_16 on scale-space\n// with Harris scoring\nconst multiscaleFastWithHarris = importShader('keypoints/multiscale-fast.glsl')\n                                .withArguments('pyramid', 'threshold', 'numberOfOctaves')\n                                .withDefines({\n                                    'USE_HARRIS_SCORE': 1\n                                });\n\n\n\n//\n// Harris-Shi-Tomasi corner detector\n//\n\n// compute corner responses (score map)\nconst multiscaleHarris = importShader('keypoints/multiscale-harris.glsl')\n                        .withArguments('pyramid', 'windowRadius', 'numberOfOctaves', 'sobelDerivatives');\n\n// discard corners below a specified quality level\nconst harrisCutoff = importShader('keypoints/harris-cutoff.glsl').withArguments('corners', 'maxScore', 'quality');\n\n\n//\n// BRISK feature detection\n//\nconst brisk = importShader('keypoints/brisk.glsl')\n             .withArguments('image', 'layerA', 'layerB', 'scaleA', 'scaleB', 'lgM', 'h');\n\n\n\n//\n// Generic keypoint routines\n//\n\n// non-maximum suppression\nconst nonmaxSuppression = importShader('keypoints/nonmax-suppression.glsl').withArguments('image');\nconst multiscaleSuppression = importShader('keypoints/multiscale-suppression.glsl').withArguments('image');\nconst samescaleSuppression = importShader('keypoints/samescale-suppression.glsl').withArguments('image');\n\n// Sobel derivatives\nconst multiscaleSobel = importShader('keypoints/multiscale-sobel.glsl').withArguments('pyramid', 'lod');\n\n\n\n\n/**\n * GPUKeypoints\n * Keypoint detection\n */\nexport class GPUKeypoints extends SpeedyProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            // FAST-9,16\n            .compose('fast9', '_fast9', '_fastScore16')\n            .declare('_fast9', fast9) // find corners\n            .declare('_fastScore16', fastScore16) // compute scores\n\n            // FAST-7,12\n            .compose('fast7', '_fast7', '_fastScore12')\n            .declare('_fast7', fast7)\n            .declare('_fastScore12', fastScore12)\n\n            // FAST-5,8\n            .compose('fast5', '_fast5', '_fastScore8')\n            .declare('_fast5', fast5)\n            .declare('_fastScore8', fastScore8)\n\n            // FAST-9,16 (multi-scale)\n            .declare('multiscaleFast', multiscaleFast)\n            .declare('multiscaleFastWithHarris', multiscaleFastWithHarris)\n\n            // BRISK Scale-Space Non-Maximum Suppression & Interpolation\n            .declare('brisk', brisk)\n\n            // Harris-Shi-Tomasi corner detector\n            .declare('multiscaleHarris', multiscaleHarris) // scale-space\n            .declare('harrisCutoff', harrisCutoff)\n\n            // Generic non-maximum suppression\n            .declare('nonmaxSuppression', nonmaxSuppression)\n            .declare('multiscaleSuppression', multiscaleSuppression) // scale-space\n            .declare('samescaleSuppression', samescaleSuppression) // scale-space\n\n            // Sobel derivatives\n            .declare('multiscaleSobel', multiscaleSobel, {\n                ...this.program.doesNotRecycleTextures()\n            }) // scale-space\n        ;\n    }\n}\n\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * pyramids.js\n * Image pyramids\n */\n\nimport { SpeedyProgramGroup } from '../speedy-program-group';\nimport { importShader, createShader } from '../shader-declaration';\nimport { PYRAMID_MAX_LEVELS, PYRAMID_MAX_SCALE } from '../../utils/globals';\nimport { convX, convY } from '../shaders/filters/convolution';\n\n\n\n//\n// Shaders\n//\n\n// pyramid generation\nconst upsample2 = importShader('pyramids/upsample2.glsl').withArguments('image');\nconst downsample2 = importShader('pyramids/downsample2.glsl').withArguments('image');\nconst upsample3 = importShader('pyramids/upsample3.glsl').withArguments('image');\nconst downsample3 = importShader('pyramids/downsample3.glsl').withArguments('image');\n\n// utilities for merging keypoints across multiple scales\nconst mergeKeypoints = importShader('pyramids/merge-keypoints.glsl').withArguments('target', 'source');\nconst mergeKeypointsAtConsecutiveLevels = importShader('pyramids/merge-keypoints-at-consecutive-levels.glsl').withArguments('largerImage', 'smallerImage');\nconst normalizeKeypoints = importShader('pyramids/normalize-keypoints.glsl').withArguments('image', 'imageScale');\n\n// misc\nconst crop = importShader('pyramids/crop.glsl').withArguments('image');\nconst flipY = importShader('utils/flip-y.glsl').withArguments('image');\n\n\n\n/**\n * GPUPyramids\n * Image pyramids\n */\nexport class GPUPyramids extends SpeedyProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            // initialize pyramid\n            .declare('setBase', setScale(1.0))\n \n            // pyramid operations\n            .compose('reduce', '_smoothX', '_smoothY', '_downsample2', '_scale1/2')\n            .compose('expand', '_upsample2', '_smoothX2', '_smoothY2', '_scale2')\n           \n            // intra-pyramid operations (between two pyramid levels)\n            .compose('intraReduce', '_upsample2', '_smoothX2', '_smoothY2', '_downsample3/2', '_scale2/3')\n            .compose('intraExpand', '_upsample3', '_smoothX3', '_smoothY3', '_downsample2/3', '_scale3/2')\n\n            // Merge keypoints across multiple scales\n            .declare('mergeKeypoints', mergeKeypoints)\n            .declare('mergeKeypointsAtConsecutiveLevels', mergeKeypointsAtConsecutiveLevels)\n            .declare('normalizeKeypoints', normalizeKeypoints)\n\n            // Crop texture to width x height of the current pyramid level\n            .declare('crop', crop)\n\n            // kernels for debugging\n            .declare('output', flipY, {\n                ...this.program.hasTextureSize(this._width, this._height),\n                ...this.program.displaysGraphics()\n            })\n\n            .declare('output2', flipY, {\n                ...this.program.hasTextureSize(2 * this._width, 2 * this._height),\n                ...this.program.displaysGraphics()\n            })\n\n            .declare('output3', flipY, {\n                ...this.program.hasTextureSize(3 * this._width, 3 * this._height),\n                ...this.program.displaysGraphics()\n            })\n\n\n            \n            // separable kernels for gaussian smoothing\n            // use [c, b, a, b, c] where a+2c = 2b and a+2b+2c = 1\n            // pick a = 0.4 for gaussian approximation\n            .declare('_smoothX', convX([\n                0.05, 0.25, 0.4, 0.25, 0.05\n            ]))\n            .declare('_smoothY', convY([\n                0.05, 0.25, 0.4, 0.25, 0.05\n            ]))\n\n            // smoothing for 2x image\n            // same rules as above with sum(k) = 2\n            .declare('_smoothX2', convX([\n                0.1, 0.5, 0.8, 0.5, 0.1\n            ]), this.program.hasTextureSize(2 * this._width, 2 * this._height))\n\n            .declare('_smoothY2', convY([\n                0.1, 0.5, 0.8, 0.5, 0.1\n            ], 1.0 / 2.0), this.program.hasTextureSize(2 * this._width, 2 * this._height))\n\n            // smoothing for 3x image\n            // use [1-b, b, 1, b, 1-b], where 0 < b < 1\n            .declare('_smoothX3', convX([\n                0.2, 0.8, 1.0, 0.8, 0.2\n            ]), this.program.hasTextureSize(3 * this._width, 3 * this._height))\n\n            .declare('_smoothY3', convY([\n                0.2, 0.8, 1.0, 0.8, 0.2\n            ], 1.0 / 3.0), this.program.hasTextureSize(3 * this._width, 3 * this._height))\n\n            // upsampling & downsampling\n            .declare('_upsample2', upsample2,\n                this.program.hasTextureSize(2 * this._width, 2 * this._height))\n\n            .declare('_downsample2', downsample2,\n                this.program.hasTextureSize((1 + this._width) / 2, (1 + this._height) / 2))\n\n            .declare('_upsample3', upsample3,\n                this.program.hasTextureSize(3 * this._width, 3 * this._height))\n\n            .declare('_downsample3', downsample3,\n                this.program.hasTextureSize((2 + this._width) / 3, (2 + this._height) / 3))\n\n            .declare('_downsample2/3', downsample2,\n                this.program.hasTextureSize(3 * this._width / 2, 3 * this._height / 2))\n\n            .declare('_downsample3/2', downsample3,\n                this.program.hasTextureSize(2 * this._width / 3, 2 * this._height / 3))\n\n            // adjust the scale coefficients\n            .declare('_scale2', scale(2.0),\n                this.program.hasTextureSize(2 * this._width, 2 * this._height))\n\n            .declare('_scale1/2', scale(0.5),\n                this.program.hasTextureSize((1 + this._width) / 2, (1 + this._height) / 2))\n\n            .declare('_scale3/2', scale(1.5),\n                this.program.hasTextureSize(3 * this._width / 2, 3 * this._height / 2))\n\n            .declare('_scale2/3', scale(2.0 / 3.0),\n                this.program.hasTextureSize(2 * this._width / 3, 2 * this._height / 3))\n        ;\n    }\n}\n\n\n\n\n/*\n * Image scale is encoded in the alpha channel (a)\n * according to the following model:\n *\n * a(x) = (log2(M) - log2(x)) / (log2(M) + h)\n *\n * where x := scale of the image in the pyramid\n *            it may be 1, 0.5, 0.25, 0.125...\n *            also sqrt(2)/2, sqrt(2)/4... (intra-layers)\n *            (note that lod = -log2(x))\n *\n *       h := height (depth) of the pyramid, an integer\n *            (i.e., PYRAMID_MAX_LEVELS)\n *\n *       M := scale upper bound: the maximum supported\n *            scale x for a pyramid layer, a constant\n *            that is preferably a power of two\n *            (i.e., PYRAMID_MAX_SCALE)\n *\n *\n *\n * This model has neat properties:\n *\n * Scale image by factor s:\n * a(s*x) = a(x) - log2(s) / (log2(M) + h)\n *\n * Log of scale (scale-axis):\n * log2(x) = log2(M) - (log2(M) + h) * a(x)\n *\n * Bounded output:\n * 0 <= a(x) < 1\n *\n * Since x <= M, it follows that a(x) >= 0 for all x\n * Since x > 1/2^h, it follows that a(x) < 1 for all x\n * Thus, if alpha channel = 1.0, we have no scale data\n *\n *\n *\n * A note on image scale:\n *\n * scale = 1 means an image with its original size\n * scale = 2 means double the size (4x the area)\n * scale = 0.5 means half the size (1/4 the area)\n * and so on...\n */\n\n// Set image scale\nfunction setScale(scale)\n{\n    const lgM = Math.log2(PYRAMID_MAX_SCALE), eps = 1e-5;\n    const pyramidMinScale = Math.pow(2, -PYRAMID_MAX_LEVELS) + eps;\n    const x = Math.max(pyramidMinScale, Math.min(scale, PYRAMID_MAX_SCALE));\n    const alpha = (lgM - Math.log2(x)) / (lgM + PYRAMID_MAX_LEVELS);\n    \n    const source = `\n    uniform sampler2D image;\n\n    void main()\n    {\n        color = vec4(threadPixel(image).rgb, float(${alpha}));\n    }\n    `;\n\n    return createShader(source).withArguments('image');\n}\n\n// Scale image by a factor\nfunction scale(scaleFactor)\n{\n    const lgM = Math.log2(PYRAMID_MAX_SCALE), eps = 1e-5;\n    const s = Math.max(eps, scaleFactor);\n    const delta = -Math.log2(s) / (lgM + PYRAMID_MAX_LEVELS);\n\n    const source = `\n    uniform sampler2D image;\n\n    void main()\n    {\n        vec4 pixel = threadPixel(image);\n        float alpha = clamp(pixel.a + float(${delta}), 0.0f, 1.0f);\n\n        color = vec4(pixel.rgb, alpha);\n    }\n    `;\n\n    return createShader(source).withArguments('image');\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * utils.js\n * GPU utilities\n */\n\nimport { SpeedyProgramGroup } from '../speedy-program-group';\nimport { importShader } from '../shader-declaration';\nimport { GLUtils } from '../gl-utils';\nimport { PixelComponent, ColorComponentId } from '../../utils/types';\nimport { IllegalArgumentError } from '../../utils/errors';\n\n\n\n//\n// Shaders\n//\n\n// Identity shader: no-operation\nconst identity = importShader('utils/identity.glsl').withArguments('image');\n\n// Flip y-axis for output\nconst flipY = importShader('utils/flip-y.glsl').withArguments('image');\n\n// Fill image with a constant\nconst fill = importShader('utils/fill.glsl').withArguments('value');\n\n// Fill zero or more color components of the input image with a constant value\nconst fillComponents = importShader('utils/fill-components.glsl').withArguments('image', 'pixelComponents', 'value');\n\n// Copy the src component of src to zero or more color components of a copy of dest\nconst copyComponents = importShader('utils/copy-components.glsl').withArguments('dest', 'src', 'destComponents', 'srcComponentId');\n\n// Scan the entire image and find the minimum & maximum pixel intensity for each row and column\n//const scanMinMax1D = importShader('utils/scan-minmax1d.glsl').withArguments('image', 'iterationNumber');\n\n// Scan the entire image and find the minimum & maximum pixel intensity\nconst scanMinMax2D = importShader('utils/scan-minmax2d.glsl').withArguments('image', 'iterationNumber');\n\n// Normalize a greyscale image\nconst normalizeGreyscaleImage = importShader('utils/normalize-image.glsl')\n                               .withArguments('minmax2d', 'minValue', 'maxValue')\n                               .withDefines({\n                                   'GREYSCALE': 1\n                               });\n\n// Normalize a colored image\nconst normalizeColoredImage = importShader('utils/normalize-image.glsl')\n                             .withArguments('minmax2dRGB', 'minValue', 'maxValue');\n\n\n\n/**\n * GPUUtils\n * Utility operations\n */\nexport class GPUUtils extends SpeedyProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            // no-operation\n            .declare('identity', identity)\n\n            // flip y-axis\n            .declare('flipY', flipY)\n\n            // output a texture from a pipeline\n            .declare('output', flipY, {\n                ...this.program.displaysGraphics()\n            })\n                \n            // clone a texture (release it afterwards)\n            .declare('clone', identity, {\n                ...this.program.doesNotRecycleTextures()\n            })\n\n            // Fill image with a constant\n            .declare('fill', fill)\n\n            // Fill zero or more color components of the input image with a constant value\n            .declare('fillComponents', fillComponents)\n\n            // Copy the src component of src to zero or more color components of a copy of dest\n            .declare('_copyComponents', copyComponents)\n\n            // find minimum & maximum pixel intensity for each row and column\n            /*.declare('_scanMinMax1D', scanMinMax1D, {\n                ...this.program.usesPingpongRendering()\n            })*/\n\n            // find minimum & maximum pixel intensity\n            .declare('_scanMinMax2D', scanMinMax2D, {\n                ...this.program.usesPingpongRendering()\n            })\n\n            // normalize a greyscale image\n            .declare('_normalizeGreyscaleImage', normalizeGreyscaleImage)\n\n            // normalize a colored image\n            .declare('_normalizeColoredImage', normalizeColoredImage)\n        ;\n    }\n\n    /**\n     * Release a texture\n     * @param {WebGLTexture} texture \n     * @returns {null}\n     */\n    release(texture)\n    {\n        return GLUtils.destroyTexture(this._gpu.gl, texture);\n    }\n\n    /**\n     * Generate a pyramid for a texture\n     * @param {WebGLTexture} texture\n     * @returns {WebGLTexture} the input texture\n     */\n    generatePyramid(texture)\n    {\n        GLUtils.generateMipmap(this._gpu.gl, texture);\n        return texture;\n    }\n\n    /**\n     * Scan a single component in all pixels of the image and find the maximum intensity\n     * @param {WebGLTexture} image \n     * @param {number} pixelComponent a single PixelComponent flag\n     * @returns {WebGLTexture} such that pixel[component] = max(image_pixel[component])\n     *                                                           for all image_pixels\n     */\n    scanMax(image, pixelComponent)\n    {\n        const minmax2d = this._scanMinMax(image, pixelComponent);\n        return this.copyComponents(image, minmax2d, pixelComponent, PixelComponent.RED);\n    }\n\n    /**\n     * Scan a single component in all pixels of the image and find the minimum intensity\n     * @param {WebGLTexture} image \n     * @param {number} pixelComponent a single PixelComponent flag\n     * @returns {WebGLTexture} such that pixel[component] = min(image_pixel[component])\n     *                                                           for all image_pixels\n     */\n    scanMin(image, pixelComponent)\n    {\n        const minmax2d = this._scanMinMax(image, pixelComponent);\n        return this.copyComponents(image, minmax2d, pixelComponent, PixelComponent.GREEN);\n    }\n\n    /**\n     * Copy color component\n     * @param {WebGLTexture} dest\n     * @param {WebGLTexture} src \n     * @param {number} destComponents one or more PixelComponent flags\n     * @param {number} srcComponent a single PixelComponent flag\n     * @returns {WebGLTexture} a copy of dest with its destComponents replaced by the srcComponent of src\n     */\n    copyComponents(dest, src, destComponents, srcComponent)\n    {\n        if(!ColorComponentId.hasOwnProperty(srcComponent))\n            throw new IllegalArgumentError(`Invalid srcComponent: ${srcComponent}`)\n\n        const srcComponentId = ColorComponentId[srcComponent];\n        return this._copyComponents(dest, src, destComponents, srcComponentId);\n    }\n\n    /**\n     * Normalize a greyscale image\n     * @param {WebGLTexture} image greyscale image (RGB components are the same)\n     * @param {number} [minValue] minimum desired pixel intensity (from 0 to 255, inclusive)\n     * @param {number} [maxValue] maximum desired pixel intensity (from 0 to 255, inclusive)\n     */\n    normalizeGreyscaleImage(image, minValue = 0, maxValue = 255)\n    {\n        const minmax2d = this._scanMinMax(image, PixelComponent.GREEN);\n        return this._normalizeGreyscaleImage(minmax2d, Math.min(minValue, maxValue), Math.max(minValue, maxValue));\n    }\n\n    /**\n     * Normalize a RGB image\n     * @param {WebGLTexture} image\n     * @param {number} [minValue] minimum desired pixel intensity (from 0 to 255, inclusive)\n     * @param {number} [maxValue] maximum desired pixel intensity (from 0 to 255, inclusive)\n     */\n    normalizeColoredImage(image, minValue = 0, maxValue = 255)\n    {\n        // TODO: normalize on a luminance channel instead (e.g., use HSL color space)\n        const minmax2d = new Array(3);\n        minmax2d[0] = this.clone(this._scanMinMax(image, PixelComponent.RED));\n        minmax2d[1] = this.clone(this._scanMinMax(image, PixelComponent.GREEN));\n        minmax2d[2] = this._scanMinMax(image, PixelComponent.BLUE);\n\n        const normalized = this._normalizeColoredImage(minmax2d, Math.min(minValue, maxValue), Math.max(minValue, maxValue));\n\n        this.release(minmax2d[1]);\n        this.release(minmax2d[0]);\n\n        return normalized;\n    }\n\n    /**\n     * Scan a single component in all pixels of the image and find the min & max intensities\n     * @param {WebGLTexture} image \n     * @param {number} pixelComponent a single PixelComponent flag\n     * @returns {WebGLTexture} RGBA = (max, min, max - min, original_pixel)\n     */\n    _scanMinMax(image, pixelComponent)\n    {\n        //\n        // FIXME: combinations of PixelComponent (e.g., PixelComponent.ALL)\n        //        are currently unsupported. Make separate calls.\n        //\n        const numIterations = Math.ceil(Math.log2(Math.max(this._width, this._height))) | 0;\n        let texture = this.copyComponents(image, image, PixelComponent.ALL, pixelComponent);\n\n        for(let i = 0; i < numIterations; i++)\n            texture = this._scanMinMax2D(texture, i);\n\n        return texture;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * shader-declaration.js\n * Encapsulates a shader declaration\n */\n\nimport { ShaderPreprocessor } from './shader-preprocessor';\nimport { FileNotFoundError, IllegalArgumentError, ParseError } from '../utils/errors';\n\nconst ATTRIB_POSITION = 'a_position';\nconst ATTRIB_TEXCOORD = 'a_texCoord';\n\nconst DEFAULT_VERTEX_SHADER = `#version 300 es\nin vec2 ${ATTRIB_POSITION};\nin vec2 ${ATTRIB_TEXCOORD};\nout vec2 texCoord;\n\nvoid main() {\n    gl_Position = vec4(${ATTRIB_POSITION}, 0.0, 1.0);\n    texCoord = ${ATTRIB_TEXCOORD};\n}`;\n\nconst DEFAULT_FRAGMENT_SHADER_PREFIX = `#version 300 es\nprecision highp int;\nprecision mediump float;\nprecision mediump sampler2D;\n\nout vec4 color;\nin vec2 texCoord;\nuniform vec2 texSize;\n\n@include \"global.glsl\"\\n`;\n\n/**\n * Shader Declaration\n */\nclass ShaderDeclaration\n{\n    /* private */ constructor(options)\n    {\n        const filepath = options.filepath || null;\n        const source = filepath ? require('./shaders/' + filepath) : (options.source || '');\n\n        this._userSource = source;\n        this._fragmentSource = ShaderPreprocessor.run(DEFAULT_FRAGMENT_SHADER_PREFIX + source);\n        this._vertexSource = ShaderPreprocessor.run(DEFAULT_VERTEX_SHADER);\n        this._filepath = filepath || '<in-memory>';\n        this._uniform = this._autodetectUniforms(this._fragmentSource);\n        this._arguments = [];\n    }\n\n    /**\n     * Creates a new Shader directly from a GLSL source\n     * @param {string} source\n     * @returns {Shader}\n     */\n    static create(source)\n    {\n        return new ShaderDeclaration({ source });\n    }\n\n    /**\n     * Import a Shader from a file containing a GLSL source\n     * @param {string} filepath path to .glsl file relative to the shaders/ folder\n     * @returns {Shader}\n     */\n    static import(filepath)\n    {\n        if(!String(filepath).match(/^[a-zA-Z0-9_\\-\\/]+\\.glsl$/))\n            throw new FileNotFoundError(`Can't import shader: \"${filepath}\"`);\n\n        return new ShaderDeclaration({ filepath });\n    }\n\n    /**\n     * Specify the list & order of arguments to be\n     * passed to the shader\n     * @param  {...string} args argument names\n     * @returns {ShaderDeclaration} this\n     */\n    withArguments(...args)\n    {\n        // get arguments\n        this._arguments = args.map(arg => String(arg));\n\n        // validate\n        for(const argname of this._arguments) {\n            if(!this._uniform.hasOwnProperty(argname)) {\n                if(!this._uniform.hasOwnProperty(argname + '[0]'))\n                    throw new IllegalArgumentError(`Argument \"${argname}\" has not been declared in the shader`);\n            }\n        }\n\n        // done!\n        return this;\n    }\n\n    /**\n     * Specify a set of #defines to be prepended to\n     * the fragment shader\n     * @param {object} defines key-value pairs (define-name: define-value)\n     * @returns {ShaderDeclaration} this\n     */\n    withDefines(defines)\n    {\n        // write the #defines\n        const defs = [];\n        for(const key of Object.keys(defines))\n            defs.push(`#define ${key} ${defines[key]}\\n`);\n\n        // change the fragment shader\n        const source = DEFAULT_FRAGMENT_SHADER_PREFIX + defs.join('') + this._userSource;\n        this._fragmentSource = ShaderPreprocessor.run(source);\n\n        // done!\n        return this;\n    }\n\n    /**\n     * Return the GLSL source of the fragment shader\n     * @returns {string}\n     */\n    get fragmentSource()\n    {\n        return this._fragmentSource;\n    }\n\n    /**\n     * Return the GLSL source of the vertex shader\n     * @returns {string}\n     */\n    get vertexSource()\n    {\n        return this._vertexSource;\n    }\n\n    /**\n     * Get the names of the vertex shader attributes\n     * @returns {object}\n     */\n    get attributes()\n    {\n        return ShaderDeclaration._attr || (ShaderDeclaration._attr = Object.freeze({\n            position: ATTRIB_POSITION,\n            texCoord: ATTRIB_TEXCOORD,\n        }));\n    }\n\n    /**\n     * Names of the arguments that will be passed to the Shader,\n     * corresponding to GLSL uniforms, in the order they will be passed\n     * @returns {Array<string>}\n     */\n    get arguments()\n    {\n        return this._arguments;\n    }\n\n    /**\n     * Names of the uniforms declared in the shader\n     * @returns {Array<string>}\n     */\n    get uniforms()\n    {\n        return Object.keys(this._uniform);\n    }\n\n    /**\n     * The GLSL type of an uniform variable declared in the shader\n     * @param {string} name\n     * @returns {string}\n     */\n    uniformType(name)\n    {\n        if(!this._uniform.hasOwnProperty(name))\n            throw new IllegalArgumentError(`Unrecognized uniform variable: \"${name}\"`);\n\n        return this._uniform[name];\n    }\n\n    /**\n     * Parses a GLSL source and detects the uniform variables,\n     * as well as their types\n     * @param {string} preprocessedSource \n     * @returns {object} specifies the types of all uniforms\n     */\n    _autodetectUniforms(preprocessedSource)\n    {\n        const sourceWithoutComments = preprocessedSource; // assume we've preprocessed the source already\n        const regex = /uniform\\s+(highp\\s+|mediump\\s+|lowp\\s+)?(\\w+)\\s+([^;]+)/g;\n        const uniforms = { };\n\n        let match;\n        while((match = regex.exec(sourceWithoutComments)) !== null) {\n            const type = match[2];\n            const names = match[3].split(',').map(name => name.trim()).filter(name => name); // trim & remove empty names\n\n            for(const name of names) {\n                if(name.endsWith(']')) {\n                    // is it an array?\n                    if(!(match = name.match(/(\\w+)\\s*\\[\\s*(\\d+)\\s*\\]$/)))\n                        throw new ParseError(`Unspecified array length for uniform \"${name}\" in the shader`);\n                    const [ array, length ] = [ match[1], Number(match[2]) ];\n                    for(let i = 0; i < length; i++)\n                        uniforms[`${array}[${i}]`] = type;\n                }\n                else {\n                    // regular uniform\n                    uniforms[name] = type;\n                }\n            }\n        }\n\n        return Object.freeze(uniforms);\n    }\n}\n\n/**\n * Import a ShaderDeclaration from a GLSL file\n * @param {string} filepath relative to the shaders/ folder\n * @returns {ShaderDeclaration}\n */\nexport function importShader(filepath)\n{\n    return ShaderDeclaration.import(filepath);\n}\n\n/**\n * Create a ShaderDeclaration from a GLSL source\n * @param {string} source\n * @returns {ShaderDeclaration}\n */\nexport function createShader(source)\n{\n    return ShaderDeclaration.create(source);\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * shader-preprocessor.js\n * Custom preprocessor for shaders\n */\n\nimport { PYRAMID_MAX_LEVELS, PYRAMID_MAX_SCALE, PYRAMID_MAX_OCTAVES } from '../utils/globals';\nimport { PixelComponent } from '../utils/types';\nimport { FileNotFoundError } from '../utils/errors';\n\n// Regular Expressions\nconst commentsRegex = [ /\\/\\*(.|\\s)*?\\*\\//g , /\\/\\/.*$/gm ];\nconst includeRegex = /^\\s*@\\s*include\\s+\"(.*?)\"/gm;\nconst constantRegex = /@(\\w+)@/g;\n\n// Constant values accessible inside the shaders\nconst constants = {\n    // pyramids\n    'PYRAMID_MAX_LEVELS': PYRAMID_MAX_LEVELS,\n    'LOG2_PYRAMID_MAX_SCALE': Math.log2(PYRAMID_MAX_SCALE),\n    'PYRAMID_MAX_OCTAVES': PYRAMID_MAX_OCTAVES,\n\n    // colors\n    'PIXELCOMPONENT_RED': PixelComponent.RED,\n    'PIXELCOMPONENT_GREEN': PixelComponent.GREEN,\n    'PIXELCOMPONENT_BLUE': PixelComponent.BLUE,\n    'PIXELCOMPONENT_ALPHA': PixelComponent.ALPHA,\n};\n\n/**\n * Custom preprocessor for shaders\n */\nexport class ShaderPreprocessor\n{\n    /**\n     * Runs the preprocessor\n     * @param {string} code \n     * @returns {string} preprocessed code\n     */\n    static run(code)\n    {\n        // remove comments and run the preprocessor\n        return String(code).replace(commentsRegex[0], '')\n                           .replace(commentsRegex[1], '')\n                           .replace(includeRegex, (_, filename) =>\n                                // FIXME: no cycle detection for @include\n                                ShaderPreprocessor.run(readfileSync(filename))\n                            )\n                            .replace(constantRegex, (_, name) =>\n                                String(constants[name] || 'UNDEFINED_CONSTANT')\n                            );\n    }\n}\n\n /**\n * Reads a shader from the shaders/include/ folder\n * @param {string} filename\n * @returns {string}\n */\nfunction readfileSync(filename)\n{\n    if(String(filename).match(/^[a-zA-Z0-9_\\-]+\\.glsl$/))\n        return require('./shaders/include/' + filename);\n\n    throw new FileNotFoundError(`Shader preprocessor: can't read file \\\"${filename}\\\"`);\n}","var map = {\n\t\"./colors/rgb2grey.glsl\": \"./src/gpu/shaders/colors/rgb2grey.glsl\",\n\t\"./descriptors/orb.glsl\": \"./src/gpu/shaders/descriptors/orb.glsl\",\n\t\"./encoders/encode-keypoint-offsets.glsl\": \"./src/gpu/shaders/encoders/encode-keypoint-offsets.glsl\",\n\t\"./encoders/encode-keypoints.glsl\": \"./src/gpu/shaders/encoders/encode-keypoints.glsl\",\n\t\"./encoders/orient-encoded-keypoints.glsl\": \"./src/gpu/shaders/encoders/orient-encoded-keypoints.glsl\",\n\t\"./filters/convolution\": \"./src/gpu/shaders/filters/convolution.js\",\n\t\"./filters/convolution.js\": \"./src/gpu/shaders/filters/convolution.js\",\n\t\"./include/colors.glsl\": \"./src/gpu/shaders/include/colors.glsl\",\n\t\"./include/global.glsl\": \"./src/gpu/shaders/include/global.glsl\",\n\t\"./include/math.glsl\": \"./src/gpu/shaders/include/math.glsl\",\n\t\"./include/orientation.glsl\": \"./src/gpu/shaders/include/orientation.glsl\",\n\t\"./include/pyramids.glsl\": \"./src/gpu/shaders/include/pyramids.glsl\",\n\t\"./include/sobel.glsl\": \"./src/gpu/shaders/include/sobel.glsl\",\n\t\"./keypoints/brisk.glsl\": \"./src/gpu/shaders/keypoints/brisk.glsl\",\n\t\"./keypoints/fast-score12.glsl\": \"./src/gpu/shaders/keypoints/fast-score12.glsl\",\n\t\"./keypoints/fast-score16.glsl\": \"./src/gpu/shaders/keypoints/fast-score16.glsl\",\n\t\"./keypoints/fast-score8.glsl\": \"./src/gpu/shaders/keypoints/fast-score8.glsl\",\n\t\"./keypoints/fast5.glsl\": \"./src/gpu/shaders/keypoints/fast5.glsl\",\n\t\"./keypoints/fast7.glsl\": \"./src/gpu/shaders/keypoints/fast7.glsl\",\n\t\"./keypoints/fast9lg.glsl\": \"./src/gpu/shaders/keypoints/fast9lg.glsl\",\n\t\"./keypoints/harris-cutoff.glsl\": \"./src/gpu/shaders/keypoints/harris-cutoff.glsl\",\n\t\"./keypoints/multiscale-fast.glsl\": \"./src/gpu/shaders/keypoints/multiscale-fast.glsl\",\n\t\"./keypoints/multiscale-harris.glsl\": \"./src/gpu/shaders/keypoints/multiscale-harris.glsl\",\n\t\"./keypoints/multiscale-sobel.glsl\": \"./src/gpu/shaders/keypoints/multiscale-sobel.glsl\",\n\t\"./keypoints/multiscale-suppression.glsl\": \"./src/gpu/shaders/keypoints/multiscale-suppression.glsl\",\n\t\"./keypoints/nonmax-suppression.glsl\": \"./src/gpu/shaders/keypoints/nonmax-suppression.glsl\",\n\t\"./keypoints/samescale-suppression.glsl\": \"./src/gpu/shaders/keypoints/samescale-suppression.glsl\",\n\t\"./pyramids/crop.glsl\": \"./src/gpu/shaders/pyramids/crop.glsl\",\n\t\"./pyramids/downsample2.glsl\": \"./src/gpu/shaders/pyramids/downsample2.glsl\",\n\t\"./pyramids/downsample3.glsl\": \"./src/gpu/shaders/pyramids/downsample3.glsl\",\n\t\"./pyramids/merge-keypoints-at-consecutive-levels.glsl\": \"./src/gpu/shaders/pyramids/merge-keypoints-at-consecutive-levels.glsl\",\n\t\"./pyramids/merge-keypoints.glsl\": \"./src/gpu/shaders/pyramids/merge-keypoints.glsl\",\n\t\"./pyramids/normalize-keypoints.glsl\": \"./src/gpu/shaders/pyramids/normalize-keypoints.glsl\",\n\t\"./pyramids/upsample2.glsl\": \"./src/gpu/shaders/pyramids/upsample2.glsl\",\n\t\"./pyramids/upsample3.glsl\": \"./src/gpu/shaders/pyramids/upsample3.glsl\",\n\t\"./utils/copy-components.glsl\": \"./src/gpu/shaders/utils/copy-components.glsl\",\n\t\"./utils/fill-components.glsl\": \"./src/gpu/shaders/utils/fill-components.glsl\",\n\t\"./utils/fill.glsl\": \"./src/gpu/shaders/utils/fill.glsl\",\n\t\"./utils/flip-y.glsl\": \"./src/gpu/shaders/utils/flip-y.glsl\",\n\t\"./utils/identity.glsl\": \"./src/gpu/shaders/utils/identity.glsl\",\n\t\"./utils/normalize-image.glsl\": \"./src/gpu/shaders/utils/normalize-image.glsl\",\n\t\"./utils/scan-minmax2d.glsl\": \"./src/gpu/shaders/utils/scan-minmax2d.glsl\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./src/gpu/shaders sync recursive ^\\\\.\\\\/.*$\";","module.exports = \"const vec4 grey = vec4(0.299f, 0.587f, 0.114f, 0.0f);\\nuniform sampler2D image;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nfloat g = dot(pixel, grey);\\ncolor = vec4(g, g, g, 1.0f);\\n}\"","module.exports = \"@include \\\"math.glsl\\\"\\n@include \\\"pyramids.glsl\\\"\\n@include \\\"orientation.glsl\\\"\\nuniform sampler2D encodedCorners;\\nuniform int encoderLength;\\nuniform sampler2D pyramid;\\nconst int descriptorSize = 32;\\nconst int pixelsPerKeypoint = 10;\\nconst ivec4 pat31[256] = ivec4[256](\\nivec4(8,-3,9,5),\\nivec4(4,2,7,-12),\\nivec4(-11,9,-8,2),\\nivec4(7,-12,12,-13),\\nivec4(2,-13,2,12),\\nivec4(1,-7,1,6),\\nivec4(-2,-10,-2,-4),\\nivec4(-13,-13,-11,-8),\\nivec4(-13,-3,-12,-9),\\nivec4(10,4,11,9),\\nivec4(-13,-8,-8,-9),\\nivec4(-11,7,-9,12),\\nivec4(7,7,12,6),\\nivec4(-4,-5,-3,0),\\nivec4(-13,2,-12,-3),\\nivec4(-9,0,-7,5),\\nivec4(12,-6,12,-1),\\nivec4(-3,6,-2,12),\\nivec4(-6,-13,-4,-8),\\nivec4(11,-13,12,-8),\\nivec4(4,7,5,1),\\nivec4(5,-3,10,-3),\\nivec4(3,-7,6,12),\\nivec4(-8,-7,-6,-2),\\nivec4(-2,11,-1,-10),\\nivec4(-13,12,-8,10),\\nivec4(-7,3,-5,-3),\\nivec4(-4,2,-3,7),\\nivec4(-10,-12,-6,11),\\nivec4(5,-12,6,-7),\\nivec4(5,-6,7,-1),\\nivec4(1,0,4,-5),\\nivec4(9,11,11,-13),\\nivec4(4,7,4,12),\\nivec4(2,-1,4,4),\\nivec4(-4,-12,-2,7),\\nivec4(-8,-5,-7,-10),\\nivec4(4,11,9,12),\\nivec4(0,-8,1,-13),\\nivec4(-13,-2,-8,2),\\nivec4(-3,-2,-2,3),\\nivec4(-6,9,-4,-9),\\nivec4(8,12,10,7),\\nivec4(0,9,1,3),\\nivec4(7,-5,11,-10),\\nivec4(-13,-6,-11,0),\\nivec4(10,7,12,1),\\nivec4(-6,-3,-6,12),\\nivec4(10,-9,12,-4),\\nivec4(-13,8,-8,-12),\\nivec4(-13,0,-8,-4),\\nivec4(3,3,7,8),\\nivec4(5,7,10,-7),\\nivec4(-1,7,1,-12),\\nivec4(3,-10,5,6),\\nivec4(2,-4,3,-10),\\nivec4(-13,0,-13,5),\\nivec4(-13,-7,-12,12),\\nivec4(-13,3,-11,8),\\nivec4(-7,12,-4,7),\\nivec4(6,-10,12,8),\\nivec4(-9,-1,-7,-6),\\nivec4(-2,-5,0,12),\\nivec4(-12,5,-7,5),\\nivec4(3,-10,8,-13),\\nivec4(-7,-7,-4,5),\\nivec4(-3,-2,-1,-7),\\nivec4(2,9,5,-11),\\nivec4(-11,-13,-5,-13),\\nivec4(-1,6,0,-1),\\nivec4(5,-3,5,2),\\nivec4(-4,-13,-4,12),\\nivec4(-9,-6,-9,6),\\nivec4(-12,-10,-8,-4),\\nivec4(10,2,12,-3),\\nivec4(7,12,12,12),\\nivec4(-7,-13,-6,5),\\nivec4(-4,9,-3,4),\\nivec4(7,-1,12,2),\\nivec4(-7,6,-5,1),\\nivec4(-13,11,-12,5),\\nivec4(-3,7,-2,-6),\\nivec4(7,-8,12,-7),\\nivec4(-13,-7,-11,-12),\\nivec4(1,-3,12,12),\\nivec4(2,-6,3,0),\\nivec4(-4,3,-2,-13),\\nivec4(-1,-13,1,9),\\nivec4(7,1,8,-6),\\nivec4(1,-1,3,12),\\nivec4(9,1,12,6),\\nivec4(-1,-9,-1,3),\\nivec4(-13,-13,-10,5),\\nivec4(7,7,10,12),\\nivec4(12,-5,12,9),\\nivec4(6,3,7,11),\\nivec4(5,-13,6,10),\\nivec4(2,-12,2,3),\\nivec4(3,8,4,-6),\\nivec4(2,6,12,-13),\\nivec4(9,-12,10,3),\\nivec4(-8,4,-7,9),\\nivec4(-11,12,-4,-6),\\nivec4(1,12,2,-8),\\nivec4(6,-9,7,-4),\\nivec4(2,3,3,-2),\\nivec4(6,3,11,0),\\nivec4(3,-3,8,-8),\\nivec4(7,8,9,3),\\nivec4(-11,-5,-6,-4),\\nivec4(-10,11,-5,10),\\nivec4(-5,-8,-3,12),\\nivec4(-10,5,-9,0),\\nivec4(8,-1,12,-6),\\nivec4(4,-6,6,-11),\\nivec4(-10,12,-8,7),\\nivec4(4,-2,6,7),\\nivec4(-2,0,-2,12),\\nivec4(-5,-8,-5,2),\\nivec4(7,-6,10,12),\\nivec4(-9,-13,-8,-8),\\nivec4(-5,-13,-5,-2),\\nivec4(8,-8,9,-13),\\nivec4(-9,-11,-9,0),\\nivec4(1,-8,1,-2),\\nivec4(7,-4,9,1),\\nivec4(-2,1,-1,-4),\\nivec4(11,-6,12,-11),\\nivec4(-12,-9,-6,4),\\nivec4(3,7,7,12),\\nivec4(5,5,10,8),\\nivec4(0,-4,2,8),\\nivec4(-9,12,-5,-13),\\nivec4(0,7,2,12),\\nivec4(-1,2,1,7),\\nivec4(5,11,7,-9),\\nivec4(3,5,6,-8),\\nivec4(-13,-4,-8,9),\\nivec4(-5,9,-3,-3),\\nivec4(-4,-7,-3,-12),\\nivec4(6,5,8,0),\\nivec4(-7,6,-6,12),\\nivec4(-13,6,-5,-2),\\nivec4(1,-10,3,10),\\nivec4(4,1,8,-4),\\nivec4(-2,-2,2,-13),\\nivec4(2,-12,12,12),\\nivec4(-2,-13,0,-6),\\nivec4(4,1,9,3),\\nivec4(-6,-10,-3,-5),\\nivec4(-3,-13,-1,1),\\nivec4(7,5,12,-11),\\nivec4(4,-2,5,-7),\\nivec4(-13,9,-9,-5),\\nivec4(7,1,8,6),\\nivec4(7,-8,7,6),\\nivec4(-7,-4,-7,1),\\nivec4(-8,11,-7,-8),\\nivec4(-13,6,-12,-8),\\nivec4(2,4,3,9),\\nivec4(10,-5,12,3),\\nivec4(-6,-5,-6,7),\\nivec4(8,-3,9,-8),\\nivec4(2,-12,2,8),\\nivec4(-11,-2,-10,3),\\nivec4(-12,-13,-7,-9),\\nivec4(-11,0,-10,-5),\\nivec4(5,-3,11,8),\\nivec4(-2,-13,-1,12),\\nivec4(-1,-8,0,9),\\nivec4(-13,-11,-12,-5),\\nivec4(-10,-2,-10,11),\\nivec4(-3,9,-2,-13),\\nivec4(2,-3,3,2),\\nivec4(-9,-13,-4,0),\\nivec4(-4,6,-3,-10),\\nivec4(-4,12,-2,-7),\\nivec4(-6,-11,-4,9),\\nivec4(6,-3,6,11),\\nivec4(-13,11,-5,5),\\nivec4(11,11,12,6),\\nivec4(7,-5,12,-2),\\nivec4(-1,12,0,7),\\nivec4(-4,-8,-3,-2),\\nivec4(-7,1,-6,7),\\nivec4(-13,-12,-8,-13),\\nivec4(-7,-2,-6,-8),\\nivec4(-8,5,-6,-9),\\nivec4(-5,-1,-4,5),\\nivec4(-13,7,-8,10),\\nivec4(1,5,5,-13),\\nivec4(1,0,10,-13),\\nivec4(9,12,10,-1),\\nivec4(5,-8,10,-9),\\nivec4(-1,11,1,-13),\\nivec4(-9,-3,-6,2),\\nivec4(-1,-10,1,12),\\nivec4(-13,1,-8,-10),\\nivec4(8,-11,10,-6),\\nivec4(2,-13,3,-6),\\nivec4(7,-13,12,-9),\\nivec4(-10,-10,-5,-7),\\nivec4(-10,-8,-8,-13),\\nivec4(4,-6,8,5),\\nivec4(3,12,8,-13),\\nivec4(-4,2,-3,-3),\\nivec4(5,-13,10,-12),\\nivec4(4,-13,5,-1),\\nivec4(-9,9,-4,3),\\nivec4(0,3,3,-9),\\nivec4(-12,1,-6,1),\\nivec4(3,2,4,-8),\\nivec4(-10,-10,-10,9),\\nivec4(8,-13,12,12),\\nivec4(-8,-12,-6,-5),\\nivec4(2,2,3,7),\\nivec4(10,6,11,-8),\\nivec4(6,8,8,-12),\\nivec4(-7,10,-6,5),\\nivec4(-3,-9,-3,9),\\nivec4(-1,-13,-1,5),\\nivec4(-3,-7,-3,4),\\nivec4(-8,-2,-8,3),\\nivec4(4,2,12,12),\\nivec4(2,-5,3,11),\\nivec4(6,-9,11,-13),\\nivec4(3,-1,7,12),\\nivec4(11,-1,12,4),\\nivec4(-3,0,-3,6),\\nivec4(4,-11,4,12),\\nivec4(2,-4,2,1),\\nivec4(-10,-6,-8,1),\\nivec4(-13,7,-11,1),\\nivec4(-13,12,-11,-13),\\nivec4(6,0,11,-13),\\nivec4(0,-1,1,4),\\nivec4(-13,3,-9,-2),\\nivec4(-9,8,-6,-3),\\nivec4(-13,-6,-8,-2),\\nivec4(5,-9,8,10),\\nivec4(2,7,3,-9),\\nivec4(-1,-6,-1,-1),\\nivec4(9,5,11,-2),\\nivec4(11,-3,12,-8),\\nivec4(3,0,3,5),\\nivec4(-1,4,0,10),\\nivec4(3,-6,4,5),\\nivec4(-13,0,-10,5),\\nivec4(5,8,12,11),\\nivec4(8,9,9,-6),\\nivec4(7,-4,8,-12),\\nivec4(-10,4,-10,9),\\nivec4(7,3,12,4),\\nivec4(9,-7,10,-2),\\nivec4(7,0,12,-2),\\nivec4(-1,-6,0,-11)\\n);\\nvoid getPair(int index, float kcos, float ksin, out ivec2 p, out ivec2 q)\\n{\\nivec4 data = pat31[index];\\nvec2 op = vec2(data.xy);\\nvec2 oq = vec2(data.zw);\\np = ivec2(round(op.x * kcos - op.y * ksin), round(op.x * ksin + op.y * kcos));\\nq = ivec2(round(oq.x * kcos - oq.y * ksin), round(oq.x * ksin + oq.y * kcos));\\n}\\nstruct ORBFeature\\n{\\nivec2 position;\\nfloat orientation;\\nfloat lod;\\n};\\nvoid main()\\n{\\nORBFeature keypoint;\\nvec4 pixel = threadPixel(encodedCorners);\\nivec2 thread = threadLocation();\\nint threadRaster = thread.y * encoderLength + thread.x;\\nint keypointId = int(threadRaster / pixelsPerKeypoint);\\nint descriptorCell = threadRaster % pixelsPerKeypoint - 2;\\ncolor = pixel;\\nif(descriptorCell < 0)\\nreturn;\\nint positionCell = keypointId * pixelsPerKeypoint;\\nivec2 positionCellPos = ivec2(positionCell % encoderLength, positionCell / encoderLength);\\nivec4 encodedPosition = ivec4(texelFetch(encodedCorners, positionCellPos, 0) * 255.0f);\\nkeypoint.position = ivec2(\\nencodedPosition.r | (encodedPosition.g << 8),\\nencodedPosition.b | (encodedPosition.a << 8)\\n);\\nint propertiesCell = keypointId * pixelsPerKeypoint + 1;\\nivec2 propertiesCellPos = ivec2(propertiesCell % encoderLength, propertiesCell / encoderLength);\\nvec4 encodedProperties = texelFetch(encodedCorners, propertiesCellPos, 0);\\nkeypoint.orientation = decodeOrientation(encodedProperties.g);\\nkeypoint.lod = decodeLod(encodedProperties.r);\\nfloat pot = exp2(keypoint.lod);\\nvec2 kpos = vec2(keypoint.position);\\nfloat kcos = cos(keypoint.orientation);\\nfloat ksin = sin(keypoint.orientation);\\nvec2 imageSize = vec2(textureSize(pyramid, 0));\\nint patternStart = 32 * descriptorCell;\\nuint test[4] = uint[4](0u, 0u, 0u, 0u);\\nfor(int t = 0; t < 4; t++) {\\nuint bits = 0u;\\nivec2 p, q;\\nvec4 a, b;\\nint i = t * 8;\\nfor(int j = 0; j < 8; j++) {\\ngetPair(patternStart + i + j, kcos, ksin, p, q);\\na = pyrPixelAtEx(pyramid, round(kpos + pot * vec2(p)), keypoint.lod, imageSize);\\nb = pyrPixelAtEx(pyramid, round(kpos + pot * vec2(q)), keypoint.lod, imageSize);\\nbits |= uint(a.g < b.g) << j;\\n}\\ntest[t] = bits;\\n}\\ncolor = vec4(float(test[0]) / 255.0f, float(test[1]) / 255.0f, float(test[2]) / 255.0f, float(test[3]) / 255.0f);\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform ivec2 imageSize;\\nuniform int maxIterations;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nivec2 pos = threadLocation();\\nint offset = -1;\\nwhile(offset < maxIterations && pos.y < imageSize.y && pixelAt(image, pos).r == 0.0f) {\\n++offset;\\npos.x = (pos.x + 1) % imageSize.x;\\npos.y += int(pos.x == 0);\\n}\\ncolor = vec4(pixel.r, float(max(0, offset)) / 255.0f, pixel.ba);\\n}\"","module.exports = \"@include \\\"orientation.glsl\\\"\\nuniform sampler2D image;\\nuniform ivec2 imageSize;\\nuniform int encoderLength;\\nuniform int descriptorSize;\\nbool findQthKeypoint(int q, out ivec2 position, out vec4 pixel)\\n{\\nint i = 0, p = 0;\\nfor(position = ivec2(0, 0); position.y < imageSize.y; ) {\\npixel = texelFetch(image, position, 0);\\nif(pixel.r > 0.0f) {\\nif(p++ == q)\\nreturn true;\\n}\\ni += 1 + int(pixel.g * 255.0f);\\nposition = ivec2(i % imageSize.x, i / imageSize.x);\\n}\\nreturn false;\\n}\\nvoid main()\\n{\\nvec4 pixel;\\nivec2 position;\\nivec2 thread = threadLocation();\\nint p = encoderLength * thread.y + thread.x;\\nint d = 2 + descriptorSize / 4;\\nint q = p / d;\\ncolor = vec4(1.0f, 1.0f, 1.0f, 1.0f);\\nif(findQthKeypoint(q, position, pixel)) {\\nint r = p % d;\\nswitch(r) {\\ncase 0: {\\nivec2 lo = position & 255;\\nivec2 hi = position >> 8;\\ncolor = vec4(float(lo.x), float(hi.x), float(lo.y), float(hi.y)) / 255.0f;\\nbreak;\\n}\\ncase 1: {\\nfloat score = pixel.r;\\nfloat scale = pixel.a;\\nfloat rotation = encodeOrientation(0.0f);\\ncolor = vec4(scale, rotation, score, 0.0f);\\nbreak;\\n}\\ndefault: {\\ncolor = vec4(0.0f);\\nbreak;\\n}\\n}\\n}\\n}\"","module.exports = \"@include \\\"math.glsl\\\"\\n@include \\\"pyramids.glsl\\\"\\n@include \\\"orientation.glsl\\\"\\nuniform sampler2D pyramid;\\nuniform int patchRadius;\\nuniform sampler2D encodedKeypoints;\\nuniform int encoderLength;\\nuniform int descriptorSize;\\nconst int patchStart[8] = int[8](0, 0, 8, 28, 64, 132, 228, 356);\\nconst int patchPointCount[8] = int[8](0, 8, 20, 36, 68, 96, 128, 168);\\nconst ivec2 patchData[524] = ivec2[524](\\nivec2(-1,-1),ivec2(0,-1),ivec2(1,-1),ivec2(-1,0),ivec2(1,0),ivec2(-1,1),ivec2(0,1),ivec2(1,1),\\nivec2(-1,-2),ivec2(0,-2),ivec2(1,-2),ivec2(-2,-1),ivec2(-1,-1),ivec2(0,-1),ivec2(1,-1),ivec2(2,-1),ivec2(-2,0),ivec2(-1,0),ivec2(1,0),ivec2(2,0),ivec2(-2,1),ivec2(-1,1),ivec2(0,1),ivec2(1,1),ivec2(2,1),ivec2(-1,2),ivec2(0,2),ivec2(1,2),\\nivec2(-1,-3),ivec2(0,-3),ivec2(1,-3),ivec2(-2,-2),ivec2(-1,-2),ivec2(0,-2),ivec2(1,-2),ivec2(2,-2),ivec2(-3,-1),ivec2(-2,-1),ivec2(-1,-1),ivec2(0,-1),ivec2(1,-1),ivec2(2,-1),ivec2(3,-1),ivec2(-3,0),ivec2(-2,0),ivec2(-1,0),ivec2(1,0),ivec2(2,0),ivec2(3,0),ivec2(-3,1),ivec2(-2,1),ivec2(-1,1),ivec2(0,1),ivec2(1,1),ivec2(2,1),ivec2(3,1),ivec2(-2,2),ivec2(-1,2),ivec2(0,2),ivec2(1,2),ivec2(2,2),ivec2(-1,3),ivec2(0,3),ivec2(1,3),\\nivec2(-2,-4),ivec2(-1,-4),ivec2(0,-4),ivec2(1,-4),ivec2(2,-4),ivec2(-3,-3),ivec2(-2,-3),ivec2(-1,-3),ivec2(0,-3),ivec2(1,-3),ivec2(2,-3),ivec2(3,-3),ivec2(-4,-2),ivec2(-3,-2),ivec2(-2,-2),ivec2(-1,-2),ivec2(0,-2),ivec2(1,-2),ivec2(2,-2),ivec2(3,-2),ivec2(4,-2),ivec2(-4,-1),ivec2(-3,-1),ivec2(-2,-1),ivec2(-1,-1),ivec2(0,-1),ivec2(1,-1),ivec2(2,-1),ivec2(3,-1),ivec2(4,-1),ivec2(-4,0),ivec2(-3,0),ivec2(-2,0),ivec2(-1,0),ivec2(1,0),ivec2(2,0),ivec2(3,0),ivec2(4,0),ivec2(-4,1),ivec2(-3,1),ivec2(-2,1),ivec2(-1,1),ivec2(0,1),ivec2(1,1),ivec2(2,1),ivec2(3,1),ivec2(4,1),ivec2(-4,2),ivec2(-3,2),ivec2(-2,2),ivec2(-1,2),ivec2(0,2),ivec2(1,2),ivec2(2,2),ivec2(3,2),ivec2(4,2),ivec2(-3,3),ivec2(-2,3),ivec2(-1,3),ivec2(0,3),ivec2(1,3),ivec2(2,3),ivec2(3,3),ivec2(-2,4),ivec2(-1,4),ivec2(0,4),ivec2(1,4),ivec2(2,4),\\nivec2(-2,-5),ivec2(-1,-5),ivec2(0,-5),ivec2(1,-5),ivec2(2,-5),ivec2(-3,-4),ivec2(-2,-4),ivec2(-1,-4),ivec2(0,-4),ivec2(1,-4),ivec2(2,-4),ivec2(3,-4),ivec2(-4,-3),ivec2(-3,-3),ivec2(-2,-3),ivec2(-1,-3),ivec2(0,-3),ivec2(1,-3),ivec2(2,-3),ivec2(3,-3),ivec2(4,-3),ivec2(-5,-2),ivec2(-4,-2),ivec2(-3,-2),ivec2(-2,-2),ivec2(-1,-2),ivec2(0,-2),ivec2(1,-2),ivec2(2,-2),ivec2(3,-2),ivec2(4,-2),ivec2(5,-2),ivec2(-5,-1),ivec2(-4,-1),ivec2(-3,-1),ivec2(-2,-1),ivec2(-1,-1),ivec2(0,-1),ivec2(1,-1),ivec2(2,-1),ivec2(3,-1),ivec2(4,-1),ivec2(5,-1),ivec2(-5,0),ivec2(-4,0),ivec2(-3,0),ivec2(-2,0),ivec2(-1,0),ivec2(1,0),ivec2(2,0),ivec2(3,0),ivec2(4,0),ivec2(5,0),ivec2(-5,1),ivec2(-4,1),ivec2(-3,1),ivec2(-2,1),ivec2(-1,1),ivec2(0,1),ivec2(1,1),ivec2(2,1),ivec2(3,1),ivec2(4,1),ivec2(5,1),ivec2(-5,2),ivec2(-4,2),ivec2(-3,2),ivec2(-2,2),ivec2(-1,2),ivec2(0,2),ivec2(1,2),ivec2(2,2),ivec2(3,2),ivec2(4,2),ivec2(5,2),ivec2(-4,3),ivec2(-3,3),ivec2(-2,3),ivec2(-1,3),ivec2(0,3),ivec2(1,3),ivec2(2,3),ivec2(3,3),ivec2(4,3),ivec2(-3,4),ivec2(-2,4),ivec2(-1,4),ivec2(0,4),ivec2(1,4),ivec2(2,4),ivec2(3,4),ivec2(-2,5),ivec2(-1,5),ivec2(0,5),ivec2(1,5),ivec2(2,5),\\nivec2(-2,-6),ivec2(-1,-6),ivec2(0,-6),ivec2(1,-6),ivec2(2,-6),ivec2(-3,-5),ivec2(-2,-5),ivec2(-1,-5),ivec2(0,-5),ivec2(1,-5),ivec2(2,-5),ivec2(3,-5),ivec2(-4,-4),ivec2(-3,-4),ivec2(-2,-4),ivec2(-1,-4),ivec2(0,-4),ivec2(1,-4),ivec2(2,-4),ivec2(3,-4),ivec2(4,-4),ivec2(-5,-3),ivec2(-4,-3),ivec2(-3,-3),ivec2(-2,-3),ivec2(-1,-3),ivec2(0,-3),ivec2(1,-3),ivec2(2,-3),ivec2(3,-3),ivec2(4,-3),ivec2(5,-3),ivec2(-6,-2),ivec2(-5,-2),ivec2(-4,-2),ivec2(-3,-2),ivec2(-2,-2),ivec2(-1,-2),ivec2(0,-2),ivec2(1,-2),ivec2(2,-2),ivec2(3,-2),ivec2(4,-2),ivec2(5,-2),ivec2(6,-2),ivec2(-6,-1),ivec2(-5,-1),ivec2(-4,-1),ivec2(-3,-1),ivec2(-2,-1),ivec2(-1,-1),ivec2(0,-1),ivec2(1,-1),ivec2(2,-1),ivec2(3,-1),ivec2(4,-1),ivec2(5,-1),ivec2(6,-1),ivec2(-6,0),ivec2(-5,0),ivec2(-4,0),ivec2(-3,0),ivec2(-2,0),ivec2(-1,0),ivec2(1,0),ivec2(2,0),ivec2(3,0),ivec2(4,0),ivec2(5,0),ivec2(6,0),ivec2(-6,1),ivec2(-5,1),ivec2(-4,1),ivec2(-3,1),ivec2(-2,1),ivec2(-1,1),ivec2(0,1),ivec2(1,1),ivec2(2,1),ivec2(3,1),ivec2(4,1),ivec2(5,1),ivec2(6,1),ivec2(-6,2),ivec2(-5,2),ivec2(-4,2),ivec2(-3,2),ivec2(-2,2),ivec2(-1,2),ivec2(0,2),ivec2(1,2),ivec2(2,2),ivec2(3,2),ivec2(4,2),ivec2(5,2),ivec2(6,2),ivec2(-5,3),ivec2(-4,3),ivec2(-3,3),ivec2(-2,3),ivec2(-1,3),ivec2(0,3),ivec2(1,3),ivec2(2,3),ivec2(3,3),ivec2(4,3),ivec2(5,3),ivec2(-4,4),ivec2(-3,4),ivec2(-2,4),ivec2(-1,4),ivec2(0,4),ivec2(1,4),ivec2(2,4),ivec2(3,4),ivec2(4,4),ivec2(-3,5),ivec2(-2,5),ivec2(-1,5),ivec2(0,5),ivec2(1,5),ivec2(2,5),ivec2(3,5),ivec2(-2,6),ivec2(-1,6),ivec2(0,6),ivec2(1,6),ivec2(2,6),\\nivec2(-2,-7),ivec2(-1,-7),ivec2(0,-7),ivec2(1,-7),ivec2(2,-7),ivec2(-4,-6),ivec2(-3,-6),ivec2(-2,-6),ivec2(-1,-6),ivec2(0,-6),ivec2(1,-6),ivec2(2,-6),ivec2(3,-6),ivec2(4,-6),ivec2(-5,-5),ivec2(-3,-5),ivec2(-2,-5),ivec2(-1,-5),ivec2(0,-5),ivec2(1,-5),ivec2(2,-5),ivec2(3,-5),ivec2(5,-5),ivec2(-6,-4),ivec2(-4,-4),ivec2(-3,-4),ivec2(-2,-4),ivec2(-1,-4),ivec2(0,-4),ivec2(1,-4),ivec2(2,-4),ivec2(3,-4),ivec2(4,-4),ivec2(6,-4),ivec2(-6,-3),ivec2(-5,-3),ivec2(-4,-3),ivec2(-3,-3),ivec2(-2,-3),ivec2(-1,-3),ivec2(0,-3),ivec2(1,-3),ivec2(2,-3),ivec2(3,-3),ivec2(4,-3),ivec2(5,-3),ivec2(6,-3),ivec2(-7,-2),ivec2(-6,-2),ivec2(-5,-2),ivec2(-4,-2),ivec2(-3,-2),ivec2(-2,-2),ivec2(-1,-2),ivec2(0,-2),ivec2(1,-2),ivec2(2,-2),ivec2(3,-2),ivec2(4,-2),ivec2(5,-2),ivec2(6,-2),ivec2(7,-2),ivec2(-7,-1),ivec2(-6,-1),ivec2(-5,-1),ivec2(-4,-1),ivec2(-3,-1),ivec2(-2,-1),ivec2(-1,-1),ivec2(0,-1),ivec2(1,-1),ivec2(2,-1),ivec2(3,-1),ivec2(4,-1),ivec2(5,-1),ivec2(6,-1),ivec2(7,-1),ivec2(-7,0),ivec2(-6,0),ivec2(-5,0),ivec2(-4,0),ivec2(-3,0),ivec2(-2,0),ivec2(-1,0),ivec2(1,0),ivec2(2,0),ivec2(3,0),ivec2(4,0),ivec2(5,0),ivec2(6,0),ivec2(7,0),ivec2(-7,1),ivec2(-6,1),ivec2(-5,1),ivec2(-4,1),ivec2(-3,1),ivec2(-2,1),ivec2(-1,1),ivec2(0,1),ivec2(1,1),ivec2(2,1),ivec2(3,1),ivec2(4,1),ivec2(5,1),ivec2(6,1),ivec2(7,1),ivec2(-7,2),ivec2(-6,2),ivec2(-5,2),ivec2(-4,2),ivec2(-3,2),ivec2(-2,2),ivec2(-1,2),ivec2(0,2),ivec2(1,2),ivec2(2,2),ivec2(3,2),ivec2(4,2),ivec2(5,2),ivec2(6,2),ivec2(7,2),ivec2(-6,3),ivec2(-5,3),ivec2(-4,3),ivec2(-3,3),ivec2(-2,3),ivec2(-1,3),ivec2(0,3),ivec2(1,3),ivec2(2,3),ivec2(3,3),ivec2(4,3),ivec2(5,3),ivec2(6,3),ivec2(-6,4),ivec2(-4,4),ivec2(-3,4),ivec2(-2,4),ivec2(-1,4),ivec2(0,4),ivec2(1,4),ivec2(2,4),ivec2(3,4),ivec2(4,4),ivec2(6,4),ivec2(-5,5),ivec2(-3,5),ivec2(-2,5),ivec2(-1,5),ivec2(0,5),ivec2(1,5),ivec2(2,5),ivec2(3,5),ivec2(5,5),ivec2(-4,6),ivec2(-3,6),ivec2(-2,6),ivec2(-1,6),ivec2(0,6),ivec2(1,6),ivec2(2,6),ivec2(3,6),ivec2(4,6),ivec2(-2,7),ivec2(-1,7),ivec2(0,7),ivec2(1,7),ivec2(2,7)\\n);\\nconst int MIN_PATCH_RADIUS = 3;\\nconst int MAX_PATCH_RADIUS = 7;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(encodedKeypoints);\\nivec2 thread = threadLocation();\\nint threadRaster = thread.y * encoderLength + thread.x;\\nint pixelsPerKeypoint = 2 + descriptorSize / 4;\\nint keypointId = int(threadRaster / pixelsPerKeypoint);\\nint keypointCell = threadRaster % pixelsPerKeypoint;\\ncolor = pixel;\\nif(keypointCell != 1)\\nreturn;\\nint positionCell = keypointId * pixelsPerKeypoint;\\nivec2 positionCellPos = ivec2(positionCell % encoderLength, positionCell / encoderLength);\\nivec4 encodedPosition = ivec4(texelFetch(encodedKeypoints, positionCellPos, 0) * 255.0f);\\nivec2 keypointPosition = ivec2(\\nencodedPosition.r | (encodedPosition.g << 8),\\nencodedPosition.b | (encodedPosition.a << 8)\\n);\\nfloat lod = decodeLod(pixel.r);\\nfloat pot = exp2(lod);\\nvec2 m = vec2(0.0f);\\nivec2 pyrBaseSize = textureSize(pyramid, 0);\\nint scaledRadius = int(ceil(float(patchRadius) / pot));\\nint radius = clamp(scaledRadius, MIN_PATCH_RADIUS, MAX_PATCH_RADIUS);\\nint start = patchStart[radius];\\nint count = patchPointCount[radius];\\nfor(int j = 0; j < count; j++) {\\nvec2 offset = vec2(patchData[start + j]);\\nivec2 position = keypointPosition + ivec2(round(pot * offset));\\nvec4 patchPixel = pyrPixelAtEx(pyramid, position, lod, pyrBaseSize);\\nm += offset * patchPixel.g;\\n}\\nfloat angle = fastAtan2(m.y, m.x);\\ncolor.g = encodeOrientation(angle);\\n}\"","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * convolution.js\n * Convolution shader generators\n */\n\nimport { createShader } from '../../shader-declaration';\nimport { IllegalArgumentError } from '../../../utils/errors';\n\n// Utilities\nconst cartesian = (a, b) => [].concat(...a.map(a => b.map(b => [a,b]))); // [a] x [b]\nconst symmetricRange = n => [...Array(2*n + 1).keys()].map(x => x-n);    // [-n, ..., n]\n\n\n\n/**\n * Generate a 2D convolution with a square kernel\n * @param {Array<number>} kernel convolution kernel\n * @param {number} [normalizationConstant] will be multiplied by all kernel entries\n */\nexport function conv2D(kernel, normalizationConstant = 1.0)\n{\n    const kernel32 = new Float32Array(kernel.map(x => (+x) * (+normalizationConstant)));\n    const kSize = Math.sqrt(kernel32.length) | 0;\n    const N = (kSize / 2) | 0;\n\n    // validate input\n    if(kSize < 1 || kSize % 2 == 0)\n        throw new IllegalArgumentError(`Can't perform a 2D convolution with an invalid kSize of ${kSize}`);\n    else if(kSize * kSize != kernel32.length)\n        throw new IllegalArgumentError(`Invalid 2D convolution kernel of ${kernel32.length} elements (expected: square)`);\n\n    // code generator\n    const foreachKernelElement = fn => cartesian(symmetricRange(N), symmetricRange(N)).map(\n        cur => fn(\n            kernel32[(cur[0] + N) * kSize + (cur[1] + N)],\n            cur[0], cur[1]\n        )\n    ).join('\\n');\n\n    const generateCode = (k, dy, dx) => `\n        result += pixelAtOffset(image, ivec2(${dx | 0}, ${dy | 0})) * float(${+k});\n    `;\n\n    // shader\n    const source = `\n    uniform sampler2D image;\n\n    void main()\n    {\n        float alpha = threadPixel(image).a;\n        vec4 result = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n\n        ${foreachKernelElement(generateCode)}\n\n        color = vec4(result.rgb, alpha);\n    }\n    `;\n\n    // done!\n    return createShader(source).withArguments('image');\n}\n\n\n\n\n/**\n * Generate a 1D convolution function on the x-axis\n * @param {Array<number>} kernel convolution kernel\n * @param {number} [normalizationConstant] will be multiplied by all kernel entries\n */\nexport function convX(kernel, normalizationConstant = 1.0)\n{\n    return conv1D('x', kernel, normalizationConstant);\n}\n\n\n\n\n/**\n * Generate a 1D convolution function on the y-axis\n * @param {Array<number>} kernel convolution kernel\n * @param {number} [normalizationConstant] will be multiplied by all kernel entries\n */\nexport function convY(kernel, normalizationConstant = 1.0)\n{\n    return conv1D('y', kernel, normalizationConstant);\n}\n\n\n\n\n/**\n * 1D convolution function generator\n * @param {string} axis either \"x\" or \"y\"\n * @param {Array<number>} kernel convolution kernel\n * @param {number} [normalizationConstant] will be multiplied by all kernel entries\n */\nfunction conv1D(axis, kernel, normalizationConstant = 1.0)\n{\n    const kernel32 = new Float32Array(kernel.map(x => (+x) * (+normalizationConstant)));\n    const kSize = kernel32.length;\n    const N = (kSize / 2) | 0;\n\n    // validate input\n    if(kSize < 1 || kSize % 2 == 0)\n        throw new IllegalArgumentError(`Can't perform a 1D convolution with an invalid kSize of ${kSize}`);\n    else if(axis != 'x' && axis != 'y')\n        throw new IllegalArgumentError(`Can't perform 1D convolution: invalid axis \"${axis}\"`); // this should never happen\n\n    // code generator\n    const foreachKernelElement = fn => symmetricRange(N).reduce(\n        (acc, cur) => acc + fn(kernel32[cur + N], cur),\n    '');\n    const generateCode = (k, i) => ((axis == 'x') ? `\n        pixel += pixelAtOffset(image, ivec2(${i | 0}, 0)) * float(${+k});\n    ` : `\n        pixel += pixelAtOffset(image, ivec2(0, ${i | 0})) * float(${+k});\n    `);\n\n    // shader\n    const source = `\n    uniform sampler2D image;\n\n    void main()\n    {\n        float alpha = threadPixel(image).a;\n        vec4 pixel = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n\n        ${foreachKernelElement(generateCode)}\n\n        color = vec4(pixel.rgb, alpha);\n    }\n    `;\n\n    // done!\n    return createShader(source).withArguments('image');\n}\n\n\n\n\n\n/*\n * ------------------------------------------------------------------\n * Texture Encoding\n * Encoding a float in [0,1] into RGB[A]\n * ------------------------------------------------------------------\n * Define frac(x) := x - floor(x)\n * Of course, 0 <= frac(x) < 1.\n * \n * Given: x in [0,1]\n * \n * Define e0 := floor(x),\n *        e1 := 256 frac(x)\n *        e2 := 256 frac(e1) = 256 frac(256 frac(x))\n *        e3 := 256 frac(e2) = 256 frac(256 frac(e1)) = 256 frac(256 frac(256 frac(x))),\n *        ...\n *        more generally,\n *        ej := 256 frac(e_{j-1}), j >= 2\n * \n * Since x = frac(x) + floor(x), it follows that\n * x = floor(x) + 256 frac(x) / 256 = e0 + e1 / 256 = e0 + (frac(e1) + floor(e1)) / 256 =\n * e0 + (256 frac(e1) + 256 floor(e1)) / (256^2) = e0 + (e2 + 256 floor(e1)) / (256^2) =\n * e0 + ((256 frac(e2) + 256 floor(e2)) + 256^2 floor(e1)) / (256^3) =\n * e0 + (e3 + 256 floor(e2) + 256^2 floor(e1)) / (256^3) = \n * floor(e0) + floor(e1) / 256 + floor(e2) / (256^2) + e3 / (256^3) = ... =\n * floor(e0) + floor(e1) / 256 + floor(e2) / (256^2) + floor(e3) / (256^3) + e4 / (256^4) = ... ~\n * \\sum_{i >= 0} floor(e_i) / 256^i\n * \n * Observe that e0 in {0, 1} and, for j >= 1, 0 <= e_j < 256, meaning that\n * e0 and (e_j / 256) can be stored in a 8-bit color channel.\n * \n * We now have approximations for x:\n * x ~ x0 <-- first order\n * x ~ x0 + x1 / 256 <-- second order\n * x ~ x0 + x1 / 256 + x2 / (256^2) <-- third order (RGB)\n * x ~ x0 + x1 / 256 + x2 / (256^2) + x3 / (256^3) <-- fourth order (RGBA)\n * where x_i = floor(e_i).\n */\n\n\n\n\n/**\n * Generate a texture-based 2D convolution kernel of size\n * (kernelSize x kernelSize), where all entries belong to\n * the [0, 1] range\n * @param {number} kernelSize odd number, e.g., 3 to create a 3x3 kernel, and so on\n */\nexport function createKernel2D(kernelSize)\n{\n    // validate input\n    kernelSize |= 0;\n    if(kernelSize < 1 || kernelSize % 2 == 0)\n        throw new IllegalArgumentError(`Can't create a 2D texture kernel of size ${kernelSize}`);\n\n    // encode float in the [0,1] range to RGBA\n    const shader = `\n    uniform float kernel[${kernelSize * kernelSize}];\n\n    void main()\n    {\n        ivec2 thread = threadLocation();\n        float val = kernel[(${kernelSize}) * thread.y + thread.x];\n\n        float e0 = floor(val);\n        float e1 = 256.0f * fract(val);\n        float e2 = 256.0f * fract(e1);\n        float e3 = 256.0f * fract(e2);\n\n        color = vec4(e0, floor(e1) / 256.0f, floor(e2) / 256.0f, floor(e3) / 256.0f);\n    }\n    `;\n\n    // IMPORTANT: all entries of the input kernel\n    // are assumed to be in the [0, 1] range AND\n    // kernel.length >= kernelSize * kernelSize\n    return createShader(shader).withArguments('kernel');\n}\n\n\n\n\n/**\n * Generate a texture-based 1D convolution kernel of size\n * (kernelSize x 1), where all entries belong to the [0,1] range\n * @param {number} kernelSize odd number\n */\nexport function createKernel1D(kernelSize)\n{\n    // validate input\n    kernelSize |= 0;\n    if(kernelSize < 1 || kernelSize % 2 == 0)\n        throw new IllegalArgumentError(`Can't create a 1D texture kernel of size ${kernelSize}`);\n\n    // encode float in the [0,1] range to RGBA\n    const shader = `\n    uniform float kernel[${kernelSize}];\n\n    void main()\n    {\n        ivec2 thread = threadLocation();\n        float val = kernel[thread.x];\n\n        float e0 = floor(val);\n        float e1 = 256.0f * fract(val);\n        float e2 = 256.0f * fract(e1);\n        float e3 = 256.0f * fract(e2);\n\n        color = vec4(e0, floor(e1) / 256.0f, floor(e2) / 256.0f, floor(e3) / 256.0f);\n    }\n    `;\n\n    // IMPORTANT: all entries of the input kernel\n    // are assumed to be in the [0, 1] range AND\n    // kernel.length >= kernelSize\n    return createShader(shader).withArguments('kernel');\n}\n\n\n\n\n/**\n * 2D convolution with a texture-based kernel of size\n * kernelSize x kernelSize, with optional scale & offset\n * By default, scale and offset are 1 and 0, respectively\n * @param {number} kernelSize odd number, e.g., 3 to create a 3x3 kernel, and so on\n */\nexport function texConv2D(kernelSize)\n{\n    // validate input\n    const N = kernelSize >> 1; // idiv 2\n    if(kernelSize < 1 || kernelSize % 2 == 0)\n        throw new IllegalArgumentError(`Can't perform a texture-based 2D convolution with an invalid kernel size of ${kernelSize}`);\n\n    // utilities\n    const foreachKernelElement = fn => cartesian(symmetricRange(N), symmetricRange(N)).map(\n        ij => fn(ij[0], ij[1])\n    ).join('\\n');\n\n    const generateCode = (i, j) => `\n        kernel = pixelAt(texKernel, ivec2(${i + N}, ${j + N}));\n        value = dot(kernel, magic) * scale + offset;\n        result += pixelAtOffset(image, ivec2(${i}, ${j})) * value;\n    `;\n\n    // image: target image\n    // texKernel: convolution kernel (all entries in [0,1])\n    // scale: multiply the kernel entries by a number (like 1.0)\n    // offset: add a number to all kernel entries (like 0.0)\n    const shader = `\n    const vec4 magic = vec4(1.0f, 1.0f, 1.0f / 256.0f, 1.0f / 65536.0f);\n    uniform sampler2D image, texKernel;\n    uniform float scale, offset;\n\n    void main()\n    {\n        vec4 kernel = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n        vec4 result = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n        float alpha = threadPixel(image).a;\n        float value = 0.0f;\n\n        ${foreachKernelElement(generateCode)}\n\n        result = clamp(result, 0.0f, 1.0f);\n        color = vec4(result.rgb, alpha);\n    }\n    `;\n\n    // done!\n    return createShader(shader).withArguments('image', 'texKernel', 'scale', 'offset');\n}\n\n\n\n\n/**\n * Texture-based 1D convolution on the x-axis\n * @param {number} kernelSize odd number\n */\nexport const texConvX = kernelSize => texConv1D(kernelSize, 'x');\n\n\n\n/**\n * Texture-based 1D convolution on the x-axis\n * @param {number} kernelSize odd number\n */\nexport const texConvY = kernelSize => texConv1D(kernelSize, 'y');\n\n\n\n\n/**\n * Texture-based 1D convolution function generator\n * (the convolution kernel is stored in a texture)\n * @param {number} kernelSize odd number\n * @param {string} axis either \"x\" or \"y\"\n */\nfunction texConv1D(kernelSize, axis)\n{\n    // validate input\n    const N = kernelSize >> 1; // idiv 2\n    if(kernelSize < 1 || kernelSize % 2 == 0)\n        throw new IllegalArgumentError(`Can't perform a texture-based 2D convolution with an invalid kernel size of ${kernelSize}`);\n    else if(axis != 'x' && axis != 'y')\n        throw new IllegalArgumentError(`Can't perform a texture-based 1D convolution: invalid axis \"${axis}\"`); // this should never happen\n\n    // utilities\n    const foreachKernelElement = fn => symmetricRange(N).map(fn).join('\\n');\n    const generateCode = i => ((axis == 'x') ? `\n        kernel = pixelAt(texKernel, ivec2(${i + N}, 0));\n        value = dot(kernel, magic) * scale + offset;\n        result += pixelAtOffset(image, ivec2(${i}, 0)) * value;\n    ` : `\n        kernel = pixelAt(texKernel, ivec2(${i + N}, 0));\n        value = dot(kernel, magic) * scale + offset;\n        result += pixelAtOffset(image, ivec2(0, ${i})) * value;\n    `);\n\n    // image: target image\n    // texKernel: convolution kernel (all entries in [0,1])\n    // scale: multiply the kernel entries by a number (like 1.0)\n    // offset: add a number to all kernel entries (like 0.0)\n    const shader = `\n    const vec4 magic = vec4(1.0f, 1.0f, 1.0f / 256.0f, 1.0f / 65536.0f);\n    uniform sampler2D image, texKernel;\n    uniform float scale, offset;\n\n    void main()\n    {\n        vec4 kernel = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n        vec4 result = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n        float alpha = threadPixel(image).a;\n        float value = 0.0f;\n\n        ${foreachKernelElement(generateCode)}\n\n        result = clamp(result, 0.0f, 1.0f);\n        color = vec4(result.rgb, alpha);\n    }\n    `;\n\n    // done!\n    return createShader(shader).withArguments('image', 'texKernel', 'scale', 'offset');\n}","var map = {\n\t\"./colors.glsl\": \"./src/gpu/shaders/include/colors.glsl\",\n\t\"./global.glsl\": \"./src/gpu/shaders/include/global.glsl\",\n\t\"./math.glsl\": \"./src/gpu/shaders/include/math.glsl\",\n\t\"./orientation.glsl\": \"./src/gpu/shaders/include/orientation.glsl\",\n\t\"./pyramids.glsl\": \"./src/gpu/shaders/include/pyramids.glsl\",\n\t\"./sobel.glsl\": \"./src/gpu/shaders/include/sobel.glsl\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./src/gpu/shaders/include sync recursive ^\\\\.\\\\/.*$\";","module.exports = \"#ifndef _COLORS_GLSL\\n#define _COLORS_GLSL\\n#define PIXELCOMPONENT_RED   @PIXELCOMPONENT_RED@\\n#define PIXELCOMPONENT_GREEN @PIXELCOMPONENT_GREEN@\\n#define PIXELCOMPONENT_BLUE  @PIXELCOMPONENT_BLUE@\\n#define PIXELCOMPONENT_ALPHA @PIXELCOMPONENT_ALPHA@\\n#endif\"","module.exports = \"#ifndef _GLOBAL_GLSL\\n#define _GLOBAL_GLSL\\n#define threadLocation() ivec2(texCoord * texSize)\\n#define outputSize() ivec2(texSize)\\n#define DEBUG(scalar) do { color = vec4(float(scalar), 0.0f, 0.0f, 1.0f); return; } while(false)\\n#define threadPixel(img) textureLod((img), texCoord, 0.0f)\\n#define pixelAt(img, pos) texelFetch((img), (pos), 0)\\n#define pixelAtOffset(img, offset) textureLodOffset((img), texCoord, 0.0f, (offset))\\n#endif\"","module.exports = \"#ifndef _MATH_GLSL\\n#define _MATH_GLSL\\n#define TWO_PI          6.28318530718f\\n#define PI              3.14159265359f\\n#define PI_OVER_2       1.57079632679f\\n#define PI_OVER_4       0.78539816339f\\n#define INV_PI          0.3183098861837907f\\n#define USE_FAST_ATAN\\n#ifdef USE_FAST_ATAN\\nfloat fastAtan(float x)\\n{\\nfloat w = 1.0f - abs(x);\\nreturn (w >= 0.0f) ?\\n(PI_OVER_4 + 0.273f * w) * x :\\nsign(x) * PI_OVER_2 - (PI_OVER_4 + 0.273f * (1.0f - abs(1.0f / x))) / x;\\n}\\n#else\\n#define fastAtan(x) atan(x)\\n#endif\\n#ifdef USE_FAST_ATAN\\nfloat fastAtan2(float y, float x)\\n{\\nreturn (x == 0.0f) ? PI_OVER_2 * sign(y) : fastAtan(y / x) + float(x < 0.0f) * PI * sign(y);\\n}\\n#else\\n#define fastAtan2(y, x) atan((y), (x))\\n#endif\\n#endif\"","module.exports = \"#ifndef _ORIENTATION_GLSL\\n#define _ORIENTATION_GLSL\\n@include \\\"math.glsl\\\"\\n#define encodeOrientation(angle) ((angle) * INV_PI + 1.0f) * 0.5f\\n#define decodeOrientation(value) ((value) * 2.0f - 1.0f) * PI\\n#endif\"","module.exports = \"#ifndef _PYRAMIDS_GLSL\\n#define _PYRAMIDS_GLSL\\n#define pyrPixel(pyr, lod) textureLod((pyr), texCoord, (lod))\\n#define pyrPixelAtOffset(pyr, lod, pot, offset) textureLod((pyr), texCoord + ((pot) * vec2(offset)) / texSize, (lod))\\n#define pyrPixelAt(pyr, pos, lod) textureLod((pyr), (vec2(pos) + vec2(0.5f)) / texSize, (lod))\\n#define pyrPixelAtEx(pyr, pos, lod, pyrBaseSize) textureLod((pyr), (vec2(pos) + vec2(0.5f)) / vec2(pyrBaseSize), (lod))\\n#define PYRAMID_MAX_LEVELS      float(@PYRAMID_MAX_LEVELS@)\\n#define PYRAMID_MAX_OCTAVES     int(@PYRAMID_MAX_OCTAVES@)\\n#define LOG2_PYRAMID_MAX_SCALE  float(@LOG2_PYRAMID_MAX_SCALE@)\\nfloat encodeLod(float lod)\\n{\\nreturn (LOG2_PYRAMID_MAX_SCALE + lod) / (LOG2_PYRAMID_MAX_SCALE + PYRAMID_MAX_LEVELS);\\n}\\nfloat decodeLod(float encodedLod)\\n{\\nreturn mix(0.0f,\\nencodedLod * (LOG2_PYRAMID_MAX_SCALE + PYRAMID_MAX_LEVELS) - LOG2_PYRAMID_MAX_SCALE,\\nencodedLod < 1.0f\\n);\\n}\\n#define isSameEncodedLod(alpha1, alpha2) (abs((alpha1) - (alpha2)) < encodedLodEps)\\nconst float encodedLodEps = 0.2 / (LOG2_PYRAMID_MAX_SCALE + PYRAMID_MAX_LEVELS);\\n#endif\"","module.exports = \"#ifndef _SOBEL_GLSL\\n#define _SOBEL_GLSL\\nvec4 encodeSobel(vec2 df)\\n{\\nvec2 zeroes = vec2(0.0f, 0.0f);\\nvec2 dmax = -max(df, zeroes);\\nvec2 dmin = min(df, zeroes);\\nreturn exp2(vec4(dmax, dmin));\\n}\\nvec2 decodeSobel(vec4 encodedSobel)\\n{\\nvec4 lg = log2(encodedSobel);\\nreturn vec2(lg.b - lg.r, lg.a - lg.g);\\n}\\n#endif\"","module.exports = \"uniform sampler2D image, layerA, layerB;\\nuniform float scaleA, scaleB, lgM, h;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nfloat score = pixel.r;\\nivec2 zero = ivec2(0, 0);\\nivec2 sizeA = textureSize(layerA, 0);\\nivec2 sizeB = textureSize(layerB, 0);\\nvec2 mid = (texCoord * texSize) + vec2(0.5f, 0.5f);\\nivec2 pa = clamp(ivec2(ceil(mid * scaleA - 1.0f)), zero, sizeA - 2);\\nivec2 pb = clamp(ivec2(ceil(mid * scaleB - 1.0f)), zero, sizeB - 2);\\nvec4 a00 = pixelAt(layerA, pa);\\nvec4 a10 = pixelAt(layerA, pa + ivec2(1, 0));\\nvec4 a01 = pixelAt(layerA, pa + ivec2(0, 1));\\nvec4 a11 = pixelAt(layerA, pa + ivec2(1, 1));\\nvec4 b00 = pixelAt(layerB, pb);\\nvec4 b10 = pixelAt(layerB, pb + ivec2(1, 0));\\nvec4 b01 = pixelAt(layerB, pb + ivec2(0, 1));\\nvec4 b11 = pixelAt(layerB, pb + ivec2(1, 1));\\nfloat maxScore = max(\\nmax(max(a00.r, a10.r), max(a01.r, a11.r)),\\nmax(max(b00.r, b10.r), max(b01.r, b11.r))\\n);\\ncolor = vec4(0.0f, pixel.gba);\\nif(score < maxScore || score == 0.0f)\\nreturn;\\nvec2 ea = fract(mid * scaleA);\\nvec2 eb = fract(mid * scaleB);\\nfloat isa = a00.b * (1.0f - ea.x) * (1.0f - ea.y) +\\na10.b * ea.x * (1.0f - ea.y) +\\na01.b * (1.0f - ea.x) * ea.y +\\na11.b * ea.x * ea.y;\\nfloat isb = b00.b * (1.0f - eb.x) * (1.0f - eb.y) +\\nb10.b * eb.x * (1.0f - eb.y) +\\nb01.b * (1.0f - eb.x) * eb.y +\\nb11.b * eb.x * eb.y;\\ncolor = (isa > score && isa > isb) ? vec4(isa, pixel.gb, a00.a) : pixel;\\ncolor = (isb > score && isb > isa) ? vec4(isb, pixel.gb, b00.a) : pixel;\\nfloat y1 = isa, y2 = isb, y3 = score;\\nfloat x1 = lgM - (lgM + h) * a00.a;\\nfloat x2 = lgM - (lgM + h) * b00.a;\\nfloat x3 = lgM - (lgM + h) * pixel.a;\\nfloat dn = (x1 - x2) * (x1 - x3) * (x2 - x3);\\nif(abs(dn) < 0.00001f)\\nreturn;\\nfloat a = (x3 * (y2 - y1) + x2 * (y1 - y3) + x1 * (y3 - y2)) / dn;\\nif(a >= 0.0f)\\nreturn;\\nfloat b = (x3 * x3 * (y1 - y2) + x2 * x2 * (y3 - y1) + x1 * x1 * (y2 - y3)) / dn;\\nfloat c = (x2 * x3 * (x2 - x3) * y1 + x3 * x1 * (x3 - x1) * y2 + x1 * x2 * (x1 - x2) * y3) / dn;\\nfloat xv = -b / (2.0f * a);\\nfloat yv = c - (b * b) / (4.0f * a);\\nif(xv < min(x1, min(x2, x3)) || xv > max(x1, max(x2, x3)))\\nreturn;\\nfloat interpolatedScale = (lgM - xv) / (lgM + h);\\nfloat interpolatedScore = clamp(yv, 0.0f, 1.0f);\\ncolor = vec4(interpolatedScore, pixel.gb, interpolatedScale);\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform float threshold;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nfloat t = clamp(threshold, 0.0f, 1.0f);\\nfloat ct = pixel.g + t, c_t = pixel.g - t;\\nfloat p0 = pixelAtOffset(image, ivec2(0, 2)).g;\\nfloat p1 = pixelAtOffset(image, ivec2(1, 2)).g;\\nfloat p2 = pixelAtOffset(image, ivec2(2, 1)).g;\\nfloat p3 = pixelAtOffset(image, ivec2(2, 0)).g;\\nfloat p4 = pixelAtOffset(image, ivec2(2, -1)).g;\\nfloat p5 = pixelAtOffset(image, ivec2(1, -2)).g;\\nfloat p6 = pixelAtOffset(image, ivec2(0, -2)).g;\\nfloat p7 = pixelAtOffset(image, ivec2(-1, -2)).g;\\nfloat p8 = pixelAtOffset(image, ivec2(-2, -1)).g;\\nfloat p9 = pixelAtOffset(image, ivec2(-2, 0)).g;\\nfloat p10 = pixelAtOffset(image, ivec2(-2, 1)).g;\\nfloat p11 = pixelAtOffset(image, ivec2(-1, 2)).g;\\nvec2 scores = vec2(0.0f, 0.0f);\\nscores += vec2(max(c_t - p0, 0.0f), max(p0 - ct, 0.0f));\\nscores += vec2(max(c_t - p1, 0.0f), max(p1 - ct, 0.0f));\\nscores += vec2(max(c_t - p2, 0.0f), max(p2 - ct, 0.0f));\\nscores += vec2(max(c_t - p3, 0.0f), max(p3 - ct, 0.0f));\\nscores += vec2(max(c_t - p4, 0.0f), max(p4 - ct, 0.0f));\\nscores += vec2(max(c_t - p5, 0.0f), max(p5 - ct, 0.0f));\\nscores += vec2(max(c_t - p6, 0.0f), max(p6 - ct, 0.0f));\\nscores += vec2(max(c_t - p7, 0.0f), max(p7 - ct, 0.0f));\\nscores += vec2(max(c_t - p8, 0.0f), max(p8 - ct, 0.0f));\\nscores += vec2(max(c_t - p9, 0.0f), max(p9 - ct, 0.0f));\\nscores += vec2(max(c_t - p10, 0.0f), max(p10 - ct, 0.0f));\\nscores += vec2(max(c_t - p11, 0.0f), max(p11 - ct, 0.0f));\\nfloat score = max(scores.x, scores.y) / 12.0f;\\ncolor = vec4(score * step(1.0f, pixel.r), pixel.g, score, pixel.a);\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform float threshold;\\nconst vec4 zeroes = vec4(0.0f, 0.0f, 0.0f, 0.0f);\\nconst vec4 ones = vec4(1.0f, 1.0f, 1.0f, 1.0f);\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nfloat t = clamp(threshold, 0.0f, 1.0f);\\nfloat ct = pixel.g + t, c_t = pixel.g - t;\\nmat4 mp = mat4(\\npixelAtOffset(image, ivec2(0, 3)).g,\\npixelAtOffset(image, ivec2(1, 3)).g,\\npixelAtOffset(image, ivec2(2, 2)).g,\\npixelAtOffset(image, ivec2(3, 1)).g,\\npixelAtOffset(image, ivec2(3, 0)).g,\\npixelAtOffset(image, ivec2(3, -1)).g,\\npixelAtOffset(image, ivec2(2, -2)).g,\\npixelAtOffset(image, ivec2(1, -3)).g,\\npixelAtOffset(image, ivec2(0, -3)).g,\\npixelAtOffset(image, ivec2(-1, -3)).g,\\npixelAtOffset(image, ivec2(-2, -2)).g,\\npixelAtOffset(image, ivec2(-3, -1)).g,\\npixelAtOffset(image, ivec2(-3, 0)).g,\\npixelAtOffset(image, ivec2(-3, 1)).g,\\npixelAtOffset(image, ivec2(-2, 2)).g,\\npixelAtOffset(image, ivec2(-1, 3)).g\\n);\\nmat4 mct = mp - mat4(\\nct, ct, ct, ct,\\nct, ct, ct, ct,\\nct, ct, ct, ct,\\nct, ct, ct, ct\\n), mc_t = mat4(\\nc_t, c_t, c_t, c_t,\\nc_t, c_t, c_t, c_t,\\nc_t, c_t, c_t, c_t,\\nc_t, c_t, c_t, c_t\\n) - mp;\\nvec4 bs = max(mc_t[0], zeroes), ds = max(mct[0], zeroes);\\nbs += max(mc_t[1], zeroes); ds += max(mct[1], zeroes);\\nbs += max(mc_t[2], zeroes); ds += max(mct[2], zeroes);\\nbs += max(mc_t[3], zeroes); ds += max(mct[3], zeroes);\\nfloat score = max(dot(bs, ones), dot(ds, ones)) / 16.0f;\\ncolor = vec4(score * step(1.0f, pixel.r), pixel.g, score, pixel.a);\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform float threshold;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nfloat t = clamp(threshold, 0.0f, 1.0f);\\nfloat ct = pixel.g + t, c_t = pixel.g - t;\\nfloat p0 = pixelAtOffset(image, ivec2(0, 1)).g;\\nfloat p1 = pixelAtOffset(image, ivec2(1, 1)).g;\\nfloat p2 = pixelAtOffset(image, ivec2(1, 0)).g;\\nfloat p3 = pixelAtOffset(image, ivec2(1, -1)).g;\\nfloat p4 = pixelAtOffset(image, ivec2(0, -1)).g;\\nfloat p5 = pixelAtOffset(image, ivec2(-1, -1)).g;\\nfloat p6 = pixelAtOffset(image, ivec2(-1, 0)).g;\\nfloat p7 = pixelAtOffset(image, ivec2(-1, 1)).g;\\nvec2 scores = vec2(0.0f, 0.0f);\\nscores += vec2(max(c_t - p0, 0.0f), max(p0 - ct, 0.0f));\\nscores += vec2(max(c_t - p1, 0.0f), max(p1 - ct, 0.0f));\\nscores += vec2(max(c_t - p2, 0.0f), max(p2 - ct, 0.0f));\\nscores += vec2(max(c_t - p3, 0.0f), max(p3 - ct, 0.0f));\\nscores += vec2(max(c_t - p4, 0.0f), max(p4 - ct, 0.0f));\\nscores += vec2(max(c_t - p5, 0.0f), max(p5 - ct, 0.0f));\\nscores += vec2(max(c_t - p6, 0.0f), max(p6 - ct, 0.0f));\\nscores += vec2(max(c_t - p7, 0.0f), max(p7 - ct, 0.0f));\\nfloat score = max(scores.x, scores.y) / 8.0f;\\ncolor = vec4(score * step(1.0f, pixel.r), pixel.g, score, pixel.a);\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform float threshold;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nivec2 size = outputSize();\\nvec4 pixel = threadPixel(image);\\ncolor = vec4(0.0f, pixel.gba);\\nif(\\nthread.x >= 3 && thread.x < size.x - 3 &&\\nthread.y >= 3 && thread.y < size.y - 3\\n) {\\nfloat t = clamp(threshold, 0.0f, 1.0f);\\nfloat c = pixel.g;\\nfloat ct = c + t, c_t = c - t;\\nfloat p0 = pixelAtOffset(image, ivec2(0, 1)).g;\\nfloat p1 = pixelAtOffset(image, ivec2(1, 1)).g;\\nfloat p2 = pixelAtOffset(image, ivec2(1, 0)).g;\\nfloat p3 = pixelAtOffset(image, ivec2(1, -1)).g;\\nfloat p4 = pixelAtOffset(image, ivec2(0, -1)).g;\\nfloat p5 = pixelAtOffset(image, ivec2(-1, -1)).g;\\nfloat p6 = pixelAtOffset(image, ivec2(-1, 0)).g;\\nfloat p7 = pixelAtOffset(image, ivec2(-1, 1)).g;\\nbool possibleCorner =\\n((c_t > p1 || c_t > p5) && (c_t > p3 || c_t > p7)) ||\\n((ct < p1  || ct < p5)  && (ct < p3  || ct < p7))  ;\\nif(possibleCorner) {\\nint bright = 0, dark = 0, bc = 0, dc = 0;\\nif(c_t > p0) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p0) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p1) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p1) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p2) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p2) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p3) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p3) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p4) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p4) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p5) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p5) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p6) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p6) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p7) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p7) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(bright < 5 && dark < 5) {\\nif(bc > 0 && bc < 5) do {\\nif(c_t > p0)           bc += 1; else break;\\nif(c_t > p1 && bc < 5) bc += 1; else break;\\nif(c_t > p2 && bc < 5) bc += 1; else break;\\nif(c_t > p3 && bc < 5) bc += 1; else break;\\n} while(false);\\nif(dc > 0 && dc < 5) do {\\nif(ct < p0)           dc += 1; else break;\\nif(ct < p1 && dc < 5) dc += 1; else break;\\nif(ct < p2 && dc < 5) dc += 1; else break;\\nif(ct < p3 && dc < 5) dc += 1; else break;\\n} while(false);\\nif(bc >= 5 || dc >= 5)\\ncolor = vec4(1.0f, pixel.gba);\\n}\\nelse {\\ncolor = vec4(1.0f, pixel.gba);\\n}\\n}\\n}\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform float threshold;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nivec2 size = outputSize();\\nvec4 pixel = threadPixel(image);\\ncolor = vec4(0.0f, pixel.gba);\\nif(\\nthread.x >= 3 && thread.x < size.x - 3 &&\\nthread.y >= 3 && thread.y < size.y - 3\\n) {\\nfloat t = clamp(threshold, 0.0f, 1.0f);\\nfloat c = pixel.g;\\nfloat ct = c + t, c_t = c - t;\\nfloat p0 = pixelAtOffset(image, ivec2(0, 2)).g;\\nfloat p1 = pixelAtOffset(image, ivec2(1, 2)).g;\\nfloat p2 = pixelAtOffset(image, ivec2(2, 1)).g;\\nfloat p3 = pixelAtOffset(image, ivec2(2, 0)).g;\\nfloat p4 = pixelAtOffset(image, ivec2(2, -1)).g;\\nfloat p5 = pixelAtOffset(image, ivec2(1, -2)).g;\\nfloat p6 = pixelAtOffset(image, ivec2(0, -2)).g;\\nfloat p7 = pixelAtOffset(image, ivec2(-1, -2)).g;\\nfloat p8 = pixelAtOffset(image, ivec2(-2, -1)).g;\\nfloat p9 = pixelAtOffset(image, ivec2(-2, 0)).g;\\nfloat p10 = pixelAtOffset(image, ivec2(-2, 1)).g;\\nfloat p11 = pixelAtOffset(image, ivec2(-1, 2)).g;\\nbool possibleCorner =\\n((c_t > p0 || c_t > p6) && (c_t > p3 || c_t > p9)) ||\\n((ct < p0  || ct < p6)  && (ct < p3  || ct < p9))  ;\\nif(possibleCorner) {\\nint bright = 0, dark = 0, bc = 0, dc = 0;\\nif(c_t > p0) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p0) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p1) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p1) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p2) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p2) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p3) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p3) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p4) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p4) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p5) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p5) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p6) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p6) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p7) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p7) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p8) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p8) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p9) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p9) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p10) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p10) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p11) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p11) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(bright < 7 && dark < 7) {\\nif(bc > 0 && bc < 7) do {\\nif(c_t > p0)           bc += 1; else break;\\nif(c_t > p1 && bc < 7) bc += 1; else break;\\nif(c_t > p2 && bc < 7) bc += 1; else break;\\nif(c_t > p3 && bc < 7) bc += 1; else break;\\nif(c_t > p4 && bc < 7) bc += 1; else break;\\nif(c_t > p5 && bc < 7) bc += 1; else break;\\n} while(false);\\nif(dc > 0 && dc < 7) do {\\nif(ct < p0)           dc += 1; else break;\\nif(ct < p1 && dc < 7) dc += 1; else break;\\nif(ct < p2 && dc < 7) dc += 1; else break;\\nif(ct < p3 && dc < 7) dc += 1; else break;\\nif(ct < p4 && dc < 7) dc += 1; else break;\\nif(ct < p5 && dc < 7) dc += 1; else break;\\n} while(false);\\nif(bc >= 7 || dc >= 7)\\ncolor = vec4(1.0f, pixel.gba);\\n}\\nelse {\\ncolor = vec4(1.0f, pixel.gba);\\n}\\n}\\n}\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform float threshold;\\nconst ivec4 margin = ivec4(3, 3, 4, 4);\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nivec2 thread = threadLocation();\\nivec2 size = outputSize();\\ncolor = vec4(0.0f, pixel.gba);\\nif(any(lessThan(ivec4(thread, size - thread), margin)))\\nreturn;\\nfloat t = clamp(threshold, 0.0f, 1.0f);\\nfloat ct = pixel.g + t, c_t = pixel.g - t;\\nfloat p0 = pixelAtOffset(image, ivec2(0, 3)).g;\\nfloat p4 = pixelAtOffset(image, ivec2(3, 0)).g;\\nfloat p8 = pixelAtOffset(image, ivec2(0, -3)).g;\\nfloat p12 = pixelAtOffset(image, ivec2(-3, 0)).g;\\nif(!(\\n((c_t > p0 || c_t > p8) && (c_t > p4 || c_t > p12)) ||\\n((ct < p0  || ct < p8)  && (ct < p4  || ct < p12))\\n))\\nreturn;\\nfloat p1 = pixelAtOffset(image, ivec2(1, 3)).g;\\nfloat p2 = pixelAtOffset(image, ivec2(2, 2)).g;\\nfloat p3 = pixelAtOffset(image, ivec2(3, 1)).g;\\nfloat p5 = pixelAtOffset(image, ivec2(3, -1)).g;\\nfloat p6 = pixelAtOffset(image, ivec2(2, -2)).g;\\nfloat p7 = pixelAtOffset(image, ivec2(1, -3)).g;\\nfloat p9 = pixelAtOffset(image, ivec2(-1, -3)).g;\\nfloat p10 = pixelAtOffset(image, ivec2(-2, -2)).g;\\nfloat p11 = pixelAtOffset(image, ivec2(-3, -1)).g;\\nfloat p13 = pixelAtOffset(image, ivec2(-3, 1)).g;\\nfloat p14 = pixelAtOffset(image, ivec2(-2, 2)).g;\\nfloat p15 = pixelAtOffset(image, ivec2(-1, 3)).g;\\nbool A=(p0>ct),B=(p1>ct),C=(p2>ct),D=(p3>ct),E=(p4>ct),F=(p5>ct),G=(p6>ct),H=(p7>ct),I=(p8>ct),J=(p9>ct),K=(p10>ct),L=(p11>ct),M=(p12>ct),N=(p13>ct),O=(p14>ct),P=(p15>ct),a=(p0<c_t),b=(p1<c_t),c=(p2<c_t),d=(p3<c_t),e=(p4<c_t),f=(p5<c_t),g=(p6<c_t),h=(p7<c_t),i=(p8<c_t),j=(p9<c_t),k=(p10<c_t),l=(p11<c_t),m=(p12<c_t),n=(p13<c_t),o=(p14<c_t),p=(p15<c_t);\\nbool isCorner=A&&(B&&(K&&L&&J&&(M&&N&&O&&P||G&&H&&I&&(M&&N&&O||F&&(M&&N||E&&(M||D))))||C&&(K&&L&&M&&(N&&O&&P||G&&H&&I&&J&&(N&&O||F&&(N||E)))||D&&(N&&(L&&M&&(K&&G&&H&&I&&J&&(O||F)||O&&P)||k&&l&&m&&e&&f&&g&&h&&i&&j)||E&&(O&&(M&&N&&(K&&L&&G&&H&&I&&J||P)||k&&l&&m&&n&&f&&g&&h&&i&&j)||F&&(P&&(N&&O||k&&l&&m&&n&&o&&g&&h&&i&&j)||G&&(O&&P||H&&(P||I)||k&&l&&m&&n&&o&&p&&h&&i&&j)||k&&l&&m&&n&&o&&h&&i&&j&&(p||g))||k&&l&&m&&n&&h&&i&&j&&(o&&(p||g)||f&&(o&&p||g)))||k&&l&&m&&h&&i&&j&&(n&&(o&&p||g&&(o||f))||e&&(n&&o&&p||g&&(n&&o||f))))||k&&l&&h&&i&&j&&(m&&(n&&o&&p||g&&(n&&o||f&&(n||e)))||d&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e)))))||k&&h&&i&&j&&(l&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d))))))||K&&I&&J&&(L&&M&&N&&O&&P||G&&H&&(L&&M&&N&&O||F&&(L&&M&&N||E&&(L&&M||D&&(L||C)))))||h&&i&&j&&(b&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c)))))||k&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c)))))))||B&&(H&&I&&J&&(K&&L&&M&&N&&O&&P&&a||G&&(K&&L&&M&&N&&O&&a||F&&(K&&L&&M&&N&&a||E&&(K&&L&&M&&a||D&&(K&&L&&a||C)))))||a&&k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||C&&(K&&H&&I&&J&&(L&&M&&N&&O&&P&&a&&b||G&&(L&&M&&N&&O&&a&&b||F&&(L&&M&&N&&a&&b||E&&(L&&M&&a&&b||D))))||a&&b&&k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d)))))||D&&(K&&L&&H&&I&&J&&(M&&N&&O&&P&&a&&b&&c||G&&(M&&N&&O&&a&&b&&c||F&&(M&&N&&a&&b&&c||E)))||a&&b&&k&&l&&m&&c&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e))))||E&&(K&&L&&M&&H&&I&&J&&(N&&O&&P&&a&&b&&c&&d||G&&(N&&O&&a&&b&&c&&d||F))||a&&b&&l&&m&&n&&c&&d&&(k&&g&&h&&i&&j&&(o||f)||o&&p))||F&&(K&&L&&M&&N&&H&&I&&J&&(O&&P&&a&&b&&c&&d&&e||G)||a&&b&&m&&n&&o&&c&&d&&e&&(k&&l&&g&&h&&i&&j||p))||G&&(K&&L&&M&&N&&O&&H&&I&&J||a&&b&&n&&o&&p&&c&&d&&e&&f)||H&&(K&&L&&M&&N&&O&&P&&I&&J||a&&b&&o&&p&&c&&d&&e&&f&&g)||a&&(b&&(k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(k&&l&&m&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e)))||d&&(l&&m&&n&&(k&&g&&h&&i&&j&&(o||f)||o&&p)||e&&(m&&n&&o&&(k&&l&&g&&h&&i&&j||p)||f&&(n&&o&&p||g&&(o&&p||h&&(p||i)))))))||k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||h&&i&&j&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c&&(b||k))))));\\ncolor = vec4(float(isCorner), pixel.gba);\\n}\"","module.exports = \"uniform sampler2D corners;\\nuniform sampler2D maxScore;\\nuniform float quality;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(corners);\\nfloat threshold = threadPixel(maxScore).r * clamp(quality, 0.0f, 1.0f);\\nfloat score = step(threshold, pixel.r) * pixel.r;\\ncolor = vec4(score, pixel.gba);\\n}\"","module.exports = \"@include \\\"pyramids.glsl\\\"\\nuniform sampler2D pyramid;\\nuniform float threshold;\\nuniform int numberOfOctaves;\\nconst ivec4 margin = ivec4(3, 3, 4, 4);\\nconst vec4 zeroes = vec4(0.0f, 0.0f, 0.0f, 0.0f);\\nconst vec4 ones = vec4(1.0f, 1.0f, 1.0f, 1.0f);\\nvoid main()\\n{\\nvec4 pixel = threadPixel(pyramid);\\nivec2 thread = threadLocation();\\nivec2 size = outputSize();\\nfloat t = clamp(threshold, 0.0f, 1.0f);\\nfloat ct = pixel.g + t, c_t = pixel.g - t;\\nvec2 best = vec2(0.0f, pixel.a);\\n#ifdef USE_HARRIS_SCORE\\nvec2 dfmm[PYRAMID_MAX_OCTAVES], dfm0[PYRAMID_MAX_OCTAVES], dfm1[PYRAMID_MAX_OCTAVES],\\ndf0m[PYRAMID_MAX_OCTAVES], df00[PYRAMID_MAX_OCTAVES], df01[PYRAMID_MAX_OCTAVES],\\ndf1m[PYRAMID_MAX_OCTAVES], df10[PYRAMID_MAX_OCTAVES], df11[PYRAMID_MAX_OCTAVES];\\nfloat pyrpix = 0.0f;\\nfor(int l = 0; l < PYRAMID_MAX_OCTAVES; l++) {\\nfloat lod = float(l) * 0.5f;\\nfloat pot = exp2(lod);\\npyrpix = pyrPixelAtOffset(pyramid, lod, pot, ivec2(-1,-1)).g;\\ndfmm[l] = vec2(dFdx(pyrpix), dFdy(pyrpix));\\npyrpix = pyrPixelAtOffset(pyramid, lod, pot, ivec2(-1,0)).g;\\ndfm0[l] = vec2(dFdx(pyrpix), dFdy(pyrpix));\\npyrpix = pyrPixelAtOffset(pyramid, lod, pot, ivec2(-1,1)).g;\\ndfm1[l] = vec2(dFdx(pyrpix), dFdy(pyrpix));\\npyrpix = pyrPixelAtOffset(pyramid, lod, pot, ivec2(0,-1)).g;\\ndf0m[l] = vec2(dFdx(pyrpix), dFdy(pyrpix));\\npyrpix = pyrPixelAtOffset(pyramid, lod, pot, ivec2(0,0)).g;\\ndf00[l] = vec2(dFdx(pyrpix), dFdy(pyrpix));\\npyrpix = pyrPixelAtOffset(pyramid, lod, pot, ivec2(0,1)).g;\\ndf01[l] = vec2(dFdx(pyrpix), dFdy(pyrpix));\\npyrpix = pyrPixelAtOffset(pyramid, lod, pot, ivec2(1,-1)).g;\\ndf1m[l] = vec2(dFdx(pyrpix), dFdy(pyrpix));\\npyrpix = pyrPixelAtOffset(pyramid, lod, pot, ivec2(1,0)).g;\\ndf10[l] = vec2(dFdx(pyrpix), dFdy(pyrpix));\\npyrpix = pyrPixelAtOffset(pyramid, lod, pot, ivec2(1,1)).g;\\ndf11[l] = vec2(dFdx(pyrpix), dFdy(pyrpix));\\n}\\n#endif\\ncolor = vec4(0.0f, pixel.g, 0.0f, pixel.a);\\nfloat lod = 0.0f, pot = 1.0f;\\nfor(int octave = 0; octave < numberOfOctaves; octave++, pot = exp2(lod += 0.5f)) {\\npixel = pyrPixel(pyramid, lod);\\nct = pixel.g + t;\\nc_t = pixel.g - t;\\nvec4 p4k = vec4(\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(0, 3)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(3, 0)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(0, -3)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-3, 0)).g\\n);\\nmat4 mp = mat4(\\np4k.x,\\np4k.y,\\np4k.z,\\np4k.w,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(1, 3)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(3, -1)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-1, -3)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-3, 1)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(2, 2)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(2, -2)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-2, -2)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-2, 2)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(3, 1)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(1, -3)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-3, -1)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-1, 3)).g\\n);\\nbool A=(mp[0][0]>ct),B=(mp[1][0]>ct),C=(mp[2][0]>ct),D=(mp[3][0]>ct),E=(mp[0][1]>ct),F=(mp[1][1]>ct),G=(mp[2][1]>ct),H=(mp[3][1]>ct),I=(mp[0][2]>ct),J=(mp[1][2]>ct),K=(mp[2][2]>ct),L=(mp[3][2]>ct),M=(mp[0][3]>ct),N=(mp[1][3]>ct),O=(mp[2][3]>ct),P=(mp[3][3]>ct),a=(mp[0][0]<c_t),b=(mp[1][0]<c_t),c=(mp[2][0]<c_t),d=(mp[3][0]<c_t),e=(mp[0][1]<c_t),f=(mp[1][1]<c_t),g=(mp[2][1]<c_t),h=(mp[3][1]<c_t),i=(mp[0][2]<c_t),j=(mp[1][2]<c_t),k=(mp[2][2]<c_t),l=(mp[3][2]<c_t),m=(mp[0][3]<c_t),n=(mp[1][3]<c_t),o=(mp[2][3]<c_t),p=(mp[3][3]<c_t);\\nbool isCorner=A&&(B&&(K&&L&&J&&(M&&N&&O&&P||G&&H&&I&&(M&&N&&O||F&&(M&&N||E&&(M||D))))||C&&(K&&L&&M&&(N&&O&&P||G&&H&&I&&J&&(N&&O||F&&(N||E)))||D&&(N&&(L&&M&&(K&&G&&H&&I&&J&&(O||F)||O&&P)||k&&l&&m&&e&&f&&g&&h&&i&&j)||E&&(O&&(M&&N&&(K&&L&&G&&H&&I&&J||P)||k&&l&&m&&n&&f&&g&&h&&i&&j)||F&&(P&&(N&&O||k&&l&&m&&n&&o&&g&&h&&i&&j)||G&&(O&&P||H&&(P||I)||k&&l&&m&&n&&o&&p&&h&&i&&j)||k&&l&&m&&n&&o&&h&&i&&j&&(p||g))||k&&l&&m&&n&&h&&i&&j&&(o&&(p||g)||f&&(o&&p||g)))||k&&l&&m&&h&&i&&j&&(n&&(o&&p||g&&(o||f))||e&&(n&&o&&p||g&&(n&&o||f))))||k&&l&&h&&i&&j&&(m&&(n&&o&&p||g&&(n&&o||f&&(n||e)))||d&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e)))))||k&&h&&i&&j&&(l&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d))))))||K&&I&&J&&(L&&M&&N&&O&&P||G&&H&&(L&&M&&N&&O||F&&(L&&M&&N||E&&(L&&M||D&&(L||C)))))||h&&i&&j&&(b&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c)))))||k&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c)))))))||B&&(H&&I&&J&&(K&&L&&M&&N&&O&&P&&a||G&&(K&&L&&M&&N&&O&&a||F&&(K&&L&&M&&N&&a||E&&(K&&L&&M&&a||D&&(K&&L&&a||C)))))||a&&k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||C&&(K&&H&&I&&J&&(L&&M&&N&&O&&P&&a&&b||G&&(L&&M&&N&&O&&a&&b||F&&(L&&M&&N&&a&&b||E&&(L&&M&&a&&b||D))))||a&&b&&k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d)))))||D&&(K&&L&&H&&I&&J&&(M&&N&&O&&P&&a&&b&&c||G&&(M&&N&&O&&a&&b&&c||F&&(M&&N&&a&&b&&c||E)))||a&&b&&k&&l&&m&&c&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e))))||E&&(K&&L&&M&&H&&I&&J&&(N&&O&&P&&a&&b&&c&&d||G&&(N&&O&&a&&b&&c&&d||F))||a&&b&&l&&m&&n&&c&&d&&(k&&g&&h&&i&&j&&(o||f)||o&&p))||F&&(K&&L&&M&&N&&H&&I&&J&&(O&&P&&a&&b&&c&&d&&e||G)||a&&b&&m&&n&&o&&c&&d&&e&&(k&&l&&g&&h&&i&&j||p))||G&&(K&&L&&M&&N&&O&&H&&I&&J||a&&b&&n&&o&&p&&c&&d&&e&&f)||H&&(K&&L&&M&&N&&O&&P&&I&&J||a&&b&&o&&p&&c&&d&&e&&f&&g)||a&&(b&&(k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(k&&l&&m&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e)))||d&&(l&&m&&n&&(k&&g&&h&&i&&j&&(o||f)||o&&p)||e&&(m&&n&&o&&(k&&l&&g&&h&&i&&j||p)||f&&(n&&o&&p||g&&(o&&p||h&&(p||i)))))))||k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||h&&i&&j&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c&&(b||k))))));\\nfloat score = 0.0f;\\n#ifdef USE_HARRIS_SCORE\\nint lodIndex = int(lod * 2.0f);\\nvec2 df0 = dfmm[lodIndex], df1 = dfm0[lodIndex], df2 = dfm1[lodIndex],\\ndf3 = df0m[lodIndex], df4 = df00[lodIndex], df5 = df01[lodIndex],\\ndf6 = df1m[lodIndex], df7 = df10[lodIndex], df8 = df11[lodIndex];\\nvec3 hm = vec3(0.0f);\\nhm += vec3(df0.x * df0.x, df0.x * df0.y, df0.y * df0.y);\\nhm += vec3(df1.x * df1.x, df1.x * df1.y, df1.y * df1.y);\\nhm += vec3(df2.x * df2.x, df2.x * df2.y, df2.y * df2.y);\\nhm += vec3(df3.x * df3.x, df3.x * df3.y, df3.y * df3.y);\\nhm += vec3(df4.x * df4.x, df4.x * df4.y, df4.y * df4.y);\\nhm += vec3(df5.x * df5.x, df5.x * df5.y, df5.y * df5.y);\\nhm += vec3(df6.x * df6.x, df6.x * df6.y, df6.y * df6.y);\\nhm += vec3(df7.x * df7.x, df7.x * df7.y, df7.y * df7.y);\\nhm += vec3(df8.x * df8.x, df8.x * df8.y, df8.y * df8.y);\\nfloat response = 0.5f * (hm.x + hm.z - sqrt((hm.x - hm.z) * (hm.x - hm.z) + 4.0f * hm.y * hm.y));\\nscore = response;\\n#else\\nmat4 mct = mp - mat4(\\nct, ct, ct, ct,\\nct, ct, ct, ct,\\nct, ct, ct, ct,\\nct, ct, ct, ct\\n), mc_t = mat4(\\nc_t, c_t, c_t, c_t,\\nc_t, c_t, c_t, c_t,\\nc_t, c_t, c_t, c_t,\\nc_t, c_t, c_t, c_t\\n) - mp;\\nvec4 bs = max(mc_t[0], zeroes), ds = max(mct[0], zeroes);\\nbs += max(mc_t[1], zeroes); ds += max(mct[1], zeroes);\\nbs += max(mc_t[2], zeroes); ds += max(mct[2], zeroes);\\nbs += max(mc_t[3], zeroes); ds += max(mct[3], zeroes);\\nscore = max(dot(bs, ones), dot(ds, ones)) / 16.0f;\\n#endif\\nscore *= float(isCorner);\\nivec2 remainder = thread % int(pot);\\nscore *= float(remainder.x + remainder.y == 0);\\nfloat scale = encodeLod(lod);\\nbest = (score > best.x) ? vec2(score, scale) : best;\\n}\\ncolor.rba = best.xxy;\\n}\"","module.exports = \"@include \\\"sobel.glsl\\\"\\n@include \\\"pyramids.glsl\\\"\\nuniform sampler2D pyramid;\\nuniform int windowRadius;\\nuniform int numberOfOctaves;\\nuniform sampler2D sobelDerivatives[@PYRAMID_MAX_OCTAVES@];\\nvec4 pickSobelDerivatives(int index, ivec2 offset)\\n{\\nswitch(index) {\\ncase 0:  return textureLod(sobelDerivatives[0], texCoord + vec2(offset) / texSize, 0.0f);\\ncase 1:  return textureLod(sobelDerivatives[1], texCoord + vec2(offset) / texSize, 0.0f);\\ncase 2:  return textureLod(sobelDerivatives[2], texCoord + vec2(offset) / texSize, 0.0f);\\ncase 3:  return textureLod(sobelDerivatives[3], texCoord + vec2(offset) / texSize, 0.0f);\\ncase 4:  return textureLod(sobelDerivatives[4], texCoord + vec2(offset) / texSize, 0.0f);\\ncase 5:  return textureLod(sobelDerivatives[5], texCoord + vec2(offset) / texSize, 0.0f);\\ncase 6:  return textureLod(sobelDerivatives[6], texCoord + vec2(offset) / texSize, 0.0f);\\ndefault: return textureLod(sobelDerivatives[0], texCoord + vec2(offset) / texSize, 0.0f);\\n}\\n}\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nvec4 pixel = threadPixel(pyramid);\\nvec2 best = vec2(0.0f, pixel.a);\\nfor(int octave = 0; octave < numberOfOctaves; octave++) {\\nvec3 m = vec3(0.0f, 0.0f, 0.0f);\\nfor(int j = -windowRadius; j <= windowRadius; j++) {\\nfor(int i = -windowRadius; i <= windowRadius; i++) {\\nvec2 df = decodeSobel(pickSobelDerivatives(octave, ivec2(i, j)));\\nm += vec3(df.x * df.x, df.x * df.y, df.y * df.y);\\n}\\n}\\nfloat response = 0.5f * (m.x + m.z - sqrt((m.x - m.z) * (m.x - m.z) + 4.0f * m.y * m.y));\\nfloat score = max(0.0f, response / 4.0f);\\nfloat lod = 0.5f * float(octave);\\nfloat scale = encodeLod(lod);\\nbest = (score > best.x) ? vec2(score, scale) : best;\\n}\\ncolor = vec4(best.x, pixel.g, best.xy);\\n}\"","module.exports = \"@include \\\"sobel.glsl\\\"\\n@include \\\"pyramids.glsl\\\"\\nuniform sampler2D pyramid;\\nuniform float lod;\\nconst mat3 horizontalKernel = mat3(\\n-1.0f, 0.0f, 1.0f,\\n-2.0f, 0.0f, 2.0f,\\n-1.0f, 0.0f, 1.0f\\n);\\nconst mat3 verticalKernel = mat3(\\n1.0f, 2.0f, 1.0f,\\n0.0f, 0.0f, 0.0f,\\n-1.0f,-2.0f,-1.0f\\n);\\nconst vec3 ones = vec3(1.0f, 1.0f, 1.0f);\\nvoid main()\\n{\\nfloat pot = exp2(lod);\\nmat3 neighbors = mat3(\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-1, -1)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(0, -1)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(1, -1)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-1, 0)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(0, 0)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(1, 0)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-1, 1)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(0, 1)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(1, 1)).g\\n);\\nmat3 sobelX = matrixCompMult(horizontalKernel, neighbors);\\nmat3 sobelY = matrixCompMult(verticalKernel, neighbors);\\nvec2 df = vec2(\\ndot(sobelX[0] + sobelX[1] + sobelX[2], ones),\\ndot(sobelY[0] + sobelY[1] + sobelY[2], ones)\\n);\\ncolor = encodeSobel(df);\\n}\"","module.exports = \"@include \\\"pyramids.glsl\\\"\\nuniform sampler2D image;\\n#define ENABLE_INNER_RING\\n#define ENABLE_MIDDLE_RING\\n#define ENABLE_OUTER_RING\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nfloat lod = decodeLod(pixel.a);\\nfloat lodJump = 0.5f;\\ncolor = pixel;\\nif(pixel.r == 0.0f)\\nreturn;\\n#ifdef ENABLE_INNER_RING\\nvec4 p0 = pixelAtOffset(image, ivec2(0, 1));\\nvec4 p1 = pixelAtOffset(image, ivec2(1, 1));\\nvec4 p2 = pixelAtOffset(image, ivec2(1, 0));\\nvec4 p3 = pixelAtOffset(image, ivec2(1, -1));\\nvec4 p4 = pixelAtOffset(image, ivec2(0, -1));\\nvec4 p5 = pixelAtOffset(image, ivec2(-1, -1));\\nvec4 p6 = pixelAtOffset(image, ivec2(-1, 0));\\nvec4 p7 = pixelAtOffset(image, ivec2(-1, 1));\\n#else\\nvec4 p0, p1, p2, p3, p4, p5, p6, p7;\\np0 = p1 = p2 = p3 = p4 = p5 = p6 = p7 = vec4(0.0f, 0.0f, 0.0f, 1.0f);\\n#endif\\n#ifdef ENABLE_MIDDLE_RING\\nvec4 q0 = pixelAtOffset(image, ivec2(0, 2));\\nvec4 q1 = pixelAtOffset(image, ivec2(1, 2));\\nvec4 q2 = pixelAtOffset(image, ivec2(2, 2));\\nvec4 q3 = pixelAtOffset(image, ivec2(2, 1));\\nvec4 q4 = pixelAtOffset(image, ivec2(2, 0));\\nvec4 q5 = pixelAtOffset(image, ivec2(2, -1));\\nvec4 q6 = pixelAtOffset(image, ivec2(2, -2));\\nvec4 q7 = pixelAtOffset(image, ivec2(1, -2));\\nvec4 q8 = pixelAtOffset(image, ivec2(0, -2));\\nvec4 q9 = pixelAtOffset(image, ivec2(-1, -2));\\nvec4 q10 = pixelAtOffset(image, ivec2(-2, -2));\\nvec4 q11 = pixelAtOffset(image, ivec2(-2, -1));\\nvec4 q12 = pixelAtOffset(image, ivec2(-2, 0));\\nvec4 q13 = pixelAtOffset(image, ivec2(-2, 1));\\nvec4 q14 = pixelAtOffset(image, ivec2(-2, 2));\\nvec4 q15 = pixelAtOffset(image, ivec2(-1, 2));\\n#else\\nvec4 q0, q1, q2, q3, q4, q5, q6, q7, q8, q9, q10, q11, q12, q13, q14, q15;\\nq0 = q1 = q2 = q3 = q4 = q5 = q6 = q7 = q8 = q9 = q10 =\\nq11 = q12 = q13 = q14 = q15= vec4(0.0f, 0.0f, 0.0f, 1.0f);\\n#endif\\n#ifdef ENABLE_OUTER_RING\\nvec4 r0 = pixelAtOffset(image, ivec2(0, 3));\\nvec4 r1 = pixelAtOffset(image, ivec2(1, 3));\\nvec4 r2 = pixelAtOffset(image, ivec2(3, 1));\\nvec4 r3 = pixelAtOffset(image, ivec2(3, 0));\\nvec4 r4 = pixelAtOffset(image, ivec2(3, -1));\\nvec4 r5 = pixelAtOffset(image, ivec2(1, -3));\\nvec4 r6 = pixelAtOffset(image, ivec2(0, -3));\\nvec4 r7 = pixelAtOffset(image, ivec2(-1, -3));\\nvec4 r8 = pixelAtOffset(image, ivec2(-3, -1));\\nvec4 r9 = pixelAtOffset(image, ivec2(-3, 0));\\nvec4 r10 = pixelAtOffset(image, ivec2(-3, 1));\\nvec4 r11 = pixelAtOffset(image, ivec2(-1, 3));\\nvec4 r12 = pixelAtOffset(image, ivec2(0, 4));\\nvec4 r13 = pixelAtOffset(image, ivec2(4, 0));\\nvec4 r14 = pixelAtOffset(image, ivec2(0, -4));\\nvec4 r15 = pixelAtOffset(image, ivec2(-4, 0));\\n#else\\nvec4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15;\\nr0 = r1 = r2 = r3 = r4 = r5 = r6 = r7 = r8 = r9 = r10 =\\nr11 = r12 = r13 = r14 = r15 = vec4(0.0f, 0.0f, 0.0f, 1.0f);\\n#endif\\nfloat lodPlus = min(lod + lodJump, PYRAMID_MAX_LEVELS - 1.0f);\\nfloat lodMinus = max(lod - lodJump, 0.0f);\\nfloat alphaPlus = encodeLod(lodPlus);\\nfloat alphaMinus = encodeLod(lodMinus);\\nmat3 innerScore = mat3(\\np0.r * float(isSameEncodedLod(p0.a, alphaPlus) || isSameEncodedLod(p0.a, alphaMinus)),\\np1.r * float(isSameEncodedLod(p1.a, alphaPlus) || isSameEncodedLod(p1.a, alphaMinus)),\\np2.r * float(isSameEncodedLod(p2.a, alphaPlus) || isSameEncodedLod(p2.a, alphaMinus)),\\np3.r * float(isSameEncodedLod(p3.a, alphaPlus) || isSameEncodedLod(p3.a, alphaMinus)),\\np4.r * float(isSameEncodedLod(p4.a, alphaPlus) || isSameEncodedLod(p4.a, alphaMinus)),\\np5.r * float(isSameEncodedLod(p5.a, alphaPlus) || isSameEncodedLod(p5.a, alphaMinus)),\\np6.r * float(isSameEncodedLod(p6.a, alphaPlus) || isSameEncodedLod(p6.a, alphaMinus)),\\np7.r * float(isSameEncodedLod(p7.a, alphaPlus) || isSameEncodedLod(p7.a, alphaMinus)),\\n0.0f\\n);\\nmat4 middleScore = mat4(\\nq0.r * float(isSameEncodedLod(q0.a, alphaPlus) || isSameEncodedLod(q0.a, alphaMinus)),\\nq1.r * float(isSameEncodedLod(q1.a, alphaPlus) || isSameEncodedLod(q1.a, alphaMinus)),\\nq2.r * float(isSameEncodedLod(q2.a, alphaPlus) || isSameEncodedLod(q2.a, alphaMinus)),\\nq3.r * float(isSameEncodedLod(q3.a, alphaPlus) || isSameEncodedLod(q3.a, alphaMinus)),\\nq4.r * float(isSameEncodedLod(q4.a, alphaPlus) || isSameEncodedLod(q4.a, alphaMinus)),\\nq5.r * float(isSameEncodedLod(q5.a, alphaPlus) || isSameEncodedLod(q5.a, alphaMinus)),\\nq6.r * float(isSameEncodedLod(q6.a, alphaPlus) || isSameEncodedLod(q6.a, alphaMinus)),\\nq7.r * float(isSameEncodedLod(q7.a, alphaPlus) || isSameEncodedLod(q7.a, alphaMinus)),\\nq8.r * float(isSameEncodedLod(q8.a, alphaPlus) || isSameEncodedLod(q8.a, alphaMinus)),\\nq9.r * float(isSameEncodedLod(q9.a, alphaPlus) || isSameEncodedLod(q9.a, alphaMinus)),\\nq10.r * float(isSameEncodedLod(q10.a, alphaPlus) || isSameEncodedLod(q10.a, alphaMinus)),\\nq11.r * float(isSameEncodedLod(q11.a, alphaPlus) || isSameEncodedLod(q11.a, alphaMinus)),\\nq12.r * float(isSameEncodedLod(q12.a, alphaPlus) || isSameEncodedLod(q12.a, alphaMinus)),\\nq13.r * float(isSameEncodedLod(q13.a, alphaPlus) || isSameEncodedLod(q13.a, alphaMinus)),\\nq14.r * float(isSameEncodedLod(q14.a, alphaPlus) || isSameEncodedLod(q14.a, alphaMinus)),\\nq15.r * float(isSameEncodedLod(q15.a, alphaPlus) || isSameEncodedLod(q15.a, alphaMinus))\\n);\\nmat4 outerScore = mat4(\\nr0.r * float(isSameEncodedLod(r0.a, alphaPlus) || isSameEncodedLod(r0.a, alphaMinus)),\\nr1.r * float(isSameEncodedLod(r1.a, alphaPlus) || isSameEncodedLod(r1.a, alphaMinus)),\\nr2.r * float(isSameEncodedLod(r2.a, alphaPlus) || isSameEncodedLod(r2.a, alphaMinus)),\\nr3.r * float(isSameEncodedLod(r3.a, alphaPlus) || isSameEncodedLod(r3.a, alphaMinus)),\\nr4.r * float(isSameEncodedLod(r4.a, alphaPlus) || isSameEncodedLod(r4.a, alphaMinus)),\\nr5.r * float(isSameEncodedLod(r5.a, alphaPlus) || isSameEncodedLod(r5.a, alphaMinus)),\\nr6.r * float(isSameEncodedLod(r6.a, alphaPlus) || isSameEncodedLod(r6.a, alphaMinus)),\\nr7.r * float(isSameEncodedLod(r7.a, alphaPlus) || isSameEncodedLod(r7.a, alphaMinus)),\\nr8.r * float(isSameEncodedLod(r8.a, alphaPlus) || isSameEncodedLod(r8.a, alphaMinus)),\\nr9.r * float(isSameEncodedLod(r9.a, alphaPlus) || isSameEncodedLod(r9.a, alphaMinus)),\\nr10.r * float(isSameEncodedLod(r10.a, alphaPlus) || isSameEncodedLod(r10.a, alphaMinus)),\\nr11.r * float(isSameEncodedLod(r11.a, alphaPlus) || isSameEncodedLod(r11.a, alphaMinus)),\\nr12.r * float(isSameEncodedLod(r12.a, alphaPlus) || isSameEncodedLod(r12.a, alphaMinus)),\\nr13.r * float(isSameEncodedLod(r13.a, alphaPlus) || isSameEncodedLod(r13.a, alphaMinus)),\\nr14.r * float(isSameEncodedLod(r14.a, alphaPlus) || isSameEncodedLod(r14.a, alphaMinus)),\\nr15.r * float(isSameEncodedLod(r15.a, alphaPlus) || isSameEncodedLod(r15.a, alphaMinus))\\n);\\nvec3 maxInnerScore3 = max(innerScore[0], max(innerScore[1], innerScore[2]));\\nvec4 maxMiddleScore4 = max(max(middleScore[0], middleScore[1]), max(middleScore[2], middleScore[3]));\\nvec4 maxOuterScore4 = max(max(outerScore[0], outerScore[1]), max(outerScore[2], outerScore[3]));\\nfloat maxInnerScore = max(maxInnerScore3.x, max(maxInnerScore3.y, maxInnerScore3.z));\\nfloat maxMiddleScore = max(max(maxMiddleScore4.x, maxMiddleScore4.y), max(maxMiddleScore4.z, maxMiddleScore4.w));\\nfloat maxOuterScore = max(max(maxOuterScore4.x, maxOuterScore4.y), max(maxOuterScore4.z, maxOuterScore4.w));\\nfloat maxScore = max(maxInnerScore, max(maxMiddleScore, maxOuterScore));\\nfloat myScore = step(maxScore, pixel.r) * pixel.r;\\ncolor = vec4(myScore, pixel.gba);\\n}\"","module.exports = \"uniform sampler2D image;\\nvoid main()\\n{\\nfloat p0 = pixelAtOffset(image, ivec2(0, 1)).r;\\nfloat p1 = pixelAtOffset(image, ivec2(1, 1)).r;\\nfloat p2 = pixelAtOffset(image, ivec2(1, 0)).r;\\nfloat p3 = pixelAtOffset(image, ivec2(1, -1)).r;\\nfloat p4 = pixelAtOffset(image, ivec2(0, -1)).r;\\nfloat p5 = pixelAtOffset(image, ivec2(-1, -1)).r;\\nfloat p6 = pixelAtOffset(image, ivec2(-1, 0)).r;\\nfloat p7 = pixelAtOffset(image, ivec2(-1, 1)).r;\\nfloat m = max(\\nmax(max(p0, p1), max(p2, p3)),\\nmax(max(p4, p5), max(p6, p7))\\n);\\nvec4 pixel = threadPixel(image);\\nfloat score = step(m, pixel.r) * pixel.r;\\ncolor = vec4(score, pixel.gba);\\n}\"","module.exports = \"@include \\\"pyramids.glsl\\\"\\nuniform sampler2D image;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nivec2 thread = threadLocation();\\nfloat lod = decodeLod(pixel.a);\\nfloat pot = exp2(lod);\\ncolor = pixel;\\nif(pixel.r == 0.0f)\\nreturn;\\nvec4 p0 = pixelAtOffset(image, ivec2(0, 1));\\nvec4 p1 = pixelAtOffset(image, ivec2(1, 1));\\nvec4 p2 = pixelAtOffset(image, ivec2(1, 0));\\nvec4 p3 = pixelAtOffset(image, ivec2(1, -1));\\nvec4 p4 = pixelAtOffset(image, ivec2(0, -1));\\nvec4 p5 = pixelAtOffset(image, ivec2(-1, -1));\\nvec4 p6 = pixelAtOffset(image, ivec2(-1, 0));\\nvec4 p7 = pixelAtOffset(image, ivec2(-1, 1));\\nmat3 score = mat3(\\np0.r * float(isSameEncodedLod(p0.a, pixel.a)),\\np1.r * float(isSameEncodedLod(p1.a, pixel.a)),\\np2.r * float(isSameEncodedLod(p2.a, pixel.a)),\\np3.r * float(isSameEncodedLod(p3.a, pixel.a)),\\np4.r * float(isSameEncodedLod(p4.a, pixel.a)),\\np5.r * float(isSameEncodedLod(p5.a, pixel.a)),\\np6.r * float(isSameEncodedLod(p6.a, pixel.a)),\\np7.r * float(isSameEncodedLod(p7.a, pixel.a)),\\n0.0f\\n);\\nvec3 maxScore3 = max(score[0], max(score[1], score[2]));\\nfloat maxScore = max(maxScore3.x, max(maxScore3.y, maxScore3.z));\\nfloat myScore = step(maxScore, pixel.r) * pixel.r;\\ncolor = vec4(myScore, pixel.gba);\\n}\"","module.exports = \"uniform sampler2D image;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nivec2 size = outputSize();\\nivec2 zero = ivec2(0, 0);\\ncolor = pixelAt(image, clamp(thread, zero, size - 1));\\n}\"","module.exports = \"uniform sampler2D image;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nivec2 pos = min(thread * 2, textureSize(image, 0) - 1);\\ncolor = pixelAt(image, pos);\\n}\"","module.exports = \"uniform sampler2D image;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nivec2 pos = min(thread * 3, textureSize(image, 0) - 1);\\ncolor = pixelAt(image, pos);\\n}\"","module.exports = \"uniform sampler2D largerImage;\\nuniform sampler2D smallerImage;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nvec4 lg = pixelAt(largerImage, min(thread, textureSize(largerImage, 0) - 1));\\nvec4 sm = pixelAt(smallerImage, min(thread / 2, textureSize(smallerImage, 0) - 1));\\ncolor = ((((thread.x & 1) + (thread.y & 1)) == 0) && (sm.r > lg.r)) ? vec4(sm.r, lg.gb, sm.a) : lg;\\n}\"","module.exports = \"uniform sampler2D target;\\nuniform sampler2D source;\\nvoid main()\\n{\\nvec4 a = threadPixel(target);\\nvec4 b = threadPixel(source);\\ncolor = (b.r > a.r) ? b : a;\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform float imageScale;\\nconst ivec2 one = ivec2(1, 1);\\n#define B2(expr) bvec2((expr),(expr))\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nivec2 size = outputSize();\\nivec2 scaled = ivec2((texCoord * texSize) * imageScale);\\nivec2 imageSize = textureSize(image, 0);\\nvec4 pixel = threadPixel(image);\\nvec4 p0 = pixelAt(image, min(scaled, imageSize-1));\\nvec4 p1 = pixelAt(image, min(scaled + ivec2(0, 1), imageSize-1));\\nvec4 p2 = pixelAt(image, min(scaled + ivec2(1, 0), imageSize-1));\\nvec4 p3 = pixelAt(image, min(scaled + ivec2(1, 1), imageSize-1));\\nbool gotCorner = ((thread.x & 1) + (thread.y & 1) == 0) &&\\n(all(lessThan(scaled + one, size))) &&\\n(p0.r + p1.r + p2.r + p3.r > 0.0f);\\nvec2 best = mix(\\nvec2(0.0f, pixel.a),\\nmix(\\nmix(\\np1.r > p3.r ? p1.ra : p3.ra,\\np1.r > p2.r ? p1.ra : p2.ra,\\nB2(p2.r > p3.r)\\n),\\nmix(\\np0.r > p3.r ? p0.ra : p3.ra,\\np0.r > p2.r ? p0.ra : p2.ra,\\nB2(p2.r > p3.r)\\n),\\nB2(p0.r > p1.r)\\n),\\nB2(gotCorner)\\n);\\ncolor = vec4(best.x, pixel.gb, best.y);\\n}\"","module.exports = \"uniform sampler2D image;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nvec4 pixel = pixelAt(image, thread / 2);\\ncolor = (((thread.x + thread.y) & 1) == 0) ? pixel : vec4(0.0f, 0.0f, 0.0f, pixel.a);\\n}\"","module.exports = \"uniform sampler2D image;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nvec4 pixel = pixelAt(image, thread / 3);\\nbool cond = ((thread.x - (thread.y % 3) + 3) % 3) == 0;\\ncolor = (((thread.x - (thread.y % 3) + 3) % 3) == 0) ? pixel : vec4(0.0f, 0.0f, 0.0f, pixel.a);\\n}\"","module.exports = \"@include \\\"colors.glsl\\\"\\nuniform sampler2D dest, src;\\nuniform int destComponents;\\nuniform int srcComponentId;\\nvoid main()\\n{\\nvec4 destPixel = threadPixel(dest);\\nvec4 srcPixel = threadPixel(src);\\nbvec4 flags = bvec4(\\n(destComponents & PIXELCOMPONENT_RED) != 0,\\n(destComponents & PIXELCOMPONENT_GREEN) != 0,\\n(destComponents & PIXELCOMPONENT_BLUE) != 0,\\n(destComponents & PIXELCOMPONENT_ALPHA) != 0\\n);\\ncolor = mix(destPixel, vec4(srcPixel[srcComponentId]), flags);\\n}\"","module.exports = \"@include \\\"colors.glsl\\\"\\nuniform sampler2D image;\\nuniform int pixelComponents;\\nuniform float value;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nbvec4 flags = bvec4(\\n(pixelComponents & PIXELCOMPONENT_RED) != 0,\\n(pixelComponents & PIXELCOMPONENT_GREEN) != 0,\\n(pixelComponents & PIXELCOMPONENT_BLUE) != 0,\\n(pixelComponents & PIXELCOMPONENT_ALPHA) != 0\\n);\\ncolor = mix(pixel, vec4(value), flags);\\n}\"","module.exports = \"uniform float value;\\nvoid main()\\n{\\ncolor = vec4(value);\\n}\"","module.exports = \"uniform sampler2D image;\\nvoid main() {\\nivec2 pos = threadLocation();\\npos.y = int(texSize.y) - 1 - pos.y;\\ncolor = pixelAt(image, pos);\\n}\"","module.exports = \"uniform sampler2D image;\\nvoid main()\\n{\\ncolor = threadPixel(image);\\n}\"","module.exports = \"#ifdef GREYSCALE\\nuniform sampler2D minmax2d;\\n#else\\nuniform sampler2D minmax2dRGB[3];\\n#endif\\nuniform float minValue;\\nuniform float maxValue;\\nconst float eps = 1.0f / 255.0f;\\nvoid main()\\n{\\nvec2 minmax = clamp(vec2(minValue, maxValue), 0.0f, 255.0f) / 255.0f;\\nvec4 newMin = vec4(minmax.x);\\nvec4 newRange = vec4(minmax.y - minmax.x);\\nvec4 alpha = vec4(1.0f, newMin.x, newRange.x, 1.0f);\\n#ifdef GREYSCALE\\nvec4 pixel = threadPixel(minmax2d);\\nmat4 channel = mat4(pixel, pixel, pixel, alpha);\\n#else\\nmat4 channel = mat4(\\nthreadPixel(minmax2dRGB[0]),\\nthreadPixel(minmax2dRGB[1]),\\nthreadPixel(minmax2dRGB[2]),\\nalpha\\n);\\n#endif\\nvec4 oldMin = vec4(channel[0].g, channel[1].g, channel[2].g, channel[3].g);\\nvec4 oldRange = max(vec4(channel[0].b, channel[1].b, channel[2].b, channel[3].b), eps);\\nvec4 oldIntensity = vec4(channel[0].a, channel[1].a, channel[2].a, channel[3].a);\\nvec4 newIntensity = (oldIntensity - oldMin) * newRange / oldRange + newMin;\\ncolor = newIntensity;\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform int iterationNumber;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nivec2 last = outputSize() - ivec2(1);\\nint jump = (1 << iterationNumber);\\nint clusterLength = jump << 1;\\nint clusterMask = clusterLength - 1;\\nivec2 clusterPos = ivec2(thread >> (1 + iterationNumber)) << (1 + iterationNumber);\\nivec2 next1 = clusterPos + ((thread - clusterPos + ivec2(jump, 0)) & clusterMask);\\nivec2 next2 = clusterPos + ((thread - clusterPos + ivec2(0, jump)) & clusterMask);\\nivec2 next3 = clusterPos + ((thread - clusterPos + ivec2(jump, jump)) & clusterMask);\\nvec4 p0 = texelFetch(image, thread, 0);\\nvec4 p1 = texelFetch(image, min(next1, last), 0);\\nvec4 p2 = texelFetch(image, min(next2, last), 0);\\nvec4 p3 = texelFetch(image, min(next3, last), 0);\\nvec4 pmax = max(max(p0, p1), max(p2, p3));\\nvec4 pmin = min(min(p0, p1), min(p2, p3));\\ncolor = vec4(pmax.r, pmin.g, pmax.r - pmin.g, p0.a);\\n}\"","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-gpu.js\n * GPU routines for accelerated computer vision\n */\n\nimport { GLUtils } from './gl-utils.js';\nimport { Utils } from '../utils/utils';\nimport { SpeedyProgramCenter } from './speedy-program-center';\nimport { PYRAMID_MAX_LEVELS, PYRAMID_MAX_SCALE, MAX_TEXTURE_LENGTH } from '../utils/globals';\nimport { NotSupportedError, IllegalArgumentError } from '../utils/errors';\n\n/**\n * GPU routines for\n * accelerated computer vision\n */\nexport class SpeedyGPU\n{\n    /**\n     * Class constructor\n     * @param {number} width Texture width\n     * @param {number} height Texture height\n     */\n    constructor(width, height)\n    {\n        // initialize properties\n        this._gl = null;\n        this._canvas = null;\n        this._width = 0;\n        this._height = 0;\n        this._programs = null;\n        this._pyramid = null;\n        this._intraPyramid = null;\n        this._inputTexture = null;\n        this._inputTextureIndex = 0;\n        this._omitGLContextWarning = false;\n\n        // does the browser support WebGL2?\n        checkWebGL2Availability();\n\n        // read & validate texture size\n        this._width = Math.max(1, width | 0);\n        this._height = Math.max(1, height | 0);\n        if(this._width > MAX_TEXTURE_LENGTH || this._height > MAX_TEXTURE_LENGTH) {\n            Utils.warning(`Maximum texture size exceeded (using ${this._width} x ${this._height}).`);\n            this._width = Math.min(this._width, MAX_TEXTURE_LENGTH);\n            this._height = Math.min(this._height, MAX_TEXTURE_LENGTH);\n        }\n\n        // setup WebGL\n        this._setupWebGL();\n    }\n\n    /**\n     * WebGL context\n     * Be careful when caching this, as the context may be lost!\n     * @returns {WebGL2RenderingContext}\n     */\n    get gl()\n    {\n        return this._gl;\n    }\n\n    /**\n     * Internal canvas\n     * @returns {HTMLCanvasElement|OffscreenCanvas}\n     */\n    get canvas()\n    {\n        return this._canvas;\n    }\n\n    /**\n     * Access point to all GPU programs\n     * @returns {SpeedyProgramCenter}\n     */\n    get programs()\n    {\n        return this._programs;\n    }\n\n    /**\n     * Access the program groups of a pyramid level\n     * sizeof(pyramid(i)) = sizeof(pyramid(0)) / 2^i\n     * @param {number} level a number in 0, 1, ..., PYRAMID_MAX_LEVELS - 1\n     * @returns {Array}\n     */\n    pyramid(level)\n    {\n        const lv = level | 0;\n\n        if(lv < 0 || lv >= PYRAMID_MAX_LEVELS)\n            throw new IllegalArgumentError(`Invalid pyramid level: ${lv}`);\n\n        return this._pyramid[lv];\n    }\n\n    /**\n     * Access the program groups of an intra-pyramid level\n     * The intra-pyramid encodes layers between pyramid layers\n     * sizeof(intraPyramid(0)) = 1.5 * sizeof(pyramid(0))\n     * sizeof(intraPyramid(1)) = 1.5 * sizeof(pyramid(1))\n     * @param {number} level a number in 0, 1, ..., PYRAMID_MAX_LEVELS\n     * @returns {Array}\n     */\n    intraPyramid(level)\n    {\n        const lv = level | 0;\n\n        if(lv < 0 || lv >= PYRAMID_MAX_LEVELS + 1)\n            throw new IllegalArgumentError(`Invalid intra-pyramid level: ${lv}`);\n\n        return this._intraPyramid[lv];\n    }\n\n    /**\n     * The number of layers of the pyramid\n     * @returns {number}\n     */\n    get pyramidHeight()\n    {\n        return PYRAMID_MAX_LEVELS;\n    }\n\n    /**\n     * The maximum supported scale for a pyramid layer\n     * @returns {number}\n     */\n    get pyramidMaxScale()\n    {\n        return PYRAMID_MAX_SCALE;\n    }\n\n    /**\n     * Upload data to the GPU\n     * @param {ImageBitmap|ImageData|ArrayBufferView|HTMLImageElement|HTMLVideoElement|HTMLCanvasElement} data \n     * @param {number} [width]\n     * @param {number} [height] \n     * @returns {WebGLTexture}\n     */\n    upload(data, width = -1, height = -1)\n    {\n        const gl = this._gl;\n\n        // lost GL context?\n        if(gl.isContextLost()) {\n            Utils.warning(`Can't upload texture without a WebGL context`);\n            return (this._inputTexture = null);\n        }\n\n        // default values\n        if(width < 0)\n            width = gl.canvas.width;\n        if(height < 0)\n            height = gl.canvas.height;\n\n        // invalid dimensions?\n        if(width == 0 || height == 0)\n            throw new IllegalArgumentError(`Can't upload an image of area 0`);\n\n        // create or recreate & size texture\n        if(this._inputTexture === null) {\n            gl.canvas.width = Math.max(gl.canvas.width, width);\n            gl.canvas.height = Math.max(gl.canvas.height, height);\n            this._inputTexture = Array(2).fill(null).map(_ =>\n                GLUtils.createTexture(gl, gl.canvas.width, gl.canvas.height));\n        }\n        else if(width > gl.canvas.width || height > gl.canvas.height) {\n            Utils.warning(`Resizing input texture to ${width} x ${height}`)\n            this._inputTexture.forEach(inputTexture =>\n                GLUtils.destroyTexture(gl, inputTexture));\n            return this.upload(data, width, height);\n        }\n\n        // use round-robin to mitigate WebGL's implicit synchronization\n        // and maybe minimize texture upload times\n        this._inputTextureIndex = 1 - this._inputTextureIndex;\n\n        // done! note: the input texture is upside-down, i.e.,\n        // flipped on the y-axis. We need to unflip it on the\n        // output, so that (0,0) becomes the top-left corner\n        GLUtils.uploadToTexture(gl, this._inputTexture[this._inputTextureIndex], width, height, data);\n        return this._inputTexture[this._inputTextureIndex];\n    }\n\n    /**\n     * Clear the internal canvas\n     */\n    /*clearCanvas()\n    {\n        const gl = this._gl;\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n        gl.clearColor(0, 0, 0, 1);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n    }*/\n\n    /**\n     * Lose & restore the WebGL context\n     * @param {number} [timeToRestore] in seconds\n     * @return {Promise} resolves as soon as the context is restored,\n     *                   or as soon as it is lost if timeToRestore is Infinity\n     */\n    loseAndRestoreWebGLContext(timeToRestore = 1.0)\n    {\n        const gl = this._gl;\n\n        if(gl.isContextLost())\n            return Promise.reject('Context already lost');\n\n        const ext = gl.getExtension('WEBGL_lose_context');\n\n        if(ext) {\n            ext.loseContext();\n            return new Promise(resolve => {\n                if(isFinite(timeToRestore)) {\n                    setTimeout(() => {\n                        ext.restoreContext();\n                        setTimeout(() => resolve(), 0); // next frame\n                    }, Math.max(timeToRestore, 0) * 1000.0);\n                }\n                else\n                    resolve(); // won't restore\n            });\n        }\n        else\n            throw new NotSupportedError('WEBGL_lose_context is unavailable');\n    }\n\n    /**\n     * Lose the WebGL context.\n     * This is a way to manually free resources.\n     */\n    loseWebGLContext()\n    {\n        this._omitGLContextWarning = true;\n        return this.loseAndRestoreWebGLContext(Infinity);\n    }\n\n    // setup WebGL\n    _setupWebGL()\n    {\n        const width = this._width;\n        const height = this._height;\n\n        // initializing\n        this._programs = null;\n        this._pyramid = null;\n        this._intraPyramid = null;\n        this._inputTexture = null;\n        this._inputTextureIndex = 0;\n        this._omitGLContextWarning = false;\n        if(this._canvas !== undefined)\n            delete this._canvas;\n\n        // create canvas\n        this._canvas = createCanvas(width, height);\n        this._canvas.addEventListener('webglcontextlost', ev => {\n            if(!this._omitGLContextWarning)\n                Utils.warning('Lost WebGL context');\n            ev.preventDefault();\n        }, false);\n        this._canvas.addEventListener('webglcontextrestored', ev => {\n            if(!this._omitGLContextWarning)\n                Utils.warning('Restoring WebGL context...');\n            this._setupWebGL();\n        }, false);\n\n        // create WebGL context\n        this._gl = createWebGLContext(this._canvas);\n\n        // spawn program groups\n        this._programs = new SpeedyProgramCenter(this, width, height);\n\n        // spawn pyramids of program groups\n        this._pyramid = this._buildPyramid(width, height, 1.0, PYRAMID_MAX_LEVELS);\n        this._intraPyramid = this._buildPyramid(width, height, 1.5, PYRAMID_MAX_LEVELS + 1);\n    }\n\n    // build a pyramid, where each level stores the program groups\n    _buildPyramid(imageWidth, imageHeight, baseScale, numLevels)\n    {\n        let scale = +baseScale;\n        let width = (imageWidth * scale) | 0, height = (imageHeight * scale) | 0;\n        let pyramid = new Array(numLevels);\n\n        for(let i = 0; i < pyramid.length; i++) {\n            pyramid[i] = new SpeedyProgramCenter(this, width, height);\n            width = ((1 + width) / 2) | 0;\n            height = ((1 + height) / 2) | 0;\n            scale /= 2;\n        }\n\n        return pyramid;\n    }\n}\n\n// Create a canvas\nfunction createCanvas(width, height)\n{\n    const inWorker = (typeof importScripts === 'function') && (typeof WorkerGlobalScope !== 'undefined');\n\n    if(inWorker) {\n        if(typeof OffscreenCanvas !== 'function')\n            throw new NotSupportedError('OffscreenCanvas is not available in your browser. Please upgrade.');\n\n        return new OffscreenCanvas(width, height);\n    }\n    else {\n        const canvas = document.createElement('canvas');\n        canvas.width = width;\n        canvas.height = height;\n        return canvas;\n    }\n}\n\n// Checks if the browser supports WebGL2\nfunction checkWebGL2Availability()\n{\n    if(typeof WebGL2RenderingContext === 'undefined')\n        throw new NotSupportedError('WebGL2 is required by this application, but it\\'s not available in your browser. Please use a different browser.');\n}\n\n// Create a WebGL2 context\nfunction createWebGLContext(canvas)\n{\n    const gl = canvas.getContext('webgl2', {\n        premultipliedAlpha: false,\n        preserveDrawingBuffer: false,\n        //preferLowPowerToHighPerformance: false, // TODO user option?\n        alpha: true,\n        antialias: false,\n        depth: false,\n        stencil: false,\n    });\n\n    if(!gl)\n        throw new NotSupportedError('Can\\'t create WebGL2 context. Try in a different browser.');\n\n    return gl;\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-program-center.js\n * An access point to all programs that run on the GPU\n */\n\nimport { GPUUtils } from './programs/utils';\nimport { GPUColors } from './programs/colors';\nimport { GPUFilters } from './programs/filters';\nimport { GPUKeypoints } from './programs/keypoints';\nimport { GPUEncoders } from './programs/encoders';\nimport { GPUDescriptors } from './programs/descriptors';\nimport { GPUPyramids } from './programs/pyramids';\n\n/**\n * An access point to all programs that run on the CPU\n * All program groups can be accessed via this class\n */\nexport class SpeedyProgramCenter\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu \n     * @param {number} width default width for output textures\n     * @param {number} height default height for output textures\n     */\n    constructor(gpu, width, height)\n    {\n        // properties\n        this._gpu = gpu;\n        this._width = width;\n        this._height = height;\n\n        // program groups\n        // (lazy instantiation)\n        this._utils = null;\n        this._colors = null;\n        this._filters = null;\n        this._keypoints = null;\n        this._encoders = null;\n        this._descriptors = null;\n        this._pyramids = null;\n    }\n\n    /**\n     * Default width of the output texture of the programs\n     * @returns {number}\n     */\n    get width()\n    {\n        return this._width;\n    }\n\n    /**\n     * Default height of the output texture of the programs\n     * @returns {number}\n     */\n    get height()\n    {\n        return this._height;\n    }\n\n    /**\n     * Utility programs\n     * @returns {GPUUtils}\n     */\n    get utils()\n    {\n        return this._utils || (this._utils = new GPUUtils(this._gpu, this._width, this._height));\n    }\n\n    /**\n     * Programs related to color conversions\n     * @returns {GPUColors}\n     */\n    get colors()\n    {\n        return this._colors || (this._colors = new GPUColors(this._gpu, this._width, this._height));\n    }\n\n    /**\n     * Image filters & convolutions\n     * @returns {GPUFilters}\n     */\n    get filters()\n    {\n        return this._filters || (this._filters = new GPUFilters(this._gpu, this._width, this._height));\n    }\n\n    /**\n     * Keypoint detectors\n     * @returns {GPUKeypoints}\n     */\n    get keypoints()\n    {\n        return this._keypoints || (this._keypoints = new GPUKeypoints(this._gpu, this._width, this._height));\n    }\n\n    /**\n     * Keypoint encoders\n     * @returns {GPUEncoders}\n     */\n    get encoders()\n    {\n        return this._encoders || (this._encoders = new GPUEncoders(this._gpu, this._width, this._height));\n    }\n\n    /**\n     * Keypoint descriptors\n     * @returns {GPUDescriptors}\n     */\n    get descriptors()\n    {\n        return this._descriptors || (this._descriptors = new GPUDescriptors(this._gpu, this._width, this._height));\n    }\n\n    /**\n     * Image pyramids & scale-space\n     * @returns {GPUPyramids}\n     */\n    get pyramids()\n    {\n        return this._pyramids || (this._pyramids = new GPUPyramids(this._gpu, this._width, this._height));\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-program-group.js\n * An abstract group of programs that run on the GPU\n */\n\nimport { SpeedyProgram } from './speedy-program';\n\n/**\n * SpeedyProgramGroup\n * A semantically correlated group\n * of programs that run on the GPU\n */\n\nexport /* abstract */ class SpeedyProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} width Texture width (depends on the pyramid layer)\n     * @param {number} height Texture height (depends on the pyramid layer)\n     */\n    /* protected */ constructor(gpu, width, height)\n    {\n        this._gpu = gpu;\n        this._width = width;\n        this._height = height;\n    }\n\n    /**\n     * Declare a program\n     * @param {string} name Program name\n     * @param {ShaderDeclaration} shaderdecl Shader declaration\n     * @param {object} settings Program settings\n     * @returns {SpeedyProgramGroup} This object\n     */\n    /* protected */ declare(name, shaderdecl, settings = { })\n    {\n        // lazy instantiation of kernels\n        Object.defineProperty(this, name, {\n            get: (() => {\n                const key = '__k_' + name;\n                return (function() {\n                    return this[key] || (this[key] = this._createProgram(shaderdecl, settings));\n                }).bind(this);\n            })()\n        });\n\n        return this;\n    }\n\n    /**\n     * Multi-pass composition\n     * @param {string} name Program name\n     * @param {string} fn Other programs\n     * @returns {SpeedyProgramGroup} This object\n     */\n    /* protected */ compose(name, ...fn)\n    {\n        // function composition: functions are called in the order they are specified\n        // e.g., compose('h', 'f', 'g') means h(x) = g(f(x))\n        Object.defineProperty(this, name, {\n            get: (() => {\n                const key = '__c_' + name;\n                return (function() {\n                    return this[key] || (this[key] = (fn.length == 2) ? (() => {\n                        fn = fn.map(fi => this[fi]);\n                        return function compose(image, ...args) {\n                            return (fn[1])((fn[0])(image, ...args), ...args);\n                        };\n                    })() : ((fn.length == 3) ? (() => {\n                        fn = fn.map(fi => this[fi]);\n                        return function compose(image, ...args) {\n                            return (fn[2])((fn[1])((fn[0])(image, ...args), ...args), ...args);\n                        };\n                    })() : ((fn.length == 4) ? (() => {\n                        fn = fn.map(fi => this[fi]);\n                        return function compose(image, ...args) {\n                            return (fn[3])((fn[2])((fn[1])((fn[0])(image, ...args), ...args), ...args), ...args);\n                        };\n                    })() : (() => {\n                        fn = fn.map(fi => this[fi]);\n                        return function compose(image, ...args) {\n                            return fn.reduce((img, fi) => fi(img, ...args), image);\n                        };\n                    })())));\n                }).bind(this);\n            })()\n        });\n\n        return this;\n    }\n\n    /**\n     * Neat helpers to be used\n     * when defining programs\n     */\n    get program()\n    {\n        return this._helpers || (this.helpers = {\n\n            // Set texture input/output size\n            // Dimensions are converted to integers\n            hasTextureSize(width, height) {\n                return {\n                    output: [ width|0, height|0 ]\n                };\n            },\n\n            // Render to canvas\n            // Use it when we're supposed to see the texture\n            displaysGraphics() {\n                return {\n                    renderToTexture: false\n                };\n            },\n\n            // Calling the program will return a new\n            // instance of the output texture every time\n            // The returned texture must be released manually\n            doesNotRecycleTextures() {\n                return {\n                    recycleTexture: false\n                };\n            },\n\n            // Pingpong Rendering: the output texture of a\n            // program cannot be used as an input to itself.\n            // This is a convenient helper in these situations\n            usesPingpongRendering() {\n                return {\n                    pingpong: true\n                };\n            },\n\n        });\n    }\n\n    /* private */ _createProgram(shaderdecl, settings = { })\n    {\n        return new SpeedyProgram(this._gpu.gl, shaderdecl, {\n            // default settings\n            output: [ this._width, this._height ],\n            ...settings\n        });\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-program.js\n * SpeedyProgram class\n */\n\nimport { GLUtils } from './gl-utils.js';\nimport { NotSupportedError, IllegalArgumentError, IllegalOperationError } from '../utils/errors';\n\nconst LOCATION_ATTRIB_POSITION = 0;\nconst LOCATION_ATTRIB_TEXCOORD = 1;\n\nconst UNIFORM_TYPES = {\n    'sampler2D':'uniform1i',\n    'float':    'uniform1f',\n    'int':      'uniform1i',\n    'uint':     'uniform1ui',\n    'bool':     'uniform1i',\n    'vec2':     'uniform2f',\n    'vec3':     'uniform3f',\n    'vec4':     'uniform4f',\n    'ivec2':    'uniform2i',\n    'ivec3':    'uniform3i',\n    'ivec4':    'uniform4i',\n    'uvec2':    'uniform2ui',\n    'uvec3':    'uniform3ui',\n    'uvec4':    'uniform4ui',\n    'bvec2':    'uniform2i',\n    'bvec3':    'uniform3i',\n    'bvec4':    'uniform4i',\n};\n\n// number of pixel buffer objects\n// used to get a performance boost in gl.readPixels()\n// (1 seems to perform better on mobile, 2 on the PC?)\nconst PBO_COUNT = 1;\n\n/**\n * A SpeedyProgram is a Function that\n * runs GPU-accelerated GLSL code\n */\nexport class SpeedyProgram extends Function\n{\n    /**\n     * Creates a new SpeedyProgram\n     * @param {WebGL2RenderingContext} gl WebGL context\n     * @param {ShaderDeclaration} shaderdecl Shader declaration\n     * @param {object} [options] user options\n     */\n    constructor(gl, shaderdecl, options = { })\n    {\n        super('...args', 'return this._self._call(...args)');\n        this._self = this.bind(this);\n        this._self._init(gl, shaderdecl, options);\n        return this._self;\n    }\n\n    /**\n     * Resize the output texture\n     * @param {number} width \n     * @param {number} height \n     */\n    resize(width, height)\n    {\n        // lost context?\n        const gl = this._gl;\n        if(gl.isContextLost())\n            return;\n\n        // get size\n        width = Math.max(1, width | 0);\n        height = Math.max(1, height | 0);\n\n        // no need to resize?\n        if(width === this._stdprog.width && height === this._stdprog.height)\n            return;\n\n        // update options.output\n        const options = this._options;\n        options.output[0] = width;\n        options.output[1] = height;\n\n        // resize stdprog\n        this._stdprog.resize(width, height);\n\n        // reallocate buffers for reading pixels\n        this._reallocatePixelBuffers(width, height);\n    }\n\n    /**\n     * Read pixels from the output texture.\n     * You may optionally specify a (x,y,width,height) sub-rectangle.\n     * @param {number} [x]\n     * @param {number} [y] \n     * @param {number} [width]\n     * @param {number} [height]\n     * @returns {Uint8Array} pixels in the RGBA format\n     */\n    readPixelsSync(x = 0, y = 0, width = -1, height = -1)\n    {\n        const gl = this._gl;\n\n        // lost context?\n        if(gl.isContextLost())\n            return this._pixelBuffer[0];\n\n        // default values\n        if(width < 0)\n            width = this._stdprog.width;\n        if(height < 0)\n            height = this._stdprog.height;\n\n        // clamp values\n        width = Math.min(width, this._stdprog.width);\n        height = Math.min(height, this._stdprog.height);\n        x = Math.max(0, Math.min(x, width - 1));\n        y = Math.max(0, Math.min(y, height - 1));\n\n        // allocate the pixel buffers\n        if(this._pixelBuffer[0] == null)\n            this._reallocatePixelBuffers(this._stdprog.width, this._stdprog.height);\n\n        // read pixels\n        if(this._stdprog.fbo != null) {\n            gl.bindFramebuffer(gl.FRAMEBUFFER, this._stdprog.fbo);\n            gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, this._pixelBuffer[0]);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        }\n        else\n            gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, this._pixelBuffer[0]);\n\n        // done!\n        return this._pixelBuffer[0];\n    }\n\n    /**\n     * Read pixels from the output texture asynchronously with PBOs.\n     * You may optionally specify a (x,y,width,height) sub-rectangle.\n     * (this won't work very well if options.renderToTexture == false\n     * and you display the canvas)\n     * @param {number} [x]\n     * @param {number} [y] \n     * @param {number} [width]\n     * @param {number} [height]\n     * @returns {Promise<Uint8Array>} resolves to an array of pixels in the RGBA format\n     */\n    readPixelsAsync(x = 0, y = 0, width = -1, height = -1)\n    {\n        const gl = this._gl;\n\n        // lost context?\n        if(gl.isContextLost())\n            return Promise.resolve(this._pixelBuffer[0]);\n\n        // default values\n        if(width < 0)\n            width = this._stdprog.width;\n        if(height < 0)\n            height = this._stdprog.height;\n\n        // clamp values\n        width = Math.min(width, this._stdprog.width);\n        height = Math.min(height, this._stdprog.height);\n        x = Math.max(0, Math.min(x, width - 1));\n        y = Math.max(0, Math.min(y, height - 1));\n\n        // allocate the pixel buffers\n        if(this._pixelBuffer[0] == null)\n            this._reallocatePixelBuffers(this._stdprog.width, this._stdprog.height);\n\n        // GPU needs to produce data\n        if(this._pboProducerQueue.length > 0) {\n            const nextPBO = this._pboProducerQueue.shift();\n            GLUtils.readPixelsViaPBO(gl, this._pbo[nextPBO], this._pixelBuffer[nextPBO], x, y, width, height, this._stdprog.fbo).then(downloadTime => {\n                this._pboConsumerQueue.push(nextPBO);\n            });\n        }\n        else waitForQueueNotEmpty(this._pboProducerQueue).then(waitTime => {\n            const nextPBO = this._pboProducerQueue.shift();\n            GLUtils.readPixelsViaPBO(gl, this._pbo[nextPBO], this._pixelBuffer[nextPBO], x, y, width, height, this._stdprog.fbo).then(downloadTime => {\n                this._pboConsumerQueue.push(nextPBO);\n            });\n        });\n\n        // CPU needs to consume data\n        if(this._pboConsumerQueue.length > 0) {\n            const readyPBO = this._pboConsumerQueue.shift();\n            return new Promise(resolve => {\n                resolve(this._pixelBuffer[readyPBO]);\n                this._pboProducerQueue.push(readyPBO); // enqueue AFTER resolve()\n            });\n        }\n        else return new Promise(resolve => {\n            waitForQueueNotEmpty(this._pboConsumerQueue).then(waitTime => {\n                const readyPBO = this._pboConsumerQueue.shift();\n                resolve(this._pixelBuffer[readyPBO]);\n                this._pboProducerQueue.push(readyPBO); // enqueue AFTER resolve()\n            });\n        });\n    }\n\n    /**\n     * Read uniforms of the program (metadata)\n     * @returns {object}\n     */\n    get uniforms()\n    {\n        return this._stdprog.uniform;\n    }\n\n    // Prepare the shader\n    _init(gl, shaderdecl, options)\n    {\n        // default options\n        options = {\n            output: [ gl.drawingBufferWidth, gl.drawingBufferHeight ], // size of the output texture\n            uniforms: { }, // user-defined constants (as uniforms)\n            renderToTexture: true, // render results to a texture?\n            recycleTexture: true, // recycle output texture? If false, you must manually destroy the output texture\n            pingpong: false, // alternate output texture between calls\n            ...options // user-defined options\n        };\n\n        // validate options\n        if(options.pingpong && !options.renderToTexture)\n            throw new IllegalOperationError(`Pingpong rendering can only be used when rendering to textures`);\n\n        // get size\n        let width = Math.max(1, options.output[0] | 0);\n        let height = Math.max(1, options.output[1] | 0);\n        options.output = [ width, height ];\n\n        // need to resize the canvas?\n        const canvas = gl.canvas;\n        if(width > canvas.width)\n            canvas.width = width;\n        if(height > canvas.height)\n            canvas.height = height;\n\n        // if(gl.isContextLost()) ...\n\n        // create shader\n        const stdprog = new StandardProgram(gl, width, height, shaderdecl, options.uniforms);\n        if(options.renderToTexture)\n            stdprog.attachFBO(options.pingpong);\n\n        // validate arguments\n        const params = shaderdecl.arguments;\n        for(let j = 0; j < params.length; j++) {\n            if(!stdprog.uniform.hasOwnProperty(params[j])) {\n                if(!stdprog.uniform.hasOwnProperty(params[j] + '[0]'))\n                    throw new IllegalOperationError(`Can't run shader: expected uniform \"${params[j]}\"`);\n            }\n        }\n\n        // store context\n        this._gl = gl;\n        this._source = shaderdecl.fragmentSource;\n        this._options = Object.freeze(options);\n        this._stdprog = stdprog;\n        this._params = params;\n        this._initPixelBuffers(gl);\n    }\n\n    // Run the SpeedyProgram\n    _call(...args)\n    {\n        const gl = this._gl;\n        const options = this._options;\n        const stdprog = this._stdprog;\n        const params = this._params;\n\n        // skip things\n        if(gl.isContextLost())\n            return stdprog.texture;\n        \n        // matching arguments?\n        if(args.length != params.length)\n            throw new IllegalArgumentError(`Can't run shader: incorrect number of arguments`);\n\n        // use program\n        gl.useProgram(stdprog.program);\n\n        // update texSize uniform\n        if(stdprog.dirtySize) { // if the program was resized\n            gl.uniform2f(stdprog.uniform.texSize.location, stdprog.width, stdprog.height);\n            stdprog.dirtySize = false;\n        }\n\n        // set uniforms[i] to args[i]\n        for(let i = 0, texNo = 0; i < args.length; i++) {\n            const argname = params[i];\n            let uniform = stdprog.uniform[argname];\n\n            if(uniform) {\n                // uniform variable matches parameter name\n                texNo = this._setUniform(uniform, args[i], texNo);\n            }\n            else if(stdprog.uniform.hasOwnProperty(argname + '[0]')) {\n                // uniform array matches parameter name\n                const array = args[i];\n                if(stdprog.uniform.hasOwnProperty(`${argname}[${array.length}]`))\n                    throw new IllegalArgumentError(`Can't run shader: too few elements in array \"${argname}\"`);\n                for(let j = 0; (uniform = stdprog.uniform[`${argname}[${j}]`]); j++)\n                    texNo = this._setUniform(uniform, array[j], texNo);\n            }\n            else\n                throw new IllegalArgumentError(`Can't run shader: unknown parameter \"${argname}\": ${args[i]}`);\n        }\n\n        // bind fbo\n        if(options.renderToTexture)\n            gl.bindFramebuffer(gl.FRAMEBUFFER, stdprog.fbo);\n        else\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n        // render\n        gl.viewport(0, 0, stdprog.width, stdprog.height);\n        gl.drawArrays(gl.TRIANGLE_STRIP,\n                      0,        // offset\n                      4);       // count       \n\n        // output texture\n        let outputTexture = null;\n        if(options.renderToTexture) {\n            outputTexture = stdprog.texture;\n\n            // clone outputTexture using the current framebuffer\n            if(!options.recycleTexture) {\n                const cloneTexture = GLUtils.createTexture(gl, stdprog.width, stdprog.height);\n                gl.activeTexture(gl.TEXTURE0);\n                gl.bindTexture(gl.TEXTURE_2D, cloneTexture);\n                gl.copyTexSubImage2D(gl.TEXTURE_2D,     // target\n                                     0,                 // mipmap level\n                                     0,                 // xoffset\n                                     0,                 // yoffset\n                                     0,                 // x\n                                     0,                 // y\n                                     stdprog.width,     // width\n                                     stdprog.height);   // height\n                gl.bindTexture(gl.TEXTURE_2D, null);\n                outputTexture = cloneTexture;\n            }\n\n            // ping-pong rendering\n            if(options.pingpong)\n                stdprog.pingpong();\n        }\n\n        // unbind fbo\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n        // return texture (if available)\n        return outputTexture;\n    }\n\n    // set uniform to value\n    // arrays of arbitrary size are not supported, only fixed-size vectors (vecX, ivecX, etc.)\n    _setUniform(uniform, value, texNo)\n    {\n        const gl = this._gl;\n\n        if(uniform.type == 'sampler2D') {\n            // set texture\n            if(texNo > gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS)\n                throw new NotSupportedError(`Can't bind ${texNo} textures to a program: max is ${gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS}`);\n            else if(value === this._stdprog.texture)\n                throw new NotSupportedError(`Can't run shader: cannot use its output texture as an input to itself`);\n            else if(value == null)\n                throw new IllegalArgumentError(`Can't run shader: cannot use null as an input texture`);\n\n            gl.activeTexture(gl.TEXTURE0 + texNo);\n            gl.bindTexture(gl.TEXTURE_2D, value);\n            gl.uniform1i(uniform.location, texNo);\n            texNo++;\n        }\n        else {\n            // set value\n            if(typeof value == 'number' || typeof value == 'boolean')\n                (gl[UNIFORM_TYPES[uniform.type]])(uniform.location, value);\n            else if(Array.isArray(value))\n                (gl[UNIFORM_TYPES[uniform.type]])(uniform.location, ...value);\n            else\n                throw new IllegalArgumentError(`Can't run shader: unrecognized argument \"${value}\"`);\n        }\n\n        return texNo;\n    }\n\n    // initialize pixel buffers\n    _initPixelBuffers(gl)\n    {\n        this._pixelBuffer = Array(PBO_COUNT).fill(null);\n        this._pixelBufferSize = [0, 0];\n        this._pboConsumerQueue = Array(PBO_COUNT).fill(0).map((_, i) => i);\n        this._pboProducerQueue = [];\n        this._pbo = Array(PBO_COUNT).fill(null).map(() => gl.createBuffer());\n    }\n\n    // resize pixel buffers\n    _reallocatePixelBuffers(width, height)\n    {\n        // skip realloc\n        if(width * height <= this._pixelBufferSize[0] * this._pixelBufferSize[1])\n            return;\n\n        // update size\n        this._pixelBufferSize[0] = width;\n        this._pixelBufferSize[1] = height;\n\n        // reallocate pixels array\n        for(let i = 0; i < PBO_COUNT; i++) {\n            const oldBuffer = this._pixelBuffer[i];\n            this._pixelBuffer[i] = this._createPixelBuffer(width, height);\n\n            if(oldBuffer) {\n                if(oldBuffer.length > this._pixelBuffer[i].length)\n                    this._pixelBuffer[i].set(oldBuffer.slice(0, this._pixelBuffer[i].length));\n                else\n                    this._pixelBuffer[i].set(oldBuffer);\n            }\n        }\n    }\n\n    // create a width x height buffer for RGBA data\n    _createPixelBuffer(width, height)\n    {\n        const pixels = new Uint8Array(width * height * 4);\n        pixels.fill(255, 0, 4); // will be recognized as empty\n        return pixels;\n    }\n}\n\n\n\n//\n// Standard Program\n//\n\n// a standard program runs a shader on an \"image\"\n// uniforms: { 'name': <default_value>, ... }\nfunction StandardProgram(gl, width, height, shaderdecl, uniforms = { })\n{\n    // compile shaders\n    const program = GLUtils.createProgram(gl, shaderdecl.vertexSource, shaderdecl.fragmentSource);\n\n    // setup geometry\n    gl.bindAttribLocation(program, LOCATION_ATTRIB_POSITION, shaderdecl.attributes.position);\n    gl.bindAttribLocation(program, LOCATION_ATTRIB_TEXCOORD, shaderdecl.attributes.texCoord);\n    const vertexObjects = GLUtils.createStandardGeometry(gl, LOCATION_ATTRIB_POSITION, LOCATION_ATTRIB_TEXCOORD);\n\n    // define texSize\n    width = Math.max(width | 0, 1);\n    height = Math.max(height | 0, 1);\n    uniforms.texSize = [ width, height ];\n\n    // autodetect uniforms\n    const uniform = { };\n    for(const u of shaderdecl.uniforms)\n        uniform[u] = { type: shaderdecl.uniformType(u) };\n\n    // given the declared uniforms, get their\n    // locations and set their default values\n    gl.useProgram(program);\n    for(const u in uniform) {\n        // get location\n        uniform[u].location = gl.getUniformLocation(program, u);\n\n        // validate type\n        if(!UNIFORM_TYPES.hasOwnProperty(uniform[u].type))\n            throw new NotSupportedError(`Unknown uniform type: ${uniform[u].type}`);\n\n        // must set a default value?\n        if(uniforms.hasOwnProperty(u)) {\n            const value = uniforms[u];\n            if(typeof value == 'number' || typeof value == 'boolean')\n                (gl[UNIFORM_TYPES[uniform[u].type]])(uniform[u].location, value);\n            else if(typeof value == 'object')\n                (gl[UNIFORM_TYPES[uniform[u].type]])(uniform[u].location, ...Array.from(value));\n            else\n                throw new IllegalArgumentError(`Unrecognized uniform value: \"${value}\"`);\n        }\n\n        // note: to set the default value of array arr, pass\n        // { 'arr[0]': val0, 'arr[1]': val1, ... } to uniforms\n    }\n\n    // done!\n    this.gl = gl;\n    this.program = program;\n    this.uniform = uniform;\n    this.width = width;\n    this.height = height;\n    this.dirtySize = false;\n    this.vertexObjects = vertexObjects;\n    this._fbo = this._texture = null; this._texIndex = 0;\n    Object.defineProperty(this, 'fbo', {\n        get: () => this._fbo ? this._fbo[this._texIndex] : null\n    });\n    Object.defineProperty(this, 'texture', {\n        get: () => this._texture ? this._texture[this._texIndex] : null\n    });\n}\n\n// Attach a framebuffer object to a standard program\nStandardProgram.prototype.attachFBO = function(pingpong = false)\n{\n    const gl = this.gl;\n    const width = this.width;\n    const height = this.height;\n    const numTextures = pingpong ? 2 : 1;\n\n    this._texIndex = 0;\n    this._texture = Array(numTextures);\n    this._fbo = Array(numTextures);\n\n    for(let i = 0; i < numTextures; i++) {\n        this._texture[i] = GLUtils.createTexture(gl, width, height);\n        this._fbo[i] = GLUtils.createFramebuffer(gl, this._texture[i]);\n    }\n}\n\n// Detach a framebuffer object from a standard program\nStandardProgram.prototype.detachFBO = function()\n{\n    const gl = this.gl;\n\n    if(this._fbo != null) {\n        for(let fbo of this._fbo)\n            GLUtils.destroyFramebuffer(gl, fbo);\n        this._fbo = null;\n    }\n\n    if(this._texture != null) {\n        for(let texture of this._texture)\n            GLUtils.destroyTexture(gl, texture);\n        this._texture = null;\n    }\n\n    this._texIndex = 0;\n}\n\n// Ping-pong rendering\nStandardProgram.prototype.pingpong = function()\n{\n    if(this._fbo != null && this._fbo.length > 1)\n        this._texIndex = 1 - this._texIndex;\n}\n\n// Resize\nStandardProgram.prototype.resize = function(width, height)\n{\n    const gl = this.gl;\n    const oldWidth = this.width;\n    const oldHeight = this.height;\n\n    // validate size\n    width = Math.max(1, width | 0);\n    height = Math.max(1, height | 0);\n\n    // update size\n    this.width = width;\n    this.height = height;\n\n    // set dirty flag to update texSize uniform later\n    this.dirtySize = true;\n\n    // resize textures\n    if(this._fbo != null) {\n        const numTextures = this._fbo.length;\n        const newTexture = Array(numTextures);\n        const newFBO = Array(numTextures);\n\n        // create textures with new size & old content\n        for(let i = 0; i < numTextures; i++) {\n            newTexture[i] = GLUtils.createTexture(gl, width, height);\n\n            gl.bindFramebuffer(gl.FRAMEBUFFER, this._fbo[i]);\n            gl.activeTexture(gl.TEXTURE0);\n            gl.bindTexture(gl.TEXTURE_2D, newTexture[i]);\n            gl.copyTexSubImage2D(gl.TEXTURE_2D,     // target\n                                 0,                 // mipmap level\n                                 0,                 // xoffset\n                                 0,                 // yoffset\n                                 0,                 // x\n                                 0,                 // y\n                                 Math.min(width, oldWidth),    // width\n                                 Math.min(height, oldHeight)); // height\n            gl.bindTexture(gl.TEXTURE_2D, null);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n            newFBO[i] = GLUtils.createFramebuffer(gl, newTexture[i]);\n        }\n\n        // release old textures\n        for(let fbo of this._fbo)\n            GLUtils.destroyFramebuffer(gl, fbo);\n\n        for(let texture of this._texture)\n            GLUtils.destroyTexture(gl, texture);\n\n        // update references\n        this._texture = newTexture;\n        this._fbo = newFBO;\n    }\n\n    //console.log(`Resized program to ${width} x ${height}`);\n}\n\n\n\n//\n// Consumer-producer\n//\n\n// wait for a queue to be not empty\nfunction waitForQueueNotEmpty(queue)\n{\n    return new Promise(resolve => {\n        const start = performance.now();\n        function wait() {\n            if(queue.length > 0)\n                resolve(performance.now() - start);\n            else\n                setTimeout(wait, 0); // Utils.setZeroTimeout may hinder performance (GLUtils already calls it)\n                //Utils.setZeroTimeout(wait);\n        }\n        wait();\n    });\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy.js\n * Speedy's entry point\n */\n\nimport { SpeedyMedia } from './core/speedy-media';\nimport { SpeedyPipeline } from './core/speedy-pipeline';\nimport { FPSCounter } from './utils/fps-counter';\n\nclass Speedy\n{\n    /**\n     * Loads a SpeedyMedia object based on the provided source element\n     * @param {HTMLImageElement|HTMLVideoElement|HTMLCanvasElement} sourceElement The source media\n     * @param {object} [options] Additional options for advanced configuration\n     * @returns {Promise<SpeedyMedia>}\n     */\n    static load(sourceElement, options = { })\n    {\n        return SpeedyMedia.load(sourceElement, options);\n    }\n\n    /**\n     * Loads a camera stream\n     * @param {number} [width] width of the stream\n     * @param {number} [height] height of the stream\n     * @param {object} [cameraOptions] additional options to pass to getUserMedia()\n     * @param {object} [mediaOptions] additional options for advanced configuration of the SpeedyMedia\n     * @returns {Promise<SpeedyMedia>}\n     */\n    static camera(width = 426, height = 240, cameraOptions = {}, mediaOptions = {})\n    {\n        return SpeedyMedia.loadCameraStream(width, height, cameraOptions, mediaOptions);\n    }\n\n    /**\n     * Creates a new pipeline\n     * @returns {SpeedyPipeline}\n     */\n    static pipeline()\n    {\n        return new SpeedyPipeline();\n    }\n\n    /**\n     * The version of the library\n     * @returns {string} The version of the library\n     */\n    static get version()\n    {\n        return __SPEEDY_VERSION__;\n    }\n\n    /**\n     * The FPS rate. Get it as Speedy.fps.value\n     * @returns {number} Frames per second (FPS)\n     */\n    static get fps()\n    {\n        return {\n            get value() { return FPSCounter.instance.fps; }\n        };\n    }\n}\n\nexport const load = Speedy.load;\nexport const camera = Speedy.camera;\nexport const pipeline = Speedy.pipeline;\nexport const version = Speedy.version;\nexport const fps = Speedy.fps;","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * errors.js\n * Error classes\n */\n\n/**\n * Generic error class for Speedy\n */\nexport class SpeedyError extends Error\n{\n    /**\n     * Class constructor\n     * @param {string} message message text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message, cause = null)\n    {\n        super([\n            message,\n            cause ? cause.toString() : '@ [speedy-vision.js]'\n        ].join('\\n-> '));\n        this._cause = cause;\n    }\n\n    /**\n     * Error name\n     * @returns {string}\n     */\n    get name()\n    {\n        return this.constructor.name;\n    }\n\n    /**\n     * Set error name (ignored)\n     * @param {string} _ ignored\n     */\n    set name(_)\n    {\n        ;\n    }\n\n    /**\n     * Get the cause of the error. Available if\n     * it has been specified in the constructor\n     * @returns {SpeedyError|null}\n     */\n    get cause()\n    {\n        return this._cause;\n    }\n}\n\n/**\n * Unsupported operation error\n * The requested operation is not supported\n */\nexport class NotSupportedError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Unsupported operation. ${message}`, cause);\n    }\n}\n\n/**\n * Not implemented error\n * The called method is not implemented\n */\nexport class NotImplementedError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Method not implemented. ${message}`, cause);\n    }\n}\n\n/**\n * WebGL error\n */\nexport class GLError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`WebGL error. ${message}`, cause);\n    }\n}\n\n/**\n * AbstractMethodError\n * Thrown when one tries to call an abstract method\n */\nexport class AbstractMethodError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Can't call abstract method. ${message}`, cause);\n    }\n}\n\n/**\n * Illegal argument error\n * A method has received one or more illegal arguments\n */\nexport class IllegalArgumentError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Illegal argument. ${message}`, cause);\n    }\n}\n\n/**\n * Illegal operation error\n * The method arguments are valid, but the method can't\n * be called due to the current the state of the object\n */\nexport class IllegalOperationError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Illegal operation. ${message}`, cause);\n    }\n}\n\n/**\n * File not found error\n */\nexport class FileNotFoundError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`File not found. ${message}`, cause);\n    }\n}\n\n/**\n * Timeout error\n */\nexport class TimeoutError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Timeout error. ${message}`, cause);\n    }\n}\n\n/**\n * Parse error\n */\nexport class ParseError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Parse error. ${message}`, cause);\n    }\n}\n\n/**\n * Assertion error\n */\nexport class AssertionError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Assertion failed. ${message}`, cause);\n    }\n}\n\n/**\n * Access denied\n */\nexport class AccessDeniedError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Access denied. ${message}`, cause);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * fps-counter.js\n * A FPS counter\n */\n\nimport { Utils } from './utils';\nimport { IllegalOperationError } from './errors';\n\nlet instance = null;\nconst UPDATE_INTERVAL = 500; // in ms\n\nexport class FPSCounter\n{\n    /**\n     * Creates a new FPSCounter\n     */\n    /* private */ constructor()\n    {\n        this._fps = 60;\n        this._frames = 0;\n        this._updateInterval = UPDATE_INTERVAL;\n        this._lastUpdate = performance.now();\n\n        // this should never happen...\n        if(instance !== null)\n            throw new IllegalOperationError(`Can't have multiple instances of FPSCounter`);\n\n        // start FPS counter\n        requestAnimationFrame(this._update.bind(this));\n    }\n\n    /**\n     * Gets an instance of the FPS counter.\n     * Using lazy loading, i.e., we will not\n     * create a FPS counter unless we need to!\n     */\n    static get instance()\n    {\n        if(instance === null)\n            instance = new FPSCounter();\n\n        return instance;\n    }\n\n    /**\n     * Get the FPS rate\n     * @returns {number} frames per second\n     */\n    get fps()\n    {\n        return this._fps;\n    }\n\n    // Updates the FPS counter\n    _update()\n    {\n        const now = performance.now();\n        const deltaTime = now - this._lastUpdate;\n\n        if(deltaTime >= this._updateInterval) {\n            this._fps = Math.round(this._frames / (deltaTime * 0.001));\n            this._frames = 0;\n            this._lastUpdate = now;\n        }\n\n        this._frames++;\n        requestAnimationFrame(this._update.bind(this));\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * globals.js\n * Global constants\n */\n\n// -----------------------------------------------------------------\n// GENERAL\n// -----------------------------------------------------------------\n\n// Maximum texture length\nexport const MAX_TEXTURE_LENGTH = 65534; // 2^n - 2 due to encoding\n\n\n\n// -----------------------------------------------------------------\n// IMAGE PYRAMIDS & SCALE-SPACE\n// -----------------------------------------------------------------\n\n// The maximum number of layers of the pyramid (not counting intra-layers)\nexport const PYRAMID_MAX_LEVELS = 4; // scaling factor = 1\n\n// The maximum number of layers of the pyramid (counting intra-layers)\nexport const PYRAMID_MAX_OCTAVES = 2 * PYRAMID_MAX_LEVELS - 1; // scaling factor = sqrt(2)\n\n// The maximum supported scale for a pyramid layer\nexport const PYRAMID_MAX_SCALE = 2; // preferably a power of 2 (image scale can go up to this value)","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * observable.js\n * Observer design pattern\n */\n\n/**\n * Implementation of the Observer design pattern\n */\nexport /* abstract */ class Observable\n{\n    /**\n     * Class constructor\n     */\n    constructor()\n    {\n        this._subscribers = [];\n    }\n\n    /**\n     * Add subscriber\n     * @param {Function} fn callback\n     */\n    subscribe(fn)\n    {\n        if(this._subscribers.indexOf(fn) < 0)\n            this._subscribers.push(fn);\n    }\n\n    /**\n     * Remove subscriber\n     * @param {Function} fn previously added callback\n     */\n    unsubscribe(fn)\n    {\n        this._subscribers = this._subscribers.filter(subscriber => subscriber !== fn);\n    }\n\n    /**\n     * Notify all subscribers about a state change\n     * @param {any} data generic data\n     */\n    /* protected */ _notify(data)\n    {\n        for(const fn of this._subscribers)\n            fn(data);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * types.js\n * Types & formats\n */\n\nimport { Utils } from './utils';\n\nexport const MediaType = Utils.enum(\n    'Image',\n    'Video',\n    'Canvas',\n    'Texture'\n);\n\nexport const ColorFormat = Utils.enum(\n    'RGB',\n    'Greyscale',\n    'Binary'\n);\n\nexport const PixelComponent = Object.freeze({\n    RED:   1,\n    GREEN: 2,\n    BLUE:  4,\n    ALPHA: 8,\n    ALL:   15 // = RED | GREEN | BLUE | ALPHA\n});\n\nexport const ColorComponentId = Object.freeze({\n    [PixelComponent.RED]:   0,\n    [PixelComponent.GREEN]: 1,\n    [PixelComponent.BLUE]:  2,\n    [PixelComponent.ALPHA]: 3\n});","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * utils.js\n * Generic utilities\n */\n\nimport { IllegalArgumentError, ParseError, AssertionError } from './errors'\n\nexport class Utils\n{\n    /**\n     * Generates a warning\n     * @param {string} text message text\n     * @param  {...string} [args] optional text\n     * @returns {string} the message text\n     */\n    static warning(text, ...args)\n    {\n        const message = [ text, ...args ].join(' ');\n        console.warn('[speedy-vision.js]', message);\n        return message;\n    }\n\n    /**\n     * Logs a message\n     * @param {string} text message text\n     * @param  {...string} [args] optional text\n     * @returns {string} the message text\n     */\n    static log(text, ...args)\n    {\n        const message = [ text, ...args ].join(' ');\n        console.log('[speedy-vision.js]', message);\n        return message;\n    }\n\n    /**\n     * Assertion\n     * @param {boolean} expr expression\n     * @param {string} [text] error message\n     * @throws {AssertionError}\n     */\n    static assert(expr, text = '')\n    {\n        if(!expr)\n            throw new AssertionError(text);\n    }\n\n    /**\n     * Generates an enumeration\n     * @param {...string} values enumeration options\n     * @returns {object} enum object\n     */\n    static enum(...values)\n    {\n        return Object.freeze(\n            values.reduce((acc, cur) => ((acc[cur] = Symbol(cur)), acc), { })\n        );\n    }\n\n    /**\n     * Similar to setTimeout(fn, 0), but without the ~4ms delay.\n     * Although much faster than setTimeout, this may be resource-hungry\n     * (heavy on battery) if used in a loop. Use with caution.\n     * Implementation based on David Baron's, but adapted for ES6 classes\n     * @param {Function} fn\n     */\n    //static setZeroTimeout(fn) { setTimeout(fn, 0); } // easier on the CPU\n    static get setZeroTimeout()\n    {\n        return this._setZeroTimeout || (this._setZeroTimeout = (() => {\n            const msgId = '0%' + Math.random().toString(36).slice(2);\n            const queue = [];\n\n            window.addEventListener('message', ev => {\n                if(ev.source === window && ev.data === msgId) {\n                    event.stopPropagation();\n                    queue.shift().call(window);\n                }\n            }, true);\n\n            // make it efficient\n            return function setZeroTimeout(fn) {\n                queue.push(fn);\n                window.postMessage(msgId, '*');\n            }\n        })());\n    }\n\n    /**\n     * Gets the names of the arguments of the specified function\n     * @param {Function} fun \n     * @returns {Array<string>}\n     */\n    static functionArguments(fun)\n    {\n        const code = fun.toString();\n        const regex = code.startsWith('function') ? 'function\\\\s.*\\\\(([^)]*)\\\\)' :\n                     (code.startsWith('(') ? '\\\\(([^)]*)\\\\).*=>' : '([^=]+).*=>');\n        const match = new RegExp(regex).exec(code);\n\n        if(match !== null) {\n            const args = match[1].replace(/\\/\\*.*?\\*\\//g, ''); // remove comments\n            return args.split(',').map(argname =>\n                argname.replace(/=.*$/, '').trim() // remove default params & trim\n            ).filter(argname =>\n                argname // handle trailing commas\n            );\n        }\n        else\n            throw new ParseError(`Can't detect function arguments of ${code}`);\n\n        return [];\n    }\n\n    /**\n     * Generates a random number with\n     * Gaussian distribution (mu, sigma)\n     * @param {number} mu mean\n     * @param {number} sigma standard deviation\n     * @returns {number} random number\n     */\n    static gaussianNoise(mu = 0, sigma = 1)\n    {\n        // Box-Muller transformation\n        const TWO_PI = 2.0 * Math.PI;\n        \n        let a, b = Math.random();\n        do { a = Math.random(); } while(a <= Number.EPSILON);\n        let z = Math.sqrt(-2 * Math.log(a)) * Math.sin(TWO_PI * b);\n\n        return z * sigma + mu;\n    }\n\n    /**\n     * Generate a 1D gaussian kernel with custom sigma\n     * Tip: use kernelSize = (5 * sigma), kernelSize odd\n     * @param {number} sigma gaussian sigma\n     * @param {number} [kernelSize] kernel size, odd number\n     * @param {bool} [normalized] normalize entries so that their sum is 1\n     */\n    static gaussianKernel(sigma, kernelSize = -1, normalized = true)\n    {\n        /*\n         * Let G(x) be a Gaussian function centered at 0 with fixed sigma:\n         *\n         * G(x) = (1 / (sigma * sqrt(2 * pi))) * exp(-(x / (sqrt(2) * sigma))^2)\n         * \n         * In addition, let f(p) be a kernel value at pixel p, -k/2 <= p <= k/2:\n         * \n         * f(p) = \\int_{p - 0.5}^{p + 0.5} G(x) dx (integrate around p)\n         *      = \\int_{0}^{p + 0.5} G(x) dx - \\int_{0}^{p - 0.5} G(x) dx\n         * \n         * Setting a constant c := sqrt(2) * sigma, it follows that:\n         * \n         * f(p) = (1 / 2c) * (erf((p + 0.5) / c) - erf((p - 0.5) / c))\n         */\n\n        // default kernel size\n        if(kernelSize < 0) {\n            kernelSize = Math.ceil(5.0 * sigma) | 0;\n            kernelSize += 1 - (kernelSize % 2);\n        }\n\n        // validate input\n        kernelSize |= 0;\n        if(kernelSize < 1 || kernelSize % 2 == 0)\n            throw new IllegalArgumentError(`Invalid kernel size given to gaussianKernel: ${kernelSize} x 1`);\n        else if(sigma <= 0.0)\n            throw new IllegalArgumentError(`Invalid sigma given to gaussianKernel: ${sigma}`);\n\n        // function erf(x) = -erf(-x) can be approximated numerically. See:\n        // https://en.wikipedia.org/wiki/Error_function#Numerical_approximations\n        const kernel = new Array(kernelSize);\n\n        // set constants\n        const N  =  kernelSize >> 1; // integer (floor, div 2)\n        const c  =  (+sigma) * Math.sqrt(2);\n        const m  =  0.3275911;\n        const a1 =  0.254829592;\n        const a2 = -0.284496736;\n        const a3 =  1.421413741;\n        const a4 = -1.453152027;\n        const a5 =  1.061405429;\n\n        // compute the kernel\n        let sum = 0.0;\n        for(let j = 0; j < kernelSize; j++) {\n            let xa = (j - N + 0.5) / c;\n            let xb = (j - N - 0.5) / c;\n            let sa = 1.0, sb = 1.0;\n\n            if(xa < 0.0) { sa = -1.0; xa = -xa; }\n            if(xb < 0.0) { sb = -1.0; xb = -xb; }\n\n            const ta = 1.0 / (1.0 + m * xa);\n            const tb = 1.0 / (1.0 + m * xb);\n            const pa = ((((a5 * ta + a4) * ta + a3) * ta + a2) * ta + a1) * ta;\n            const pb = ((((a5 * tb + a4) * tb + a3) * tb + a2) * tb + a1) * tb;\n            const ya = 1.0 - pa * Math.exp(-xa * xa);\n            const yb = 1.0 - pb * Math.exp(-xb * xb);\n\n            const erfa = sa * ya;\n            const erfb = sb * yb;\n            const fp = (erfa - erfb) / (2.0 * c);\n\n            kernel[j] = fp;\n            sum += fp;\n        }\n\n        // done!\n        return normalized ? kernel.map(k => k / sum) : kernel;\n    }\n}"],"sourceRoot":""}