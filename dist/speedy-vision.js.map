{"version":3,"sources":["webpack://Speedy/webpack/bootstrap","webpack://Speedy/./node_modules/process/browser.js","webpack://Speedy/./src/core/keypoints/descriptors/orb.js","webpack://Speedy/./src/core/keypoints/detectors/fast.js","webpack://Speedy/./src/core/keypoints/detectors/harris.js","webpack://Speedy/./src/core/keypoints/feature-algorithm-decorator.js","webpack://Speedy/./src/core/keypoints/feature-algorithm.js","webpack://Speedy/./src/core/keypoints/feature-description-algorithm.js","webpack://Speedy/./src/core/keypoints/feature-detection-algorithm.js","webpack://Speedy/./src/core/keypoints/feature-downloader.js","webpack://Speedy/./src/core/keypoints/feature-encoder.js","webpack://Speedy/./src/core/keypoints/feature-tracking-algorithm.js","webpack://Speedy/./src/core/keypoints/trackers/lk.js","webpack://Speedy/./src/core/matrix/bound-matrix-operation.js","webpack://Speedy/./src/core/matrix/linalg/basic.js","webpack://Speedy/./src/core/matrix/linalg/functional.js","webpack://Speedy/./src/core/matrix/linalg/homography.js","webpack://Speedy/./src/core/matrix/linalg/inverse.js","webpack://Speedy/./src/core/matrix/linalg/linalg.js","webpack://Speedy/./src/core/matrix/linalg/qr.js","webpack://Speedy/./src/core/matrix/linalg/ransac.js","webpack://Speedy/./src/core/matrix/linalg/sequence.js","webpack://Speedy/./src/core/matrix/linalg/solve.js","webpack://Speedy/./src/core/matrix/linalg/transform.js","webpack://Speedy/./src/core/matrix/linalg/utils.js","webpack://Speedy/./src/core/matrix/matrix-buffer.js","webpack://Speedy/./src/core/matrix/matrix-expression-factory.js","webpack://Speedy/./src/core/matrix/matrix-expressions.js","webpack://Speedy/./src/core/matrix/matrix-operation-header.js","webpack://Speedy/./src/core/matrix/matrix-operations-queue.js","webpack://Speedy/./src/core/matrix/matrix-operations.js","webpack://Speedy/./src/core/matrix/matrix-settings.js","webpack://Speedy/./src/core/matrix/matrix-shape.js","webpack://Speedy/./src/core/matrix/matrix-type.js","webpack://Speedy/./src/core/matrix/matrix-worker.js","webpack://Speedy/./src/core/matrix/matrix.js","webpack://Speedy/./src/core/pipeline/factories/filter-factory.js","webpack://Speedy/./src/core/pipeline/factories/image-factory.js","webpack://Speedy/./src/core/pipeline/factories/keypoint-factory.js","webpack://Speedy/./src/core/pipeline/factories/transform-factory.js","webpack://Speedy/./src/core/pipeline/nodes/filters/convolution.js","webpack://Speedy/./src/core/pipeline/nodes/filters/gaussian-blur.js","webpack://Speedy/./src/core/pipeline/nodes/filters/greyscale.js","webpack://Speedy/./src/core/pipeline/nodes/filters/median-blur.js","webpack://Speedy/./src/core/pipeline/nodes/filters/nightvision.js","webpack://Speedy/./src/core/pipeline/nodes/filters/normalize.js","webpack://Speedy/./src/core/pipeline/nodes/filters/simple-blur.js","webpack://Speedy/./src/core/pipeline/nodes/images/buffer.js","webpack://Speedy/./src/core/pipeline/nodes/images/multiplexer.js","webpack://Speedy/./src/core/pipeline/nodes/images/pyramid.js","webpack://Speedy/./src/core/pipeline/nodes/images/sink.js","webpack://Speedy/./src/core/pipeline/nodes/images/source.js","webpack://Speedy/./src/core/pipeline/nodes/keypoints/buffer.js","webpack://Speedy/./src/core/pipeline/nodes/keypoints/clipper.js","webpack://Speedy/./src/core/pipeline/nodes/keypoints/descriptors/descriptor.js","webpack://Speedy/./src/core/pipeline/nodes/keypoints/descriptors/orb.js","webpack://Speedy/./src/core/pipeline/nodes/keypoints/detectors/detector.js","webpack://Speedy/./src/core/pipeline/nodes/keypoints/detectors/fast.js","webpack://Speedy/./src/core/pipeline/nodes/keypoints/detectors/harris.js","webpack://Speedy/./src/core/pipeline/nodes/keypoints/mixer.js","webpack://Speedy/./src/core/pipeline/nodes/keypoints/sink.js","webpack://Speedy/./src/core/pipeline/nodes/keypoints/source.js","webpack://Speedy/./src/core/pipeline/nodes/keypoints/trackers/lk.js","webpack://Speedy/./src/core/pipeline/nodes/transforms/perspective-warp.js","webpack://Speedy/./src/core/pipeline/nodes/transforms/resize.js","webpack://Speedy/./src/core/pipeline/pipeline-message.js","webpack://Speedy/./src/core/pipeline/pipeline-node.js","webpack://Speedy/./src/core/pipeline/pipeline-port.js","webpack://Speedy/./src/core/pipeline/pipeline-portbuilder.js","webpack://Speedy/./src/core/pipeline/pipeline-portspec.js","webpack://Speedy/./src/core/pipeline/pipeline.js","webpack://Speedy/./src/core/speedy-descriptor.js","webpack://Speedy/./src/core/speedy-feature-decorator.js","webpack://Speedy/./src/core/speedy-feature-descriptor-factory.js","webpack://Speedy/./src/core/speedy-feature-detector-factory.js","webpack://Speedy/./src/core/speedy-feature-detector.js","webpack://Speedy/./src/core/speedy-feature-tracker-factory.js","webpack://Speedy/./src/core/speedy-feature-tracker.js","webpack://Speedy/./src/core/speedy-feature.js","webpack://Speedy/./src/core/speedy-flags.js","webpack://Speedy/./src/core/speedy-keypoint.js","webpack://Speedy/./src/core/speedy-media-source.js","webpack://Speedy/./src/core/speedy-media.js","webpack://Speedy/./src/core/speedy-namespace.js","webpack://Speedy/./src/core/speedy-point.js","webpack://Speedy/./src/core/speedy-size.js","webpack://Speedy/./src/core/speedy-vector.js","webpack://Speedy/./src/core/speedy.js","webpack://Speedy/./src/gpu/gl-utils.js","webpack://Speedy/./src/gpu/programs/colors.js","webpack://Speedy/./src/gpu/programs/encoders.js","webpack://Speedy/./src/gpu/programs/enhancements.js","webpack://Speedy/./src/gpu/programs/filters.js","webpack://Speedy/./src/gpu/programs/keypoints.js","webpack://Speedy/./src/gpu/programs/pyramids.js","webpack://Speedy/./src/gpu/programs/trackers.js","webpack://Speedy/./src/gpu/programs/transforms.js","webpack://Speedy/./src/gpu/programs/utils.js","webpack://Speedy/./src/gpu/shader-declaration.js","webpack://Speedy/./src/gpu/shader-preprocessor.js","webpack://Speedy/./src/gpu/shaders sync ^\\.\\/.*$","webpack://Speedy/./src/gpu/shaders/colors/rgb2grey.glsl","webpack://Speedy/./src/gpu/shaders/encoders/encode-keypoint-long-offsets.glsl","webpack://Speedy/./src/gpu/shaders/encoders/encode-keypoint-offsets.glsl","webpack://Speedy/./src/gpu/shaders/encoders/encode-keypoints.glsl","webpack://Speedy/./src/gpu/shaders/encoders/encode-null-keypoints.glsl","webpack://Speedy/./src/gpu/shaders/encoders/resize-encoded-keypoints.glsl","webpack://Speedy/./src/gpu/shaders/encoders/upload-keypoints.glsl","webpack://Speedy/./src/gpu/shaders/enhancements/nightvision.glsl","webpack://Speedy/./src/gpu/shaders/enhancements/normalize-image.glsl","webpack://Speedy/./src/gpu/shaders/filters/convolution.js","webpack://Speedy/./src/gpu/shaders/filters/convolution1d.glsl","webpack://Speedy/./src/gpu/shaders/filters/convolution2d.glsl","webpack://Speedy/./src/gpu/shaders/filters/fast-median.glsl","webpack://Speedy/./src/gpu/shaders/include sync ^\\.\\/.*$","webpack://Speedy/./src/gpu/shaders/include/colors.glsl","webpack://Speedy/./src/gpu/shaders/include/fixed-point.glsl","webpack://Speedy/./src/gpu/shaders/include/float16.glsl","webpack://Speedy/./src/gpu/shaders/include/global.glsl","webpack://Speedy/./src/gpu/shaders/include/keypoints.glsl","webpack://Speedy/./src/gpu/shaders/include/math.glsl","webpack://Speedy/./src/gpu/shaders/include/orientation.glsl","webpack://Speedy/./src/gpu/shaders/include/pyramids.glsl","webpack://Speedy/./src/gpu/shaders/include/quickselect.glsl","webpack://Speedy/./src/gpu/shaders/include/sobel.glsl","webpack://Speedy/./src/gpu/shaders/include/subpixel.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/brisk.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/expand-encoder.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/fast.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/fast/fast-score12.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/fast/fast-score16.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/fast/fast-score8.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/fast/fast5.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/fast/fast7.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/fast/fast9.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/fast/multiscale-fast.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/harris-cutoff.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/harris-derivatives.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/harris.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/harris/encode-harris-score.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/harris/multiscale-harris.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/harris/multiscale-sobel.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/mix-keypoints.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/nonmax-suppression.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/orb-descriptor.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/orb-orientation.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/score-8bits.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/score-findmax.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/sort-applyperm.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/sort-createperm.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/sort-mergeperm.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/suppress-descriptors.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/transfer-orientation.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/upload-keypoints.glsl","webpack://Speedy/./src/gpu/shaders/pyramids/downsample2.glsl","webpack://Speedy/./src/gpu/shaders/pyramids/upsample2.glsl","webpack://Speedy/./src/gpu/shaders/trackers/lk-discard-old.glsl","webpack://Speedy/./src/gpu/shaders/trackers/lk-discard.glsl","webpack://Speedy/./src/gpu/shaders/trackers/lk.glsl","webpack://Speedy/./src/gpu/shaders/trackers/transfer-flow.glsl","webpack://Speedy/./src/gpu/shaders/transforms/resize.glsl","webpack://Speedy/./src/gpu/shaders/transforms/warp-perspective.glsl","webpack://Speedy/./src/gpu/shaders/utils/copy-components.glsl","webpack://Speedy/./src/gpu/shaders/utils/fill-components.glsl","webpack://Speedy/./src/gpu/shaders/utils/fill.glsl","webpack://Speedy/./src/gpu/shaders/utils/flip-y.glsl","webpack://Speedy/./src/gpu/shaders/utils/identity.glsl","webpack://Speedy/./src/gpu/shaders/utils/scan-minmax2d.glsl","webpack://Speedy/./src/gpu/speedy-gl.js","webpack://Speedy/./src/gpu/speedy-gpu.js","webpack://Speedy/./src/gpu/speedy-program-center.js","webpack://Speedy/./src/gpu/speedy-program-group.js","webpack://Speedy/./src/gpu/speedy-program.js","webpack://Speedy/./src/gpu/speedy-texture-pool.js","webpack://Speedy/./src/gpu/speedy-texture-reader.js","webpack://Speedy/./src/gpu/speedy-texture-uploader.js","webpack://Speedy/./src/gpu/speedy-texture.js","webpack://Speedy/./src/index.js","webpack://Speedy/./src/utils/errors.js","webpack://Speedy/./src/utils/fps-counter.js","webpack://Speedy/./src/utils/globals.js","webpack://Speedy/./src/utils/observable.js","webpack://Speedy/./src/utils/sorting-networks.js","webpack://Speedy/./src/utils/speedy-promise.js","webpack://Speedy/./src/utils/types.js","webpack://Speedy/./src/utils/utils.js"],"names":[],"mappings":";;;;;;;;;;;;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA,4BAA4B,UAAU;;;;;;;;;;;;;ACvLtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoD;AAC2B;AACvB;AACG;AACQ;;AAEnE;AACA,2BAA2B;;AAE3B;AACA;AACA;AACO,0BAA0B,0FAA2B;AAC5D;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,gBAAgB;AAC/B,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,2EAA2B;AACvD;AACA,uCAAuC,mEAAgB;AACvD;AACA;AACA;AACA,C;;;;;;;;;;;;ACtGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoD;AACQ;AACe;AACjB;AACb;AACe;;AAE5D;AACA;AACA;AACA;AACA;AACA,oCAAoC;;;;AAIpC;AACA;AACA;AACO,2BAA2B,sFAAyB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,QAAQ,kDAAK;AACb;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,QAAQ,kDAAK;AACb;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+DAAiB;;AAEvC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACO,qCAAqC,sFAAyB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,QAAQ,kDAAK;AACb;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,QAAQ,kDAAK;AACb;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,QAAQ,kDAAK,2CAA2C,iEAAkB;AAC1E;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;AC9QA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkD;AACE;AACgB;AACO;AACrB;AACM;AACf;;AAE7C;AACA,4BAA4B;AAC5B,wBAAwB;AACxB,8BAA8B;AAC9B,gDAAgD;AAChD,0BAA0B;AAC1B,0BAA0B;AAC1B,uBAAuB,iEAAkB,KAAK;;AAE9C;AACA;AACA;AACO,6BAA6B,sFAAyB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,QAAQ,kDAAK;AACb;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO,uCAAuC,sFAAyB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,sBAAsB;AACrE,gBAAgB,yEAAqB,CAAC,uDAAQ;AAC9C;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,QAAQ,kDAAK;AACb;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,QAAQ,kDAAK,2CAA2C,iEAAkB;AAC1E;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sBAAsB,oBAAoB;AAC1C;AACA;AACA;AACA;AACA,mCAAmC,6BAA6B;AAChE,wDAAwD;;AAExD;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;ACrPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuD;AACL;AACS;AACjB;;AAE1C;AACA;AACA;AACA;AACA;AACO,wCAAwC,mEAAgB;AAC/D;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA,QAAQ,kDAAK,sCAAsC,mEAAgB;AACnE,QAAQ,kDAAK;AACb,QAAQ,kDAAK;;AAEb;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,eAAe,sBAAsB;AACrC,iBAAiB;AACjB;AACA;AACA;AACA,QAAQ,kDAAK;AACb,QAAQ,kDAAK;;AAEb;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACvIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiD;AACQ;AACA;AACf;AACQ;AACS;AACD;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA,QAAQ,kDAAK,0BAA0B,kEAAmB;AAC1D,QAAQ,kDAAK;AACb,QAAQ,kDAAK;;AAEb,mBAAmB,OAAO;AAC1B,8CAA8C;;AAE9C,mBAAmB,OAAO;AAC1B,oCAAoC;AACpC;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,eAAe,sBAAsB;AACrC,iBAAiB,+BAA+B;AAChD;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,QAAQ,kDAAK,mCAAmC;AAChD;;AAEA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,QAAQ,kDAAK,wCAAwC;AACrD;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;AACA,C;;;;;;;;;;;;ACnIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AACF;AACmB;AACA;AACxB;AACS;AACjB;;AAE1C;AACA;AACA;AACA;AACO,0CAA0C,sFAAyB;AAC1E;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,OAAO;AACtB;AACA;AACA;AACA,QAAQ,kDAAK,sCAAsC,mEAAgB;AACnE,QAAQ,kDAAK;;AAEb;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,eAAe,sBAAsB;AACrC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA,eAAe,gBAAgB;AAC/B,iBAAiB;AACjB;AACA;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;AACA,C;;;;;;;;;;;;ACnGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AACF;AACE;AACP;AACD;AACQ;AACE;;AAE3D;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACO,wCAAwC,mEAAgB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,kCAAkC;AACrD;;AAEA,mBAAmB,kBAAkB;AACrC,+BAA+B,qEAAiB;AAChD;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,eAAe,sBAAsB;AACrC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,qCAAqC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,EAAE;AAClD;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2DAA2D;AAC3D;;AAEA;AACA;AACA,C;;;;;;;;;;;;ACzJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEmD;AACD;AACD;AACU;AACA;AACjB;AAIb;;AAE7B;AACA,gCAAgC,+DAAc,gBAAgB,qEAAsB,EAAE;AACtF,iCAAiC;AACjC,yBAAyB;AACzB;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC;AAChC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,8BAA8B,qEAAsB;;AAEpD,mBAAmB,sBAAsB;AACzC;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,sBAAsB;AACrC,iBAAiB;AACjB;AACA;AACA;AACA;AACA,QAAQ,kDAAK;AACb,QAAQ,kDAAK;;AAEb;AACA;AACA;AACA,2DAA2D;AAC3D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B,+DAAc;;AAE5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAkC,+DAAc;;AAEhD;AACA;;AAEA,SAAS;AACT,sBAAsB,mEAAqB;AAC3C,SAAS;AACT;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,kBAAkB,+DAAc;AAChC;AACA;;AAEA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;;AAEA,qCAAqC,QAAQ;AAC7C,4CAA4C,0DAAW;;AAEvD;AACA;;;;AAIA;AACA;AACA,iBAAiB,OAAO;AACxB;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mDAAmD;AACnD;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC/QA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkD;AAMrB;;AAE7B;AACA,+CAA+C,gEAAiB,OAAO;AACvE,+BAA+B;;AAE/B;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,6CAA6C,gEAAiB;AAC9D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA,6CAA6C,gEAAiB;AAC9D;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA,6CAA6C,gEAAiB;AAC9D;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sBAAsB,UAAU;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA,iBAAiB,6DAAc;AAC/B,iBAAiB,6DAAc;;AAE/B;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,qEAAsB,IAAI,qEAAsB,GAAG,iEAAkB;;AAEtF;AACA,mCAAmC,2DAAY;AAC/C;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA,oBAAoB,6DAAa;AACjC;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;ACnJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiD;AACQ;AACA;AACF;AACE;AACN;AACD;AACS;AACjB;;AAE1C;AACA;AACA;AACA;AACO,uCAAuC,mEAAgB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,cAAc;AACjC;;AAEA,mBAAmB,cAAc;AACjC;;AAEA,mBAAmB,kBAAkB;AACrC,+BAA+B,qEAAiB;AAChD;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,eAAe,sBAAsB;AACrC,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,qEAAiB;AACpC,YAAY,kDAAK;;AAEjB;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,gBAAgB;AAC/B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA,8BAA8B,+DAAc;AAC5C;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;AACA,C;;;;;;;;;;;;AC9JA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoD;AACQ;AACa;AAC5B;AACe;;AAE5D;AACA;AACA,kCAAkC,iEAAkB;AACpD;AACA;AACA;;AAEA;AACA;AACA;AACO,yCAAyC,oFAAwB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,QAAQ,kDAAK;AACb;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,QAAQ,kDAAK,2CAA2C,iEAAkB;AAC1E;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,QAAQ,kDAAK;AACb;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,QAAQ,kDAAK;AACb;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,QAAQ,kDAAK;AACb;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;AC7KA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE8G;AACnD;AACnB;AACE;;AAE1C;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,aAAa;AAC5B,eAAe,eAAe;AAC9B;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;;AAEA,mBAAmB,aAAa;AAChC;;AAEA,mBAAmB,eAAe;AAClC;;AAEA;AACA;AACA,YAAY,kDAAK;;AAEjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,aAAa;AAC5B,eAAe,2BAA2B;AAC1C,eAAe,2BAA2B;AAC1C;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,2BAA2B;AAC9C;;AAEA,mBAAmB,6CAA6C;AAChE;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,QAAQ;AAC9D;AACA;AACA;AACA;AACA,uBAAuB,yCAAyC;AAChE;AACA;;AAEA;AACA,yDAAyD,QAAQ;AACjE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,0EAAuB;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,0EAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,cAAc;AAC7B,gBAAgB,OAAO;AACvB;AACA;AACA;AACA,QAAQ,kDAAK;AACb;AACA;AACA;AACA,C;;;;;;;;;;;;AC3KA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA,WAAW,wBAAwB;AACnC,WAAW,QAAQ;AACnB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,aAAa;AAC/B;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA,WAAW,wBAAwB;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,aAAa;AACrC,kBAAkB,UAAU;AAC5B;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA,WAAW,wBAAwB;AACnC;AACA;;AAEA;AACA,mBAAmB,UAAU;AAC7B,uBAAuB,aAAa;AACpC;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA,WAAW,wBAAwB;AACnC;AACA;;AAEA;AACA,6BAA6B,aAAa;AAC1C,kBAAkB,UAAU;AAC5B;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA,WAAW,wBAAwB;AACnC;AACA;;AAEA;AACA,6BAA6B,aAAa;AAC1C,kBAAkB,UAAU;AAC5B;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA,WAAW,wBAAwB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,aAAa;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,cAAc;AACtC,uBAAuB,cAAc;AACrC;AACA,sBAAsB,UAAU;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA,WAAW,wBAAwB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,cAAc;AACtC,uBAAuB,cAAc;AACrC;AACA,sBAAsB,WAAW;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA,WAAW,wBAAwB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,aAAa;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,cAAc;AACtC,uBAAuB,WAAW;AAClC;AACA,sBAAsB,UAAU;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,mBAAmB,cAAc;AACjC;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA,WAAW,wBAAwB;AACnC,WAAW,SAAS;AACpB;;AAEA;AACA,cAAc,aAAa;AAC3B;AACA,kBAAkB,UAAU;AAC5B;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA,WAAW,wBAAwB;AACnC;AACA;;AAEA;AACA,6BAA6B,aAAa;AAC1C,kBAAkB,UAAU;AAC5B;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA,WAAW,wBAAwB;AACnC;AACA,4B;;AAEA;AACA,yBAAyB,aAAa;AACtC,oBAAoB;AACpB,kBAAkB,UAAU;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA,WAAW,wBAAwB;AACnC;AACA,WAAW,cAAc;AACzB;;AAEA;AACA,6BAA6B,aAAa;AAC1C,kBAAkB,UAAU;AAC5B;AACA;AACA,C;;;;;;;;;;;;AChXA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA;AACA,WAAW,wBAAwB;AACnC;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,uCAAuC,YAAY;AACnD;;AAEA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA,gEAAgE,kBAAkB;AAClF,sBAAsB,eAAe;AACrC;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gEAAgE,wBAAwB;AACxF,sBAAsB,qBAAqB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA;AACA,WAAW,wBAAwB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,uCAAuC,YAAY;AACnD;;AAEA;AACA;AACA,iCAAiC;AACjC,mCAAmC,aAAa;AAChD,kBAAkB,UAAU;AAC5B;AACA;;AAEA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA,gEAAgE,kBAAkB;AAClF,sBAAsB,eAAe;AACrC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,uCAAuC,aAAa;AACpD,sBAAsB,UAAU;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA,mCAAmC,aAAa;AAChD,kBAAkB,UAAU;AAC5B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA;AACA,WAAW,wBAAwB;AACnC;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,yHAAyH;AACzH,+CAA+C,YAAY;AAC3D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC;AACzC,oEAAoE,kBAAkB;AACtF,sBAAsB,eAAe;AACrC;AACA;;AAEA,kBAAkB;AAClB,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,qFAAqF,kBAAkB;AACvG,8BAA8B,eAAe;AAC7C;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA,qFAAqF,kBAAkB;AACvG,8BAA8B,eAAe;AAC7C;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,OAAO,OAAO;AAC5B,0CAA0C;AAC1C,oEAAoE,kBAAkB;AACtF,sBAAsB,eAAe;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;AC/OA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC;;AAElC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC;;AAElC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE,qDAAqD;AACrD,iDAAiD;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sCAAsC,OAAO;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,aAAa;AAC7B,gBAAgB,aAAa;AAC7B,gBAAgB,aAAa;;AAE7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA,uDAAuD;AACvD,uDAAuD;AACvD;AACA;AACA;AACA,gDAAgD;AAChD,+CAA+C;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C,mBAAmB,0BAA0B;AAC7C,mBAAmB,0BAA0B;;AAE7C;AACA;AACA;AACA,qBAAqB,4BAA4B;AACjD,qBAAqB,4BAA4B;AACjD,qBAAqB,4BAA4B;;AAEjD;AACA,8BAA8B,OAAO;AACrC;AACA;AACA;AACA,C;;;;;;;;;;;;ACvlBA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,aAAa,GAAG,mBAAO,CAAC,wDAAgB;AAC/C;AACA,OAAO,mBAAO,CAAC,kDAAS;AACxB,OAAO,mBAAO,CAAC,sDAAW;AAC1B,OAAO,mBAAO,CAAC,kDAAS;AACxB,OAAO,mBAAO,CAAC,4CAAM;AACrB,OAAO,mBAAO,CAAC,wDAAY;AAC3B,OAAO,mBAAO,CAAC,4DAAc;AAC7B,OAAO,mBAAO,CAAC,4DAAc;AAC7B,OAAO,mBAAO,CAAC,0DAAa;AAC5B,OAAO,mBAAO,CAAC,oDAAU;AACzB,OAAO,mBAAO,CAAC,kDAAS;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB,WAAW,OAAO;AAClB;;AAEA,WAAW,OAAO;AAClB;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA,2CAA2C,KAAK;AAChD;AACA,mDAAmD,KAAK;AACxD;AACA,iDAAiD,KAAK;;AAEtD;AACA,sBAAsB;AACtB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,oCAAoC,EAAE,MAAM,QAAQ,mBAAmB;AACvE;;AAEA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,2BAA2B,sBAAsB;;AAEjD,EAAE;;AAEF;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED,kBAAkB,U;;;;;;;;;;;;AClIlB;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mEAAmE,MAAM,KAAK,SAAS;;AAEvF;AACA;AACA,mEAAmE,MAAM,KAAK,SAAS,wCAAwC,MAAM,+BAA+B,MAAM;;AAE1K;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,cAAc;AAC5B,4BAA4B;AAC5B,8BAA8B;;AAE9B,sBAAsB;AACtB,oEAAoE;;AAEpE;AACA,kBAAkB,OAAO;AACzB;AACA,2DAA2D;;AAE3D;AACA;AACA;AACA,4BAA4B,UAAU;AACtC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6CAA6C,qBAAqB;AAClE;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gFAAgF,MAAM,KAAK,SAAS,6CAA6C,MAAM,KAAK,iBAAiB,UAAU,MAAM,KAAK,SAAS;;AAE3M;AACA,sBAAsB,WAAW,OAAO;AACxC;AACA,oCAAoC;AACpC,qCAAqC,QAAQ,OAAO;AACpD;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,cAAc;AACzC,iCAAiC,WAAW;AAC5C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mFAAmF,MAAM,KAAK,SAAS,6CAA6C,MAAM,KAAK,oBAAoB,UAAU,MAAM,KAAK,SAAS;;AAEjN;AACA,sBAAsB,cAAc,OAAO;AAC3C;AACA,oCAAoC;AACpC,qCAAqC,QAAQ,OAAO;AACpD;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wFAAwF,EAAE,eAAe,MAAM,KAAK,SAAS;AAC7H;AACA,yFAAyF,EAAE,KAAK,IAAI,WAAW,MAAM,KAAK,SAAS;;AAEnI;AACA,sBAAsB,OAAO;AAC7B;;AAEA;AACA,sBAAsB,OAAO,OAAO;AACpC,+BAA+B;AAC/B;AACA,0BAA0B,OAAO;AACjC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wFAAwF,EAAE,eAAe,MAAM,KAAK,SAAS;AAC7H;AACA,yFAAyF,EAAE,KAAK,IAAI,WAAW,MAAM,KAAK,SAAS;;AAEnI;AACA,sBAAsB,OAAO;AAC7B;;AAEA;AACA,0BAA0B,QAAQ,OAAO;AACzC,+BAA+B;AAC/B;AACA,0BAA0B,OAAO;AACjC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,yCAAyC;AACzC;;AAEA;AACA;AACA,wFAAwF,EAAE,eAAe,MAAM,KAAK,SAAS;AAC7H;AACA,yFAAyF,EAAE,KAAK,IAAI,WAAW,MAAM,KAAK,SAAS;;AAEnI;AACA,sBAAsB,OAAO,OAAO;AACpC;AACA;AACA;;AAEA;AACA,8BAA8B,QAAQ;AACtC;AACA;AACA,kCAAkC,QAAQ;AAC1C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,+DAA+D,KAAK;AACpE;AACA,C;;;;;;;;;;;;ACpSA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA,WAAW,+BAA+B;AAC1C,2CAA2C;AAC3C,2BAA2B;AAC3B,wCAAwC;AACxC;AACA;AACA;AACA,WAAW,oDAAoD;AAC/D;AACA,6CAA6C;AAC7C,gDAAgD;AAChD,8BAA8B,cAAc,mBAAmB;AAC/D;AACA;AACA,8BAA8B,gBAAgB,cAAc;AAC5D,mCAAmC,6BAA6B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,SAAS;AACvB;;AAEA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,cAAc,QAAQ;AACtB;AACA;AACA,iCAAiC;AACjC,wBAAwB;AACxB;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uCAAuC;AACvC,4BAA4B;AAC5B,mCAAmC;AACnC,mCAAmC;AACnC,mCAAmC;AACnC,mCAAmC;;AAEnC;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;;AAEA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;;AAEA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA,C;;;;;;;;;;;;AC1NA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA;AACA,C;;;;;;;;;;;;AC9BA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;;AAEA;AACA,+DAA+D,MAAM,KAAK,QAAQ,MAAM,WAAW,KAAK,SAAS,qBAAqB,MAAM,KAAK,SAAS;AAC1J;AACA,gEAAgE,MAAM,yBAAyB,KAAK,KAAK,QAAQ;;AAEjH;AACA;AACA,qBAAqB;AACrB,yCAAyC;AACzC,sCAAsC;AACtC,wCAAwC;;AAExC;AACA,gBAAgB,QAAQ;AACxB;AACA,oBAAoB,OAAO;AAC3B;;AAEA;AACA;AACA;AACA;AACA,0DAA0D,IAAI;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B,sBAAsB;;AAEnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;ACnGA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA,WAAW,kBAAkB;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AClHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,YAAY;AACvB,WAAW,cAAc;AACzB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,WAAW,kBAAkB;AAC7B,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACO,kDAAkD;AACzD;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,OAAO;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,WAAW,kBAAkB;AAC7B,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACO,4EAA4E;AACnF;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mDAAmD,OAAO;AAC1D;AACA,qFAAqF;AACrF,qFAAqF;AACrF,6DAA6D;;AAE7D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA;;AAEA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,MAAM;AACjB,aAAa;AACb;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;AACA;;AAEA;AACA;AACA,kBAAkB,SAAS;AAC3B;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,gBAAgB;AAC3B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACO;AACP;AACA;;AAEA,cAAc,YAAY;AAC1B;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,MAAM;AACnB;AACO;AACP;AACA;AACA;;AAEA,8BAA8B,WAAW;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,SAAS;AACtB;AACO;AACP;AACA,uBAAuB,YAAY;AACnC;;;;;;;;;;;;;ACrOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2C;AACyD;AACzC;;;AAG3D;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,8BAA8B;AAC7C,eAAe,eAAe;AAC9B,eAAe,cAAc;AAC7B;AACA,+CAA+C,uDAAU;AACzD;AACA;;AAEA;AACA,YAAY,uDAAU;AACtB,sBAAsB,kEAAoB,wBAAwB,MAAM;AACxE;AACA,sBAAsB,kEAAoB;;AAE1C;AACA;AACA,+BAA+B,uDAAU;AACzC,oCAAoC,uDAAU;AAC9C;;;;AAIA;;AAEA,mBAAmB,eAAe;AAClC;;AAEA,mBAAmB,gBAAgB;AACnC;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;;;;AAIA;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,kBAAkB;AACrC;;AAEA,mBAAmB,eAAe;AAClC;;AAEA,mBAAmB,cAAc;AACjC;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mEAAa;AACpC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,mBAAmB,mEAAa;AAChC;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,iBAAiB,EAAE;AACnC;;AAEA;AACA;;AAEA;AACA,4CAA4C,QAAQ;AACpD;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,iBAAiB,EAAE;AACnC;;AAEA;AACA;AACA,oEAAoE;AACpE;;AAEA;AACA;;AAEA,0BAA0B,OAAO;AACjC;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;;AAEA;AACA,4CAA4C,QAAQ;AACpD;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;;AAEzD;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,iBAAiB,EAAE;AACnC;;AAEA;AACA,mBAAmB,uDAAU;;AAE7B;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA,C;;;;;;;;;;;;ACpPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0D;AACf;AACE;AACL;AACiB;AACV;AAWjB;;AAE9B;AACA;AACA;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,eAAe;AAC9B,iBAAiB;AACjB;AACA,wCAAwC,uDAAU;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,eAAe;AAC9B,iBAAiB;AACjB;AACA,uCAAuC,uDAAU;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,eAAe;AAC9B,iBAAiB;AACjB;AACA,sCAAsC,uDAAU;AAChD;AACA;AACA,gDAAgD,QAAQ;AACxD;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,eAAe;AAC9B,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA,yDAAyD,uDAAU;AACnE;AACA,wBAAwB,yDAAW;;AAEnC;AACA;AACA,0BAA0B,kEAAoB,8CAA8C,OAAO;AACnG;AACA,6BAA6B,oDAAY;AACzC;;AAEA,mBAAmB,8EAA0B;AAC7C;;;;;AAKA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,qEAAoB;AACnC;;AAEA;AACA;AACA,eAAe,iBAAiB;AAChC,iBAAiB;AACjB;AACA;AACA;AACA,wBAAwB,8EAA0B;AAClD;AACA;;AAEA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,eAAe;AAC9B,iBAAiB,iBAAiB;AAClC;AACA,+BAA+B,uDAAU;AACzC;AACA;AACA,sBAAsB,kEAAoB,qCAAqC,OAAO;;AAEtF;AACA,sBAAsB,OAAO;AAC7B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,iBAAiB;AAChC,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB,kBAAkB,yBAAyB;;AAErF;AACA;AACA,0BAA0B,OAAO;AACjC,gCAAgC,0DAAY;;AAE5C;AACA,SAAS;AACT;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,UAAU;AACzB,iBAAiB,kCAAkC;AACnD;AACA,iBAAiB,OAAO;AACxB,kBAAkB,OAAO;AACzB;AACA,wBAAwB;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;AAMA;AACA;AACA;;AAEA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB,mDAAmD,OAAO,OAAO,YAAY;;AAEvH,mBAAmB,gFAA4B;AAC/C;;AAEA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC,eAAe,sBAAsB;AACrC;AACA,iBAAiB,OAAO;AACxB,kBAAkB,OAAO;AACzB,kBAAkB,+BAA+B;AACjD;AACA,iBAAiB,OAAO;AACxB,kBAAkB,wBAAwB;AAC1C,kBAAkB,OAAO;AACzB,kBAAkB,OAAO;AACzB,kBAAkB,OAAO;AACzB;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,0BAA0B;;AAEnC;AACA;AACA,sBAAsB,kEAAoB,0CAA0C,OAAO,OAAO,YAAY;;AAE9G;AACA;AACA;AACA;AACA,kCAAkC,yDAAW,kCAAkC;AAC/E,gDAAgD,8EAA0B,gBAAgB,oDAAY;;AAEtG;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,0EAAsB;AACvD,0BAA0B,kEAAoB;AAC9C;AACA,0BAA0B,kEAAoB,6DAA6D,eAAe;;AAE1H;AACA,uBAAuB,qFAAiC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iFAA6B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB,kDAAkD,eAAe;AAC3G;AACA;;AAEA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB,kDAAkD,yBAAyB;;AAErH;AACA;AACA,2BAA2B,mFAA+B;AAC1D;AACA,2BAA2B,+EAA2B;AACtD;AACA;AACA,uBAAuB,iFAA6B;;AAEpD,kBAAkB,kEAAoB,+DAA+D,sBAAsB;AAC3H;AACA,C;;;;;;;;;;;;AChVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwC;AACkD;AAC7C;AACqB;AAC4E;AACnF;AACjB;AACsB;AA6BnC;;AAE7B;AACA,8BAA8B,8EAAqB;;;AAGnD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;;AAEA,mBAAmB,qBAAqB;AACxC,kCAAkC;AAClC;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA,kBAAkB,mEAAqB;AACvC;;AAEA;AACA;AACA,eAAe,yBAAyB;AACxC,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,mEAAqB;AACvC;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB,6CAA6C,eAAe,YAAY,aAAa;AAChI;AACA,sBAAsB,mEAAqB,wCAAwC,cAAc,KAAK,iBAAiB,UAAU,YAAY,KAAK,eAAe;AACjK;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA,eAAe,0BAA0B;AACzC,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,mEAAqB;AACvC;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,mEAAqB;AACvC;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;;;AAGA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,iBAAiB;AAChC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,iBAAiB;AAChC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,wBAAwB;AACvC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,iBAAiB;AAChC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;;AAEA;AACA;AACA,eAAe,iBAAiB;AAChC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,4BAA4B;AAC3C,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,mEAAqB;AACvC;;;;;;;;;AASA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB;AAC1C;AACA,sBAAsB,kEAAoB,6BAA6B,UAAU,4CAA4C,UAAU;AACvI;AACA,sBAAsB,kEAAoB,uDAAuD,aAAa,qCAAqC,aAAa;;AAEhK;AACA,+BAA+B,yDAAW;AAC1C,+BAA+B,yDAAW;AAC1C,kEAAkE,oDAAY;AAC9E,qEAAqE,oDAAY;AACjF;AACA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB;AAC1C;AACA,sBAAsB,kEAAoB,gCAAgC,UAAU,4CAA4C,UAAU;AAC1I;AACA,sBAAsB,kEAAoB,0DAA0D,aAAa,qCAAqC,aAAa;AACnK;AACA,sBAAsB,kEAAoB;;AAE1C;AACA,+BAA+B,yDAAW;AAC1C,+BAA+B,yDAAW;AAC1C,kEAAkE,oDAAY;AAC9E,qFAAqF,oDAAY;AACjG,qEAAqE,oDAAY;AACjF;AACA;AACA;AACA,sBAAsB,mEAAqB;AAC3C;AACA,sBAAsB,mEAAqB;;AAE3C;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB;AAC1C;AACA,sBAAsB,kEAAoB,8BAA8B,UAAU,4CAA4C,UAAU;AACxI;AACA,sBAAsB,kEAAoB,wDAAwD,aAAa,qCAAqC,aAAa;;AAEjK;AACA,+BAA+B,yDAAW;AAC1C,kEAAkE,oDAAY;AAC9E,kEAAkE,oDAAY;;AAE9E;AACA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,kEAAoB,kDAAkD,KAAK,KAAK,QAAQ;AAC9G;AACA,sBAAsB,kEAAoB,qBAAqB,KAAK,oCAAoC,OAAO,KAAK,UAAU;;AAE9H;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,0BAA0B,kEAAoB,+BAA+B,OAAO;AACpF;AACA;;;;;;;;AAQA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA,0BAA0B,yDAAW;AACrC,2BAA2B,oDAAY;;AAEvC;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;;AAEA,mBAAmB,aAAa;AAChC,8BAA8B,oDAAY;AAC1C;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;;AAEA,mBAAmB,gBAAgB;AACnC;;AAEA;AACA,QAAQ,kDAAK,iDAAiD;AAC9D;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,gBAAgB,gFAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;;AAEA,mBAAmB,iBAAiB;AACpC;;AAEA,mBAAmB,gBAAgB;AACnC;;AAEA;AACA,QAAQ,kDAAK,iDAAiD;AAC9D;AACA,sBAAsB,kEAAoB,0DAA0D,eAAe,sBAAsB,gBAAgB;AACzJ;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,mEAAa;AAC5B;AACA;AACA;AACA,gBAAgB,gFAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;;AAEA,mBAAmB,iBAAiB;AACpC;;AAEA,mBAAmB,iBAAiB;AACpC;;AAEA,mBAAmB,gBAAgB;AACnC;;AAEA;AACA,QAAQ,kDAAK,iDAAiD;AAC9D;AACA,sBAAsB,kEAAoB,2DAA2D,gBAAgB,uBAAuB,iBAAiB,wBAAwB,gBAAgB;AACrM;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,mEAAa;AAC5B;AACA;AACA;AACA;AACA,gBAAgB,gFAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA,kBAAkB,yDAAW;;AAE7B,mBAAmB,iBAAiB;AACpC;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,cAAc;AACjC;;AAEA,mBAAmB,cAAc;AACjC;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT,gBAAgB,gFAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA,kBAAkB,yDAAW;;AAE7B,mBAAmB,iBAAiB;AACpC;;AAEA,mBAAmB,cAAc;AACjC;;AAEA,mBAAmB,cAAc;AACjC;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT,gBAAgB,gFAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;;AAEA,mBAAmB,uBAAuB;AAC1C;;AAEA,mBAAmB,iBAAiB;AACpC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,mEAAa;AAC5B;AACA;AACA;AACA;AACA,oBAAoB,gFAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,mEAAa;AAC5B;AACA;AACA;AACA,gBAAgB,gFAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA,eAAe,yBAAyB;AACxC,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA,eAAe,0BAA0B;AACzC,iBAAiB,sCAAsC;AACvD;AACA;AACA;AACA;AACA;AACA,4BAA4B,oDAAY;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,4BAA4B,oDAAY;AACxC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,cAAc;AAC7B;AACA;AACA;AACA;;AAEA,mBAAmB,aAAa;AAChC,yCAAyC,oDAAY;;AAErD,mBAAmB,gBAAgB;AACnC,yBAAyB,sEAAmB;;AAE5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,mEAAa;AAC5B;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,mEAAa,aAAa,gFAAwB;AACjE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,yBAAyB;AACxC,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,mEAAa,aAAa,gFAAwB;AACjE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA,kBAAkB,yDAAW;;AAE7B,mBAAmB,uBAAuB;AAC1C;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,cAAc;AACjC;;AAEA,mBAAmB,cAAc;AACjC;;AAEA,mBAAmB,gBAAgB;AACnC,yBAAyB,sEAAmB;AAC5C;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,SAAS;AACT;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT,gBAAgB,gFAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,yBAAyB;AACxC,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,mEAAa,aAAa,gFAAwB;AACjE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC;AACA;AACA;AACA;AACA,kBAAkB,yDAAW;;AAE7B,mBAAmB,uBAAuB;AAC1C;;AAEA,mBAAmB,cAAc;AACjC;;AAEA,mBAAmB,cAAc;AACjC;;AAEA,mBAAmB,gBAAgB;AACnC,yBAAyB,sEAAmB;AAC5C;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,SAAS;AACT;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT,gBAAgB,gFAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,yBAAyB;AACxC,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,mEAAa,aAAa,gFAAwB;AACjE;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA,mBAAmB,gBAAgB;AACnC,8BAA8B,sEAAmB;AACjD;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,mEAAa,aAAa,gFAAwB;AACjE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,2EAAwB;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB;AAC3C;AACA,sBAAsB,+DAAiB;;AAEvC,wBAAwB,yEAAsB;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA,uCAAuC,qEAAkB;AACzD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA,uCAAuC,0EAAuB;AAC9D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,kEAAoB,qBAAqB,cAAc,KAAK,iBAAiB,eAAe,eAAe,KAAK,kBAAkB;;AAExJ,uCAAuC,0EAAuB;AAC9D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB,qBAAqB,iBAAiB,KAAK,cAAc,4BAA4B,eAAe,KAAK,kBAAkB;;AAErK,uCAAuC,4EAAyB;AAChE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB,qBAAqB,cAAc,KAAK,iBAAiB,eAAe,kBAAkB,KAAK,eAAe;;AAExJ,uCAAuC,4EAAyB;AAChE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB,qBAAqB,cAAc,KAAK,iBAAiB,eAAe,eAAe,KAAK,kBAAkB;;AAExJ,uCAAuC,6EAA0B;AACjE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,OAAO;AACtB;AACA;AACA;AACA,wBAAwB,uEAAoB;AAC5C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA,uCAAuC,0EAAuB;AAC9D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB,4CAA4C,UAAU,KAAK,aAAa;;AAElH,wBAAwB,oEAAiB;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC,eAAe,aAAa;AAC5B,eAAe,aAAa;AAC5B;AACA;AACA;AACA,QAAQ,kDAAK;AACb,QAAQ,kDAAK;AACb;AACA,gCAAgC,yDAAW;AAC3C;;AAEA,mBAAmB,iBAAiB;AACpC;;AAEA,mBAAmB,iBAAiB;AACpC;;AAEA,mBAAmB,aAAa;AAChC;;AAEA,mBAAmB,aAAa;AAChC;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,oBAAoB,gFAAwB;AAC5C,wBAAwB,qEAAkB;AAC1C;AACA;AACA,4BAA4B,gFAAwB;AACpD,4BAA4B,gFAAwB;AACpD,4BAA4B,gFAAwB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC,eAAe,aAAa;AAC5B,eAAe,aAAa;AAC5B,eAAe,aAAa;AAC5B,eAAe,iBAAiB;AAChC;AACA;AACA;AACA,QAAQ,kDAAK;AACb,QAAQ,kDAAK;AACb,QAAQ,kDAAK;AACb,QAAQ,kDAAK;AACb;;AAEA,mBAAmB,iBAAiB;AACpC;;AAEA,mBAAmB,iBAAiB;AACpC;;AAEA,mBAAmB,aAAa;AAChC;;AAEA,mBAAmB,aAAa;AAChC;;AAEA,mBAAmB,aAAa;AAChC;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gFAAwB;AAChD,4BAA4B,wEAAqB;AACjD;AACA;AACA,gCAAgC,gFAAwB;AACxD,gCAAgC,gFAAwB;AACxD,gCAAgC,gFAAwB;AACxD,gCAAgC,gFAAwB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC,eAAe,aAAa;AAC5B,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA,QAAQ,kDAAK;AACb,QAAQ,kDAAK;;AAEb,mBAAmB,iBAAiB;AACpC;;AAEA,mBAAmB,iBAAiB;AACpC;;AAEA,mBAAmB,YAAY;AAC/B;;AAEA,mBAAmB,aAAa;AAChC;;AAEA,mBAAmB,aAAa;AAChC;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,2BAA2B,gFAAwB;AACnD,wBAAwB,sEAAmB;AAC3C;AACA;AACA,4BAA4B,gFAAwB;AACpD,4BAA4B,gFAAwB;AACpD,4BAA4B,gFAAwB;AACpD;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC;AACA;AACA;AACA,QAAQ,kDAAK;AACb,QAAQ,kDAAK;AACb,uCAAuC,8EAA2B;AAClE;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC;AACA;AACA;AACA,QAAQ,kDAAK;AACb,QAAQ,kDAAK;AACb,uCAAuC,+EAA4B;AACnE;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC;AACA;AACA;AACA,QAAQ,kDAAK;AACb,QAAQ,kDAAK;AACb,4BAA4B,iFAA8B;AAC1D;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC;AACA;AACA;AACA,QAAQ,kDAAK;AACb,QAAQ,kDAAK;AACb,4BAA4B,6EAA0B;AACtD;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC;AACA;AACA;AACA,QAAQ,kDAAK;AACb,QAAQ,kDAAK;AACb,4BAA4B,+EAA4B;AACxD;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,uBAAuB;AACtC;AACA;AACA;AACA,QAAQ,kDAAK;AACb,QAAQ,kDAAK;AACb,QAAQ,kDAAK;AACb,QAAQ,kDAAK;AACb,QAAQ,kDAAK;AACb,QAAQ,kDAAK;;AAEb,6CAA6C,mFAAgC;AAC7E;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB,4CAA4C,aAAa,KAAK,gBAAgB;AACxH;AACA,sBAAsB,kEAAoB,eAAe,aAAa,kCAAkC,aAAa,KAAK,gBAAgB;;AAE1I,oCAAoC,yEAAsB;AAC1D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB,eAAe,WAAW,KAAK,eAAe,uBAAuB,WAAW,KAAK,cAAc;;AAE7I,yBAAyB,kFAA+B;AACxD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,kEAAoB,mDAAmD,EAAE,KAAK,EAAE;AACtG;AACA,sBAAsB,kEAAoB,eAAe,EAAE,kCAAkC,aAAa,KAAK,gBAAgB;;AAE/H,oCAAoC,yEAAsB;AAC1D;AACA,C;;;;;;;;;;;;ACpuEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwC;AACK;AACH;;AAE1C;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,eAAe;AAClC;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B,wBAAwB;;AAExB,mBAAmB,OAAO;AAC1B,4BAA4B;;AAE5B,mBAAmB,OAAO;AAC1B,wBAAwB;;AAExB,mBAAmB,SAAS;AAC5B,mDAAmD;;AAEnD,mBAAmB,SAAS;AAC5B,sDAAsD;;AAEtD,mBAAmB,SAAS;AAC5B,qDAAqD;;AAErD,mBAAmB,SAAS;AAC5B,yDAAyD;;AAEzD,mBAAmB,SAAS;AAC5B,qDAAqD;;AAErD,mBAAmB,OAAO;AAC1B;AACA;;AAEA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,QAAQ,kDAAK;AACb;;AAEA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA,0FAA0F;AAC1F,QAAQ,kDAAK;;AAEb,sBAAsB,OAAO;AAC7B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kDAAK;AACrB;AACA;AACA;AACA,C;;;;;;;;;;;;AC5IA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwC;AACc;AACK;;AAE3D;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,aAAa;AAChC;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,aAAa;AAC5B,eAAe,eAAe;AAC9B,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA,mBAAmB,mEAAa;AAChC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,6CAA6C,QAAQ;AACrD;;AAEA;AACA;AACA;AACA,iDAAiD,QAAQ;AACzD;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA,C;;;;;;;;;;;;AC7HA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiF;AACvC;AACiB;AACnB;AACK;AACE;AACmB;AACzB;;AAEzC;AACA,eAAe,2DAAY;;AAE3B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,iEAAiE,OAAO;;AAExE,mBAAmB,YAAY;AAC/B;;AAEA,mBAAmB,sBAAsB;AACzC,2BAA2B,8EAAqB;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,aAAa;AAC5B,eAAe,QAAQ;AACvB,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,aAAa;AAC5B,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,mEAAa;;AAEhC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,QAAQ;AACzD;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,aAAa;AAC5B,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,mEAAa;;AAEhC;AACA;;AAEA;AACA,QAAQ,qDAAM;AACd;AACA;AACA;AACA;AACA,eAAe,mEAAa;AAC5B;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB,wCAAwC,oBAAoB,YAAY,WAAW;AAC9H;AACA,sBAAsB,mEAAqB,yBAAyB,UAAU,KAAK,aAAa,aAAa,mBAAmB,KAAK,sBAAsB;AAC3J;;AAEA;AACA;AACA,eAAe,eAAe;AAC9B,iBAAiB;AACjB;AACA;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,gBAAgB;AAChB;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB;AACA;AACA;AACA,iCAAiC,gBAAgB;AACjD;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA,kCAAkC,yDAAW;AAC7C;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA,QAAQ,kDAAK;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,YAAY;AAC3B;AACA;AACA;AACA,QAAQ,kDAAK;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,YAAY;AAC3B;AACA;AACA;AACA,QAAQ,kDAAK;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,YAAY;AAC3B;AACA;AACA;AACA,QAAQ,kDAAK;AACb;AACA,uDAAuD;;AAEvD,6BAA6B,yDAAW;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB;AACA;AACA;AACA,kCAAkC,kBAAkB;AACpD;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,YAAY;AAC3B;AACA;AACA;AACA,QAAQ,kDAAK;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,YAAY;AAC3B;AACA;AACA;AACA,QAAQ,kDAAK;AACb,mCAAmC,yDAAW;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,YAAY;AAC3B;AACA;AACA;AACA,QAAQ,kDAAK;AACb,mCAAmC,yDAAW;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,YAAY;AAC3B;AACA;AACA;AACA,QAAQ,kDAAK;AACb,oCAAoC,yDAAW;AAC/C;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB;AACA;AACA;AACA,oBAAoB,6CAA6C;AACjE;AACA,sBAAsB,kEAAoB,oCAAoC,KAAK;;AAEnF;AACA;AACA,2BAA2B,yDAAW,qCAAqC,UAAU;AACrF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,YAAY;AAC3B;AACA;AACA;AACA,QAAQ,kDAAK;AACb,2BAA2B,yDAAW,kDAAkD,uBAAuB;AAC/G;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA,QAAQ,kDAAK;AACb,gCAAgC,yDAAW;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,YAAY;AAC3B;AACA;AACA;AACA,QAAQ,kDAAK;AACb,gCAAgC,yDAAW;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB;AACA,8FAA8F;AAC9F;AACA;AACA;AACA,6EAA6E,YAAY,KAAK;AAC9F,SAAS;AACT;;AAEA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,OAAO;AAC7B,gBAAgB;AAChB;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,QAAQ,kDAAK;AACb;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,oCAAoC;AACnD;AACA;AACA;AACA;AACA,QAAQ,kDAAK;AACb,QAAQ,kDAAK;AACb;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,OAAO;AACpE;AACA;AACA,uEAAuE,QAAQ;AAC/E;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B,eAAe,oCAAoC;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,YAAY;AAC3B;AACA;AACA;AACA,QAAQ,kDAAK;AACb,yCAAyC,yDAAW;AACpD;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,YAAY;AAC3B;AACA;AACA;AACA,QAAQ,kDAAK;AACb,0CAA0C,yDAAW;AACrD;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,YAAY;AAC3B;AACA;AACA;AACA,QAAQ,kDAAK;AACb;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,YAAY;AAC3B;AACA;AACA;AACA,QAAQ,kDAAK;AACb;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,YAAY;AAC3B;AACA;AACA;AACA,QAAQ,kDAAK;AACb;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,QAAQ,kDAAK;AACb,QAAQ,kDAAK;AACb,0CAA0C,yDAAW;AACrD;AACA,SAAS;AACT;AACA,C;;;;;;;;;;;;AChzBA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkE;;AAElE;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,8EAAqB;AACpC;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,QAAQ,8EAAqB;AAC7B;AACA,C;;;;;;;;;;;;ACxDA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0D;AACf;;AAE3C;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,eAAe;AAC9B;AACA,uCAAuC,uDAAU;AACjD;AACA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,eAAe;AAClC;;AAEA;AACA,YAAY,uDAAU;AACtB,sBAAsB,kEAAoB,+BAA+B,WAAW;AACpF;AACA,sBAAsB,kEAAoB,yBAAyB,UAAU,KAAK,aAAa;;AAE/F;AACA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mCAAmC,UAAU,QAAQ,aAAa,UAAU,WAAW;AACvF;AACA,C;;;;;;;;;;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,eAAe;AAC9B,eAAe,MAAM;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qDAAqD,MAAM;;AAE3D;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,SAAS;AACT;;AAEA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,mC;;;;;;;;;;;;ACtGlB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyC;AACyB;AACP;AACA;;AAE3D;AACA,kCAAkC;AAClC,kBAAkB;;AAElB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,qBAAqB;AACxC;;AAEA,mBAAmB,OAAO;AAC1B;AACA;;AAEA;AACA;AACA,eAAe,sBAAsB;AACrC,eAAe,YAAY;AAC3B,eAAe,cAAc;AAC7B,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA,mBAAmB,mEAAa;;AAEhC;AACA;AACA;AACA;AACA,qBAAqB;;AAErB,mBAAmB,mEAAa;AAChC;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sCAAsC,qDAAM,gBAAgB;AAC5D,kEAAkE;AAClE,uCAAuC,iCAAiC;AACxE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB,kBAAkB,WAAW;AACxE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA,WAAW,wDAAwD;;AAEnE;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA,C;;;;;;;;;;;;AChIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoG;AACzD;AACE;AACE;AACmB;AACT;AACE;;;;AAI3D;AACA,8BAA8B,8EAAqB;;;;AAInD;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,aAAa;AAC5B;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,aAAa;AAChC,qCAAqC,2DAAY;;AAEjD,mBAAmB,mBAAmB;AACtC;;AAEA;AACA;AACA,sBAAsB,kEAAoB,6BAA6B,UAAU,qBAAqB,YAAY;AAClH;AACA,sBAAsB,kEAAoB,kDAAkD,yBAAyB,UAAU,cAAc;AAC7I;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wBAAwB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,UAAU;AAChC,0BAA0B,UAAU;AACpC;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,UAAU;AAChC;AACA,0BAA0B,aAAa;AACvC;AACA;;AAEA;AACA;AACA,6CAA6C,KAAK,SAAS,QAAQ,WAAW,WAAW,aAAa,IAAI;AAC1G;AACA,SAAS;AACT;;;;;;AAMA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,kEAAoB,kDAAkD,SAAS,GAAG,QAAQ,IAAI,YAAY,GAAG,WAAW;AAC9I;AACA,sBAAsB,kEAAoB,4CAA4C,SAAS,GAAG,QAAQ,IAAI,YAAY,GAAG,WAAW,OAAO,KAAK,KAAK,QAAQ;;AAEjK;AACA;AACA;AACA,6BAA6B,yDAAW;;AAExC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yDAAW;;AAErC;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,oCAAoC,UAAU,SAAS,aAAa,WAAW,WAAW;AAC1F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kDAAkD,qEAAkB;AACpE;AACA;AACA,C;;;;;;;;;;;;AC5SA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AACgB;AACO;AACJ;AACA;AACC;AACA;AACJ;;AAEzE;AACA;AACA;AACO,0CAA0C,iEAAe;AAChE;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,oFAA2B;AAC9C;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,2FAA8B;AACjD;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,uFAA4B;AAC/C;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,uFAA4B;AAC/C;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,wFAA6B;AAChD;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,wFAA6B;AAChD;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,oFAA2B;AAC9C;AACA,C;;;;;;;;;;;;ACxGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AACc;AACJ;AACc;AACV;AACE;;AAEzE;AACA;AACA;AACO,yCAAyC,iEAAe;AAC/D;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,kFAA6B;AAChD;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,8EAA2B;AAC9C;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,4FAAkC;AACrD;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,kFAA6B;AAChD;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,oFAA8B;AACjD;AACA,C;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AACoB;AACJ;AACM;AACF;AACF;AACgB;AACI;AACF;AACR;;AAErF;AACA;AACA;AACA,oDAAoD,iEAAe;AACnE;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,sGAAsC;AACzD;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,0GAAwC;AAC3D;AACA;;AAEA;AACA;AACA;AACA,sDAAsD,iEAAe;AACrE;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,wGAAuC;AAC1D;AACA;;AAEA;AACA;AACA;AACA,mDAAmD,iEAAe;AAClE;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,gGAAmC;AACtD;AACA;;AAEA;AACA;AACA;AACO,4CAA4C,iEAAe;AAClE;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,wFAAgC;AACnD;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,oFAA8B;AACjD;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,0FAAiC;AACpD;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,wFAAgC;AACnD;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,sFAA+B;AAClD;AACA,C;;;;;;;;;;;;AC3KA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AACgC;AACnB;;AAEtE;AACA;AACA;AACO,6CAA6C,iEAAe;AACnE;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,iFAAwB;AAC3C;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,oGAAiC;AACpD;AACA,C;;;;;;;;;;;;ACjDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AAC0C;AAChC;AACZ;AACQ;AACb;AACF;AACM;AAC6B;AAClB;AACX;AACK;AACuC;;AAElG;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO,4CAA4C,iEAAkB;AACrE;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,YAAY,uEAAS,WAAW,2EAAyB;AACzD,YAAY,wEAAU,WAAW,2EAAyB;AAC1D;;;AAGA,mBAAmB,iBAAiB;AACpC,uBAAuB,4EAAgB,2CAA2C;AAClF;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA,sBAAsB,+DAAiB;AACvC;AACA,sBAAsB,+DAAiB;;AAEvC;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA,C;;;;;;;;;;;;AC3GA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AAC0C;AAChC;AACZ;AACQ;AACb;AACK;AACP;AACM;AACkD;AACvC;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,4DAAa;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO,6CAA6C,iEAAkB;AACtE;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,YAAY,uEAAS,WAAW,2EAAyB;AACzD,YAAY,wEAAU,WAAW,2EAAyB;AAC1D;;AAEA,mBAAmB,WAAW;AAC9B,+BAA+B,uDAAU;;AAEzC,mBAAmB,cAAc;AACjC;;AAEA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA,QAAQ,kDAAK,8BAA8B,uDAAU;;AAErD;AACA;AACA,sBAAsB,+DAAiB,6BAA6B,GAAG,GAAG,GAAG;;AAE7E;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA,QAAQ,kDAAK,yBAAyB,4DAAa;AACnD,QAAQ,kDAAK;;AAEb;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kDAAK;;AAElC;AACA;AACA;AACA,6BAA6B,kDAAK;AAClC;AACA,C;;;;;;;;;;;;ACjMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AAC0C;AAChC;AACZ;AACQ;AACf;AACM;AACW;;AAEjE;AACA;AACA;AACO,0CAA0C,iEAAkB;AACnE;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,YAAY,uEAAS,WAAW,2EAAyB;AACzD,YAAY,wEAAU,WAAW,2EAAyB;AAC1D;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;;AAEA;AACA;AACA;;AAEA,4CAA4C,wDAAW;AACvD;AACA,C;;;;;;;;;;;;AChEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AAC0C;AAChC;AACZ;AACQ;AACb;AACF;AACM;AAC4B;AACjB;;AAEjE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO,2CAA2C,iEAAkB;AACpE;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,YAAY,uEAAS,WAAW,2EAAyB;AACzD,sCAAsC,wDAAW;AACjD;AACA,YAAY,wEAAU,WAAW,2EAAyB;AAC1D;;AAEA,mBAAmB,WAAW;AAC9B,+BAA+B,uDAAU;AACzC;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA,QAAQ,kDAAK,8BAA8B,uDAAU;;AAErD;AACA;AACA,sBAAsB,+DAAiB;AACvC;AACA,sBAAsB,+DAAiB;;AAEvC;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,C;;;;;;;;;;;;AC1GA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AAC0C;AAChC;AACZ;AACQ;AACf;AACgB;AACwB;AACvB;;AAEjE;AACA,aAAa,sBAAsB;AACnC;;AAEA;AACA;AACA;AACO,4CAA4C,iEAAkB;AACrE;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,YAAY,uEAAS,WAAW,2EAAyB;AACzD,sCAAsC,wDAAW,wBAAwB,wDAAW;AACpF;AACA,YAAY,wEAAU,WAAW,2EAAyB;AAC1D;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,wBAAwB;AAC3C;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,wBAAwB;AACvC;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB,uDAAuD,QAAQ;;AAEzG;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,wDAAW;AACjC;AACA;AACA;AACA;AACA,2BAA2B,wDAAW;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;AC3MA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AAC0C;AAChC;AACZ;AACQ;AACf;AACwC;AACvB;;AAEjE;AACA;AACA;AACO,0CAA0C,iEAAkB;AACnE;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,YAAY,uEAAS,WAAW,2EAAyB;AACzD,sCAAsC,wDAAW;AACjD;AACA,YAAY,wEAAU,WAAW,2EAAyB;AAC1D;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oDAAoD,2DAAc;;AAElE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,eAAe,eAAe;AAC9B,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,kDAAK,QAAQ,6DAAgB;;AAErC;AACA;;AAEA,4DAA4D,2DAAc,MAAM,6DAAgB;AAChG,sBAAsB,mBAAmB;AACzC;;AAEA;AACA;AACA,C;;;;;;;;;;;;AC7IA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AAC0C;AAChC;AACZ;AACQ;AACb;AACF;AACM;AAC4B;AACjB;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO,2CAA2C,iEAAkB;AACpE;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,YAAY,uEAAS,WAAW,2EAAyB;AACzD,YAAY,wEAAU,WAAW,2EAAyB;AAC1D;;AAEA,mBAAmB,WAAW;AAC9B,+BAA+B,uDAAU;;AAEzC,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA,QAAQ,kDAAK,8BAA8B,uDAAU;;AAErD;AACA;AACA,sBAAsB,+DAAiB,6BAA6B,GAAG,GAAG,GAAG;;AAE7E;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,C;;;;;;;;;;;;AC/IA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AAC0C;AAChC;AACb;AACC;AACQ;AACf;AACa;AACI;;;;AAIjE;AACA;AACA;AACA;AACO,4CAA4C,iEAAkB;AACrE;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,YAAY,uEAAS,WAAW,2EAAyB;AACzD,YAAY,wEAAU,WAAW,2EAAyB;AAC1D;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,YAAY;AAC/B,+BAA+B,wDAAW;AAC1C;;AAEA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,+DAAiB;;AAEvC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;ACzGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEmF;AACgB;AAChC;AACZ;AACQ;AACX;AACJ;AACgB;AACC;;AAEjE;AACA,aAAa,IAAI;AACjB;;AAEA,WAAW,SAAS;AACpB;;AAEA;AACA;AACA;AACO,iDAAiD,iEAAkB;AAC1E;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,2CAA2C,uEAAS,mBAAmB,2EAAyB;AAChG,YAAY,wEAAU,WAAW,2EAAyB;AAC1D;;AAEA,mBAAmB,2BAA2B;AAC9C;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,2BAA2B;AAC1C;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB,kBAAkB,KAAK;;AAEjE;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,C;;;;;;;;;;;;AC1FA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AAC0C;AAChC;AACZ;AACQ;AACf;AACe;AACT;AACW;;AAEjE;AACA,mBAAmB,iEAAkB;AACrC;;AAEA;AACA;AACA;AACO,6CAA6C,iEAAkB;AACtE;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,YAAY,uEAAS,WAAW,2EAAyB;AACzD,YAAY,wEAAU,WAAW,2EAAyB;AAC1D;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sBAAsB,kBAAkB;AACxC;AACA;;AAEA;AACA;AACA,0BAA0B,mBAAmB;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;ACpGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiF;AACkB;AAChC;AACZ;AACQ;AACX;AACa;AACjB;AACM;AACW;;AAEjE;AACA;AACA;AACO,0CAA0C,qEAAsB;AACvE;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,YAAY,uEAAS,WAAW,2EAAyB;AACzD;;AAEA,mBAAmB,YAAY;AAC/B;;AAEA,mBAAmB,YAAY;AAC/B,uBAAuB,wDAAW;AAClC;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,QAAQ,kDAAK;;AAEb,eAAe,sEAAiB;AAChC,gBAAgB,yDAAW,UAAU,6BAA6B;AAClE;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,gBAAgB;;AAE/B,mBAAmB,mEAAa;AAChC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,C;;;;;;;;;;;;ACrFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEmF;AACgB;AAChC;AACZ;AACQ;AACX;AACJ;AACM;AACW;AACA;;AAEjE;AACA;AACA;AACO,4CAA4C,uEAAwB;AAC3E;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,YAAY,wEAAU,WAAW,2EAAyB;AAC1D;;AAEA,mBAAmB,YAAY;AAC/B;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA,QAAQ,kDAAK,yBAAyB,yDAAW;AACjD;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA,kDAAkD,wDAAW;AAC7D;AACA,C;;;;;;;;;;;;ACjFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AACiB;AAC6B;AACpC;AACZ;AACQ;AACf;AACiB;;;;AAIjE;AACA;AACA;AACA;AACO,+CAA+C,iEAAkB;AACxE;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,YAAY,uEAAS,WAAW,2EAAyB;AACzD,YAAY,wEAAU,WAAW,2EAAyB;AAC1D;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,6DAA6D;AAC5E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;AC9GA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiF;AACP;AACyB;AAChC;AACZ;AACqB;AACb;AACf;AACiB;AACA;AACA;;;AAGjE;AACA;AACA,iBAAiB,mEAAoB;;;;AAIrC;AACA;AACA;AACO,gDAAgD,iEAAkB;AACzE;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,YAAY,uEAAS,WAAW,2EAAyB;AACzD;AACA;AACA,YAAY,wEAAU,WAAW,2EAAyB;AAC1D;;AAEA,mBAAmB,OAAO;AAC1B;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,6DAA6D;AAC5E;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,sFAAkC;AAC3D;;AAEA;AACA,wCAAwC;AACxC,0DAA0D;AAC1D,oDAAoD;AACpD;;AAEA;AACA;AACA,iCAAiC,sFAAkC;;AAEnE;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,gBAAgB;AACtC,qCAAqC;AACrC,4CAA4C;AAC5C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;AC7IA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4D;AACc;AAChB;AAC+B;AACd;AACxB;;AAEnD;AACA;AACA;AACA;AACO,mDAAmD,iEAAkB;AAC5E;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,4BAA4B;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,cAAc;AAC7B,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA,QAAQ,kDAAK;AACb,QAAQ,kDAAK;;AAEb;AACA,qCAAqC,sFAAkC;AACvE;AACA,oCAAoC,sFAAkC;;AAEtE;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACvEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4D;AAC8E;AACpE;AACZ;AAC+B;AAChC;AACN;AACiB;AACO;AACP;;AAEpE;AACA,2BAA2B;;AAE3B;AACA;AACA;AACO,sDAAsD,gFAAoC;AACjG;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,YAAY,uEAAS,kBAAkB,2EAAyB;AAChE,sCAAsC,wDAAW;AACjD;AACA,YAAY,uEAAS,sBAAsB,2EAAyB;AACpE;AACA;AACA,YAAY,wEAAU,WAAW,2EAAyB;AAC1D;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,6DAA6D;AAC5E;AACA;AACA;;AAEA;AACA,yBAAyB,sFAAkC;AAC3D,qFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AC3FA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4D;AAC8C;AAChC;AAChB;AAC+B;AACtC;AACiB;AACuC;;AAE3G;AACA,yBAAyB;AACzB,kCAAkC;AAClC,qBAAqB,mEAAoB,CAAC;AAC1C,8BAA8B;AAC9B,gDAAgD;;AAEhD;AACA;AACA;AACA;AACO,iDAAiD,iEAAkB;AAC1E;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,4BAA4B;AAC3C;AACA;AACA;AACA;;AAEA,mBAAmB,OAAO;AAC1B,0CAA0C;AAC1C;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,eAAe,sBAAsB;AACrC,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,6BAA6B;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,oBAAoB;AAC/C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,sBAAsB;AACrC,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA,6CAA6C,gEAAiB;AAC9D;;AAEA,wBAAwB,iEAAkB;AAC1C;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA,6CAA6C,gEAAiB;AAC9D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,4BAA4B;AAC3C;AACA;AACA;AACA;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC/OA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0E;AACgC;AACpC;AACZ;AACQ;AACT;AACN;AACiB;AACA;AACiB;;AAErF;AACA;;;;AAIA;AACA;AACA;AACO,qDAAqD,sFAA4C;AACxG;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,YAAY,uEAAS,WAAW,2EAAyB;AACzD,sCAAsC,wDAAW;AACjD;AACA,YAAY,wEAAU,WAAW,2EAAyB;AAC1D;;AAEA,mBAAmB,OAAO;AAC1B;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,mEAAqB,0BAA0B,cAAc;;AAEnF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B,iEAAkB;AAC9C,iCAAiC,qBAAqB,iEAAkB,CAAC;AACzE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;AClIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0E;AACgC;AACpC;AACZ;AACQ;AACT;AACJ;AACF;AACuC;AACtB;AACF;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACO,uDAAuD,sFAA4C;AAC1G;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,YAAY,uEAAS,WAAW,2EAAyB;AACzD,sCAAsC,wDAAW;AACjD;AACA,YAAY,wEAAU,WAAW,2EAAyB;AAC1D;;AAEA,mBAAmB,WAAW;AAC9B,+BAA+B,uDAAU;;AAEzC,mBAAmB,OAAO;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB,oBAAoB,WAAW;;AAEzE;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,mEAAqB,0BAA0B,cAAc;;AAEnF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC,qBAAqB,kEAAkB,CAAC;AACzE;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;ACnLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AACiB;AAC6B;AACpC;AACZ;AACqB;AACb;AACf;AACiB;AACA;AACA;;;AAGjE;AACA;;;;AAIA;AACA;AACA;AACO,8CAA8C,iEAAkB;AACvE;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,YAAY,uEAAS,gBAAgB,2EAAyB;AAC9D,YAAY,uEAAS,gBAAgB,2EAAyB;AAC9D,YAAY,wEAAU,WAAW,2EAAyB;AAC1D;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C;AACA,qBAAqB,sFAAkC;AACvD,qBAAqB,sFAAkC;AACvD;;AAEA;AACA,8BAA8B,sFAAkC;;AAEhE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC;AACxC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,gBAAgB;AACtC,qCAAqC;AACrC,4CAA4C;AAC5C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;ACxHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiF;AACkB;AAChC;AACZ;AACqB;AACb;AACX;AACJ;AACM;AACW;AACA;AACP;AAMvB;;;;AAInC;AACA;AACA;AACO,6CAA6C,qEAAsB;AAC1E;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,YAAY,uEAAS,WAAW,2EAAyB;AACzD;;AAEA,mBAAmB,iBAAiB;AACpC;;AAEA,mBAAmB,oBAAoB;AACvC,kCAAkC,8EAAmB;AACrD;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,oEAAa;AAC5B;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,6DAA6D;AAC5E,2CAA2C;;AAE3C;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA,6CAA6C,iEAAiB;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sBAAsB,UAAU;AAChC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,8DAAc;AAC/B,iBAAiB,8DAAc;;AAE/B;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,sEAAsB,IAAI,sEAAsB,GAAG,kEAAkB;;AAEtF;AACA,mCAAmC,4DAAY;AAC/C;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA,oBAAoB,gEAAc;AAClC;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;ACtKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEmF;AACT;AACyB;AAC3C;AACD;AACQ;AACf;AACgB;AACC;AACP;;AAE1D;AACA,4BAA4B;AAC5B,yBAAyB;AACzB,uDAAuD;;AAEvD;AACA;AACA;AACO,+CAA+C,uEAAwB;AAC9E;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,YAAY,wEAAU,WAAW,2EAAyB;AAC1D;;AAEA,mBAAmB,iBAAiB;AACpC;;AAEA,mBAAmB,aAAa;AAChC;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA,QAAQ,kDAAK;AACb;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,sFAAkC;;AAEhE;;AAEA;AACA;AACA,sBAAsB,eAAe;AACrC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA,QAAQ,kDAAK;;AAEb;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,iBAAiB;AAChC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA,sBAAsB,OAAO;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;AC5JA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4D;AACe;AAC+B;AACpC;AACZ;AACQ;AACT;AACJ;AACF;AACoC;AACnB;AACiB;;AAErF;AACA,gCAAgC,uDAAU;AAC1C,kCAAkC,kEAAkB;AACpD;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACO,kDAAkD,iEAAkB;AAC3E;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,YAAY,uEAAS,0BAA0B,2EAAyB;AACxE,sCAAsC,wDAAW;AACjD;AACA,YAAY,uEAAS,sBAAsB,2EAAyB;AACpE,sCAAsC,wDAAW;AACjD;AACA,YAAY,uEAAS,8BAA8B,2EAAyB;AAC5E,YAAY,wEAAU,WAAW,2EAAyB;AAC1D;;AAEA,mBAAmB,WAAW;AAC9B;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA,QAAQ,kDAAK;AACb,QAAQ,kDAAK;AACb;;AAEA;AACA;AACA,sBAAsB,+DAAiB,eAAe,iBAAiB;AACvE;AACA,sBAAsB,+DAAiB,eAAe,iBAAiB;AACvE;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA,QAAQ,kDAAK,iCAAiC,kEAAkB;AAChE;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA,QAAQ,kDAAK;AACb;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA,QAAQ,kDAAK;AACb;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA,QAAQ,kDAAK;AACb;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,6DAA6D;AAC5E;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sFAAkC;AAC/D;AACA;;AAEA;AACA;AACA,iCAAiC,UAAU;AAC3C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;ACjPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AAC0C;AAChC;AACZ;AACQ;AACf;AACwC;AACvB;AACD;AACV;AACK;AACuC;;AAElG;AACA;;AAEA;AACA;AACA;AACO,gDAAgD,iEAAkB;AACzE;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,YAAY,uEAAS,WAAW,2EAAyB;AACzD,YAAY,wEAAU,WAAW,2EAAyB;AAC1D;;AAEA,mBAAmB,iBAAiB;AACpC,0BAA0B,4EAAgB,2CAA2C;AACrF;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB,qCAAqC,UAAU;;AAEzF;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yCAAyC;AACzC,yCAAyC;AACzC,yCAAyC;;AAEzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;ACrJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AAC0C;AAChC;AACZ;AACQ;AACf;AACgB;AACV;AACJ;AACK;AACU;;AAEjE;AACA,aAAa,qBAAqB;AAClC;;AAEA;AACA;AACA;AACO,uCAAuC,iEAAkB;AAChE;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,YAAY,uEAAS,WAAW,2EAAyB;AACzD,YAAY,wEAAU,WAAW,2EAAyB;AAC1D;;AAEA,mBAAmB,WAAW;AAC9B,yBAAyB,uDAAU;;AAEnC,mBAAmB,cAAc;AACjC,0BAA0B,4DAAa;;AAEvC,mBAAmB,0BAA0B;AAC7C;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB,4BAA4B,OAAO;;AAE7E;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,C;;;;;;;;;;;;ACnJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0C;AACM;AACS;AACA;;AAEzD;AACA;AACA,UAAU;AACV;AACO;AACP;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,0BAA0B;AACzC;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,0BAA0B;AACzC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,KAAK;AACvC;;AAEA;AACA;AACA,gBAAgB,OAAO;AACvB,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA,eAAe,0BAA0B;AACzC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,cAAc;AACjC;;AAEA,mBAAmB,YAAY;AAC/B,uBAAuB,wDAAW;AAClC;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,YAAY;AAC3B,iBAAiB,sBAAsB;AACvC;AACA,wBAAwB,wDAAW;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,sBAAsB;AACzC;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;AACA;;AAEA;AACA;AACA,eAAe,sBAAsB;AACrC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,kDAAK;AACb,QAAQ,kDAAK;AACb,QAAQ,kDAAK;;AAEb;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,WAAW,0BAA0B;AACrC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACrUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0C;AACiB;AACoB;AACyB;AACrC;AACF;AAChB;;AAEjD;AACA;AACA,aAAa,mCAAmC;AAChD,aAAa,wCAAwC;AACrD,aAAa,yCAAyC;AACtD;;AAEA;AACA;AACA,WAAW,qBAAqB;AAChC,aAAa;AACb;AACA;AACA;AACA,wDAAwD,oBAAoB;;AAE5E;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,4BAA4B;AAC3C;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,sCAAsC;;AAEtC,mBAAmB,OAAO;AAC1B;;;;AAIA;AACA;;AAEA,mBAAmB,oBAAoB;AACvC;;AAEA,mBAAmB,qBAAqB;AACxC;;;;AAIA;;AAEA,mBAAmB,wBAAwB;AAC3C;;AAEA,mBAAmB,wBAAwB;AAC3C;;;;AAIA;AACA;AACA,sBAAsB,kEAAoB,kBAAkB,WAAW,aAAa,cAAc;;AAElG;AACA;AACA,sBAAsB,kEAAoB,qCAAqC,cAAc;AAC7F;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,sBAAsB,GAAG,UAAU;AACrD;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA,qBAAqB,sEAAuB;AAC5C;AACA;AACA;;AAEA,kBAAkB,kEAAoB,0BAA0B,SAAS,WAAW,cAAc;AAClG;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA,sBAAsB,uEAAwB;AAC9C;AACA;AACA;;AAEA,kBAAkB,kEAAoB,2BAA2B,SAAS,WAAW,cAAc;AACnG;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,kDAAK,qGAAqG,SAAS,MAAM,cAAc;;AAEvJ;AACA;AACA;AACA;AACA,gBAAgB,kDAAK,qGAAqG,SAAS,MAAM,cAAc;AACvJ,SAAS;AACT;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA,sBAAsB,iCAAiC;AACvD;;AAEA;AACA,sBAAsB,sBAAsB;AAC5C;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;;AAEA;AACA,oDAAoD,QAAQ;AAC5D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iCAAiC;AACvD;;AAEA;AACA;AACA,sBAAsB,sBAAsB;AAC5C,iCAAiC;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,QAAQ,kDAAK;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,4BAA4B;AAC3C;AACA;AACA;AACA;AACA,QAAQ,kDAAK;AACb;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,4BAA4B;AAC3C;AACA;AACA;AACA;AACA,QAAQ,kDAAK;AACb;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;AACA,C;;;;;;;;;;;;ACvWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0C;AAC+E;AAC5D;AAC2D;AACnE;;AAErD;AACA;AACA;AACA;AACA,0BAA0B,kFAAgC;;AAE1D;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,uBAAuB;AACtC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,uBAAuB;AAC1C;;AAEA,mBAAmB,mBAAmB;AACtC;;AAEA,mBAAmB,sBAAsB;AACzC;;;AAGA;AACA,QAAQ,kDAAK,6DAA6D,WAAW;AACrF;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB,yBAAyB,UAAU;;AAE9E;AACA;;AAEA;AACA;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA,kBAAkB,+DAAiB,gBAAgB,QAAQ,WAAW,UAAU;AAChF;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,uBAAuB;AACtC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;;AAEA,mBAAmB,sBAAsB;AACzC;AACA;;AAEA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB,8BAA8B,UAAU,WAAW,UAAU;;AAEvG;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB,gBAAgB,QAAQ,WAAW,UAAU,IAAI,WAAW;;AAEtG;AACA;;AAEA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,kCAAkC,uEAAqB;;AAEvD;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,uBAAuB;AACtC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB,6BAA6B,UAAU,WAAW,UAAU;AACtG;AACA,sBAAsB,kEAAoB,wBAAwB,UAAU,OAAO,UAAU;;AAE7F;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,8CAA8C,UAAU,MAAM,SAAS;;AAEvE;AACA,sBAAsB,mEAAqB,oCAAoC,KAAK;;AAEpF;AACA;AACA,sBAAsB,kEAAoB,kBAAkB,QAAQ,WAAW,KAAK,IAAI,WAAW;;AAEnG;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC7TA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0C;AAC8D;AAC3C;AACyB;AACjC;;AAErD;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,0BAA0B;AAC7C,qBAAqB,2EAAyB;;AAE9C,mBAAmB,gCAAgC;AACnD;AACA;;AAEA;AACA;AACA,eAAe,0BAA0B;AACzC,iBAAiB,0BAA0B;AAC3C;AACA;AACA;AACA,QAAQ,kDAAK,sBAAsB,2EAAyB;AAC5D,QAAQ,kDAAK,gBAAgB,2EAAyB;;AAEtD;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,gCAAgC;AAC/C,iBAAiB,0BAA0B;AAC3C;AACA;AACA;AACA,QAAQ,kDAAK,sBAAsB,2EAAyB;AAC5D,QAAQ,kDAAK;AACb,QAAQ,kDAAK;;AAEb;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,mBAAmB;AAClC,iBAAiB;AACjB;AACA;AACA;AACA,yBAAyB,yEAAsB;AAC/C;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACO,8BAA8B,sEAAuB;AAC5D;AACA,yCAAyC,sEAAuB;AAChE;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACO,+BAA+B,uEAAwB;AAC9D;AACA,yCAAyC,uEAAwB;AACjE,C;;;;;;;;;;;;ACjHA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsF;AAC5C;;AAE1C;AACA;AACA,aAAa,yCAAyC;AACtD;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,0BAA0B;AACzC,eAAe,gCAAgC;AAC/C;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;;AAEA,mBAAmB,gCAAgC;AACnD;;;AAGA;AACA,QAAQ,kDAAK,qCAAqC,2EAAyB;AAC3E;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,sBAAsB;AACrC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC,2EAAyB;AAC1D,oBAAoB,2EAAyB;AAC7C;;AAEA,+BAA+B,KAAK,cAAc,qBAAqB;AACvE;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACnGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0C;AACiB;AACyC;AACG;AACC;AACvD;AACH;AACI;;AAElD;AACA,aAAa,8CAA8C;AAC3D;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;;AAEA,mBAAmB,qBAAqB;AACxC;;AAEA,mBAAmB,qBAAqB;AACxC;;AAEA,mBAAmB,UAAU;AAC7B;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAgB,sBAAsB;AACtC,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB;AAC3C;AACA,sBAAsB,kEAAoB;;AAE1C;AACA,wBAAwB,yDAAS;;AAEjC;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sBAAsB,2BAA2B;AACjD;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,oCAAoC;AACrD;AACA;AACA;AACA,QAAQ,kDAAK;;AAEb;AACA;AACA;AACA,uBAAuB,mEAAa;AACpC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAsB,2BAA2B;AACjD;;AAEA;AACA;;AAEA;AACA,YAAY,mEAAa;;AAEzB;AACA;AACA;AACA;AACA;AACA,kDAAkD,QAAQ;AAC1D;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,qBAAqB;AACpC,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,mBAAmB,mEAAa;;AAEhC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,qBAAqB;AACpC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kCAAkC,mEAAqB;AACvD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,qBAAqB;AACpC,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA,sBAAsB,kBAAkB;AACxC;;AAEA,sBAAsB,kBAAkB;AACxC;AACA;;AAEA,0BAA0B,mBAAmB;AAC7C;AACA;;AAEA;AACA,8BAA8B,mEAAqB,iDAAiD,cAAc;;AAElH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,qBAAqB;AACpC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB;AAC3C;AACA,sBAAsB,mEAAqB;AAC3C;AACA,sBAAsB,mEAAqB;AAC3C;AACA;;;;;;;;;;;;;AC9SA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsD;;AAEtD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACzFA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoF;AACnB;AAC1B;;AAEvC;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,iBAAiB;AAChC,iBAAiB;AACjB;AACA;AACA;AACA;AACA,QAAQ,kDAAK,sCAAsC,gGAAyB;;AAE5E;AACA;AACA,C;;;;;;;;;;;;ACrDA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqD;AACe;AACV;;AAE1D;AACA;AACA;AACA;AACO,6CAA6C,iEAAe;AACnE;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,gFAAsB,CAAC,sEAAW;AACrD;AACA,C;;;;;;;;;;;;ACvCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqD;AAMlB;AACkD;AAC/B;;;AAGtD;AACA;AACA;AACO,2CAA2C,iEAAe;AACjE;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,4EAAmB;AACtC;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,sFAA6B;AAChD;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,8EAAqB;AACxC;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,wFAA+B;AAClD;;AAEA;AACA;AACA,iBAAiB,gCAAgC;AACjD;AACA;AACA;AACA,oBAAoB,iGAA8B;AAClD,8BAA8B,wFAA+B;AAC7D,oCAAoC;AACpC;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;AACA,C;;;;;;;;;;;;AChGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsH;AAC/E;AACK;AACC;AACC;AACQ;AACT;AACuC;AACI;AACrB;AACe;AACM;AACpB;;;;AAIpE;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,0BAA0B;AACzC;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;;AAEA,mBAAmB,0BAA0B;AAC7C;;AAEA,mBAAmB,OAAO;AAC1B,8BAA8B;;AAE9B,mBAAmB,iBAAiB;AACpC;;AAEA,mBAAmB,SAAS;AAC5B;;AAEA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA,+BAA+B,+EAAiB;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wDAAW;AAC7C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB;;AAE1C;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,kBAAkB,uEAAY;;AAE9B;AACA;AACA,sBAAsB,+DAAiB,gDAAgD,EAAE;;AAEzF;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,kBAAkB,iFAAsB;;AAExC;AACA;AACA,sBAAsB,+DAAiB,2DAA2D,EAAE;;AAEpG;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2EAAc;AAChC;;AAEA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qFAAwB;AAC1C;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC7kBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqD;AACR;AACe;;AAE5D;AACA;AACA;AACO,0CAA0C,iEAAe;AAChE;AACA;AACA;AACA,eAAe,YAAY;AAC3B,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,wEAAgB;AACnC;AACA,C;;;;;;;;;;;;ACvCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkF;AACjB;AACE;AACtB;AACC;AACQ;AACN;AAC8B;AACvC;AAC4B;AACE;AACD;;AAEpE;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,yBAAyB;AACxC,eAAe,YAAY;AAC3B;AACA;AACA;AACA,mBAAmB,yBAAyB;AAC5C;;AAEA,mBAAmB,iBAAiB;AACpC;;AAEA,mBAAmB,YAAY;AAC/B;;AAEA,mBAAmB,cAAc;AACjC;;AAEA,mBAAmB,cAAc;AACjC;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,qBAAqB;AACpC,eAAe,eAAe;AAC9B,iBAAiB;AACjB;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,kEAAoB;;AAE1C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,6BAA6B;AACvD,kEAAkE,0DAAW;;AAE7E;AACA;;AAEA;AACA;;AAEA;AACA;AACA,4BAA4B,4DAAa;AACzC,4BAA4B,4DAAa;AACzC;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,UAAU;AACzB,eAAe,mBAAmB;AAClC,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C;AACA;AACA;AACA,sBAAsB,mEAAqB,kDAAkD,aAAa;;AAE1G;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA,8BAA8B,kFAA0B;AACxD;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC1QA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuD;AAChB;;AAEvC;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,WAAW;AAC1B,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,QAAQ,GAAG,QAAQ;AACtC;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,uCAAuC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACzKA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;;AAEP;AACA;;AAEA,CAAC,E;;;;;;;;;;;;AC1BD;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE8C;;AAE9C;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,WAAW;AAC1B,eAAe,WAAW;AAC1B;AACA;AACA;AACA,6BAA6B,0DAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,OAAO,GAAG,OAAO;AACpC;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC/IA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuC;AACiB;AACyD;AACvE;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gEAAgE;AACnF;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;AACA;;AAEA;AACA;AACA,eAAe,gEAAgE;AAC/E,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB,4BAA4B,cAAc;AACpF;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,mEAAa;AAChC,YAAY,kDAAK,oBAAoB,UAAU,sBAAsB,QAAQ;;AAE7E;AACA,2BAA2B,0DAAY,IAAI,UAAU,6BAA6B,QAAQ,aAAa,QAAQ;AAC/G,aAAa;;AAEb;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,eAAe,sDAAS;AACxB;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,iBAAiB;AAChC,iBAAiB;AACjB;AACA;AACA;AACA,wDAAwD;AACxD,mBAAmB,mEAAa;AAChC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,eAAe,sDAAS;AACxB;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,iBAAiB;AAChC,iBAAiB;AACjB;AACA;AACA;AACA,mCAAmC;AACnC,mBAAmB,mEAAa;AAChC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,eAAe,sDAAS;AACxB;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C,0BAA0B,kDAAK;AAC/B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,kBAAkB;AACjC,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,mEAAa;AAC5B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,eAAe,sDAAS;AACxB;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,mEAAa;AAC5B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,C;;;;;;;;;;;;ACxWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE8C;AACQ;AACC;AACuB;AACvC;AACmB;AACF;;AAExD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA,oCAAoC,gBAAgB,wDAAW;AAC/D;AACA,QAAQ,kDAAK;;AAEb,mBAAmB,kBAAkB;AACrC;;AAEA,mBAAmB,OAAO;AAC1B;AACA,yCAAyC,sDAAS;AAClD,SAAS;;AAET,mBAAmB,YAAY;AAC/B;;AAEA,mBAAmB,UAAU;AAC7B,oEAAoE,yDAAS;;AAE7E;AACA,gCAAgC,sDAAS;AACzC,YAAY,kDAAK;AACjB;;AAEA;AACA;AACA;AACA,eAAe,gEAAgE;AAC/E,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA,wCAAwC,EAAE;AAC1C;AACA,eAAe,sEAAiB;AAChC,YAAY,kDAAK;;AAEjB;AACA,YAAY,kDAAK,kCAAkC,YAAY;;AAE/D;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA,4DAA4D,EAAE,kBAAkB,EAAE;AAClF;AACA,eAAe,kDAAK;AACpB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,gEAAgE;AACjF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,iBAAiB,sDAAS;AAC1B;;AAEA,iBAAiB,sDAAS;AAC1B;;AAEA,iBAAiB,sDAAS;AAC1B;;AAEA,iBAAiB,sDAAS;AAC1B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,YAAY,kDAAK;AACjB;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,2BAA2B;AAC5C;AACA;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C;AACA;;AAEA;AACA,eAAe,mEAAa;AAC5B;;AAEA;AACA;AACA,eAAe,kBAAkB;AACjC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB;AAC3C;AACA,sBAAsB,mEAAqB;;AAE3C,mBAAmB,mEAAa;AAChC;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iCAAiC,EAAE;;AAEnC;AACA;AACA,YAAY,kDAAK,0DAA0D,cAAc;AACzF;AACA,YAAY,kDAAK;AACjB;;AAEA;AACA,sCAAsC;AACtC;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC3QA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqD;;AAErD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;AACA,C;;;;;;;;;;;;ACvCA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgD;;AAEhD;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,+BAA+B,kBAAkB,IAAI,kBAAkB;AACvE;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,4DAAa;AAChC;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACzFA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,6BAA6B,WAAW,IAAI,YAAY;AACxD;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC5EA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,gCAAgC,kBAAkB,IAAI,kBAAkB;AACxE;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC/IA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6C;AACK;AAC+B;AACF;AACM;AACxC;AACG;AACF;AACH;AACkC;AACrB;AACH;AAC2B;AACE;AACM;AACF;AAC/C;AACU;;AAEjD;AACA,8BAA8B,yFAAuB;;AAErD;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,oDAAoD;AACnE,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA,0CAA0C,EAAE;AAC5C;AACA,eAAe,yDAAW;AAC1B;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA,+DAA+D,mBAAmB;AAClF;AACA,eAAe,yDAAW;AAC1B;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,eAAe,WAAkB;AACjC;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,eAAe,6DAAU;AACzB;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,6FAA4B;AAC3C;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,2FAA2B;AAC1C;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,iGAA8B;AAC7C;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA,mBAAmB,4DAAa;AAChC;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA,mBAAmB,0DAAY;AAC/B;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA,mBAAmB,uDAAU;AAC7B;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,oEAAa;AAC5B;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,kEAAc;AACjC;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,6FAA0B;AACzC;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,+FAA2B;AAC1C;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,qGAA8B;AAC7C;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,mGAA6B;AAC5C;AACA;;AAEA;AACA,4CAA4C,yDAAW;;AAEvD;AACA,IAAI,6DAAa;AACjB,IAAI,mDAAK,yC;;;;;;;;;;;;ACxNT;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuC;AACiB;AAC+B;;;;AAIvF;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,qDAAO;AAC1B;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,UAAU;AACzB,eAAe,WAAW;AAC1B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kDAAK,gFAAgF;AACrG,gGAAgG;AAChG;AACA;AACA,+DAA+D;AAC/D,oBAAoB,kDAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET,mBAAmB,mEAAa;AAChC;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,gBAAgB;AAC/B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,sBAAsB,mEAAqB;AAC3C,SAAS;AACT;AACA,SAAS;AACT;AACA,C;;;;;;;;;;;;AC/HA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6D;AACR;;;;AAIrD;AACA;AACA;;AAEA;AACA,iBAAiB,wEAAY;;;;;AAK7B;AACA;AACA;AACA;AACO,wBAAwB,wEAAkB;AACjD;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACxDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6D;AACY;AACV;AACV;AACK;AACY;AAC7B;AACiB;AACoB;AACwB;;AAEtG;AACA,gCAAgC,gEAAiB,KAAK;AACtD,4BAA4B;AAC5B,wDAAwD;AACxD,yBAAyB;AACzB,kCAAkC;AAClC,8CAA8C;;;;;AAK9C;AACA;AACA;;AAEA;AACA,kCAAkC,wEAAY;AAC9C;AACA,+CAA+C,kDAAkD;;AAEjG;AACA,sCAAsC,wEAAY;AAClD;AACA,mDAAmD,kDAAkD;;AAErG;AACA,wBAAwB,wEAAY;AACpC;;AAEA;AACA,4BAA4B,wEAAY;;AAExC;AACA,+BAA+B,wEAAY;AAC3C;;AAEA;AACA,0BAA0B,wEAAY;AACtC;;AAEA;AACA,wBAAwB,wEAAY;AACpC;AACA;AACA;AACA,wBAAwB;;;;;AAKxB;AACA;AACA;AACA;AACO,0BAA0B,wEAAkB;AACnD;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA,+CAA+C,qEAAsB,EAAE,qEAAsB;AAC7F;AACA,aAAa;AACb;AACA,+CAA+C,qEAAsB,EAAE,qEAAsB;AAC7F,aAAa;AACb;AACA,+CAA+C,qEAAsB,EAAE,qEAAsB;AAC7F,aAAa;AACb;AACA,+CAA+C,qEAAsB,EAAE,qEAAsB;AAC7F,aAAa;AACb;AACA,+CAA+C,qEAAsB,EAAE,qEAAsB;AAC7F,aAAa;AACb;;;;AAIA;;AAEA,mBAAmB,oBAAoB;AACvC,kCAAkC,0EAAmB;;AAErD,mBAAmB,aAAa;AAChC,kCAAkC;AAClC;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,6BAA6B;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,mEAAoB;AAClD;AACA;AACA,iCAAiC,8EAAc;AAC/C;AACA;AACA;AACA,2BAA2B,oBAAoB;AAC/C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,QAAQ;AACvB,iBAAiB,4BAA4B;AAC7C;AACA;AACA;AACA;AACA,yCAAyC,qEAAqB;AAC9D;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,mEAAqB;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+DAAiB,iBAAiB,cAAc,mCAAmC,uBAAuB;AAChI;;AAEA;AACA,2BAA2B,8EAAc;AACzC,YAAY,kDAAK,wCAAwC,cAAc,QAAQ,iBAAiB,8BAA8B,eAAe,eAAe,UAAU;;AAEtK;AACA;AACA,kEAAkE;AAClE;AACA,YAAY,kDAAK;AACjB;AACA;;AAEA;AACA,sBAAsB,mBAAmB;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACvPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6D;AACR;AACS;AACX;AACT;AACgB;;;AAG1D;AACA;AACA;;AAEA;AACA,gCAAgC,wEAAY;AAC5C;AACA,6CAA6C,iBAAiB;AAC9D,8BAA8B,wEAAY;AAC1C;;AAEA;AACA,oBAAoB,wEAAY;AAChC;AACA,6BAA6B,wEAAY;AACzC;AACA,0CAA0C,iBAAiB;;;;;AAK3D;AACA;AACA;AACA;AACO,8BAA8B,wEAAkB;AACvD;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,4CAA4C,0EAAK,CAAC,kDAAK;AACvD,4CAA4C,0EAAK,CAAC,kDAAK;AACvD;AACA,0CAA0C,0EAAK,CAAC,kDAAK;AACrD,0CAA0C,0EAAK,CAAC,kDAAK;AACrD;AACA,4CAA4C,0EAAK,CAAC,kDAAK;AACvD,4CAA4C,0EAAK,CAAC,kDAAK;AACvD;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,+DAA+D,2DAAc;AAC7E;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,4DAA4D,2DAAc;AAC1E,4DAA4D,2DAAc;AAC1E,4DAA4D,2DAAc;;AAE1E;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO,2BAA2B;AACjD,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB,4CAA4C,QAAQ;;AAE9F;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC1JA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6D;AACR;AACS;AACpB;;;;AAI1C;AACA;AACA,wBAAwB,wEAAY;AACpC,qCAAqC,uCAAuC;AAC5E;AACA,+BAA+B;;AAE/B;AACA;AACA,yBAAyB,wEAAY;AACrC,sCAAsC,kCAAkC;AACxE;AACA,gCAAgC;;AAEhC;AACA,yBAAyB,wEAAY;AACrC,sCAAsC,kCAAkC;AACxE;AACA,gCAAgC;AAChC;AACA;AACA,mBAAmB,wEAAY;AAC/B,gCAAgC,uBAAuB;AACvD;AACA,0BAA0B;;;;AAI1B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO,yBAAyB,wEAAkB;AAClD;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,0EAAK;AACtC;AACA;AACA;AACA,iCAAiC,0EAAK;AACtC;AACA;AACA;AACA,iCAAiC,0EAAK;AACtC;AACA;AACA;AACA,iCAAiC,0EAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,0EAAK,CAAC,kDAAK;AAC5C,iCAAiC,0EAAK,CAAC,kDAAK;AAC5C,iCAAiC,0EAAK,CAAC,kDAAK;AAC5C,iCAAiC,0EAAK,CAAC,kDAAK;AAC5C,kCAAkC,0EAAK,CAAC,kDAAK;AAC7C,kCAAkC,0EAAK,CAAC,kDAAK;;AAE7C;AACA,+BAA+B,0EAAK;AACpC,+BAA+B,0EAAK;AACpC,+BAA+B,0EAAK;AACpC,+BAA+B,0EAAK;AACpC,+BAA+B,0EAAK;AACpC,+BAA+B,0EAAK;AACpC,+BAA+B,0EAAK;AACpC,+BAA+B,0EAAK;AACpC,gCAAgC,0EAAK;AACrC,gCAAgC,0EAAK;AACrC;AACA;AACA;;;;;;;;;;;;;ACrKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6D;AACY;AACpB;AACiB;AACb;AACf;;;AAG1C;AACA,iBAAiB,wEAAY;AAC7B,8BAA8B,mBAAmB;AACjD;;AAEA,yBAAyB,wEAAY;AACrC,sCAAsC,cAAc;AACpD;;AAEA;AACA;AACA,mBAAmB,wEAAY;AAC/B,gCAAgC,qBAAqB;AACrD;AACA,0BAA0B;;AAE1B,0BAA0B,wEAAY;AACtC;;AAEA,2BAA2B,wEAAY;AACvC;;AAEA,0BAA0B,wEAAY;AACtC;;AAEA,2BAA2B,wEAAY;AACvC,wCAAwC,cAAc;AACtD;AACA;AACA,sBAAsB,wEAAY;AAClC;;AAEA,uBAAuB,wEAAY;AACnC;;AAEA;AACA,0BAA0B,wEAAY;AACtC,uCAAuC,kBAAkB;AACzD;;AAEA,oCAAoC,wEAAY;AAChD,iDAAiD,kBAAkB;AACnE;;AAEA;AACA,8BAA8B,wEAAY;AAC1C;;AAEA,6BAA6B,wEAAY;AACzC;;AAEA,6BAA6B,wEAAY;AACzC;;AAEA;AACA,sBAAsB,wEAAY;AAClC;;AAEA,4BAA4B,wEAAY;AACxC;;AAEA,4BAA4B,wEAAY;AACxC;;AAEA,wBAAwB,wEAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;;AAEA,qBAAqB,wEAAY;AACjC;;;;;AAKA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,cAAc,wEAAY;;AAE1B;AACA;AACA,cAAc,wEAAY;;AAE1B;AACA;AACA,cAAc,wEAAY;;AAE1B;AACA;AACA,oBAAoB,wEAAY;;AAEhC;AACA;AACA,oBAAoB,wEAAY;;AAEhC;AACA;AACA,mBAAmB,wEAAY;;AAE/B;AACA;AACA,uBAAuB,wEAAY;AACnC;;AAEA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA,yBAAyB,wEAAY;AACrC,sCAAsC,mBAAmB,iEAAkB,MAAM;AACjF;;AAEA;AACA;;AAEA;AACA,0BAA0B,wEAAY;;AAEtC;AACA;;AAEA;AACA,wBAAwB,wEAAY;;;;AAIpC;AACA;AACA;AACA,cAAc,wEAAY;AAC1B;;;;;;;AAOA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACO,2BAA2B,wEAAkB;AACpD;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;;;AAIA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,QAAQ,kDAAK;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,kCAAkC,8EAAc;AAChD,8FAA8F;;AAE9F;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,QAAQ,kDAAK;AACb;AACA;AACA;AACA,C;;;;;;;;;;;;ACxXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6D;AACnB;AACQ;AACuB;AACpB;AACS;AACH;;;;AAI3D;AACA;AACA;;AAEA;AACA,kBAAkB,wEAAY;AAC9B,oBAAoB,wEAAY;AAChC;AACA;;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;AACO,0BAA0B,wEAAkB;AACnD;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,gCAAgC,0EAAK;AACrC;AACA;AACA,gCAAgC,0EAAK;AACrC;AACA;;AAEA;AACA;AACA,iCAAiC,0EAAK;AACtC;AACA;AACA;AACA,aAAa;;AAEb,iCAAiC,0EAAK;AACtC;AACA;AACA;AACA,aAAa;;;AAGb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA,iCAAiC,0EAAK;AACtC;AACA;AACA,iCAAiC,0EAAK;AACtC;AACA;;AAEA;AACA;AACA,kCAAkC,0EAAK;AACvC;AACA;AACA;AACA,aAAa;;AAEb,kCAAkC,0EAAK;AACvC;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC9MA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6D;AACR;AACI;AACa;;;;AAItE;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B,oCAAoC;AACpC,sCAAsC;AACtC,sCAAsC;AACtC,6BAA6B;;AAE7B,WAAW,wEAAY;AACvB;AACA;AACA;AACA,YAAY;;AAEZ,gBAAgB,wEAAY;AAC5B;AACA;AACA;AACA,iBAAiB;;AAEjB,kBAAkB,wEAAY;AAC9B;AACA;AACA;AACA,mBAAmB;;AAEnB,mBAAmB,wEAAY;AAC/B;AACA;AACA;AACA,oBAAoB;;AAEpB,qBAAqB,wEAAY;AACjC;;AAEA,kBAAkB,wEAAY;AAC9B;;AAEA,qBAAqB,wEAAY;AACjC;;;AAGA;AACA;AACA;AACA;AACO,0BAA0B,wEAAkB;AACnD;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA,aAAa;AACb,uCAAuC;AACvC;AACA,aAAa;AACb,yCAAyC;AACzC;AACA,aAAa;AACb,yCAAyC;AACzC;AACA,aAAa;AACb;;AAEA;AACA;;;;;AAKA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,yCAAyC,iEAAkB;AAC3D;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8EAAc;AAC3C;AACA;;AAEA;AACA;AACA,kCAAkC,YAAY;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;ACrMA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6D;AACR;AACK;;;;AAI1D;AACA;AACA;;AAEA;AACA,wBAAwB,wEAAY;;AAEpC;AACA,iBAAiB,wEAAY;AAC7B;AACA;AACA,kBAAkB;AAClB;;AAEA,iBAAiB,wEAAY;AAC7B;AACA;AACA,kBAAkB;AAClB;;;AAGA;AACA;AACA;AACA;AACO,4BAA4B,wEAAkB;AACrD;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB,sBAAsB,WAAW;;AAE3E;AACA;AACA;AACA;AACA,qEAAqE;AACrE;;AAEA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yCAAyC;AACzC,yCAAyC;AACzC,yCAAyC;;AAEzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;ACtIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6D;AACY;AACpB;AACgB;AACX;AAChB;;;;AAI1C;AACA;AACA;;AAEA;AACA,iBAAiB,wEAAY;;AAE7B;AACA,cAAc,wEAAY;;AAE1B;AACA,aAAa,wEAAY;;AAEzB;AACA,uBAAuB,wEAAY;;AAEnC;AACA,uBAAuB,wEAAY;;AAEnC;AACA;;AAEA;AACA,qBAAqB,wEAAY;;;;AAIjC;AACA;AACA;AACA;AACO,uBAAuB,wEAAkB;AAChD;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY,kDAAK,mCAAmC,MAAM,KAAK,OAAO;AACtE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA,oEAAoE,2DAAc;AAClF;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA,oEAAoE,2DAAc;AAClF;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA,iDAAiD,6DAAgB;AACjE,sBAAsB,kEAAoB,0BAA0B,aAAa;;AAEjF,+BAA+B,6DAAgB;AAC/C;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,2DAAc;;AAEtE,sBAAsB,mBAAmB;AACzC;;AAEA;AACA;AACA,C;;;;;;;;;;;;ACrMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2D;AACkD;;AAE7G;AACA;AACA;AACA,CAAC;;AAED;AACA,mCAAmC;AACnC;AACA,CAAC;;AAED;AACA,mBAAmB,qCAAqC,YAAY;AACpE,mBAAmB,qCAAqC,YAAY;AACpE;;AAEA;AACA,yBAAyB,4BAA4B;AACrD,iBAAiB;AACjB,CAAC;;AAED;AACA,oBAAoB;AACpB,wBAAwB;AACxB;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,kCAAkC,mEAAQ,IAAY,WAAW,CAAC;AAClE;AACA,sBAAsB,kEAAoB;;AAE1C,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B,6BAA6B,uEAAkB;;AAE/C,mBAAmB,OAAO;AAC1B,+BAA+B,uEAAkB;;AAEjD,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,SAAS;AAC5B;;AAEA,mBAAmB,mBAAmB;AACtC;;AAEA,mBAAmB,mBAAmB;AACtC;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,+DAAiB,0BAA0B,SAAS;;AAE1E,sCAAsC,WAAW;AACjD;;AAEA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B,kEAAoB,cAAc,QAAQ;AACxE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C;AACA;AACA;AACA,+CAA+C;AAC/C;AACA,iCAAiC,IAAI,GAAG,MAAM;AAC9C;;AAEA;AACA;AACA,+BAA+B,uEAAkB;AACjD;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB,oCAAoC,KAAK;;AAEnF;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB,+CAA+C,KAAK;;AAE9F;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA,yDAAyD;AACzD,+EAA+E;AAC/E;;AAEA;AACA;AACA;AACA,4FAA4F;;AAE5F;AACA;AACA;AACA;AACA,kCAAkC,wDAAU,0CAA0C,KAAK;;AAE3F;AACA;;AAEA;AACA,kCAAkC,UAAU;AAC5C,wCAAwC,MAAM,GAAG,EAAE;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;AACA;AACA,C;;;;;;;;;;;;ACzTA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAS0B;AACa;AACS;AACgB;;AAEhE;AACA;AACA;AACA;AACA;AACA,6EAA6E,wCAAwC,iCAAiC,kBAAkB;AACxK,6EAA6E,wCAAwC,wCAAwC,kBAAkB;AAC/K;;AAEA;AACA;AACA;AACA,0BAA0B,iEAAkB;AAC5C,qBAAqB,4DAAa;;AAElC;AACA,0BAA0B,iEAAkB;AAC5C,8BAA8B,qEAAsB;;AAEpD;AACA,0BAA0B,2DAAc;AACxC,4BAA4B,2DAAc;AAC1C,2BAA2B,2DAAc;AACzC,4BAA4B,2DAAc;;AAE1C;AACA,gBAAgB,uDAAQ;AACxB,sBAAsB,6DAAc;;AAEpC;AACA,2BAA2B,kEAAmB;AAC9C,yBAAyB,gEAAiB;AAC1C,gBAAgB,uDAAQ;AACxB,oBAAoB,2DAAY;AAChC,mBAAmB,0DAAW;AAC9B,CAAC;;AAED;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,mBAAmB;AAClC,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,KAAK;AACpE;AACA;AACA;AACA;AACA,+DAA+D,IAAI;AACnE;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe,2EAAQ,IAAoB,WAAW,CAAC;;AAEvD,cAAc,+DAAiB,0CAA0C,SAAS;AAClF;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,mBAAmB;AAC9B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;;AAEA,kBAAkB,OAAO;AACzB;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAU,6CAA6C,MAAM,QAAQ,IAAI,cAAc,MAAM;AACnH;AACA,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA,IAAI,kDAAK;;AAET;AACA;AACA,8BAA8B,MAAM;AACpC,yBAAyB,KAAK;AAC9B,4BAA4B,QAAQ;AACpC,0BAA0B,MAAM;AAChC,wBAAwB,IAAI;AAC5B,wBAAwB,IAAI;AAC5B,yBAAyB,KAAK;AAC9B,6BAA6B,SAAS;AACtC;AACA;;AAEA;AACA;AACA,iDAAiD;;AAEjD;AACA,8CAA8C,iBAAiB;;AAE/D;AACA,uBAAuB,KAAK,GAAG,SAAS;;AAExC;AACA;AACA,sBAAsB,SAAS;AAC/B,0BAA0B,IAAI,QAAQ,KAAK,GAAG,IAAI,SAAS,GAAG;;AAE9D;AACA,sBAAsB;AACtB;;AAEA;AACA;AACA,C;;;;;;;;;;;ACpNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kE;;;;;;;;;;;ACxFA,uEAAuE,0BAA0B,gBAAgB,kCAAkC,6BAA6B,8BAA8B,GAAG,C;;;;;;;;;;;ACAjN,iDAAiD,0BAA0B,gQAAgQ,yCAAyC,kCAAkC,wBAAwB,wBAAwB,sDAAsD,uCAAuC,2BAA2B,qBAAqB,mFAAmF,wBAAwB,oEAAoE,qCAAqC,mCAAmC,wBAAwB,GAAG,uBAAuB,gBAAgB,oBAAoB,OAAO,2DAA2D,gCAAgC,oEAAoE,qCAAqC,mCAAmC,gCAAgC,GAAG,gDAAgD,4DAA4D,GAAG,C;;;;;;;;;;;ACAhyC,4CAA4C,0BAA0B,kKAAkK,oCAAoC,+BAA+B,wBAAwB,wBAAwB,iBAAiB,mGAAmG,WAAW,oCAAoC,2BAA2B,GAAG,uBAAuB,gBAAgB,oBAAoB,OAAO,2DAA2D,kBAAkB,oCAAoC,2BAA2B,gCAAgC,GAAG,mEAAmE,GAAG,C;;;;;;;;;;;ACAn1B,8EAA8E,0BAA0B,qBAAqB,wBAAwB,4BAA4B,qCAAqC,6BAA6B,wBAAwB,4BAA4B,yKAAyK,qCAAqC,2BAA2B,2BAA2B,oBAAoB,0DAA0D,6CAA6C,yEAAyE,gDAAgD,2BAA2B,iDAAiD,GAAG,kBAAkB,GAAG,gBAAgB,kCAAkC,+EAA+E,kGAAkG,gEAAgE,qBAAqB,iCAAiC,wCAAwC,gDAAgD,mDAAmD,0FAA0F,6CAA6C,qCAAqC,+DAA+D,kHAAkH,+GAA+G,4DAA4D,aAAa,+BAA+B,mHAAmH,qKAAqK,GAAG,C;;;;;;;;;;;ACAtrE,6DAA6D,+BAA+B,GAAG,C;;;;;;;;;;;ACA/F,8EAA8E,kCAAkC,6BAA6B,iCAAiC,mCAAmC,8BAA8B,kCAAkC,gBAAgB,yCAAyC,kCAAkC,6HAA6H,0FAA0F,yFAAyF,qGAAqG,mCAAmC,sHAAsH,GAAG,C;;;;;;;;;;;ACA75B,yEAAyE,6BAA6B,wBAAwB,4BAA4B,8HAA8H,8CAA8C,IAAI,gBAAgB,kCAAkC,kGAAkG,oEAAoE,+BAA+B,qCAAqC,oCAAoC,0BAA0B,WAAW,oCAAoC,0BAA0B,iCAAiC,4EAA4E,QAAQ,GAAG,WAAW,0CAA0C,kCAAkC,2CAA2C,8CAA8C,8CAA8C,QAAQ,GAAG,YAAY,qBAAqB,QAAQ,GAAG,GAAG,GAAG,C;;;;;;;;;;;ACAhoC,0CAA0C,oCAAoC,qBAAqB,uBAAuB,sBAAsB,sHAAsH,0GAA0G,4BAA4B,0CAA0C,4BAA4B,iCAAiC,gBAAgB,kCAAkC,gDAAgD,sDAAsD,yCAAyC,2CAA2C,sCAAsC,gDAAgD,sGAAsG,oDAAoD,uCAAuC,6CAA6C,8CAA8C,0FAA0F,2BAA2B,6DAA6D,2DAA2D,wCAAwC,WAAW,C;;;;;;;;;;;ACAj3C,+DAA+D,0CAA0C,iCAAiC,yBAAyB,kCAAkC,gBAAgB,uEAAuE,+BAA+B,4CAA4C,sDAAsD,uDAAuD,kDAAkD,kIAAkI,qFAAqF,yFAAyF,mFAAmF,6EAA6E,uBAAuB,GAAG,C;;;;;;;;;;;;ACAh/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwD;AACX;AACgB;;;;AAI7D;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB;AACO;AACP;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA,kBAAkB,kEAAoB,4DAA4D,MAAM;AACxG;AACA,kBAAkB,kEAAoB,qCAAqC,gBAAgB;;AAE3F;AACA;;AAEA;AACA,uCAAuC,kDAAK,WAAW,kDAAK,oBAAoB,kDAAK;AACrF;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,cAAc,gBAAgB,UAAU,IAAI,UAAU,aAAa,GAAG;AAC1F;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA,WAAW,wEAAY;AACvB;;;;;AAKA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB;AACO;AACP;AACA;AACA;;;;;AAKA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB;AACO;AACP;AACA;AACA;;;;;AAKA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA,kBAAkB,kEAAoB,4DAA4D,MAAM;AACxG;AACA,kBAAkB,kEAAoB,gDAAgD,KAAK,IAAI;;AAE/F;AACA;;AAEA;AACA,uCAAuC,kDAAK;AAC5C;AACA;AACA;AACA,mBAAmB,cAAc,gBAAgB,SAAS,gBAAgB,GAAG;AAC7E;AACA,mBAAmB,cAAc,mBAAmB,SAAS,aAAa,GAAG;AAC7E;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA,WAAW,wEAAY;AACvB,C;;;;;;;;;;;AC3JA,yIAAyI,sCAAsC,kGAAkG,2BAA2B,iDAAiD,cAAc,cAAc,mDAAmD,cAAc,cAAc,mDAAmD,cAAc,cAAc,cAAc,cAAc,kDAAkD,aAAa,aAAa,aAAa,aAAa,mDAAmD,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,kDAAkD,aAAa,aAAa,aAAa,aAAa,aAAa,aAAa,mDAAmD,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,kDAAkD,aAAa,aAAa,aAAa,aAAa,aAAa,aAAa,aAAa,aAAa,qDAAqD,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,oDAAoD,aAAa,aAAa,aAAa,aAAa,aAAa,aAAa,aAAa,aAAa,aAAa,aAAa,qDAAqD,eAAe,eAAe,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,oDAAoD,cAAc,cAAc,aAAa,aAAa,aAAa,aAAa,aAAa,aAAa,aAAa,aAAa,aAAa,aAAa,qDAAqD,eAAe,eAAe,eAAe,eAAe,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,oDAAoD,cAAc,cAAc,cAAc,cAAc,aAAa,aAAa,aAAa,aAAa,aAAa,aAAa,aAAa,aAAa,aAAa,aAAa,2EAA2E,GAAG,C;;;;;;;;;;;ACA9jF,wHAAwH,8CAA8C,kGAAkG,2BAA2B,4CAA4C,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,gDAAgD,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,gDAAgD,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,eAAe,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,oFAAoF,GAAG,C;;;;;;;;;;;ACA1pD,0CAA0C,4DAA4D,YAAY,YAAY,qFAAqF,eAAe,SAAS,gGAAgG,aAAa,aAAa,aAAa,aAAa,aAAa,aAAa,aAAa,aAAa,aAAa,SAAS,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,gBAAgB,sCAAsC,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,SAAS,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,QAAQ,QAAQ,OAAO,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,SAAS,QAAQ,QAAQ,SAAS,QAAQ,QAAQ,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,QAAQ,QAAQ,QAAQ,OAAO,SAAS,QAAQ,QAAQ,SAAS,QAAQ,QAAQ,SAAS,QAAQ,QAAQ,SAAS,QAAQ,QAAQ,SAAS,QAAQ,QAAQ,SAAS,QAAQ,QAAQ,QAAQ,QAAQ,SAAS,SAAS,QAAQ,QAAQ,OAAO,QAAQ,QAAQ,SAAS,QAAQ,QAAQ,QAAQ,QAAQ,OAAO,OAAO,SAAS,SAAS,OAAO,SAAS,QAAQ,QAAQ,SAAS,QAAQ,QAAQ,SAAS,QAAQ,SAAS,SAAS,SAAS,SAAS,iBAAiB,sCAAsC,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,SAAS,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,SAAS,QAAQ,QAAQ,QAAQ,SAAS,SAAS,SAAS,SAAS,SAAS,QAAQ,SAAS,SAAS,QAAQ,SAAS,SAAS,QAAQ,SAAS,SAAS,OAAO,QAAQ,OAAO,QAAQ,QAAQ,QAAQ,OAAO,OAAO,SAAS,OAAO,QAAQ,OAAO,QAAQ,QAAQ,QAAQ,OAAO,OAAO,SAAS,OAAO,OAAO,OAAO,OAAO,QAAQ,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,QAAQ,QAAQ,QAAQ,QAAQ,SAAS,SAAS,OAAO,SAAS,SAAS,QAAQ,SAAS,SAAS,QAAQ,SAAS,SAAS,QAAQ,SAAS,SAAS,OAAO,OAAO,SAAS,SAAS,SAAS,SAAS,SAAS,QAAQ,QAAQ,QAAQ,QAAQ,SAAS,SAAS,OAAO,SAAS,SAAS,QAAQ,SAAS,SAAS,QAAQ,SAAS,SAAS,QAAQ,SAAS,SAAS,OAAO,OAAO,SAAS,SAAS,SAAS,SAAS,SAAS,OAAO,OAAO,OAAO,OAAO,QAAQ,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,QAAQ,SAAS,SAAS,QAAQ,SAAS,QAAQ,SAAS,SAAS,QAAQ,SAAS,SAAS,SAAS,SAAS,SAAS,OAAO,SAAS,SAAS,SAAS,SAAS,SAAS,QAAQ,SAAS,SAAS,SAAS,SAAS,SAAS,QAAQ,SAAS,SAAS,SAAS,SAAS,SAAS,QAAQ,SAAS,SAAS,SAAS,SAAS,OAAO,OAAO,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,QAAQ,SAAS,QAAQ,SAAS,QAAQ,SAAS,QAAQ,SAAS,SAAS,SAAS,SAAS,SAAS,OAAO,SAAS,SAAS,SAAS,SAAS,QAAQ,SAAS,SAAS,SAAS,SAAS,SAAS,QAAQ,SAAS,SAAS,SAAS,SAAS,SAAS,QAAQ,SAAS,SAAS,SAAS,SAAS,OAAO,OAAO,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,OAAO,OAAO,OAAO,OAAO,QAAQ,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,iBAAiB,4FAA4F,GAAG,C;;;;;;;;;;;ACA5zL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0E;;;;;;;;;;;AChCA,sR;;;;;;;;;;;ACAA,wJAAwJ,uDAAuD,sZ;;;;;;;;;;;ACA/M,yMAAyM,uCAAuC,kCAAkC,GAAG,6BAA6B,aAAa,4CAA4C,GAAG,S;;;;;;;;;;;ACA9W,+c;;;;;;;;;;;ACAA,gLAAgL,gBAAgB,oBAAoB,YAAY,cAAc,YAAY,IAAI,2BAA2B,WAAW,aAAa,IAAI,6DAA6D,yDAAyD,uCAAuC,+CAA+C,6CAA6C,+jBAA+jB,kDAAkD,yGAAyG,mFAAmF,GAAG,4GAA4G,yDAAyD,+EAA+E,4DAA4D,sHAAsH,iBAAiB,GAAG,oGAAoG,+BAA+B,oBAAoB,qEAAqE,uEAAuE,+FAA+F,6DAA6D,2IAA2I,gGAAgG,gEAAgE,gDAAgD,uCAAuC,4DAA4D,gEAAgE,mEAAmE,qGAAqG,kBAAkB,GAAG,+CAA+C,gCAAgC,iDAAiD,0BAA0B,yBAAyB,+CAA+C,GAAG,4LAA4L,gEAAgE,oEAAoE,GAAG,S;;;;;;;;;;;ACA17G,8UAA8U,0BAA0B,iIAAiI,GAAG,wGAAwG,8FAA8F,GAAG,gE;;;;;;;;;;;ACArrB,6O;;;;;;;;;;;ACAA,wyBAAwyB,iEAAiE,uEAAuE,+BAA+B,0FAA0F,GAAG,sCAAsC,oGAAoG,4CAA4C,GAAG,0KAA0K,S;;;;;;;;;;;ACA/4C,k8BAAk8B,yCAAyC,+BAA+B,kEAAkE,qBAAqB,cAAc,gBAAgB,QAAQ,gBAAgB,OAAO,OAAO,kBAAkB,kBAAkB,+BAA+B,wBAAwB,+DAA+D,8BAA8B,8BAA8B,YAAY,GAAG,gBAAgB,WAAW,GAAG,mDAAmD,gBAAgB,0BAA0B,kCAAkC,gDAAgD,yEAAyE,GAAG,kDAAkD,GAAG,S;;;;;;;;;;;ACAxtD,wFAAwF,qDAAqD,6BAA6B,4BAA4B,gCAAgC,sCAAsC,sEAAsE,8BAA8B,WAAW,wCAAwC,qDAAqD,wCAAwC,oDAAoD,2EAA2E,8BAA8B,WAAW,S;;;;;;;;;;;ACAxqB,6MAA6M,wBAAwB,+BAA+B,mEAAmE,0CAA0C,4DAA4D,4DAA4D,4DAA4D,8CAA8C,kFAAkF,mBAAmB,GAAG,S;;;;;;;;;;;ACA3rB,0DAA0D,uCAAuC,gBAAgB,kCAAkC,wBAAwB,2BAA2B,uCAAuC,uCAAuC,qDAAqD,sEAAsE,sEAAsE,iCAAiC,+CAA+C,+CAA+C,+CAA+C,iCAAiC,+CAA+C,+CAA+C,+CAA+C,kHAAkH,gCAAgC,gDAAgD,gCAAgC,gCAAgC,2IAA2I,2IAA2I,0EAA0E,0EAA0E,uCAAuC,qCAAqC,qCAAqC,uCAAuC,+CAA+C,iCAAiC,oEAAoE,wBAAwB,mFAAmF,kGAAkG,6BAA6B,sCAAsC,qEAAqE,mDAAmD,kDAAkD,+DAA+D,GAAG,C;;;;;;;;;;;ACArwE,kFAAkF,kCAAkC,6BAA6B,iCAAiC,mCAAmC,8BAA8B,kCAAkC,gBAAgB,6CAA6C,kCAAkC,6HAA6H,0FAA0F,yFAAyF,qGAAqG,uDAAuD,uGAAuG,6FAA6F,6CAA6C,GAAG,C;;;;;;;;;;;ACApjC,mGAAmG,4BAA4B,oBAAoB,wBAAwB,wFAAwF,uCAAuC,mCAAmC,kCAAkC,4BAA4B,wBAAwB,qDAAqD,wCAAwC,uCAAuC,wHAAwH,kEAAkE,sEAAsE,8DAA8D,gEAAgE,+FAA+F,uFAAuF,4CAA4C,oDAAoD,uDAAuD,4DAA4D,0DAA0D,mWAAmW,8vEAA8vE,wBAAwB,wEAAwE,wEAAwE,yFAAyF,mDAAmD,yDAAyD,2BAA2B,+BAA+B,2BAA2B,+BAA+B,2BAA2B,+BAA+B,8DAA8D,2CAA2C,mEAAmE,6DAA6D,iDAAiD,C;;;;;;;;;;;ACA9vJ,qEAAqE,0BAA0B,gBAAgB,kCAAkC,yCAAyC,4CAA4C,sDAAsD,sDAAsD,sDAAsD,sDAAsD,uDAAuD,uDAAuD,uDAAuD,wDAAwD,wDAAwD,uDAAuD,wDAAwD,wDAAwD,iCAAiC,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,4DAA4D,4DAA4D,kBAAkB,8DAA8D,gBAAgB,kCAAkC,GAAG,C;;;;;;;;;;;ACA5tD,qEAAqE,0BAA0B,mDAAmD,iDAAiD,gBAAgB,kCAAkC,yCAAyC,4CAA4C,ktBAAktB,uMAAuM,2DAA2D,6BAA6B,2BAA2B,6BAA6B,2BAA2B,6BAA6B,2BAA2B,wEAAwE,iBAAiB,gBAAgB,kCAAkC,GAAG,C;;;;;;;;;;;ACAplD,qEAAqE,0BAA0B,gBAAgB,kCAAkC,yCAAyC,4CAA4C,sDAAsD,sDAAsD,sDAAsD,uDAAuD,uDAAuD,wDAAwD,uDAAuD,uDAAuD,iCAAiC,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,iBAAiB,8DAA8D,gBAAgB,kCAAkC,GAAG,C;;;;;;;;;;;ACAjxC,sEAAsE,0BAA0B,gBAAgB,kCAAkC,4BAA4B,kCAAkC,qDAAqD,6FAA6F,yCAAyC,oBAAoB,gCAAgC,sDAAsD,sDAAsD,sDAAsD,uDAAuD,uDAAuD,wDAAwD,uDAAuD,uDAAuD,oIAAoI,sBAAsB,2CAA2C,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,8BAA8B,2BAA2B,iCAAiC,YAAY,iCAAiC,YAAY,iCAAiC,YAAY,iCAAiC,YAAY,GAAG,cAAc,2BAA2B,gCAAgC,YAAY,gCAAgC,YAAY,gCAAgC,YAAY,gCAAgC,YAAY,GAAG,cAAc,yCAAyC,GAAG,QAAQ,iBAAiB,GAAG,GAAG,GAAG,GAAG,C;;;;;;;;;;;ACA7uF,sEAAsE,0BAA0B,gBAAgB,kCAAkC,4BAA4B,kCAAkC,qDAAqD,6FAA6F,yCAAyC,oBAAoB,gCAAgC,sDAAsD,sDAAsD,sDAAsD,sDAAsD,uDAAuD,uDAAuD,uDAAuD,wDAAwD,wDAAwD,uDAAuD,wDAAwD,wDAAwD,oIAAoI,sBAAsB,2CAA2C,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,iBAAiB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,eAAe,SAAS,yBAAyB,EAAE,aAAa,EAAE,iBAAiB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,eAAe,SAAS,yBAAyB,EAAE,aAAa,EAAE,8BAA8B,2BAA2B,iCAAiC,YAAY,iCAAiC,YAAY,iCAAiC,YAAY,iCAAiC,YAAY,iCAAiC,YAAY,iCAAiC,YAAY,GAAG,cAAc,2BAA2B,gCAAgC,YAAY,gCAAgC,YAAY,gCAAgC,YAAY,gCAAgC,YAAY,gCAAgC,YAAY,gCAAgC,YAAY,GAAG,cAAc,yCAAyC,GAAG,QAAQ,iBAAiB,GAAG,GAAG,GAAG,GAAG,C;;;;;;;;;;;ACArsH,sEAAsE,0BAA0B,yCAAyC,gBAAgB,kCAAkC,kCAAkC,4BAA4B,qDAAqD,kEAAkE,yCAAyC,4CAA4C,sDAAsD,sDAAsD,uDAAuD,wDAAwD,gIAAgI,sDAAsD,sDAAsD,sDAAsD,uDAAuD,uDAAuD,uDAAuD,wDAAwD,yDAAyD,yDAAyD,wDAAwD,wDAAwD,wDAAwD,mWAAmW,8vEAA8vE,4BAA4B,GAAG,C;;;;;;;;;;;ACAzjI,mGAAmG,0BAA0B,6BAA6B,wBAAwB,yCAAyC,mDAAmD,iDAAiD,gBAAgB,oCAAoC,kCAAkC,4BAA4B,yCAAyC,4CAA4C,yBAAyB,6CAA6C,+BAA+B,oBAAoB,wBAAwB,WAAW,iCAAiC,mBAAmB,oBAAoB,2OAA2O,4rBAA4rB,uhBAAuhB,8vEAA8vE,uMAAuM,2DAA2D,6BAA6B,2BAA2B,6BAA6B,2BAA2B,6BAA6B,2BAA2B,0DAA0D,2BAA2B,oDAAoD,iBAAiB,kBAAkB,GAAG,mCAAmC,8BAA8B,GAAG,C;;;;;;;;;;;ACAnkK,uEAAuE,6BAA6B,wBAAwB,gBAAgB,oCAAoC,wCAAwC,yDAAyD,wDAAwD,gBAAgB,iEAAiE,GAAG,C;;;;;;;;;;;ACA7Z,mGAAmG,oBAAoB,iKAAiK,uGAAuG,gBAAgB,wBAAwB,wHAAwH,uCAAuC,uCAAuC,0FAA0F,yDAAyD,GAAG,C;;;;;;;;;;;ACAnwB,mGAAmG,gCAAgC,oBAAoB,4EAA4E,+DAA+D,qEAAqE,oCAAoC,yBAAyB,uBAAuB,sBAAsB,gBAAgB,4FAA4F,mCAAmC,SAAS,SAAS,UAAU,QAAQ,QAAQ,UAAU,QAAQ,QAAQ,mCAAmC,UAAU,SAAS,SAAS,SAAS,WAAW,UAAU,SAAS,SAAS,SAAS,UAAU,SAAS,QAAQ,QAAQ,QAAQ,UAAU,SAAS,QAAQ,QAAQ,QAAQ,UAAU,SAAS,QAAQ,QAAQ,QAAQ,mCAAmC,UAAU,UAAU,SAAS,SAAS,SAAS,SAAS,WAAW,UAAU,UAAU,SAAS,SAAS,SAAS,SAAS,WAAW,UAAU,UAAU,SAAS,SAAS,SAAS,SAAS,UAAU,SAAS,SAAS,QAAQ,QAAQ,QAAQ,QAAQ,UAAU,SAAS,SAAS,QAAQ,QAAQ,QAAQ,QAAQ,UAAU,SAAS,SAAS,QAAQ,QAAQ,QAAQ,QAAQ,UAAU,SAAS,SAAS,QAAQ,QAAQ,QAAQ,QAAQ,sIAAsI,8DAA8D,+CAA+C,2DAA2D,GAAG,C;;;;;;;;;;;ACAjqD,qEAAqE,gBAAgB,kCAAkC,wCAAwC,qCAAqC,+CAA+C,GAAG,C;;;;;;;;;;;ACAtP,qPAAqP,yBAAyB,6BAA6B,wBAAwB,mDAAmD,uDAAuD,0HAA0H,gCAAgC,kCAAkC,UAAU,kCAAkC,UAAU,iCAAiC,SAAS,gCAAgC,SAAS,kBAAkB,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,6BAA6B,GAAG,GAAG,gBAAgB,kCAAkC,oCAAoC,+BAA+B,oDAAoD,wBAAwB,oBAAoB,wBAAwB,WAAW,sBAAsB,SAAS,gBAAgB,gBAAgB,OAAO,gBAAgB,gBAAgB,OAAO,iEAAiE,mDAAmD,GAAG,GAAG,2FAA2F,uCAAuC,sCAAsC,qCAAqC,yDAAyD,GAAG,2CAA2C,wCAAwC,kDAAkD,0BAA0B,GAAG,C;;;;;;;;;;;ACAvuD,iGAAiG,oBAAoB,oGAAoG,gGAAgG,2CAA2C,gBAAgB,wBAAwB,8fAA8f,4DAA4D,0DAA0D,kHAAkH,0BAA0B,GAAG,C;;;;;;;;;;;ACA/oC,qFAAqF,+BAA+B,iCAAiC,6BAA6B,wBAAwB,+BAA+B,gBAAgB,kCAAkC,+EAA+E,qGAAqG,uEAAuE,yDAAyD,+DAA+D,6FAA6F,gKAAgK,uEAAuE,4DAA4D,GAAG,C;;;;;;;;;;;ACAjhC,iGAAiG,wBAAwB,wqBAAwqB,gBAAgB,kCAAkC,iCAAiC,wCAAwC,gBAAgB,4BAA4B,iHAAiH,qOAAqO,gEAAgE,0OAA0O,gEAAgE,sDAAsD,+CAA+C,+BAA+B,mFAAmF,uIAAuI,sIAAsI,8EAA8E,uGAAuG,kGAAkG,uFAAuF,mHAAmH,8GAA8G,0EAA0E,mDAAmD,uCAAuC,GAAG,C;;;;;;;;;;;ACAl2F,gFAAgF,4BAA4B,4BAA4B,wBAAwB,gCAAgC,ikKAAikK,8DAA8D,4BAA4B,0BAA0B,0BAA0B,eAAe,eAAe,GAAG,gBAAgB,2CAA2C,kCAAkC,kGAAkG,gFAAgF,gBAAgB,iCAAiC,6EAA6E,sCAAsC,2EAA2E,mFAAmF,gCAAgC,gCAAgC,2CAA2C,iCAAiC,iDAAiD,yCAAyC,yCAAyC,gBAAgB,OAAO,OAAO,iBAAiB,YAAY,YAAY,gBAAgB,yBAAyB,OAAO,OAAO,2CAA2C,yFAAyF,yFAAyF,+BAA+B,GAAG,iBAAiB,GAAG,4DAA4D,GAAG,C;;;;;;;;;;;ACAhuN,yEAAyE,qCAAqC,6BAA6B,wBAAwB,4BAA4B,gJAAgJ,q7LAAq7L,sCAAsC,iCAAiC,gBAAgB,6CAA6C,kCAAkC,2DAA2D,+EAA+E,kFAAkF,+EAA+E,sBAAsB,iCAAiC,8CAA8C,kEAAkE,mDAAmD,qCAAqC,gBAAgB,WAAW,OAAO,mCAAmC,0DAA0D,+EAA+E,6BAA6B,GAAG,oCAAoC,sDAAsD,0EAA0E,6DAA6D,GAAG,C;;;;;;;;;;;ACAt6O,uEAAuE,gBAAgB,oCAAoC,wCAAwC,8GAA8G,wDAAwD,qFAAqF,GAAG,C;;;;;;;;;;;ACAja,uEAAuE,8BAA8B,gBAAgB,kCAAkC,8BAA8B,oCAAoC,gCAAgC,sCAAsC,qFAAqF,oFAAoF,oFAAoF,uFAAuF,2CAA2C,mDAAmD,mDAAmD,mDAAmD,kCAAkC,kCAAkC,kCAAkC,kCAAkC,6CAA6C,6CAA6C,6CAA6C,qBAAqB,sEAAsE,GAAG,C;;;;;;;;;;;ACApqC,6EAA6E,2BAA2B,qCAAqC,6BAA6B,wBAAwB,8BAA8B,oBAAoB,cAAc,aAAa,IAAI,4DAA4D,6BAA6B,+EAA+E,mCAAmC,kDAAkD,iBAAiB,GAAG,+GAA+G,wCAAwC,kEAAkE,0EAA0E,yCAAyC,GAAG,gBAAgB,kCAAkC,wCAAwC,uGAAuG,gFAAgF,4CAA4C,sGAAsG,4DAA4D,+EAA+E,yGAAyG,oFAAoF,gGAAgG,GAAG,C;;;;;;;;;;;ACAjsD,kFAAkF,6BAA6B,wBAAwB,4BAA4B,8BAA8B,oBAAoB,cAAc,aAAa,IAAI,8DAA8D,qCAAqC,iDAAiD,qGAAqG,0CAA0C,GAAG,gBAAgB,kCAAkC,8BAA8B,mDAAmD,+EAA+E,kFAAkF,+EAA+E,6BAA6B,2CAA2C,iCAAiC,wCAAwC,4CAA4C,GAAG,C;;;;;;;;;;;ACA7kC,gDAAgD,wBAAwB,+BAA+B,8BAA8B,oBAAoB,cAAc,aAAa,IAAI,4DAA4D,6BAA6B,+EAA+E,mCAAmC,kDAAkD,iBAAiB,GAAG,8DAA8D,qCAAqC,iDAAiD,qGAAqG,0CAA0C,GAAG,+GAA+G,wCAAwC,kEAAkE,0EAA0E,yCAAyC,GAAG,wEAAwE,0BAA0B,qBAAqB,4BAA4B,sBAAsB,sBAAsB,8BAA8B,8BAA8B,gBAAgB,sBAAsB,OAAO,+CAA+C,+CAA+C,4CAA4C,yBAAyB,yBAAyB,eAAe,eAAe,8DAA8D,8DAA8D,iCAAiC,+BAA+B,8CAA8C,+CAA+C,oDAAoD,qDAAqD,sDAAsD,qDAAqD,GAAG,qEAAqE,GAAG,gBAAgB,kCAAkC,8BAA8B,kDAAkD,4CAA4C,6CAA6C,kCAAkC,8BAA8B,kBAAkB,4CAA4C,sBAAsB,4DAA4D,4CAA4C,GAAG,C;;;;;;;;;;;ACAllF,kFAAkF,6BAA6B,wBAAwB,4BAA4B,sCAAsC,gBAAgB,kCAAkC,iGAAiG,2DAA2D,+EAA+E,gGAAgG,0EAA0E,GAAG,C;;;;;;;;;;;ACAnpB,qFAAqF,qCAAqC,6BAA6B,wBAAwB,4BAA4B,gBAAgB,6CAA6C,kCAAkC,oGAAoG,wEAAwE,uEAAuE,iGAAiG,4DAA4D,2CAA2C,qCAAqC,iFAAiF,sDAAsD,0CAA0C,qIAAqI,GAAG,C;;;;;;;;;;;ACAnkC,kFAAkF,yBAAyB,uBAAuB,6BAA6B,wBAAwB,4BAA4B,qGAAqG,mCAAmC,IAAI,gBAAgB,6CAA6C,kCAAkC,kGAAkG,oEAAoE,gBAAgB,iCAAiC,+BAA+B,gCAAgC,iDAAiD,0BAA0B,WAAW,oCAAoC,0BAA0B,iCAAiC,4EAA4E,QAAQ,GAAG,WAAW,0CAA0C,kCAAkC,2CAA2C,8CAA8C,8CAA8C,QAAQ,GAAG,YAAY,qBAAqB,QAAQ,GAAG,GAAG,GAAG,C;;;;;;;;;;;ACA3vC,0CAA0C,gBAAgB,kCAAkC,gEAAgE,8BAA8B,GAAG,C;;;;;;;;;;;ACA7L,0CAA0C,gBAAgB,kCAAkC,0CAA0C,uFAAuF,GAAG,C;;;;;;;;;;;ACAhO,yEAAyE,qCAAqC,yBAAyB,iCAAiC,6BAA6B,wBAAwB,4BAA4B,sCAAsC,iDAAiD,mCAAmC,qIAAqI,GAAG,gBAAgB,6CAA6C,kCAAkC,kGAAkG,gBAAgB,kCAAkC,+EAA+E,sCAAsC,2FAA2F,gDAAgD,0DAA0D,GAAG,C;;;;;;;;;;;ACA3iC,yEAAyE,yBAAyB,qCAAqC,6BAA6B,wBAAwB,4BAA4B,sCAAsC,iDAAiD,mCAAmC,qIAAqI,GAAG,gBAAgB,6CAA6C,kCAAkC,kGAAkG,+EAA+E,sHAAsH,4DAA4D,GAAG,C;;;;;;;;;;;ACA/5B,wGAAwG,gCAAgC,gCAAgC,kCAAkC,yBAAyB,oBAAoB,oBAAoB,iCAAiC,iCAAiC,wBAAwB,6BAA6B,wBAAwB,4BAA4B,6LAA6L,yDAAyD,uFAAuF,gFAAgF,oEAAoE,4DAA4D,wDAAwD,oDAAoD,2CAA2C,qGAAqG,6RAA6R,8JAA8J,kDAAkD,wBAAwB,yBAAyB,eAAe,SAAS,0DAA0D,0CAA0C,kGAAkG,iHAAiH,gBAAgB,OAAO,gBAAgB,gBAAgB,OAAO,yBAAyB,GAAG,GAAG,eAAe,gBAAgB,gBAAgB,OAAO,yBAAyB,yBAAyB,wBAAwB,wBAAwB,GAAG,wBAAwB,wBAAwB,wBAAwB,wBAAwB,GAAG,yDAAyD,6DAA6D,6DAA6D,6DAA6D,+hBAA+hB,uCAAuC,uCAAuC,+BAA+B,mIAAmI,GAAG,yDAAyD,sCAAsC,wCAAwC,6DAA6D,mEAAmE,GAAG,2DAA2D,iCAAiC,2BAA2B,+BAA+B,wNAAwN,0IAA0I,GAAG,sEAAsE,qBAAqB,4BAA4B,+BAA+B,uCAAuC,iBAAiB,iBAAiB,QAAQ,iBAAiB,iBAAiB,QAAQ,aAAa,YAAY,6IAA6I,mDAAmD,GAAG,GAAG,kBAAkB,GAAG,+BAA+B,4DAA4D,GAAG,8BAA8B,4DAA4D,GAAG,gBAAgB,wCAAwC,kCAAkC,oDAAoD,yBAAyB,2DAA2D,+EAA+E,kFAAkF,4EAA4E,iCAAiC,sCAAsC,6EAA6E,8CAA8C,oBAAoB,4BAA4B,gBAAgB,gBAAgB,OAAO,gBAAgB,gBAAgB,OAAO,uFAAuF,uHAAuH,wCAAwC,GAAG,GAAG,iDAAiD,8DAA8D,kCAAkC,wEAAwE,sJAAsJ,8FAA8F,wDAAwD,uCAAuC,sDAAsD,gBAAgB,wBAAwB,OAAO,qEAAqE,wCAAwC,gDAAgD,2CAA2C,GAAG,4CAA4C,8DAA8D,kCAAkC,GAAG,C;;;;;;;;;;;ACAp1N,wGAAwG,qCAAqC,6BAA6B,wBAAwB,4BAA4B,8BAA8B,4DAA4D,GAAG,gBAAgB,6CAA6C,kCAAkC,oGAAoG,iFAAiF,wEAAwE,0CAA0C,uDAAuD,oDAAoD,sCAAsC,sEAAsE,6FAA6F,0DAA0D,GAAG,C;;;;;;;;;;;ACAljC,sEAAsE,gBAAgB,+CAA+C,gJAAgJ,yEAAyE,qFAAqF,uDAAuD,C;;;;;;;;;;;ACA1e,sEAAsE,iCAAiC,uDAAuD,kDAAkD,sCAAsC,oBAAoB,GAAG,gBAAgB,oCAAoC,4BAA4B,+BAA+B,mEAAmE,+FAA+F,kEAAkE,GAAG,C;;;;;;;;;;;ACAnmB,wEAAwE,6BAA6B,6BAA6B,gBAAgB,qCAAqC,mCAAmC,kNAAkN,gEAAgE,GAAG,C;;;;;;;;;;;ACA/e,oEAAoE,8BAA8B,sBAAsB,gBAAgB,kCAAkC,sNAAsN,yCAAyC,GAAG,C;;;;;;;;;;;ACA5a,sCAAsC,gBAAgB,sBAAsB,GAAG,C;;;;;;;;;;;ACA/E,0CAA0C,eAAe,+BAA+B,qCAAqC,8BAA8B,GAAG,C;;;;;;;;;;;ACA9J,0CAA0C,gBAAgB,6BAA6B,GAAG,C;;;;;;;;;;;ACA1F,0CAA0C,8BAA8B,gBAAgB,kCAAkC,uCAAuC,oCAAoC,gCAAgC,sCAAsC,qFAAqF,oFAAoF,oFAAoF,uFAAuF,yCAAyC,mDAAmD,mDAAmD,mDAAmD,4CAA4C,4CAA4C,sDAAsD,GAAG,C;;;;;;;;;;;;ACAl7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuC;AACU;AACO;AACJ;;AAEpD;AACA,0BAA0B;AAC1B;AACA;;AAEA,WAAW,SAAS;AACpB;;AAEA;AACA;AACA;AACO,uBAAuB,4DAAU;AACxC;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,QAAQ,kDAAK;AACb;;AAEA;AACA;AACA,sBAAsB,+DAAiB;;AAEvC,mBAAmB,kBAAkB;AACrC;;AAEA,mBAAmB,uBAAuB;AAC1C;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA,uBAAuB,kDAAK;;AAE5B;AACA,YAAY,kDAAK;AACjB;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS,SAAS;;AAElB;AACA;;AAEA;AACA;AACA,eAAe,kBAAkB;AACjC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,sBAAsB,+DAAiB,sE;;AAEvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,kDAAK;;AAEb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,+DAAiB;;AAEvC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,kCAAkC;AAClD;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,mEAAa;AAChC;AACA;AACA;AACA;AACA,kDAAkD;AAClD,aAAa;AACb,SAAS;AACT;AACA,C;;;;;;;;;;;;AChNA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuC;AACU;AACa;AACJ;AACQ;AACF;AACU;AACpB;AACf;;;AAGvC;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,mBAAmB,iEAAkB,aAAa,iEAAkB;AACpE,sBAAsB,+DAAiB,yCAAyC,MAAM,KAAK,OAAO,mBAAmB,iEAAkB,CAAC,KAAK,iEAAkB,CAAC;AAChK;AACA,sBAAsB,kEAAoB,0BAA0B,MAAM,KAAK,OAAO;;;;AAItF,mBAAmB,SAAS;AAC5B,yBAAyB,mDAAQ;;AAEjC,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,oBAAoB;AACvC,6BAA6B,0EAAmB;;AAEhD,mBAAmB,kBAAkB;AACrC,gCAAgC,sEAAiB;;AAEjD,mBAAmB,sBAAsB;AACzC,oCAAoC,8EAAqB;;;;AAIzD;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,kBAAkB;AACjC,eAAe,cAAc;AAC7B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,QAAQ,kDAAK;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,0EAAmB;AAChD,gCAAgC,sEAAiB;AACjD,oCAAoC,8EAAqB;AACzD;AACA,C;;;;;;;;;;;;ACvLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4C;AACE;AACE;AACI;AACF;AACA;AACQ;AACR;AACI;AACM;AACN;AACC;;AAEvD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kEAAkB;AACtD;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iDAAiD,wDAAQ;AACzD;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mDAAmD,0DAAS;AAC5D;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,qDAAqD,4DAAU;AAC/D;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yDAAyD,gEAAY;AACrE;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,uDAAuD,8DAAW;AAClE;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,uDAAuD,8DAAW;AAClE;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,+DAA+D,sEAAe;AAC9E;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,2DAA2D,kEAAa;AACxE;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,kEAAkB;AAC/C,sBAAsB,mEAAoB,2BAA2B,IAAI,wBAAwB,kEAAkB,GAAG;;AAEtH;AACA,iEAAiE,8DAAW;AAC5E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,8DAA8D,wEAAkB;AAChF;AACA;AACA;;AAEA,sBAAsB,2BAA2B;AACjD;AACA;AACA;;AAEA;AACA;AACA,C;;;;;;;;;;;;AC1MA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiD;AACR;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,gBAAgB;AACnC;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,kBAAkB;AACjC,eAAe,OAAO;AACtB,iBAAiB,mBAAmB;AACpC;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb,SAAS;;AAET;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb,SAAS;AACT;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,sBAAsB,2BAA2B;AACjD;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,kBAAkB;AACjC,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA,4CAA4C;AAC5C;AACA,4BAA4B,6DAAa;AACzC;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,C;;;;;;;;;;;;AC3LA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwE;AAChB;AACC;AAClB;AACmE;;AAE1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;AAID;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,kBAAkB;AACjC,eAAe,OAAO;AACtB;AACA,2CAA2C,EAAE;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,kBAAkB;AACjC,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;;;AAIT,mBAAmB,uBAAuB;AAC1C;;AAEA,mBAAmB,aAAa;AAChC;;AAEA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA,SAAS;;AAET,mBAAmB,SAAS;AAC5B;;AAEA,mBAAmB,UAAU;AAC7B;;AAEA,mBAAmB,UAAU;AAC7B;;AAEA,mBAAmB,QAAQ;AAC3B;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,wBAAwB;AAC3C,uCAAuC,mCAAmC;AAC1E,sBAAsB,qEAAqB;;AAE3C,mBAAmB,wBAAwB;AAC3C;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,4BAA4B;AAC/C;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,2BAA2B;AACjD;AACA;AACA;AACA;AACA,8BAA8B,mEAAqB,sBAAsB,QAAQ;AACjF;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,mDAAmD;AACnE,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,kEAAoB,8DAA8D,gBAAgB,QAAQ,YAAY;;AAE5I;AACA,qCAAqC;AACrC,wCAAwC,QAAQ;AAChD;AACA,0BAA0B,+DAAiB;AAC3C;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iCAAiC,iBAAiB;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,QAAQ,GAAG,aAAa;AAChE,8BAA8B,kEAAoB,+CAA+C,QAAQ;AACzG,mDAAmD,iCAAiC,QAAQ,GAAG,EAAE,mBAAmB;AACpH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,0CAA0C;;AAE1C;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,gBAAgB,yBAAyB;AACzC,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA,QAAQ,kDAAK;;AAEb;AACA;AACA;;AAEA;AACA,sBAAsB,0BAA0B;AAChD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,wBAAwB;AACvC,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA,QAAQ,kDAAK,uFAAuF,iBAAiB;;AAErH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,0BAA0B;AAChD;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sBAAsB,6BAA6B;AACnD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,qDAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;;;;;;;AAOA;AACA;AACA,WAAW,uBAAuB;AAClC,WAAW,qBAAqB;AAChC,aAAa;AACb;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA,aAAa,OAAO;AACpB,cAAc,YAAY;AAC1B,cAAc,YAAY;AAC1B;AACA;AACA;AACA,eAAe,uBAAuB;AACtC;;AAEA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA,KAAK;;AAEL,eAAe,uBAAuB;AACtC;;;;AAIA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;;AAE/B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;AAMA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,qBAAqB;AAChC;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA,kBAAkB,+DAAiB,8BAA8B,UAAU;;AAE3E,eAAe,qBAAqB;AACpC;;AAEA,eAAe,OAAO;AACtB;AACA;;AAEA,eAAe,OAAO;AACtB;;AAEA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,uBAAuB;AAClC,WAAW,gDAAgD;AAC3D,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,+DAAiB,eAAe,MAAM,iCAAiC,oCAAoC;AACjI;AACA,sBAAsB,kEAAoB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA,2DAA2D;AAC3D;AACA;AACA,sBAAsB,kEAAoB,qDAAqD,UAAU,KAAK,MAAM;AACpH;AACA;AACA,kBAAkB,kEAAoB,6CAA6C,MAAM;;AAEzF;AACA;AACA;;;;;;;AAOA;AACA;AACA,WAAW,uBAAuB;AAClC,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,+EAA+E;AAC/E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,C;;;;;;;;;;;;ACpuBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuC;AACE;AACgB;AACN;;AAEnD;AACA;AACA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;;;AAIA;AACA,aAAa,OAAO;AACpB;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAsB;AACrC,eAAe,mBAAmB;AAClC,eAAe,mBAAmB;AAClC;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;;AAEA,mBAAmB,mBAAmB;AACtC;;AAEA,mBAAmB,mBAAmB;AACtC;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;AACA;;;;AAIA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB;AACA;AACA;AACA,QAAQ,kDAAK;;AAEb,mBAAmB,gBAAgB;AACnC,mCAAmC,mBAAmB;;AAEtD,mBAAmB,mBAAmB;AACtC;;AAEA,mBAAmB,UAAU;AAC7B;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,8DAAgB,8BAA8B,oBAAoB;;AAExF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,sBAAsB;AACrC,iBAAiB;AACjB;AACA;AACA;AACA;AACA,QAAQ,kDAAK;;AAEb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,sBAAsB,yBAAyB;AAC/C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA,4BAA4B,qEAAqB;AACjD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,C;;;;;;;;;;;;AClLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuC;AACF;AACmB;AACC;AACqB;;AAE9E;AACA;AACA;AACA,oCAAoC;;;AAGpC;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA,QAAQ,kDAAK;;AAEb,mBAAmB,aAAa;AAChC;;AAEA,mBAAmB,SAAS;AAC5B;;AAEA,mBAAmB,SAAS;AAC5B;AACA;;AAEA;AACA;AACA;AACA,eAAe,sBAAsB;AACrC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,gDAAgD;AAChD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,sBAAsB;AACrC,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,0BAA0B;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,gDAAgD;AAChD;;AAEA;AACA;AACA,mBAAmB,mEAAa;;AAEhC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;;AAET;AACA;AACA;AACA,uBAAuB,mEAAa;AACpC;AACA,2DAA2D;AAC3D,aAAa;AACb;AACA,wBAAwB,mEAAa;AACrC;AACA;AACA;AACA,2DAA2D;AAC3D,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,8BAA8B;AACpD;AACA,gDAAgD;AAChD;AACA;AACA;;AAEA;AACA;AACA,eAAe,MAAM;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,mEAAa;AAChC;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,WAAW;AAC1B,eAAe,iBAAiB;AAChC,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,kEAAoB;;AAE1C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,eAAe,iDAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB;AAC3C,SAAS;AACT;AACA,SAAS;AACT;AACA,C;;;;;;;;;;;;ACrPA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyC;AACQ;AACe;;AAEhE;AACA,6BAA6B;;AAE7B;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;;AAEA,mBAAmB,gBAAgB;AACnC;;AAEA,mBAAmB,OAAO;AAC1B;AACA;;AAEA;AACA;AACA,eAAe,kBAAkB;AACjC,eAAe,cAAc;AAC7B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,0BAA0B;AACpD,uCAAuC,6DAAa;AACpD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,sBAAsB,0BAA0B;AAChD;AACA;AACA;;AAEA;AACA;AACA,C;;;;;;;;;;;;ACtGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyC;AACF;AAC0B;AACX;;AAEtD;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,OAAO;AAC1B;;AAEA,mBAAmB,aAAa;AAChC;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,0FAA0F;AACzG,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA,QAAQ,kDAAK;;AAEb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB;AACnB,QAAQ,kDAAK;;AAEb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,wBAAwB;AACvC,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY,kDAAK;;AAEjB;AACA,8BAA8B,uBAAuB;AACrD;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,kDAAK;;AAErB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,QAAQ,kDAAK;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,aAAa;AAC5B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,0FAA0F;AACzG,eAAe,MAAM;AACrB,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;;AAE9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,kDAAK;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB;AACnB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,wFAAwF;;AAExF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC;;AAEnC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,aAAa;AAC5B,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qDAAO,8BAA8B,MAAM,IAAI,OAAO;AAC5E;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,iBAAiB;AAChC,eAAe,aAAa;AAC5B,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,MAAM;AACrB,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,C;;;;;;;;;;;ACnqBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,2CAAe,S;;;;;;;;;;;;ACrBxC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,8BAA8B,QAAQ;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,8BAA8B,QAAQ;AACtC;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA,C;;;;;;;;;;;;ACzQA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiD;;AAEjD;AACA,4BAA4B;;AAErB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,6DAAqB;;AAE3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;ACvFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACO,6BAA6B;;AAEpC;AACO,4BAA4B;;AAEnC;AACO;;;;AAIP;AACA;AACA;;AAEA;AACO,mBAAmB;;AAE1B;AACO,6CAA6C;;;;AAIpD;AACA;AACA;;AAEA;AACO,sDAAsD;;;;AAI7D;AACA;AACA;;AAEA;AACO;;AAEP;AACO;;AAEP;AACO,uEAAuE;;AAE9E;AACO;;AAEP;AACO,kCAAkC;;AAEzC;AACO;;AAEP;AACO;;AAEP;AACO;;;;AAIP;AACA;AACA;;AAEA;AACO;AACP;AACA,CAAC,I;;;;;;;;;;;;AC9FD;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,IAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACjEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE+C;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,2DAAmB;AACrC;;AAEA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,SAAS;AACxB,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,iBAAiB;AAChC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,iBAAiB;AAChC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA,mDAAmD;AACnD,yDAAyD;;AAEzD,iCAAiC,qCAAqC;AACtE;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACxIA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,8CAA8C;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC;AACvC,sCAAsC;AACtC;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA,2BAA2B,aAAa,YAAY;AACpD;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;;AAErB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,uCAAuC,YAAY;AACnD;AACA,uCAAuC,eAAe,YAAY,EAAE;AACpE;AACA,uCAAuC,cAAc,YAAY,EAAE;AACnE;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,IAAI;AACnB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,IAAI;AACnB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iDAAiD,iBAAiB,oCAAoC,EAAE;AACxG,0BAA0B,YAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,IAAI;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,IAAI;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,IAAI;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,cAAc;AACxC;AACA;;AAEA;AACA;AACA;AACA,kEAAkE;AAClE,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,cAAc;AACxC;AACA;;AAEA;AACA;AACA;AACA,kEAAkE;AAClE,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,IAAI;AACnB;AACA;AACA;AACA,gFAAgF;AAChF;AACA;AACA;;AAEA;AACA,kCAAkC;;AAElC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,YAAY,8BAA8B,EAAE;AAC1E,8BAA8B,WAAW,8BAA8B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB;;AAEpB;AACA;AACA,kBAAkB;AAClB,4CAA4C;AAC5C,E;;;;;;;;;;;;;ACpbA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgC;;AAEhC;AACA;AACA,UAAU;AACV;AACO,kBAAkB,4CAAK;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACO;AACP;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACO,oBAAoB,4CAAK;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,CAAC,E;;;;;;;;;;;;ACzED;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiH;AAChE;;AAEjD;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,UAAU;AAC1B,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,UAAU;AAC1B,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,WAAW,IAA2B;AACtC;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,sBAAsB,sDAAc;AACpC;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,0EAA0E,EAAE;AAC5E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA,iCAAiC,mBAAmB,EAAE;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kDAAU,uCAAuC,KAAK;;AAE5E;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,mBAAmB,EAAE;AACjC;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ,EAAE,QAAQ;AAC1C,wBAAwB,EAAE,EAAE,QAAQ,iBAAiB,EAAE,EAAE,QAAQ;AACjE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,4DAAoB,iDAAiD,WAAW;AACtG;AACA,sBAAsB,4DAAoB,2CAA2C,MAAM;;AAE3F;AACA;AACA;;AAEA;AACA,oCAAoC;AACpC,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;;AAEA,0BAA0B,WAAW,UAAU;AAC/C,0BAA0B,WAAW,UAAU;;AAE/C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,aAAa;AACrC,4BAA4B,aAAa;AACzC;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA,sBAAsB,4DAAoB;;AAE1C;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA,sBAAsB,4DAAoB;;AAE1C;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA,0DAA0D;AAC1D;AACA;;AAEA;AACA,sBAAsB,yDAAiB;;AAEvC,mBAAmB,6DAAa;AAChC;AACA;AACA;AACA,4BAA4B,eAAe;AAC3C,6BAA6B,gBAAgB;AAC7C;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,2BAA2B,yDAAiB;AAC5C;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,C","file":"speedy-vision.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * orb.js\n * ORB features\n */\n\nimport { SpeedyGPU } from '../../../gpu/speedy-gpu';\nimport { FeatureDescriptionAlgorithm } from '../feature-description-algorithm';\nimport { FeatureAlgorithm } from '../feature-algorithm';\nimport { BinaryDescriptor } from '../../speedy-descriptor';\nimport { SpeedyFeatureWithDescriptor } from '../../speedy-feature';\n\n// constants\nconst DESCRIPTOR_SIZE = 32; // 256 bits\n\n/**\n * ORB features\n */\nexport class ORBFeatures extends FeatureDescriptionAlgorithm\n{\n    /**\n     * Constructor\n     * @param {FeatureAlgorithm} decoratedAlgorithm preferably Multiscale Harris\n     */\n    constructor(decoratedAlgorithm)\n    {\n        super(decoratedAlgorithm, DESCRIPTOR_SIZE);\n    }\n\n    /**\n     * Compute ORB feature descriptors\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture pre-processed greyscale image\n     * @param {SpeedyTexture} detectedKeypoints tiny texture with appropriate size for the descriptors\n     * @returns {SpeedyTexture} tiny texture with encoded keypoints & descriptors\n     */\n    _describe(gpu, inputTexture, detectedKeypoints)\n    {\n        const descriptorSize = this.descriptorSize;\n        const extraSize = this.extraSize;\n        const encoderLength = this.encoderLength;\n\n        // get oriented keypoints\n        const orientedKeypoints = this._computeOrientation(gpu, inputTexture, detectedKeypoints);\n\n        // smooth the image before computing the descriptors\n        const smoothTexture = gpu.programs.filters.gauss7(inputTexture);\n        const smoothPyramid = smoothTexture.generateMipmaps();\n\n        // compute ORB feature descriptors\n        return gpu.programs.keypoints.orbOld(smoothPyramid, orientedKeypoints, descriptorSize, extraSize, encoderLength);\n    }\n\n    /**\n     * Compute the orientation of the keypoints\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture pre-processed greyscale image\n     * @param {SpeedyTexture} detectedKeypoints tiny texture with appropriate size for the descriptors\n     * @returns {SpeedyTexture} tiny texture with encoded keypoints & descriptors\n     */\n    _computeOrientation(gpu, inputTexture, detectedKeypoints)\n    {\n        const descriptorSize = this.descriptorSize;\n        const extraSize = this.extraSize;\n        const encoderLength = this.encoderLength;\n\n        // generate pyramid\n        const pyramid = inputTexture.generateMipmaps();\n\n        // compute orientation\n        return gpu.programs.keypoints.orbOrientationOld(pyramid, detectedKeypoints, descriptorSize, extraSize, encoderLength);\n    }\n\n    /**\n     * Post-process the keypoints after downloading them\n     * @param {SpeedyFeature[]} keypoints\n     * @returns {SpeedyFeature[]}\n     */\n    _postProcess(keypoints)\n    {\n        return keypoints.map(\n            keypoint => new SpeedyFeatureWithDescriptor(\n                keypoint,\n                descriptorBytes => new BinaryDescriptor(descriptorBytes)\n            )\n        );\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * fast.js\n * FAST corner detector\n */\n\nimport { SpeedyGPU } from '../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../gpu/speedy-texture';\nimport { FeatureDetectionAlgorithm } from '../feature-detection-algorithm';\nimport { NotSupportedError } from '../../../utils/errors';\nimport { Utils } from '../../../utils/utils';\nimport { PYRAMID_MAX_LEVELS } from '../../../utils/globals';\n\n// constants\nconst SQRT_2 = 1.4142135623730951;\nconst DEFAULT_FAST_VARIANT = 9;\nconst DEFAULT_FAST_THRESHOLD = 20;\nconst DEFAULT_DEPTH = 4;\nconst DEFAULT_SCALE_FACTOR = SQRT_2; // scale factor between consecutive pyramid layers\n\n\n\n/**\n * FAST corner detector\n */\nexport class FASTFeatures extends FeatureDetectionAlgorithm\n{\n    /**\n     * Constructor\n     */\n    constructor()\n    {\n        super();\n\n        /** @type {number} FAST variant */\n        this._n = DEFAULT_FAST_VARIANT;\n\n        /** @type {number} FAST threshold in [0,255] */\n        this._threshold = DEFAULT_FAST_THRESHOLD;\n    }\n\n    /**\n     * Get FAST variant\n     * @returns {number}\n     */\n    get n()\n    {\n        return this._n;\n    }\n\n    /**\n     * Set FAST variant\n     * @param {number} value 9, 7 or 5\n     */\n    set n(value)\n    {\n        this._n = value | 0;\n        Utils.assert(this._n === 9 || this._n === 7 || this._n === 5);\n    }\n\n    /**\n     * Get FAST threshold\n     * @returns {number}\n     */\n    get threshold()\n    {\n        return this._threshold;\n    }\n\n    /**\n     * Set FAST threshold\n     * @param {number} value a number in [0,255]\n     */\n    set threshold(value)\n    {\n        this._threshold = value | 0;\n        Utils.assert(this._threshold >= 0 && this._threshold <= 255);\n    }\n\n    /**\n     * Detect feature points\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture pre-processed greyscale image\n     * @returns {SpeedyTexture} encoded keypoints\n     */\n    _detect(gpu, inputTexture)\n    {\n        const n = this._n;\n        const threshold = this._threshold;\n        const normalizedThreshold = threshold / 255.0;\n        const descriptorSize = this.descriptorSize;\n        const extraSize = this.extraSize;\n        const encoderLength = this.encoderLength;\n\n        // find corners\n        let corners = null;\n        if(n == 9)\n            corners = gpu.programs.keypoints.fast9(inputTexture, normalizedThreshold);\n        else if(n == 7)\n            corners = gpu.programs.keypoints.fast7(inputTexture, normalizedThreshold);\n        else if(n == 5)\n            corners = gpu.programs.keypoints.fast5(inputTexture, normalizedThreshold);\n        else\n            throw new NotSupportedError();\n\n        // non-maximum suppression\n        const suppressedCorners = gpu.programs.keypoints.nonMaxSuppression(corners);\n\n        // convert scores to an 8-bit component\n        const finalCorners = gpu.programs.keypoints.encodeFastScore(suppressedCorners);\n\n        // encode corners\n        return gpu.programs.encoders.encodeKeypoints(finalCorners, descriptorSize, extraSize, encoderLength);\n    }\n}\n\n\n\n\n\n/**\n * FAST corner detector in an image pyramid\n */\nexport class MultiscaleFASTFeatures extends FeatureDetectionAlgorithm\n{\n    /**\n     * Constructor\n     */\n    constructor()\n    {\n        super();\n\n        /** @type {number} FAST variant */\n        this._n = DEFAULT_FAST_VARIANT;\n\n        /** @type {number} FAST threshold in [0,255] */\n        this._threshold = DEFAULT_FAST_THRESHOLD;\n\n        /** @type {number} how many pyramid levels we'll scan */\n        this._depth = DEFAULT_DEPTH;\n\n        /** @type {number} scale factor between consecutive pyramid levels */\n        this._scaleFactor = DEFAULT_SCALE_FACTOR;\n    }\n\n    /**\n     * Get FAST variant\n     * @returns {number}\n     */\n    get n()\n    {\n        return this._n;\n    }\n\n    /**\n     * Set FAST variant\n     * @param {number} value only 9 is supported at this time\n     */\n    set n(value)\n    {\n        this._n = value | 0;\n        Utils.assert(this._n === 9);\n    }\n\n    /**\n     * Get FAST threshold\n     * @returns {number}\n     */\n    get threshold()\n    {\n        return this._threshold;\n    }\n\n    /**\n     * Set FAST threshold\n     * @param {number} value a number in [0,255]\n     */\n    set threshold(value)\n    {\n        this._threshold = value | 0;\n        Utils.assert(this._threshold >= 0 && this._threshold <= 255);\n    }\n\n    /**\n     * Get depth: how many pyramid levels we will scan\n     * @returns {number}\n     */\n    get depth()\n    {\n        return this._depth;\n    }\n\n    /**\n     * Set depth: how many pyramid levels we will scan\n     * @param {number} value 1, 2, 3...\n     */\n    set depth(value)\n    {\n        this._depth = value | 0;\n        Utils.assert(this._depth >= 1 && this._depth <= PYRAMID_MAX_LEVELS);\n    }\n\n    /**\n     * Get the scale factor between consecutive pyramid layers\n     * @returns {number}\n     */\n    get scaleFactor()\n    {\n        return this._scaleFactor;\n    }\n\n    /**\n     * Set the scale factor between consecutive pyramid layers\n     * @param {number} value a value greater than 1 and less than or equal to 2\n     */\n    set scaleFactor(value)\n    {\n        this._scaleFactor = Math.min(Math.max(1, +value), 2);\n    }\n\n    /**\n     * Detect feature points\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture pre-processed greyscale image\n     * @returns {SpeedyTexture} encoded keypoints\n     */\n    _detect(gpu, inputTexture)\n    {\n        const threshold = this._threshold;\n        const depth = this._depth;\n        const normalizedThreshold = threshold / 255.0;\n        const numberOfLayers = 2 * depth - 1;\n        const lodStep = Math.log2(this._scaleFactor);\n        const descriptorSize = this.descriptorSize;\n        const extraSize = this.extraSize;\n        const encoderLength = this.encoderLength;\n\n        // generate pyramid\n        const pyramid = inputTexture.generateMipmaps();\n\n        // find corners\n        const corners = gpu.programs.keypoints.multiscaleFast(pyramid, normalizedThreshold, numberOfLayers, lodStep);\n\n        // non-maximum suppression\n        const suppressedCorners = gpu.programs.keypoints.nonMaxSuppression(corners, lodStep);\n\n        // convert scores to an 8-bit component\n        const finalCorners = gpu.programs.keypoints.encodeFastScore(suppressedCorners);\n\n        // encode keypoints\n        const detectedKeypoints = gpu.programs.encoders.encodeKeypoints(finalCorners, descriptorSize, extraSize, encoderLength);\n\n        // done\n        return detectedKeypoints;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * harris.js\n * Harris corner detector\n */\n\nimport { SpeedyGL } from '../../../gpu/speedy-gl';\nimport { SpeedyGPU } from '../../../gpu/speedy-gpu';\nimport { SpeedyDrawableTexture } from '../../../gpu/speedy-texture';\nimport { FeatureDetectionAlgorithm } from '../feature-detection-algorithm';\nimport { PixelComponent } from '../../../utils/types';\nimport { PYRAMID_MAX_LEVELS } from '../../../utils/globals';\nimport { Utils } from '../../../utils/utils';\n\n// constants\nconst DEFAULT_QUALITY = 0.1; // default quality metric\nconst DEFAULT_DEPTH = 4; // default depth for multiscale feature detection\nconst DEFAULT_WINDOW_SIZE = 3; // compute Harris autocorrelation matrix within a 3x3 window\nconst DEFAULT_SCALE_FACTOR = 1.4142135623730951; // scale factor between consecutive pyramid layers (sqrt(2))\nconst MIN_WINDOW_SIZE = 0; // minimum window size when computing the autocorrelation matrix\nconst MAX_WINDOW_SIZE = 7; // maximum window size when computing the autocorrelation matrix\nconst MAX_LAYERS = 2 * PYRAMID_MAX_LEVELS - 1; // Sobel derivatives for each pyramid layer\n\n/**\n * Harris corner detector\n */\nexport class HarrisFeatures extends FeatureDetectionAlgorithm\n{\n    /**\n     * Constructor\n     */\n    constructor()\n    {\n        super();\n        this._quality = DEFAULT_QUALITY;\n    }\n\n    /**\n     * Get detector quality\n     * @returns {number}\n     */\n    get quality()\n    {\n        return this._quality;\n    }\n\n    /**\n     * Set detector quality\n     * @param {number} value a number in [0,1]: we will pick corners having score >= quality * max(score)\n     */\n    set quality(value)\n    {\n        this._quality = +value;\n        Utils.assert(this._quality >= 0 && this._quality <= 1);\n    }\n\n    /**\n     * Run the Harris corner detector\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture pre-processed greyscale image\n     * @returns {SpeedyTexture} encoded keypoints\n     */\n    _detect(gpu, inputTexture)\n    {\n        const { width, height } = gpu.programs.keypoints.multiscaleSobel;\n        const quality = this._quality;\n        const descriptorSize = this.descriptorSize;\n        const extraSize = this.extraSize;\n        const encoderLength = this.encoderLength;\n        const windowSize = DEFAULT_WINDOW_SIZE;\n        const lod = 0, lodStep = 1, numberOfLayers = 1;\n\n        // compute derivatives\n        gpu.programs.keypoints.multiscaleSobel.outputs(width, height, null);\n        const df = gpu.programs.keypoints.multiscaleSobel(inputTexture, lod);\n        const sobelDerivatives = new Array(MAX_LAYERS).fill(df);\n\n        // corner detection\n        const corners = gpu.programs.keypoints.multiscaleHarris(inputTexture, windowSize, numberOfLayers, lodStep, sobelDerivatives);\n\n        // find the maximum corner response\n        const numIterations = Math.ceil(Math.log2(Math.max(corners.width, corners.height)));\n        let maxScore = corners;\n        for(let i = 0; i < numIterations; i++)\n            maxScore = gpu.programs.keypoints.maxHarrisScore(maxScore, i);\n\n        // discard corners according to quality level\n        //const filteredCorners = gpu.programs.keypoints.harrisCutoff(suppressedCorners, maxScore, quality);\n        const filteredCorners = gpu.programs.keypoints.harrisCutoff(corners, maxScore, quality);\n\n        // non-maximum suppression\n        const suppressedCorners = gpu.programs.keypoints.nonMaxSuppression(filteredCorners);\n\n        // convert score to 8-bit component\n        const finalCorners = gpu.programs.keypoints.encodeHarrisScore(suppressedCorners);\n\n        // encode corners\n        return gpu.programs.encoders.encodeKeypoints(finalCorners, descriptorSize, extraSize, encoderLength);\n    }\n}\n\n/**\n * Harris corner detector in an image pyramid\n */\nexport class MultiscaleHarrisFeatures extends FeatureDetectionAlgorithm\n{\n    /**\n     * Constructor\n     */\n    constructor()\n    {\n        super();\n        this._quality = DEFAULT_QUALITY;\n        this._depth = DEFAULT_DEPTH;\n        this._scaleFactor = DEFAULT_SCALE_FACTOR;\n        this._derivativesTexture = Array.from({ length : MAX_LAYERS }, () =>\n            new SpeedyDrawableTexture(SpeedyGL.instance.gl, 1, 1));\n    }\n\n    /**\n     * Get detector quality\n     * @returns {number}\n     */\n    get quality()\n    {\n        return this._quality;\n    }\n\n    /**\n     * Set detector quality\n     * @param {number} value a number in [0,1]: we will pick corners having score >= quality * max(score)\n     */\n    set quality(value)\n    {\n        this._quality = +value;\n        Utils.assert(this._quality >= 0 && this._quality <= 1);\n    }\n\n    /**\n     * Get depth: how many pyramid levels we will scan\n     * @returns {number}\n     */\n    get depth()\n    {\n        return this._depth;\n    }\n\n    /**\n     * Set depth: how many pyramid levels we will scan\n     * @param {number} value 1, 2, 3...\n     */\n    set depth(value)\n    {\n        this._depth = value | 0;\n        Utils.assert(this._depth >= 1 && this._depth <= PYRAMID_MAX_LEVELS);\n    }\n\n    /**\n     * Get the scale factor between consecutive pyramid layers\n     * @returns {number}\n     */\n    get scaleFactor()\n    {\n        return this._scaleFactor;\n    }\n\n    /**\n     * Set the scale factor between consecutive pyramid layers\n     * @param {number} value a value greater than 1 and less than or equal to 2\n     */\n    set scaleFactor(value)\n    {\n        this._scaleFactor = Math.min(Math.max(1, +value), 2);\n    }\n\n    /**\n     * Detect feature points\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture pre-processed greyscale image\n     * @returns {SpeedyTexture} encoded keypoints\n     */\n    _detect(gpu, inputTexture)\n    {\n        const { width, height } = gpu.programs.keypoints.multiscaleSobel;\n        const quality = this._quality;\n        const depth = this._depth;\n        const descriptorSize = this.descriptorSize;\n        const extraSize = this.extraSize;\n        const encoderLength = this.encoderLength;\n        const windowSize = DEFAULT_WINDOW_SIZE;\n        const numberOfLayers = 2 * depth - 1;\n        const lodStep = Math.log2(this._scaleFactor);\n\n        // generate pyramid\n        const pyramid = inputTexture.generateMipmaps();\n\n        // compute derivatives\n        const sobelDerivatives = new Array(MAX_LAYERS);\n        for(let j = 0; j < numberOfLayers; j++) {\n            gpu.programs.keypoints.multiscaleSobel.outputs(width, height, this._derivativesTexture[j]);\n            sobelDerivatives[j] = gpu.programs.keypoints.multiscaleSobel(pyramid, j * lodStep);\n            gpu.programs.keypoints.multiscaleSobel.outputs(width, height, null);\n        }\n        for(let k = numberOfLayers; k < sobelDerivatives.length; k++)\n            sobelDerivatives[k] = sobelDerivatives[k-1]; // can't call shaders with null pointers\n\n        // corner detection\n        const corners = gpu.programs.keypoints.multiscaleHarris(pyramid, windowSize, numberOfLayers, lodStep, sobelDerivatives);\n\n        // find the maximum corner response\n        const numIterations = Math.ceil(Math.log2(Math.max(corners.width, corners.height)));\n        let maxScore = corners;\n        for(let i = 0; i < numIterations; i++)\n            maxScore = gpu.programs.keypoints.maxHarrisScore(maxScore, i);\n\n        // discard corners according to the quality level\n        const filteredCorners = gpu.programs.keypoints.harrisCutoff(corners, maxScore, quality);\n\n        // non-maximum suppression\n        const suppressedCorners = gpu.programs.keypoints.nonMaxSuppression(filteredCorners, lodStep);\n\n        // convert score to 8-bit component\n        const finalCorners = gpu.programs.keypoints.encodeHarrisScore(suppressedCorners);\n\n        // encode keypoints\n        const detectedKeypoints = gpu.programs.encoders.encodeKeypoints(finalCorners, descriptorSize, extraSize, encoderLength);\n\n        // done\n        return detectedKeypoints;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * feature-algorithm-decorator.js\n * Decorator pattern applied to the FeatureAlgorithm class\n */\n\nimport { FeatureAlgorithm } from './feature-algorithm';\nimport { SpeedyFeature } from '../speedy-feature';\nimport { SpeedyPromise } from '../../utils/speedy-promise';\nimport { Utils } from '../../utils/utils';\n\n/**\n * This decorator lets us extend and combine\n * the FeatureAlgorithm class in many ways\n * @abstract\n */\nexport class FeatureAlgorithmDecorator extends FeatureAlgorithm\n{\n    /**\n     * Constructor\n     * @param {FeatureAlgorithm} decoratedAlgorithm \n     * @param {number} [descriptorSize] in bytes, required for GPU algorithms\n     * @param {number} [extraSize] in bytes, required for GPU algorithms\n     */\n    constructor(decoratedAlgorithm, descriptorSize = 0, extraSize = 0)\n    {\n        Utils.assert(decoratedAlgorithm instanceof FeatureAlgorithm);\n        Utils.assert(descriptorSize >= decoratedAlgorithm.descriptorSize);\n        Utils.assert(extraSize >= decoratedAlgorithm.extraSize);\n\n        super(descriptorSize, extraSize);\n\n        /** @type {FeatureAlgorithm} decorated algorithm */\n        this._decoratedAlgorithm = decoratedAlgorithm;\n        this._decoratedAlgorithm.descriptorSize = this.descriptorSize;\n        this._decoratedAlgorithm.extraSize = this.extraSize;\n    }\n\n    /**\n     * Abstract \"run\" operation:\n     * runs something on the GPU\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture\n     * @returns {SpeedyTexture}\n     */\n    run(gpu, inputTexture)\n    {\n        return this._decoratedAlgorithm.run(gpu, inputTexture);\n    }\n\n    /**\n     * Download feature points from the GPU\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} encodedKeypoints tiny texture with encoded keypoints\n     * @param {FeatureDownloaderFlag} [flags] will be passed to the downloader\n     * @returns {SpeedyPromise<SpeedyFeature[]>}\n     */\n    download(gpu, encodedKeypoints, flags = 0)\n    {\n        Utils.assert(this.extraSize == this._decoratedAlgorithm.extraSize);\n        Utils.assert(this.descriptorSize == this._decoratedAlgorithm.descriptorSize);\n\n        return this._decoratedAlgorithm.download(gpu, encodedKeypoints, flags);\n    }\n\n    /**\n     * The decorated algorithm\n     * @returns {FeatureAlgorithm}\n     */\n    get decoratedAlgorithm()\n    {\n        return this._decoratedAlgorithm;\n    }\n\n    /**\n     * Extra size of the headers of the encoded keypoint texture\n     * @return {number} in bytes\n     */\n    get extraSize()\n    {\n        return super.extraSize;\n    }\n\n    /**\n     * Set the extra size of the headers of the encoded keypoint texture\n     * @param {number} bytes a multiple of 4 (32 bits)\n     */\n    set extraSize(bytes)\n    {\n        super.extraSize = bytes;\n        this._decoratedAlgorithm.extraSize = bytes;\n    }\n\n    /**\n     * Descriptor size\n     * @return {number} in bytes\n     */\n    get descriptorSize()\n    {\n        return super.descriptorSize;\n    }\n\n    /**\n     * Set the descriptor size, in bytes\n     * @param {number} bytes a multiple of 4 (32 bits)\n     */\n    set descriptorSize(bytes)\n    {\n        super.descriptorSize = bytes;\n        this._decoratedAlgorithm.descriptorSize = bytes;\n    }\n\n    /**\n     * Size of the keypoint encoder texture\n     * @returns {number}\n     */\n    get encoderLength()\n    {\n        return this._decoratedAlgorithm.encoderLength;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * feature-algorithm.js\n * An abstract algorithm related to feature points\n */\n\nimport { SpeedyGPU } from '../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../gpu/speedy-texture';\nimport { AbstractMethodError } from '../../utils/errors';\nimport { Utils } from '../../utils/utils';\nimport { SpeedyFeature } from '../speedy-feature';\nimport { SpeedyPromise } from '../../utils/speedy-promise';\nimport { MAX_DESCRIPTOR_SIZE } from '../../utils/globals';\n\n/**\n * An abstract algorithm that deals with\n * feature points in any way (detection,\n * tracking, etc.)\n * @abstract\n */\nexport class FeatureAlgorithm\n{\n    /**\n     * Class constructor\n     * @param {number} [descriptorSize] in bytes, required for GPU algorithms\n     * @param {number} [extraSize] in bytes, required for GPU algorithms\n     */\n    constructor(descriptorSize = 0, extraSize = 0)\n    {\n        Utils.assert(descriptorSize <= MAX_DESCRIPTOR_SIZE);\n        Utils.assert(descriptorSize % 4 === 0);\n        Utils.assert(extraSize % 4 === 0);\n\n        /** @type {number} descriptor size in bytes */\n        this._descriptorSize = descriptorSize; // for encoded keypoint textures\n\n        /** @type {number} extra size in bytes */\n        this._extraSize = extraSize; // for encoded keypoint textures\n    }\n\n    /**\n     * Abstract \"run\" operation:\n     * runs something on the GPU\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture\n     * @returns {SpeedyTexture}\n     */\n    run(gpu, inputTexture)\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Download feature points from the GPU\n     * Needs to be overridden in subclasses\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} encodedKeypoints tiny texture\n     * @param {FeatureDownloaderFlag} [flags] will be passed to the downloader\n     * @returns {SpeedyPromise<SpeedyFeature[]>} feature points\n     */\n    download(gpu, encodedKeypoints, flags = 0)\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Extra size of the headers of the encoded keypoint texture\n     * By default, this is set to zero\n     * @return {number} in bytes\n     */\n    get extraSize()\n    {\n        return this._extraSize;\n    }\n\n    /**\n     * Set the extra size of the headers of the encoded keypoint texture\n     * By default, this is set to zero\n     * This is low-level stuff!\n     * @param {number} bytes a multiple of 4 (32 bits)\n     */\n    set extraSize(bytes)\n    {\n        this._extraSize = Math.max(0, bytes | 0);\n        Utils.assert(this._extraSize % 4 === 0); // multiple of 32 bits (RGBA pixel)\n    }\n\n    /**\n     * Descriptor size\n     * By default, this is set to zero\n     * @return {number} in bytes\n     */\n    get descriptorSize()\n    {\n        return this._descriptorSize;\n    }\n\n    /**\n     * Set the descriptor size, in bytes\n     * By default, this is set to zero\n     * @param {number} bytes a multiple of 4 (32 bits)\n     */\n    set descriptorSize(bytes)\n    {\n        this._descriptorSize = Math.max(0, bytes | 0);\n        Utils.assert(this._descriptorSize % 4 === 0); // multiple of 32 bits (RGBA pixel)\n    }\n\n    /**\n     * Size of the keypoint encoder texture\n     * @returns {number}\n     */\n    get encoderLength()\n    {\n        throw new AbstractMethodError();\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * feature-description-algorithm.js\n * Abstract feature description algorithm\n */\n\nimport { AbstractMethodError } from '../../utils/errors';\nimport { FeatureAlgorithm } from './feature-algorithm';\nimport { FeatureAlgorithmDecorator } from './feature-algorithm-decorator';\nimport { FeatureDetectionAlgorithm } from './feature-detection-algorithm';\nimport { SpeedyFeature } from '../speedy-feature';\nimport { SpeedyPromise } from '../../utils/speedy-promise';\nimport { Utils } from '../../utils/utils';\n\n/**\n * Abstract feature description algorithm\n * @abstract\n */\nexport class FeatureDescriptionAlgorithm extends FeatureAlgorithmDecorator\n{\n    /**\n     * Constructor\n     * @param {FeatureAlgorithm} decoratedAlgorithm usually the feature detection algorithm \n     * @param {number} descriptorSize in bytes, required for GPU algorithms\n     */\n    constructor(decoratedAlgorithm, descriptorSize)\n    {\n        Utils.assert(decoratedAlgorithm instanceof FeatureAlgorithm);\n        Utils.assert(descriptorSize > 0);\n\n        super(decoratedAlgorithm, descriptorSize, decoratedAlgorithm.extraSize);\n    }\n\n    /**\n     * To \"run\" this algorithm means: to describe feature points\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture pre-processed greyscale image\n     * @returns {SpeedyTexture} tiny texture with encoded keypoints & descriptors\n     */\n    run(gpu, inputTexture)\n    {\n        // run decorated algorithm (e.g., feature detection)\n        const detectedKeypoints = this.decoratedAlgorithm.run(gpu, inputTexture);\n\n        // run feature description algorithm\n        return this._describe(gpu, inputTexture, detectedKeypoints);\n    }\n\n    /**\n     * Download feature points from the GPU\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} encodedKeypoints tiny texture with encoded keypoints\n     * @param {FeatureDownloaderFlag} [flags] will be passed to the downloader\n     * @returns {SpeedyPromise<SpeedyFeature[]>}\n     */\n    download(gpu, encodedKeypoints, flags = 0)\n    {\n        return super.download(gpu, encodedKeypoints, flags).then(\n            keypoints => this._postProcess(keypoints)\n        );\n    }\n\n    /**\n     * Describe feature points\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture pre-processed greyscale image\n     * @param {SpeedyTexture} detectedKeypoints tiny texture with appropriate size for the descriptors\n     * @returns {SpeedyTexture} tiny texture with encoded keypoints & descriptors\n     */\n    _describe(gpu, inputTexture, detectedKeypoints)\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Post-process the keypoints after downloading them\n     * @param {SpeedyFeature[]} keypoints\n     * @returns {SpeedyFeature[]}\n     */\n    _postProcess(keypoints)\n    {\n        //return keypoints;\n        throw new AbstractMethodError();\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * feature-detection-algorithm.js\n * Feature detection & description: abstract class\n */\n\nimport { AbstractMethodError } from '../../utils/errors';\nimport { FeatureAlgorithm } from './feature-algorithm';\nimport { FeatureDownloader } from './feature-downloader';\nimport { SpeedyFeature } from '../speedy-feature';\nimport { SpeedyGPU } from '../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../gpu/speedy-texture';\nimport { SpeedyPromise } from '../../utils/speedy-promise';\n\n// Constants\n\n/**\n * Enhancements\n * @typedef {object} FeatureDetectionEnhancements\n * @property {number} gain contrast stretching, typically in [0,1]\n * @property {number} offset global brightness, typically in [0,1]\n * @property {number} decay from the center, in [0,1]\n * @property {string} quality filter quality ('high' | 'medium' | 'low')\n */\nconst DEFAULT_ENHANCEMENTS = Object.freeze({\n    gain: 0.9,\n    offset: 0.5,\n    decay: 0.0,\n    quality: 'low'\n});\n\n/**\n * An abstract class for feature\n * detection & description\n * @abstract\n */\nexport class FeatureDetectionAlgorithm extends FeatureAlgorithm\n{\n    /**\n     * Class constructor\n     */\n    constructor()\n    {\n        super(0, 0);\n\n        /** @type {FeatureDetectionEnhancements|null} */\n        this._enhancements = null;\n\n        /** @type {FeatureDownloader} */\n        this._downloader = new FeatureDownloader();\n    }\n\n    /**\n     * To \"run\" this algorithm means: to detect feature points\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture pre-processed greyscale image\n     * @returns {SpeedyTexture} tiny texture with encoded keypoints\n     */\n    run(gpu, inputTexture)\n    {\n        const enhancedInputTexture = this._enhanceTexture(gpu, inputTexture);\n        return this._detect(gpu, enhancedInputTexture);\n    }\n\n    /**\n     * Download feature points from the GPU\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} encodedKeypoints tiny texture with encoded keypoints\n     * @param {FeatureDownloaderFlag} [flags] will be passed to the downloader\n     * @returns {SpeedyPromise<SpeedyFeature[]>}\n     */\n    download(gpu, encodedKeypoints, flags = 0)\n    {\n        return this._downloader.download(gpu, encodedKeypoints, this.descriptorSize, this.extraSize, flags);\n    }\n\n    /**\n     * Size of the keypoint encoder texture\n     * @returns {number}\n     */\n    get encoderLength()\n    {\n        return this._downloader.encoderLength;\n    }\n\n    /**\n     * The feature downloader\n     * @returns {FeatureDownloader}\n     */\n    get downloader()\n    {\n        return this._downloader;\n    }\n\n    /**\n     * Setup enhancements to be applied when detecting features\n     * @param {FeatureDetectionEnhancements|boolean} [enhancements] fix irregular lighting in the scene?\n     */\n    setEnhancements(enhancements)\n    {\n        if(enhancements === true)\n            this._enhancements = DEFAULT_ENHANCEMENTS;\n        else if(typeof enhancements === 'object' && enhancements !== null)\n            this._enhancements = Object.assign({ }, DEFAULT_ENHANCEMENTS, enhancements);\n        else\n            this._enhancements = null;\n    }\n\n    /**\n     * Detect feature points\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture pre-processed greyscale image\n     * @returns {SpeedyTexture} tiny texture with encoded keypoints\n     */\n    _detect(gpu, inputTexture)\n    {\n        // This must be implemented in subclasses\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Enhances a texture specifically for feature detection\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture\n     * @returns {SpeedyTexture}\n     */\n    _enhanceTexture(gpu, inputTexture)\n    {\n        let texture = inputTexture;\n        const options = this._enhancements;\n\n        if(options !== null) {\n            texture = gpu.programs.enhancements.nightvision(texture, options.gain, options.offset, options.decay, options.quality, true);\n            texture = gpu.programs.filters.gauss3(texture); // blur a bit more\n        }\n\n        return texture;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * feature-downloader.js\n * Download features from the GPU\n */\n\nimport { FeatureEncoder } from './feature-encoder';\nimport { SpeedyFeature } from '../speedy-feature';\nimport { SpeedyGPU } from '../../gpu/speedy-gpu';\nimport { SpeedyPromise } from '../../utils/speedy-promise';\nimport { IllegalOperationError } from '../../utils/errors';\nimport { Utils } from '../../utils/utils';\nimport {\n    INITIAL_ENCODER_LENGTH,\n    KPF_DISCARD,\n} from '../../utils/globals';\n\n// constants\nconst INITIAL_KEYPOINTS_GUESS = FeatureEncoder.capacity(0, 0, INITIAL_ENCODER_LENGTH); // a guess about the initial number of keypoints\nconst INITIAL_FILTER_GAIN = 0.85; // a number in [0,1]\nconst MIN_KEYPOINTS = 32; // at any point in time, the encoder will have space for\n                          // at least this number of keypoints\n\n\n\n\n/**\n * A filter used to estimate the future number of\n * keypoints given past measurements\n */\nclass FeatureCountEstimator\n{\n    /**\n     * Class constructor\n     */\n    constructor()\n    {\n        this._gain = INITIAL_FILTER_GAIN;\n        this._state = INITIAL_KEYPOINTS_GUESS;\n        this._prevState = this._state;\n    }\n\n    /**\n     * Estimate the number of keypoints on the next time-step\n     * @param {number} measurement\n     * @returns {number}\n     */\n    estimate(measurement)\n    {\n        // extrapolate the current state\n        const prediction = Math.max(0, this._state + (this._state - this._prevState));\n    \n        // estimate the new state\n        const gain = this._gain; // do we trust more the prediction or the measurement?\n        const newState = prediction + gain * (measurement - prediction);\n\n        // update gain\n        this._gain = Math.min(INITIAL_FILTER_GAIN, this._gain + 0.3);\n\n        // testing\n        /*\n        this._cnt = Math.round(measurement - this._state) >= 1 ? (this._cnt||0) + 1 : 0;\n        const diff = Math.abs(Math.round(measurement - this._state));\n        const ratio = measurement / this._state-1;\n        console.log(JSON.stringify({\n            gain,\n            prediction: Math.round(prediction),\n            newState: Math.round(newState),\n            measurement,\n            diff,\n            ratio: Math.round(100*ratio)+'%'\n        }).replace(/,/g,',\\n'));\n        if(ratio+1 > this.maxGrowth) console.log('maxGrowth exceeded!');\n        */\n\n        // save state\n        this._prevState = this._state;\n        this._state = newState;\n\n        // return\n        return Math.round(this._state);\n    }\n\n    /**\n     * Reset the filter to its initial state\n     */\n    reset()\n    {\n        // trust the prediction, not the measurement\n        this._gain = 0;\n\n        // reset state & prev state\n        this._state = this._prevState = INITIAL_KEYPOINTS_GUESS;\n    }\n\n    /**\n     * We expect measurement <= maxGrowth * previousState\n     * to be true (almost) all the time, so we can\n     * accomodate the encoder\n     * @returns {number} greater than 1\n     */\n    get maxGrowth()\n    {\n        // If you increase this number, you'll get\n        // more robust responses to abrupt and significant\n        // increases in the number of keypoints, but you'll\n        // also increase the amount of data going back and\n        // forth from the GPU, thus impacting performance.\n        // We would like to keep this value low.\n        return 1.5;\n    }\n}\n\n\n\n/**\n * The FeatureDownloader receives a texture of encoded\n * keypoints and returns a corresponding array of keypoints\n */\nexport class FeatureDownloader\n{\n    /**\n     * Class constructor\n     */\n    constructor()\n    {\n        /** @type {number} size of the keypoint encoder texture */\n        this._encoderLength = INITIAL_ENCODER_LENGTH;\n\n        /** @type {FeatureCountEstimator} used to estimate the future number of keypoints */\n        this._estimator = new FeatureCountEstimator();\n    }\n\n    /**\n     * Download feature points from the GPU\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} encodedKeypoints tiny texture with encoded keypoints\n     * @param {number} descriptorSize in bytes (set it to zero if there is no descriptor)\n     * @param {number} extraSize in bytes (set it to zero if there is no extra data)\n     * @param {FeatureDownloaderFlag} [flags] used to modify the behavior of the downloader\n     * @returns {SpeedyPromise<SpeedyFeature[]>}\n     */\n    download(gpu, encodedKeypoints, descriptorSize, extraSize, flags = 0)\n    {\n        // validate the input texture\n        Utils.assert(encodedKeypoints.width === encodedKeypoints.height);\n        Utils.assert(encodedKeypoints.width === this._encoderLength);\n\n        // reset the capacity of the downloader\n        if(flags & FeatureDownloader.RESET_DOWNLOADER_STATE != 0) {\n            this._estimator.reset();\n            //this._encoderLength = INITIAL_ENCODER_LENGTH; // no need\n        }\n\n        // download keypoints\n        const useBufferedDownloads = (flags & FeatureDownloader.USE_BUFFERED_DOWNLOADS) != 0;\n        return gpu.programs.encoders.downloadEncodedKeypoints(encodedKeypoints, useBufferedDownloads).then(data => {\n\n            // decode the keypoints\n            const encoderLength = encodedKeypoints.width;\n            const multiplier = (flags & FeatureDownloader.SUPPRESS_DESCRIPTORS) != 0 ? 0 : 1;\n            const keypoints = FeatureEncoder.decode(data, descriptorSize * multiplier, extraSize, encoderLength);\n\n            // how many keypoints do we expect in the next frame?\n            const discardedCount = this._countDiscardedKeypoints(keypoints);\n            const nextCount = this._estimator.estimate(keypoints.length - discardedCount);\n\n            // optimize the keypoint encoder\n            // add slack (maxGrowth) to accomodate for abrupt changes in the number of keypoints\n            const capacity = Math.max(nextCount, MIN_KEYPOINTS);\n            const extraCapacity = this._estimator.maxGrowth * capacity;\n            this._encoderLength = FeatureEncoder.minLength(extraCapacity, descriptorSize, extraSize);\n\n            // done!\n            return keypoints;\n\n        }).catch(err => {\n            throw new IllegalOperationError(`Can't download keypoints`, err);\n        });\n    }\n\n    /**\n     * Size of the keypoint encoder texture\n     * @returns {number}\n     */\n    get encoderLength()\n    {\n        return this._encoderLength;\n    }\n\n    /**\n     * Ensures that encoderLength is large enough to handle a\n     * particular configuration of the keypoint encoder\n     * @param {number} keypointCount integer\n     * @param {number} descriptorSize in bytes\n     * @param {number} extraSize in bytes\n     * @param {boolean} [tight] make it a tight fit (i.e., remove any slack)\n     */\n    reserveSpace(keypointCount, descriptorSize, extraSize, tight = false)\n    {\n        const e = FeatureEncoder.minLength(keypointCount, descriptorSize, extraSize);\n        this._encoderLength = tight ? e : Math.max(this._encoderLength, e);\n    }\n\n    /**\n     * Count keypoints that should be discarded\n     * @param {SpeedyFeature[]} keypoints\n     */\n    _countDiscardedKeypoints(keypoints)\n    {\n        let i, count = 0;\n\n        for(i = keypoints.length - 1; i >= 0; i--)\n            count += ((keypoints[i].flags & KPF_DISCARD) != 0) | 0;\n\n        return count;\n    }\n\n\n\n    /**\n     * Flags accepted by the FeatureDownloader (bitwise)\n     * @typedef {number} FeatureDownloaderFlag\n     */\n\n    /**\n     * Flag: reset the state of the downloader\n     * @returns {FeatureDownloaderFlag}\n     */\n    static get RESET_DOWNLOADER_STATE()\n    {\n        return 1;\n    }\n\n    /**\n     * Flag: use buffered downloads\n     * It's an optimization technique that implies a 1-frame delay\n     * in the downloads when using async transfers; it may or may\n     * not be acceptable, depending on what you're trying to do\n     * @returns {FeatureDownloaderFlag}\n     */\n    static get USE_BUFFERED_DOWNLOADS()\n    {\n        return 2;\n    }\n\n    /**\n     * Flag: suppress feature descriptors\n     * This is meant to improve download times. Use if the\n     * descriptors are not needed by the end-user\n     * @returns {FeatureDownloaderFlag}\n     */\n    static get SUPPRESS_DESCRIPTORS()\n    {\n        return 4;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * feature-encoder.js\n * Utilities related to the encoding of feature points in a texture\n */\n\nimport { SpeedyFeature } from '../speedy-feature';\nimport {\n    MIN_KEYPOINT_SIZE,\n    FIX_RESOLUTION,\n    LOG2_PYRAMID_MAX_SCALE, PYRAMID_MAX_LEVELS,\n    KPF_ORIENTED,\n} from '../../utils/globals';\n\n// Constants\nconst MIN_ENCODER_LENGTH = Math.ceil(Math.sqrt(MIN_KEYPOINT_SIZE / 4)); // Minimum size of the keypoint encoder, in pixels\nconst MAX_ENCODER_LENGTH = 300; // Maximum size of the keypoint encoder - make it too large, and you may get a crash (WebGL context lost)\n\n/**\n * Utilities related to the encoding of feature points in a texture\n */\nexport class FeatureEncoder\n{\n    /**\n     * The minimum encoder length for a set of keypoints\n     * @param {number} keypointCount integer\n     * @param {number} descriptorSize in bytes\n     * @param {number} extraSize in bytes\n     * @returns {number}\n     */\n    static minLength(keypointCount, descriptorSize, extraSize)\n    {\n        const pixelsPerKeypoint = Math.ceil((MIN_KEYPOINT_SIZE + descriptorSize + extraSize) / 4);\n        const clampedKeypointCount = Math.max(0, Math.ceil(keypointCount));\n        const len = Math.ceil(Math.sqrt(clampedKeypointCount * pixelsPerKeypoint));\n\n        return Math.max(MIN_ENCODER_LENGTH, Math.min(len, MAX_ENCODER_LENGTH));\n    }\n\n    /**\n     * The maximum number of keypoints we can store using\n     * a particular configuration of a keypoint encoder\n     * @param {number} descriptorSize in bytes\n     * @param {number} extraSize in bytes\n     * @param {number} encoderLength\n     */\n    static capacity(descriptorSize, extraSize, encoderLength)\n    {\n        const pixelsPerKeypoint = Math.ceil((MIN_KEYPOINT_SIZE + descriptorSize + extraSize) / 4);\n        const numberOfPixels = encoderLength * encoderLength;\n\n        return Math.floor(numberOfPixels / pixelsPerKeypoint);\n    }\n\n    /**\n     * Decode a sequence of keypoints, given a flattened\n     * image of encoded pixels\n     * @param {Uint8Array[]} pixels pixels in the [r,g,b,a,...] format\n     * @param {number} descriptorSize in bytes\n     * @param {number} extraSize in bytes\n     * @param {number} encoderLength\n     * @returns {SpeedyFeature[]} keypoints\n     */\n    static decode(pixels, descriptorSize, extraSize, encoderLength)\n    {\n        const pixelsPerKeypoint = Math.ceil((MIN_KEYPOINT_SIZE + descriptorSize + extraSize) / 4);\n        let x, y, lod, rotation, score, flags, extraBytes, descriptorBytes;\n        let hasLod, hasRotation;\n        const keypoints = [];\n\n        // how many bytes should we read?\n        const e = encoderLength;\n        const e2 = e * e * pixelsPerKeypoint * 4;\n        const size = Math.min(pixels.length, e2);\n\n        // copy the data (we use shared buffers when receiving pixels[])\n        if(descriptorSize + extraSize > 0)\n            pixels = new Uint8Array(pixels);\n\n        // for each encoded keypoint\n        for(let i = 0; i < size; i += 4 /* RGBA */ * pixelsPerKeypoint) {\n            // extract fixed-point coordinates\n            x = (pixels[i+1] << 8) | pixels[i];\n            y = (pixels[i+3] << 8) | pixels[i+2];\n            if(x >= 0xFFFF && y >= 0xFFFF) // if end of list\n                break;\n\n            // We've cleared the texture to black.\n            // Likely to be incorrect black pixels\n            // due to resize. Bad for encoderLength\n            if(x + y == 0 && pixels[i+6] == 0)\n                continue; // discard, it's noise\n\n            // convert from fixed-point\n            x /= FIX_RESOLUTION;\n            y /= FIX_RESOLUTION;\n\n            // extract flags\n            flags = pixels[i+7];\n\n            // extract LOD\n            hasLod = (pixels[i+4] < 255);\n            lod = !hasLod ? 0.0 :\n                -LOG2_PYRAMID_MAX_SCALE + (LOG2_PYRAMID_MAX_SCALE + PYRAMID_MAX_LEVELS) * pixels[i+4] / 255.0;\n\n            // extract orientation\n            hasRotation = (flags & KPF_ORIENTED != 0);\n            rotation = !hasRotation ? 0.0 :\n                ((2 * pixels[i+5]) / 255.0 - 1.0) * Math.PI;\n\n            // extract score\n            score = pixels[i+6] / 255.0;\n\n            // extra bytes\n            extraBytes = pixels.subarray(8 + i, 8 + i + extraSize);\n\n            // descriptor bytes\n            descriptorBytes = pixels.subarray(8 + i + extraSize, 8 + i + extraSize + descriptorSize);\n\n            // something is off here\n            if(descriptorBytes.length < descriptorSize || extraBytes.length < extraSize)\n                continue; // discard\n\n            // register keypoint\n            keypoints.push(\n                new SpeedyFeature(x, y, lod, rotation, score, flags, extraBytes, descriptorBytes)\n            );\n        }\n\n        // done!\n        return keypoints;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * feature-tracking-algorithm.js\n * Abstract feature tracking algorithm\n */\n\nimport { SpeedyGPU } from '../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../gpu/speedy-texture';\nimport { AbstractMethodError } from '../../utils/errors';\nimport { FeatureAlgorithm } from './feature-algorithm';\nimport { FeatureDownloader } from './feature-downloader';\nimport { FeatureEncoder } from './feature-encoder';\nimport { SpeedyFeature } from '../speedy-feature';\nimport { SpeedyPromise } from '../../utils/speedy-promise';\nimport { Utils } from '../../utils/utils';\n\n/**\n * Abstract feature tracking algorithm\n * @abstract\n */\nexport class FeatureTrackingAlgorithm extends FeatureAlgorithm\n{\n    /**\n     * Class constructor\n     */\n    constructor()\n    {\n        super(0, 0);\n\n        /** @type {SpeedyTexture} previous image */\n        this._prevImage = null;\n\n        /** @type {SpeedyTexture} tiny texture with encoded keypoints */\n        this._prevKeypoints = null;\n\n        /** @type {FeatureDownloader} keypoint downloader */\n        this._downloader = new FeatureDownloader();\n    }\n\n    /**\n     * To \"run\" this algorithm means: to track feature points\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture pre-processed greyscale image (nextImage)\n     * @returns {SpeedyTexture} tiny texture with encoded keypoints (the result of tracking)\n     */\n    run(gpu, inputTexture)\n    {\n        return this._track(gpu, inputTexture);\n    }\n\n    /**\n     * Get previous image (time: t-1)\n     * @returns {SpeedyTexture}\n     */\n    get prevImage()\n    {\n        return this._prevImage;\n    }\n\n    /**\n     * Set previous image (time: t-1)\n     * @param {SpeedyTexture} texture\n     */\n    set prevImage(texture)\n    {\n        this._prevImage = texture;\n    }\n\n    /**\n     * Get previous keypoints (time: t-1)\n     * as a tiny texture with encoded data\n     * @returns {SpeedyTexture}\n     */\n    get prevKeypoints()\n    {\n        return this._prevKeypoints;\n    }\n\n    /**\n     * Set previous keypoints (time: t-1)\n     * as a tiny texture with encoded data\n     * @param {SpeedyTexture} texture\n     */\n    set prevKeypoints(texture)\n    {\n        this._prevKeypoints = texture;\n    }\n\n    /**\n     * Download feature points from the GPU\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} encodedKeypoints tiny texture with encoded keypoints\n     * @param {FeatureDownloaderFlag} [flags] will be passed to the downloader\n     * @returns {SpeedyPromise<SpeedyFeature[]>}\n     */\n    download(gpu, encodedKeypoints, flags = 0)\n    {\n        if(flags & FeatureDownloader.USE_BUFFERED_DOWNLOADS != 0)\n            Utils.warning(`Feature trackers shouldn't use buffered downloads`);\n\n        return this._downloader.download(gpu, encodedKeypoints, this.descriptorSize, this.extraSize, flags);\n    }\n\n    /**\n     * Size of the keypoint encoder texture\n     * @returns {number}\n     */\n    get encoderLength()\n    {\n        return this._downloader.encoderLength;\n    }\n\n    /**\n     * The feature downloader\n     * @returns {FeatureDownloader}\n     */\n    get downloader()\n    {\n        return this._downloader;\n    }\n\n    /**\n     * Upload feature points to the GPU\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyFeature[]} keypoints feature points\n     * @returns {SpeedyTexture} tiny texture\n     */\n    upload(gpu, keypoints)\n    {\n        const encoderLength = FeatureEncoder.minLength(keypoints.length, this.descriptorSize, this.extraSize);\n        return gpu.programs.encoders.uploadKeypointsOld(keypoints, this.descriptorSize, this.extraSize, encoderLength);\n    }\n\n    /**\n     * Track a set of feature points\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} nextImage next image (time: t)\n     * @returns {SpeedyTexture} nextKeypoints tiny texture with encoded keypoints (time: t)\n     */\n    _track(gpu, nextImage)\n    {\n        throw new AbstractMethodError();\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * lk.js\n * Lucas-Kanade feature tracker in a pyramid\n */\n\nimport { SpeedyGPU } from '../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../gpu/speedy-texture';\nimport { FeatureTrackingAlgorithm } from '../feature-tracking-algorithm';\nimport { Utils } from '../../../utils/utils';\nimport { PYRAMID_MAX_LEVELS } from '../../../utils/globals';\n\n// Constants\nconst DEFAULT_WINDOW_SIZE = 15;\nconst DEFAULT_DEPTH = Math.min(6, PYRAMID_MAX_LEVELS);\nconst DEFAULT_NUMBER_OF_ITERATIONS = 5;\nconst DEFAULT_DISCARD_THRESHOLD = 0.0001;\nconst DEFAULT_EPSILON = 0.01;\n\n/**\n * Lucas-Kanade feature tracker in a pyramid\n */\nexport class LKFeatureTrackingAlgorithm extends FeatureTrackingAlgorithm\n{\n    /**\n     * Constructor\n     */\n    constructor()\n    {\n        super();\n        this._windowSize = DEFAULT_WINDOW_SIZE;\n        this._depth = DEFAULT_DEPTH;\n        this._numberOfIterations = DEFAULT_NUMBER_OF_ITERATIONS;\n        this._discardThreshold = DEFAULT_DISCARD_THRESHOLD;\n        this._epsilon = DEFAULT_EPSILON;\n    }\n\n    /**\n     * Get neighborhood size\n     * @returns {number}\n     */\n    get windowSize()\n    {\n        return this._windowSize;\n    }\n\n    /**\n     * Set neighborhood size\n     * @param {number} value positive odd number\n     */\n    set windowSize(value)\n    {\n        this._windowSize = value | 0;\n        Utils.assert(this._windowSize % 2 === 1 && this._windowSize >= 1);\n    }\n\n    /**\n     * Get depth, i.e., how many pyramid levels will be scanned\n     * @returns {number}\n     */\n    get depth()\n    {\n        return this._depth;\n    }\n\n    /**\n     * Set depth, i.e., how many pyramid levels will be scanned\n     * @param {number} value positive integer (1, 2, 3, 4...)\n     */\n    set depth(value)\n    {\n        this._depth = value | 0;\n        Utils.assert(this._depth >= 1 && this._depth <= PYRAMID_MAX_LEVELS);\n    }\n\n    /**\n     * Get the maximum number of iterations of the pyramidal LK algorithm\n     * @returns {number}\n     */\n    get numberOfIterations()\n    {\n        return this._numberOfIterations;\n    }\n\n    /**\n     * Set the maximum number of iterations of the pyramidal LK algorithm\n     * @param {number} value\n     */\n    set numberOfIterations(value)\n    {\n        this._numberOfIterations = value | 0;\n        Utils.assert(this._numberOfIterations >= 1);\n    }\n\n    /**\n     * Get the discard threshold, used to discard \"bad\" keypoints\n     * @returns {number}\n     */\n    get discardThreshold()\n    {\n        return this._discardThreshold;\n    }\n\n    /**\n     * Set the discard threshold, used to discard \"bad\" keypoints\n     * @param {number} value typically 10^(-4) - increase to discard more\n     */\n    set discardThreshold(value)\n    {\n        this._discardThreshold = +value;\n        Utils.assert(this._discardThreshold >= 0);\n    }\n\n    /**\n     * Get the accuracy threshold, used to stop LK iterations\n     * @returns {number}\n     */\n    get epsilon()\n    {\n        return this._epsilon;\n    }\n\n    /**\n     * Get the accuracy threshold, used to stop LK iterations\n     * @param {number} value typically 0.01\n     */\n    set epsilon(value)\n    {\n        this._epsilon = +value;\n        Utils.assert(this._epsilon >= 0);\n    }\n\n    /**\n     * Track a set of feature points\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} nextImage next image (time: t)\n     * @returns {SpeedyTexture} nextKeypoints tiny texture with encoded keypoints (time: t)\n     */\n    _track(gpu, nextImage)\n    {\n        const prevImage = this.prevImage;\n        const prevKeypoints = this.prevKeypoints;\n        const descriptorSize = this.descriptorSize;\n        const extraSize = this.extraSize;\n        const encoderLength = this.encoderLength;\n        const windowSize = this.windowSize;\n        const depth = this.depth;\n        const numberOfIterations = this.numberOfIterations;\n        const discardThreshold = this.discardThreshold;\n        const epsilon = this.epsilon;\n\n        // create pyramids\n        const nextPyramid = nextImage.generateMipmaps();\n        const prevPyramid = prevImage.generateMipmaps();\n\n        // track feature points\n        return gpu.programs.trackers.lk(nextPyramid, prevPyramid, prevKeypoints, windowSize, depth, numberOfIterations, discardThreshold, epsilon, descriptorSize, extraSize, encoderLength);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * bound-matrix-operation.js\n * Bound matrix operations\n */\n\nimport { MatrixOperation, MatrixOperationWithSubroutine, MatrixOperationSequence } from './matrix-operations';\nimport { SpeedyPromise } from '../../utils/speedy-promise';\nimport { SpeedyMatrix } from './matrix';\nimport { Utils } from '../../utils/utils';\n\n/**\n * A MatrixOperation bound with input & output matrices\n */\nexport class BoundMatrixOperation\n{\n    /**\n     * Constructor\n     * @param {?MatrixOperation} operation if null, this is just a helper no-op\n     * @param {SpeedyMatrix} outputMatrix\n     * @param {SpeedyMatrix[]} inputMatrices\n     */\n    constructor(operation, outputMatrix, inputMatrices)\n    {\n        /** @type {?MatrixOperation} matrix operation */\n        this.operation = operation;\n\n        /** @type {SpeedyMatrix} output matrix */\n        this.outputMatrix = outputMatrix;\n\n        /** @type {SpeedyMatrix[]} input matrices */\n        this.inputMatrices = inputMatrices;\n\n        // validate\n        if(this.operation !== null)\n            Utils.assert(this.operation.numberOfInputMatrices() === this.inputMatrices.length);\n\n        // make it immutable\n        return Object.freeze(this);\n    }\n}\n\n/**\n * A tree of bound matrix operations\n */\nexport class BoundMatrixOperationTree\n{\n    /**\n     * Constructor\n     * @param {?MatrixOperation} operation operation of this node\n     * @param {SpeedyMatrix} outputMatrix output of this operation tree\n     * @param {BoundMatrixOperationTree[]} [children] child nodes\n     * @param {BoundMatrixOperationTree[]} [subroutines] callbacks\n     */\n    constructor(operation, outputMatrix, children = [], subroutines = [])\n    {\n        /** @type {BoundMatrixOperation} operation of this node */\n        this._boundOperation = new BoundMatrixOperation(\n            operation, // if operation is null, this is just an empty node to help construct the tree\n            outputMatrix,\n            children.map(child => child._boundOperation.outputMatrix)\n        );\n\n        /** @type {BoundMatrixOperationTree[]} child nodes */\n        this._children = children;\n\n        /** @type {Array<pair<string,BoundMatrixOperationTree>>} subroutines are packed within this node */\n        this._subroutines = subroutines;\n\n        // make it immutable\n        return Object.freeze(this);\n    }\n\n    /**\n     * The operation associated with this node of the tree\n     * @returns {MatrixOperation}\n     */\n    get operation()\n    {\n        return this._boundOperation.operation;\n    }\n\n    /**\n     * The output matrix of this node of the tree\n     * @returns {SpeedyMatrix}\n     */\n    get outputMatrix()\n    {\n        return this._boundOperation.outputMatrix;\n    }\n\n    /**\n     * Pack the tree into a single BoundMatrixOperation\n     * @returns {BoundMatrixOperation}\n     */\n    pack()\n    {\n        const matrices = []; // matrices of the ENTIRE tree\n        const stack = [ [ this, false ] ];\n        const steps = [];\n\n        // transform the tree into a sequence of operations\n        while(stack.length > 0) {\n            const [ node, done ] = stack.pop();\n            if(!done) {\n                // visit children (in increasing order)\n                stack.push([ node, true ]);\n                for(let i = node._children.length - 1; i >= 0; i--)\n                    stack.push([ node._children[i], false ]);\n            }\n            else if(node._boundOperation.operation !== null) {\n                // visit this node (we skip it if the operation is null)\n                const { operation, outputMatrix, inputMatrices } = node._boundOperation;\n                const indexOfOutputMatrix = this._findOrAdd(matrices, outputMatrix);\n                const indicesOfInputMatrices = inputMatrices.map(inputMatrix => this._findOrAdd(matrices, inputMatrix));\n\n                // the operation of this node contains other operations\n                for(let i = node._subroutines.length - 1; i >= 0; i--) {\n                    const [ subname, subtree ] = node._subroutines[i];\n                    const sub = subtree.pack();\n                    const remap = mat => this._findOrAdd(indicesOfInputMatrices, this._findOrAdd(matrices, mat));\n                    sub.operation.adjustIndices(remap, sub.inputMatrices);\n                    operation.setStepsOf(subname, sub.operation.steps());\n                }\n\n                // this node becomes a step in a sequence of operations\n                const step = MatrixOperationSequence.step(operation, indexOfOutputMatrix, indicesOfInputMatrices)\n                step.header.updateMetadata(outputMatrix, inputMatrices);\n                steps.push(step);\n            }\n        }\n\n        // bind the sequence of operations to the appropriate matrices\n        return new BoundMatrixOperation(\n            new MatrixOperationSequence(\n                matrices.length,\n                this.outputMatrix.shape,\n                steps\n            ),\n            this.outputMatrix,\n            matrices\n        );\n    }\n\n    /**\n     * Find an element in an array. If it doesn't exist, add it.\n     * @param {Array} array\n     * @param {object|number} element\n     * @return {number} index of the element in the array\n     */\n    _findOrAdd(array, element)\n    {\n        Utils.assert(element !== undefined);\n        const idx = array.lastIndexOf(element);\n        return idx >= 0 ? idx : array.push(element) - 1;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * basic.js\n * Basic matrix operations\n */\n\n/**\n * No-operation\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs\n */\nexport function nop(header, output, inputs)\n{\n}\n\n/**\n * Fill the matrix with a constant value\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs\n */\nexport function fill(header, output, inputs)\n{\n    const { rows, columns, stride } = header;\n    const { value } = header.custom;\n    const length = output.length;\n\n    // use a memset-like operation if possible\n    if(rows * columns == length) {\n        output.fill(value, 0, length);\n        return;\n    }\n\n    // fill the columns one by one\n    for(let j = 0; j < columns; j++)\n        output.fill(value, j * stride, j * stride + rows);\n}\n\n/**\n * Copy matrix\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs\n */\nexport function copy(header, output, inputs)\n{\n    const { rows, columns, stride } = header;\n    const [ istride ] = header.strideOfInputs;\n    const [ input ] = inputs;\n    const length = output.length;\n\n    // use a memcpy-like operation if possible\n    if(length == header.lengthOfInputs[0] && rows * columns == length) {\n        output.set(input, 0, length);\n        return;\n    }\n\n    // copy values one by one\n    let i, j, oj, ij;\n    for(oj = ij = j = 0; j < columns; j++, oj += stride, ij += istride) {\n        for(i = 0; i < rows; i++)\n            output[oj + i] = input[ij + i];\n    }\n}\n\n/**\n * Transpose matrix\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs\n */\nexport function transpose(header, output, inputs)\n{\n    const { rows, columns, stride } = header;\n    const [ strideT ] = header.strideOfInputs;\n    const [ input ] = inputs;\n\n    let i, j, ii, oj;\n    for(ii = i = 0; i < rows; i++, ii += strideT) {\n        for(oj = j = 0; j < columns; j++, oj += stride)\n            output[oj + i] = input[ii + j];\n    }\n}\n\n/**\n * Add two matrices\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs\n */\nexport function add(header, output, inputs)\n{\n    const { rows, columns, stride } = header;\n    const [ strideA, strideB ] = header.strideOfInputs;\n    const [ a, b ] = inputs;\n\n    let i, j, oj, aj, bj;\n    for(aj = bj = oj = j = 0; j < columns; j++, oj += stride, bj += strideB, aj += strideA) {\n        for(i = 0; i < rows; i++)\n            output[oj + i] = a[aj + i] + b[bj + i];\n    }\n}\n\n/**\n * Subtract two matrices\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs\n */\nexport function subtract(header, output, inputs)\n{\n    const { rows, columns, stride } = header;\n    const [ strideA, strideB ] = header.strideOfInputs;\n    const [ a, b ] = inputs;\n\n    let i, j, oj, aj, bj;\n    for(aj = bj = oj = j = 0; j < columns; j++, oj += stride, bj += strideB, aj += strideA) {\n        for(i = 0; i < rows; i++)\n            output[oj + i] = a[aj + i] - b[bj + i];\n    }\n}\n\n/**\n * Multiply two matrices (e.g., C = A B)\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs\n */\nexport function multiply(header, output, inputs)\n{\n    const { rows, columns, stride } = header;\n    const [ columnsA, columnsB ] = header.columnsOfInputs;\n    const [ strideA, strideB ] = header.strideOfInputs;\n    const [ a, b ] = inputs;\n    const length = output.length;\n\n    // clear matrix\n    if(rows * columns != length) {\n        for(let c = 0; c < columns; c++)\n            output.fill(0, c * stride, c * stride + rows);\n    }\n    else\n        output.fill(0, 0, length);\n\n    // multiply taking cache locality into account\n    let i, j, k, ok, aj, bk, bjk;\n    for(ok = bk = k = 0; k < columnsB; k++, ok += stride, bk += strideB) {\n        for(aj = j = 0; j < columnsA; j++, aj += strideA) {\n            bjk = b[bk + j];\n            for(i = 0; i < rows; i++)\n                output[ok + i] += a[aj + i] * bjk;\n        }\n    }\n}\n\n/**\n * Multiply two matrices, transposing the left operand\n * (e.g., C = A^T B)\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs\n */\nexport function multiplylt(header, output, inputs)\n{\n    const { rows, columns, stride } = header;\n    const [ columnsA, columnsB ] = header.columnsOfInputs;\n    const [ rowsA, rowsB ] = header.rowsOfInputs;\n    const [ strideA, strideB ] = header.strideOfInputs;\n    const [ a, b ] = inputs;\n\n    // multiply taking cache locality into account\n    let i, j, k, aj, bk, ok, ojk;\n    for(ok = bk = k = 0; k < columnsB; k++, ok += stride, bk += strideB) {\n        for(aj = j = 0; j < columnsA; j++, aj += strideA) {\n            output[ojk = ok + j] = 0;\n            for(i = 0; i < rowsB; i++)\n                output[ojk] += a[aj + i] * b[bk + i];\n        }\n    }\n}\n\n/**\n * Multiply two matrices, transposing the right operand\n * (e.g., C = A B^T)\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs\n */\nexport function multiplyrt(header, output, inputs)\n{\n    const { rows, columns, stride } = header;\n    const [ columnsA, columnsB ] = header.columnsOfInputs;\n    const [ rowsA, rowsB ] = header.rowsOfInputs;\n    const [ strideA, strideB ] = header.strideOfInputs;\n    const [ a, b ] = inputs;\n    const length = output.length;\n\n    // clear matrix\n    if(rows * columns != length) {\n        for(let c = 0; c < columns; c++)\n            output.fill(0, c * stride, c * stride + rows);\n    }\n    else\n        output.fill(0, 0, length);\n\n    // multiply taking cache locality into account\n    let i, j, k, ok, aj, bj, bkj;\n    for(aj = bj = j = 0; j < columnsA; j++, aj += strideA, bj += strideB) {\n        for(ok = k = 0; k < rowsB; k++, ok += stride) {\n            bkj = b[bj + k];\n            for(i = 0; i < rows; i++)\n                output[ok + i] += a[aj + i] * bkj;\n        }\n    }\n}\n\n/**\n * Fast multiplication of two 3x3 matrices (A * B)\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs\n */\nexport function multiply3(header, output, inputs)\n{\n    const { stride } = header;\n    const [ matA, matB ] = inputs;\n    const [ sa, sb ] = header.strideOfInputs;\n    const sa2 = sa + sa, sb2 = sb + sb;\n    const stride2 = stride + stride;\n    const a = matA[0], b = matA[0 + sa], c = matA[0 + sa2],\n          d = matA[1], e = matA[1 + sa], f = matA[1 + sa2],\n          g = matA[2], h = matA[2 + sa], i = matA[2 + sa2],\n          j = matB[0], k = matB[0 + sb], l = matB[0 + sb2],\n          m = matB[1], n = matB[1 + sb], o = matB[1 + sb2],\n          p = matB[2], q = matB[2 + sb], r = matB[2 + sb2];\n\n    output[0] = a*j + b*m + c*p;\n    output[1] = d*j + e*m + f*p;\n    output[2] = g*j + h*m + i*p;\n\n    output[0 + stride] = a*k + b*n + c*q;\n    output[1 + stride] = d*k + e*n + f*q;\n    output[2 + stride] = g*k + h*n + i*q;\n\n    output[0 + stride2] = a*l + b*o + c*r;\n    output[1 + stride2] = d*l + e*o + f*r;\n    output[2 + stride2] = g*l + h*o + i*r;\n}\n\n/**\n * Multiply by a column-vector\n * (i.e., y = A x)\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs\n */\nexport function multiplyvec(header, output, inputs)\n{\n    const [ irows ] = header.rowsOfInputs;\n    const [ icolumns ] = header.columnsOfInputs;\n    const [ istride ] = header.strideOfInputs;\n    const [ a, x ] = inputs;\n\n    output.fill(0, 0, irows);\n\n    let i, j, aj, xj;\n    for(aj = j = 0; j < icolumns; j++, aj += istride) {\n        xj = x[j];\n        for(i = 0; i < irows; i++)\n            output[i] += a[aj + i] * xj;\n    }\n}\n\n/**\n * Multiply by a constant\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs\n */\nexport function scale(header, output, inputs)\n{\n    const { rows, columns, stride } = header;\n    const { scalar } = header.custom;\n    const [ input ] = inputs;\n\n    let i, j, oj;\n    for(j = 0; j < columns; j++) {\n        oj = j * stride;\n        for(i = 0; i < rows; i++)\n            output[oj + i] = input[oj + i] * scalar;\n    }\n}\n\n/**\n * Component-wise multiplication\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs\n */\nexport function compmult(header, output, inputs)\n{\n    const { rows, columns, stride } = header;\n    const [ strideA, strideB ] = header.strideOfInputs;\n    const [ a, b ] = inputs;\n\n    let i, j, oj, aj, bj;\n    for(aj = bj = oj = j = 0; j < columns; j++, oj += stride, aj += strideA, bj += strideB) {\n        for(i = 0; i < rows; i++)\n            output[oj + i] = a[aj + i] * b[bj + i];\n    }\n}\n\n/**\n * Outer product (m x 1 vector by 1 x n vector)\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs\n */\nexport function outer(header, output, inputs)\n{\n    const { rows, columns, stride } = header;\n    const [ strideA, strideB ] = header.strideOfInputs;\n    const [ a, b ] = inputs;       \n\n    let i, j, bj, oj, obj;\n    for(obj = oj = j = 0; j < columns; j++, oj += stride, obj += strideB) {\n        bj = b[obj]; //b[j * strideB];\n        for(i = 0; i < rows; i++)\n            output[oj + i] = a[i] * bj;\n    }\n}\n\n/**\n * Given matrices A and B, scalars alpha and beta,\n * compute the sum (alpha A + beta B). The output\n * array can be one of the input arrays\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs\n */\nexport function addInPlace(header, output, inputs)\n{\n    const { rows, columns, stride } = header;\n    const [ strideA, strideB ] = header.strideOfInputs;\n    const { alpha, beta } = header.custom;\n    const [ a, b ] = inputs;\n\n    let i, j, oj, aj, bj;\n    for(aj = bj = oj = j = 0; j < columns; j++, oj += stride, aj += strideA, bj += strideB) {\n        for(i = 0; i < rows; i++)\n            output[oj + i] = alpha * a[aj + i] + beta * b[bj + i];\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * functional.js\n * Functional programming\n */\n\n/**\n * Map the blocks of a matrix\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs\n */\nexport function map(header, output, inputs)\n{\n    const [ input, mapfn, bi, index ] = inputs;\n    const { rows, columns, stride } = header;\n    const [ istride, mstride, bistride ] = header.strideOfInputs;\n    const [ outputBlockRows, outputBlockColumns ] = [ header.rowsOfInputs[1], header.columnsOfInputs[1] ];\n    const [ blockRows, blockColumns ] = [ header.rowsOfInputs[2], header.columnsOfInputs[2] ];\n    const [ ilength, bilength ] = [ inputs[0].length, inputs[2].length ];\n    const n = columns / blockColumns;\n    const biidx = 2; //inputs.indexOf(bi);\n    const blkopt = (bistride === istride && bilength === ilength);\n    const block = blkopt ? Array.from({ length: n }, (_, i) => input.subarray(i * istride * blockColumns, (i+1) * istride * blockColumns)) : null;\n    let b, i, j, ij, oj;\n\n    // for each block\n    for(b = 0; b < n; b++) {\n        // copy block[b] to bi\n        if(block != null)\n            inputs[biidx] = block[b];\n        else for(oj = 0, ij = b * istride * blockColumns, j = 0; j < blockColumns; j++, oj += bistride, ij += istride) {\n            for(i = 0; i < blockRows; i++)\n                bi[oj + i] = input[ij + i];\n        }\n\n        // call mapfn(bi, index)\n        index[0] = b;\n        this.subroutine('mapfn', header, inputs);\n\n        // copy mapfn to outputBlock[b]\n        for(oj = b * outputBlockColumns * stride, ij = 0, j = 0; j < outputBlockColumns; j++, oj += stride, ij += mstride) {\n            for(i = 0; i < outputBlockRows; i++)\n                output[oj + i] = mapfn[ij + i];\n        }\n    }\n\n    // restore pointer\n    inputs[biidx] = bi;\n}\n\n/**\n * Reduce the blocks of a matrix\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs\n */\nexport function reduce(header, output, inputs)\n{\n    const [ input, reducefn, accumulator, bi, index, initial ] = inputs;\n    const { rows, columns, stride } = header;\n    const [ istride, rstride, astride, bistride, indexstride, initialstride ] = header.strideOfInputs;\n    const [ ilength, rlength, alength, bilength, indexlength, initiallength ] = inputs.map(m => m.length);\n    const [ blockRows, blockColumns ] = [ header.rowsOfInputs[3], header.columnsOfInputs[3] ];\n    const length = output.length;\n    const begopt = (astride === initialstride && alength === initiallength);\n    const midopt = (astride === rstride && alength === rlength);\n    const endopt = (astride === stride && alength === length);\n    const blkopt = (bistride === istride && bilength === ilength);\n    const n = header.columnsOfInputs[0] / blockColumns;\n    const biidx = 3; //inputs.indexOf(bi);\n    const block = blkopt ? Array.from({ length: n }, (_, i) => input.subarray(i * istride * blockColumns, (i+1) * istride * blockColumns)) : null;\n    let b, i, j, ij, oj;\n\n    // copy the initial matrix to the accumulator\n    if(begopt) // optimize copy\n        accumulator.set(initial); // memcpy()-like - is it required that dtype of accumulator === dtype of initial ?\n    else for(oj = 0, ij = 0, j = 0; j < columns; j++, ij += initialstride, oj += astride) {\n        for(i = 0; i < rows; i++)\n            accumulator[oj + i] = initial[ij + i];\n    }\n\n    // for each block\n    for(b = 0; b < n; b++) {\n        // copy block[b] to bi\n        if(block != null)\n            inputs[biidx] = block[b];\n        else for(oj = 0, ij = b * istride * blockColumns, j = 0; j < blockColumns; j++, oj += bistride, ij += istride) {\n            for(i = 0; i < blockRows; i++)\n                bi[oj + i] = input[ij + i];\n        }\n\n        // call reducefn(accumulator, bi, index)\n        index[0] = b;\n        this.subroutine('reducefn', header, inputs);\n\n        // copy reducefn to the accumulator\n        if(midopt)\n            accumulator.set(reducefn);\n        else for(oj = 0, ij = 0, j = 0; j < columns; j++, ij += rstride, oj += astride) {\n            for(i = 0; i < rows; i++)\n                accumulator[oj + i] = reducefn[ij + i];\n        }\n    }\n\n    // copy the accumulator to the output\n    if(endopt)\n        output.set(accumulator);\n    else for(oj = 0, ij = 0, j = 0; j < columns; j++, ij += astride, oj += stride) {\n        for(i = 0; i < rows; i++)\n            output[oj + i] = accumulator[ij + i];\n    }\n\n    // restore pointer\n    inputs[biidx] = bi;\n}\n\n/**\n * Sort the blocks of a matrix\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs\n */\nexport function sort(header, output, inputs)\n{\n    const [ input, cmp, bi, bj ] = inputs;\n    const { rows, columns, stride } = header;\n    const [ istride, cmpstride, bistride, bjstride ] = header.strideOfInputs;\n    const [ ilength, cmplength, bilength, bjlength ] = inputs.map(m => m.length);\n    const [ blockRows, blockColumns ] = [ header.rowsOfInputs[2], header.columnsOfInputs[2] ];\n    const n = columns / blockColumns;\n    const biidx = 2, bjidx = 3; //const biidx = inputs.indexOf(bi), bjidx = inputs.indexOf(bj);\n    const biopt = (bistride === istride && bilength === ilength), bjopt = (bjstride === istride && bjlength === ilength); // note: bistride === bjstride\n    const block = biopt && bjopt ? Array.from({ length: n }, (_, i) => input.subarray(i * istride * blockColumns, (i+1) * istride * blockColumns)) : null;\n    const permutation = this.range(n);\n    const stack = (new Array(n)).fill(0);\n    let top = -1, l = 0, r = 0, p = 0, pivot = 0;\n    let i, j, oj, ij;\n    let a, b, c, t;\n\n    // quicksort on a permutation of indices of blocks\n    stack[++top] = 0;\n    stack[++top] = n - 1;\n    while(top >= 0) {\n        r = stack[top--];\n        l = stack[top--];\n\n        // partition\n        p = (l + r) >>> 1;\n        pivot = permutation[p];\n\n        // copy block[pivot] to bj\n        if(block != null)\n            inputs[bjidx] = block[pivot]; // it's faster if we just set a reference\n        else for(oj = 0, ij = pivot * istride * blockColumns, j = 0; j < blockColumns; j++, oj += bjstride, ij += istride) {\n            for(i = 0; i < blockRows; i++)\n                bj[oj + i] = input[ij + i];\n        }\n\n        a = l - 1; b = r + 1;\n        for(;;) {\n            do {\n                a++;\n\n                // copy block[permutation[a]] to bi\n                if(block != null)\n                    inputs[biidx] = block[permutation[a]];\n                else for(oj = 0, ij = permutation[a] * istride * blockColumns, j = 0; j < blockColumns; j++, oj += bistride, ij += istride) {\n                    for(i = 0; i < blockRows; i++)\n                        bi[oj + i] = input[ij + i];\n                }\n\n                // is block[permutation[a]] < block[pivot] ?\n                this.subroutine('cmp', header, inputs);\n            } while(cmp[0] < 0 && a < r);\n\n            do {\n                b--;\n\n                // copy block[permutation[b]] to bi\n                if(block != null)\n                    inputs[biidx] = block[permutation[b]];\n                else for(oj = 0, ij = permutation[b] * istride * blockColumns, j = 0; j < blockColumns; j++, oj += bistride, ij += istride) {\n                    for(i = 0; i < blockRows; i++)\n                        bi[oj + i] = input[ij + i];\n                }\n\n                // is block[permutation[b]] > block[pivot] ?\n                this.subroutine('cmp', header, inputs);\n            } while(cmp[0] > 0 && b > l);\n\n            // swap elements\n            if(a < b) {\n                t = permutation[a];\n                permutation[a] = permutation[b];\n                permutation[b] = t;\n            }\n            else break;\n        }\n\n        // recursion\n        p = b;\n        if(l < p) {\n            stack[++top] = l;\n            stack[++top] = p;\n        }\n        if(r > p + 1) {\n            stack[++top] = p + 1;\n            stack[++top] = r;\n        }\n    }\n\n    // apply permutation\n    for(b = 0; b < n; b++) { // for each block...\n        c = permutation[b] * blockColumns; // for each column...\n        for(oj = b * blockColumns * stride, ij = c * istride, j = 0; j < blockColumns; j++, oj += stride, ij += istride) {\n            for(i = 0; i < blockRows; i++)\n                output[oj + i] = input[ij + i];\n        }\n    }\n\n    // restore pointers\n    inputs[biidx] = bi;\n    inputs[bjidx] = bj;\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * homography.js\n * Find homography matrix\n */\n\n/*\n\nSuppose that we want to use 4 correspondences (uk, vk) <-> (xk, yk) to\nfind a homography matrix H that maps (u,v) to (x,y):\n\n    [ a  b  c ]\nH = [ d  e  f ]\n    [ g  h  i ]\n\nOne way to do it is to solve the equation below (we set i = 1):\n\n[ u0  v0  1   0   0   0  -u0*x0  -v0*x0 ] [ a ]   [ x0 ]\n[ u1  v1  1   0   0   0  -u1*x1  -v1*x1 ] [ b ]   [ x1 ]\n[ u2  v2  1   0   0   0  -u2*x2  -v2*x2 ] [ c ]   [ x2 ]\n[ u3  v3  1   0   0   0  -u3*x3  -v3*x3 ] [ d ] = [ x3 ]\n[ 0   0   0   u0  v0  1  -u0*y0  -v0*y0 ] [ e ]   [ y0 ]\n[ 0   0   0   u1  v1  1  -u1*y1  -v1*y1 ] [ f ]   [ y1 ]\n[ 0   0   0   u2  v2  1  -u2*y2  -v2*y2 ] [ g ]   [ y2 ]\n[ 0   0   0   u3  v3  1  -u3*y3  -v3*y3 ] [ h ]   [ y3 ]\n\nIt turns out that this equation gets a bit simpler if we transform\npoints to/from the unit square centered at 0.5, i.e., [0,1] x [0,1].\n\nIn fact, I can solve this equation using pen and paper and type in a\nclosed formula, which I did!\n\nNo Gaussian elimination, no SVD, no loops, nothing! This should run\nvery fast.\n\nNote: it's also possible to solve this equation directly (without the\nunit square). However, the algebra is quite messy and I'm not sure it\nwill be any better, numerically speaking, than the approach I'm taking.\n\n*/\n\n/**\n * Find a homography using 4 correspondences of points. We'll map\n * (u,v) to (x,y). The input matrices are expected to have the form:\n * \n * [ u0  u1  u2  u3 ] [ x0  x1  x2  x3 ]\n * [ v0  v1  v2  v3 ] [ y0  y1  y2  y3 ]\n * \n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs\n */\nexport function homography4p(header, output, inputs)\n{\n    const stride = header.stride;\n    const sstride = header.strideOfInputs[0];\n    const dstride = header.strideOfInputs[1];\n    const src = inputs[0], dest = inputs[1];\n    const eps = 1e-6; // avoid division by small numbers\n\n    let m00, m01, m10, m11, z0, z1, det, idet;\n    let a1, b1, c1, d1, e1, f1, g1, h1, i1;\n    let a2, b2, c2, d2, e2, f2, g2, h2, i2;\n    let a, b, c, d, e, f, g, h, i;\n\n    //\n    // Initialization\n    //\n\n    // Read (ui, vi) - source\n    const u0 = src[0],\n          v0 = src[1],\n          u1 = src[0 + sstride],\n          v1 = src[1 + sstride],\n          u2 = src[0 + 2 * sstride],\n          v2 = src[1 + 2 * sstride],\n          u3 = src[0 + 3 * sstride],\n          v3 = src[1 + 3 * sstride];\n\n    // Read (xi, yi) - destination\n    const x0 = dest[0],\n          y0 = dest[1],\n          x1 = dest[0 + dstride],\n          y1 = dest[1 + dstride],\n          x2 = dest[0 + 2 * dstride],\n          y2 = dest[1 + 2 * dstride],\n          x3 = dest[0 + 3 * dstride],\n          y3 = dest[1 + 3 * dstride];\n\n    // This is supposed to be executed many times.\n    // Should we normalize the input/output points\n    // at this stage? Let the user decide! See\n    // function homographynorm4p() below.\n\n    // Initialize homography H\n    a = b = c = d = e = f = g = h = i = Number.NaN;\n\n    do {\n\n    //\n    // From source to unit square\n    //\n\n    // Compute a few \"cross products\" (signed areas)\n    const alpha = (u3 - u0) * (v1 - v0) - (v3 - v0) * (u1 - u0);\n    const beta = (u3 - u0) * (v2 - v0) - (v3 - v0) * (u2 - u0);\n    const phi = (u1 - u0) * (v2 - v0) - (v1 - v0) * (u2 - u0);\n    const chi = (u3 - u1) * (v2 - v1) - (v3 - v1) * (u2 - u1);\n    const theta = -alpha;\n\n    // We require a quadrilateral, not a triangle,\n    // nor a line, nor a single point! Are 3 or 4\n    // points colinear?\n    if(\n        Math.abs(alpha) < eps || Math.abs(beta) < eps ||\n        Math.abs(phi) < eps || Math.abs(chi) < eps\n    )\n        break; // goto end;\n\n    // Find M and Z\n    m00 = u2 * alpha - u1 * beta;\n    m01 = v2 * alpha - v1 * beta;\n    m10 = u3 * phi - u2 * theta;\n    m11 = v3 * phi - v2 * theta;\n    z0 = beta - alpha;\n    z1 = theta - phi;\n\n    // Solve M p = z for p = [ g  h ]^t\n    det = m00 * m11 - m01 * m10;\n    if(Math.abs(det) < eps) break; // shouldn't happen\n    idet = 1.0 / det;\n    g1 = (m11 * z0 - m01 * z1) * idet;\n    h1 = (m00 * z1 - m10 * z0) * idet;\n\n    // Find the remaining entries of the homography\n    if(Math.abs(alpha) > Math.abs(beta)) {\n        a1 = (1.0 + g1 * u1 + h1 * v1) * (v3 - v0) / (-alpha);\n        b1 = (1.0 + g1 * u1 + h1 * v1) * (u3 - u0) / alpha;\n    }\n    else {\n        a1 = (1.0 + g1 * u2 + h1 * v2) * (v3 - v0) / (-beta);\n        b1 = (1.0 + g1 * u2 + h1 * v2) * (u3 - u0) / beta;\n    }\n\n    if(Math.abs(phi) > Math.abs(theta)) {\n        d1 = (1.0 + g1 * u2 + h1 * v2) * (v1 - v0) / (-phi);\n        e1 = (1.0 + g1 * u2 + h1 * v2) * (u1 - u0) / phi;\n    }\n    else {\n        d1 = (1.0 + g1 * u3 + h1 * v3) * (v1 - v0) / (-theta);\n        e1 = (1.0 + g1 * u3 + h1 * v3) * (u1 - u0) / theta;\n    }\n\n    c1 = -a1 * u0 - b1 * v0;\n    f1 = -d1 * u0 - e1 * v0;\n    i1 = 1.0;\n\n    // Bad homography?\n    det = a1*e1*i1 + b1*f1*g1 + c1*d1*h1 - b1*d1*i1 - a1*f1*h1 - c1*e1*g1;\n    if(Math.abs(det) < eps) break; // goto end;\n\n    //\n    // From unit square to destination\n    //\n\n    // Find M and z\n    m00 = x1 - x2;\n    m01 = x3 - x2;\n    m10 = y1 - y2;\n    m11 = y3 - y2;\n    z0 = (x0 - x1) + (x2 - x3);\n    z1 = (y0 - y1) + (y2 - y3);\n\n    // Solve M p = z for p = [ g  h ]^t\n    det = m00 * m11 - m01 * m10;\n    if(Math.abs(det) < eps) break; // goto end;\n    idet = 1.0 / det;\n    g2 = (m11 * z0 - m01 * z1) * idet;\n    h2 = (m00 * z1 - m10 * z0) * idet;\n\n    // Find the remaining entries of the homography\n    a2 = g2 * x1 + (x1 - x0);\n    b2 = h2 * x3 + (x3 - x0);\n    c2 = x0;\n    d2 = g2 * y1 + (y1 - y0);\n    e2 = h2 * y3 + (y3 - y0);\n    f2 = y0;\n    i2 = 1.0;\n\n    // Bad homography?\n    det = a2*e2*i2 + b2*f2*g2 + c2*d2*h2 - b2*d2*i2 - a2*f2*h2 - c2*e2*g2;\n    if(Math.abs(det) < eps) break; // goto end;\n\n    //\n    // From source to destination\n    //\n\n    // Find homography\n    a = a2 * a1 + b2 * d1 + c2 * g1;\n    b = a2 * b1 + b2 * e1 + c2 * h1;\n    c = a2 * c1 + b2 * f1 + c2 * i1;\n    d = d2 * a1 + e2 * d1 + f2 * g1;\n    e = d2 * b1 + e2 * e1 + f2 * h1;\n    f = d2 * c1 + e2 * f1 + f2 * i1;\n    g = g2 * a1 + h2 * d1 + i2 * g1;\n    h = g2 * b1 + h2 * e1 + i2 * h1;\n    i = g2 * c1 + h2 * f1 + i2 * i1;\n\n    } while(0);\n\n    // end:\n\n    // Write the matrix to the output\n    output[0] = a;\n    output[1] = d;\n    output[2] = g;\n    output[0 + stride] = b;\n    output[1 + stride] = e;\n    output[2 + stride] = h;\n    output[0 + 2 * stride] = c;\n    output[1 + 2 * stride] = f;\n    output[2 + 2 * stride] = i;\n}\n\n/**\n * Find a homography using 4 correspondences of points, given as\n * two 2 x 4 matrices. The points will be normalized FAST!\n * @param {object} header\n * @param {ArrayBufferView} output 3x3\n * @param {ArrayBufferView[]} inputs [src, dst] 2x4\n */\nexport function homographynorm4p(header, output, inputs)\n{\n    const stride = header.stride;\n    const sstride = header.strideOfInputs[0];\n    const dstride = header.strideOfInputs[1];\n    const stride2 = stride * 2;\n    const sstride2 = sstride * 2, sstride3 = sstride * 3;\n    const dstride2 = dstride * 2, dstride3 = dstride * 3;\n    const src = inputs[0], dst = inputs[1];\n\n    // store the points\n    const u0 = src[0],\n          v0 = src[1],\n          u1 = src[0 + sstride],\n          v1 = src[1 + sstride],\n          u2 = src[0 + sstride2],\n          v2 = src[1 + sstride2],\n          u3 = src[0 + sstride3],\n          v3 = src[1 + sstride3],\n          x0 = dst[0],\n          y0 = dst[1],\n          x1 = dst[0 + dstride],\n          y1 = dst[1 + dstride],\n          x2 = dst[0 + dstride2],\n          y2 = dst[1 + dstride2],\n          x3 = dst[0 + dstride3],\n          y3 = dst[1 + dstride3];\n\n    // find the centers of mass (scx, scy) and (dcx, dcy)\n    const scx = (u0 + u1 + u2 + u3) * 0.25,\n          scy = (v0 + v1 + v2 + v3) * 0.25,\n          dcx = (x0 + x1 + x2 + x3) * 0.25,\n          dcy = (y0 + y1 + y2 + y3) * 0.25;\n\n    // find suitable scale factors (via RMS distance)\n    const sdist = (u0 - scx) * (u0 - scx) + (v0 - scy) * (v0 - scy) +\n                  (u1 - scx) * (u1 - scx) + (v1 - scy) * (v1 - scy) +\n                  (u2 - scx) * (u2 - scx) + (v2 - scy) * (v2 - scy) +\n                  (u3 - scx) * (u3 - scx) + (v3 - scy) * (v3 - scy);\n    const ddist = (x0 - dcx) * (x0 - dcx) + (y0 - dcy) * (y0 - dcy) +\n                  (x1 - dcx) * (x1 - dcx) + (y1 - dcy) * (y1 - dcy) +\n                  (x2 - dcx) * (x2 - dcx) + (y2 - dcy) * (y2 - dcy) +\n                  (x3 - dcx) * (x3 - dcx) + (y3 - dcy) * (y3 - dcy);\n    const sscale = Math.sqrt(8.0 / sdist),\n          dscale = Math.sqrt(8.0 / ddist);\n\n    // normalize the points\n    src[0] = sscale * (u0 - scx);\n    src[1] = sscale * (v0 - scy);\n    src[0 + sstride] = sscale * (u1 - scx);\n    src[1 + sstride] = sscale * (v1 - scy);\n    src[0 + sstride2] = sscale * (u2 - scx);\n    src[1 + sstride2] = sscale * (v2 - scy);\n    src[0 + sstride3] = sscale * (u3 - scx);\n    src[1 + sstride3] = sscale * (v3 - scy);\n    dst[0] = dscale * (x0 - dcx);\n    dst[1] = dscale * (y0 - dcy);\n    dst[0 + dstride] = dscale * (x1 - dcx);\n    dst[1 + dstride] = dscale * (y1 - dcy);\n    dst[0 + dstride2] = dscale * (x2 - dcx);\n    dst[1 + dstride2] = dscale * (y2 - dcy);\n    dst[0 + dstride3] = dscale * (x3 - dcx);\n    dst[1 + dstride3] = dscale * (y3 - dcy);\n\n    // find a homography using the normalized points\n    this.homography4p(header, output, inputs);\n\n    // denormalize the points\n    src[0] = u0;\n    src[1] = v0;\n    src[0 + sstride] = u1;\n    src[1 + sstride] = v1;\n    src[0 + sstride2] = u2;\n    src[1 + sstride2] = v2;\n    src[0 + sstride3] = u3;\n    src[1 + sstride3] = v3;\n    dst[0] = x0;\n    dst[1] = y0;\n    dst[0 + dstride] = x1;\n    dst[1 + dstride] = y1;\n    dst[0 + dstride2] = x2;\n    dst[1 + dstride2] = y2;\n    dst[0 + dstride3] = x3;\n    dst[1 + dstride3] = y3;\n\n    // embed normalization and denormalization in the homography, i.e.,\n    // normalize (src space) -> apply homography -> denormalize (dst space)\n    const h00 = output[0], h01 = output[0 + stride], h02 = output[0 + stride2],\n          h10 = output[1], h11 = output[1 + stride], h12 = output[1 + stride2],\n          h20 = output[2], h21 = output[2 + stride], h22 = output[2 + stride2];\n    const s = sscale, z = 1.0 / dscale;\n    const tmp = h22 - s * (scx * h20 + scy * h21);\n\n    output[0] = s * (z * h00 + dcx * h20);\n    output[1] = s * (z * h10 + dcy * h20);\n    output[2] = s * h20;\n    output[0 + stride] = s * (z * h01 + dcx * h21);\n    output[1 + stride] = s * (z * h11 + dcy * h21);\n    output[2 + stride] = s * h21;\n    output[0 + stride2] = dcx * tmp + z * (h02 - s * (scx * h00 + scy * h01));\n    output[1 + stride2] = dcy * tmp + z * (h12 - s * (scx * h10 + scy * h11));\n    output[2 + stride2] = tmp;\n}\n\n/**\n * Find a homography using n >= 4 correspondences of points (u,v) to (x,y)\n * using Direct Linear Transform (DLT). It's recommended to normalize the\n * input before calling this function (see homographynormdlt() below).\n * The input matrices are expected to be 2 x n.\n * @param {object} header\n * @param {ArrayBufferView} output 3x3 homography matrix\n * @param {ArrayBufferView[]} inputs [ src, dest ]\n */\nexport function homographydlt(header, output, inputs)\n{\n    const dtype = header.dtype;\n    const n = header.columnsOfInputs[0]; // number of correspondences\n    const src = inputs[0], dest = inputs[1];\n    const stride = header.stride;\n    const sstride = header.strideOfInputs[0];\n    const dstride = header.strideOfInputs[1];\n    const astride = 2 * n;\n    const matA = this.createTypedArray(dtype, 16 * n).fill(0.0); // 2n x 8 matrix\n    const vecB = this.createTypedArray(dtype, 2 * n); // 2n x 1 matrix\n    const vecH = this.createTypedArray(dtype, 8); // 8x1 matrix\n    const eps = 1e-6;\n    let u, v, x, y, k, j, ij, iij;\n    let a, b, c, d, e, f, g, h, i, det;\n\n    /*\n    // create system of linear equations\n    [ uj  vj  1   0   0   0  -uj*xj  -vj*xj ] h  =  [ xj ]\n    [ 0   0   0   uj  vj  1  -uj*yj  -vj*yj ]       [ yj ]\n    */\n    for(ij = 0, iij = 0, j = 0, k = 0; k < n; k++, j += 2, ij += sstride, iij += dstride) {\n        u = src[ij + 0];\n        v = src[ij + 1];\n        x = dest[iij + 0];\n        y = dest[iij + 1];\n\n        matA[0 + j] = u;\n        //matA[1 + j] = 0;\n        matA[astride + 0 + j] = v;\n        //matA[astride + 1 + j] = 0.0;\n        matA[2 * astride + 0 + j] = 1.0;\n        //matA[2 * astride + 1 + j] = 0.0;\n        //matA[3 * astride + 0 + j] = 0.0;\n        matA[3 * astride + 1 + j] = u;\n        //matA[4 * astride + 0 + j] = 0.0;\n        matA[4 * astride + 1 + j] = v;\n        //matA[5 * astride + 0 + j] = 0.0;\n        matA[5 * astride + 1 + j] = 1.0;\n        matA[6 * astride + 0 + j] = -u*x;\n        matA[6 * astride + 1 + j] = -u*y;\n        matA[7 * astride + 0 + j] = -v*x;\n        matA[7 * astride + 1 + j] = -v*y;\n\n        vecB[0 + j] = x;\n        vecB[1 + j] = y;\n    }\n\n    // solve Ah = b for h\n    this.run(this.lssolve, dtype, [\n        // output\n        8, 1, 8,\n\n        // inputs\n        2*n, 8, 2*n,\n        2*n, 1, 2*n,\n    ], [ vecH, matA, vecB ]);\n\n    // read homography\n    a = vecH[0]; b = vecH[1]; c = vecH[2];\n    d = vecH[3]; e = vecH[4]; f = vecH[5];\n    g = vecH[6]; h = vecH[7]; i = 1.0;\n\n    // bad homography?\n    det = a*e*i + b*f*g + c*d*h - b*d*i - a*f*h - c*e*g;\n    if(Number.isNaN(det) || Math.abs(det) < eps)\n        a = b = c = d = e = f = g = h = i = Number.NaN;\n\n    // write homography to the output\n    const stride2 = stride + stride;\n    output[0] = a;\n    output[1] = d;\n    output[2] = g;\n    output[stride + 0] = b;\n    output[stride + 1] = e;\n    output[stride + 2] = h;\n    output[stride2 + 0] = c;\n    output[stride2 + 1] = f;\n    output[stride2 + 2] = i;\n}\n\n/**\n * Find a homography using n >= 4 correspondences of points (u,v) to (x,y)\n * using the normalized Direct Linear Transform (nDLT). The input matrices\n * are expected to be 2 x n.\n * @param {object} header\n * @param {ArrayBufferView} output 3x3 homography matrix\n * @param {ArrayBufferView[]} inputs [ src, dest ]\n */\nexport function homographynormdlt(header, output, inputs)\n{\n    const { dtype, stride } = header;\n    const n = header.columnsOfInputs[0];\n    const sstride = header.strideOfInputs[0];\n    const dstride = header.strideOfInputs[1];\n    const src = inputs[0], dst = inputs[1];\n    const ptsbuf = this.createTypedArray(dtype, 4 * n); // two 2 x n matrices\n    const matbuf = this.createTypedArray(dtype, 9 * 4); // four 3 x 3 matrices\n    const srcnormpts = ptsbuf.subarray(0, 2 * n);\n    const dstnormpts = ptsbuf.subarray(2 * n, 4 * n);\n    const srcnormmat = matbuf.subarray(0, 9);\n    const srcdenormmat = matbuf.subarray(9, 18); // unused results\n    const dstnormmat = matbuf.subarray(18, 27); // unused results\n    const dstdenormmat = matbuf.subarray(27, 36);\n    const hommat = dstnormmat;\n    const tmpmat = srcdenormmat;\n\n    // Normalize source points\n    this.run(this.dltnorm2d, dtype, [\n        // output\n        2, n, 2,\n\n        // inputs\n        2, n, sstride,\n        3, 3, 3,\n        3, 3, 3,\n    ], [ srcnormpts, src, srcnormmat, srcdenormmat ]);\n\n    // Normalize destination points\n    this.run(this.dltnorm2d, dtype, [\n        // output\n        2, n, 2,\n\n        // inputs\n        2, n, dstride,\n        3, 3, 3,\n        3, 3, 3,\n    ], [ dstnormpts, dst, dstnormmat, dstdenormmat ]);\n\n    // DLT using the normalized points\n    this.run(this.homographydlt, dtype, [\n        // output\n        3, 3, 3,\n\n        // inputs\n        2, n, 2,\n        2, n, 2,\n    ], [ hommat, srcnormpts, dstnormpts ]);\n\n    // Compute normalized DLT using matrix multiplications\n    this.run(this.multiply3, dtype, [\n        // output\n        3, 3, 3,\n\n        // inputs\n        3, 3, 3,\n        3, 3, 3,\n    ], [ tmpmat, hommat, srcnormmat ]);\n\n    this.run(this.multiply3, dtype, [\n        // output\n        3, 3, stride,\n\n        // inputs\n        3, 3, 3,\n        3, 3, 3,\n    ], [ output, dstdenormmat, tmpmat ]);\n\n    /*\n    // Normalize the entries of the resulting matrix\n    let i = 0;\n    let norm2 = 0.0, inorm = 0.0;\n    const stride2 = stride + stride;\n\n    for(i = 0; i < 3; i++) {\n        norm2 += output[i] * output[i];\n        norm2 += output[i + stride] * output[i + stride];\n        norm2 += output[i + stride2] * output[i + stride2];\n    }\n\n    inorm = 1.0 / Math.sqrt(norm2);\n    for(i = 0; i < 3; i++) {\n        output[i] *= inorm;\n        output[i + stride] *= inorm;\n        output[i + stride2] *= inorm;\n    }\n    */\n}\n\n/**\n * Given a set of n points (xi, yi) encoded in a 2 x n matrix,\n * find normalization and denormalization matrices (3x3) so that\n * the average distance of the normalized points to the origin\n * becomes a small constant. Returns the transformed points as\n * the output.\n * @param {object} header\n * @param {ArrayBufferView} output normalized points (2xn)\n * @param {ArrayBufferView[]} inputs [ input points (2xn), out norm matrix (3x3), out denorm matrix (3x3) ]\n */\nexport function dltnorm2d(header, output, inputs)\n{\n    const stride = header.stride;\n    const pstride = header.strideOfInputs[0];\n    const nstride = header.strideOfInputs[1];\n    const dstride = header.strideOfInputs[2];\n    const n = header.columnsOfInputs[0];\n    const pts = inputs[0], normmat = inputs[1], denormmat = inputs[2];\n    let cx = 0.0, cy = 0.0, dx = 0.0, dy = 0.0, d = 0.0, s = 0.0, z = 0.0;\n    let i = 0, ip = 0, io = 0;\n\n    // find the center of mass (cx, cy) = c\n    for(ip = i = 0; i < n; i++, ip += pstride) {\n        cx += pts[ip];\n        cy += pts[ip + 1];\n    }\n    cx /= n;\n    cy /= n;\n\n    // find the RMS distance to the center of mass\n    for(ip = i = 0; i < n; i++, ip += pstride) {\n        dx = pts[ip] - cx;\n        dy = pts[ip + 1] - cy;\n        d += dx * dx + dy * dy;\n    }\n    d = Math.sqrt(d / n);\n\n    // find the scale factor s\n    const SQRT2 = 1.4142135623730951;\n    s = SQRT2 / d;\n    z = d / SQRT2; // = 1/s\n\n    // write the normalization matrix\n    // given a point p, set p_normalized := s(p - c)\n    const nstride2 = nstride + nstride;\n    normmat[0] = s; normmat[0 + nstride] = 0; normmat[0 + nstride2] = -s * cx;\n    normmat[1] = 0; normmat[1 + nstride] = s; normmat[1 + nstride2] = -s * cy;\n    normmat[2] = 0; normmat[2 + nstride] = 0; normmat[2 + nstride2] = 1;\n\n    // write the denormalization matrix\n    // given a normalized point q, set q_denormalized := q/s + c\n    const dstride2 = dstride + dstride;\n    denormmat[0] = z; denormmat[0 + dstride] = 0; denormmat[0 + dstride2] = cx;\n    denormmat[1] = 0; denormmat[1 + dstride] = z; denormmat[1 + dstride2] = cy;\n    denormmat[2] = 0; denormmat[2 + dstride] = 0; denormmat[2 + dstride2] = 1;\n\n    // normalize the points\n    for(io = 0, ip = 0, i = 0; i < n; i++, ip += pstride, io += stride) {\n        output[io] = s * (pts[ip] - cx);\n        output[io + 1] = s * (pts[ip + 1] - cy);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * inverse.js\n * Inverse of a matrix\n */\n\n/**\n * Inverse of a 1x1 matrix\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs\n */\nexport function inverse1(header, output, inputs)\n{\n    output[0] = 1.0 / inputs[0][0];\n}\n\n/**\n * Inverse of a 2x2 matrix\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs\n */\nexport function inverse2(header, output, inputs)\n{\n    const stride = header.stride;\n    const istride = header.strideOfInputs[0];\n    const input = inputs[0];\n\n    // read entries of the matrix\n    const a11 = input[0];\n    const a21 = input[1];\n    const a12 = input[0 + istride];\n    const a22 = input[1 + istride];\n\n    // compute the determinant\n    const det = a11 * a22 - a12 * a21;\n    const d = 1.0 / det;\n\n    // set up the inverse\n    output[0] = a22 * d;\n    output[1] = -a21 * d;\n    output[0 + stride] = -a12 * d;\n    output[1 + stride] = a11 * d;\n}\n\n/**\n * Inverse of a 3x3 matrix\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs\n */\nexport function inverse3(header, output, inputs)\n{\n    const stride = header.stride;\n    const istride = header.strideOfInputs[0];\n    const input = inputs[0];\n\n    // read entries of the matrix\n    const a11 = input[0];\n    const a21 = input[1];\n    const a31 = input[2];\n    const a12 = input[0 + istride];\n    const a22 = input[1 + istride];\n    const a32 = input[2 + istride];\n    const a13 = input[0 + istride + istride];\n    const a23 = input[1 + istride + istride];\n    const a33 = input[2 + istride + istride];\n\n    // compute auxiliary values\n    const b1 = a33 * a22 - a32 * a23;\n    const b2 = a33 * a12 - a32 * a13;\n    const b3 = a23 * a12 - a22 * a13;\n\n    // compute the determinant\n    const det = a11 * b1 - a21 * b2 + a31 * b3;\n    const d = 1.0 / det;\n\n    // set up the inverse\n    const stride2 = stride + stride;\n    output[0] = b1 * d;\n    output[1] = -(a33 * a21 - a31 * a23) * d;\n    output[2] = (a32 * a21 - a31 * a22) * d;\n    output[0 + stride] = -b2 * d;\n    output[1 + stride] = (a33 * a11 - a31 * a13) * d;\n    output[2 + stride] = -(a32 * a11 - a31 * a12) * d;\n    output[0 + stride2] = b3 * d;\n    output[1 + stride2] = -(a23 * a11 - a21 * a13) * d;\n    output[2 + stride2] = (a22 * a11 - a21 * a12) * d;\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * linalg.js\n * Plug & Play Linear algebra methods\n */\n\nconst { MatrixType } = require('../matrix-type');\nconst LinAlgLib = {\n    ...require('./basic'),\n    ...require('./inverse'),\n    ...require('./solve'),\n    ...require('./qr'),\n    ...require('./sequence'),\n    ...require('./functional'),\n    ...require('./homography'),\n    ...require('./transform'),\n    ...require('./ransac'),\n    ...require('./utils'),\n};\n\n/**\n * Plug & Play Linear Algebra methods\n * The actual Linear Algebra methods will be plugged in!\n * This is a class of static methods that can be \"exported\" to a WebWorker.\n * Currently, LinAlgLib methods cannot import things external to LinAlg.\n * @class\n */\nconst LinAlg = (function() {\n'use strict';\nfunction LinAlg() { }\n\n/** @type {object} linear algebra library */\nLinAlg.lib = Object.create(null);\n\n/** @type {object} source code of methods */\nconst _src = Object.create(null);\n\n/**\n * Register a method\n * @param {string} name method name\n * @param {Function} fn function code\n */\nLinAlg.register = function(name, fn)\n{\n    // validate\n    if(typeof fn !== `function`)\n        throw new Error(`Not a function: ${name}`);\n    else if(typeof name !== `string` || !name.match(/^[a-z_][0-9a-z_]*$/i))\n        throw new Error(`Undesirable identifier: ${name}`);\n    else if(LinAlg.hasMethod(name))\n        throw new Error(`Can't redefine method ${name}`);\n\n    // register method\n    const readonly = { enumerable: true, writable: false, configurable: false };\n    Object.defineProperty(LinAlg.lib, name, {\n        value: fn.bind(LinAlg.lib), // methods will be bound to LinAlg.lib\n        ...readonly\n    });\n    Object.defineProperty(_src, name, {\n        value: fn.toString(),\n        ...readonly\n    });\n};\n\n/**\n * Check if a method has been registered\n * @param {string} name method name\n * @returns {boolean}\n */\nLinAlg.hasMethod = function(name)\n{\n    return Object.prototype.hasOwnProperty.call(LinAlg.lib, name);\n}\n\n/**\n * Convert this Plug & Play class to a string\n * @returns {string}\n */\nLinAlg.toString = function()\n{\n    const methods = Object.keys(_src)\n            .map(x => `LinAlg.lib.${x} = (${_src[x]}).bind(LinAlg.lib);`)\n            .join('\\n');\n\n    return `` + // IIFE\n`(function() {\n'use strict';\nfunction LinAlg() { }\nLinAlg.lib = Object.create(null);\nLinAlg.lib.MatrixType = (${MatrixType.toString()}).freeze();\n\n${methods}\n\nObject.freeze(LinAlg.lib);\nreturn Object.freeze(LinAlg);\n})()`;\n};\n\n// Import MatrixType into the lib\nObject.defineProperty(LinAlg.lib, 'MatrixType', {\n    value: MatrixType.freeze(),\n    writable: false,\n    configurable: false,\n    enumerable: false,\n});\n\n// Plug in the Linear Algebra methods\nObject.keys(LinAlgLib).forEach(method => {\n    LinAlg.register(method, LinAlgLib[method]);\n});\n\n// done!\nreturn Object.freeze(LinAlg);\n})();\n\nmodule.exports = { LinAlg };","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * qr.js\n * QR decomposition\n */\n\n/**\n * QR decomposition\n * @param {object} header\n * @param {ArrayBufferView} output becomes [ Q | R ] or [ Q'x | R ] or [ Qx | R ]\n * @param {ArrayBufferView[]} inputs\n */\nexport function qr(header, output, inputs)\n{\n    const { stride, dtype } = header;\n    const [ orows, ocolumns ] = [ header.rows, header.columns ];\n    const [ irows, xrows ] = header.rowsOfInputs;\n    const [ icolumns, xcolumns ] = header.columnsOfInputs;\n    const [ istride ] = header.strideOfInputs;\n    const [ input, x ] = inputs;\n    const { mode } = header.custom;\n    const wantMatrices = (mode == 'full-qr' || mode == 'reduced-qr');\n\n    // create temporary storage\n    const storage = this.createTypedArray(dtype, 2 * irows * icolumns + icolumns);\n    const reflect = storage.subarray(0, irows * icolumns);\n    const tmprow = storage.subarray(irows * icolumns, irows * icolumns + icolumns);\n    const tmp = storage.subarray(irows * icolumns + icolumns, 2 * irows * icolumns + icolumns);\n\n    // create soon-to-be upper triangular matrix R\n    const rstride = stride;\n    const triangular = !wantMatrices ? output.subarray(stride) :\n        output.subarray(((mode == 'reduced-qr') ? icolumns : irows) * stride);\n\n    // input matrix is m x n and should be such that m >= n\n    if(irows < icolumns)\n        throw new Error(`Can't compute the QR decomposition of a ${irows} x ${icolumns} matrix`);\n\n    // validate the number of rows of the output\n    if(orows != irows)\n        throw new Error(`Can't compute the QR decomposition of a ${irows} x ${icolumns} matrix: expected an output matrix of ${irows} rows, but found a matrix of ${orows} rows`);\n\n    // copy input[:,:] to triangular[:,:]\n    if(input.length != triangular.length) {\n        this.runWithBlocks(this.copy, dtype, [\n            // output: 1st row, last row, 1st col, last col, stride\n            0, irows-1, 0, icolumns-1, rstride,\n\n            // inputs\n            0, irows-1, 0, icolumns-1, istride,\n        ], [ triangular, input ]);\n    }\n    else\n        triangular.set(input, 0, input.length);\n\n    // Compute the reflection vectors and the upper triangular matrix R\n    let i, j, k, n, norm, sign, fkk, rkk;\n    for(k = 0; k < icolumns; k++) {\n        fkk = k * irows + k; // reflector index\n        rkk = k * rstride + k; // upper-triangular R\n\n        n = irows - k; // the k-th reflection vector has n components\n        sign = (+(triangular[rkk] >= 0)) - (+(triangular[rkk] < 0)); // sign(triangular[k,k]) is +1 or -1\n\n        // use reflect[k:irows-1,k] to temporarily store the k-th reflection vector\n        for(i = 0; i < n; i++) // copy triangular[k:irows-1,k] to reflect[k:irows-1,k]\n            reflect[fkk + i] = triangular[rkk + i];\n        reflect[fkk] += sign * this.norm2(reflect, fkk, n); // 1st coordinate\n\n        // normalize the k-th reflection vector\n        norm = this.norm2(reflect, fkk, n);\n        // if(norm > 0) // error\n        for(i = fkk + n - 1; i >= fkk; i--)\n            reflect[i] /= norm;\n\n        // compute tmprow[0,0:icolumns-k-1] = reflect[k:irows-1,k]^T * triangular[k:irows-1,k:icolumns-1]\n        this.runWithBlocks(this.multiplylt, dtype, [\n            // output: 1st row, last row, 1st col, last col, stride\n            0, 0, 0, icolumns-k-1, 1, // row vector tmprow[0,0:icolumns-k-1]\n\n            // inputs\n            k, irows-1, k, k, irows, // reflect[k:irows-1,k]\n            k, irows-1, k, icolumns-1, rstride, // triangular[k:irows-1,k:icolumns-1]\n        ], [ tmprow, reflect, triangular ]);\n\n        // compute tmp[0:irows-k-1,0:icolumns-k-1] = reflect[k:irows-1,k] * tmprow[0,0:icolumns-k-1]\n        this.runWithBlocks(this.outer, dtype, [\n            // output: 1st row, last row, 1st col, last col, stride\n            0, irows-k-1, 0, icolumns-k-1, irows, // tmp[0:irows-k-1,0:icolumns-k-1]\n\n            // inputs\n            k, irows-1, k, k, irows, // reflect[k:irows-1,k]\n            0, 0, 0, icolumns-k-1, 1, // tmprow[0,0:icolumns-k-1], the result of the previous calculation\n        ], [ tmp, reflect, tmprow ]);\n\n        // apply Householder reflector to set the column vector triangular[k+1:irows-1,k] to zero\n        // i.e., run triangular[k:irows-1,k:icolumns-1] -= 2 * tmp[0:irows-k-1,0:icolumns-k-1]\n        this.runWithBlocks(this.addInPlace, dtype, [\n            // output: 1st row, last row, 1st col, last col, stride\n            k, irows-1, k, icolumns-1, rstride, // triangular[k:irows-1,k:icolumns-1]\n\n            // inputs\n            k, irows-1, k, icolumns-1, rstride, // triangular[k:irows-1,k:icolumns-1]\n            0, irows-k-1, 0, icolumns-k-1, irows, // tmp[0:irows-k-1,0:icolumns-k-1], the result of the previous calculation\n        ], [ triangular, triangular, tmp ], { alpha: 1, beta: -2 });\n    }\n\n    // Compute the unitary matrix Q\n    switch(mode) {\n\n        //\n        // Full QR decomposition\n        // Q: m x m, R: m x n\n        //\n        case 'full-qr': {\n            const qstride = stride;\n            const unitary = output.subarray(0, qstride * irows).fill(0);\n            let fk, qj, dot;\n\n            // validate output size\n            if(orows != irows || ocolumns != icolumns + irows)\n                throw new Error(`Can't compute the full QR decomposition of a ${irows} x ${icolumns} matrix: expected an output matrix of size ${irows} x ${icolumns + irows}, found ${orows} x ${ocolumns}`);\n\n            // apply Householder reflectors to e_j = e_1, ... , e_m\n            for(j = 0; j < irows; j++) { // for each e_j\n                qj = j * qstride;\n                unitary[qj + j] = 1; // setup e_j = [ 0 0 0 ... 1 ... 0 0 0 ]^T\n                for(k = icolumns - 1; k >= 0; k--) { // compute Q e_j = ( Q_1 ... Q_n ) e_j\n                    fk = k * irows;\n                    dot = -2 * this.dot(unitary, reflect, qj + k, fk + k, irows - k);\n                    for(i = irows - 1; i >= k; i--)\n                        unitary[qj + i] += dot * reflect[fk + i];\n                }\n            }\n\n            /*\n            // fill the lower part of R with zeros\n            let rk;\n            for(rk = k = 0; k < icolumns; k++, rk += rstride) {\n                for(i = icolumns; i < irows; i++)\n                    triangular[rk + i] = 0;\n            }\n            */\n\n            break;\n        }\n\n        //\n        // Reduced QR decomposition\n        // Q: m x n, R: n x n\n        //\n        case 'reduced-qr': {\n            const qstride = stride;\n            const unitary = output.subarray(0, qstride * icolumns).fill(0);\n            let fk, qj, dot;\n\n            // validate output size\n            if(orows != irows || ocolumns != icolumns + icolumns)\n                throw new Error(`Can't compute the reduced QR decomposition of a ${irows} x ${icolumns} matrix: expected an output matrix of size ${irows} x ${icolumns + icolumns}, found ${orows} x ${ocolumns}`);\n\n            // apply Householder reflectors to e_j = e_1, ... , e_n (n <= m)\n            for(j = 0; j < icolumns; j++) { // for each e_j\n                qj = j * qstride;\n                unitary[qj + j] = 1; // setup e_j = [ 0 0 0 ... 1 ... 0 0 0 ]^T\n                for(k = icolumns - 1; k >= 0; k--) { // compute Q e_j = ( Q_1 ... Q_n ) e_j\n                    fk = k * irows;\n                    dot = -2 * this.dot(unitary, reflect, qj + k, fk + k, irows - k);\n                    for(i = irows - 1; i >= k; i--)\n                        unitary[qj + i] += dot * reflect[fk + i];\n                }\n            }\n\n            break;\n        }\n\n        //\n        // Compute y = Q'x for an input vector x (Q' means Q^T)\n        // x: m x 1, y: m x 1\n        //\n        case 'Q\\'x': {\n            const ystride = stride;\n            const y = output.subarray(0, ystride);\n            const m = irows, n = icolumns;\n            let fk, dot;\n\n            // validate input / output size\n            if(m != xrows || 1 != xcolumns)\n                throw new Error(`QR decomposition: the input vector is expected to be ${m} x 1, but is ${xrows} x ${xcolumns}`);\n            else if(m != orows || 1 + n != ocolumns)\n                throw new Error(`QR decomposition: the output matrix is expected to be ${m} x ${1+n}, but is ${orows} x ${ocolumns}`);\n\n            // initialize output vector\n            for(i = 0; i < m; i++)\n                y[i] = x[i];\n\n            // apply Householder reflectors to input x\n            for(k = 0; k < n; k++) { // compute Q'x = ( Q_n ... Q_1 ) x\n                fk = k * irows; // get the k-th reflector\n                dot = -2 * this.dot(y, reflect, k, fk + k, m - k);\n                for(i = k; i < m; i++)\n                    y[i] += dot * reflect[fk + i];\n            }\n\n            break;\n        }\n\n        //\n        // Compute Qx for an input vector x\n        // x: m x 1, y: m x 1\n        //\n        case 'Qx': {\n            const ystride = stride;\n            const y = output.subarray(0, ystride);\n            const m = irows, n = icolumns;\n            let fk, dot;\n\n            // validate input / output size\n            if(m != xrows || 1 != xcolumns)\n                throw new Error(`QR decomposition: the input vector is expected to be ${m} x 1, but is ${xrows} x ${xcolumns}`);\n            else if(m != orows || 1 + n != ocolumns)\n                throw new Error(`QR decomposition: the output matrix is expected to be ${m} x ${1+n}, but is ${orows} x ${ocolumns}`);\n\n            // initialize output vector\n            for(i = 0; i < m; i++)\n                y[i] = x[i];\n\n            // apply Householder reflectors to input x\n            for(k = n - 1; k >= 0; k--) { // compute Qx = ( Q_1 ... Q_n ) x\n                fk = k * irows; // get the k-th reflector\n                dot = -2 * this.dot(y, reflect, k, fk + k, m - k);\n                for(i = k; i < m; i++)\n                    y[i] += dot * reflect[fk + i];\n            }\n\n            break;\n        }\n\n        //\n        // Compute y = Q'x for an input vector x using reduced QR\n        // x: m x 1, y: m x 1\n        //\n        case 'reduced-Q\\'x': {\n            const m = irows, n = icolumns;\n            const y = output.subarray(0, n); // output[n..m-1] is unused\n            const e = tmp.subarray(0, m); // e_j is m x 1, for all j = 0, 1 .. n-1\n            let fk, dot;\n\n            // validate input / output size\n            if(m != xrows || 1 != xcolumns)\n                throw new Error(`QR decomposition: the input vector is expected to be ${m} x 1, but is ${xrows} x ${xcolumns}`);\n            else if(m != orows || 1 + n != ocolumns)\n                throw new Error(`QR decomposition: the output matrix is expected to be ${m} x ${1+n}, but is ${orows} x ${ocolumns}`);\n\n            // apply Householder reflectors\n            for(j = 0; j < n; j++) { // for each e_j\n                // setup e_j = [ 0 0 0 ... 1 ... 0 0 0 ]^T\n                e.fill(0);\n                e[j] = 1;\n\n                // compute Q e_j = ( Q_1 ... Q_n ) e_j\n                for(k = n - 1; k >= 0; k--) {\n                    fk = k * irows;\n                    dot = -2 * this.dot(e, reflect, k, fk + k, m - k);\n                    for(i = m - 1; i >= k; i--)\n                        e[i] += dot * reflect[fk + i];\n                }\n\n                // compute y_j = dot(x, Q e_j)\n                y[j] = this.dot(x, e, 0, 0, m);\n            }\n\n            break;\n        }\n\n        default:\n            throw new Error(`QR decomposition: unknown mode \"${mode}\"`);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * ransac.js\n * Variants of RANSAC\n */\n\n/**\n * P-RANSAC for homography estimation\n * This is a new JavaScript implementation based on Nister's preemptive RANSAC idea\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs\n */\nexport function pransacHomography(header, output, inputs)\n{\n    const { dtype, rows, columns, stride } = header;\n    const src = inputs[0], dst = inputs[1]; // 2 x n matrices featuring source & destination points\n    const mask = inputs[2]; // 1 x n matrix\n    const n = header.columnsOfInputs[0]; // number of points\n    const sstride = header.strideOfInputs[0];\n    const dstride = header.strideOfInputs[1];\n    const mstride = header.strideOfInputs[2];\n    const { numberOfHypotheses, bundleSize, reprojectionError } = header.custom;\n    const reprojErr2 = reprojectionError * reprojectionError;\n    const ptsPerHyp = 4 * numberOfHypotheses; // need 4 points per hypothesis\n    const len = ptsPerHyp + n - (ptsPerHyp % n); // pick a multiple of n that is >= ptsPerHyp\n    const ptidx = Array.from({ length: len }, (_, i) => i % n); // indices of points\n    const permutation = this.shuffle(this.range(n));\n    const hypbuf = this.createTypedArray(dtype, 9 * numberOfHypotheses);\n    function Hypothesis(mat) { this.mat = mat; this.err = 0; }\n    const hypothesis = Array.from({ length: numberOfHypotheses },\n        (_, i) => new Hypothesis(hypbuf.subarray(9 * i, 9 * (i+1)))\n    );\n    const smat = this.createTypedArray(dtype, 8), dmat = this.createTypedArray(dtype, 8);\n    const hompts = [ smat, dmat ];\n    const homheader = this.run(null, dtype, [ 3, 3, 3, 2, 4, 2, 2, 4, 2 ], [ hypothesis[0].mat, smat, dmat ]);\n    const cmp = (hi, hj) => hi.err - hj.err;\n    const b = bundleSize;\n    let m = numberOfHypotheses;\n    let h = 0, i = 0, j = 0, ij = 0, iij = 0, oj = 0;\n    let p0 = 0, p1 = 0, p2 = 0, p3 = 0;\n    let x = 0.0, y = 0.0, z = 0.0, dx = 0.0, dy = 0.0, sx = 0.0, sy = 0.0, hx = 0.0, hy = 0.0;\n    let hom = hypothesis[0].mat;\n    let badcnt = 0;\n\n    // Shuffle input\n    for(i = 0; i < len; i += n)\n        this.shuffle(ptidx, i, i+n);\n\n    // Generate m hypotheses\n    for(h = 0; h < m; h++) {\n        // pick 4 points at random\n        j = 4 * h;\n        p0 = ptidx[j]\n        p1 = ptidx[j + 1];\n        p2 = ptidx[j + 2];\n        p3 = ptidx[j + 3];\n\n        // set reference\n        hom = hypothesis[h].mat;\n\n        // grab source points\n        smat[0] = src[sstride * p0 + 0];\n        smat[1] = src[sstride * p0 + 1];\n        smat[2] = src[sstride * p1 + 0];\n        smat[3] = src[sstride * p1 + 1];\n        smat[4] = src[sstride * p2 + 0];\n        smat[5] = src[sstride * p2 + 1];\n        smat[6] = src[sstride * p3 + 0];\n        smat[7] = src[sstride * p3 + 1];\n\n        // grab destination points\n        dmat[0] = dst[dstride * p0 + 0];\n        dmat[1] = dst[dstride * p0 + 1];\n        dmat[2] = dst[dstride * p1 + 0];\n        dmat[3] = dst[dstride * p1 + 1];\n        dmat[4] = dst[dstride * p2 + 0];\n        dmat[5] = dst[dstride * p2 + 1];\n        dmat[6] = dst[dstride * p3 + 0];\n        dmat[7] = dst[dstride * p3 + 1];\n\n        // generate hypothesis\n        this.homographynorm4p(homheader, hom, hompts);\n        //this.homography4p(homheader, hom, hompts);\n\n        // bad homography?\n        if(Number.isNaN(hom[0])) {\n            hypothesis[h].err = n; // all points are outliers\n            badcnt++;\n        }\n    }\n\n    // Remove bad homographies\n    badcnt = badcnt < m ? badcnt : m - 1;\n    hypothesis.sort(cmp);\n    hypothesis.length = (m -= badcnt);\n\n    // For each correspondence\n    for(i = 0; i < n ; i++) {\n        // cut the number of hypotheses in half (every b iterations)\n        if(i % b == 0 && m > 1) {\n            hypothesis.sort(cmp); // keep the best ones\n            m = m >>> 1; // m div 2\n            hypothesis.length = m;\n        }\n\n        // we've got only 1 hypothesis left\n        if(m == 1)\n            break;\n\n        // pick a correspondence of points\n        //p0 = (Math.random() * n) | 0; // pick a random correspondence with replacement\n        p0 = permutation[i]; // pick a random correspondence without replacement\n        sx = src[sstride * p0 + 0]; // src_x\n        sy = src[sstride * p0 + 1]; // src_y\n        hx = dst[dstride * p0 + 0]; // dst_x\n        hy = dst[dstride * p0 + 1]; // dst_y\n\n        // evaluate the m best hypotheses so far using the p0-th correspondence\n        for(h = 0; h < m; h++) {\n            hom = hypothesis[h].mat;\n            z = hom[2] * sx + hom[5] * sy + hom[8];\n            x = (hom[0] * sx + hom[3] * sy + hom[6]) / z;\n            y = (hom[1] * sx + hom[4] * sy + hom[7]) / z;\n            dx = x - hx; dy = y - hy;\n            hypothesis[h].err += (dx * dx + dy * dy > reprojErr2) | 0;\n        }\n    }\n\n    // pick the best hypothesis j\n    for(j = 0, h = 1; h < m; h++) {\n        if(hypothesis[h].err < hypothesis[j].err)\n            j = h;\n    }\n    hom = hypothesis[j].mat;\n\n    // read the entries of the best homography\n    const h00 = hom[0], h01 = hom[3], h02 = hom[6],\n          h10 = hom[1], h11 = hom[4], h12 = hom[7],\n          h20 = hom[2], h21 = hom[5], h22 = hom[8];\n\n    // separate inliers from outliers\n    const inliers = [];\n    for(ij = 0, iij = 0, oj = 0, j = 0; j < n; j++, ij += sstride, iij += dstride, oj += mstride) {\n        sx = src[ij + 0];\n        sy = src[ij + 1];\n\n        z = h20 * sx + h21 * sy + h22;\n        x = (h00 * sx + h01 * sy + h02) / z;\n        y = (h10 * sx + h11 * sy + h12) / z;\n\n        dx = x - dst[iij + 0];\n        dy = y - dst[iij + 1];\n        if((mask[oj] = (dx * dx + dy * dy <= reprojErr2) | 0))\n            inliers.push(j);\n    }\n\n    // write the best homography to the output\n    const stride2 = stride + stride;\n    output[0] = h00;\n    output[1] = h10;\n    output[2] = h20;\n    output[0 + stride] = h01;\n    output[1 + stride] = h11;\n    output[2 + stride] = h21;\n    output[0 + stride2] = h02;\n    output[1 + stride2] = h12;\n    output[2 + stride2] = h22;\n\n    // refine the homography: use only inliers\n    if(inliers.length > 4) {\n        const cnt = inliers.length;\n        const buf = this.createTypedArray(dtype, 4 * cnt); // two 2 x cnt matrices\n        const isrc = buf.subarray(0, 2 * cnt);\n        const idst = buf.subarray(2 * cnt, 4 * cnt);\n\n        // copy the inliers to isrc and idst\n        for(i = j = 0; j < cnt; j++, i += 2) {\n            p0 = inliers[j];\n            isrc[i + 0] = src[sstride * p0 + 0];\n            isrc[i + 1] = src[sstride * p0 + 1];\n            idst[i + 0] = dst[dstride * p0 + 0];\n            idst[i + 1] = dst[dstride * p0 + 1];\n        }\n\n        // normalized DLT using inliers only\n        this.run(this.homographynormdlt, dtype, [\n            // output\n            rows, columns, stride,\n\n            // inputs\n            2, cnt, 2,\n            2, cnt, 2,\n        ], [ output, isrc, idst ]);\n\n        // Note: should we recompute the inliers mask?\n    }\n\n    // bad homography!\n    else if(inliers.length < 4) {\n        for(i = 0; i < 3; i++)\n            output[i] = output[i + stride] = output[i + stride2] = Number.NaN;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * sequence.js\n * Sequences of matrix operations\n */\n\n/**\n * A sequence of matrix operations encapsulated into one\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs\n */\nexport function sequence(header, output, inputs)\n{\n    this.subroutine('sequence', header, inputs);\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * solve.js\n * Utilities for solving linear systems of equations\n */\n\n/**\n * Back-substitution: solve Rx = b for x,\n * where R is n x n upper triangular\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs a single input of the form [ b | R ]\n */\nexport function backsub(header, output, inputs)\n{\n    const { rows, columns } = header;\n    const [ input ] = inputs;\n    const [ irows ] = header.rowsOfInputs;\n    const [ icolumns ] = header.columnsOfInputs;\n    const [ istride ] = header.strideOfInputs;\n\n    if(icolumns !== irows + 1)\n        throw new Error(`Invalid input for backsub: expected ${irows} x ${irows+1} or ${icolumns-1} x ${icolumns} matrix, but found ${irows} x ${icolumns} matrix`);\n    else if(rows !== irows || columns !== 1)\n        throw new Error(`Invalid output for backsub: expected ${irows} x 1 matrix, but found ${rows} x ${columns} matrix`);\n\n    // Back-substitution\n    const n = irows;\n    const x = output; // x is n x 1 vector (output)\n    const b = input.subarray(0, istride); // b is n x 1 vector\n    const r = input.subarray(istride); // R is n x n upper triangular\n    let i, j, rjj, rj = (n-1) * istride; // column index\n\n    x[n-1] = b[n-1] / r[rj + (n-1)];\n    for(j = n-2; j >= 0; j--) {\n        x[j] = b[j];\n        for(i = j+1; i < n; i++)\n            x[j] -= x[i] * r[istride * i + j];\n\n        rj -= istride;\n        rjj = r[rj + j];\n        /*\n        if(rjj === 0)\n            throw new Error(`Invalid input for backsub: ${j+1}-th diagonal element of the upper triangular matrix is zero`);\n        */\n        x[j] /= rjj;\n    }\n}\n\n/**\n * Find best-fit solution of Ax = b with least-squares method\n * A is m x n, b is m x 1, output x is n x 1\n * (m equations, n unknowns, m >= n)\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs [ A, b ]\n */\nexport function lssolve(header, output, inputs)\n{\n    const { stride, dtype } = header;\n    const [ m, n ] = [ header.rowsOfInputs[0], header.columnsOfInputs[0] ];\n    const [ matA, vecB ] = inputs;\n    const [ strideA, strideB ] = header.strideOfInputs;\n    const tmp = this.createTypedArray(dtype, m * (n+1));\n\n    // find [ Q'b | R ] with a reduced QR of A\n    this.run(this.qr, dtype, [\n        // output: rows, columns, stride\n        m, n+1, m,\n\n        // inputs\n        m, n, strideA,\n        m, 1, strideB,\n    ], [ tmp, matA, vecB ], { mode: \"reduced-Q'x\" });\n\n    // extract the top n x (n+1) submatrix of [ Q'b | R ]\n    // (the bottom rows are zeros) to solve R x = Q'b for x\n    this.runWithBlocks(this.backsub, dtype, [\n        // output: 1st row, last row, 1st col, last col, stride\n        0, n-1, 0, 0, stride, // output[0:n-1,0]\n\n        // inputs\n        0, n-1, 0, n, m, // tmp[0:n-1,0:n]\n    ], [ output, tmp ]);\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * transform.js\n * Geometric transformations\n */\n\n/**\n * Apply a homography matrix to a set of 2D points\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs\n */\nexport function applyHomography(header, output, inputs)\n{\n    const { columns, stride } = header;\n    const [ hom, pts ] = inputs;\n    const [ hstride, pstride ] = header.strideOfInputs;\n    const hstride2 = hstride + hstride;\n\n    // read the entries of the homography\n    const h00 = hom[0];\n    const h10 = hom[1];\n    const h20 = hom[2];\n    const h01 = hom[0 + hstride];\n    const h11 = hom[1 + hstride];\n    const h21 = hom[2 + hstride];\n    const h02 = hom[0 + hstride2];\n    const h12 = hom[1 + hstride2];\n    const h22 = hom[2 + hstride2];\n\n    // for each point (column of pts), apply the homography\n    // (we use homogeneous coordinates internally)\n    let j, ij, oj, x, y, d;\n    for(ij = oj = j = 0; j < columns; j++, ij += pstride, oj += stride) {\n        x = pts[ij];\n        y = pts[ij + 1];\n        d = h20 * x + h21 * y + h22;\n        output[oj] = (h00 * x + h01 * y + h02) / d;\n        output[oj + 1] = (h10 * x + h11 * y + h12) / d;\n    }\n}\n\n/**\n * Apply an affine transformation to a set of 2D points\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs\n */\nexport function applyAffine(header, output, inputs)\n{\n    const { columns, stride } = header;\n    const [ mat, pts ] = inputs;\n    const [ mstride, pstride ] = header.strideOfInputs;\n    const mstride2 = mstride + mstride;\n\n    // read the entries of the transformation\n    const m00 = mat[0];\n    const m10 = mat[1];\n    const m01 = mat[0 + mstride];\n    const m11 = mat[1 + mstride];\n    const m02 = mat[0 + mstride2];\n    const m12 = mat[1 + mstride2];\n\n    // for each point (column of pts), apply the transformation\n    let j, ij, oj, x, y;\n    for(ij = oj = j = 0; j < columns; j++, ij += pstride, oj += stride) {\n        x = pts[ij];\n        y = pts[ij + 1];\n        output[oj] = m00 * x + m01 * y + m02;\n        output[oj + 1] = m10 * x + m11 * y + m12;\n    }\n}\n\n/**\n * Apply a 2x2 linear transformation to a set of 2D points\n * @param {object} header\n * @param {ArrayBufferView} output\n * @param {ArrayBufferView[]} inputs\n */\nexport function applyLinear2d(header, output, inputs)\n{\n    const { columns, stride } = header;\n    const [ mat, pts ] = inputs;\n    const [ mstride, pstride ] = header.strideOfInputs;\n\n    // read the entries of the transformation\n    const m00 = mat[0];\n    const m10 = mat[1];\n    const m01 = mat[0 + mstride];\n    const m11 = mat[1 + mstride];\n\n    // for each point (column of pts), apply the transformation\n    let j, ij, oj, x, y;\n    for(ij = oj = j = 0; j < columns; j++, ij += pstride, oj += stride) {\n        x = pts[ij];\n        y = pts[ij + 1];\n        output[oj] = m00 * x + m01 * y;\n        output[oj + 1] = m10 * x + m11 * y;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * utils.js\n * Low-level utilities for Linear Algebra routines\n */\n\n/**\n * Call a Linear Algebra routine\n * @param {MatrixOperationHeader} header\n * @param {ArrayBuffer} outputBuffer\n * @param {ArrayBuffer[]} inputBuffers\n */\nexport function execute(header, outputBuffer, inputBuffers)\n{\n    // wrap the incoming buffers with the appropriate TypedArrays\n    const output = this.createTypedArray(header.dtype, outputBuffer, header.byteOffset, header.length);\n    const inputs = inputBuffers.map((inputBuffer, i) =>\n        this.createTypedArray(header.dtype, inputBuffer, header.byteOffsetOfInputs[i], header.lengthOfInputs[i])\n    );\n\n    // perform the computation\n    (this[header.method])(header, output, inputs);\n}\n\n/**\n * Fast & handy wrapper to run a Linear Algebra routine from another one\n * @param {?Function} fn the function that you wish to call\n * @param {string} dtypes data types\n * @param {number[]} shapes flattened triples (rows, columns, stride) of output, input1, input2, input3...\n * @param {ArrayBufferView[]} data flattened array containing output array, input1 array, input2 array...\n * @param {object} [custom] user-data\n * @returns {object} the header object that was used to call the routine\n */\nexport function run(fn, dtypes, shapes, data, custom = {})\n{\n    const n = data.length - 1; // number of input matrices\n    if(3 * n + 3 !== shapes.length || n < 0)\n        throw new Error(`Can't run() routine with invalid input`);\n\n    const inputs = new Array(n);\n    const rowsOfInputs = new Array(n);\n    const columnsOfInputs = new Array(n);\n    const strideOfInputs = new Array(n);\n    //const lengthOfInputs = new Array(n);\n    //const byteOffsetOfInputs = new Array(n);\n\n    for(let j = 3, i = 0; i < n; i++, j += 3) {\n        inputs[i] = data[i+1];\n        rowsOfInputs[i] = shapes[j];\n        columnsOfInputs[i] = shapes[j+1];\n        strideOfInputs[i] = shapes[j+2];\n        //lengthOfInputs[i] = data[i+1].length;\n        //byteOffsetOfInputs[i] = data[i+1].byteOffset;\n    }\n\n    const header = {\n        method: '', dtype: dtypes, custom: custom,\n\n        rows: shapes[0],\n        columns: shapes[1],\n        stride: shapes[2],\n\n        rowsOfInputs: rowsOfInputs,\n        columnsOfInputs: columnsOfInputs,\n        strideOfInputs: strideOfInputs,\n\n        /*length: data[0].length,\n        lengthOfInputs: lengthOfInputs,\n        byteOffset: data[0].byteOffset,\n        byteOffsetOfInputs: byteOffsetOfInputs,*/\n        length: 0, lengthOfInputs: [],\n        byteOffset: 0, byteOffsetOfInputs: [],\n    };\n\n    if(fn != null)\n        fn.call(this, header, data[0], inputs);\n\n    return header;\n}\n\n/**\n * Similar to run(), but this function extracts blocks of the matrices\n * Make sure you get the indices right, because they won't be checked!\n * @param {?Function} fn the function that you wish to call\n * @param {string} dtypes data types\n * @param {number[]} shapesOfBlocks flattened tuples (firstRow, lastRow, firstCol, lastCol, stride) of output, input1...\n * @param {ArrayBufferView[]} originalData flattened array containing output array, input1 array, input2 array...\n * @param {object} [custom] user-data\n * @returns {object} the header object that was used to call the routine\n */\nexport function runWithBlocks(fn, dtypes, shapesOfBlocks, originalData, custom = {})\n{\n    const n = originalData.length;\n    if(shapesOfBlocks.length !== 5 * n)\n        throw new Error(`Can't runWithBlocks() with invalid input`);\n\n    const newShapes = new Array(3 * n);\n    const newArrays = new Array(n);\n\n    for(let baseAddr = 0, stride = 0, j = 0, i = 0; i < n; i++, j += 3, baseAddr += 5) {\n        // compute the shape of the block\n        newShapes[j+0] = shapesOfBlocks[baseAddr+1] - shapesOfBlocks[baseAddr+0] + 1; // number of rows\n        newShapes[j+1] = shapesOfBlocks[baseAddr+3] - shapesOfBlocks[baseAddr+2] + 1; // number of columns\n        newShapes[j+2] = stride = shapesOfBlocks[baseAddr+4]; // stride\n\n        // extract subarray\n        newArrays[i] = originalData[i].subarray(\n            shapesOfBlocks[baseAddr+2] * stride + shapesOfBlocks[baseAddr+0], // 1st col * stride + 1st row\n            shapesOfBlocks[baseAddr+3] * stride + shapesOfBlocks[baseAddr+1] + 1\n        );\n    }\n\n    return this.run(fn, dtypes, newShapes, newArrays, custom);\n}\n\n/**\n * Call a stored subroutine\n * @param {string} subname\n * @param {object} header\n * @param {ArrayBufferView[]} inputs\n */\nexport function subroutine(subname, header, inputs)\n{\n    const steps = header.custom.subroutine[subname];\n\n    // run a sequence of operations\n    for(let i = 0, n = steps.length; i < n; i++) {\n        const step = steps[i];\n        const stepOutput = inputs[step.indexOfOutputMatrix];\n        const stepInputs = step.indicesOfInputMatrices.map(index => inputs[index]);\n        const stepMethod = this[step.header.method];\n\n        stepMethod(step.header, stepOutput, stepInputs);\n    }\n}\n\n/**\n * Create a TypedArray of the specified type\n * @param {MatrixDataType} dtype data type\n * @param {any[]} args will be passed to the constructor of the TypedArray\n * @returns {ArrayBufferView}\n */\nexport function createTypedArray(dtype, ...args)\n{\n    return this.MatrixType.createTypedArray(dtype, ...args);\n}\n\n/**\n * The 2-norm of a column vector\n * @param {ArrayBufferView} column\n * @param {number} [begin] first index\n * @param {number} [length]\n * @returns {number}\n */\nexport function norm2(column, begin = 0, length = column.length)\n{\n    let norm = 0, end = begin + length, i;\n\n    // Since we store data in column-major format,\n    // we don't need to use stride\n    for(i = begin; i < end; i++)\n        norm += column[i] * column[i];\n\n    return Math.sqrt(norm);\n}\n\n/**\n * The dot product of two column vectors\n * @param {ArrayBufferView} u\n * @param {ArrayBufferView} v\n * @param {number} [uBegin] first index \n * @param {number} [vBegin] first index \n * @param {number} [length] \n */\nexport function dot(u, v, uBegin = 0, vBegin = 0, length = u.length)\n{\n    let dot = 0, i;\n\n    for(i = 0; i < length; i++)\n        dot += u[uBegin + i] * v[vBegin + i];\n\n    return dot;\n}\n\n/**\n * Fisher-Yates shuffle\n * @param {Array} array\n * @param {number} [begin] the index of the beginning of the subarray, inclusive\n * @param {number} [end] last index of the subarray, exclusive\n * @returns {Array} the input array, shuffled\n */\nexport function shuffle(array, begin = 0, end = array.length)\n{\n    begin = Math.max(begin, 0);\n    end = Math.min(end, array.length);\n\n    for(let t, j, i = end - 1; i > begin; i--) {\n        j = ((Math.random() * (i+1 - begin)) | 0) + begin;\n        t = array[i];\n        array[i] = array[j];\n        array[j] = t;\n    }\n\n    return array;\n}\n\n/**\n * Range from 0 to n-1\n * @param {number} n\n * @returns {number[]} array of length n\n */\nexport function range(n)\n{\n    return Array.from({ length: n }, (_, i) => i);\n}\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * matrix-buffer.js\n * Storage for elements of matrices\n */\n\nimport { MatrixType } from './matrix-type';\nimport { IllegalArgumentError, IllegalOperationError, NotSupportedError } from '../../utils/errors';\nimport { SpeedyPromise } from '../../utils/speedy-promise';\n\n\n/**\n * Stores the contents of a matrix\n */\nexport class MatrixBuffer\n{\n    /**\n     * Class constructor\n     * @param {number} length number of elements of the buffer\n     * @param {number[]|ArrayBufferView|null} [values] initial values in column-major format\n     * @param {MatrixDataType} [dtype] the type of the elements of the matrix\n     * @param {?MatrixBuffer} [parent] the buffer that originated this one, if any\n     */\n    constructor(length, values = null, dtype = MatrixType.default, parent = null)\n    {\n        length |= 0;\n\n        // validate\n        if(!MatrixType.isValid(dtype))\n            throw new IllegalArgumentError(`Invalid data type: \"${dtype}\"`);\n        if(length <= 0)\n            throw new IllegalArgumentError(`Invalid matrix length`);\n\n        // allocate new TypedArray\n        const data =\n            (values == null) ? MatrixType.createTypedArray(dtype, length) : (\n            Array.isArray(values) ? MatrixType.createTypedArray(dtype, values) :\n            values);\n\n\n\n        // store data\n\n        /** @type {MatrixDataType} data type */\n        this._dtype = dtype;\n\n        /** @type {ArrayBufferView} a reference to the TypedArray (storage) */\n        this._data = data;\n\n        /** @type {number} TypedArray byte offset: assumed to be constant */\n        this._byteOffset = data.byteOffset;\n\n        /** @type {number} TypedArray length: assumed to be constant */\n        this._length = data.length;\n\n\n\n        // concurrency control\n\n        /** @type {number} number of pending operations that read from or write to the buffer */\n        this._pendingOperations = parent ? parent._pendingOperations : 0;\n\n        /** @type {Array<function()>} a list of Function<void> to be called as soon as there are no pending operations */\n        this._pendingAccessesQueue = [];\n\n        /** @type {MatrixBuffer[]} a list of MatrixBuffers that share their internal memory with this one (we create a tree structure) */\n        this._children = [];\n\n        /** @type {?MatrixBuffer} the buffer that originated this one, if any (null if none) */\n        this._parent = parent;\n    }\n\n    /**\n     * Data type\n     * @returns {MatrixDataType}\n     */\n    get dtype()\n    {\n        return this._dtype;\n    }\n\n    /**\n     * Get the internal TypedArray that holds the entries of the Matrix\n     * Make sure the buffer is ready() before accessing this property\n     * @returns {ArrayBufferView}\n     */\n    get data()\n    {\n        return this._data;\n    }\n\n    /**\n     * Wait for buffer readiness. Since the buffer holds\n     * a Transferable object, the data may or may not be\n     * available right now. The returned SpeedyPromise will be\n     * resolved as soon as the buffer is available for\n     * reading and writing\n     * @returns {SpeedyPromise<MatrixBuffer>}\n     */\n    ready()\n    {\n        if(this._pendingOperations > 0) {\n            // we're not ready yet: there are calculations taking place...\n            // we'll resolve this promise as soon as there are no pending calculations\n            return new SpeedyPromise(resolve => {\n                this._pendingAccessesQueue.push(() => resolve(this));\n            });\n        }\n        else {\n            // we're ready to go!\n            // no pending operations\n            return SpeedyPromise.resolve(this);\n        }\n    }\n\n    /**\n     * Lock the buffer, so it can't be read from nor written to\n     * @param {boolean} [ascend] internal\n     */\n    lock(ascend = true)\n    {\n        let my = this;\n\n        // climb the tree\n        if(ascend && my._parent) {\n            do { my = my._parent; } while(my._parent);\n        }\n\n        // lock this buffer\n        ++my._pendingOperations;\n\n        // broadcast\n        for(let i = my._children.length - 1; i >= 0; i--)\n            my._children[i].lock(false);\n    }\n\n    /**\n     * Unlock the buffer and resolve all pending read/write operations\n     * @param {boolean} [ascend] internal\n     */\n    unlock(ascend = true)\n    {\n        let my = this;\n\n        // climb the tree\n        if(ascend && my._parent) {\n            do { my = my._parent; } while(my._parent);\n        }\n\n        // unlock this buffer\n        if(--my._pendingOperations <= 0) {\n            const callbackQueue = my._pendingAccessesQueue.slice(0); // fast clone\n            const n = callbackQueue.length;\n\n            my._pendingOperations = 0;\n            my._pendingAccessesQueue.length = 0;\n\n            for(let i = 0; i < n; i++) {\n                // if the buffer has been locked again, put the functions back in the queue\n                if(my._pendingOperations > 0) {\n                    for(let j = n - 1; j >= i; j--) {\n                        my._pendingAccessesQueue.unshift(callbackQueue[j]);\n                    }\n                    break; // note: for each lock() we need an unlock()\n                }\n\n                // if the buffer remains unlocked, we're cool\n                callbackQueue[i].call(my);\n            }\n        }\n\n        // broadcast\n        for(let i = my._children.length - 1; i >= 0; i--)\n            my._children[i].unlock(false);\n    }\n\n    /**\n     * Replace the internal buffer of the TypedArray\n     * @param {ArrayBuffer} arrayBuffer new internal buffer\n     */\n    replace(arrayBuffer)\n    {\n        if(this._data.buffer !== arrayBuffer)\n            this._replace(arrayBuffer, true);\n    }\n\n    /**\n     * Create a MatrixBuffer that shares its internal memory with this one\n     * @param {number} [begin] index of the first element of the TypedArray\n     * @param {number} [length] number of elements of the TypedArray\n     * @returns {SpeedyPromise<MatrixBuffer>}\n     */\n    createSharedBuffer(begin = 0, length = this._length)\n    {\n        return this.ready().then(() => {\n            // obtain shared area of memory\n            const end = Math.min(begin + length, this._length);\n            const data = this._data.subarray(begin, end); // the main thread must own this._data\n\n            // create shared buffer\n            const sharedBuffer = new MatrixBuffer(length, data, this._dtype, this);\n            this._children.push(sharedBuffer);\n\n            // done!\n            return sharedBuffer;\n        });\n    }\n\n    /**\n     * Replace the internal buffer of the TypedArray\n     * @param {ArrayBuffer} arrayBuffer new internal buffer\n     * @param {boolean} [ascend] internal\n     */\n    _replace(arrayBuffer, ascend = true)\n    {\n        let my = this;\n\n        // climb the tree\n        if(my._parent && ascend) {\n            do { my = my._parent; } while(my._parent);\n        }\n\n        // replace the internal buffer\n        my._data = MatrixType.createTypedArray(this._dtype, arrayBuffer, my._byteOffset, my._length);\n\n        // broadcast\n        for(let i = my._children.length - 1; i >= 0; i--)\n            my._children[i]._replace(arrayBuffer, false);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * matrix-expression-factory.js\n * A factory of matrix expressions\n */\n\nimport { IllegalArgumentError } from '../../utils/errors';\nimport { MatrixType } from './matrix-type';\nimport { MatrixShape } from './matrix-shape';\nimport { SpeedyMatrix } from './matrix';\nimport { SpeedyMatrixSettings } from './matrix-settings';\nimport { SpeedyPoint2 } from '../speedy-point';\nimport {\n    SpeedyMatrixExpr,\n    SpeedyMatrixLvalueExpr,\n    SpeedyMatrixElementaryExpr,\n    SpeedyMatrixHomography4pExpr,\n    SpeedyMatrixHomographyDLTExpr,\n    SpeedyMatrixApplyHomographyExpr,\n    SpeedyMatrixApplyAffineExpr,\n    SpeedyMatrixApplyLinear2dExpr,\n    SpeedyMatrixPransacHomographyExpr,\n} from './matrix-expressions';\n\n/**\n * A factory of matrix expressions\n */\nexport class SpeedyMatrixExprFactory extends Function\n{\n    // ==============================================\n    // Matrices with known entries\n    // ==============================================\n\n    /**\n     * The factory can be invoked as a function\n     * This is an alias to SpeedyMatrixExprFactory._create()\n     */\n    constructor()\n    {\n        super('...args', 'return this._create(...args)');\n        return this.bind(this);\n    }\n\n    /**\n     * Create a new matrix filled with zeroes\n     * @param {number} rows number of rows\n     * @param {number} [columns] number of columns (defaults to the number of rows)\n     * @param {number[]} [values] initial values in column-major format\n     * @param {MatrixDataType} [dtype] data type of the elements of the matrix\n     * @returns {SpeedyMatrixElementaryExpr}\n     */\n    Zeros(rows, columns = rows, dtype = MatrixType.default)\n    {\n        const values = (new Array(rows * columns)).fill(0);\n        return this._create(rows, columns, values, dtype);\n    }\n\n    /**\n     * Create a new matrix filled with ones\n     * @param {number} rows number of rows\n     * @param {number} [columns] number of columns (defaults to the number of rows)\n     * @param {number[]} [values] initial values in column-major format\n     * @param {MatrixDataType} [dtype] data type of the elements of the matrix\n     * @returns {SpeedyMatrixElementaryExpr}\n     */\n    Ones(rows, columns = rows, dtype = MatrixType.default)\n    {\n        const values = (new Array(rows * columns)).fill(1);\n        return this._create(rows, columns, values, dtype);\n    }\n\n    /**\n     * Create a new identity matrix\n     * @param {number} rows number of rows\n     * @param {number} [columns] number of columns (defaults to the number of rows)\n     * @param {number[]} [values] initial values in column-major format\n     * @param {MatrixDataType} [dtype] data type of the elements of the matrix\n     * @returns {SpeedyMatrixElementaryExpr}\n     */\n    Eye(rows, columns = rows, dtype = MatrixType.default)\n    {\n        const values = (new Array(rows * columns)).fill(0);\n        for(let j = Math.min(rows, columns) - 1; j >= 0; j--)\n            values[j * rows + j] = 1;\n\n        return this._create(rows, columns, values, dtype);\n    }\n\n    /**\n     * Create a new SpeedyMatrixExpr that evaluates to a user-defined matrix\n     * (or to a matrix without data if its entries are not provided)\n     * @param {number} rows number of rows\n     * @param {number} [columns] number of columns (defaults to the number of rows)\n     * @param {MatrixDataType} [dtype] data type of the elements of the matrix\n     * @param {number[]} [values] initial values in column-major format\n     * @returns {SpeedyMatrixElementaryExpr}\n     */\n    _create(rows, columns = rows, values = null, dtype = MatrixType.default)\n    {\n        let shape = new MatrixShape(rows, columns, dtype), matrix = null;\n\n        if(values != null) {\n            if(!Array.isArray(values))\n                throw new IllegalArgumentError(`Can't initialize SpeedyMatrix with values ${values}`);\n            if(values.length > 0)\n                matrix = new SpeedyMatrix(shape, values);\n        }\n\n        return new SpeedyMatrixElementaryExpr(shape, matrix);\n    }\n\n\n\n\n    // ==============================================\n    // General Utilities\n    // ==============================================\n\n    /**\n     * Settings object\n     * @returns {SpeedyMatrixSettings}\n     */\n    get Settings()\n    {\n        return SpeedyMatrixSettings.instance;\n    }\n\n    /**\n     * Evaluate the expression and store the result in a new matrix\n     * @param {SpeedyMatrixExpr} expr matrix expression\n     * @returns {SpeedyPromise<SpeedyMatrixLvalueExpr>}\n     */\n    evaluate(expr)\n    {\n        const mat = new SpeedyMatrixElementaryExpr(expr._shape);\n        return mat.assign(expr);\n    }\n\n    /**\n     * Convert an array of points to a matrix representation\n     * @param {SpeedyPoint2[]} points a non-empty array\n     * @param {MatrixDataType} [dtype] data type of the elements of the matrix\n     * @returns {SpeedyMatrixExpr} 2 x n matrix with the coordinates of the points\n     */\n    fromPoints(points, dtype = MatrixType.default)\n    {\n        if(!(Array.isArray(points) && points.length > 0))\n            throw new IllegalArgumentError(`Can't create matrix from points: ${points}`);\n\n        const entries = [], n = points.length;\n        for(let i = 0; i < n; i++) {\n            entries.push(points[i].x);\n            entries.push(points[i].y);\n        }\n\n        return this._create(2, n, entries, dtype);\n    }\n\n    /**\n     * Convert a 2 x n matrix to an array of points\n     * @param {SpeedyMatrixExpr} matrix\n     * @returns {SpeedyPromise<SpeedyPoint2[]>}\n     */\n    toPoints(matrix)\n    {\n        if(matrix.rows !== 2)\n            throw new IllegalArgumentError(`Can't convert ${matrix._shape.toString()} matrix to points`);\n\n        return matrix.read().then(entries => {\n            const points = [], n = entries.length;\n            for(let i = 0; i < n; i += 2)\n                points.push(new SpeedyPoint2(entries[i], entries[i+1]));\n\n            return points;\n        });\n    }\n\n\n\n    // ==============================================\n    // Matrix decompositions\n    // ==============================================\n\n    /**\n     * QR decomposition\n     * @param {SpeedyMatrixExpr} mat m x n matrix to be decomposed (m >= n)\n     * @param {QROptions} [options] configuration object\n     * @returns {SpeedyPromise<SpeedyMatrixExpr[]>} two matrices: [Q, R]\n     * \n     * @typedef {object} QROptions\n     * @property {string} [mode] \"reduced\" | \"full\"\n     */\n    QR(mat, options = {})\n    {\n        const m = mat.rows, n = mat.columns, dtype = mat.dtype;\n\n        // if full, Q is m x m and R is m x n\n        // if reduced, Q is m x n and R is n x n\n        const full = (options.mode == 'full');\n        const matQR = full ? this._create(m, m+n, null, dtype) : this._create(m, n+n, null, dtype);\n        const matQ = full ? matQR.block(0, m-1, 0, m-1) : matQR.block(0, m-1, 0, n-1);\n        const matR = full ? matQR.block(0, m-1, m, m+n-1) : matQR.block(0, n-1, n, n+n-1);\n\n        return matQR.assign(mat.qr(options.mode)).then(() => [ matQ, matR ]).turbocharge();\n    }\n\n\n\n\n\n    // ==============================================\n    // Geometric transformations\n    // ==============================================\n\n    /**\n     * Compute a perspective transformation using 4 correspondences of points\n     * @param {SpeedyMatrixExpr} source 2x4 matrix with coordinates of 4 points (ui, vi)\n     * @param {SpeedyMatrixExpr} destination 2x4 matrix with coordinates of 4 points (xi, yi)\n     * @returns {SpeedyMatrixExpr} 3x3 matrix: perspective transformation\n     */\n    Perspective(source, destination)\n    {\n        if(!(source.rows === 2 && source.columns === 4 && source._shape.equals(destination._shape)))\n            throw new IllegalArgumentError(`Can't compute perspective transformation using ${source} and ${destination}. 4 correspondences of points are required`);\n\n        return new SpeedyMatrixHomography4pExpr(source, destination);\n    }\n\n    /**\n     * Find a homography matrix using 4 or more correspondences of points\n     * @param {SpeedyMatrixExpr} source 2 x n matrix with coordinates of n points (n >= 4)\n     * @param {SpeedyMatrixExpr} destination 2 x n matrix with coordinates of n points\n     * @param {FindHomographyOptions} [options]\n     *\n     * @typedef {object} FindHomographyOptions\n     * @property {string} method One of the following: \"p-ransac\"\n     * @property {FindHomographyMethodParameters} [parameters]\n     *\n     * @typedef {object} FindHomographyMethodParameters\n     * @property {?SpeedyMatrixLvalueExpr} [mask] 1 x n output matrix to separate inliers (1) from outliers (0)\n     * @property {number} [reprojectionError] threshold in pixels to separate inliers from outliers (RANSAC variants)\n     * @property {number} [numberOfHypotheses] for p-ransac only\n     * @property {number} [bundleSize] for p-ransac only\n     */\n    findHomography(source, destination, options = {})\n    {\n        // default options\n        options.method = options.method || 'p-ransac';\n        options.parameters = Object.assign({\n            mask: null,\n            numberOfHypotheses: 500,\n            bundleSize: 100,\n            reprojectionError: 2\n        }, options.parameters || {});\n\n        // validate shapes\n        if(!(source.rows === 2 && source.columns >= 4 && source._shape.equals(destination._shape)))\n            throw new IllegalArgumentError(`Can't compute homography matrix using ${source} and ${destination}. 4 or more correspondences of points are required`);\n\n        // returns a node according to the method\n        const parameters = options.parameters;\n        if(options.method === 'p-ransac') {\n            // create an output inlier-outlier mask if one is not supplied\n            const maskShape = new MatrixShape(1, source.columns, source.dtype); // expected shape\n            const mask = parameters.mask || new SpeedyMatrixElementaryExpr(maskShape, new SpeedyMatrix(maskShape));\n\n            // cast to number\n            const numberOfHypotheses = parameters.numberOfHypotheses | 0;\n            const bundleSize = parameters.bundleSize | 0;\n            const reprojectionError = +(parameters.reprojectionError);\n\n            // validate\n            if(!(mask instanceof SpeedyMatrixLvalueExpr && mask._shape.equals(maskShape)))\n                throw new IllegalArgumentError(`Can't compute homography matrix: invalid mask`);\n            else if(numberOfHypotheses <= 0 || bundleSize <= 0 || reprojectionError < 0)\n                throw new IllegalArgumentError(`Can't compute homography matrix: invalid parameters for \"${options.method}\"`);\n\n            // done!\n            return new SpeedyMatrixPransacHomographyExpr(\n                source,\n                destination,\n                numberOfHypotheses,\n                bundleSize,\n                reprojectionError,\n                mask,\n            );\n        }\n        else if(options.method === 'dlt') {\n            return new SpeedyMatrixHomographyDLTExpr(\n                source,\n                destination\n            );\n        }\n        else {\n            // invalid method\n            throw new IllegalArgumentError(`Can't compute homography matrix using method \"${options.method}\"`);\n        }\n    }\n\n    /**\n     * Apply a transformation matrix to a set of 2D points\n     * @param {SpeedyMatrixExpr} mat homography (3x3) or affine (2x3) or linear (2x2)\n     * @param {SpeedyMatrixExpr} points a set of n 2D points (2xn)\n     * @returns {SpeedyMatrixExpr} a 2xn matrix\n     */\n    transform(mat, points)\n    {\n        if(points.rows !== 2)\n            throw new IllegalArgumentError(`Can't apply transform: invalid set of points (${points._shape.toString()})`);\n\n        if(mat.columns === 3) {\n            if(mat.rows === 3)\n                return new SpeedyMatrixApplyHomographyExpr(mat, points);\n            else if(mat.rows === 2)\n                return new SpeedyMatrixApplyAffineExpr(mat, points);\n        }\n        else if(mat.columns === 2 && mat.rows === 2)\n            return new SpeedyMatrixApplyLinear2dExpr(mat, points);\n\n        throw new IllegalArgumentError(`Can't apply transformation: invalid transformation matrix (${mat._shape.toString()})`);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * matrix-expressions.js\n * Abstract Matrix Algebra\n */\n\nimport { SpeedyMatrix } from './matrix';\nimport { BoundMatrixOperation, BoundMatrixOperationTree } from './bound-matrix-operation';\nimport { MatrixShape } from './matrix-shape';\nimport { MatrixOperationsQueue } from './matrix-operations-queue';\nimport { AbstractMethodError, IllegalArgumentError, IllegalOperationError, NotSupportedError, NotImplementedError } from '../../utils/errors';\nimport { SpeedyPromise } from '../../utils/speedy-promise';\nimport { Utils } from '../../utils/utils';\nimport { OddEvenMergesort } from '../../utils/sorting-networks';\nimport {\n    MatrixOperation,\n    MatrixOperationNop,\n    MatrixOperationFill,\n    MatrixOperationCopy,\n    MatrixOperationTranspose,\n    MatrixOperationInverse,\n    MatrixOperationAdd,\n    MatrixOperationSubtract,\n    MatrixOperationMultiply,\n    MatrixOperationMultiplyLT,\n    MatrixOperationMultiplyRT,\n    MatrixOperationMultiplyVec,\n    MatrixOperationScale,\n    MatrixOperationCompMult,\n    MatrixOperationQR,\n    MatrixOperationQRSolve,\n    MatrixOperationLSSolve,\n    MatrixOperationBackSubstitution,\n    MatrixOperationSort,\n    MatrixOperationMap,\n    MatrixOperationReduce,\n    MatrixOperationHomography4p,\n    MatrixOperationHomographyDLT,\n    MatrixOperationApplyHomography,\n    MatrixOperationApplyAffine,\n    MatrixOperationApplyLinear2d,\n    MatrixOperationPransacHomography,\n} from './matrix-operations';\n\n// constants\nconst matrixOperationsQueue = MatrixOperationsQueue.instance;\n\n\n// ================================================\n// ABSTRACT TYPES\n// ================================================\n\n/**\n * An abstract algebraic expression with matrices\n * All expressions must be immutable from the outside\n * @abstract\n */\nexport class SpeedyMatrixExpr\n{\n    /**\n     * Constructor\n     * @param {MatrixShape} shape the shape of the resulting (evaluated) expression\n     */\n    constructor(shape)\n    {\n        /** @type {MatrixShape} the shape of the evaluated matrix expression */\n        this._shape = shape;\n\n        /** @type {BoundMatrixOperation} this expression, compiled */\n        this._compiledExpr = null; // to be computed lazily\n    }\n\n    /**\n     * Number of rows of the resulting matrix\n     * @returns {number}\n     */\n    get rows()\n    {\n        return this._shape.rows;\n    }\n\n    /**\n     * Number of columns of the resulting matrix\n     * @returns {number}\n     */\n    get columns()\n    {\n        return this._shape.columns;\n    }\n\n    /**\n     * Type of the resulting matrix\n     * @returns {MatrixDataType}\n     */\n    get dtype()\n    {\n        return this._shape.dtype;\n    }\n\n    /**\n     * Compile this expression\n     * @returns {SpeedyPromise<BoundMatrixOperationTree>}\n     */\n    _compile()\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Compile and evaluate this expression, so\n     * that the WebWorker will be invoked ONCE\n     * for the entire expression\n     * @returns {SpeedyPromise<SpeedyMatrixExpr>}\n     */\n    _compileAndEvaluate()\n    {\n        // We can store an expression in compiled form as long\n        // as the pointers of the internal matrices, i.e., the\n        // matrices bound to the matrix operations, do not change\n        // in time. If they do change, we need to recompile the\n        // expression. It is assumed that the structure of the\n        // expression tree does not change. This means that all\n        // descendants of this node remain the same.\n        if(this._compiledExpr === null) {\n            return this._compile().then(result =>\n                this._compiledExpr = result.pack() // store the compiled object\n            ).then(compiledExpr =>\n                matrixOperationsQueue.enqueue(\n                    compiledExpr.operation,\n                    compiledExpr.outputMatrix, // should be === this._matrix\n                    compiledExpr.inputMatrices\n                )\n            ).then(() => this);\n        }\n        else {\n            return matrixOperationsQueue.enqueue(\n                this._compiledExpr.operation,\n                this._compiledExpr.outputMatrix,\n                this._compiledExpr.inputMatrices\n            ).then(() => this);\n        }\n    }\n\n    /**\n     * Get the matrix associated with the result of this expression\n     * This matrix must be guaranteed to be available after compiling this expression\n     * @returns {SpeedyMatrix}\n     */\n    get _matrix()\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Assign a matrix\n     * @param {SpeedyMatrix} matrix\n     * @returns {SpeedyPromise<void>} resolves as soon as the assignment is done\n     */\n    _assign(matrix)\n    {\n        throw new IllegalOperationError(`Can't assign matrix: not a l-value`);\n    }\n\n    /**\n     * Compile an assignment operation\n     * @param {BoundMatrixOperationTree} value\n     * @returns {SpeedyPromise<BoundMatrixOperationTree>}\n     */\n    _compileAssignment(value)\n    {\n        throw new IllegalOperationError(`Can't assign matrix: not a l-value`);\n    }\n\n    /**\n     * Assert matrix shape and type\n     * @param {MatrixShape} actual\n     * @param {MatrixShape} expected\n     */\n    static _assertSameShape(actual, expected)\n    {\n        if(actual.equals(expected))\n            return;\n        else if(actual.dtype !== expected.dtype)\n            throw new IllegalOperationError(`Incompatible matrix data type (expected \"${expected.dtype}\", found \"${actual.dtype}\")`);\n        else\n            throw new IllegalOperationError(`Incompatible matrix shape (expected ${expected.rows} x ${expected.columns}, found ${actual.rows} x ${actual.columns})`);\n    }\n\n\n\n    //\n    // GENERIC UTILITIES\n    //\n\n    /**\n     * Assign an expression (i.e., this := expr)\n     * @param {SpeedyMatrixExpr|number[]} expr\n     * @returns {SpeedyPromise<SpeedyMatrixAssignmentExpr>}\n     */\n    assign(expr)\n    {\n        throw new IllegalOperationError(`Can't assign matrix: not a l-value`);\n    }\n\n    /**\n     * Fill the matrix with a constant value\n     * @param {number} value\n     * @returns {SpeedyPromise<SpeedyMatrixAssignmentExpr>}\n     */\n    fill(value)\n    {\n        throw new IllegalOperationError(`Can't fill matrix: not a l-value`);\n    }\n\n    /**\n     * Read the entries of this matrix\n     * Results are given in column-major format\n     * @returns {SpeedyPromise<number[]>}\n     */\n    read()\n    {\n        return this._compileAndEvaluate().then(expr => expr._matrix.read()).turbocharge();\n    }\n\n    /**\n     * Print the result of this matrix expression to the console\n     * @param {number} [decimals] format numbers to a number of decimals\n     * @param {Function} [printFunction] prints a string\n     * @returns {SpeedyPromise<void>} a promise that resolves as soon as the matrix is printed\n     */\n    print(decimals = undefined, printFunction = undefined)\n    {\n        return this._compileAndEvaluate().then(expr => expr._matrix.print(decimals, printFunction)).turbocharge();\n    }\n\n    /**\n     * Convert to string\n     * @returns {string}\n     */\n    toString()\n    {\n        return this._matrix.toString();\n    }\n\n\n\n\n\n\n    //\n    // ACCESS BY BLOCK\n    //\n\n    /**\n     * Extract a (lastRow - firstRow + 1) x (lastColumn - firstColumn + 1)\n     * block from the matrix. All indices are 0-based. Note that the\n     * memory of the block is shared with the memory of the matrix.\n     * @param {number} firstRow\n     * @param {number} lastRow\n     * @param {number} firstColumn\n     * @param {number} lastColumn\n     * @returns {SpeedyMatrixReadonlyBlockExpr}\n     */\n    block(firstRow, lastRow, firstColumn, lastColumn)\n    {\n        return new SpeedyMatrixReadonlyBlockExpr(this, firstRow, lastRow, firstColumn, lastColumn);\n    }\n\n    /**\n     * Get the i-th row of the matrix\n     * @param {number} i 0-based index\n     */\n    row(i)\n    {\n        return this.block(i, i, 0, this.columns - 1);\n    }\n\n    /**\n     * Get the j-th column of the matrix\n     * @param {number} j 0-based index\n     */\n    column(j)\n    {\n        return this.block(0, this.rows - 1, j, j);\n    }\n\n    /**\n     * Get (lastRow - firstRow + 1) contiguous rows. Both indices are inclusive.\n     * @param {number} firstRow\n     * @param {number} lastRow\n     */\n    rowSpan(firstRow, lastRow)\n    {\n        return this.block(firstRow, lastRow, 0, this.columns - 1);\n    }\n\n    /**\n     * Get (lastColumn - firstColumn + 1) contiguous columns. Both indices are inclusive.\n     * @param {number} firstColumn\n     * @param {number} lastColumn\n     */\n    columnSpan(firstColumn, lastColumn)\n    {\n        return this.block(0, this.rows - 1, firstColumn, lastColumn);\n    }\n\n    /**\n     * Get the main diagonal of the matrix. Internal buffer is shared.\n     * @returns {SpeedyMatrixReadonlyDiagonalExpr}\n     */\n    diagonal()\n    {\n        return new SpeedyMatrixReadonlyDiagonalExpr(this);\n    }\n\n\n\n\n    //\n    // GENERAL OPERATIONS\n    //\n\n\n    /**\n     * Transpose matrix\n     * @returns {SpeedyMatrixExpr}\n     */\n    transpose()\n    {\n        return new SpeedyMatrixTransposeExpr(this);\n    }\n\n    /**\n     * Add this matrix to another\n     * @param {SpeedyMatrixExpr} expr\n     * @returns {SpeedyMatrixExpr}\n     */\n    plus(expr)\n    {\n        return new SpeedyMatrixAddExpr(this, expr);\n    }\n\n    /**\n     * Subtract another matrix from this\n     * @param {SpeedyMatrixExpr} expr\n     * @returns {SpeedyMatrixExpr}\n     */\n    minus(expr)\n    {\n        return new SpeedyMatrixSubtractExpr(this, expr);\n    }\n\n    /**\n     * Multiply by a matrix or by a number\n     * @param {SpeedyMatrixExpr|number} expr\n     * @returns {SpeedyMatrixExpr}\n     */\n    times(expr)\n    {\n        if(expr instanceof SpeedyMatrixExpr)\n            return new SpeedyMatrixMultiplyExpr(this, expr);\n        else\n            return new SpeedyMatrixScaleExpr(this, expr);\n    }\n\n    /**\n     * Component-wise multiplication\n     * @param {SpeedyMatrixExpr} expr\n     * @returns {SpeedyMatrixExpr}\n     */\n    compMult(expr)\n    {\n        return new SpeedyMatrixCompMultExpr(this, expr);\n    }\n\n    /**\n     * Compute the inverse of this matrix\n     * @returns {SpeedyMatrixExpr}\n     */\n    inverse()\n    {\n        return new SpeedyMatrixInverseExpr(this);\n    }\n\n\n\n\n\n    //\n    // Misc\n    //\n\n    /**\n     * Similar to the comma operator in C/++\n     * @param {SpeedyMatrixExpr} expr\n     * @returns {SpeedyMatrixExpr}\n     */\n    followedBy(expr)\n    {\n        return new SpeedyMatrixSequenceExpr(this, expr);\n    }\n\n    /**\n     * Creates an assignment expression (i.e., this := expr),\n     * without actually computing or changing any numbers\n     * @param {SpeedyMatrixExpr | number[]} expr\n     * @returns {SpeedyMatrixAssignmentExpr}\n     */\n    setTo(expr)\n    {\n        throw new IllegalOperationError(`Can't create an assignment expression: not a l-value`);\n    }\n\n\n\n\n\n\n\n\n    //\n    // Functional programming\n    //\n\n    /**\n     * Map function (applied per block), analogous to Array.prototype.map()\n     * @param {number} blockRows number of rows of each block (must be the same as the number of rows of the input matrix expression)\n     * @param {number} blockColumns number of columns of each block (the number of columns of the input matrix expression must be a multiple of this)\n     * @param {Function} fn mapping function: receives a blockRows x blockColumns matrix and must return a SpeedyMatrixExpr\n     */\n    map(blockRows, blockColumns, fn)\n    {\n        // validate arguments\n        if(typeof fn !== 'function')\n            throw new IllegalArgumentError(`map() expects a mapping function`);\n        if(blockRows !== this.rows)\n            throw new IllegalArgumentError(`map() expects blockRows (${blockRows}) to be the number of rows of the matrix (${this.rows})`);\n        if(blockColumns <= 0 || this.columns % blockColumns !== 0)\n            throw new IllegalArgumentError(`map() expects the number of columns of the matrix (${this.columns}) to be divisible by blockColumns (${blockColumns})`);\n\n        // What is the matrix expression returned by fn?\n        const blockShape = new MatrixShape(blockRows, blockColumns, this.dtype);\n        const indexShape = new MatrixShape(1, 1, this.dtype /*'int32'*/ );\n        const bi = new SpeedyMatrixElementaryExpr(blockShape, new SpeedyMatrix(blockShape));\n        const index = new SpeedyMatrixElementaryExpr(indexShape, new SpeedyMatrix(indexShape));\n        const input = new SpeedyMatrixConstantExpr(this);\n        const mapfn = fn(bi, index, input);\n        if(!(mapfn instanceof SpeedyMatrixExpr))\n            throw new IllegalOperationError(`map() expects that the mapping function returns a matrix expression for all input blocks`);\n\n        // create the map expression\n        return new SpeedyMatrixMapExpr(this, mapfn, bi._matrix, index._matrix);\n    }\n\n    /**\n     * Reduce function (applied per block), analogous to Array.prototype.reduce()\n     * @param {number} blockRows number of rows of each block (must be the same as the number of rows of the input matrix expression)\n     * @param {number} blockColumns number of columns of each block (the number of columns of the input matrix expression must be a multiple of this)\n     * @param {Function} fn reducer function: receives a blockRows x blockColumns matrix and must return a SpeedyMatrixExpr\n     * @param {SpeedyMatrixExpr} initialMatrix initial matrix, used as the accumulator on the first invocation of fn\n     */\n    reduce(blockRows, blockColumns, fn, initialMatrix)\n    {\n        // validate arguments\n        if(typeof fn !== 'function')\n            throw new IllegalArgumentError(`reduce() expects a reducer function`);\n        if(blockRows !== this.rows)\n            throw new IllegalArgumentError(`reduce() expects blockRows (${blockRows}) to be the number of rows of the matrix (${this.rows})`);\n        if(blockColumns <= 0 || this.columns % blockColumns !== 0)\n            throw new IllegalArgumentError(`reduce() expects the number of columns of the matrix (${this.columns}) to be divisible by blockColumns (${blockColumns})`);\n        if(!(initialMatrix instanceof SpeedyMatrixExpr))\n            throw new IllegalArgumentError(`reduce() expects initialMatrix to be a SpeedyMatrixExpr`);\n\n        // What is the matrix expression returned by fn?\n        const blockShape = new MatrixShape(blockRows, blockColumns, this.dtype);\n        const indexShape = new MatrixShape(1, 1, this.dtype /*'int32'*/ );\n        const bi = new SpeedyMatrixElementaryExpr(blockShape, new SpeedyMatrix(blockShape));\n        const accumulator = new SpeedyMatrixElementaryExpr(initialMatrix._shape, new SpeedyMatrix(initialMatrix._shape));\n        const index = new SpeedyMatrixElementaryExpr(indexShape, new SpeedyMatrix(indexShape));\n        const input = new SpeedyMatrixConstantExpr(this);\n        const reducefn = fn(accumulator, bi, index, input);\n        if(!(reducefn instanceof SpeedyMatrixExpr))\n            throw new IllegalOperationError(`reduce() expects that the reducer function returns a SpeedyMatrixExpr for all input blocks`);\n        else if(!reducefn._shape.equals(initialMatrix._shape))\n            throw new IllegalOperationError(`reduce() expects that the reducer function returns matrices of the same shape as the initial matrix for all input blocks`);\n\n        // create the reduce expression\n        return new SpeedyMatrixReduceExpr(this, reducefn, accumulator._matrix, bi._matrix, index._matrix, initialMatrix);\n    }\n\n    /**\n     * Sort matrix blocks, analogous to Array.prototype.sort()\n     * @param {number} blockRows number of rows of each block (must be the same as the number of rows of the input matrix expression)\n     * @param {number} blockColumns number of columns of each block (the number of columns of the input matrix expression must be a multiple of this)\n     * @param {Function} cmp compare function: receives a pair of blockRows x blockColumns matrices and must return a 1x1 SpeedyMatrixExpr\n     */\n    sort(blockRows, blockColumns, cmp)\n    {\n         // validate arguments\n        if(typeof cmp !== 'function')\n            throw new IllegalArgumentError(`sort() expects a comparison function`);\n        if(blockRows !== this.rows)\n            throw new IllegalArgumentError(`sort() expects blockRows (${blockRows}) to be the number of rows of the matrix (${this.rows})`);\n        if(blockColumns <= 0 || this.columns % blockColumns !== 0)\n            throw new IllegalArgumentError(`sort() expects the number of columns of the matrix (${this.columns}) to be divisible by blockColumns (${blockColumns})`);\n\n        // create input blocks for cmp()\n        const blockShape = new MatrixShape(blockRows, blockColumns, this.dtype);\n        const bi = new SpeedyMatrixElementaryExpr(blockShape, new SpeedyMatrix(blockShape));\n        const bj = new SpeedyMatrixElementaryExpr(blockShape, new SpeedyMatrix(blockShape));\n\n        // cmp() must return a 1x1 SpeedyMatrixExpr\n        const comparator = cmp(bi, bj);\n        if(!(comparator instanceof SpeedyMatrixExpr && comparator._shape.rows === 1 && comparator._shape.columns === 1))\n            throw new IllegalOperationError(`sort() expects that the comparator function returns a 1x1 matrix expression for all comparison pairs`);\n\n        // we're ready to sort the blocks\n        return new SpeedyMatrixSortExpr(this, comparator, bi._matrix, bj._matrix);\n    }\n\n\n\n    //\n    // Linear Algebra\n    //\n\n    /**\n     * QR decomposition\n     * @param {string} [mode] 'full' | 'reduced'\n     * @returns {SpeedyMatrixExpr}\n     */\n    qr(mode = 'reduced')\n    {\n        return new SpeedyMatrixQRExpr(this, mode);\n    }\n\n    /**\n     * Find least squares solution for a system of linear equations,\n     * i.e., find x such that the 2-norm |b - Ax| is minimized.\n     * A is this (m x n) matrix expression, satisfying m >= n\n     * m is the number of equations and n is the number of unknowns\n     * @param {SpeedyMatrixExpr} b m x 1 matrix\n     */\n    lssolve(b)\n    {\n        return new SpeedyMatrixLSSolveNodeExpr(this, b);\n    }\n\n    /**\n     * Solve a linear system of equations,\n     * i.e., solve Ax = b for x. A is this\n     * (m x m) expression and b is m x 1\n     * @param {SpeedyMatrixExpr} b\n     * @param {string} [method] 'qr'\n     */\n    solve(b, method = 'qr')\n    {\n        // m: rows (number of equations), n: columns (number of unknowns)\n        const rows = this.rows, columns = this.columns;\n\n        // validate size\n        if(rows !== columns)\n            throw new IllegalArgumentError(`solve expects a square matrix, but received a ${rows} x ${columns} matrix`);\n        else if(b.rows !== rows || b.columns !== 1)\n            throw new IllegalArgumentError(`solve expected a ${rows} x 1 input vector, but received a ${b.rows} x ${b.columns} matrix`);\n\n        // solve system of equations\n        switch(method)\n        {\n            case 'qr':\n                return this.lssolve(b);\n\n            // TODO: Gaussian elimination\n            //case 'lu':\n\n            default:\n                throw new IllegalArgumentError(`Unknown method for solve: \"${method}\"`);\n        }\n    }\n\n\n\n\n\n\n\n    //\n    // Internal utilities\n    //\n\n    /**\n     * Create a new matrix expression\n     * @param {number} rows\n     * @param {number} columns\n     * @param {number[]} values in column-major format\n     * @returns {SpeedyMatrixElementaryExpr}\n     */\n    static create(rows, columns, values)\n    {\n        const shape = new MatrixShape(rows, columns);\n        const matrix = new SpeedyMatrix(shape, values);\n\n        return new SpeedyMatrixElementaryExpr(shape, matrix);\n    }\n\n    /**\n     * Internal QR solver: Ax = b\n     * This creates a matrix [ (Q^T) b | R ] using reduced QR\n     * All (m-n) entries at the bottom are zeros\n     * @param {SpeedyMatrixExpr} b\n     * @returns {SpeedyMatrixExpr}\n     */\n    _qrSolve(b)\n    {\n        return new SpeedyMatrixQRSolverNodeExpr(this, b);\n    }\n\n    /**\n     * Internal back-substitution algorithm. It assumes this\n     * matrix expression is of the form [ b | R ] for some\n     * upper-triangular R matrix and some column-vector b\n     */\n    _backSubstitution()\n    {\n        return new SpeedyMatrixBackSubstitutionNodeExpr(this);\n    }\n}\n\n/**\n * The result of an intermediate calculation (e.g., A + B)\n * A temporary matrix for storing the result of the calculation is created\n * @abstract\n */\nclass SpeedyMatrixTempExpr extends SpeedyMatrixExpr\n{\n    /**\n     * Constructor\n     * @param {MatrixShape} shape the shape of the resulting expression\n     */\n    constructor(shape)\n    {\n        super(shape);\n\n        /** @type {SpeedyMatrix} used for temporary calculations */\n        this._tmpmatrix = new SpeedyMatrix(shape);\n    }\n\n    /**\n     * Get the matrix associated with this expression\n     * This matrix must be guaranteed to be available after compiling this expression\n     * @returns {SpeedyMatrix}\n     */\n    get _matrix()\n    {\n        return this._tmpmatrix;\n    }\n}\n\n/**\n * Unary expression\n * @abstract\n */\nclass SpeedyMatrixUnaryExpr extends SpeedyMatrixTempExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} expr input expression\n     * @param {MatrixOperation} operation unary operation\n     */\n    constructor(expr, operation)\n    {\n        super(operation.shape);\n\n        /** @type {SpeedyMatrixExpr} input expression */\n        this._expr = expr;\n\n        /** @type {MatrixOperation} unary operation */\n        this._operation = operation;\n\n        // validate\n        Utils.assert(operation.numberOfInputMatrices() === 1); // must be unary\n    }\n\n    /**\n     * Compile this expression\n     * @returns {SpeedyPromise<BoundMatrixOperationTree>}\n     */\n    _compile()\n    {\n        return this._expr._compile().then(node =>\n            new BoundMatrixOperationTree(\n                this._operation,\n                this._matrix,\n                [ node ]\n            )\n        );\n    }\n\n    /**\n     * Input expression\n     * @returns {SpeedyMatrixExpr}\n     */\n    get child()\n    {\n        return this._expr;\n    }\n}\n\n/**\n * Binary expression\n * @abstract\n */\nclass SpeedyMatrixBinaryExpr extends SpeedyMatrixTempExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} leftExpr left operand/expression\n     * @param {SpeedyMatrixExpr} rightExpr right operand/expression\n     * @param {MatrixOperation} operation binary operation\n     */\n    constructor(leftExpr, rightExpr, operation)\n    {\n        super(operation.shape);\n\n        /** @type {SpeedyMatrixExpr} left operand */\n        this._leftExpr = leftExpr;\n\n        /** @type {SpeedyMatrixExpr} right operand */\n        this._rightExpr = rightExpr;\n\n        /** @type {MatrixOperation} binary operation */\n        this._operation = operation;\n\n        // validate\n        Utils.assert(operation.numberOfInputMatrices() === 2); // must be a binary operation\n        if(rightExpr.dtype !== leftExpr.dtype) // just in case...\n            throw new IllegalArgumentError(`Found a binary expression with different data types: \"${leftExpr.dtype}\" (left operand) x \"${rightExpr.dtype}\" (right operand)`);\n    }\n\n    /**\n     * Compile this expression\n     * @returns {SpeedyPromise<BoundMatrixOperationTree>}\n     */\n    _compile()\n    {\n        return SpeedyPromise.all([\n            this._leftExpr._compile().turbocharge(),\n            this._rightExpr._compile().turbocharge()\n        ]).then(([ leftNode, rightNode ]) =>\n            new BoundMatrixOperationTree(\n                this._operation,\n                this._matrix,\n                [ leftNode, rightNode ]\n            )\n        );\n    }\n\n    /**\n     * Left input expression\n     * @returns {SpeedyMatrixExpr}\n     */\n    get leftChild()\n    {\n        return this._leftExpr;\n    }\n\n    /**\n     * Right input expression\n     * @returns {SpeedyMatrixExpr}\n     */\n    get rightChild()\n    {\n        return this._rightExpr;\n    }\n}\n\n/**\n * Ternary expression\n * @abstract\n */\nclass SpeedyMatrixTernaryExpr extends SpeedyMatrixTempExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} firstExpr\n     * @param {SpeedyMatrixExpr} secondExpr\n     * @param {SpeedyMatrixExpr} thirdExpr\n     * @param {MatrixOperation} operation ternary operation\n     */\n    constructor(firstExpr, secondExpr, thirdExpr, operation)\n    {\n        super(operation.shape);\n\n        /** @type {SpeedyMatrixExpr} first operand */\n        this._firstExpr = firstExpr;\n\n        /** @type {SpeedyMatrixExpr} second operand */\n        this._secondExpr = secondExpr;\n\n        /** @type {SpeedyMatrixExpr} third operand */\n        this._thirdExpr = thirdExpr;\n\n        /** @type {MatrixOperation} ternary operation */\n        this._operation = operation;\n\n        // validate\n        Utils.assert(operation.numberOfInputMatrices() === 3); // must be a ternary operation\n        if(firstExpr.dtype !== secondExpr.dtype || firstExpr.dtype !== thirdExpr.dtype)\n            throw new IllegalArgumentError(`Found a ternary expression with different data types: \"${firstExpr.dtype}\" (first operand) x \"${secondExpr.dtype}\" (second operand) x \"${thirdExpr.dtype}\" (third operand)`);\n    }\n\n    /**\n     * Compile this expression\n     * @returns {SpeedyPromise<BoundMatrixOperationTree>}\n     */\n    _compile()\n    {\n        return SpeedyPromise.all([\n            this._firstExpr._compile().turbocharge(),\n            this._secondExpr._compile().turbocharge(),\n            this._thirdExpr._compile().turbocharge()\n        ]).then(([ firstNode, secondNode, thirdNode ]) =>\n            new BoundMatrixOperationTree(\n                this._operation,\n                this._matrix,\n                [ firstNode, secondNode, thirdNode ]\n            )\n        );\n    }\n\n    /**\n     * First operand\n     * @returns {SpeedyMatrixExpr}\n     */\n    get firstChild()\n    {\n        return this._firstExpr;\n    }\n\n    /**\n     * Second operand\n     * @returns {SpeedyMatrixExpr}\n     */\n    get secondChild()\n    {\n        return this._secondExpr;\n    }\n\n    /**\n     * Third operand\n     * @returns {SpeedyMatrixExpr}\n     */\n    get thirdChild()\n    {\n        return this._thirdExpr;\n    }\n}\n\n/**\n * Extract a read-only block submatrix from a matrix expression\n */\nclass SpeedyMatrixReadonlyBlockExpr extends SpeedyMatrixExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} expr originating matrix expression\n     * @param {number} firstRow indexed by 0\n     * @param {number} lastRow\n     * @param {number} firstColumn\n     * @param {number} lastColumn\n     */\n    constructor(expr, firstRow, lastRow, firstColumn, lastColumn)\n    {\n        super(new MatrixShape(lastRow - firstRow + 1, lastColumn - firstColumn + 1, expr.dtype));\n\n        /** @type {SpeedyMatrixExpr} originating matrix expression */\n        this._expr = expr;\n\n        /** @type {number} index of the top-most row (starts at zero) */\n        this._firstRow = firstRow;\n\n        /** @type {number} index of the last row */\n        this._lastRow = lastRow;\n\n        /** @type {number} index of the left-most column (starts at zero) */\n        this._firstColumn = firstColumn;\n\n        /** @type {number} index of the right-most column */\n        this._lastColumn = lastColumn;\n\n        /** @type {?SpeedyMatrix} the matrix associated with this expression */\n        this._submatrix = null;\n\n        /** @type {?SpeedyMatrix} used for caching */\n        this._cachedMatrix = null;\n    }\n\n    /**\n     * Get the matrix associated with this expression\n     * This matrix must be guaranteed to be available after compiling this expression\n     * @returns {SpeedyMatrix}\n     */\n    get _matrix()\n    {\n        return this._submatrix;\n    }\n\n    /**\n     * Compile this expression\n     * @returns {SpeedyPromise<BoundMatrixOperationTree>}\n     */\n    _compile()\n    {\n        return this._expr._compile().then(node => {\n            if(node.outputMatrix !== this._cachedMatrix || this._submatrix === null) {\n                this._cachedMatrix = node.outputMatrix;\n                return this._cachedMatrix.block(\n                    this._firstRow,\n                    this._lastRow,\n                    this._firstColumn,\n                    this._lastColumn\n                ).then(submatrix => {\n                    this._submatrix = submatrix;\n                    return node;\n                });\n            }\n            return node;\n        }).then(node =>\n            new BoundMatrixOperationTree(\n                null,\n                this._matrix,\n                [ node ]\n            )\n        );\n    }\n}\n\n/**\n * Extract a read-only diagonal from a matrix expression\n */\nclass SpeedyMatrixReadonlyDiagonalExpr extends SpeedyMatrixExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} expr originating matrix expression\n     */\n    constructor(expr)\n    {\n        const diagonalLength = Math.min(expr.rows, expr.columns);\n        super(new MatrixShape(1, diagonalLength, expr.dtype));\n\n        /** @type {SpeedyMatrixExpr} originating matrix expression */\n        this._expr = expr;\n\n        /** @type {?SpeedyMatrix} the matrix associated with this expression */\n        this._diagonal = null;\n\n        /** @type {?SpeedyMatrix} used for caching */\n        this._cachedMatrix = null;\n    }\n\n    /**\n     * Get the matrix associated with this expression\n     * This matrix must be guaranteed to be available after compiling this expression\n     * @returns {SpeedyMatrix}\n     */\n    get _matrix()\n    {\n        return this._diagonal;\n    }\n\n    /**\n     * Compile this expression\n     * @returns {SpeedyPromise<BoundMatrixOperationTree>}\n     */\n    _compile()\n    {\n        return this._expr._compile().then(node => {\n            if(node.outputMatrix !== this._cachedMatrix || this._diagonal === null) {\n                this._cachedMatrix = node.outputMatrix;\n                return this._cachedMatrix.diagonal().then(diagonal => {\n                    this._diagonal = diagonal;\n                    return node;\n                });\n            }\n            return node;\n        }).then(node =>\n            new BoundMatrixOperationTree(\n                null,\n                this._matrix,\n                [ node ]\n            )\n        );\n    }\n}\n\n/**\n * Assignment expression\n * Assign rvalue to lvalue (i.e., lvalue := rvalue)\n */\nclass SpeedyMatrixAssignmentExpr extends SpeedyMatrixExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixLvalueExpr} lvalue\n     * @param {SpeedyMatrixExpr} rvalue\n     */\n    constructor(lvalue, rvalue)\n    {\n        super(lvalue._shape);\n\n        /** @type {SpeedyMatrixLvalueExpr} */\n        this._lvalue = lvalue;\n\n        /** @type {SpeedyMatrixExpr} */\n        this._rvalue = rvalue;\n\n        // validate\n        SpeedyMatrixExpr._assertSameShape(lvalue._shape, rvalue._shape);\n        //Utils.assert(lvalue instanceof SpeedyMatrixLvalueExpr);\n    }\n\n    /**\n     * Get the matrix associated with this lvalue expression\n     * This matrix must be guaranteed to be available after compiling this expression\n     * @returns {SpeedyMatrix}\n     */\n    get _matrix()\n    {\n        return this._lvalue._matrix;\n    }\n\n    /**\n     * Compile this expression\n     * @returns {SpeedyPromise<BoundMatrixOperationTree>}\n     */\n    _compile()\n    {\n        return SpeedyPromise.all([\n            this._lvalue._compile().turbocharge(),\n            this._rvalue._compile().turbocharge()\n        ]).then(([ lvalue, rvalue ]) =>\n            this._lvalue._compileAssignment(rvalue).then(assignment =>\n                new BoundMatrixOperationTree(\n                    null,\n                    this._matrix, // this is lvalue.outputMatrix\n                    [ lvalue, assignment ]\n                )\n            )\n        );\n    }\n}\n\n/**\n * A sequence expression, similar to the comma operator in C/C++ and JavaScript\n * e.g., the (A, B) expression evaluates to B\n */\nclass SpeedyMatrixSequenceExpr extends SpeedyMatrixExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} first we'll discard this result\n     * @param {SpeedyMatrixExpr} second we'll use this as the result of this expression\n     */\n    constructor(first, second)\n    {\n        super(second._shape);\n\n        /** @type {SpeedyMatrixExpr} we'll discard this result */\n        this._first = first;\n\n        /** @type {SpeedyMatrixExpr} the result of this expression */\n        this._second = second;\n    }\n\n    /**\n     * Get the matrix associated with this expression\n     * This matrix must be guaranteed to be available after compiling this expression\n     * @returns {SpeedyMatrix}\n     */\n    get _matrix()\n    {\n        return this._second._matrix;\n    }\n\n    /**\n     * Compile this expression\n     * @returns {SpeedyPromise<BoundMatrixOperationTree>}\n     */\n    _compile()\n    {\n        return SpeedyPromise.all([\n            this._first._compile().turbocharge(),\n            this._second._compile().turbocharge(),\n        ]).then(([ first, second ]) =>\n            new BoundMatrixOperationTree(\n                null,\n                this._matrix,\n                [ first, second ]\n            )\n        );\n    }\n}\n\n\n\n// ================================================\n// L-VALUES\n// ================================================\n\n/**\n * An lvalue (locator value) expression represents a user-owned object stored in memory\n * @abstract\n */\nexport class SpeedyMatrixLvalueExpr extends SpeedyMatrixExpr\n{\n    /**\n     * Get the matrix associated with this lvalue expression\n     * This matrix must be guaranteed to be available after compiling this expression\n     * @returns {SpeedyMatrix}\n     */\n    get _matrix()\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Evaluate this lvalue\n     * @returns {SpeedyPromise<SpeedyMatrixLvalueExpr>}\n     */\n    _evaluateLvalue()\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Assign a matrix\n     * @param {SpeedyMatrix} matrix\n     * @returns {SpeedyPromise<void>} resolves as soon as the assignment is done\n     */\n    _assign(matrix)\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Compile an assignment operation\n     * @param {BoundMatrixOperationTree} value\n     * @returns {SpeedyPromise<BoundMatrixOperationTree>}\n     */\n    _compileAssignment(value)\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Assign an expression to this lvalue\n     * @param {SpeedyMatrixExpr|number[]} expr\n     * @returns {SpeedyPromise<SpeedyMatrixLvalueExpr>} resolves as soon as the assignment is done\n     */\n    assign(expr)\n    {\n        // got an array of numbers?\n        if(Array.isArray(expr)) {\n            const mat = new SpeedyMatrix(this._shape, expr);\n            return this._evaluateLvalue().then(lvalue =>\n                lvalue._assign(mat)\n            ).then(() => this);\n        }\n\n        // compile expr and get the data\n        return this._evaluateLvalue().then(lvalue =>\n            expr._compileAndEvaluate().then(result => lvalue._assign(result._matrix))\n        ).then(() => this);\n    }\n\n    /**\n     * Fill the matrix with a constant value\n     * @param {number} value\n     * @returns {SpeedyPromise<SpeedyMatrixLvalueExpr>}\n     */\n    fill(value)\n    {\n        // FIXME: currently inefficient (compiles new fill expr multiple times)\n        return this.assign(new SpeedyMatrixFillExpr(this._shape, +value));\n    }\n\n    /**\n     * Creates an assignment expression (i.e., this := expr),\n     * without actually computing or changing any numbers\n     * @param {SpeedyMatrixExpr|number[]} expr matrix expression or an array of numbers in column-major format\n     * @returns {SpeedyMatrixAssignmentExpr}\n     */\n    setTo(expr)\n    {\n        // got an array of numbers?\n        if(Array.isArray(expr)) {\n            const mat = new SpeedyMatrix(this._shape, expr);\n            expr = new SpeedyMatrixElementaryExpr(mat.shape, mat);\n        }\n\n        // return assignment expression\n        return new SpeedyMatrixAssignmentExpr(this, expr);\n    }\n\n    /**\n     * Extract a (lastRow - firstRow + 1) x (lastColumn - firstColumn + 1)\n     * block from the matrix. All indices are 0-based. Note that the\n     * memory of the block is shared with the memory of the matrix.\n     * @param {number} firstRow\n     * @param {number} lastRow\n     * @param {number} firstColumn\n     * @param {number} lastColumn\n     * @returns {SpeedyMatrixReadwriteBlockExpr}\n     */\n    block(firstRow, lastRow, firstColumn, lastColumn)\n    {\n        return new SpeedyMatrixReadwriteBlockExpr(this, firstRow, lastRow, firstColumn, lastColumn);\n    }\n\n    /**\n     * Get the main diagonal of the matrix. Internal buffer is shared.\n     * @returns {SpeedyMatrixReadwriteDiagonalExpr}\n     */\n    diagonal()\n    {\n        return new SpeedyMatrixReadwriteDiagonalExpr(this);\n    }\n}\n\n/**\n * An elementary expression representing a single matrix\n * (e.g., expression 'A' represents a single matrix)\n */\nexport class SpeedyMatrixElementaryExpr extends SpeedyMatrixLvalueExpr\n{\n    /**\n     * Constructor\n     * @param {MatrixShape} shape shape of the matrix\n     * @param {?SpeedyMatrix} [matrix] user matrix\n     */\n    constructor(shape, matrix = null)\n    {\n        super(shape);\n\n        /** @type {SpeedyMatrix} the matrix associated with this expression */\n        this._usermatrix = matrix || new SpeedyMatrix(this._shape);\n\n        /** @type {MatrixOperation} copy operation, used in compiled mode */\n        this._copy = new MatrixOperationCopy(this._shape);\n\n        // validate\n        if(matrix != null)\n            SpeedyMatrixExpr._assertSameShape(this._shape, matrix.shape);\n    }\n\n    /**\n     * Read the entries of this matrix\n     * Results are given in column-major format\n     * @returns {SpeedyPromise<number[]>}\n     */\n    read()\n    {\n        // this is an elementary expression, so we've got the data\n        return this._usermatrix.read().turbocharge();\n    }\n\n    /**\n     * Get the matrix associated with this lvalue expression\n     * This matrix must be guaranteed to be available after compiling this expression\n     * @returns {SpeedyMatrix}\n     */\n    get _matrix()\n    {\n        return this._usermatrix;\n    }\n\n    /**\n     * Evaluate this lvalue\n     * @returns {SpeedyPromise<SpeedyMatrixLvalueExpr>}\n     */\n    _evaluateLvalue()\n    {\n        return SpeedyPromise.resolve(this);\n    }\n\n    /**\n     * Assign a matrix\n     * @param {SpeedyMatrix} matrix\n     * @returns {SpeedyPromise<void>} resolves as soon as the assignment is done\n     */\n    _assign(matrix)\n    {\n        return matrixOperationsQueue.enqueue(\n            this._copy,\n            this._matrix,\n            [ matrix ]\n        );\n    }\n\n    /**\n     * Compile this expression\n     * @returns {SpeedyPromise<BoundMatrixOperationTree>}\n     */\n    _compile()\n    {\n        return SpeedyPromise.resolve(new BoundMatrixOperationTree(\n            null,\n            this._matrix,\n            []\n        ));\n    }\n\n    /**\n     * Compile an assignment operation\n     * @param {BoundMatrixOperationTree} value\n     * @returns {SpeedyPromise<BoundMatrixOperationTree>}\n     */\n    _compileAssignment(value)\n    {\n        return SpeedyPromise.resolve(new BoundMatrixOperationTree(\n            this._copy,\n            this._matrix,\n            [ value ]\n        ));\n    }\n}\n\n/**\n * Extract a read-write block submatrix from a matrix expression\n */\nclass SpeedyMatrixReadwriteBlockExpr extends SpeedyMatrixLvalueExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixLvalueExpr} expr originating matrix expression\n     * @param {number} firstRow indexed by 0\n     * @param {number} lastRow\n     * @param {number} firstColumn\n     * @param {number} lastColumn\n     */\n    constructor(expr, firstRow, lastRow, firstColumn, lastColumn)\n    {\n        super(new MatrixShape(lastRow - firstRow + 1, lastColumn - firstColumn + 1, expr.dtype));\n\n        /** @type {SpeedyMatrixLvalueExpr} originating matrix expression */\n        this._expr = expr;\n\n        /** @type {number} index of the top-most row (starts at zero) */\n        this._firstRow = firstRow;\n\n        /** @type {number} index of the last row */\n        this._lastRow = lastRow;\n\n        /** @type {number} index of the left-most column (starts at zero) */\n        this._firstColumn = firstColumn;\n\n        /** @type {number} index of the right-most column */\n        this._lastColumn = lastColumn;\n\n        /** @type {?SpeedyMatrix} the matrix associated with this expression */\n        this._submatrix = null;\n\n        /** @type {?SpeedyMatrix} used for caching */\n        this._cachedMatrix = null;\n\n        /** @type {MatrixOperation} matrix operation */\n        this._copy = new MatrixOperationCopy(this._shape);\n    }\n\n    /**\n     * Get the matrix associated with this lvalue expression\n     * This matrix must be guaranteed to be available after compiling this expression\n     * @returns {SpeedyMatrix}\n     */\n    get _matrix()\n    {\n        return this._submatrix;\n    }\n\n    /**\n     * Evaluate this lvalue\n     * @returns {SpeedyPromise<SpeedyMatrixLvalueExpr>}\n     */\n    _evaluateLvalue()\n    {\n        return this._expr._evaluateLvalue().then(result => {\n            if(result._matrix !== this._cachedMatrix || this._submatrix === null) {\n                this._cachedMatrix = result._matrix;\n                return this._cachedMatrix.block(this._firstRow, this._lastRow, this._firstColumn, this._lastColumn);\n            }\n            return this._submatrix; // we've already extracted the submatrix\n        }).then(submatrix => {\n            this._submatrix = submatrix;\n            return this;\n        });\n    }\n\n    /**\n     * Assign a matrix\n     * Since this is a submatrix, we can't just assign pointers.\n     * We need to copy the data\n     * @param {SpeedyMatrix} matrix\n     * @returns {SpeedyPromise<void>} resolves as soon as the assignment is done\n     */\n    _assign(matrix)\n    {\n        return matrixOperationsQueue.enqueue(\n            this._copy,\n            this._matrix,\n            [ matrix ]\n        );\n    }\n\n    /**\n     * Compile this expression\n     * @returns {SpeedyPromise<BoundMatrixOperationTree>}\n     */\n    _compile()\n    {\n        return this._expr._compile().then(node => {\n            if(node.outputMatrix !== this._cachedMatrix || this._submatrix === null) {\n                this._cachedMatrix = node.outputMatrix;\n                return this._cachedMatrix.block(\n                    this._firstRow,\n                    this._lastRow,\n                    this._firstColumn,\n                    this._lastColumn\n                ).then(submatrix => {\n                    this._submatrix = submatrix;\n                    return node;\n                });\n            }\n            return node;\n        }).then(node =>\n            new BoundMatrixOperationTree(\n                null,\n                this._matrix,\n                [ node ]\n            )\n        );\n    }\n\n    /**\n     * Compile an assignment operation\n     * @param {BoundMatrixOperationTree} value\n     * @returns {SpeedyPromise<BoundMatrixOperationTree>}\n     */\n    _compileAssignment(value)\n    {\n        return SpeedyPromise.resolve(new BoundMatrixOperationTree(\n            this._copy,\n            this._matrix,\n            [ value ]\n        ));\n    }\n}\n\n/**\n * Extract a read-write diagonal from a matrix expression\n */\nclass SpeedyMatrixReadwriteDiagonalExpr extends SpeedyMatrixLvalueExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixLvalueExpr} expr originating matrix expression\n     */\n    constructor(expr)\n    {\n        const diagonalLength = Math.min(expr.rows, expr.columns);\n        super(new MatrixShape(1, diagonalLength, expr.dtype));\n\n        /** @type {SpeedyMatrixLvalueExpr} originating matrix expression */\n        this._expr = expr;\n\n        /** @type {?SpeedyMatrix} the matrix associated with this expression */\n        this._diagonal = null;\n\n        /** @type {?SpeedyMatrix} used for caching */\n        this._cachedMatrix = null;\n\n        /** @type {MatrixOperation} copy operation */\n        this._copy = new MatrixOperationCopy(this._shape);\n    }\n\n    /**\n     * Get the matrix associated with this expression\n     * This matrix must be guaranteed to be available after compiling this expression\n     * @returns {SpeedyMatrix}\n     */\n    get _matrix()\n    {\n        return this._diagonal;\n    }\n\n    /**\n     * Evaluate this lvalue\n     * @returns {SpeedyPromise<SpeedyMatrixLvalueExpr>}\n     */\n    _evaluateLvalue()\n    {\n        return this._expr._evaluateLvalue().then(result => {\n            if(result._matrix !== this._cachedMatrix || this._diagonal === null) {\n                this._cachedMatrix = result._matrix;\n                return this._cachedMatrix.diagonal();\n            }\n            return this._diagonal; // we've already extracted the diagonal\n        }).then(diagonal => {\n            this._diagonal = diagonal;\n            return this;\n        });\n    }\n\n    /**\n     * Assign a matrix\n     * Since this is a diagonal, we can't just assign pointers.\n     * We need to copy the data\n     * @param {SpeedyMatrix} matrix\n     * @returns {SpeedyPromise<void>} resolves as soon as the assignment is done\n     */\n    _assign(matrix)\n    {\n        return matrixOperationsQueue.enqueue(\n            this._copy,\n            this._matrix,\n            [ matrix ]\n        );\n    }\n\n    /**\n     * Compile this expression\n     * @returns {SpeedyPromise<BoundMatrixOperationTree>}\n     */\n    _compile()\n    {\n        return this._expr._compile().then(node => {\n            if(node.outputMatrix !== this._cachedMatrix || this._diagonal === null) {\n                this._cachedMatrix = node.outputMatrix;\n                return this._cachedMatrix.diagonal().then(diagonal => {\n                    this._diagonal = diagonal;\n                    return node;\n                });\n            }\n            return node;\n        }).then(node =>\n            new BoundMatrixOperationTree(\n                null,\n                this._matrix,\n                [ node ]\n            )\n        );\n    }\n\n    /**\n     * Compile an assignment operation\n     * @param {BoundMatrixOperationTree} value\n     * @returns {SpeedyPromise<BoundMatrixOperationTree>}\n     */\n    _compileAssignment(value)\n    {\n        return SpeedyPromise.resolve(new BoundMatrixOperationTree(\n            this._copy,\n            this._matrix,\n            [ value ]\n        ));\n    }\n}\n\n\n// ================================================\n// BASIC OPERATIONS\n// ================================================\n\n/**\n * Make an expression constant\n */\nexport class SpeedyMatrixConstantExpr extends SpeedyMatrixExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} expr the expression to be made constant, possibly a lvalue\n     */\n    constructor(expr)\n    {\n        super(expr._shape);\n\n        /** @type {SpeedyMatrixExpr} the expression to be made constant, possibly a lvalue */\n        this._expr = expr;\n    }\n\n    /**\n     * Get the matrix associated with this expression\n     * This matrix must be guaranteed to be available after compiling this expression\n     * @returns {SpeedyMatrix}\n     */\n    get _matrix()\n    {\n        return this._expr._matrix;\n    }\n\n    /**\n     * Compile this expression\n     * @returns {SpeedyPromise<BoundMatrixOperationTree>}\n     */\n    _compile()\n    {\n        return this._expr._compile();\n    }\n}\n\n/**\n * Fill the output matrix with a constant value\n */\nclass SpeedyMatrixFillExpr extends SpeedyMatrixTempExpr\n{\n    /**\n     * Constructor\n     * @param {MatrixShape} shape the shape of the resulting expression\n     * @param {number} value will fill the output matrix with this constant value\n     */\n    constructor(shape, value)\n    {\n        super(shape);\n\n        /** @type {MatrixOperation} fill operation */\n        this._operation = new MatrixOperationFill(this._shape, value);\n    }\n\n    /**\n     * Compile this expression\n     * @returns {SpeedyPromise<BoundMatrixOperationTree>}\n     */\n    _compile()\n    {\n        return SpeedyPromise.resolve(new BoundMatrixOperationTree(\n            this._operation,\n            this._matrix,\n            []\n        ));\n    }\n}\n\n/**\n * Tranpose a matrix,\n * e.g., A = B^T\n */\nclass SpeedyMatrixTransposeExpr extends SpeedyMatrixUnaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} expr\n     */\n    constructor(expr)\n    {\n        // optimize if the input expression is a transposition\n        if(expr instanceof SpeedyMatrixTransposeExpr) {\n            // A = (A^T)^T\n            return expr.child;\n        }\n\n        // regular transposition\n        super(expr, new MatrixOperationTranspose(expr._shape));\n    }\n}\n\n/**\n * Compute the inverse of a matrix,\n * e.g., A = B^(-1)\n */\nclass SpeedyMatrixInverseExpr extends SpeedyMatrixUnaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} expr\n     */\n    constructor(expr)\n    {\n        if(expr.rows !== expr.columns)\n            throw new IllegalOperationError(`Can't compute the inverse of a non-square matrix`);\n        if(expr.rows > 3)\n            throw new NotSupportedError(`Currently, only matrices up to 3x3 may be inverted`);\n\n        super(expr, new MatrixOperationInverse(expr._shape));\n    }\n}\n\n/**\n * Add two matrix expressions,\n * e.g., A = B + C\n */\nclass SpeedyMatrixAddExpr extends SpeedyMatrixBinaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} leftExpr\n     * @param {SpeedyMatrixExpr} rightExpr\n     */\n    constructor(leftExpr, rightExpr)\n    {\n        SpeedyMatrixExpr._assertSameShape(leftExpr._shape, rightExpr._shape);\n        super(leftExpr, rightExpr, new MatrixOperationAdd(leftExpr._shape, rightExpr._shape));\n    }\n}\n\n/**\n * Subtract two matrix expressions,\n * e.g., A = B - C\n */\nclass SpeedyMatrixSubtractExpr extends SpeedyMatrixBinaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} leftExpr\n     * @param {SpeedyMatrixExpr} rightExpr\n     */\n    constructor(leftExpr, rightExpr)\n    {\n        SpeedyMatrixExpr._assertSameShape(leftExpr._shape, rightExpr._shape);\n        super(leftExpr, rightExpr, new MatrixOperationSubtract(leftExpr._shape, rightExpr._shape));\n    }\n}\n\n/**\n * Multiply two matrix expressions,\n * e.g., A = B * C\n */\nclass SpeedyMatrixMultiplyExpr extends SpeedyMatrixBinaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} leftExpr\n     * @param {SpeedyMatrixExpr} rightExpr\n     */\n    constructor(leftExpr, rightExpr)\n    {\n        // optimize if the input expressions are transposed\n        const lt = leftExpr instanceof SpeedyMatrixTransposeExpr;\n        const rt = rightExpr instanceof SpeedyMatrixTransposeExpr;\n        if(lt && rt) {\n            // A = (B^T) (C^T) = (C B)^T\n            return new SpeedyMatrixTransposeExpr(\n                new SpeedyMatrixMultiplyExpr(rightExpr.child, leftExpr.child)\n            );\n        }\n        else if(lt && !rt) {\n            // A = (B^T) C\n            return new SpeedyMatrixMultiplyLTExpr(leftExpr.child, rightExpr);\n        }\n        else if(!lt && rt) {\n            // A = B (C^T)\n            return new SpeedyMatrixMultiplyRTExpr(leftExpr, rightExpr.child);\n        }\n\n        // multiply by a column-vector\n        if(rightExpr.columns === 1)\n            return new SpeedyMatrixMultiplyVecExpr(leftExpr, rightExpr);\n\n        // regular multiplication\n        if(leftExpr.columns !== rightExpr.rows)\n            throw new IllegalArgumentError(`Can't multiply a ${leftExpr.rows} x ${leftExpr.columns} matrix by a ${rightExpr.rows} x ${rightExpr.columns} matrix`);\n\n        super(leftExpr, rightExpr, new MatrixOperationMultiply(leftExpr._shape, rightExpr._shape));\n    }\n}\n\n/**\n * Multiply two matrix expressions, transposing the left operand\n * e.g., A = B^T * C\n */\nclass SpeedyMatrixMultiplyLTExpr extends SpeedyMatrixBinaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} leftExpr\n     * @param {SpeedyMatrixExpr} rightExpr\n     */\n    constructor(leftExpr, rightExpr)\n    {\n        if(leftExpr.rows !== rightExpr.rows)\n            throw new IllegalArgumentError(`Can't multiply a ${leftExpr.columns} x ${leftExpr.rows} (transposed) matrix by a ${rightExpr.rows} x ${rightExpr.columns} matrix`);\n\n        super(leftExpr, rightExpr, new MatrixOperationMultiplyLT(leftExpr._shape, rightExpr._shape));\n    }\n}\n\n/**\n * Multiply two matrix expressions, transposing the right operand\n * e.g., A = B * C^T\n */\nclass SpeedyMatrixMultiplyRTExpr extends SpeedyMatrixBinaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} leftExpr\n     * @param {SpeedyMatrixExpr} rightExpr\n     */\n    constructor(leftExpr, rightExpr)\n    {\n        if(leftExpr.columns !== rightExpr.columns)\n            throw new IllegalArgumentError(`Can't multiply a ${leftExpr.rows} x ${leftExpr.columns} matrix by a ${rightExpr.columns} x ${rightExpr.rows} (transposed) matrix`);\n\n        super(leftExpr, rightExpr, new MatrixOperationMultiplyRT(leftExpr._shape, rightExpr._shape));\n    }\n}\n\n/**\n * Multiply a matrix A by a column-vector x,\n * e.g., y = A x\n */\nclass SpeedyMatrixMultiplyVecExpr extends SpeedyMatrixBinaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} leftExpr\n     * @param {SpeedyMatrixExpr} rightExpr\n     */\n    constructor(leftExpr, rightExpr)\n    {\n        if(leftExpr.columns !== rightExpr.rows || rightExpr.columns !== 1)\n            throw new IllegalArgumentError(`Can't multiply a ${leftExpr.rows} x ${leftExpr.columns} matrix by a ${rightExpr.rows} x ${rightExpr.columns} matrix / column-vector`);\n\n        super(leftExpr, rightExpr, new MatrixOperationMultiplyVec(leftExpr._shape, rightExpr._shape));\n    }\n}\n\n/**\n * Multiply a matrix expression by a number,\n * e.g., A = alpha B\n */\nclass SpeedyMatrixScaleExpr extends SpeedyMatrixUnaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} expr input expression\n     * @param {number} scalar\n     */\n    constructor(expr, scalar)\n    {\n        super(expr, new MatrixOperationScale(expr._shape, scalar));\n    }\n}\n\n/**\n * Component-wise multiplication of two matrix expressions\n */\nclass SpeedyMatrixCompMultExpr extends SpeedyMatrixBinaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} leftExpr\n     * @param {SpeedyMatrixExpr} rightExpr\n     */\n    constructor(leftExpr, rightExpr)\n    {\n        SpeedyMatrixExpr._assertSameShape(leftExpr._shape, rightExpr._shape);\n        super(leftExpr, rightExpr, new MatrixOperationCompMult(leftExpr._shape, rightExpr._shape));\n    }\n}\n\n/**\n * QR decomposition\n */\nclass SpeedyMatrixQRExpr extends SpeedyMatrixUnaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} expr\n     * @param {string} mode 'full' | 'reduced'\n     */\n    constructor(expr, mode)\n    {\n        if(expr.rows < expr.columns)\n            throw new IllegalArgumentError(`Can't compute the QR decomposition of a ${expr.rows} x ${expr.columns} matrix`);\n\n        super(expr, new MatrixOperationQR(expr._shape, mode));\n    }\n}\n\n/**\n * map() expression\n */\nclass SpeedyMatrixMapExpr extends SpeedyMatrixTempExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} inputMatrix input data\n     * @param {SpeedyMatrixExpr} mapfn mapping function\n     * @param {SpeedyMatrix} bi input to the mapping function - it has the shape of a block of the input matrix\n     * @param {SpeedyMatrix} index input to the mapping function - 1x1 index (0, 1, 2, 3, ... numBlocks-1)\n     */\n    constructor(inputMatrix, mapfn, bi, index)\n    {\n        Utils.assert(bi.shape.rows === inputMatrix.rows && inputMatrix.columns % bi.shape.columns === 0);\n        Utils.assert(inputMatrix.dtype === mapfn.dtype);\n        const numBlocks = inputMatrix.columns / bi.shape.columns;\n        const outputShape = new MatrixShape(mapfn.rows, mapfn.columns * numBlocks, mapfn.dtype);\n        super(outputShape);\n\n        /** @type {SpeedyMatrixExpr} input data */\n        this._inputMatrix = inputMatrix;\n\n        /** @type {SpeedyMatrixExpr} mapping function to be applied to each block */\n        this._mapfn = mapfn;\n\n        /** @type {SpeedyMatrix} input to the mapping function - a block of the input matrix */\n        this._bi = bi;\n\n        /** @type {SpeedyMatrix} 1x1 index (0 represents the left-most block, 1 the block next to it, and so on) */\n        this._index = index;\n    }\n\n    /**\n     * Compile this expression\n     * @returns {SpeedyPromise<BoundMatrixOperationTree>}\n     */\n    _compile()\n    {\n        return this._inputMatrix._compile().then(inputMatrix =>\n            this._mapfn._compile().then(mapfn =>\n                new BoundMatrixOperationTree(\n                    new MatrixOperationMap(this._shape),\n                    this._matrix, [\n                        inputMatrix,\n                        new BoundMatrixOperationTree(null, mapfn.outputMatrix),\n                        new BoundMatrixOperationTree(null, this._bi),\n                        new BoundMatrixOperationTree(null, this._index)\n                    ], [\n                        ['mapfn', mapfn]\n                    ]\n                )\n            )\n        );\n    }\n}\n\n/**\n * reduce() expression\n */\nclass SpeedyMatrixReduceExpr extends SpeedyMatrixTempExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} inputMatrix input data\n     * @param {SpeedyMatrixExpr} reducefn reduce expression\n     * @param {SpeedyMatrix} accumulator partial output of reduce()\n     * @param {SpeedyMatrix} bi a block of the input matrix\n     * @param {SpeedyMatrix} index 1x1 matrix\n     * @param {SpeedyMatrixExpr} initialMatrix initial value to be used as the accumulator\n     */\n    constructor(inputMatrix, reducefn, accumulator, bi, index, initialMatrix)\n    {\n        Utils.assert(bi.shape.rows === inputMatrix.rows && inputMatrix.columns % bi.shape.columns === 0);\n        Utils.assert(inputMatrix.dtype === reducefn.dtype);\n        Utils.assert(reducefn._shape.equals(initialMatrix._shape));\n        Utils.assert(reducefn._shape.equals(accumulator.shape));\n        super(reducefn._shape);\n\n        /** @type {SpeedyMatrixExpr} input data */\n        this._inputMatrix = inputMatrix;\n\n        /** @type {SpeedyMatrixExpr} reduce expression */\n        this._reducefn = reducefn;\n\n        /** @type {SpeedyMatrix} input to the reduce function - accumulator matrix */\n        this._accumulator = accumulator;\n\n        /** @type {SpeedyMatrix} input to the reduce function - a block of the input matrix */\n        this._bi = bi;\n\n        /** @type {SpeedyMatrix} 1x1 index (0 represents the left-most block, 1 the block next to it, and so on) */\n        this._index = index;\n\n        /** @type {SpeedyMatrixExpr} initial value to be used as the accumulator */\n        this._initialMatrix = initialMatrix;\n    }\n\n    /**\n     * Compile this expression\n     * @returns {SpeedyPromise<BoundMatrixOperationTree>}\n     */\n    _compile()\n    {\n        return this._inputMatrix._compile().then(inputMatrix =>\n            this._initialMatrix._compile().then(initialMatrix =>\n                this._reducefn._compile().then(reducefn =>\n                    new BoundMatrixOperationTree(\n                        new MatrixOperationReduce(this._shape),\n                        this._matrix, [\n                            inputMatrix,\n                            new BoundMatrixOperationTree(null, reducefn.outputMatrix),\n                            new BoundMatrixOperationTree(null, this._accumulator),\n                            new BoundMatrixOperationTree(null, this._bi),\n                            new BoundMatrixOperationTree(null, this._index),\n                            initialMatrix\n                        ], [\n                            [ 'reducefn', reducefn ]\n                        ]\n                    )\n                )\n            )\n        );\n    }\n}\n\n/**\n * sort() expression\n */\nclass SpeedyMatrixSortExpr extends SpeedyMatrixTempExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} inputMatrix data to be sorted\n     * @param {SpeedyMatrixExpr} comparator compares bi to bj\n     * @param {SpeedyMatrix} bi\n     * @param {SpeedyMatrix} bj\n     */\n    constructor(inputMatrix, comparator, bi, bj)\n    {\n        super(inputMatrix._shape);\n        Utils.assert(bi.shape.equals(bj.shape));\n        Utils.assert(bi.rows === inputMatrix.rows && inputMatrix.columns % bi.columns === 0);\n\n        /** @type {SpeedyMatrixExpr} data to be sorted */\n        this._inputMatrix = inputMatrix;\n\n        /** @type {SpeedyMatrixExpr} an expression comparing bi to bj */\n        this._comparator = comparator;\n\n        /** @type {MatrixShape} shape of the blocks */\n        this._blockShape = bi.shape;\n\n        /** @type {SpeedyMatrix} storage for block comparisons */\n        this._bi = bi;\n\n        /** @type {SpeedyMatrix} storage for block comparisons */\n        this._bj = bj;\n    }\n\n    /**\n     * Compile this expression\n     * @returns {SpeedyPromise<BoundMatrixOperationTree>}\n     */\n    _compile()\n    {\n        return this._inputMatrix._compile().then(inputMatrix => {\n            return this._comparator._compile().then(comparator => {\n                return new BoundMatrixOperationTree(\n                    new MatrixOperationSort(this._shape, this._blockShape),\n                    this._matrix, [\n                        inputMatrix,\n                        new BoundMatrixOperationTree(null, comparator.outputMatrix),\n                        new BoundMatrixOperationTree(null, this._bi),\n                        new BoundMatrixOperationTree(null, this._bj),\n                    ], [\n                        [ 'cmp', comparator ]\n                    ]\n                );\n            });\n        });\n    }\n}\n\n\n\n// ==============================================\n// GEOMETRIC TRANSFORMATIONS\n// ==============================================\n\n/**\n * Compute a homography matrix using 4 correspondences of points\n */\nexport class SpeedyMatrixHomography4pExpr extends SpeedyMatrixBinaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} source 2x4 matrix: source points (ui, vi)\n     * @param {SpeedyMatrixExpr} destination 2x4 matrix: destination points (xi, vi)\n     */\n    constructor(source, destination)\n    {\n        Utils.assert(source._shape.rows === 2 && source._shape.columns === 4);\n        Utils.assert(source._shape.equals(destination._shape));\n        super(source, destination, new MatrixOperationHomography4p(source._shape, destination._shape));\n    }\n}\n\n/**\n * Compute a homography matrix using n >= 4 correspondences of points via DLT\n */\nexport class SpeedyMatrixHomographyDLTExpr extends SpeedyMatrixBinaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} source 2 x n matrix: source points (ui, vi)\n     * @param {SpeedyMatrixExpr} destination 2 x n matrix: destination points (xi, vi)\n     */\n    constructor(source, destination)\n    {\n        Utils.assert(source._shape.rows === 2 && source._shape.columns >= 4);\n        Utils.assert(source._shape.equals(destination._shape));\n        super(source, destination, new MatrixOperationHomographyDLT(source._shape, destination._shape));\n    }\n}\n\n/**\n * Apply a homography matrix to a set of 2D points\n */\nexport class SpeedyMatrixApplyHomographyExpr extends SpeedyMatrixBinaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} hom homography matrix (3x3)\n     * @param {SpeedyMatrixExpr} pts set of n 2D points (2xn)\n     */\n    constructor(hom, pts)\n    {\n        Utils.assert(hom.rows === 3 && hom.columns === 3);\n        Utils.assert(pts.rows === 2);\n        super(hom, pts, new MatrixOperationApplyHomography(hom._shape, pts._shape));\n    }\n}\n\n/**\n * Apply an affine transformation to a set of 2D points\n */\nexport class SpeedyMatrixApplyAffineExpr extends SpeedyMatrixBinaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} mat transformation matrix (2x3)\n     * @param {SpeedyMatrixExpr} pts set of n 2D points (2xn)\n     */\n    constructor(mat, pts)\n    {\n        Utils.assert(mat.rows === 2 && mat.columns === 3);\n        Utils.assert(pts.rows === 2);\n        super(mat, pts, new MatrixOperationApplyAffine(mat._shape, pts._shape));\n    }\n}\n\n/**\n * Apply a linear transformation to a set of 2D points\n * (this is basically matrix multiplication)\n */\nexport class SpeedyMatrixApplyLinear2dExpr extends SpeedyMatrixBinaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} mat transformation matrix (2x2)\n     * @param {SpeedyMatrixExpr} pts set of n 2D points (2xn)\n     */\n    constructor(mat, pts)\n    {\n        Utils.assert(mat.rows === 2 && mat.columns === 2);\n        Utils.assert(pts.rows === 2);\n        super(mat, pts, new MatrixOperationApplyLinear2d(mat._shape, pts._shape));\n    }\n}\n\n/**\n * Compute a homography matrix using P-RANSAC\n */\nexport class SpeedyMatrixPransacHomographyExpr extends SpeedyMatrixTernaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} source 2 x n matrix: source points (ui, vi), n >= 4\n     * @param {SpeedyMatrixExpr} destination 2 x n matrix: destination points (xi, vi)\n     * @param {number} numberOfHypotheses positive integer\n     * @param {number} bundleSize positive integer\n     * @param {number} reprojectionError in pixels\n     * @param {SpeedyMatrixLvalueExpr} mask 1 x n output inlier-outlier mask\n     */\n    constructor(source, destination, numberOfHypotheses, bundleSize, reprojectionError, mask)\n    {\n        Utils.assert(source.rows === 2 && source.columns >= 4);\n        Utils.assert(source._shape.equals(destination._shape));\n        Utils.assert(mask.rows === 1 && mask.columns === source.columns);\n        Utils.assert(mask.dtype === source.dtype);\n        Utils.assert(mask instanceof SpeedyMatrixLvalueExpr);\n        Utils.assert(numberOfHypotheses > 0 && bundleSize > 0 && reprojectionError >= 0);\n\n        super(source, destination, mask, new MatrixOperationPransacHomography(\n            source._shape, destination._shape,\n            numberOfHypotheses, bundleSize,\n            reprojectionError, mask._shape\n        ));\n    }\n}\n\n\n\n\n\n// ==============================================\n// INTERNAL UTILITIES\n// ==============================================\n\n/**\n * Internal QR solver (Ax = b)\n */\nclass SpeedyMatrixQRSolverNodeExpr extends SpeedyMatrixBinaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} matrixA m x n matrix\n     * @param {SpeedyMatrixExpr} vectorB m x 1 vector\n     */\n    constructor(matrixA, vectorB)\n    {\n        if(matrixA.rows < matrixA.columns)\n            throw new IllegalArgumentError(`Can't compute the QR decomposition of a ${matrixA.rows} x ${matrixA.columns} matrix`);\n        else if(vectorB.columns != 1 || vectorB.rows != matrixA.rows)\n            throw new IllegalArgumentError(`Expected a ${matrixA.rows} x 1 column-vector, but found a ${vectorB.rows} x ${vectorB.columns} matrix`);\n\n        super(matrixA, vectorB, new MatrixOperationQRSolve(matrixA._shape, vectorB._shape));\n    }\n}\n\n/**\n * Back-substitution algorithm\n * (solve Rx = b for x, R is upper-triangular)\n */\nclass SpeedyMatrixBackSubstitutionNodeExpr extends SpeedyMatrixUnaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} input [b | R] matrix\n     */\n    constructor(input)\n    {\n        if(input.columns != input.rows + 1)\n            throw new IllegalArgumentError(`Expected a ${input.rows} x ${input.rows + 1} matrix, but found a ${input.rows} x ${input.columns} matrix`);\n\n        super(input, new MatrixOperationBackSubstitution(input._shape));\n    }\n}\n\n/**\n * Find best-fit solution x of Ax = b with least-squares method\n * A is m x n, b is m x 1, output x is n x 1\n * (m equations, n unknowns, m >= n)\n */\nclass SpeedyMatrixLSSolveNodeExpr extends SpeedyMatrixBinaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} matrixA m x n matrix\n     * @param {SpeedyMatrixExpr} vectorB m x 1 vector\n     */\n    constructor(matrixA, vectorB)\n    {\n        const [ m, n ] = [ matrixA.rows, matrixA.columns ];\n\n        if(m < n)\n            throw new IllegalArgumentError(`Input matrix has more columns than rows - it's ${m} x ${n}`);\n        else if(vectorB.rows != m || vectorB.columns != 1)\n            throw new IllegalArgumentError(`Expected a ${m} x 1 column-vector, but found a ${vectorB.rows} x ${vectorB.columns} matrix`);\n\n        super(matrixA, vectorB, new MatrixOperationLSSolve(matrixA._shape, vectorB._shape));\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * matrix-operation-header.js\n * Serializable metadata for matrix operations\n */\n\nimport { SpeedyMatrix } from './matrix';\nimport { MatrixShape } from './matrix-shape';\nimport { Utils } from '../../utils/utils';\n\n/**\n * Serializable metadata related to a matrix operation\n */\nexport class MatrixOperationHeader\n{\n    /**\n     * Constructor\n     * @param {string} method method name\n     * @param {number} numberOfInputMatrices how many input matrices do we require?\n     * @param {MatrixShape} outputShape shape of the output matrix\n     * @param {?object} [userData] custom serializable user-data\n     */\n    constructor(method, numberOfInputMatrices, outputShape, userData = null)\n    {\n        // ALL FIELDS ARE SERIALIZABLE\n        const n = numberOfInputMatrices | 0;\n        //Utils.assert(n >= 0);\n\n        /** @type {string} method name */\n        this.method = String(method);\n\n        /** @type {MatrixDataType} type of all matrices (input & output) */\n        this.dtype = outputShape.dtype;\n\n        /** @type {number} number of rows of the output matrix */\n        this.rows = outputShape.rows;\n\n        /** @type {number} number of columns of the output matrix */\n        this.columns = outputShape.columns;\n\n        /** @type {number} stride of the output matrix */\n        this.stride = 0; // initially unknown\n\n        /** @type {number} byte offset used to recover the data view */\n        this.byteOffset = 0; // initially unknown\n\n        /** @type {number} length in bytes used to recover the data view */\n        this.length = 0; // initially unknown\n\n        /** @type {number[]} number of rows of the input matrices */\n        this.rowsOfInputs = (new Array(n)).fill(0); // to be determined later\n\n        /** @type {number[]} number of columns of the input matrices */\n        this.columnsOfInputs = (new Array(n)).fill(0); // to be determined layer\n\n        /** @type {number[]} strides of the input matrices */\n        this.strideOfInputs = (new Array(n)).fill(0); // to be determined later - buffer may be locked\n\n        /** @type {number[]} byte offsets used to recover the data view */\n        this.byteOffsetOfInputs = (new Array(n)).fill(0); // to be determined later - buffer may be locked\n\n        /** @type {number[]} length in bytes used to recover the data view */\n        this.lengthOfInputs = (new Array(n)).fill(0); // to be determined later - buffer may be locked\n\n        /** @type {object} custom serializable user-data */\n        this.custom = new Object(userData);\n    }\n\n    /**\n     * Update fields (stride, byte offset, etc.)\n     * before executing an operation\n     * @param {SpeedyMatrix} outputMatrix \n     * @param {SpeedyMatrix[]} inputMatrices \n     */\n    updateMetadata(outputMatrix, inputMatrices)\n    {\n        this._updateOutputMetadata(outputMatrix);\n        this._updateInputMetadata(inputMatrices);\n    }\n\n    /**\n     * Update fields related to the output matrix\n     * @param {SpeedyMatrix} outputMatrix \n     */\n    _updateOutputMetadata(outputMatrix)\n    {\n        const output = outputMatrix.buffer.data;\n\n        this.stride = outputMatrix.stride;\n        this.byteOffset = output.byteOffset;\n        this.length = output.length;\n\n        // can't change the shape of the output matrix\n        Utils.assert(outputMatrix.rows === this.rows && outputMatrix.columns === this.columns && outputMatrix.dtype === this.dtype);\n    }\n\n    /**\n     * Update fields related to the input matrices\n     * The order of the input matrices shall be preserved\n     * @param {SpeedyMatrix[]} inputMatrices \n     */\n    _updateInputMetadata(inputMatrices)\n    {\n        const n = inputMatrices.length;\n        const firstIteration = this.rowsOfInputs.length == 0 || this.rowsOfInputs[0] == 0; // short-circuit\n        Utils.assert(this.rowsOfInputs.length === n);\n\n        for(let i = 0; i < n; i++) {\n            const inputMatrix = inputMatrices[i];\n            const input = inputMatrix.buffer.data;\n\n            this.strideOfInputs[i] = inputMatrix.stride;\n            this.byteOffsetOfInputs[i] = input.byteOffset;\n            this.lengthOfInputs[i] = input.length;\n\n            if(firstIteration) {\n                this.rowsOfInputs[i] = inputMatrix.rows;\n                this.columnsOfInputs[i] = inputMatrix.columns;\n            }\n            else {\n                // can't change the shape of the input matrices\n                Utils.assert(inputMatrix.rows === this.rowsOfInputs[i] && inputMatrix.columns === this.columnsOfInputs[i] && inputMatrix.dtype === this.dtype);\n            }\n        }\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * matrix-operations-queue.js\n * Run matrix operations in a FIFO fashion\n */\n\nimport { SpeedyMatrix } from './matrix';\nimport { MatrixOperation } from './matrix-operations';\nimport { SpeedyPromise } from '../../utils/speedy-promise';\n\nlet instance = null;\n\n/**\n * Used to run matrix operations in a FIFO fashion\n */\nexport class MatrixOperationsQueue\n{\n    /**\n     * Class constructor\n     */\n    constructor()\n    {\n        /** @type {Array<Array>} queue of operations */\n        this._queue = [];\n\n        /** @type {boolean} whether we have a calculation taking place */\n        this._busy = false;\n\n        /** @type {boolean} should we run the operations in a Web Worker? */\n        this._useWorker = true;\n    }\n\n    /**\n     * Get Singleton\n     * @returns {MatrixOperationsQueue}\n     */\n    static get instance()\n    {\n        return instance || (instance = new MatrixOperationsQueue());\n    }\n\n    /**\n     * Should we run the operations in a Web Worker?\n     * @param {boolean} value\n     */\n    set useWorker(value)\n    {\n        this._useWorker = Boolean(value);\n    }\n\n    /**\n     * Should we run the operations in a Web Worker?\n     * @returns {boolean}\n     */\n    get useWorker()\n    {\n        return this._useWorker;\n    }\n\n    /**\n     * Enqueue matrix operation\n     * @param {MatrixOperation} matrixOperation \n     * @param {SpeedyMatrix} outputMatrix\n     * @param {SpeedyMatrix[]} inputMatrices\n     * @returns {SpeedyPromise<void>} a promise that resolves as soon as the operation is complete\n     */\n    enqueue(matrixOperation, outputMatrix, inputMatrices)\n    {\n        // enqueue operation\n        return new SpeedyPromise(resolve => {\n            this._queue.push([ matrixOperation, inputMatrices, outputMatrix, resolve ]);\n            if(!this._busy) {\n                this._busy = true;\n                this._resolveAll();\n            }\n        });\n    }\n\n    /**\n     * Run all enqueued matrix operations\n     */\n    _resolveAll()\n    {\n        // finished the processing?\n        if(this._queue.length == 0) {\n            this._busy = false;\n            return;\n        }\n\n        // obtain the next operation\n        const [ matrixOperation, inputMatrices, outputMatrix, resolve ] = this._queue.shift();\n\n        // lock matrices\n        outputMatrix.lock();\n        for(let i = inputMatrices.length - 1; i >= 0; i--)\n            inputMatrices[i].lock();\n\n        // run the next operation\n        matrixOperation.run(inputMatrices, outputMatrix, this._useWorker).then(() => {\n            // unlock matrices\n            for(let j = inputMatrices.length - 1; j >= 0; j--)\n                inputMatrices[j].unlock();\n            outputMatrix.unlock();\n\n            // this operation is done\n            resolve();\n            this._resolveAll();\n        }).turbocharge();\n\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * matrix-operations.js\n * Matrix operations\n */\n\nimport { IllegalArgumentError, IllegalOperationError } from '../../utils/errors';\nimport { Utils } from '../../utils/utils';\nimport { SpeedyPromise } from '../../utils/speedy-promise';\nimport { SpeedyMatrix } from './matrix';\nimport { MatrixShape } from './matrix-shape';\nimport { MatrixWorker } from './matrix-worker';\nimport { MatrixOperationHeader } from './matrix-operation-header';\nimport { LinAlg } from './linalg/linalg';\n\n// Worker\nconst worker = MatrixWorker.instance;\n\n/**\n * Abstract matrix operation\n * @abstract\n */\nexport class MatrixOperation\n{\n    /**\n     * (protected) Class constructor\n     * @param {string} method method name\n     * @param {number} requiredNumberOfInputMatrices how many input matrices do we require?\n     * @param {MatrixShape} outputShape shape of the output matrix\n     * @param {?object} [userData] custom user-data, serializable\n     */\n    constructor(method, requiredNumberOfInputMatrices, outputShape, userData = null)\n    {\n        // is it a valid operation?\n        //if(!LinAlg.hasMethod(method))\n        //    throw new IllegalArgumentError(`Invalid method: \"${method}\"`);\n\n        /** @type {MatrixShape} shape of the output matrix */\n        this._shape = outputShape;\n\n        /** @type {MatrixOperationHeader} metadata related to the operation */\n        this._header = new MatrixOperationHeader(\n            method,\n            requiredNumberOfInputMatrices,\n            outputShape,\n            userData\n        );\n    }\n\n    /**\n     * The required number of rows of the output matrix\n     * @returns {number}\n     */\n    get rows()\n    {\n        return this._shape.rows;\n    }\n\n    /**\n     * The required number of columns of the output matrix\n     * @returns {number}\n     */\n    get columns()\n    {\n        return this._shape.columns;\n    }\n\n    /**\n     * The required type of the output matrix\n     * @returns {MatrixDataType}\n     */\n    get dtype()\n    {\n        return this._shape.dtype;\n    }\n\n    /**\n     * The required shape of the output matrix\n     * @returns {MatrixShape}\n     */\n    get shape()\n    {\n        return this._shape;\n    }\n\n    /**\n     * The expected number of input matrices\n     * @return {number} a non-negative integer\n     */\n    numberOfInputMatrices()\n    {\n        return this._header.rowsOfInputs.length;\n    }\n\n    /**\n     * Run the matrix operation\n     * @param {SpeedyMatrix[]} inputMatrices\n     * @param {SpeedyMatrix} outputMatrix\n     * @param {boolean} [useWorker] should we do the number crunching in a Web Worker?\n     * @returns {SpeedyPromise<void>} a promise that resolves as soon as the operation is complete\n     */\n    run(inputMatrices, outputMatrix, useWorker = true)\n    {\n        if(useWorker)\n            return this._runInWorker(inputMatrices, outputMatrix);\n        else\n            return this._runLocally(inputMatrices, outputMatrix);\n    }\n\n    /**\n     * Run the matrix operation in a Web Worker\n     * The internal buffers of the input & the output matrices are assumed to be locked\n     * @param {SpeedyMatrix[]} inputMatrices\n     * @param {SpeedyMatrix} outputMatrix\n     * @returns {SpeedyPromise<void>} a promise that resolves as soon as the operation is complete\n     */\n    _runInWorker(inputMatrices, outputMatrix)\n    {\n        // do we have a compatible output matrix?\n        this._assertCompatibility(outputMatrix.shape);\n\n        // optimization: drop if this is a sequence with no\n        // operations, such as a compiled constant expression\n        if(inputMatrices.length == 0)\n            return SpeedyPromise.resolve();\n\n        // prepare the operation header\n        this._header.updateMetadata(outputMatrix, inputMatrices);\n        \n        // crunch numbers in a WebWorker\n        return worker.run(\n            this._header,\n            this._arrayBufferOf(outputMatrix),\n            this._arrayBuffersOf(inputMatrices)\n        ).then(([newOutputBuffer, newInputBuffers]) => {\n            // update the internal buffers with the new data\n            outputMatrix.buffer.replace(newOutputBuffer);\n            for(let i = inputMatrices.length - 1; i >= 0; i--)\n                inputMatrices[i].buffer.replace(newInputBuffers[i]);\n        });\n    }\n\n    /**\n     * Run matrix operation in the same thread\n     * @param {SpeedyMatrix[]} inputMatrices\n     * @param {SpeedyMatrix} outputMatrix\n     * @returns {SpeedyPromise<void>} a promise that resolves as soon as the operation is complete\n     */\n    _runLocally(inputMatrices, outputMatrix)\n    {\n        // do we have a compatible output matrix?\n        this._assertCompatibility(outputMatrix.shape);\n\n        // optimization: drop if this is a sequence with no\n        // operations, such as a compiled constant expression\n        if(inputMatrices.length == 0)\n            return SpeedyPromise.resolve();\n\n        // prepare the operation header\n        this._header.updateMetadata(outputMatrix, inputMatrices);\n        \n        // crunch numbers locally\n        LinAlg.lib.execute(\n            this._header,\n            this._arrayBufferOf(outputMatrix),\n            this._arrayBuffersOf(inputMatrices)\n        );\n        return SpeedyPromise.resolve();\n    }\n\n    /**\n     * Assert matrix size and type\n     * @param {MatrixShape} requiredShape will test the shape of the output matrix against requiredShape\n     */\n    _assertCompatibility(requiredShape)\n    {\n        if(this._shape.equals(requiredShape))\n            return;\n        else if(this.dtype !== requiredShape.dtype)\n            throw new IllegalOperationError(`Incompatible matrix type: expected \"${requiredShape.dtype}\", found \"${this.dtype}\"`);\n        else\n            throw new IllegalOperationError(`Invalid matrix size: ${this.rows} x ${this.columns} (expected ${requiredShape.rows} x ${requiredShape.columns})`);\n    }\n\n    /**\n     * Compute a measure of the workload of an operation\n     * @param {SpeedyMatrix[]} matrices all matrices involved\n     * @returns {number}\n     */\n    _computeWorkload(matrices)\n    {\n        let w = 0;\n        for(let i = matrices.length - 1; i >= 0; i--)\n            w += matrices[i].rows * matrices[i].columns;\n\n        return w;\n    }\n\n    /**\n     * Get the internal buffers of the matrices passed as arguments\n     * Preserve the relative order of the matrices <-> buffers\n     * @param {SpeedyMatrix[]} matrices\n     * @return {ArrayBuffer[]}\n     */\n    _arrayBuffersOf(matrices)\n    {\n        const buffers = new Array(matrices.length);\n        for(let i = buffers.length - 1; i >= 0; i--)\n            buffers[i] = matrices[i].buffer.data.buffer;\n\n        return buffers;\n        //return matrices.map(this._arrayBufferOf);\n    }\n\n    /**\n     * Get the internal buffer of the matrix passed as argument\n     * @param {SpeedyMatrix} matrix\n     * @return {ArrayBuffer}\n     */\n    _arrayBufferOf(matrix)\n    {\n        return matrix.buffer.data.buffer;\n    }\n}\n\n/**\n * No-operation\n */\nexport class MatrixOperationNop extends MatrixOperation\n{\n    /**\n     * Class constructor\n     * @param {MatrixShape} shape the shape of the output matrix\n     */\n    constructor(shape)\n    {\n        super('nop', 0, shape);\n    }\n}\n\n/**\n * Fill matrix with a number\n */\nexport class MatrixOperationFill extends MatrixOperation\n{\n    /**\n     * Class constructor\n     * @param {MatrixShape} shape the shape of the output matrix\n     * @param {number} value the value we'll use to fill the matrix\n     */\n    constructor(shape, value)\n    {\n        super('fill', 0, shape, { value: +value });\n    }\n}\n\n/**\n * Copy matrix\n */\nexport class MatrixOperationCopy extends MatrixOperation\n{\n    /**\n     * Constructor\n     * @param {MatrixShape} shape the shape of the input & output matrices\n     */\n    constructor(shape)\n    {\n        super('copy', 1, shape);\n    }\n}\n\n/**\n * Transpose Matrix\n */\nexport class MatrixOperationTranspose extends MatrixOperation\n{\n    /**\n     * Class constructor\n     * @param {MatrixShape} shape the shape of the INPUT matrix\n     */\n    constructor(shape)\n    {\n        super('transpose', 1, new MatrixShape(shape.columns, shape.rows, shape.dtype));\n    }\n}\n\n/**\n * Compute the inverse of a matrix\n */\nexport class MatrixOperationInverse extends MatrixOperation\n{\n    /**\n     * Class constructor\n     * @param {MatrixShape} shape the shape of the input matrix\n     */\n    constructor(shape)\n    {\n        Utils.assert(shape.rows === shape.columns && shape.rows <= 3);\n        super('inverse' + String(shape.rows), 1, shape);\n    }\n}\n\n/**\n * Add two matrices\n * e.g., A + B\n */\nexport class MatrixOperationAdd extends MatrixOperation\n{\n    /**\n     * Class constructor\n     * @param {MatrixShape} leftShape shape of the left operand\n     * @param {MatrixShape} rightShape shape of the right operand\n     */\n    constructor(leftShape, rightShape)\n    {\n        Utils.assert(leftShape.equals(rightShape));\n        super('add', 2, leftShape);\n    }\n}\n\n/**\n * Subtract two matrices\n * e.g., A - B\n */\nexport class MatrixOperationSubtract extends MatrixOperation\n{\n    /**\n     * Class constructor\n     * @param {MatrixShape} leftShape shape of the left operand\n     * @param {MatrixShape} rightShape shape of the right operand\n     */\n    constructor(leftShape, rightShape)\n    {\n        Utils.assert(leftShape.equals(rightShape));\n        super('subtract', 2, leftShape);\n    }\n}\n\n/**\n * Multiply two matrices\n * e.g., A * B\n */\nexport class MatrixOperationMultiply extends MatrixOperation\n{\n    /**\n     * Class constructor\n     * @param {MatrixShape} leftShape shape of the left operand\n     * @param {MatrixShape} rightShape shape of the right operand\n     */\n    constructor(leftShape, rightShape)\n    {\n        Utils.assert(leftShape.columns === rightShape.rows && leftShape.dtype === rightShape.dtype);\n        const opt3 = (leftShape.rows === 3 && leftShape.columns === 3 && rightShape.columns === 3);\n        const method = opt3 ? 'multiply3' : 'multiply'; // optimize for two 3x3 matrices\n\n        super(method, 2, new MatrixShape(leftShape.rows, rightShape.columns, leftShape.dtype));\n    }\n}\n\n/**\n * Multiply by a scalar\n * e.g., alpha * A\n */\nexport class MatrixOperationScale extends MatrixOperation\n{\n    /**\n     * Constructor\n     * @param {MatrixShape} shape the shape of the input & output matrices\n     * @param {number} scalar\n     */\n    constructor(shape, scalar)\n    {\n        super('scale', 1, shape, { scalar: +scalar });\n    }\n}\n\n/**\n * Component-wise multiplication\n */\nexport class MatrixOperationCompMult extends MatrixOperation\n{\n    /**\n     * Class constructor\n     * @param {MatrixShape} leftShape shape of the left operand\n     * @param {MatrixShape} rightShape shape of the right operand\n     */\n    constructor(leftShape, rightShape)\n    {\n        Utils.assert(leftShape.equals(rightShape));\n        super('compmult', 2, leftShape);\n    }\n}\n\n/**\n * Multiply two matrices, transposing the left operand\n * e.g., A^T * B\n */\nexport class MatrixOperationMultiplyLT extends MatrixOperation\n{\n    /**\n     * Class constructor\n     * @param {MatrixShape} leftShape shape of the left operand\n     * @param {MatrixShape} rightShape shape of the right operand\n     */\n    constructor(leftShape, rightShape)\n    {\n        Utils.assert(leftShape.rows === rightShape.rows && leftShape.dtype === rightShape.dtype);\n        super('multiplylt', 2, new MatrixShape(leftShape.columns, rightShape.columns, leftShape.dtype));\n    }\n}\n\n/**\n * Multiply two matrices, transposing the right operand\n * e.g., A * B^T\n */\nexport class MatrixOperationMultiplyRT extends MatrixOperation\n{\n    /**\n     * Class constructor\n     * @param {MatrixShape} leftShape shape of the left operand\n     * @param {MatrixShape} rightShape shape of the right operand\n     */\n    constructor(leftShape, rightShape)\n    {\n        Utils.assert(leftShape.columns === rightShape.columns && leftShape.dtype === rightShape.dtype);\n        super('multiplyrt', 2, new MatrixShape(leftShape.rows, rightShape.rows, leftShape.dtype));\n    }\n}\n\n/**\n * Multiply by a column vector,\n * e.g., y = A x\n */\nexport class MatrixOperationMultiplyVec extends MatrixOperation\n{\n    /**\n     * Class constructor\n     * @param {MatrixShape} leftShape shape of the left operand\n     * @param {MatrixShape} rightShape shape of the right operand (must be a column-vector)\n     */\n    constructor(leftShape, rightShape)\n    {\n        Utils.assert(leftShape.columns === rightShape.rows && rightShape.columns === 1 && leftShape.dtype === rightShape.dtype);\n        super('multiplyvec', 2, new MatrixShape(leftShape.rows, 1, leftShape.dtype));\n    }\n}\n\n/**\n * QR decomposition\n */\nexport class MatrixOperationQR extends MatrixOperation\n{\n    /**\n     * Constructor\n     * @param {MatrixShape} shape shape of the input matrix (must satisfy rows >= columns)\n     * @param {string} mode 'full' | 'reduced'\n     */\n    constructor(shape, mode)\n    {\n        const m = ({ 'full': 'full-qr', 'reduced': 'reduced-qr' })[mode];\n        if(m === undefined)\n            throw new IllegalArgumentError(`QR decomposition: unknown mode \"${mode}\"`)\n\n        //Utils.assert(shape.rows >= shape.columns);\n        const columns = m == 'full-qr' ? shape.columns + shape.rows : 2 * shape.columns;\n        super('qr', 1, new MatrixShape(shape.rows, columns, shape.dtype), { mode: m });\n    }\n}\n\n/**\n * Internal QR solver (Ax = b) produces\n * the matrix [(Q^T)b | R] using reduced QR(*)\n * A is m x n (m >= n), b is m x 1,\n * (Q^T)b is m x 1 and R is m x n\n *\n * (*) The last (m-n) rows of the output matrix\n * will be filled with zeros. Those rows are\n * required by the calculation. You may extract\n * the first n rows\n */\nexport class MatrixOperationQRSolve extends MatrixOperation\n{\n    /**\n     * Constructor\n     * @param {MatrixShape} shapeA required shape of the input matrix A\n     * @param {MatrixShape} shapeB required shape of the input matrix B (must be a column-vector)\n     */\n    constructor(shapeA, shapeB)\n    {\n        Utils.assert(shapeA.rows === shapeB.rows && shapeB.columns === 1 && shapeA.dtype === shapeB.dtype);\n        super('qr', 2, new MatrixShape(shapeA.rows, shapeA.columns + 1, shapeA.dtype), { mode: 'reduced-Q\\'x' });\n    }\n}\n\n/**\n * Given an input matrix of the form [b | R]\n * where b is n x 1 and R is an n x n upper\n * triangular matrix, solve Rx = b for x\n */\nexport class MatrixOperationBackSubstitution extends MatrixOperation\n{\n    /**\n     * Constructor\n     * @param {MatrixShape} shape shape of the input matrix\n     */\n    constructor(shape)\n    {\n        Utils.assert(shape.columns === shape.rows + 1);\n        super('backsub', 1, new MatrixShape(shape.rows, 1, shape.dtype));\n    }\n}\n\n/**\n * Find best-fit solution x of Ax = b with least-squares method\n * A is m x n, b is m x 1, output x is n x 1\n * (m equations, n unknowns, m >= n)\n */\nexport class MatrixOperationLSSolve extends MatrixOperation\n{\n    /**\n     * Constructor\n     * @param {MatrixShape} shapeA required shape of the input matrix A\n     * @param {MatrixShape} shapeB required shape of the input matrix B (must be a column-vector)\n     */\n    constructor(shapeA, shapeB)\n    {\n        Utils.assert(shapeA.rows === shapeB.rows && shapeB.columns === 1 && shapeA.dtype === shapeB.dtype);\n        super('lssolve', 2, new MatrixShape(shapeA.columns, 1, shapeA.dtype));\n    }\n}\n\n/**\n * A matrix operation containing other matrix operations within it\n * @abstract\n */\nexport class MatrixOperationWithSubroutine extends MatrixOperation\n{\n    /**\n     * Constructor\n     * @param {string} method method name\n     * @param {number} requiredNumberOfInputMatrices how many input matrices do we require?\n     * @param {MatrixShape} outputShape shape of the output matrix\n     * @param {string[]} [subroutines] names of the subroutines\n     * @param {object} [userData] custom user-data, serializable\n     */\n    constructor(method, requiredNumberOfInputMatrices, outputShape, subroutines, userData = {})\n    {\n        super(method, requiredNumberOfInputMatrices, outputShape, {\n            ...userData,\n            subroutine: subroutines.reduce((obj, sub) => Object.assign(obj, { [sub]: [] }), {})\n        });\n    }\n\n    /**\n     * New step of a subroutine\n     * @param {MatrixOperation} operation\n     * @param {number} indexOfOutputMatrix\n     * @param {number[]} indicesOfInputMatrices\n     * @returns {StepOfSubroutineOfMatrixOperation}\n     */\n    static step(operation, indexOfOutputMatrix, indicesOfInputMatrices)\n    {\n        // The trick is to map the input & output matrices of each step of\n        // all subroutines to specific input matrices of the entire operation\n        const header = operation._header;\n\n        /** @typedef {object} StepOfSubroutineOfMatrixOperation */\n        return { header, indexOfOutputMatrix, indicesOfInputMatrices };\n    }\n\n    /**\n     * The steps performed by a subroutine, as provided in the constructor\n     * @param {string} subname name of the subroutine\n     * @return {StepOfSubroutineOfMatrixOperation[]}\n     */\n    _stepsOf(subname)\n    {\n        const subroutine = this._header.custom.subroutine;\n        Utils.assert(Object.prototype.hasOwnProperty.call(subroutine, subname));\n        return subroutine[subname];\n    }\n\n    /**\n     * Set the steps of a declared subroutine\n     * @param {string} subname name of the subroutine\n     * @param {StepOfSubroutineOfMatrixOperation[]} steps\n     */\n    setStepsOf(subname, steps)\n    {\n        const subroutine = this._header.custom.subroutine;\n        Utils.assert(Array.isArray(subroutine[subname]) && subroutine[subname].length == 0);\n        Utils.assert(Array.isArray(steps));\n        subroutine[subname] = steps;\n    }\n\n    /**\n     * Adjust the indices of all steps of the subroutine according to a given function\n     * @param {Function} newIndexOf maps a matrix to new matrix index\n     * @param {SpeedyMatrix[]} mats matrices with original indexing\n     */\n    adjustIndices(newIndexOf, mats)\n    {\n        const subroutines = this._header.custom.subroutine;\n        //(function adjust(subroutines) {\n        for(let sub in subroutines) {\n            if(Object.prototype.hasOwnProperty.call(subroutines, sub)) {\n                const steps = subroutines[sub];\n                for(let i = 0, n = steps.length, step = null; i < n; i++) {\n                    step = steps[i];\n                    step.indexOfOutputMatrix = newIndexOf(mats[step.indexOfOutputMatrix]);\n                    for(let j = step.indicesOfInputMatrices.length - 1; j >= 0; j--)\n                        step.indicesOfInputMatrices[j] = newIndexOf(mats[step.indicesOfInputMatrices[j]]);\n                    /* // this is a no go when subroutines call other subroutines:\n                    if(Object.prototype.hasOwnProperty.call(step.header.custom, 'subroutine'))\n                        adjust(step.header.custom.subroutine); */\n                }\n            }\n        }\n        //})(this._header.custom.subroutine);\n    }\n}\n\n/**\n * A sequence of MatrixOperations encapsulated into one\n */\nexport class MatrixOperationSequence extends MatrixOperationWithSubroutine\n{\n    /**\n     * Constructor\n     * @param {number} n number of input matrices\n     * @param {MatrixShape} shape shape of the output matrix\n     * @param {StepOfSubroutineOfMatrixOperation[]} steps steps to be performed, as returned by step() <static>\n     */\n    constructor(n, shape, steps)\n    {\n        super('sequence', n, shape, ['sequence']);\n        this.setStepsOf('sequence', steps);\n    }\n\n    /**\n     * The steps performed by this sequence, as provided in the constructor\n     * @returns {StepOfSubroutineOfMatrixOperation[]}\n     */\n    steps()\n    {\n        return this._stepsOf('sequence');\n    }\n}\n\n/**\n * Sort blocks of a matrix\n */\nexport class MatrixOperationSort extends MatrixOperationWithSubroutine\n{\n    /**\n     * Constructor\n     * @param {MatrixShape} outputShape shape of the output matrix\n     */\n    constructor(outputShape)\n    {\n        super('sort', 4, outputShape, ['cmp']);\n    }\n}\n\n/**\n * Map blocks of a matrix\n */\nexport class MatrixOperationMap extends MatrixOperationWithSubroutine\n{\n    /**\n     * Constructor\n     * @param {MatrixShape} outputShape shape of the output matrix\n     */\n    constructor(outputShape)\n    {\n        super('map', 4, outputShape, ['mapfn']);\n    }\n}\n\n/**\n * Reduce blocks of a matrix\n */\nexport class MatrixOperationReduce extends MatrixOperationWithSubroutine\n{\n    /**\n     * Constructor\n     * @param {MatrixShape} outputShape shape of the output matrix\n     */\n    constructor(outputShape)\n    {\n        super('reduce', 6, outputShape, ['reducefn']);\n    }\n}\n\n/**\n * Compute a homography matrix using 4 correspondences of points\n */\nexport class MatrixOperationHomography4p extends MatrixOperation\n{\n    /**\n     * Class constructor\n     * @param {MatrixShape} srcShape shape of the src operand (must be 2x4)\n     * @param {MatrixShape} dstShape shape of the dst operand (must be 2x4)\n     */\n    constructor(srcShape, dstShape)\n    {\n        Utils.assert(srcShape.equals(dstShape));\n        super('homographynorm4p', 2, new MatrixShape(3, 3, srcShape.dtype));\n    }\n}\n\n/**\n * Compute a homography matrix using n >= 4 correspondences of points via DLT\n */\nexport class MatrixOperationHomographyDLT extends MatrixOperation\n{\n    /**\n     * Class constructor\n     * @param {MatrixShape} srcShape shape of the src operand (must be 2 x n, n >= 4)\n     * @param {MatrixShape} dstShape shape of the dst operand (must be 2 x n)\n     */\n    constructor(srcShape, dstShape)\n    {\n        Utils.assert(srcShape.equals(dstShape));\n        super('homographynormdlt', 2, new MatrixShape(3, 3, srcShape.dtype));\n    }\n}\n\n/**\n * Apply a homography matrix to a set of 2D points\n */\nexport class MatrixOperationApplyHomography extends MatrixOperation\n{\n    /**\n     * Constructor\n     * @param {MatrixShape} homShape shape of the homography matrix (must be 3x3)\n     * @param {MatrixShape} ptsShape shape of the matrix of the input points (must be 2xn)\n     */\n    constructor(homShape, ptsShape)\n    {\n        Utils.assert(ptsShape.dtype === homShape.dtype);\n        super('applyHomography', 2, ptsShape);\n    }\n}\n\n/**\n * Apply an affine transformation to a set of 2D points\n */\nexport class MatrixOperationApplyAffine extends MatrixOperation\n{\n    /**\n     * Constructor\n     * @param {MatrixShape} matShape shape of the transformation matrix (must be 2x3)\n     * @param {MatrixShape} ptsShape shape of the matrix of the input points (must be 2xn)\n     */\n    constructor(matShape, ptsShape)\n    {\n        Utils.assert(ptsShape.dtype === matShape.dtype);\n        super('applyAffine', 2, ptsShape);\n    }\n}\n\n/**\n * Apply a linear transformation to a set of 2D points\n */\nexport class MatrixOperationApplyLinear2d extends MatrixOperation\n{\n    /**\n     * Constructor\n     * @param {MatrixShape} matShape shape of the transformation matrix (must be 2x2)\n     * @param {MatrixShape} ptsShape shape of the matrix of the input points (must be 2xn)\n     */\n    constructor(matShape, ptsShape)\n    {\n        Utils.assert(ptsShape.dtype === matShape.dtype);\n        super('applyLinear2d', 2, ptsShape);\n    }\n}\n\n/**\n * Compute a homography matrix using P-RANSAC\n */\nexport class MatrixOperationPransacHomography extends MatrixOperation\n{\n    /**\n     * Class constructor\n     * @param {MatrixShape} srcShape source coordinates: must be 2 x n (n >= 4)\n     * @param {MatrixShape} dstShape destination coordinates: must be 2 x n\n     * @param {number} numberOfHypotheses positive integer\n     * @param {number} bundleSize positive integer\n     * @param {number} reprojectionError in pixels\n     * @param {MatrixShape} maskShape inlier-outlier output mask: must be 1 x n\n     */\n    constructor(srcShape, dstShape, numberOfHypotheses, bundleSize, reprojectionError, maskShape)\n    {\n        Utils.assert(srcShape.equals(dstShape));\n        Utils.assert(srcShape.columns === maskShape.columns);\n        super('pransacHomography', 3, new MatrixShape(3, 3, srcShape.dtype), {\n            numberOfHypotheses, bundleSize, reprojectionError\n        });\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * matrix-settings.js\n * Global settings singleton\n */\n\nimport { MatrixOperationsQueue } from './matrix-operations-queue';\n\nlet instance = null;\n\n/**\n * Global settings singleton\n */\nexport class SpeedyMatrixSettings\n{\n    /**\n     * Get singleton\n     * @returns {SpeedyMatrixSettings}\n     */\n    static get instance()\n    {\n        return instance || (instance = new SpeedyMatrixSettings());\n    }\n\n    /**\n     * Should we run the matrix operations in a Web Worker?\n     * @returns {boolean}\n     */\n    get useWorker()\n    {\n        return MatrixOperationsQueue.instance.useWorker;\n    }\n\n    /**\n     * Should we run the matrix operations in a Web Worker?\n     * @param {boolean} value\n     */\n    set useWorker(value)\n    {\n        MatrixOperationsQueue.instance.useWorker = Boolean(value);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * matrix-shape.js\n * A convenient immutable object that represents the shape of a matrix\n */\n\nimport { IllegalArgumentError } from '../../utils/errors';\nimport { MatrixType } from './matrix-type';\n\n/**\n * A convenient immutable object that represents the shape of a matrix\n */\nexport class MatrixShape\n{\n    /**\n     * Constructor\n     * @param {number} rows number of rows of the matrix\n     * @param {number} columns number of columns of the matrix\n     * @param {MatrixDataType} [dtype] data type of the matrix\n     */\n    constructor(rows, columns, dtype = MatrixType.default)\n    {\n        /** @type {number} number of rows of the matrix */\n        this.rows = rows | 0;\n\n        /** @type {number} number of columns of the matrix */\n        this.columns = columns | 0;\n\n        /** @type {MatrixDataType} data type of the matrix */\n        this.dtype = String(dtype);\n\n        // validate\n        if(!MatrixType.isValid(this.dtype))\n            throw new IllegalArgumentError(`Invalid matrix data type: \"${this.dtype}\"`);\n        else if(this.rows < 1 || this.columns < 1)\n            throw new IllegalArgumentError(`Invalid matrix size: ${this.rows} x ${this.columns}`);\n\n        // make it immutable\n        return Object.freeze(this);\n    }\n\n    /**\n     * Checks if two shapes are equal\n     * @param {MatrixShape} shape\n     * @returns {boolean}\n     */\n    equals(shape)\n    {\n        return this.rows === shape.rows && this.columns === shape.columns && this.dtype === shape.dtype;\n    }\n\n    /**\n     * String representation of the matrix shape\n     * @returns {string}\n     */\n    toString()\n    {\n        return `MatrixShape(rows=${this.rows},cols=${this.columns},dtype=\"${this.dtype}\")`;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * matrix-type.js\n * Data types of matrices\n */\n\n//! No imports here\n//! MatrixType is exported to a WebWorker\n\n/**\n * Types of matrices: utilities\n * \n * Matrices store data of a certain type\n * (e.g., 'float32', 'float64', etc.)\n * \n * @typedef {string} MatrixDataType\n */\nclass MatrixType\n{\n    /**\n     * Is the specified matrix data type valid?\n     * @param {MatrixDataType} dtype data type\n     * @returns {boolean}\n     */\n    static isValid(dtype)\n    {\n        return Object.prototype.hasOwnProperty.call(this._classOf, dtype);\n    }\n\n    /**\n     * Create a TypedArray of the specified type\n     * @param {MatrixDataType} dtype data type\n     * @param {any[]} args will be passed to the constructor of the TypedArray\n     * @returns {ArrayBufferView}\n     */\n    static createTypedArray(dtype, ...args)\n    {\n        if(!this.isValid(dtype))\n            throw new Error(`Invalid matrix type: \"${dtype}\"`);\n\n        return Reflect.construct(this._classOf[dtype], args);\n    }\n\n    /**\n     * Default data type for matrices\n     * @returns {MatrixDataType}\n     */\n    static get default()\n    {\n        return 'float32';\n    }\n\n    /**\n     * A mapping between MatrixDataType and\n     * corresponding TypedArray constructors\n     * @returns {object}\n     */\n    static get _classOf()\n    {\n        return this._dataType || (this._dataType = Object.freeze({\n\n            /** 32-bit float */\n            'float32': Float32Array,\n\n            /** 64-bit float */\n            'float64': Float64Array,\n\n            /** 32-bit signed integer */\n            'int32': Int32Array,\n\n            /** 8-bit unsigned integer */\n            'uint8': Uint8Array,\n\n        }));\n    }\n\n    /**\n     * Freeze this class\n     * @returns {Function} this class\n     */\n    static freeze()\n    {\n        const target = (this._classOf, this);\n        return Object.freeze(target);\n    }\n}\n\nmodule.exports = { MatrixType: MatrixType.freeze() };","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * matrix-worker.js\n * Web Worker bridge\n */\n\nimport { LinAlg } from './linalg/linalg';\nimport { MatrixOperationHeader } from './matrix-operation-header';\nimport { IllegalOperationError } from '../../utils/errors';\nimport { SpeedyPromise } from '../../utils/speedy-promise';\n\n// Constants\nconst MAX_MESSAGE_ID = 0x7FFFFFFF; // use the form 2^n - 1\nconst NOP = 'nop'; // no operation\n\n/**\n * A bridge between the main thread and a Web Worker\n * that performs matrix computations\n */\nexport class MatrixWorker\n{\n    /**\n     * Get Singleton\n     * @returns {MatrixWorker}\n     */\n    static get instance()\n    {\n        return this._instance || (this._instance = new MatrixWorker());\n    }\n\n    /**\n     * Class constructor\n     */\n    constructor()\n    {\n        /** @type {number} message counter */\n        this._msgId = 0;\n\n        /** @type {Map<number,Function>} callback table */\n        this._callbackTable = new Map();\n\n        /** @type {Worker} WebWorker */\n        this._worker = this._createWorker();\n    }\n\n    /**\n     * Run computation in a Web Worker\n     * @param {MatrixOperationHeader} header serializable data\n     * @param {ArrayBuffer} outputBuffer data of the output matrix\n     * @param {ArrayBuffer[]} inputBuffers data of the input matrices\n     * @returns {SpeedyPromise<Array>} resolves as soon as the computation is complete\n     */\n    run(header, outputBuffer, inputBuffers)\n    {\n        if(header.method === NOP) // save some time\n            return SpeedyPromise.resolve([outputBuffer, inputBuffers]);\n\n        const id = (this._msgId = (this._msgId + 1) & MAX_MESSAGE_ID);\n        const transferables = inputBuffers.concat(outputBuffer).filter(\n            (x, i, arr) => arr.indexOf(x) === i // remove duplicates\n        );\n        const msg = { id, header, outputBuffer, inputBuffers, transferables };\n\n        return new SpeedyPromise(resolve => {\n            this._callbackTable.set(id, resolve);\n            this._worker.postMessage(msg, transferables);\n        });\n    }\n\n    /**\n     * Create a Web Worker capable of performing Matrix computations\n     * @returns {Worker}\n     */\n    _createWorker()\n    {\n        // setup the code\n        const js = 'self.LinAlg = ' + LinAlg.toString() + ';\\n' +\n                   'self.onmessage = ' + onmessage.toString() + ';';\n        const blob = new Blob([ js ], { type: 'application/javascript' });\n        //console.log(js);\n\n        // setup the Worker\n        const worker = new Worker(URL.createObjectURL(blob));\n        worker.onmessage = ev => {\n            const msg = ev.data;\n            const resolve = this._callbackTable.get(msg.id);\n            resolve([msg.outputBuffer, msg.inputBuffers]);\n            this._callbackTable.delete(msg.id);\n        };\n        worker.onerror = ev => {\n            throw new IllegalOperationError(`Worker error: ${ev.message}`);\n        };\n\n        // done!\n        return worker;\n    }\n}\n\n/**\n * This function runs in the Web Worker\n * @param {MessageEvent} ev\n */\nfunction onmessage(ev)\n{\n    // extract input\n    const { id, header, outputBuffer, inputBuffers, transferables } = ev.data;\n\n    // perform the computation\n    self.LinAlg.lib.execute(header, outputBuffer, inputBuffers);\n\n    // send the result of the computation back to the main thread\n    const msg = { id, outputBuffer, inputBuffers };\n    self.postMessage(msg, transferables);\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * matrix.js\n * Matrix type\n */\n\nimport { IllegalArgumentError, IllegalOperationError, NotSupportedError } from '../../utils/errors';\nimport { MatrixType } from './matrix-type';\nimport { MatrixShape } from './matrix-shape';\nimport { MatrixBuffer } from './matrix-buffer';\nimport { MatrixOperationsQueue } from './matrix-operations-queue';\nimport { MatrixOperationNop } from './matrix-operations';\nimport { SpeedyPromise } from '../../utils/speedy-promise';\n\n\n\n// Constants\nconst matrixOperationsQueue = MatrixOperationsQueue.instance;\n\n\n\n/**\n * Matrix class\n */\nexport class SpeedyMatrix\n{\n    /**\n     * Class constructor\n     * @param {MatrixShape} shape shape of the matrix\n     * @param {?number[]} [values] initial values in column-major format\n     * @param {number} [stride] custom stride\n     * @param {MatrixBuffer} [buffer] custom buffer\n     */\n    constructor(shape, values = null, stride = shape.rows, buffer = null)\n    {\n        /** @type {MatrixShape} the shape of the matrix */\n        this._shape = shape;\n\n        /** @type {number} the number of entries, in the internal buffer, between the beginning of two columns */\n        this._stride = stride | 0;\n\n        /** @type {MatrixBuffer} internal buffer */\n        this._buffer = buffer || new MatrixBuffer(this.stride * this.columns, values, this.dtype);\n\n        /** @type {MatrixOperationNop} no-op utility, spawned lazily */\n        this._nop = null;\n\n        // validate\n        if(this.stride < this.rows)\n            throw new IllegalArgumentError(`Invalid stride (expected ${this.rows} or greater, found ${this.stride})`);\n        else if(Array.isArray(values) && values.length != this.rows * this.columns)\n            throw new IllegalArgumentError(`Incorrect number of matrix elements (expected ${this.rows * this.columns}, found ${values.length})`);\n    }\n\n\n\n    // ====================================\n    // MATRIX PROPERTIES\n    // ====================================\n\n    /**\n     * Number of rows of the matrix\n     * @returns {number}\n     */\n    get rows()\n    {\n        return this._shape.rows;\n    }\n\n    /**\n     * Number of columns of the matrix\n     * @returns {number}\n     */\n    get columns()\n    {\n        return this._shape.columns;\n    }\n\n    /**\n     * Data type\n     * @returns {MatrixDataType}\n     */\n    get dtype()\n    {\n        return this._shape.dtype;\n    }\n\n    /**\n     * The number of entries, in the MatrixBuffer,\n     * between the beginning of two columns\n     * @returns {number}\n     */\n    get stride()\n    {\n        return this._stride;\n    }\n\n    /**\n     * The shape of the matrix\n     * @returns {MatrixShape}\n     */\n    get shape()\n    {\n        return this._shape;\n    }\n\n\n\n    // ====================================\n    // READ MATRIX\n    // ====================================\n\n    /**\n     * Read entries of the matrix. Note that this method is asynchronous.\n     * It will read the data as soon as all relevant calculations have been\n     * completed. Make sure you await.\n     * The entries of the matrix will be returned as a flattened array of\n     * numbers in column-major format.\n     * @returns {SpeedyPromise<number[]>} a promise that resolves to the requested entries\n     */\n    read()\n    {\n        const rows = this.rows, cols = this.columns, stride = this.stride;\n\n        return this.sync().then(() => this._buffer.ready().turbocharge()).then(buffer => {\n            const data = buffer.data;\n            const n = rows * cols;\n            const result = new Array(n);\n\n            // write entries in column-major format\n            let i, j, k = 0;\n            for(j = 0; j < cols; j++) {\n                for(i = 0; i < rows; i++)\n                    result[k++] = data[j * stride + i];\n            }\n\n            // done!\n            return result;\n        }).turbocharge();\n    }\n\n    /**\n     * Print the matrix. Useful for debugging\n     * @param {number} [decimals] format numbers to a number of decimals\n     * @param {Function} [printFunction] prints a string\n     * @returns {SpeedyPromise<void>} a promise that resolves as soon as the matrix is printed\n     */\n    print(decimals = undefined, printFunction = console.log)\n    {\n        return this.read().then(data => {\n            const rows = this.rows, columns = this.columns;\n            const row = new Array(rows);\n            let i, j;\n\n            for(i = 0; i < rows; i++) {\n                row[i] = new Array(columns);\n                for(j = 0; j < columns; j++)\n                    row[i][j] = data[j * rows + i];\n            }\n\n            const fix = decimals !== undefined ? x => x.toFixed(decimals) : x => x;\n            const fmt = row.map(r => '    ' + r.map(fix).join(', ')).join(',\\n');\n            const str = `SpeedyMatrix(rows=${rows}, cols=${columns}, dtype=\"${this.dtype}\", data=[\\n${fmt}\\n])`;\n            printFunction(str);\n        });\n    }\n\n\n\n\n\n    // ====================================\n    // ACCESS BY BLOCK\n    // ====================================\n\n    /**\n     * Create a submatrix using the range [firstRow:lastRow, firstColumn:lastColumn].\n     * It will have size (lastRow - firstRow + 1) x (lastColumn - firstColumn + 1).\n     * The internal buffer of the matrix will be shared with the submatrix,\n     * so if you modify one, you'll modify the other.\n     * @param {number} firstRow indexed by 0\n     * @param {number} lastRow indexed by 0\n     * @param {number} firstColumn indexed by 0\n     * @param {number} lastColumn indexed by 0\n     * @returns {SpeedyPromise<SpeedyMatrix>}\n     */\n    block(firstRow, lastRow, firstColumn, lastColumn)\n    {\n        const rows = this.rows, columns = this.columns;\n\n        // validate range\n        if(lastRow < firstRow || lastColumn < firstColumn)\n            throw new IllegalArgumentError(`Can't create empty submatrix - invalid range [${firstRow}:${lastRow}, ${firstColumn}:${lastColumn}]`);\n        else if(firstRow < 0 || lastRow >= rows || firstColumn < 0 || lastColumn >= columns)\n            throw new IllegalArgumentError(`Can't create submatrix - invalid range [${firstRow}:${lastRow}, ${firstColumn}:${lastColumn}] of ${rows} x ${columns} matrix`);\n\n        // compute the dimensions of the new submatrix\n        const subRows = lastRow - firstRow + 1;\n        const subColumns = lastColumn - firstColumn + 1;\n        const subShape = new MatrixShape(subRows, subColumns, this.dtype);\n\n        // obtain the relevant portion of the data\n        const stride = this.stride;\n        const begin = firstColumn * stride + firstRow;\n        const length = (lastColumn - firstColumn) * stride + subRows;\n\n        // create submatrix\n        return this._buffer.createSharedBuffer(begin, length).then(sharedBuffer =>\n            new SpeedyMatrix(subShape, undefined, stride, sharedBuffer)\n        );\n    }\n\n    /**\n     * Creates a vector featuring the elements of the main diagonal\n     * of the matrix. The internal buffers of the column-vector and of the\n     * matrix are shared, so if you change the data in one, you'll change\n     * the data in the other.\n     * @returns {SpeedyPromise<SpeedyMatrix>}\n     */\n    diagonal()\n    {\n        const rows = this.rows, stride = this.stride;\n        const diagonalLength = Math.min(rows, this.columns);\n        const bufferLength = (diagonalLength - 1) * stride + rows;\n        const shape = new MatrixShape(1, diagonalLength, this.dtype);\n\n        return this._buffer.createSharedBuffer(0, bufferLength).then(sharedBuffer =>\n            new SpeedyMatrix(shape, undefined, stride + 1, sharedBuffer)\n        );\n    }\n\n\n\n\n\n    // ====================================\n    // MATRIX UTILITIES\n    // ====================================\n\n    /**\n     * Convert to string\n     * @returns {string}\n     */\n    toString()\n    {\n        return `SpeedyMatrix(rows=${this.rows}, cols=${this.columns}, dtype=\"${this.dtype}\")`;\n    }\n\n    /**\n     * Locks the internal buffer of this matrix,\n     * so it can't be read from nor written to\n     */\n    lock()\n    {\n        this._buffer.lock();\n    }\n\n    /**\n     * Unlocks the internal buffer of this matrix and\n     * resolves all pending read/write operations\n     */\n    unlock()\n    {\n        this._buffer.unlock();\n    }\n\n    /**\n     * The internal buffer of this matrix\n     * @returns {MatrixBuffer}\n     */\n    get buffer()\n    {\n        return this._buffer;\n    }\n\n    /**\n     * Returns a promise that resolves as soon as all\n     * operations submitted UP TO NOW have finished\n     * @returns {SpeedyPromise<void>}\n     */\n    sync()\n    {\n        this._nop = this._nop || (this._nop = new MatrixOperationNop(this.shape));\n        return matrixOperationsQueue.enqueue(this._nop, this, []);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * filter-factory.js\n * Image filters\n */\n\nimport { SpeedyNamespace } from '../../speedy-namespace';\nimport { SpeedyPipelineNodeGreyscale } from '../nodes/filters/greyscale';\nimport { SpeedyPipelineNodeGaussianBlur } from '../nodes/filters/gaussian-blur';\nimport { SpeedyPipelineNodeSimpleBlur } from '../nodes/filters/simple-blur';\nimport { SpeedyPipelineNodeMedianBlur } from '../nodes/filters/median-blur';\nimport { SpeedyPipelineNodeConvolution } from '../nodes/filters/convolution';\nimport { SpeedyPipelineNodeNightvision } from '../nodes/filters/nightvision';\nimport { SpeedyPipelineNodeNormalize } from '../nodes/filters/normalize';\n\n/**\n * Image filters\n */\nexport class SpeedyPipelineFilterFactory extends SpeedyNamespace\n{\n    /**\n     * Convert image to greyscale\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeGreyscale}\n     */\n    static Greyscale(name = undefined)\n    {\n        return new SpeedyPipelineNodeGreyscale(name);\n    }\n\n    /**\n     * Gaussian Blur\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeGaussianBlur}\n     */\n    static GaussianBlur(name = undefined)\n    {\n        return new SpeedyPipelineNodeGaussianBlur(name);\n    }\n\n    /**\n     * Simple Blur (Box Filter)\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeSimpleBlur}\n     */\n    static SimpleBlur(name = undefined)\n    {\n        return new SpeedyPipelineNodeSimpleBlur(name);\n    }\n\n    /**\n     * Median Blur\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeSimpleBlur}\n     */\n    static MedianBlur(name = undefined)\n    {\n        return new SpeedyPipelineNodeMedianBlur(name);\n    }\n\n    /**\n     * Image Convolution\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeSimpleBlur}\n     */\n    static Convolution(name = undefined)\n    {\n        return new SpeedyPipelineNodeConvolution(name);\n    }\n\n    /**\n     * Nightvision\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeSimpleBlur}\n     */\n    static Nightvision(name = undefined)\n    {\n        return new SpeedyPipelineNodeNightvision(name);\n    }\n\n    /**\n     * Normalize image\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeNormalize}\n     */\n    static Normalize(name = undefined)\n    {\n        return new SpeedyPipelineNodeNormalize(name);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * image-factory.js\n * Image-related nodes\n */\n\nimport { SpeedyNamespace } from '../../speedy-namespace';\nimport { SpeedyPipelineNodeImageSource } from '../nodes/images/source';\nimport { SpeedyPipelineNodeImageSink } from '../nodes/images/sink';\nimport { SpeedyPipelineNodeImageMultiplexer } from '../nodes/images/multiplexer';\nimport { SpeedyPipelineNodeImageBuffer } from '../nodes/images/buffer';\nimport { SpeedyPipelineNodeImagePyramid } from '../nodes/images/pyramid';\n\n/**\n * Image nodes\n */\nexport class SpeedyPipelineImageFactory extends SpeedyNamespace\n{\n    /**\n     * Create an image source\n     * @param {string} [name] name of the node\n     * @returns {SpeedyPipelineNodeImageSource}\n     */\n    static Source(name = undefined)\n    {\n        return new SpeedyPipelineNodeImageSource(name);\n    }\n\n    /**\n     * Create an image sink\n     * @param {string} [name] name of the node\n     * @returns {SpeedyPipelineNodeImageSink}\n     */\n    static Sink(name = undefined)\n    {\n        return new SpeedyPipelineNodeImageSink(name);\n    }\n\n    /**\n     * Create an image multiplexer\n     * @param {string} [name] name of the node\n     * @returns {SpeedyPipelineNodeImageMultiplexer}\n     */\n    static Multiplexer(name = undefined)\n    {\n        return new SpeedyPipelineNodeImageMultiplexer(name);\n    }\n\n    /**\n     * Create an image buffer\n     * @param {string} [name] name of the node\n     * @returns {SpeedyPipelineNodeImageBuffer}\n     */\n    static Buffer(name = undefined)\n    {\n        return new SpeedyPipelineNodeImageBuffer(name);\n    }\n\n    /**\n     * Image Pyramid\n     * @param {string} [name] name of the node\n     * @returns {SpeedyPipelineNodeImagePyramid}\n     */\n    static Pyramid(name = undefined)\n    {\n        return new SpeedyPipelineNodeImagePyramid(name);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * keypoint-factory.js\n * Keypoint-related nodes\n */\n\nimport { SpeedyNamespace } from '../../speedy-namespace';\nimport { SpeedyPipelineNodeKeypointSource } from '../nodes/keypoints/source';\nimport { SpeedyPipelineNodeKeypointSink } from '../nodes/keypoints/sink';\nimport { SpeedyPipelineNodeKeypointClipper } from '../nodes/keypoints/clipper';\nimport { SpeedyPipelineNodeKeypointBuffer } from '../nodes/keypoints/buffer';\nimport { SpeedyPipelineNodeKeypointMixer } from '../nodes/keypoints/mixer';\nimport { SpeedyPipelineNodeFASTKeypointDetector } from '../nodes/keypoints/detectors/fast';\nimport { SpeedyPipelineNodeHarrisKeypointDetector } from '../nodes/keypoints/detectors/harris';\nimport { SpeedyPipelineNodeORBKeypointDescriptor } from '../nodes/keypoints/descriptors/orb';\nimport { SpeedyPipelineNodeLKKeypointTracker } from '../nodes/keypoints/trackers/lk';\n\n/**\n * Keypoint detectors\n */\nclass SpeedyPipelineKeypointDetectorFactory extends SpeedyNamespace\n{\n    /**\n     * FAST corner detector\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeFASTKeypointDetector}\n     */\n    static FAST(name = undefined)\n    {\n        return new SpeedyPipelineNodeFASTKeypointDetector(name);\n    }\n\n    /**\n     * Harris corner detector\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeFASTKeypointDetector}\n     */\n    static Harris(name = undefined)\n    {\n        return new SpeedyPipelineNodeHarrisKeypointDetector(name);\n    }\n}\n\n/**\n * Keypoint descriptors\n */\nclass SpeedyPipelineKeypointDescriptorFactory extends SpeedyNamespace\n{\n    /**\n     * ORB descriptors\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeORBKeypointDescriptor}\n     */\n    static ORB(name = undefined)\n    {\n        return new SpeedyPipelineNodeORBKeypointDescriptor(name);\n    }\n}\n\n/**\n * Keypoint trackers\n */\nclass SpeedyPipelineKeypointTrackerFactory extends SpeedyNamespace\n{\n    /**\n     * LK optical-flow\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeLKKeypointTracker}\n     */\n    static LK(name = undefined)\n    {\n        return new SpeedyPipelineNodeLKKeypointTracker(name);\n    }\n}\n\n/**\n * Keypoint-related nodes\n */\nexport class SpeedyPipelineKeypointFactory extends SpeedyNamespace\n{\n    /**\n     * Keypoint detectors\n     * @returns {Function}\n     */\n    static get Detector()\n    {\n        return SpeedyPipelineKeypointDetectorFactory;\n    }\n\n    /**\n     * Keypoint descriptors\n     * @returns {Function}\n     */\n    static get Descriptor()\n    {\n        return SpeedyPipelineKeypointDescriptorFactory;\n    }\n\n    /**\n     * Keypoint trackers\n     * @returns {Function}\n     */\n    static get Tracker()\n    {\n        return SpeedyPipelineKeypointTrackerFactory;\n    }\n\n    /**\n     * Create a keypoint source\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeKeypointSource}\n     */\n    static Source(name = undefined)\n    {\n        return new SpeedyPipelineNodeKeypointSource(name);\n    }\n\n    /**\n     * Create a keypoint sink\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeKeypointSink}\n     */\n    static Sink(name = undefined)\n    {\n        return new SpeedyPipelineNodeKeypointSink(name);\n    }\n\n    /**\n     * Keypoint clipper\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeKeypointClipper}\n     */\n    static Clipper(name = undefined)\n    {\n        return new SpeedyPipelineNodeKeypointClipper(name);\n    }\n\n    /**\n     * Create a keypoint buffer\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeKeypointBuffer}\n     */\n    static Buffer(name = undefined)\n    {\n        return new SpeedyPipelineNodeKeypointBuffer(name);\n    }\n\n    /**\n     * Create a keypoint mixer\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeKeypointMixer}\n     */\n    static Mixer(name = undefined)\n    {\n        return new SpeedyPipelineNodeKeypointMixer(name);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * transform-factory.js\n * Image transforms\n */\n\nimport { SpeedyNamespace } from '../../speedy-namespace';\nimport { SpeedyPipelineNodePerspectiveWarp } from '../nodes/transforms/perspective-warp';\nimport { SpeedyPipelineNodeResize } from '../nodes/transforms/resize';\n\n/**\n * Image transforms\n */\nexport class SpeedyPipelineTransformFactory extends SpeedyNamespace\n{\n    /**\n     * Resize image\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeNormalize}\n     */\n    static Resize(name = undefined)\n    {\n        return new SpeedyPipelineNodeResize(name);\n    }\n\n    /**\n     * Warp an image using a perspective transformation\n     * @param {string} [name]\n     * @returns {SpeedyPipelineNodeNormalize}\n     */\n    static PerspectiveWarp(name = undefined)\n    {\n        return new SpeedyPipelineNodePerspectiveWarp(name);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * convolution.js\n * Image convolution\n */\n\nimport { SpeedyPipelineNode } from '../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithImage } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { SpeedySize } from '../../../speedy-size';\nimport { Utils } from '../../../../utils/utils';\nimport { ImageFormat } from '../../../../utils/types';\nimport { NotSupportedError, IllegalArgumentError } from '../../../../utils/errors';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\nimport { SpeedyMatrix } from '../../../matrix/matrix';\nimport { MatrixShape } from '../../../matrix/matrix-shape';\nimport { SpeedyMatrixExpr, SpeedyMatrixElementaryExpr } from '../../../matrix/matrix-expressions';\n\n// 2D convolution programs\nconst CONVOLUTION = {\n    3: 'convolution3',\n    5: 'convolution5',\n    7: 'convolution7',\n};\n\n/**\n * Image convolution\n */\nexport class SpeedyPipelineNodeConvolution extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 0, [\n            InputPort().expects(SpeedyPipelineMessageType.Image),\n            OutputPort().expects(SpeedyPipelineMessageType.Image),\n        ]);\n\n\n        /** @type {SpeedyMatrixExpr} convolution kernel (square matrix) */\n        this._kernel = SpeedyMatrixExpr.create(3, 3, [0, 0, 0, 0, 1, 0, 0, 0, 0]); // identity transform\n    }\n\n    /**\n     * Convolution kernel\n     * @returns {SpeedyMatrixExpr}\n     */\n    get kernel()\n    {\n        return this._kernel;\n    }\n\n    /**\n     * Convolution kernel\n     * @param {SpeedyMatrixExpr} kernel\n     */\n    set kernel(kernel)\n    {\n        if(kernel.rows != kernel.columns)\n            throw new NotSupportedError(`Use a square kernel`);\n        else if(!(kernel.rows == 3 || kernel.rows == 5 || kernel.rows == 7))\n            throw new NotSupportedError(`Invalid kernel size. Supported sizes: 3x3, 5x5, 7x7`);\n\n        this._kernel = kernel;\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { image, format } = this.input().read();\n        const width = image.width, height = image.height;\n        const outputTexture = this._outputTexture;\n        const ksize = this._kernel.rows;\n        const conv = CONVOLUTION[ksize];\n\n        return this._kernel.read().then(kernel => {\n            (gpu.programs.filters[conv]\n                .outputs(width, height, outputTexture)\n            )(image, kernel);\n\n            this.output().swrite(outputTexture, format);\n        });\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * gaussian-blur.js\n * Gaussian Blur\n */\n\nimport { SpeedyPipelineNode } from '../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithImage } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { SpeedySize } from '../../../speedy-size';\nimport { SpeedyVector2 } from '../../../speedy-vector';\nimport { Utils } from '../../../../utils/utils';\nimport { ImageFormat } from '../../../../utils/types';\nimport { NotSupportedError, NotImplementedError, IllegalArgumentError } from '../../../../utils/errors';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\n\n// Default kernels for different sizes: 3x3, 5x5, 7x7... (use sigma_x = sigma_y)\n// Heuristics: in order to pick a sigma, we set radius = 2 * sigma. Since\n// ksize = 1 + 2 * radius, it follows that sigma = (ksize - 1) / 4. When\n// ksize is 3, we set sigma = 1. Therefore, sigma = max(1, (ksize - 1) / 4).\nconst DEFAULT_KERNEL = {\n    3: [ 0.27901008925473514, 0.44197982149052983, 0.27901008925473514 ], // 1D convolution (sigma = 1)\n    5: [ 0.06135959781344021, 0.2447701955296099, 0.3877404133138998, 0.2447701955296099, 0.06135959781344021 ], // 1D convolution (separable kernel)\n    7: [ 0.03873542500847274, 0.11308485700794121, 0.2150068609928349, 0.26634571398150225, 0.2150068609928349, 0.11308485700794121, 0.03873542500847274 ],\n    9: [ 0.028532262603370988, 0.067234535494912, 0.12400932997922749, 0.17904386461741617, 0.20236001461014655, 0.17904386461741617, 0.12400932997922749, 0.067234535494912, 0.028532262603370988 ],\n    11:[ 0.022656882730580346, 0.04610857898527292, 0.08012661469398517, 0.11890414969751599, 0.15067709325491124, 0.16305336127546846, 0.15067709325491124, 0.11890414969751599, 0.08012661469398517, 0.04610857898527292, 0.022656882730580346 ],\n    13:[ 0.018815730430644363, 0.03447396964662016, 0.05657737457255748, 0.08317258170844948, 0.10952340502389682, 0.12918787500405662, 0.13649812722755, 0.12918787500405662, 0.10952340502389682, 0.08317258170844948, 0.05657737457255748, 0.03447396964662016, 0.018815730430644363 ],\n    15:[ 0.016100340991695383, 0.027272329212157102, 0.042598338587449644, 0.06135478775568558, 0.08148767614129326, 0.09979838342934616, 0.11270444144735056, 0.11736740487004466, 0.11270444144735056, 0.09979838342934616, 0.08148767614129326, 0.06135478775568558, 0.042598338587449644, 0.027272329212157102, 0.016100340991695383 ],\n    //3: [ 0.25, 0.5, 0.25 ],\n    //5: [ 0.05, 0.25, 0.4, 0.25, 0.05 ],\n};\n\n// when we set sigma_x = sigma_y = 0, we use the above rule to compute sigma\nconst DEFAULT_SIGMA = new SpeedyVector2(0,0);\n\n// convolution programs (x-axis)\nconst CONVOLUTION_X = {\n    3: 'convolution3x',\n    5: 'convolution5x',\n    7: 'convolution7x',\n    9: 'convolution9x',\n    11: 'convolution11x',\n    13: 'convolution13x',\n    15: 'convolution15x',\n};\n\n// convolution programs (y-axis)\nconst CONVOLUTION_Y = {\n    3: 'convolution3y',\n    5: 'convolution5y',\n    7: 'convolution7y',\n    9: 'convolution9y',\n    11: 'convolution11y',\n    13: 'convolution13y',\n    15: 'convolution15y',\n};\n\n/**\n * Gaussian Blur\n */\nexport class SpeedyPipelineNodeGaussianBlur extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 1, [\n            InputPort().expects(SpeedyPipelineMessageType.Image),\n            OutputPort().expects(SpeedyPipelineMessageType.Image),\n        ]);\n\n        /** @type {SpeedySize} size of the kernel */\n        this._kernelSize = new SpeedySize(5,5);\n\n        /** @type {SpeedyVector2} sigma of the Gaussian kernel (0 means: use default settings) */\n        this._sigma = DEFAULT_SIGMA;\n\n        /** @type {Object.<string,number[]>} convolution kernel */\n        this._kernel = {\n            x: DEFAULT_KERNEL[this._kernelSize.width],\n            y: DEFAULT_KERNEL[this._kernelSize.height]\n        };\n    }\n\n    /**\n     * Size of the kernel\n     * @returns {SpeedySize}\n     */\n    get kernelSize()\n    {\n        return this._kernelSize;\n    }\n\n    /**\n     * Size of the kernel\n     * @param {SpeedySize} kernelSize\n     */\n    set kernelSize(kernelSize)\n    {\n        Utils.assert(kernelSize instanceof SpeedySize);\n\n        const kw = kernelSize.width, kh = kernelSize.height;\n        if(kw < 3 || kh < 3 || kw > 15 || kh > 15 || kw % 2 == 0 || kh % 2 == 0)\n            throw new NotSupportedError(`Unsupported kernel size: ${kw}x${kh}`);\n\n        this._kernelSize = kernelSize;\n        this._updateKernel();\n    }\n\n    /**\n     * Sigma of the Gaussian kernel\n     * @returns {SpeedyVector2}\n     */\n    get sigma()\n    {\n        return this._sigma;\n    }\n\n    /**\n     * Sigma of the Gaussian kernel\n     * @param {SpeedyVector2} sigma\n     */\n    set sigma(sigma)\n    {\n        Utils.assert(sigma instanceof SpeedyVector2, `Sigma must be a SpeedyVector2`);\n        Utils.assert(sigma.x >= 0 && sigma.y >= 0);\n\n        this._sigma = sigma;\n        this._updateKernel();\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { image, format } = this.input().read();\n        const width = image.width, height = image.height;\n        const outputTexture = this._outputTexture;\n        const kernX = this._kernel.x;\n        const kernY = this._kernel.y;\n        const convX = CONVOLUTION_X[this._kernelSize.width];\n        const convY = CONVOLUTION_Y[this._kernelSize.height];\n        const tex = this._tex[0];\n\n        (gpu.programs.filters[convX]\n            .outputs(width, height, tex)\n        )(image, kernX);\n\n        (gpu.programs.filters[convY]\n            .outputs(width, height, outputTexture)\n        )(tex, kernY);\n\n        this.output().swrite(outputTexture, format);\n    }\n\n    /**\n     * Update the internal kernel to match\n     * sigma and kernelSize\n     */\n    _updateKernel()\n    {\n        if(this._sigma.x == DEFAULT_SIGMA.x)\n            this._kernel.x = DEFAULT_KERNEL[this._kernelSize.width];\n        else\n            this._kernel.x = Utils.gaussianKernel(this._sigma.x, this._kernelSize.width, true);\n\n        if(this._sigma.y == DEFAULT_SIGMA.y)\n            this._kernel.y = DEFAULT_KERNEL[this._kernelSize.height];\n        else\n            this._kernel.y = Utils.gaussianKernel(this._sigma.y, this._kernelSize.height, true);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * greyscale.js\n * Convert an image to greyscale\n */\n\nimport { SpeedyPipelineNode } from '../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithImage } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { Utils } from '../../../../utils/utils';\nimport { ImageFormat } from '../../../../utils/types';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\n\n/**\n * Convert an image to greyscale\n */\nexport class SpeedyPipelineNodeGreyscale extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 0, [\n            InputPort().expects(SpeedyPipelineMessageType.Image),\n            OutputPort().expects(SpeedyPipelineMessageType.Image),\n        ]);\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { image } = this.input().read();\n        const width = image.width, height = image.height;\n        const outputTexture = this._outputTexture;\n\n        (gpu.programs.colors.rgb2grey\n            .outputs(width, height, outputTexture)\n        )(image);\n\n        this.output().swrite(outputTexture, ImageFormat.GREY);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * median-blur.js\n * Median Blur\n */\n\nimport { SpeedyPipelineNode } from '../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithImage } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { SpeedySize } from '../../../speedy-size';\nimport { Utils } from '../../../../utils/utils';\nimport { ImageFormat } from '../../../../utils/types';\nimport { NotSupportedError, NotImplementedError } from '../../../../utils/errors';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\n\n// Median programs\nconst MEDIAN = {\n    3: 'median3',\n    5: 'median5',\n    7: 'median7',\n};\n\n/**\n * Median Blur\n */\nexport class SpeedyPipelineNodeMedianBlur extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 0, [\n            InputPort().expects(SpeedyPipelineMessageType.Image).satisfying(\n                msg => msg.format === ImageFormat.GREY\n            ),\n            OutputPort().expects(SpeedyPipelineMessageType.Image),\n        ]);\n\n        /** @type {SpeedySize} size of the kernel (assumed to be square) */\n        this._kernelSize = new SpeedySize(5,5);\n    }\n\n    /**\n     * Size of the kernel\n     * @returns {SpeedySize}\n     */\n    get kernelSize()\n    {\n        return this._kernelSize;\n    }\n\n    /**\n     * Size of the kernel\n     * @param {SpeedySize} kernelSize\n     */\n    set kernelSize(kernelSize)\n    {\n        Utils.assert(kernelSize instanceof SpeedySize);\n\n        const ksize = kernelSize.width;\n        if(!(ksize == 3 || ksize == 5 || ksize == 7))\n            throw new NotSupportedError(`Supported kernel sizes: 3x3, 5x5, 7x7`);\n        else if(kernelSize.width != kernelSize.height)\n            throw new NotSupportedError(`Use a square kernel`);\n\n        this._kernelSize = kernelSize;\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { image, format } = this.input().read();\n        const width = image.width, height = image.height;\n        const outputTexture = this._outputTexture;\n        const ksize = this._kernelSize.width;\n        const med = MEDIAN[ksize];\n\n        (gpu.programs.filters[med]\n            .outputs(width, height, outputTexture)\n        )(image);\n\n        this.output().swrite(outputTexture, format);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * nightvision.js\n * Nightvision filter\n */\n\nimport { SpeedyPipelineNode } from '../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithImage } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { Utils } from '../../../../utils/utils';\nimport { IllegalArgumentError } from '../../../../utils/errors';\nimport { ImageFormat, PixelComponent, ColorComponentId } from '../../../../utils/types';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\n\n/**\n * @typedef {\"high\"|\"medium\"|\"low\"} NightvisionQualityLevel\n */\n\n/**\n * Nightvision filter: \"see in the dark\"\n */\nexport class SpeedyPipelineNodeNightvision extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 2, [\n            InputPort().expects(SpeedyPipelineMessageType.Image).satisfying(\n                msg => msg.format === ImageFormat.RGBA || msg.format === ImageFormat.GREY\n            ),\n            OutputPort().expects(SpeedyPipelineMessageType.Image),\n        ]);\n\n        /** @type {number} a value typically in [0,1]: larger number => higher contrast */\n        this._gain = 0.5;\n\n        /** @type {number} a value typically in [0,1]: controls brightness */\n        this._offset = 0.5;\n\n        /** @type {number} gain decay, a value in [0,1] */\n        this._decay = 0.0;\n\n        /** @type {NightvisionQualityLevel} quality level */\n        this._quality = 'medium';\n    }\n\n    /**\n     * Gain, a value typically in [0,1]: larger number => higher contrast\n     * @returns {number}\n     */\n    get gain()\n    {\n        return this._gain;\n    }\n\n    /**\n     * Gain, a value typically in [0,1]: larger number => higher contrast\n     * @param {number} gain\n     */\n    set gain(gain)\n    {\n        this._gain = +gain;\n    }\n\n    /**\n     * Offset, a value typically in [0,1] that controls the brightness\n     * @returns {number}\n     */\n    get offset()\n    {\n        return this._offset;\n    }\n\n    /**\n     * Offset, a value typically in [0,1] that controls the brightness\n     * @param {number} offset\n     */\n    set offset(offset)\n    {\n        this._offset = +offset;\n    }\n\n    /**\n     * Gain decay, a value in [0,1] that controls how the gain decays from the center of the image\n     * @returns {number}\n     */\n    get decay()\n    {\n        return this._decay;\n    }\n\n    /**\n     * Gain decay, a value in [0,1] that controls how the gain decays from the center of the image\n     * @param {number} decay\n     */\n    set decay(decay)\n    {\n        this._decay = Math.max(0.0, Math.min(+decay, 1.0));\n    }\n\n    /**\n     * Quality level of the filter\n     * @returns {NightvisionQualityLevel}\n     */\n    get quality()\n    {\n        return this._quality;\n    }\n\n    /**\n     * Quality level of the filter\n     * @param {NightvisionQualityLevel} quality\n     */\n    set quality(quality)\n    {\n        if(!(quality == 'high' || quality == 'medium' || quality == 'low'))\n            throw new IllegalArgumentError(`Invalid quality level for the Nightvision filter: \"${quality}\"`);\n\n        this._quality = String(quality);\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { image, format } = this.input().read();\n        const width = image.width, height = image.height;\n        const outputTexture = this._outputTexture;\n        const gain = this._gain;\n        const offset = this._offset;\n        const decay = this._decay;\n        const quality = this._quality;\n        const program = gpu.programs.enhancements;\n        const tmp = this._tex[0];\n        const illuminationMap = this._tex[1];\n\n        // compute illumination map\n        if(quality == 'medium') {\n            (program._illuminationMapX\n                .outputs(width, height, tmp)\n            )(image);\n\n            (program._illuminationMapY\n                .outputs(width, height, illuminationMap)\n            )(tmp);\n        }\n        else if(quality == 'high') {\n            (program._illuminationMapHiX\n                .outputs(width, height, tmp)\n            )(image);\n\n            (program._illuminationMapHiY\n                .outputs(width, height, illuminationMap)\n            )(tmp);\n        }\n        else if(quality == 'low') {\n            (program._illuminationMapLoX\n                .outputs(width, height, tmp)\n            )(image);\n\n            (program._illuminationMapLoY\n                .outputs(width, height, illuminationMap)\n            )(tmp);\n        }\n\n        // run nightvision\n        if(format === ImageFormat.GREY) {\n            (program._nightvisionGreyscale\n                .outputs(width, height, outputTexture)\n            )(image, illuminationMap, gain, offset, decay);\n        }\n        else if(format === ImageFormat.RGBA) {\n            (program._nightvision\n                .outputs(width, height, outputTexture)\n            )(image, illuminationMap, gain, offset, decay);\n        }\n\n        // done!\n        this.output().swrite(outputTexture, format);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * normalize.js\n * Normalize image to a range\n */\n\nimport { SpeedyPipelineNode } from '../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithImage } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { Utils } from '../../../../utils/utils';\nimport { ImageFormat, PixelComponent, ColorComponentId } from '../../../../utils/types';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\n\n/**\n * Normalize image to a range\n */\nexport class SpeedyPipelineNodeNormalize extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 3, [\n            InputPort().expects(SpeedyPipelineMessageType.Image).satisfying(\n                msg => msg.format === ImageFormat.GREY\n            ),\n            OutputPort().expects(SpeedyPipelineMessageType.Image),\n        ]);\n\n        /** @type {number} a value in [0,255] */\n        this._minValue = 0;\n\n        /** @type {number} a value in [0,255] */\n        this._maxValue = 255;\n    }\n\n    /**\n     * Minimum intensity in the output image, a value in [0,255]\n     * @returns {number}\n     */\n    get minValue()\n    {\n        return this._minValue;\n    }\n\n    /**\n     * Minimum intensity in the output image, a value in [0,255]\n     * @param {number} minValue\n     */\n    set minValue(minValue)\n    {\n        this._minValue = Math.max(0, Math.min(+minValue, 255));\n    }\n\n    /**\n     * Maximum intensity in the output image, a value in [0,255]\n     * @returns {number}\n     */\n    get maxValue()\n    {\n        return this._maxValue;\n    }\n\n    /**\n     * Maximum intensity in the output image, a value in [0,255]\n     * @param {number} maxValue\n     */\n    set maxValue(maxValue)\n    {\n        this._maxValue = Math.max(0, Math.min(+maxValue, 255));\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { image, format } = this.input().read();\n        const width = image.width, height = image.height;\n        const outputTexture = this._outputTexture;\n        let minValue = this._minValue;\n        let maxValue = this._maxValue;\n\n        if(minValue > maxValue)\n            minValue = maxValue = (minValue + maxValue) / 2;\n\n        const minmax = this._scanMinMax(gpu, image, PixelComponent.GREEN);\n\n        (gpu.programs.enhancements._normalizeGreyscaleImage\n            .outputs(width, height, outputTexture)\n        )(minmax, minValue, maxValue);\n\n        this.output().swrite(outputTexture, format);\n    }\n\n    /**\n     * Scan a single component in all pixels of the image and find the min & max intensities\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} image input image\n     * @param {PixelComponent} pixelComponent a single PixelComponent flag\n     * @returns {SpeedyDrawableTexture} RGBA = (max, min, max - min, original_pixel)\n     */\n    _scanMinMax(gpu, image, pixelComponent)\n    {\n        const tex = this._tex;\n        const program = gpu.programs.utils;\n        const width = image.width, height = image.height;\n        const numIterations = Math.ceil(Math.log2(Math.max(width, height))) | 0;\n\n        Utils.assert(ColorComponentId[pixelComponent] !== undefined);\n\n        program._copyComponents.outputs(width, height, tex[2]);\n        program._scanMinMax2D.outputs(width, height, tex[0], tex[1]);\n        \n        let texture = program._copyComponents(image, image, PixelComponent.ALL, ColorComponentId[pixelComponent]);\n        for(let i = 0; i < numIterations; i++)\n            texture = program._scanMinMax2D(texture, i);\n\n        return texture;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * simple-blur.js\n * Simple Blur (Box Filter)\n */\n\nimport { SpeedyPipelineNode } from '../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithImage } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { SpeedySize } from '../../../speedy-size';\nimport { Utils } from '../../../../utils/utils';\nimport { ImageFormat } from '../../../../utils/types';\nimport { NotSupportedError, NotImplementedError } from '../../../../utils/errors';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\n\n// 1D convolution filters\nconst BOX_FILTER = {\n    3: (new Array(3)).fill(1/3),\n    5: (new Array(5)).fill(1/5),\n    7: (new Array(7)).fill(1/7),\n    9: (new Array(9)).fill(1/9),\n    11: (new Array(11)).fill(1/11),\n    13: (new Array(13)).fill(1/13),\n    15: (new Array(15)).fill(1/15),\n};\n\n// convolution programs (x-axis)\nconst CONVOLUTION_X = {\n    3: 'convolution3x',\n    5: 'convolution5x',\n    7: 'convolution7x',\n    9: 'convolution9x',\n    11: 'convolution11x',\n    13: 'convolution13x',\n    15: 'convolution15x',\n};\n\n// convolution programs (y-axis)\nconst CONVOLUTION_Y = {\n    3: 'convolution3y',\n    5: 'convolution5y',\n    7: 'convolution7y',\n    9: 'convolution9y',\n    11: 'convolution11y',\n    13: 'convolution13y',\n    15: 'convolution15y',\n};\n\n/**\n * Simple Blur (Box Filter)\n */\nexport class SpeedyPipelineNodeSimpleBlur extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 1, [\n            InputPort().expects(SpeedyPipelineMessageType.Image),\n            OutputPort().expects(SpeedyPipelineMessageType.Image),\n        ]);\n\n        /** @type {SpeedySize} size of the kernel */\n        this._kernelSize = new SpeedySize(5,5);\n\n        /** @type {Object.<string,number[]>} convolution kernel */\n        this._kernel = {\n            x: BOX_FILTER[this._kernelSize.width],\n            y: BOX_FILTER[this._kernelSize.height]\n        };\n    }\n\n    /**\n     * Size of the kernel\n     * @returns {SpeedySize}\n     */\n    get kernelSize()\n    {\n        return this._kernelSize;\n    }\n\n    /**\n     * Size of the kernel\n     * @param {SpeedySize} kernelSize\n     */\n    set kernelSize(kernelSize)\n    {\n        Utils.assert(kernelSize instanceof SpeedySize);\n\n        const kw = kernelSize.width, kh = kernelSize.height;\n        if(kw < 3 || kh < 3 || kw > 15 || kh > 15 || kw % 2 == 0 || kh % 2 == 0)\n            throw new NotSupportedError(`Unsupported kernel size: ${kw}x${kh}`);\n\n        this._kernelSize = kernelSize;\n        this._kernel.x = BOX_FILTER[this._kernelSize.width];\n        this._kernel.y = BOX_FILTER[this._kernelSize.height];\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { image, format } = this.input().read();\n        const width = image.width, height = image.height;\n        const outputTexture = this._outputTexture;\n        const kernX = this._kernel.x;\n        const kernY = this._kernel.y;\n        const convX = CONVOLUTION_X[this._kernelSize.width];\n        const convY = CONVOLUTION_Y[this._kernelSize.height];\n        const tex = this._tex[0];\n\n        (gpu.programs.filters[convX]\n            .outputs(width, height, tex)\n        )(image, kernX);\n\n        (gpu.programs.filters[convY]\n            .outputs(width, height, outputTexture)\n        )(tex, kernY);\n\n        this.output().swrite(outputTexture, format);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * buffer.js\n * Image Buffer\n */\n\nimport { SpeedyPipelineNode } from '../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithImage } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { ImageFormat } from '../../../../utils/types';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { Utils } from '../../../../utils/utils';\nimport { NotSupportedError } from '../../../../utils/errors';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\n\n\n\n/**\n * Image Buffer: a node with memory.\n * At time t, it outputs the image received at time t-1\n */\nexport class SpeedyPipelineNodeImageBuffer extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 2, [\n            InputPort().expects(SpeedyPipelineMessageType.Image),\n            OutputPort().expects(SpeedyPipelineMessageType.Image)\n        ]);\n\n        /** @type {number} current page: 0 or 1 */\n        this._pageIndex = 0;\n\n        /** @type {boolean} first run? */\n        this._initialized = false;\n\n        /** @type {ImageFormat} previous image format */\n        this._previousFormat = ImageFormat.RGBA;\n    }\n\n    /**\n     * Releases this node\n     * @param {SpeedyGPU} gpu\n     */\n    release(gpu)\n    {\n        this._initialized = false;\n        super.release(gpu);\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { image, format } = this.input().read();\n        const previousFormat = this._previousFormat;\n        const page = this._tex;\n        const previousInputTexture = page[1 - this._pageIndex];\n        const outputTexture = page[this._pageIndex];\n\n        // can't store pyramids\n        if(image.hasMipmaps())\n            throw new NotSupportedError(`Can't bufferize a pyramid`);\n\n        // store input\n        this._previousFormat = format;\n        previousInputTexture.resize(image.width, image.height);\n        image.copyTo(previousInputTexture);\n\n        // page flipping\n        this._pageIndex = 1 - this._pageIndex;\n\n        // first run?\n        if(!this._initialized) {\n            this._initialized = true;\n            this.output().swrite(previousInputTexture, format);\n            return;\n        }\n\n        // done!\n        this.output().swrite(outputTexture, previousFormat);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * image-multiplexer.js\n * Image multiplexer\n */\n\nimport { SpeedyPipelineNode, SpeedyPipelineSourceNode } from '../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithImage } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { SpeedyMedia } from '../../../speedy-media';\nimport { Utils } from '../../../../utils/utils';\nimport { IllegalArgumentError } from '../../../../utils/errors';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\n\n/**\n * @typedef {0|1} ImageMultiplexerPortNumber\n */\n\n/** @type {string[]} the names of the input ports indexed by their number */\nconst INPUT_PORT = [ 'in0', 'in1' ];\n\n/**\n * Image multiplexer\n */\nexport class SpeedyPipelineNodeImageMultiplexer extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 0, [\n            ...(INPUT_PORT.map(portName => InputPort(portName).expects(SpeedyPipelineMessageType.Image))),\n            OutputPort().expects(SpeedyPipelineMessageType.Image),\n        ]);\n\n        /** @type {ImageMultiplexerPortNumber} which port should be linked to the output? */\n        this._port = 0;\n    }\n\n    /**\n     * The number of the port that should be linked to the output\n     * @returns {ImageMultiplexerPortNumber}\n     */\n    get port()\n    {\n        return this._port;\n    }\n\n    /**\n     * The number of the port that should be linked to the output\n     * @param {ImageMultiplexerPortNumber} port\n     */\n    set port(port)\n    {\n        if(port < 0 || port >= INPUT_PORT.length)\n            throw new IllegalArgumentError(`Invalid port: ${port}`);\n\n        this._port = port | 0;\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const message = this.input(INPUT_PORT[this._port]).read();\n\n        this.output().write(message);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * pyramid.js\n * Generate pyramid\n */\n\nimport { SpeedyPipelineNode } from '../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithImage } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { Utils } from '../../../../utils/utils';\nimport { PYRAMID_MAX_LEVELS } from '../../../../utils/globals';\nimport { ImageFormat } from '../../../../utils/types';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\n\n// Constants\nconst MAX_LEVELS = PYRAMID_MAX_LEVELS;\nconst MAX_TEXTURES = 2 * MAX_LEVELS - 1;\n\n/**\n * Generate pyramid\n */\nexport class SpeedyPipelineNodeImagePyramid extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, MAX_TEXTURES, [\n            InputPort().expects(SpeedyPipelineMessageType.Image),\n            OutputPort().expects(SpeedyPipelineMessageType.Image),\n        ]);\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { image, format } = this.input().read();\n        const outputTexture = this._outputTexture;\n        const pyramids = gpu.programs.pyramids(0);\n        let width = image.width, height = image.height;\n\n        // number of mipmap images according to the OpenGL ES 3.0 spec (sec 3.8.10.4)\n        const mipLevels = 1 + Math.floor(Math.log2(Math.max(width, height)));\n\n        // get work textures\n        const mip = new Array(MAX_TEXTURES + 1);\n        for(let i = 0; i < MAX_TEXTURES; i++)\n            mip[i+1] = this._tex[i];\n        mip[0] = image;\n\n        // generate gaussian pyramid\n        const numLevels = Math.min(mipLevels, MAX_LEVELS);\n        for(let level = 1; level < numLevels; level++) {\n            // use max(1, floor(size / 2^lod)), in accordance to\n            // the OpenGL ES 3.0 spec sec 3.8.10.4 (Mipmapping)\n            const halfWidth = Math.max(1, width >>> 1);\n            const halfHeight = Math.max(1, height >>> 1);\n\n            // reduce operation\n            const tmp = (level - 1) + MAX_LEVELS;\n            (pyramids.smoothX.outputs(width, height, mip[tmp]))(mip[level-1]);\n            (pyramids.smoothY.outputs(width, height, mip[level-1]))(mip[tmp]);\n            (pyramids.downsample2.outputs(halfWidth, halfHeight, mip[level]))(mip[level-1]);\n\n            // next level\n            width = halfWidth;\n            height = halfHeight;\n        }\n\n        // copy to output & set mipmap\n        outputTexture.resize(image.width, image.height);\n        image.copyTo(outputTexture);\n        outputTexture.generateMipmaps(mip.slice(0, numLevels));\n\n        // done!\n        this.output().swrite(outputTexture, format);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * image-output.js\n * Gets an image out of a pipeline\n */\n\nimport { SpeedyPipelineNode, SpeedyPipelineSinkNode } from '../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithImage } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { SpeedyMedia } from '../../../speedy-media';\nimport { SpeedyMediaSource } from '../../../speedy-media-source';\nimport { Utils } from '../../../../utils/utils';\nimport { ImageFormat } from '../../../../utils/types';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\n\n/**\n * Gets an image out of a pipeline\n */\nexport class SpeedyPipelineNodeImageSink extends SpeedyPipelineSinkNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = 'image')\n    {\n        super(name, 0, [\n            InputPort().expects(SpeedyPipelineMessageType.Image)\n        ]);\n\n        /** @type {ImageBitmap} output bitmap */\n        this._bitmap = null;\n\n        /** @type {ImageFormat} output format */\n        this._format = ImageFormat.RGBA;\n    }\n\n    /**\n     * Export data from this node to the user\n     * @returns {SpeedyPromise<any>}\n     */\n    export()\n    {\n        Utils.assert(this._bitmap != null);\n\n        return SpeedyMediaSource.load(this._bitmap).then(source =>\n            new SpeedyMedia(source, { lightweight: 1 /* FIXME */ }) //, this._format ?\n        );\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { image, format } = this.input().read();\n\n        return new SpeedyPromise(resolve => {\n            const canvas = gpu.renderToCanvas(image);\n            createImageBitmap(canvas, 0, canvas.height - image.height, image.width, image.height).then(bitmap => {\n                this._bitmap = bitmap;\n                this._format = format;\n                resolve();\n            });\n        });\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * image-input.js\n * Gets an image into a pipeline\n */\n\nimport { SpeedyPipelineNode, SpeedyPipelineSourceNode } from '../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithImage } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { SpeedyMedia } from '../../../speedy-media';\nimport { Utils } from '../../../../utils/utils';\nimport { ImageFormat } from '../../../../utils/types';\nimport { IllegalOperationError } from '../../../../utils/errors';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\n\n/**\n * Gets an image into a pipeline\n */\nexport class SpeedyPipelineNodeImageSource extends SpeedyPipelineSourceNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 0, [\n            OutputPort().expects(SpeedyPipelineMessageType.Image)\n        ]);\n\n        /** @type {SpeedyMedia} source media */\n        this._media = null;\n    }\n\n    /**\n     * Source media\n     * @returns {SpeedyMedia}\n     */\n    get media()\n    {\n        return this._media;\n    }\n\n    /**\n     * Source media\n     * @param {SpeedyMedia} media\n     */\n    set media(media)\n    {\n        Utils.assert(media instanceof SpeedyMedia);\n        this._media = media;\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        gpu.upload(this._media._source, this._outputTexture);\n\n        this.output().swrite(this._outputTexture, ImageFormat.RGBA);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * buffer.js\n * Keypoint Buffer\n */\n\nimport { SpeedyPipelineNode } from '../../pipeline-node';\nimport { SpeedyPipelineNodeKeypointDetector } from './detectors/detector';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithKeypoints } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { Utils } from '../../../../utils/utils';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\n\n\n\n/**\n * Keypoint Buffer: a node with memory.\n * At time t, it outputs the keypoints received at time t-1\n */\nexport class SpeedyPipelineNodeKeypointBuffer extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 2, [\n            InputPort().expects(SpeedyPipelineMessageType.Keypoints),\n            OutputPort().expects(SpeedyPipelineMessageType.Keypoints)\n        ]);\n\n        /** @type {number} current page: 0 or 1 */\n        this._pageIndex = 0;\n\n        /** @type {boolean} first run? */\n        this._initialized = false;\n\n        /** @type {number} previous descriptor size, in bytes */\n        this._previousDescriptorSize = 0;\n\n        /** @type {number} previous extra size, in bytes */\n        this._previousExtraSize = 0;\n\n        /** @type {number} previous encoder length */\n        this._previousEncoderLength = 0;\n    }\n\n    /**\n     * Releases this node\n     * @param {SpeedyGPU} gpu\n     */\n    release(gpu)\n    {\n        this._initialized = false;\n        super.release(gpu);\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { encodedKeypoints, descriptorSize, extraSize, encoderLength } = this.input().read();\n        const previousDescriptorSize = this._previousDescriptorSize;\n        const previousExtraSize = this._previousExtraSize;\n        const previousEncoderLength = this._previousEncoderLength;\n        const page = this._tex;\n        const previousInputTexture = page[1 - this._pageIndex];\n        const outputTexture = page[this._pageIndex];\n\n        // store input\n        this._previousDescriptorSize = descriptorSize;\n        this._previousExtraSize = extraSize;\n        this._previousEncoderLength = encoderLength;\n        previousInputTexture.resize(encoderLength, encoderLength);\n        encodedKeypoints.copyTo(previousInputTexture);\n\n        // page flipping\n        this._pageIndex = 1 - this._pageIndex;\n\n        // first run?\n        if(!this._initialized) {\n            this._initialized = true;\n            this.output().swrite(previousInputTexture, descriptorSize, extraSize, encoderLength);\n            return;\n        }\n\n        // done!\n        this.output().swrite(outputTexture, previousDescriptorSize, previousExtraSize, previousEncoderLength);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * clipper.js\n * Keypoint clipper\n */\n\nimport { SpeedyPipelineNode, SpeedyPipelineSinkNode } from '../../pipeline-node';\nimport { SpeedyPipelineNodeKeypointDetector } from './detectors/detector';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithImage } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTextureReader } from '../../../../gpu/speedy-texture-reader';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { Utils } from '../../../../utils/utils';\nimport { IllegalOperationError } from '../../../../utils/errors';\nimport { MAX_ENCODER_CAPACITY } from '../../../../utils/globals';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\n\n\n// Constants\nconst LOG2_STRIDE = 5;\nconst MAX_SIZE = MAX_ENCODER_CAPACITY;\n\n\n\n/**\n * Keypoint clipper: filters the best keypoints from a stream\n */\nexport class SpeedyPipelineNodeKeypointClipper extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 3, [\n            InputPort().expects(SpeedyPipelineMessageType.Keypoints).satisfying(\n                msg => msg.descriptorSize == 0 && msg.extraSize == 0\n            ),\n            OutputPort().expects(SpeedyPipelineMessageType.Keypoints)\n        ]);\n\n        /** @type {number} the maximum number of keypoints in the output */\n        this._size = MAX_SIZE;\n    }\n\n    /**\n     * The maximum number of keypoints in the output\n     * @returns {number}\n     */\n    get size()\n    {\n        return this._size;\n    }\n\n    /**\n     * The maximum number of keypoints in the output\n     * @param {number} size\n     */\n    set size(size)\n    {\n        this._size = Math.max(0, Math.min(size | 0, MAX_SIZE));\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { encodedKeypoints, descriptorSize, extraSize, encoderLength } = this.input().read();\n        const keypoints = gpu.programs.keypoints;\n        const outputTexture = this._outputTexture;\n        const clipValue = this._size;\n        const tex = this._tex;\n\n        // find the minimum power of 2 pot such that pot >= capacity\n        const capacity = SpeedyPipelineNodeKeypointDetector.encoderCapacity(descriptorSize, extraSize, encoderLength);\n        //const pot = 1 << (Math.ceil(Math.log2(capacity)) | 0);\n\n        // find the dimensions of the sorting shaders\n        const stride = 1 << LOG2_STRIDE; // must be a power of 2\n        //const height = Math.max(1, pot >>> LOG2_STRIDE); // this is also a power of 2\n        const height = Math.ceil(capacity / stride); // more economical, maybe not a power of 2\n        const numberOfPixels = stride * height;\n\n        // find the dimensions of the output texture\n        const newCapacity = Math.min(capacity, clipValue);\n        const newEncoderLength = SpeedyPipelineNodeKeypointDetector.encoderLength(newCapacity, descriptorSize, extraSize);\n\n        // generate permutation of keypoints\n        keypoints.sortCreatePermutation.outputs(stride, height, tex[0]);\n        let permutation = keypoints.sortCreatePermutation(encodedKeypoints, descriptorSize, extraSize, encoderLength);\n\n        // sort permutation\n        const numPasses = Math.ceil(Math.log2(numberOfPixels));\n        keypoints.sortMergePermutation.outputs(stride, height, tex[1], tex[2]);\n        for(let i = 1; i <= numPasses; i++) {\n            const blockSize = 1 << i; // 2, 4, 8...\n            const dblLog2BlockSize = i << 1; // 2 * log2(blockSize)\n            permutation = keypoints.sortMergePermutation(permutation, blockSize, dblLog2BlockSize);\n        }\n\n        // apply permutation\n        keypoints.sortApplyPermutation.outputs(newEncoderLength, newEncoderLength, outputTexture);\n        keypoints.sortApplyPermutation(permutation, newCapacity, encodedKeypoints, descriptorSize, extraSize);\n\n        /*\n        // debug (read the contents of the permutation)\n        this._textureReader = this._textureReader || new SpeedyTextureReader();\n        const debug = [];\n        const pixels = this._textureReader.readPixelsSync(permutation);\n        for(let i = 0; i < pixels.length; i += 4) {\n            let id = pixels[i] | (pixels[i+1] << 8);\n            let score = pixels[i+2] / 255.0;\n            let valid = pixels[i+3] / 255.0;\n            debug.push([ id, valid, score, ].join(', '));\n        }\n        console.log(debug);\n        */\n\n        // done!\n        this.output().swrite(outputTexture, descriptorSize, extraSize, newEncoderLength);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * descriptor.js\n * Abstract keypoint descriptor\n */\n\nimport { SpeedyPipelineNode } from '../../../pipeline-node';\nimport { SpeedyPipelinePortBuilder } from '../../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../../gpu/speedy-gpu';\nimport { SpeedyTexture, SpeedyDrawableTexture } from '../../../../../gpu/speedy-texture';\nimport { SpeedyPipelineNodeKeypointDetector } from '../detectors/detector';\nimport { Utils } from '../../../../../utils/utils';\n\n/**\n * Abstract keypoint descriptor\n * @abstract\n */\nexport class SpeedyPipelineNodeKeypointDescriptor extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     * @param {number} [texCount] number of internal work textures\n     * @param {SpeedyPipelinePortBuilder[]} [portBuilders] port builders\n     */\n    constructor(name = undefined, texCount = 0, portBuilders = undefined)\n    {\n        super(name, texCount + 1, portBuilders);\n    }\n\n    /**\n     * \n     * Allocate space for keypoint descriptors\n     * @param {SpeedyGPU} gpu\n     * @param {number} inputDescriptorSize must be 0\n     * @param {number} inputExtraSize must be 0\n     * @param {number} outputDescriptorSize in bytes, must be positive\n     * @param {number} outputExtraSize must be inputExtraSize\n     * @param {SpeedyTexture} inputEncodedKeypoints input with no descriptors\n     * @returns {SpeedyDrawableTexture} encodedKeypoints\n     */\n    _allocateSpaceForTheDescriptors(gpu, inputDescriptorSize, inputExtraSize, outputDescriptorSize, outputExtraSize, inputEncodedKeypoints)\n    {\n        Utils.assert(inputDescriptorSize === 0 && inputExtraSize === 0);\n        Utils.assert(outputDescriptorSize > 0 && outputExtraSize === inputExtraSize);\n\n        const inputEncoderLength = inputEncodedKeypoints.width;\n        const inputEncoderCapacity = SpeedyPipelineNodeKeypointDetector.encoderCapacity(inputDescriptorSize, inputExtraSize, inputEncoderLength);\n        const outputEncoderCapacity = inputEncoderCapacity;\n        const outputEncoderLength = SpeedyPipelineNodeKeypointDetector.encoderLength(outputEncoderCapacity, outputDescriptorSize, outputExtraSize);\n\n        const tex = this._tex[this._tex.length - 1];\n        return (gpu.programs.keypoints.expandEncoder\n            .outputs(outputEncoderLength, outputEncoderLength, tex)\n        )(inputEncodedKeypoints, inputDescriptorSize, inputExtraSize, inputEncoderLength, outputDescriptorSize, outputExtraSize, outputEncoderLength);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * orb.js\n * ORB descriptors\n */\n\nimport { SpeedyPipelineNode } from '../../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithImage, SpeedyPipelineMessageWithKeypoints } from '../../../pipeline-message';\nimport { InputPort, OutputPort } from '../../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../../gpu/speedy-gpu';\nimport { SpeedyTexture, SpeedyDrawableTexture } from '../../../../../gpu/speedy-texture';\nimport { ImageFormat } from '../../../../../utils/types';\nimport { Utils } from '../../../../../utils/utils';\nimport { SpeedyPromise } from '../../../../../utils/speedy-promise';\nimport { SpeedyPipelineNodeKeypointDetector } from '../detectors/detector';\nimport { SpeedyPipelineNodeKeypointDescriptor } from './descriptor';\n\n// Constants\nconst DESCRIPTOR_SIZE = 32; // 256 bits\n\n/**\n * ORB descriptors\n */\nexport class SpeedyPipelineNodeORBKeypointDescriptor extends SpeedyPipelineNodeKeypointDescriptor\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 2, [\n            InputPort('image').expects(SpeedyPipelineMessageType.Image).satisfying(\n                msg => msg.format === ImageFormat.GREY && msg.image.hasMipmaps()\n            ),\n            InputPort('keypoints').expects(SpeedyPipelineMessageType.Keypoints).satisfying(\n                msg => msg.descriptorSize == 0 && msg.extraSize == 0\n            ),\n            OutputPort().expects(SpeedyPipelineMessageType.Keypoints),\n        ]);\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { encodedKeypoints, descriptorSize, extraSize, encoderLength } = this.input('keypoints').read();\n        const pyramid = this.input('image').read().image;\n        const outputTexture = this._outputTexture;\n        const tex = this._tex;\n\n        // compute orientation\n        const capacity = SpeedyPipelineNodeKeypointDetector.encoderCapacity(descriptorSize, extraSize, encoderLength);\n        const orientationEncoderLength = Math.max(1, Math.ceil(Math.sqrt(capacity))); // 1 pixel per keypoint\n        const encodedOrientations = (gpu.programs.keypoints.orbOrientation\n            .outputs(orientationEncoderLength, orientationEncoderLength, tex[0])\n        )(pyramid, encodedKeypoints, descriptorSize, extraSize, encoderLength);\n        const orientedKeypoints = (gpu.programs.keypoints.transferOrientation\n            .outputs(encoderLength, encoderLength, tex[1])\n        )(encodedOrientations, encodedKeypoints, descriptorSize, extraSize, encoderLength);\n\n        // allocate space\n        const encodedKps = this._allocateSpaceForTheDescriptors(gpu, descriptorSize, extraSize, DESCRIPTOR_SIZE, extraSize, orientedKeypoints);\n        const newEncoderLength = encodedKps.width;\n\n        // compute descriptors (it's a good idea to blur the pyramid)\n        const describedKeypoints = (gpu.programs.keypoints.orbDescriptor\n            .outputs(newEncoderLength, newEncoderLength, outputTexture)\n        )(pyramid, encodedKps, extraSize, newEncoderLength);\n\n        // done!\n        this.output().swrite(describedKeypoints, DESCRIPTOR_SIZE, extraSize, newEncoderLength);\n    }\n}\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * detector.js\n * Abstract keypoint detectors\n */\n\nimport { SpeedyPipelineNode } from '../../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithKeypoints } from '../../../pipeline-message';\nimport { SpeedyPipelinePortBuilder } from '../../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../../gpu/speedy-gpu';\nimport { SpeedyTexture, SpeedyDrawableTexture } from '../../../../../gpu/speedy-texture';\nimport { Utils } from '../../../../../utils/utils';\nimport { SpeedyPromise } from '../../../../../utils/speedy-promise';\nimport { MIN_KEYPOINT_SIZE, MIN_ENCODER_LENGTH, MAX_ENCODER_CAPACITY } from '../../../../../utils/globals';\n\n// Constants\nconst ENCODER_PASSES = 8; // number of passes of the keypoint encoder: directly impacts performance\nconst LONG_SKIP_OFFSET_PASSES = 2; // number of passes of the long skip offsets shader\nconst MAX_CAPACITY = MAX_ENCODER_CAPACITY; // maximum capacity of the encoder (up to this many keypoints can be stored)\nconst DEFAULT_CAPACITY = 2048; // default capacity of the encoder (64x64 texture with 2 pixels per keypoint)\nconst DEFAULT_SCALE_FACTOR = 1.4142135623730951; // sqrt(2)\n\n/**\n * Abstract keypoint detector\n * @abstract\n */\nexport class SpeedyPipelineNodeKeypointDetector extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     * @param {number} [texCount] number of internal work textures\n     * @param {SpeedyPipelinePortBuilder[]} [portBuilders] port builders\n     */\n    constructor(name = undefined, texCount = 0, portBuilders = undefined)\n    {\n        super(name, texCount + 4, portBuilders);\n\n        /** @type {number} encoder capacity */\n        this._capacity = DEFAULT_CAPACITY; // must not be greater than MAX_ENCODER_CAPACITY\n    }\n\n    /**\n     * We can encode up to this many keypoints. If you find a\n     * tight bound for this, download times will be faster.\n     * @returns {number}\n     */\n    get capacity()\n    {\n        return this._capacity;\n    }\n\n    /**\n     * We can encode up to this many keypoints. If you find a\n     * tight bound for this, download times will be faster.\n     * @param {number} capacity\n     */\n    set capacity(capacity)\n    {\n        this._capacity = Math.min(Math.max(0, capacity | 0), MAX_CAPACITY);\n    }\n\n    /**\n     * Create a tiny texture with encoded keypoints out of\n     * an encoded corners texture\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} corners input\n     * @param {SpeedyDrawableTexture} encodedKeypoints output\n     * @returns {SpeedyDrawableTexture} encodedKeypoints\n     */\n    _encodeKeypoints(gpu, corners, encodedKeypoints)\n    {\n        const capacity = this._capacity;\n        const encoderLength = SpeedyPipelineNodeKeypointDetector.encoderLength(capacity, 0, 0);\n        const width = corners.width, height = corners.height;\n        const imageSize = [ width, height ];\n        const tex = this._tex.slice(this._tex.length - 4);\n        const encoders = gpu.programs.encoders;\n\n        // prepare programs\n        encoders._encodeKeypointSkipOffsets.outputs(width, height, tex[0]);\n        encoders._encodeKeypointLongSkipOffsets.outputs(width, height, tex[1], tex[0]);\n        encoders._encodeKeypoints.outputs(encoderLength, encoderLength, tex[2], tex[3]);\n\n        // encode skip offsets\n        let offsets = encoders._encodeKeypointSkipOffsets(corners, imageSize);\n        for(let i = 0; i < LONG_SKIP_OFFSET_PASSES; i++) // to boost performance\n            offsets = encoders._encodeKeypointLongSkipOffsets(offsets, imageSize);\n\n        /*\n        // debug: view corners\n        let cornerview = offsets;\n        gpu.programs.utils.fillComponents.outputs(width,height,null);\n        gpu.programs.utils.identity.outputs(width,height,null);\n        cornerview = gpu.programs.utils.fillComponents(cornerview, PixelComponent.GREEN, 0);\n        cornerview = gpu.programs.utils.identity(cornerview);\n        cornerview = gpu.programs.utils.fillComponents(cornerview, PixelComponent.RED, 0);\n        cornerview = gpu.programs.utils.identity(cornerview);\n        cornerview = gpu.programs.utils.fillComponents(cornerview, PixelComponent.ALPHA, 1);\n        const canvas = gpu.renderToCanvas(cornerview);\n        if(!window._ww) document.body.appendChild(canvas);\n        window._ww = 1;\n        */\n\n        // encode keypoints\n        const numPasses = ENCODER_PASSES;\n        let encodedKps = tex[3].clear();\n        for(let passId = 0; passId < numPasses; passId++)\n            encodedKps = encoders._encodeKeypoints(offsets, imageSize, passId, numPasses, capacity, encodedKps, 0, 0, encoderLength);\n\n        // write to encodedKeypoints\n        encodedKeypoints.resize(encoderLength, encoderLength);\n        encodedKps.copyTo(encodedKeypoints);\n\n        // done!\n        return encodedKeypoints;\n    }\n\n    /**\n     * Create a tiny texture with zero encoded keypoints\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyDrawableTexture} encodedKeypoints output texture\n     * @returns {SpeedyDrawableTexture} encodedKeypoints\n     */\n    _encodeZeroKeypoints(gpu, encodedKeypoints)\n    {\n        const capacity = 0;\n        const encoderLength = SpeedyPipelineNodeKeypointDetector.encoderLength(capacity, 0, 0);\n        const program = gpu.programs.encoders;\n\n        program._encodeNullKeypoints.outputs(encoderLength, encoderLength, encodedKeypoints);\n        program._encodeNullKeypoints();\n\n        return encodedKeypoints;\n    }\n\n    /**\n     * Compute the length of the keypoint encoder, given its capacity\n     * @param {number} encoderCapacity how many keypoints can we fit?\n     * @param {number} descriptorSize in bytes\n     * @param {number} extraSize in bytes\n     */\n    static encoderLength(encoderCapacity, descriptorSize, extraSize)\n    {\n        const pixelsPerKeypoint = Math.ceil((MIN_KEYPOINT_SIZE + descriptorSize + extraSize) / 4);\n        const numberOfPixels = encoderCapacity * pixelsPerKeypoint;\n\n        return Math.max(MIN_ENCODER_LENGTH, Math.ceil(Math.sqrt(numberOfPixels)));\n    }\n\n    /**\n     * The maximum number of keypoints we can store using\n     * a particular configuration of a keypoint encoder\n     * @param {number} descriptorSize in bytes\n     * @param {number} extraSize in bytes\n     * @param {number} encoderLength\n     */\n    static encoderCapacity(descriptorSize, extraSize, encoderLength)\n    {\n        const pixelsPerKeypoint = Math.ceil((MIN_KEYPOINT_SIZE + descriptorSize + extraSize) / 4);\n        const numberOfPixels = encoderLength * encoderLength;\n\n        return Math.floor(numberOfPixels / pixelsPerKeypoint);\n    }\n}\n\n/**\n * Abstract scale-space keypoint detector\n * @abstract\n */\nexport class SpeedyPipelineNodeMultiscaleKeypointDetector extends SpeedyPipelineNodeKeypointDetector\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     * @param {number} [texCount] number of internal work textures\n     * @param {SpeedyPipelinePortBuilder[]} [portBuilders] port builders\n     */\n    constructor(name = undefined, texCount = undefined, portBuilders = undefined)\n    {\n        super(name, texCount, portBuilders);\n\n        /** @type {number} number of pyramid levels */\n        this._levels = 1;\n\n        /** @type {number} scale factor between two pyramid levels */\n        this._scaleFactor = DEFAULT_SCALE_FACTOR;\n    }\n\n    /**\n     * Number of pyramid levels\n     * @returns {number}\n     */\n    get levels()\n    {\n        return this._levels;\n    }\n\n    /**\n     * Number of pyramid levels\n     * @param {number} levels\n     */\n    set levels(levels)\n    {\n        this._levels = Math.max(1, levels | 0);\n    }\n\n    /**\n     * Scale factor between two pyramid levels\n     * @returns {number}\n     */\n    get scaleFactor()\n    {\n        return this._scaleFactor;\n    }\n\n    /**\n     * Scale factor between two pyramid levels\n     * @param {number} scaleFactor should be greater than 1\n     */\n    set scaleFactor(scaleFactor)\n    {\n        this._scaleFactor = Math.max(1.0, Math.min(+scaleFactor, 2.0));\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * fast.js\n * FAST corner detector\n */\n\nimport { SpeedyPipelineNodeMultiscaleKeypointDetector } from './detector';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithKeypoints } from '../../../pipeline-message';\nimport { InputPort, OutputPort } from '../../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../../gpu/speedy-texture';\nimport { ImageFormat } from '../../../../../utils/types';\nimport { Utils } from '../../../../../utils/utils';\nimport { IllegalOperationError } from '../../../../../utils/errors';\nimport { SpeedyPromise } from '../../../../../utils/speedy-promise';\nimport { MIN_KEYPOINT_SIZE, PYRAMID_MAX_LEVELS } from '../../../../../utils/globals';\n\n// Constants\nconst DEFAULT_THRESHOLD = 20;\n\n\n\n/**\n * FAST corner detector\n */\nexport class SpeedyPipelineNodeFASTKeypointDetector extends SpeedyPipelineNodeMultiscaleKeypointDetector\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 3, [\n            InputPort().expects(SpeedyPipelineMessageType.Image).satisfying(\n                msg => msg.format === ImageFormat.GREY\n            ),\n            OutputPort().expects(SpeedyPipelineMessageType.Keypoints),\n        ]);\n\n        /** @type {number} FAST threshold in [0,255] */\n        this._threshold = DEFAULT_THRESHOLD;\n    }\n\n    /**\n     * FAST threshold in [0,255]\n     * @returns {number}\n     */\n    get threshold()\n    {\n        return this._threshold;\n    }\n\n    /**\n     * FAST threshold in [0,255]\n     * @param {number} threshold\n     */\n    set threshold(threshold)\n    {\n        this._threshold = Math.max(0, Math.min(threshold | 0, 255));\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const image = this.input().read().image;\n        const width = image.width, height = image.height;\n        const tex = this._tex;\n        const capacity = this._capacity;\n        const threshold = this._threshold;\n        const lodStep = Math.log2(this.scaleFactor);\n        const levels = this.levels;\n        const keypoints = gpu.programs.keypoints;\n        const nonmax = levels > 1 ? keypoints.pyrnonmax : keypoints.nonmax;\n\n        // validate pyramid\n        if(!(levels == 1 || image.hasMipmaps()))\n            throw new IllegalOperationError(`Expected a pyramid in ${this.fullName}`);\n\n        // skip if the capacity is zero\n        if(capacity == 0) {\n            const encodedKeypoints = this._encodeZeroKeypoints(gpu, this._outputTexture);\n            const encoderLength = encodedKeypoints.width;\n            this.output().swrite(encodedKeypoints, 0, 0, encoderLength);\n            return;\n        }\n\n        // FAST\n        keypoints.fast9_16.outputs(width, height, tex[0], tex[1]);\n        let corners = tex[1].clear();\n        let last = Math.min(PYRAMID_MAX_LEVELS - 1, (levels - 1) * lodStep);\n        for(let i = 0, lod = 0.0; i < levels && lod < PYRAMID_MAX_LEVELS; i++, lod += lodStep)\n            corners = keypoints.fast9_16(corners, image, last - lod, threshold);\n\n        // non-maximum suppression\n        const suppressedCorners = (nonmax\n            .outputs(width, height, tex[2])\n        )(corners, lodStep);\n\n        // convert scores to 8 bit\n        const finalCorners = (keypoints.fastScoreTo8bits\n            .outputs(width, height, tex[0])\n        )(suppressedCorners);\n\n        // encode keypoints\n        const encodedKeypoints = this._encodeKeypoints(gpu, finalCorners, this._outputTexture);\n        const encoderLength = encodedKeypoints.width;\n\n        // done!\n        this.output().swrite(encodedKeypoints, 0, 0, encoderLength);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * harris.js\n * Harris corner detector\n */\n\nimport { SpeedyPipelineNodeMultiscaleKeypointDetector } from './detector';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithKeypoints } from '../../../pipeline-message';\nimport { InputPort, OutputPort } from '../../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../../gpu/speedy-texture';\nimport { ImageFormat } from '../../../../../utils/types';\nimport { SpeedySize } from '../../../../speedy-size';\nimport { Utils } from '../../../../../utils/utils';\nimport { IllegalOperationError, IllegalArgumentError } from '../../../../../utils/errors';\nimport { SpeedyPromise } from '../../../../../utils/speedy-promise';\nimport { PYRAMID_MAX_LEVELS } from '../../../../../utils/globals';\n\n// Constants\nconst DEFAULT_QUALITY = 0.1;\nconst HARRIS = {\n    1: 'harris1',\n    3: 'harris3',\n    5: 'harris5',\n    7: 'harris7',\n};\n\n\n/**\n * Harris corner detector\n */\nexport class SpeedyPipelineNodeHarrisKeypointDetector extends SpeedyPipelineNodeMultiscaleKeypointDetector\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 3, [\n            InputPort().expects(SpeedyPipelineMessageType.Image).satisfying(\n                msg => msg.format === ImageFormat.GREY\n            ),\n            OutputPort().expects(SpeedyPipelineMessageType.Keypoints),\n        ]);\n\n        /** @type {SpeedySize} neighborhood size */\n        this._windowSize = new SpeedySize(3, 3);\n\n        /** @type {number} min corner quality in [0,1] */\n        this._quality = DEFAULT_QUALITY;\n    }\n\n    /**\n     * Minimum corner quality in [0,1] - this is a fraction of\n     * the largest min. eigenvalue of the autocorrelation matrix\n     * over the entire image\n     * @returns {number}\n     */\n    get quality()\n    {\n        return this._quality;\n    }\n\n    /**\n     * Minimum corner quality in [0,1]\n     * @param {number} quality\n     */\n    set quality(quality)\n    {\n        this._quality = Math.max(0.0, Math.min(+quality, 1.0));\n    }\n\n    /**\n     * Neighborhood size\n     * @returns {SpeedySize}\n     */\n    get windowSize()\n    {\n        return this._windowSize;\n    }\n\n    /**\n     * Neighborhood size\n     * @param {SpeedySize} windowSize\n     */\n    set windowSize(windowSize)\n    {\n        const d = windowSize.width;\n        if(!((d == windowSize.height) && (d == 1 || d == 3 || d == 5 || d == 7)))\n            throw new IllegalArgumentError(`Invalid window: ${windowSize}. Acceptable sizes: 1x1, 3x3, 5x5, 7x7`);\n\n        this._windowSize = windowSize;\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const image = this.input().read().image;\n        const width = image.width, height = image.height;\n        const tex = this._tex;\n        const capacity = this._capacity;\n        const quality = this._quality;\n        const windowSize = this._windowSize;\n        const lodStep = Math.log2(this.scaleFactor);\n        const levels = this.levels;\n        const keypoints = gpu.programs.keypoints;\n        const nonmax = levels > 1 ? keypoints.pyrnonmax : keypoints.nonmax;\n        const harris = keypoints[HARRIS[windowSize.width]];\n\n        // validate pyramid\n        if(!(levels == 1 || image.hasMipmaps()))\n            throw new IllegalOperationError(`Expected a pyramid in ${this.fullName}`);\n\n        // skip if the capacity is zero\n        if(capacity == 0) {\n            const encodedKeypoints = this._encodeZeroKeypoints(gpu, this._outputTexture);\n            const encoderLength = encodedKeypoints.width;\n            this.output().swrite(encodedKeypoints, 0, 0, encoderLength);\n            return;\n        }\n\n        // compute corner response map\n        harris.outputs(width, height, tex[0], tex[1]);\n        keypoints.harrisDerivatives.outputs(width, height, tex[2]);\n        let corners = tex[1].clear();\n        for(let i = 0, lod = 0.0; i < levels && lod < PYRAMID_MAX_LEVELS; i++, lod += lodStep) {\n            const derivatives = keypoints.harrisDerivatives(image, lod);\n            corners = harris(corners, derivatives, lod);\n        }\n\n        // non-maximum suppression\n        const suppressedCorners = (nonmax\n            .outputs(width, height, tex[2])\n        )(corners, lodStep);\n\n        // find the maximum corner response over the entire image\n        keypoints.harrisScoreFindMax.outputs(width, height, tex[0], tex[1]);\n        const npasses = Math.ceil(Math.log2(Math.max(width, height)));\n        let maxScore = suppressedCorners;\n        for(let j = 0; j < npasses; j++)\n            maxScore = keypoints.harrisScoreFindMax(maxScore, j);\n\n        // discard corners below a quality level\n        const niceCorners = (keypoints.harrisScoreCutoff\n            .outputs(width, height, maxScore == tex[0] ? tex[1] : tex[0])\n        )(suppressedCorners, maxScore, quality);\n\n        // convert scores to 8 bit\n        const finalCorners = (keypoints.harrisScoreTo8bits\n            .outputs(width, height, tex[2])\n        )(niceCorners);\n\n        // encode keypoints\n        const encodedKeypoints = this._encodeKeypoints(gpu, finalCorners, this._outputTexture);\n        const encoderLength = encodedKeypoints.width;\n\n        // done!\n        this.output().swrite(encodedKeypoints, 0, 0, encoderLength);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * mixer.js\n * Keypoint Mixer\n */\n\nimport { SpeedyPipelineNode } from '../../pipeline-node';\nimport { SpeedyPipelineNodeKeypointDetector } from './detectors/detector';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithKeypoints } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTextureReader } from '../../../../gpu/speedy-texture-reader';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { Utils } from '../../../../utils/utils';\nimport { IllegalOperationError } from '../../../../utils/errors';\nimport { MAX_ENCODER_CAPACITY } from '../../../../utils/globals';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\n\n\n// Constants\nconst LOG2_STRIDE = 5;\n\n\n\n/**\n * Keypoint Mixer: merges two sets of keypoints\n */\nexport class SpeedyPipelineNodeKeypointMixer extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 4, [\n            InputPort('in0').expects(SpeedyPipelineMessageType.Keypoints),\n            InputPort('in1').expects(SpeedyPipelineMessageType.Keypoints),\n            OutputPort().expects(SpeedyPipelineMessageType.Keypoints)\n        ]);\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const kps0 = this.input('in0').read();\n        const kps1 = this.input('in1').read();\n        const descriptorSize = kps0.descriptorSize;\n        const extraSize = kps0.extraSize;\n        const keypoints = gpu.programs.keypoints;\n        const outputTexture = this._outputTexture;\n        const tex = this._tex;\n\n        // ensure that the format of kps0 equals the format of kps1\n        if(!(kps0.descriptorSize === kps1.descriptorSize && kps0.extraSize === kps0.extraSize))\n            throw new IllegalOperationError(`Can't merge two sets of keypoints that have different formats`);\n\n        // find the capacity of kps0 + kps1\n        const cap0 = SpeedyPipelineNodeKeypointDetector.encoderCapacity(kps0.descriptorSize, kps0.extraSize, kps0.encoderLength);\n        const cap1 = SpeedyPipelineNodeKeypointDetector.encoderCapacity(kps1.descriptorSize, kps1.extraSize, kps1.encoderLength);\n        const capacity = cap0 + cap1;\n\n        // find the dimensions of the output texture\n        const encoderLength = SpeedyPipelineNodeKeypointDetector.encoderLength(capacity, descriptorSize, extraSize);\n\n        // mix keypoints\n        keypoints.mixKeypoints.outputs(encoderLength, encoderLength, tex[3]);\n        const mixedKeypoints = keypoints.mixKeypoints(\n            [ kps0.encodedKeypoints, kps1.encodedKeypoints ],\n            [ kps0.encoderLength, kps1.encoderLength ],\n            [ cap0, cap1 ],\n            descriptorSize,\n            extraSize,\n            encoderLength\n        );\n\n        // find the dimensions of the sorting shaders\n        const stride = 1 << LOG2_STRIDE; // must be a power of 2\n        const height = Math.ceil(capacity / stride);\n        const numberOfPixels = stride * height;\n\n        // generate permutation of keypoints\n        keypoints.sortCreatePermutation.outputs(stride, height, tex[0]);\n        let permutation = keypoints.sortCreatePermutation(mixedKeypoints, descriptorSize, extraSize, encoderLength);\n\n        // sort permutation\n        const numPasses = Math.ceil(Math.log2(numberOfPixels));\n        keypoints.sortMergePermutation.outputs(stride, height, tex[1], tex[2]);\n        for(let i = 1; i <= numPasses; i++) {\n            const blockSize = 1 << i; // 2, 4, 8...\n            const dblLog2BlockSize = i << 1; // 2 * log2(blockSize)\n            permutation = keypoints.sortMergePermutation(permutation, blockSize, dblLog2BlockSize);\n        }\n\n        // apply permutation\n        keypoints.sortApplyPermutation.outputs(encoderLength, encoderLength, outputTexture);\n        keypoints.sortApplyPermutation(permutation, capacity, mixedKeypoints, descriptorSize, extraSize);\n\n        // done!\n        this.output().swrite(outputTexture, descriptorSize, extraSize, encoderLength);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * sink.js\n * Gets keypoints out of the pipeline\n */\n\nimport { SpeedyPipelineNode, SpeedyPipelineSinkNode } from '../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithImage } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTextureReader } from '../../../../gpu/speedy-texture-reader';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { SpeedyMedia } from '../../../speedy-media';\nimport { Utils } from '../../../../utils/utils';\nimport { ImageFormat } from '../../../../utils/types';\nimport { IllegalOperationError } from '../../../../utils/errors';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\nimport { SpeedyKeypoint } from '../../../speedy-keypoint';\nimport {\n    MIN_KEYPOINT_SIZE,\n    FIX_RESOLUTION,\n    LOG2_PYRAMID_MAX_SCALE, PYRAMID_MAX_LEVELS,\n    KPF_ORIENTED,\n} from '../../../../utils/globals';\n\n\n\n/**\n * Gets keypoints out of the pipeline\n */\nexport class SpeedyPipelineNodeKeypointSink extends SpeedyPipelineSinkNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = 'keypoints')\n    {\n        super(name, 0, [\n            InputPort().expects(SpeedyPipelineMessageType.Keypoints)\n        ]);\n\n        /** @type {SpeedyKeypoint[]} keypoints (output) */\n        this._keypoints = [];\n\n        /** @type {SpeedyTextureReader} texture reader */\n        this._textureReader = new SpeedyTextureReader();\n    }\n\n    /**\n     * Export data from this node to the user\n     * @returns {SpeedyPromise<SpeedyKeypoint[]>}\n     */\n    export()\n    {\n        return SpeedyPromise.resolve(this._keypoints);\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { encodedKeypoints, descriptorSize, extraSize, encoderLength } = this.input().read();\n        const useBufferedDownloads = false; // TODO\n\n        return this._textureReader.readPixelsAsync(encodedKeypoints, useBufferedDownloads).then(pixels => {\n            this._keypoints = SpeedyPipelineNodeKeypointSink._decode(pixels, descriptorSize, extraSize, encoderLength);\n        });\n    }\n\n    /**\n     * Decode a sequence of keypoints, given a flattened image of encoded pixels\n     * @param {Uint8Array[]} pixels pixels in the [r,g,b,a,...] format\n     * @param {number} descriptorSize in bytes\n     * @param {number} extraSize in bytes\n     * @param {number} encoderLength\n     * @returns {SpeedyKeypoint[]} keypoints\n     */\n    static _decode(pixels, descriptorSize, extraSize, encoderLength)\n    {\n        const pixelsPerKeypoint = Math.ceil((MIN_KEYPOINT_SIZE + descriptorSize + extraSize) / 4);\n        const bytesPerKeypoint = 4 * pixelsPerKeypoint;\n        let x, y, lod, rotation, score, flags, extraBytes, descriptorBytes;\n        let hasLod, hasRotation;\n        const keypoints = [];\n\n        // how many bytes should we read?\n        const e = encoderLength;\n        const e2 = e * e * pixelsPerKeypoint * 4;\n        const size = Math.min(pixels.length, e2);\n\n        // copy the data (we use shared buffers when receiving pixels[])\n        if(descriptorSize + extraSize > 0)\n            pixels = new Uint8Array(pixels);\n\n        // for each encoded keypoint\n        for(let i = 0; i < size; i += bytesPerKeypoint) {\n            // extract fixed-point coordinates\n            x = (pixels[i+1] << 8) | pixels[i];\n            y = (pixels[i+3] << 8) | pixels[i+2];\n\n            // we have reached the end of the list\n            if(x >= 0xFFFF && y >= 0xFFFF) // \"null\" keypoint\n                break;\n\n            // discard if the header is zero\n            if(x + y == 0 && pixels[i+6] == 0)\n                continue;\n\n            // convert from fixed-point\n            x /= FIX_RESOLUTION;\n            y /= FIX_RESOLUTION;\n\n            // extract flags\n            flags = pixels[i+7];\n\n            // extract LOD\n            hasLod = (pixels[i+4] < 255);\n            lod = !hasLod ? 0.0 :\n                -LOG2_PYRAMID_MAX_SCALE + (LOG2_PYRAMID_MAX_SCALE + PYRAMID_MAX_LEVELS) * pixels[i+4] / 255.0;\n\n            // extract orientation\n            hasRotation = (flags & KPF_ORIENTED != 0);\n            rotation = !hasRotation ? 0.0 :\n                ((2 * pixels[i+5]) / 255.0 - 1.0) * Math.PI;\n\n            // extract score\n            score = pixels[i+6] / 255.0;\n\n            // extra bytes\n            extraBytes = pixels.subarray(8 + i, 8 + i + extraSize);\n\n            // descriptor bytes\n            descriptorBytes = pixels.subarray(8 + i + extraSize, 8 + i + extraSize + descriptorSize);\n\n            // something is off here\n            if(descriptorBytes.length < descriptorSize || extraBytes.length < extraSize)\n                continue; // discard\n\n            // register keypoint\n            keypoints.push(\n                new SpeedyKeypoint(x, y, lod, rotation, score, flags, descriptorBytes, extraBytes)\n            );\n        }\n\n        // done!\n        return keypoints;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * source.js\n * Gets keypoints into the pipeline\n */\n\nimport { SpeedyPipelineNode, SpeedyPipelineSourceNode } from '../../pipeline-node';\nimport { SpeedyPipelineNodeKeypointDetector } from './detectors/detector';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithImage } from '../../pipeline-message';\nimport { OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { Utils } from '../../../../utils/utils';\nimport { IllegalArgumentError } from '../../../../utils/errors';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\nimport { SpeedyKeypoint } from '../../../speedy-keypoint';\n\n// Constants\nconst UBO_MAX_BYTES = 16384; // UBOs can hold at least 16KB of data: gl.MAX_UNIFORM_BLOCK_SIZE >= 16384 according to the GL ES 3 reference\nconst BUFFER_SIZE = 1024; // how many keypoints we can upload in one pass of the shader (as defined in the shader program)\nconst SIZEOF_VEC4 = Float32Array.BYTES_PER_ELEMENT * 4; // 16 bytes\n\n/**\n * Gets keypoints into the pipeline\n */\nexport class SpeedyPipelineNodeKeypointSource extends SpeedyPipelineSourceNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 1, [\n            OutputPort().expects(SpeedyPipelineMessageType.Keypoints)\n        ]);\n\n        /** @type {SpeedyKeypoint[]} keypoints to be uploaded to the GPU */\n        this._keypoints = [];\n\n        /** @type {Float32Array} upload buffer (UBO) */\n        this._buffer = SpeedyPipelineNodeKeypointSource._createUploadBuffer(BUFFER_SIZE);\n    }\n\n    /**\n     * Keypoints to be uploaded\n     * @returns {SpeedyKeypoint[]}\n     */\n    get keypoints()\n    {\n        return this._keypoints;\n    }\n\n    /**\n     * Keypoints to be uploaded\n     * @param {SpeedyKeypoint[]} keypoints\n     */\n    set keypoints(keypoints)\n    {\n        Utils.assert(Array.isArray(keypoints));\n        this._keypoints = keypoints;\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        // Descriptors, orientation, flags and extra bytes will be lost\n        const descriptorSize = 0, extraSize = 0;\n        const keypoints = this._keypoints;\n        const numKeypoints = keypoints.length;\n        const numPasses = Math.max(1, Math.ceil(numKeypoints / BUFFER_SIZE));\n        const buffer = this._buffer;\n        const tex = this._tex[0];\n        const outputTexture = this._outputTexture;\n        const uploadKeypoints = gpu.programs.keypoints.uploadKeypoints;\n        const encoderLength = SpeedyPipelineNodeKeypointDetector.encoderLength(numKeypoints, descriptorSize, extraSize);\n\n        uploadKeypoints.outputs(encoderLength, encoderLength, outputTexture, tex);\n\n        let startIndex = 0;\n        let encodedKeypoints = tex;\n        for(let i = 0; i < numPasses; i++) {\n            const n = Math.min(BUFFER_SIZE, numKeypoints - startIndex);\n            const endIndex = startIndex + n;\n\n            uploadKeypoints.setUBO('KeypointBuffer', SpeedyPipelineNodeKeypointSource._fillUploadBuffer(buffer, keypoints, startIndex, endIndex));\n            encodedKeypoints = uploadKeypoints(encodedKeypoints, startIndex, endIndex, descriptorSize, extraSize, encoderLength);\n\n            startIndex = endIndex;\n        }\n\n        if(encodedKeypoints != outputTexture)\n            encodedKeypoints.copyTo(outputTexture);\n\n        this.output().swrite(outputTexture, descriptorSize, extraSize, encoderLength);\n    }\n\n    /**\n     * Create an upload buffer\n     * @param {number} bufferSize number of keypoints\n     * @returns {Float32Array}\n     */\n    static _createUploadBuffer(bufferSize)\n    {\n        const internalBuffer = new ArrayBuffer(SIZEOF_VEC4 * bufferSize);\n\n        Utils.assert(internalBuffer.byteLength <= UBO_MAX_BYTES);\n\n        return new Float32Array(internalBuffer);\n    }\n\n    /**\n     * Fill upload buffer with keypoint data\n     * @param {Float32Array} buffer\n     * @param {SpeedyKeypoint[]} keypoints \n     * @param {number} start index, inclusive\n     * @param {number} end index, exclusive\n     * @returns {Float32Array} buffer\n     */\n    static _fillUploadBuffer(buffer, keypoints, start, end)\n    {\n        const n = end - start;\n        for(let i = 0; i < n; i++) {\n            const keypoint = keypoints[start + i];\n            const j = i * 4;\n\n            // Format data as follows:\n            // vec4(xpos, ypos, lod, score)\n            buffer[j]   = +(keypoint.position.x) || 0;\n            buffer[j+1] = +(keypoint.position.y) || 0;\n            buffer[j+2] = +(keypoint.lod) || 0;\n            buffer[j+3] = +(keypoint.score) || 0;\n        }\n\n        // done!\n        return buffer;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * lk.js\n * LK optical-flow\n */\n\nimport { SpeedyPipelineNode } from '../../../pipeline-node';\nimport { SpeedyPipelineNodeKeypointDetector } from '../detectors/detector';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithKeypoints } from '../../../pipeline-message';\nimport { InputPort, OutputPort } from '../../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../../gpu/speedy-texture';\nimport { ImageFormat } from '../../../../../utils/types';\nimport { SpeedySize } from '../../../../speedy-size';\nimport { Utils } from '../../../../../utils/utils';\nimport { IllegalOperationError, NotSupportedError } from '../../../../../utils/errors';\nimport { SpeedyPromise } from '../../../../../utils/speedy-promise';\nimport { MIN_KEYPOINT_SIZE, PYRAMID_MAX_LEVELS } from '../../../../../utils/globals';\n\n// Constants\nconst DEFAULT_WINDOW_SIZE = new SpeedySize(15, 15);\nconst DEFAULT_DEPTH = Math.min(6, PYRAMID_MAX_LEVELS);\nconst DEFAULT_NUMBER_OF_ITERATIONS = 5;\nconst DEFAULT_DISCARD_THRESHOLD = 0.0001;\nconst DEFAULT_EPSILON = 0.01;\nconst MIN_WINDOW_SIZE = 5;\nconst MAX_WINDOW_SIZE = 21;\n\n\n/**\n * LK optical-flow\n */\nexport class SpeedyPipelineNodeLKKeypointTracker extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 3, [\n            InputPort('previousImage').expects(SpeedyPipelineMessageType.Image).satisfying(\n                msg => msg.format === ImageFormat.GREY\n            ),\n            InputPort('nextImage').expects(SpeedyPipelineMessageType.Image).satisfying(\n                msg => msg.format === ImageFormat.GREY\n            ),\n            InputPort('previousKeypoints').expects(SpeedyPipelineMessageType.Keypoints),\n            OutputPort().expects(SpeedyPipelineMessageType.Keypoints),\n        ]);\n\n        /** @type {SpeedySize} window size */\n        this._windowSize = DEFAULT_WINDOW_SIZE;\n\n        /** @type {number} number of pyramid levels to use */\n        this._levels = DEFAULT_DEPTH;\n\n        /** @type {number} minimum acceptable corner response */\n        this._discardThreshold = DEFAULT_DISCARD_THRESHOLD;\n\n        /** @type {number} number of iterations per pyramid level (termination criteria) */\n        this._numberOfIterations = DEFAULT_NUMBER_OF_ITERATIONS;\n\n        /** @type {number} minimum increment per iteration (termination criteria) */\n        this._epsilon = DEFAULT_EPSILON;\n    }\n\n    /**\n     * Window size (use odd numbers)\n     * @returns {SpeedySize}\n     */\n    get windowSize()\n    {\n        return this._windowSize;\n    }\n\n    /**\n     * Window size (use odd numbers)\n     * @param {SpeedySize} windowSize must be a square window\n     */\n    set windowSize(windowSize)\n    {\n        Utils.assert(windowSize.width == windowSize.height && windowSize.area() > 0);\n        Utils.assert(windowSize.width % 2 == 1 && windowSize.height % 2 == 1);\n        this._windowSize = windowSize;\n\n        const wsize = this._windowSize.width;\n        if(wsize > MAX_WINDOW_SIZE)\n            throw new NotSupportedError(`LK: window ${this._windowSize} is too large!`);\n        else if(wsize < MIN_WINDOW_SIZE)\n            throw new NotSupportedError(`LK: window ${this._windowSize} is too small!`);\n    }\n\n    /**\n     * Number of pyramid levels to use\n     * @returns {number}\n     */\n    get levels()\n    {\n        return this._levels;\n    }\n\n    /**\n     * Number of pyramid levels to use\n     * @param {number} levels\n     */\n    set levels(levels)\n    {\n        Utils.assert(levels >= 1 && levels <= PYRAMID_MAX_LEVELS);\n        this._levels = levels | 0;\n    }\n\n    /**\n     * Get the discard threshold, used to discard \"bad\" keypoints\n     * @returns {number}\n     */\n    get discardThreshold()\n    {\n        return this._discardThreshold;\n    }\n\n    /**\n     * Set the discard threshold, used to discard \"bad\" keypoints\n     * @param {number} value typically 10^(-4) - increase to discard more\n     */\n    set discardThreshold(value)\n    {\n        Utils.assert(value >= 0);\n        this._discardThreshold = +value;\n    }\n\n    /**\n     * Get the maximum number of iterations of the pyramidal LK algorithm\n     * @returns {number}\n     */\n    get numberOfIterations()\n    {\n        return this._numberOfIterations;\n    }\n\n    /**\n     * Set the maximum number of iterations of the pyramidal LK algorithm\n     * @param {number} value\n     */\n    set numberOfIterations(value)\n    {\n        Utils.assert(value >= 1);\n        this._numberOfIterations = value | 0;\n    }\n\n    /**\n     * Get the accuracy threshold, used to stop LK iterations\n     * @returns {number}\n     */\n    get epsilon()\n    {\n        return this._epsilon;\n    }\n\n    /**\n     * Get the accuracy threshold, used to stop LK iterations\n     * @param {number} value typically 0.01\n     */\n    set epsilon(value)\n    {\n        Utils.assert(value >= 0);\n        this._epsilon = +value;\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { encodedKeypoints, descriptorSize, extraSize, encoderLength } = this.input('previousKeypoints').read();\n        const previousImage = this.input('previousImage').read().image;\n        const nextImage = this.input('nextImage').read().image;\n        const previousKeypoints = encodedKeypoints;\n        const levels = this._levels;\n        const windowSize = this._windowSize;\n        const wsize = windowSize.width; // square window\n        const numberOfIterations = this._numberOfIterations;\n        const discardThreshold = this._discardThreshold;\n        const epsilon = this._epsilon;\n        const program = gpu.programs.trackers;\n        const tex = this._tex;\n\n        // do we need a pyramid?\n        if(!(levels == 1 || (previousImage.hasMipmaps() && nextImage.hasMipmaps())))\n            throw new IllegalOperationError(`LK: a pyramid is required if levels > 1`);\n\n        // select the appropriate program\n        const lk = (\n            (wsize <= 7  ? program.lk7  :\n            (wsize <= 11 ? program.lk11 : \n            (wsize <= 15 ? program.lk15 :\n            (wsize <= 21 ? program.lk21 : null\n        )))));\n\n        //\n        // Optimization!\n        // because this is such a demanding algorithm, we'll\n        // split the work into multiple passes of the shader\n        //\n        const numKeypoints = SpeedyPipelineNodeKeypointDetector.encoderCapacity(descriptorSize, extraSize, encoderLength);\n        const lkEncoderLength = Math.max(1, Math.ceil(Math.sqrt(numKeypoints)));\n        lk.outputs(lkEncoderLength, lkEncoderLength, tex[0], tex[1]);\n\n        // compute optical-flow\n        let flow = tex[1].clear();\n        for(let lod = levels - 1; lod >= 0; lod--)\n            flow = lk(flow, previousKeypoints, nextImage, previousImage, wsize, lod, levels, numberOfIterations, discardThreshold, epsilon, descriptorSize, extraSize, encoderLength);\n\n        // transfer optical-flow to nextKeypoints\n        program.transferFlow.outputs(encoderLength, encoderLength, tex[2]);\n        const nextKeypoints = program.transferFlow(flow, previousKeypoints, descriptorSize, extraSize, encoderLength);\n\n        // discard \"bad\" keypoints\n        program.lkDiscard.outputs(encoderLength, encoderLength, this._outputTexture);\n        const goodKeypoints = program.lkDiscard(nextImage, wsize, nextKeypoints, descriptorSize, extraSize, encoderLength);\n\n        // done!\n        this.output().swrite(goodKeypoints, descriptorSize, extraSize, encoderLength);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * perspective-warp.js\n * Warp an image using a perspective transformation\n */\n\nimport { SpeedyPipelineNode } from '../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithImage } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { Utils } from '../../../../utils/utils';\nimport { ImageFormat, PixelComponent, ColorComponentId } from '../../../../utils/types';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\nimport { IllegalArgumentError } from '../../../../utils/errors';\nimport { SpeedyMatrix } from '../../../matrix/matrix';\nimport { MatrixShape } from '../../../matrix/matrix-shape';\nimport { SpeedyMatrixExpr, SpeedyMatrixElementaryExpr } from '../../../matrix/matrix-expressions';\n\n// Used when an invalid matrix is provided\nconst SINGULAR_MATRIX = [0,0,0,0,0,0,0,0,1];\n\n/**\n * Warp an image using a perspective transformation\n */\nexport class SpeedyPipelineNodePerspectiveWarp extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 0, [\n            InputPort().expects(SpeedyPipelineMessageType.Image),\n            OutputPort().expects(SpeedyPipelineMessageType.Image),\n        ]);\n\n        /** @type {SpeedyMatrixExpr} perspective transformation */\n        this._transform = SpeedyMatrixExpr.create(3, 3, [1, 0, 0, 0, 1, 0, 0, 0, 1]); // identity matrix\n    }\n\n    /**\n     * Perspective transform, a 3x3 homography matrix\n     * @returns {SpeedyMatrixExpr}\n     */\n    get transform()\n    {\n        return this._transform;\n    }\n\n    /**\n     * Perspective transform, a 3x3 homography matrix\n     * @param {SpeedyMatrixExpr} transform\n     */\n    set transform(transform)\n    {\n        if(!(transform.rows == 3 && transform.columns == 3))\n            throw new IllegalArgumentError(`Not a 3x3 transformation matrix: ${transform}`);\n\n        this._transform = transform;\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { image, format } = this.input().read();\n        const width = image.width, height = image.height;\n        const outputTexture = this._outputTexture;\n\n        return this._transform.read().then(homography => {\n            let inverseHomography = this._inverse3(homography);\n\n            if(Number.isNaN(inverseHomography[0]))\n                inverseHomography = SINGULAR_MATRIX;\n\n            (gpu.programs.transforms._warpPerspective\n                .outputs(width, height, outputTexture)\n            )(image, inverseHomography);\n\n            this.output().swrite(outputTexture, format);\n        });\n    }\n\n    /**\n     * Compute the inverse of a 3x3 matrix IN-PLACE (do it fast!)\n     * @param {number[]} mat 3x3 matrix in column-major format\n     * @param {number} [eps] epsilon\n     * @returns {number[]} 3x3 inverse matrix in column-major format\n     */\n    _inverse3(mat, eps = 1e-6)\n    {\n        // read the entries of the matrix\n        const a11 = mat[0];\n        const a21 = mat[1];\n        const a31 = mat[2];\n        const a12 = mat[3];\n        const a22 = mat[4];\n        const a32 = mat[5];\n        const a13 = mat[6];\n        const a23 = mat[7];\n        const a33 = mat[8];\n\n        // compute cofactors\n        const b1 = a33 * a22 - a32 * a23; // b11\n        const b2 = a33 * a12 - a32 * a13; // b21\n        const b3 = a23 * a12 - a22 * a13; // b31\n\n        // compute the determinant\n        const det = a11 * b1 - a21 * b2 + a31 * b3;\n\n        // set up the inverse\n        if(!(Math.abs(det) < eps)) {\n            const d = 1.0 / det;\n            mat[0] = b1 * d;\n            mat[1] = -(a33 * a21 - a31 * a23) * d;\n            mat[2] = (a32 * a21 - a31 * a22) * d;\n            mat[3] = -b2 * d;\n            mat[4] = (a33 * a11 - a31 * a13) * d;\n            mat[5] = -(a32 * a11 - a31 * a12) * d;\n            mat[6] = b3 * d;\n            mat[7] = -(a23 * a11 - a21 * a13) * d;\n            mat[8] = (a22 * a11 - a21 * a12) * d;\n        }\n        else\n            mat.fill(Number.NaN, 0, 9);\n\n        // done!\n        return mat;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * resize.js\n * Resize image\n */\n\nimport { SpeedyPipelineNode } from '../../pipeline-node';\nimport { SpeedyPipelineMessageType, SpeedyPipelineMessageWithImage } from '../../pipeline-message';\nimport { InputPort, OutputPort } from '../../pipeline-portbuilder';\nimport { SpeedyGPU } from '../../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../../gpu/speedy-texture';\nimport { Utils } from '../../../../utils/utils';\nimport { IllegalArgumentError } from '../../../../utils/errors';\nimport { ImageFormat } from '../../../../utils/types';\nimport { SpeedySize } from '../../../speedy-size';\nimport { SpeedyVector2 } from '../../../speedy-vector';\nimport { SpeedyPromise } from '../../../../utils/speedy-promise';\n\n/**\n * @typedef {\"nearest\"|\"bilinear\"} ResizeInterpolationMethod\n */\n\n/**\n * Resize image\n */\nexport class SpeedyPipelineNodeResize extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] name of the node\n     */\n    constructor(name = undefined)\n    {\n        super(name, 0, [\n            InputPort().expects(SpeedyPipelineMessageType.Image),\n            OutputPort().expects(SpeedyPipelineMessageType.Image),\n        ]);\n\n        /** @type {SpeedySize} size of the output image, in pixels */\n        this._size = new SpeedySize(0, 0);\n\n        /** @type {SpeedyVector2} size of the output relative to the size of the input */\n        this._scale = new SpeedyVector2(1, 1);\n\n        /** @type {ResizeInterpolationMethod} interpolation method */\n        this._method = 'bilinear';\n    }\n\n    /**\n     * Size of the output image, in pixels (use 0 to use scale)\n     * @returns {SpeedySize}\n     */\n    get size()\n    {\n        return this._size;\n    }\n\n    /**\n     * Size of the output image, in pixels (use 0 to use scale)\n     * @param {SpeedySize} size\n     */\n    set size(size)\n    {\n        this._size = size;\n    }\n\n    /**\n     * Size of the output image relative to the size of the input image\n     * @returns {SpeedyVector2}\n     */\n    get scale()\n    {\n        return this._scale;\n    }\n\n    /**\n     * Size of the output image relative to the size of the input image\n     * @param {SpeedyVector2} scale\n     */\n    set scale(scale)\n    {\n        this._scale = scale;\n    }\n\n    /**\n     * Interpolation method\n     * @returns {ResizeInterpolationMethod}\n     */\n    get method()\n    {\n        return this._method;\n    }\n\n    /**\n     * Interpolation method\n     * @param {ResizeInterpolationMethod} method\n     */\n    set method(method)\n    {\n        if(method !== 'nearest' && method !== 'bilinear')\n            throw new IllegalArgumentError(`Invalid method method: \"${method}\"`);\n\n        this._method = method;\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        const { image, format } = this.input().read();\n        const width = image.width, height = image.height;\n        const outputTexture = this._outputTexture;\n        const method = this._method;\n        const newWidth = this._size.width || Math.max(1, this._scale.x * width);\n        const newHeight = this._size.height || Math.max(1, this._scale.y * height);\n\n        if(method == 'bilinear') {\n            (gpu.programs.transforms.resizeBI\n                .outputs(newWidth, newHeight, outputTexture)\n            )(image);\n        }\n        else if(method == 'nearest') {\n            (gpu.programs.transforms.resizeNN\n                .outputs(newWidth, newHeight, outputTexture)\n            )(image);\n        }\n\n        this.output().swrite(outputTexture, format);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * pipeline-message.js\n * A message that is shared between nodes of a pipeline\n */\n\nimport { Utils } from '../../utils/utils';\nimport { ImageFormat } from '../../utils/types';\nimport { AbstractMethodError } from '../../utils/errors';\nimport { SpeedyTexture } from '../../gpu/speedy-texture';\n\n/**\n * Types of messages\n * @enum {number}\n */\nexport const SpeedyPipelineMessageType = Object.freeze({\n    Nothing: 0,\n    Image: 1,\n    Keypoints: 2,\n});\n\n/**\n * A message that is shared between nodes of a pipeline\n * @abstract\n */\nexport class SpeedyPipelineMessage\n{\n    /**\n     * Constructor\n     * @param {SpeedyPipelineMessageType} type message type\n     */\n    constructor(type)\n    {\n        /** @type {SpeedyPipelineMessageType} message type */\n        this._type = type;\n    }\n\n    /**\n     * Message type\n     * @returns {SpeedyPipelineMessageType}\n     */\n    get type()\n    {\n        return this._type;\n    }\n\n    /**\n     * Checks if the type of this message is equal to parameter type\n     * @param {SpeedyPipelineMessageType} type\n     * @returns {boolean}\n     */\n    hasType(type)\n    {\n        return this._type === type;\n    }\n\n    /**\n     * Is this an empty message?\n     * @returns {boolean}\n     */\n    isEmpty()\n    {\n        return this.hasType(SpeedyPipelineMessageType.Nothing);\n    }\n\n    /**\n     * Convert to string\n     * @returns {string}\n     */\n    toString()\n    {\n        const type = Object.keys(SpeedyPipelineMessageType).find(\n            type => SpeedyPipelineMessageType[type] === this.type\n        );\n\n        return `message of type ${type}`;\n    }\n\n    /**\n     * Set parameters\n     * @param  {...any} args\n     * @returns {SpeedyPipelineMessage} this message\n     */\n    set(...args)\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Create a message of the specified type\n     * @param {SpeedyPipelineMessageType} type\n     * @returns {SpeedyPipelineMessage}\n     */\n    static create(type)\n    {\n        return createMessage(type);\n    }\n}\n\n/**\n * An empty message carrying nothing\n */\nexport class SpeedyPipelineMessageWithNothing extends SpeedyPipelineMessage\n{\n    /**\n     * Constructor\n     */\n    constructor()\n    {\n        super(SpeedyPipelineMessageType.Nothing, null);\n    }\n\n    /**\n     * Set parameters\n     * @returns {SpeedyPipelineMessage} this message\n     */\n    set()\n    {\n        return this;\n    }\n}\n\n/**\n * A message transporting an image\n */\nexport class SpeedyPipelineMessageWithImage extends SpeedyPipelineMessage\n{\n    /**\n     * Constructor\n     */\n    constructor()\n    {\n        super(SpeedyPipelineMessageType.Image);\n\n        /** @type {SpeedyTexture} the image we carry */\n        this._image = null;\n\n        /** @type {ImageFormat} image format */\n        this._format = ImageFormat.RGBA;\n    }\n\n    /**\n     * Set parameters\n     * @param {SpeedyTexture} image the image we carry\n     * @param {ImageFormat} [format] image format\n     * @returns {SpeedyPipelineMessage} this message\n     */\n    set(image, format = ImageFormat.RGBA)\n    {\n        // set parameters\n        this._image = image;\n        this._format = format;\n\n        // done!\n        return this;\n    }\n\n    /**\n     * The image we carry\n     * @returns {SpeedyTexture}\n     */\n    get image()\n    {\n        return this._image;\n    }\n\n    /**\n     * Image format\n     * @returns {ImageFormat}\n     */\n    get format()\n    {\n        return this._format;\n    }\n}\n\n/**\n * A message transporting keypoints\n */\nexport class SpeedyPipelineMessageWithKeypoints extends SpeedyPipelineMessage\n{\n    /**\n     * Constructor\n     */\n    constructor()\n    {\n        super(SpeedyPipelineMessageType.Keypoints);\n\n        /** @type {SpeedyDrawableTexture} encoded keypoints */\n        this._encodedKeypoints = null;\n\n        /** @type {number} descriptor size in bytes */\n        this._descriptorSize = 0;\n\n        /** @type {number} extra size in bytes */\n        this._extraSize = 0;\n\n        /** @type {number} encoder length */\n        this._encoderLength = 1;\n    }\n\n    /**\n     * Set parameters\n     * @param {SpeedyDrawableTexture} encodedKeypoints encoded keypoints\n     * @param {number} descriptorSize in bytes\n     * @param {number} extraSize in bytes\n     * @param {number} encoderLength positive integer\n     * @returns {SpeedyPipelineMessage} this message\n     */\n    set(encodedKeypoints, descriptorSize, extraSize, encoderLength)\n    {\n        // set parameters\n        this._encodedKeypoints = encodedKeypoints;\n        this._descriptorSize = descriptorSize | 0;\n        this._extraSize = extraSize | 0;\n        this._encoderLength = encoderLength | 0;\n\n        // validate\n        Utils.assert(this._descriptorSize >= 0 && this._extraSize >= 0);\n        Utils.assert(this._encoderLength === this._encodedKeypoints.width, 'Invalid encoderLength');\n        Utils.assert(this._encodedKeypoints.width === this._encodedKeypoints.height, 'Invalid encodedKeypoints texture');\n\n        // done!\n        return this;\n    }\n\n    /**\n     * Encoded keypoints\n     * @returns {SpeedyDrawableTexture}\n     */\n    get encodedKeypoints()\n    {\n        return this._encodedKeypoints;\n    }\n\n    /**\n     * Descriptor size, in bytes\n     * @returns {number}\n     */\n    get descriptorSize()\n    {\n        return this._descriptorSize;\n    }\n\n    /**\n     * Extra size, in bytes\n     * @returns {number}\n     */\n    get extraSize()\n    {\n        return this._extraSize;\n    }\n\n    /**\n     * Encoder length\n     * @returns {number}\n     */\n    get encoderLength()\n    {\n        return this._encoderLength;\n    }\n\n    /**\n     * Do we have keypoint descriptors in this message?\n     * @returns {boolean}\n     */\n    hasDescriptors()\n    {\n        return this._descriptorSize > 0;\n    }\n\n    /**\n     * Do we have keypoint matches in this message?\n     * @returns {boolean}\n     */\n    hasMatches()\n    {\n        // FIXME - find a better solution\n        return this._extraSize > 0;\n    }\n}\n\n\n\n\n\n\n\n//\n// Utilities\n//\n\n\n\n// Map message type to message class\nconst MESSAGE_CLASS = Object.freeze({\n    [SpeedyPipelineMessageType.Nothing]: SpeedyPipelineMessageWithNothing,\n    [SpeedyPipelineMessageType.Image]: SpeedyPipelineMessageWithImage,\n    [SpeedyPipelineMessageType.Keypoints]: SpeedyPipelineMessageWithKeypoints,\n});\n\n/**\n * Create a message of the specified type\n * @param {SpeedyPipelineMessageType} type\n * @returns {SpeedyPipelineMessage}\n */\nfunction createMessage(type)\n{\n    //return Reflect.construct(MESSAGE_CLASS[type], []);\n    return new MESSAGE_CLASS[type];\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * pipeline-node.js\n * Node of a pipeline\n */\n\nimport { Utils } from '../../utils/utils';\nimport { SpeedyPromise } from '../../utils/speedy-promise';\nimport { AbstractMethodError, IllegalArgumentError } from '../../utils/errors';\nimport { SpeedyPipelinePort, SpeedyPipelineInputPort, SpeedyPipelineOutputPort } from './pipeline-port';\nimport { SpeedyPipelinePortBuilder } from './pipeline-portbuilder';\nimport { SpeedyDrawableTexture } from '../../gpu/speedy-texture';\nimport { SpeedyGPU } from '../../gpu/speedy-gpu';\n\n/**\n * A PortDictionary is an object with null prototype storing instances of SpeedyPipelinePort\n * @typedef {Object.<string,SpeedyPipelinePort>} PortDictionary\n * @typedef {Object.<string,SpeedyPipelineInputPort>} InputPortDictionary\n * @typedef {Object.<string,SpeedyPipelineOutputPort>} OutputPortDictionary\n */\n\n/**\n * Map an array of ports to a PortDictionary whose keys are their names\n * @param {SpeedyPipelinePort[]} ports\n * @returns {PortDictionary}\n */\nconst PortDictionary = ports =>\n    ports.reduce((dict, port) => ((dict[port.name] = port), dict), Object.create(null));\n    //ports.reduce((dict, port) => Object.assign(dict, { [port.name]: port }), Object.create(null));\n\n/**\n * Generate a unique ID\n * @returns {number}\n */\nconst generateUniqueID = (function() {\n    let counter = 0;\n    return () => counter++;\n})();\n\n/**\n * Generate a random name for a node\n * @returns {string}\n */\nconst generateRandomName = () =>\n    Math.random().toString(16).substr(2);\n\n/**\n * Node of a pipeline\n * @abstract\n */\nexport class SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] the name of this node\n     * @param {number} [texCount] number of internal work textures\n     * @param {SpeedyPipelinePortBuilder[]} [portBuilders] port builders\n     */\n    constructor(name = generateRandomName(), texCount = 0, portBuilders = [])\n    {\n        /** @type {number} the ID of this node (unique) */\n        this._id = generateUniqueID(); // node names may be the same...\n\n        /** @type {string} the name of this node */\n        this._name = String(name);\n\n\n\n        // build the ports\n        const ports = portBuilders.map(builder => builder.build(this));\n\n        /** @type {InputPortDictionary} input ports */\n        this._inputPorts = PortDictionary(ports.filter(port => port.isInputPort()));\n\n        /** @type {OutputPortDictionary} output ports */\n        this._outputPorts = PortDictionary(ports.filter(port => port.isOutputPort()));\n\n\n\n        // other properties\n\n        /** @type {SpeedyDrawableTexture[]} output texture(s) */\n        this._outputTextures = (new Array(this._outputPorts.length)).fill(null);\n\n        /** @type {SpeedyDrawableTexture[]} internal work texture(s) */\n        this._tex = (new Array(texCount)).fill(null);\n\n\n\n        // got a valid name?\n        if(this._name.length == 0)\n            throw new IllegalArgumentError(`Invalid name \"${this._name}\" for node ${this.fullName}`);\n\n        // got some ports?\n        if(portBuilders.length == 0)\n            throw new IllegalArgumentError(`No ports have been found in node ${this.fullName}`);\n    }\n\n    /**\n     * The name of this node\n     * @returns {string}\n     */\n    get name()\n    {\n        return this._name;\n    }\n\n    /**\n     * Name and type of this node\n     * @returns {string}\n     */\n    get fullName()\n    {\n        return `${this.constructor.name}[${this.name}]`;\n    }\n\n    /**\n     * The unique ID of this node\n     * @returns {number}\n     */\n    get id()\n    {\n        return this._id;\n    }\n\n    /**\n     * Find input port by name\n     * @param {string} [portName]\n     * @returns {SpeedyPipelineInputPort}\n     */\n    input(portName = SpeedyPipelineInputPort.DEFAULT_NAME)\n    {\n        if(portName in this._inputPorts)\n            return this._inputPorts[portName];\n\n        throw new IllegalArgumentError(`Can't find input port ${portName} in node ${this.fullName}`);\n    }\n\n    /**\n     * Find output port by name\n     * @param {string} [portName]\n     * @returns {SpeedyPipelineOutputPort}\n     */\n    output(portName = SpeedyPipelineOutputPort.DEFAULT_NAME)\n    {\n        if(portName in this._outputPorts)\n            return this._outputPorts[portName];\n\n        throw new IllegalArgumentError(`Can't find output port ${portName} in node ${this.fullName}`);\n    }\n\n    /**\n     * Get data from the input ports and execute\n     * the task that this node is supposed to!\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    execute(gpu)\n    {\n        let portName;\n\n        // clear output ports\n        for(portName in this._outputPorts)\n            this._outputPorts[portName].clearMessage();\n\n        // let the input ports receive what is due\n        for(portName in this._inputPorts)\n            this._inputPorts[portName].pullMessage(this.fullName);\n\n        // run the task\n        const runTask = this._run(gpu);\n        if(runTask == undefined) {\n            for(portName in this._outputPorts) // ensure that no output ports are empty\n                Utils.assert(this._outputPorts[portName].hasMessage(), `Did you forget to write data to the output port ${portName} of ${this.fullName}?`);\n\n            return undefined;\n        }\n        else return runTask.then(() => {\n            for(portName in this._outputPorts) // ensure that no output ports are empty\n                Utils.assert(this._outputPorts[portName].hasMessage(), `Did you forget to write data to the output port ${portName} of ${this.fullName}?`);\n        });\n    }\n\n    /**\n     * Run the specific task of this node\n     * @param {SpeedyGPU} gpu\n     * @returns {void|SpeedyPromise<void>}\n     */\n    _run(gpu)\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Initializes this node\n     * @param {SpeedyGPU} gpu\n     */\n    init(gpu)\n    {\n        // allocate output texture(s)\n        for(let i = 0; i < this._outputTextures.length; i++)\n            this._outputTextures[i] = gpu.texturePool.allocate();\n\n        // allocate internal work texture(s)\n        for(let j = 0; j < this._tex.length; j++)\n            this._tex[j] = gpu.texturePool.allocate();\n    }\n\n    /**\n     * Releases this node\n     * @param {SpeedyGPU} gpu\n     */\n    release(gpu)\n    {\n        // deallocate internal work texture(s)\n        for(let j = this._tex.length - 1; j >= 0; j--)\n            this._tex[j] = gpu.texturePool.free(this._tex[j]);\n\n        // deallocate output texture(s)\n        for(let i = this._outputTextures.length - 1; i >= 0; i--)\n            this._outputTextures[i] = gpu.texturePool.free(this._outputTextures[i]);\n    }\n\n    /**\n     * Clear internal textures\n     */\n    clearTextures()\n    {\n        // clear output textures\n        for(let i = 0; i < this._outputTextures.length; i++)\n            this._outputTextures[i].clear();\n\n        /*// do we need this?!\n        // clear internal work textures\n        for(let j = 0; j < this._tex.length; j++)\n            this._tex[j].clear();*/\n    }\n\n    /**\n     * Clear all ports\n     */\n    clearPorts()\n    {\n        let portName;\n\n        for(portName in this._inputPorts)\n            this._inputPorts[portName].clearMessage();\n\n        for(portName in this._outputPorts)\n            this._outputPorts[portName].clearMessage();\n    }\n\n    /**\n     * Find all nodes that feed input to this node\n     * @returns {SpeedyPipelineNode[]}\n     */\n    inputNodes()\n    {\n        const nodes = [];\n\n        for(const portName in this._inputPorts) {\n            const port = this._inputPorts[portName];\n            if(port.incomingLink != null)\n                nodes.push(port.incomingLink.node);\n        }\n\n        return nodes;\n    }\n\n    /**\n     * Is this a source node, i.e., it has no input ports?\n     * @returns {boolean}\n     */\n    isSource()\n    {\n        return Object.keys(this._inputPorts).length == 0;\n    }\n\n    /**\n     * Is this a sink node, i.e., it has no output ports?\n     * @returns {boolean}\n     */\n    isSink()\n    {\n        return Object.keys(this._outputPorts).length == 0;\n    }\n\n    /**\n     * Output texture\n     * @returns {SpeedyDrawableTexture}\n     */\n    get _outputTexture()\n    {\n        // don't use this helper if there are multiple output ports!\n        Utils.assert(this._outputTextures.length == 1);\n        return this._outputTextures[0];\n    }\n}\n\n/**\n * Source node (located at the beginning of a pipeline)\n * @abstract\n */\nexport class SpeedyPipelineSourceNode extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] the name of this node\n     * @param {number} [texCount] number of internal work textures\n     * @param {SpeedyPipelinePortBuilder[]} [portBuilders] port builders\n     */\n    constructor(name = undefined, texCount = undefined, portBuilders = undefined)\n    {\n        super(name, texCount, portBuilders);\n        Utils.assert(this.isSource());\n    }\n}\n\n/**\n * Sink node (located at the end of a pipeline)\n * @abstract\n */\nexport class SpeedyPipelineSinkNode extends SpeedyPipelineNode\n{\n    /**\n     * Constructor\n     * @param {string} [name] the name of this node\n     * @param {number} [texCount] number of internal work textures\n     * @param {SpeedyPipelinePortBuilder[]} [portBuilders] port builders\n     */\n    constructor(name = undefined, texCount = undefined, portBuilders = undefined)\n    {\n        super(name, texCount, portBuilders);\n        Utils.assert(this.isSink());\n    }\n\n    /**\n     * Export data from this node to the user\n     * @returns {SpeedyPromise<any>}\n     */\n    export()\n    {\n        throw new AbstractMethodError();\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * pipeline-port.js\n * Port of a node of a pipeline\n */\n\nimport { Utils } from '../../utils/utils';\nimport { IllegalArgumentError, IllegalOperationError, AbstractMethodError, NotSupportedError } from '../../utils/errors';\nimport { SpeedyPipelinePortSpec } from './pipeline-portspec';\nimport { SpeedyPipelineMessage, SpeedyPipelineMessageWithNothing, SpeedyPipelineMessageType } from './pipeline-message';\nimport { SpeedyPipelineNode } from './pipeline-node';\n\n// Constants\nconst DEFAULT_INPUT_PORT_NAME = 'in';\nconst DEFAULT_OUTPUT_PORT_NAME = 'out';\nconst ACCEPTABLE_PORT_NAME = /^[a-z][a-zA-Z0-9]*$/;\nconst EMPTY_MESSAGE = new SpeedyPipelineMessageWithNothing();\n\n/**\n * Port of a node of a pipeline\n * @abstract\n */\nexport class SpeedyPipelinePort\n{\n    /**\n     * Constructor\n     * @param {string} name the name of this port \n     * @param {SpeedyPipelinePortSpec} spec port specification\n     * @param {SpeedyPipelineNode} node the node to which this port belongs\n     */\n    constructor(name, spec, node)\n    {\n        /** @type {string} the name of this port */\n        this._name = String(name);\n\n        /** @type {SpeedyPipelinePortSpec} the specification of this port */\n        this._spec = spec;\n\n        /** @type {SpeedyPipelineNode} the node to which this port belongs */\n        this._node = node;\n\n        /** @type {SpeedyPipelineMessage} the message located in this port */\n        this._message = EMPTY_MESSAGE;\n\n\n        // check if we've got an acceptable port name\n        Utils.assert(ACCEPTABLE_PORT_NAME.test(this._name), `Port name \"${this._name}\" is not acceptable`);\n    }\n\n    /**\n     * The name of this port\n     * @returns {string}\n     */\n    get name()\n    {\n        return this._name;\n    }\n\n    /**\n     * The node to which this port belongs\n     * @returns {SpeedyPipelineNode}\n     */\n    get node()\n    {\n        return this._node;\n    }\n\n    /**\n     * Connect this port to another\n     * @param {SpeedyPipelinePort} port\n     */\n    connectTo(port)\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Is this an input port?\n     * @returns {boolean}\n     */\n    isInputPort()\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Is this an output port?\n     * @returns {boolean}\n     */\n    isOutputPort()\n    {\n        return !this.isInputPort();\n    }\n\n    /**\n     * Clear the message stored in this port\n     */\n    clearMessage()\n    {\n        this._message = EMPTY_MESSAGE;\n    }\n\n    /**\n     * Is there a valid message located in this port?\n     * @returns {boolean}\n     */\n    hasMessage()\n    {\n        return !this._message.isEmpty();\n    }\n\n    /**\n     * Read the message that is in this port\n     * @returns {SpeedyPipelineMessage}\n     */\n    read()\n    {\n        if(this._message.isEmpty())\n            throw new IllegalOperationError(`Can't read from port ${this.name}: nothing to read`);\n\n        return this._message;\n    }\n\n    /**\n     * Write a message to this port\n     * @param {SpeedyPipelineMessage} message\n     */\n    write(message)\n    {\n        throw new NotSupportedError(`Can't write ${message} to port ${this.name}: unsupported operation`);\n    }\n\n    /**\n     * Default port name\n     * @returns {string}\n     */\n    static get DEFAULT_NAME()\n    {\n        throw new AbstractMethodError();\n    }\n}\n\n/**\n * Output port\n */\nexport class SpeedyPipelineOutputPort extends SpeedyPipelinePort\n{\n    /**\n     * Constructor\n     * @param {string} name the name of this port \n     * @param {SpeedyPipelinePortSpec} spec port specification\n     * @param {SpeedyPipelineNode} node the node to which this port belongs\n     */\n    constructor(name, spec, node)\n    {\n        super(name, spec, node);\n\n        /** @type {SpeedyPipelineMessage} cached message */\n        this._cachedMessage = null;\n    }\n\n    /**\n     * Connect this port to another\n     * @param {SpeedyPipelinePort} port\n     */\n    connectTo(port)\n    {\n        if(!port.isInputPort())\n            throw new IllegalArgumentError(`Can't connect output port ${this.name} to port ${port.name}: expected an input port`);\n\n        port.connectTo(this);\n    }\n\n    /**\n     * Is this an input port?\n     * @returns {boolean}\n     */\n    isInputPort()\n    {\n        return false;\n    }\n\n    /**\n     * Write a message to this port\n     * @param {SpeedyPipelineMessage} message\n     */\n    write(message)\n    {\n        if(!this._spec.accepts(message))\n            throw new IllegalArgumentError(`Can't write ${message} to port ${this.name}. ${this._spec}`);\n\n        this._message = message;\n    }\n\n    /**\n     * Write a message to this port using a cached message object\n     * @param  {...any} args to be passed to SpeedyPipelineMessage.set()\n     */\n    swrite(...args)\n    {\n        if(this._cachedMessage == null)\n            this._cachedMessage = SpeedyPipelineMessage.create(this._spec.expectedMessageType);\n\n        this.write(this._cachedMessage.set(...args));\n    }\n\n    /**\n     * Default port name\n     * @returns {string}\n     */\n    static get DEFAULT_NAME()\n    {\n        return DEFAULT_OUTPUT_PORT_NAME;\n    }\n}\n\n/**\n * Input port\n */\nexport class SpeedyPipelineInputPort extends SpeedyPipelinePort\n{\n    /**\n     * Constructor\n     * @param {string} name the name of this port \n     * @param {SpeedyPipelinePortSpec} spec port specification\n     * @param {SpeedyPipelineNode} node the node to which this port belongs\n     */\n    constructor(name, spec, node)\n    {\n        super(name, spec, node);\n\n        /** @type {SpeedyPipelineOutputPort?} incoming link */\n        this._incomingLink = null;\n    }\n\n    /**\n     * Incoming link\n     * @returns {SpeedyPipelineOutputPort|null}\n     */\n    get incomingLink()\n    {\n        return this._incomingLink;\n    }\n\n    /**\n     * Connect this port to another\n     * @param {SpeedyPipelinePort} port\n     */\n    connectTo(port)\n    {\n        if(!port.isOutputPort())\n            throw new IllegalArgumentError(`Can't connect input port ${this.name} to port ${port.name}: expected an output port`);\n        else if(!this._spec.isCompatibleWith(port._spec))\n            throw new IllegalArgumentError(`Can't connect ports ${this.name} and ${port.name}: incompatible types`);\n\n        this._incomingLink = port;\n    }\n\n    /**\n     * Unlink this port\n     */\n    disconnect()\n    {\n        this._incomingLink = null;\n    }\n\n    /**\n     * Is this an input port?\n     * @returns {boolean}\n     */\n    isInputPort()\n    {\n        return true;\n    }\n\n    /**\n     * Receive a message using the incoming link\n     * @param {string} [nodeName]\n     * @returns {SpeedyPipelineMessage}\n     */\n    pullMessage(nodeName = '')\n    {\n        const name = nodeName.length > 0 ? `${this.name} of ${nodeName}` : this.name;\n\n        if(this._incomingLink == null)\n            throw new IllegalOperationError(`No incoming link for input port ${name}`);\n\n        const message = this._incomingLink.read();\n        if(!this._spec.accepts(message))\n            throw new IllegalArgumentError(`Can't receive ${message} at port ${name}: ${this._spec}`);\n\n        return (this._message = message);\n    }\n\n    /**\n     * Default port name\n     * @returns {string}\n     */\n    static get DEFAULT_NAME()\n    {\n        return DEFAULT_INPUT_PORT_NAME;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * pipeline-portbuilder.js\n * Builder of a port of a node of a pipeline\n */\n\nimport { Utils } from '../../utils/utils';\nimport { SpeedyPipelinePort, SpeedyPipelineInputPort, SpeedyPipelineOutputPort } from './pipeline-port';\nimport { SpeedyPipelinePortSpec } from './pipeline-portspec';\nimport { SpeedyPipelineMessage, SpeedyPipelineMessageType } from './pipeline-message';\nimport { SpeedyPipelineNode } from './pipeline-node';\n\n/**\n * Builder of a port of a node of a pipeline\n */\nexport class SpeedyPipelinePortBuilder\n{\n    /**\n     * Constructor\n     * @param {Function} portClass input or output?\n     * @param {string} portName\n     */\n    constructor(portClass, portName)\n    {\n        /** @type {Function} input or output? */\n        this._class = portClass;\n\n        /** @type {string} port name */\n        this._name = String(portName);\n\n        /** @type {SpeedyPipelineMessageType} accepted message type */\n        this._type = SpeedyPipelineMessageType.Nothing;\n\n        /** @type {SpeedyPipelineMessageConstraint} message validation function */\n        this._messageConstraint = undefined;\n    }\n\n    /**\n     * Declare that the new port expects a certain type of message\n     * @param {SpeedyPipelineMessageType} type expected type\n     * @returns {SpeedyPipelinePortBuilder} this builder\n     */\n    expects(type)\n    {\n        Utils.assert(this._type == SpeedyPipelineMessageType.Nothing);\n        Utils.assert(type != SpeedyPipelineMessageType.Nothing);\n\n        this._type = type;\n\n        return this;\n    }\n\n    /**\n     * Declare that the new port expects messages satisfying a constraint\n     * @param {SpeedyPipelineMessageConstraint} constraint\n     * @returns {SpeedyPipelinePortBuilder} this builder\n     */\n    satisfying(constraint)\n    {\n        Utils.assert(this._type != SpeedyPipelineMessageType.Nothing, 'You must first declare what type of message this port expects');\n        Utils.assert(this._messageConstraint === undefined);\n        Utils.assert(typeof constraint === 'function');\n\n        this._messageConstraint = constraint;\n\n        return this;\n    }\n\n    /**\n     * Build a port\n     * @param {SpeedyPipelineNode} node the node to which the new port will belong\n     * @returns {SpeedyPipelinePort}\n     */\n    build(node)\n    {\n        const spec = new SpeedyPipelinePortSpec(this._type, this._messageConstraint);\n        return Reflect.construct(this._class, [this._name, spec, node]);\n    }\n}\n\n/**\n * Creates a builder for an input port\n * @param {string} [portName]\n * @returns {SpeedyPipelinePortBuilder}\n */\nexport function InputPort(portName = SpeedyPipelineInputPort.DEFAULT_NAME)\n{\n    return new SpeedyPipelinePortBuilder(SpeedyPipelineInputPort, portName);\n}\n\n/**\n * Creates a builder for an output port\n * @param {string} [portName]\n * @returns {SpeedyPipelinePortBuilder}\n */\nexport function OutputPort(portName = SpeedyPipelineOutputPort.DEFAULT_NAME)\n{\n    return new SpeedyPipelinePortBuilder(SpeedyPipelineOutputPort, portName);\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * pipeline-portspec.js\n * Specification (requirements) of a port of a node of a pipeline\n */\n\nimport { SpeedyPipelineMessage, SpeedyPipelineMessageType } from './pipeline-message';\nimport { Utils } from '../../utils/utils';\n\n/**\n * A message constraint is a message validation predicate\n * @typedef {function(SpeedyPipelineMessage): boolean} SpeedyPipelineMessageConstraint\n */\n\n/**\n * A validation predicate that validates all messages\n * @type {SpeedyPipelineMessageConstraint}\n */\nconst none = message => true;\n\n/**\n * Specification (requirements) of a port of a node of a pipeline\n */\nexport class SpeedyPipelinePortSpec\n{\n    /**\n     * Constructor\n     * @param {SpeedyPipelineMessageType} expectedMessageType expected message type\n     * @param {SpeedyPipelineMessageConstraint} [messageConstraint] message validation function\n     */\n    constructor(expectedMessageType, messageConstraint = none)\n    {\n        /** @type {SpeedyPipelineMessageType} expected message type */\n        this._expectedMessageType = expectedMessageType;\n\n        /** @type {SpeedyPipelineMessageConstraint} message validation function */\n        this._isValidMessage = (typeof messageConstraint === 'function') ? messageConstraint : none;\n\n\n        // expect a valid type\n        Utils.assert(this._expectedMessageType != SpeedyPipelineMessageType.Nothing);\n    }\n\n    /**\n     * Checks if two specs have the same expected type\n     * @param {SpeedyPipelinePortSpec} spec\n     * @returns {boolean}\n     */\n    isCompatibleWith(spec)\n    {\n        return this._expectedMessageType == spec._expectedMessageType;\n    }\n\n    /**\n     * Is the given message accepted by a port that abides by this specification?\n     * @param {SpeedyPipelineMessage} message\n     * @returns {boolean}\n     */\n    accepts(message)\n    {\n        return message.hasType(this._expectedMessageType) && this._isValidMessage(message);\n    }\n\n    /**\n     * Convert to string\n     * @returns {string}\n     */\n    toString()\n    {\n        const type = Object.keys(SpeedyPipelineMessageType).find(\n            type => SpeedyPipelineMessageType[type] === this._expectedMessageType\n        );\n\n        return `Port expects ${type} satisfying ${this._isValidMessage}`;\n    }\n\n    /**\n     * Expected message type\n     * @returns {SpeedyPipelineMessageType}\n     */\n    get expectedMessageType()\n    {\n        return this._expectedMessageType;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * pipeline.js\n * A pipeline is a network of nodes in which data flows to a sink\n */\n\nimport { Utils } from '../../utils/utils';\nimport { SpeedyPromise } from '../../utils/speedy-promise';\nimport { IllegalOperationError, IllegalArgumentError, NotSupportedError } from '../../utils/errors';\nimport { SpeedyPipelineNode, SpeedyPipelineSourceNode, SpeedyPipelineSinkNode } from './pipeline-node';\nimport { SpeedyPipelinePort, SpeedyPipelineInputPort, SpeedyPipelineOutputPort } from './pipeline-port';\nimport { SpeedyGPU } from '../../gpu/speedy-gpu';\nimport { SpeedyMedia } from '../speedy-media';\nimport { SpeedyFeature } from '../speedy-feature';\n\n/**\n * @typedef {Object.<string,(SpeedyMedia|SpeedyFeature[])>} SpeedyPipelineOutput\n * indexed by the names of the sink nodes\n */\n\n/**\n * A pipeline is a network of nodes in which data flows to a sink\n */\nexport class SpeedyPipeline\n{\n    /**\n     * Constructor\n     */\n    constructor()\n    {\n        /** @type {SpeedyPipelineNode[]} the collection of all nodes that belong to this pipeline */\n        this._nodes = [];\n\n        /** @type {SpeedyPipelineNode[]} a sequence of nodes: from the source(s) to the sink */\n        this._sequence = [];\n\n        /** @type {SpeedyPipelineOutput} output template */\n        this._template = SpeedyPipeline._createOutputTemplate();\n\n        /** @type {SpeedyGPU} GPU instance */\n        this._gpu = null;\n\n        /** @type {boolean} are we running the pipeline at this moment? */\n        this._busy = false;\n    }\n\n    /**\n     * Find a node by its name\n     * @param {string} name\n     * @returns {SpeedyPipelineNode|null}\n     */\n    node(name)\n    {\n        for(let i = 0, n = this._nodes.length; i < n; i++) {\n            if(this._nodes[i].name === name)\n                return this._nodes[i];\n        }\n\n        return null;\n    }\n\n    /**\n     * Initialize the pipeline\n     * @param  {...SpeedyPipelineNode} nodes\n     * @returns {SpeedyPipeline} this pipeline\n     */\n    init(...nodes)\n    {\n        // validate\n        if(this._nodes.length > 0)\n            throw new IllegalOperationError(`The pipeline has already been initialized`);\n        else if(nodes.length == 0)\n            throw new IllegalArgumentError(`Can't initialize the pipeline. Please specify its nodes`);\n\n        // create a GPU instance\n        this._gpu = new SpeedyGPU(1, 1);\n\n        // add nodes to the network\n        for(let i = 0; i < nodes.length; i++) {\n            const node = nodes[i];\n            if(!this._nodes.includes(node))\n                this._nodes.push(node);\n        }\n\n        // generate the output template\n        this._template = SpeedyPipeline._createOutputTemplate(this._nodes);\n\n        // generate the sequence of nodes\n        this._sequence = SpeedyPipeline._tsort(this._nodes);\n        SpeedyPipeline._validateSequence(this._sequence);\n\n        // initialize nodes\n        for(let i = 0; i < this._sequence.length; i++)\n            this._sequence[i].init(this._gpu);\n\n        // done!\n        return this;\n    }\n\n    /**\n     * Release the resources associated with this pipeline\n     * @returns {null}\n     */\n    release()\n    {\n        if(this._nodes.length == 0)\n            throw new IllegalOperationError(`The pipeline has already been released or has never been initialized`);\n\n        // release nodes\n        for(let i = this._sequence.length - 1; i >= 0; i--)\n            this._sequence[i].release(this._gpu);\n        this._sequence.length = 0;\n        this._nodes.length = 0;\n\n        // release GPU\n        this._gpu = this._gpu.release();\n\n        // release other properties\n        this._template = SpeedyPipeline._createOutputTemplate();\n\n        // done!\n        return null;\n    }\n\n    /**\n     * Run the pipeline\n     * @returns {SpeedyPromise<SpeedyPipelineOutput>} results are indexed by the names of the sink nodes\n     */\n    run()\n    {\n        Utils.assert(this._gpu != null, `Pipeline has not been initialized or has been released`);\n\n        // is the pipeline busy?\n        if(this._busy) {\n            // if so, we need to wait 'til it finishes\n            return new SpeedyPromise((resolve, reject) => {\n                setTimeout(() => this.run().then(resolve, reject), 0);\n            });\n        }\n        else {\n            // the pipeline is now busy and won't accept concurrent tasks\n            // (we allocate textures using a single pool)\n            this._busy = true;\n        }\n\n        // find the sinks\n        const sinks = this._sequence.filter(node => node.isSink());\n\n        // clear output textures\n        for(let i = 0; i < this._sequence.length; i++)\n            this._sequence[i].clearTextures();\n\n        // run the pipeline\n        return SpeedyPipeline._runSequence(this._sequence, this._gpu).then(() =>\n\n            // export results\n            SpeedyPromise.all(sinks.map(sink => sink.export())).then(results =>\n\n                // aggregate results by the names of the sinks\n                results.reduce((obj, val, idx) => ((obj[sinks[idx].name] = val), obj), this._template)\n            )\n        ).then(aggregate => {\n            // clear all ports\n            for(let i = this._sequence.length - 1; i >= 0; i--)\n                this._sequence[i].clearPorts();\n\n            // the pipeline is no longer busy\n            this._busy = false;\n\n            // done!\n            return aggregate;\n        }).turbocharge();\n    }\n\n    /**\n     * Execute the tasks of a sequence of nodes\n     * @param {SpeedyPipelineNode[]} sequence sequence of nodes\n     * @param {SpeedyGPU} gpu GPU instance\n     * @param {number} [i] in [0,n)\n     * @param {number} [n] number of nodes\n     * @returns {SpeedyPromise<void>}\n     */\n    static _runSequence(sequence, gpu, i = 0, n = sequence.length)\n    {\n        if(i >= n)\n            return SpeedyPromise.resolve();\n\n        const runTask = sequence[i].execute(gpu);\n        gpu.gl.flush();\n\n        if(runTask == undefined)\n            return SpeedyPipeline._runSequence(sequence, gpu, i+1, n);\n\n        return runTask.then(() => SpeedyPipeline._runSequence(sequence, gpu, i+1, n));\n    }\n\n    /**\n     * Topological sorting\n     * @param {SpeedyPipelineNode[]} nodes \n     * @returns {SpeedyPipelineNode[]}\n     */\n    static _tsort(nodes)\n    {\n        const outlinks = SpeedyPipeline._outlinks(nodes);\n        const stack = nodes.map(node => [ node, false ]);\n        const trash = new Set();\n        const sorted = new Array(nodes.length);\n        let j = sorted.length;\n\n        while(stack.length > 0) {\n            const [ node, done ] = stack.pop();\n            if(!done) {\n                if(!trash.has(node)) {\n                    const outnodes = outlinks.get(node);\n\n                    trash.add(node);\n                    stack.push([ node, true ]);\n                    stack.push(...(outnodes.map(node => [ node, false ])));\n\n                    if(outnodes.some(node => trash.has(node) && !sorted.includes(node)))\n                        throw new IllegalOperationError(`Pipeline networks cannot have cycles!`);\n                }\n            }\n            else\n                sorted[--j] = node;\n        }\n\n        return sorted;\n    }\n\n    /**\n     * Figure out the outgoing links of all nodes\n     * @param {SpeedyPipelineNode[]} nodes\n     * @returns {Map<SpeedyPipelineNode,SpeedyPipelineNode[]>}\n     */\n    static _outlinks(nodes)\n    {\n        const outlinks = new Map();\n\n        for(let k = 0; k < nodes.length; k++)\n            outlinks.set(nodes[k], []);\n\n        for(let i = 0; i < nodes.length; i++) {\n            const to = nodes[i];\n            const inputs = to.inputNodes();\n\n            for(let j = 0; j < inputs.length; j++) {\n                const from = inputs[j];\n                const links = outlinks.get(from);\n\n                if(!links)\n                    throw new IllegalOperationError(`Can't initialize the pipeline. Missing node: ${from.fullName}. Did you forget to add it to the initialization list?`);\n\n                if(!links.includes(to))\n                    links.push(to);\n            }\n        }\n\n        return outlinks;\n    }\n\n    /**\n     * Generate the output template by aggregating the names of the sinks\n     * @param {SpeedyPipelineNode[]} [nodes]\n     * @returns {SpeedyPipelineOutput}\n     */\n    static _createOutputTemplate(nodes = [])\n    {\n        const template = Object.create(null);\n        const sinks = nodes.filter(node => node.isSink());\n\n        return sinks.reduce((obj, sink) => ((obj[sink.name] = null), obj), template);\n    }\n\n    /**\n     * Validate a sequence of nodes\n     * @param {SpeedyPipelineNode[]} sequence\n     */\n    static _validateSequence(sequence)\n    {\n        if(sequence.length == 0)\n            throw new IllegalOperationError(`Pipeline doesn't have nodes`);\n        else if(!sequence[0].isSource())\n            throw new IllegalOperationError(`Pipeline doesn't have a source`);\n        else if(!sequence[sequence.length - 1].isSink())\n            throw new IllegalOperationError(`Pipeline doesn't have a sink`);\n    }\n}\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-descriptor.js\n * Feature descriptor\n */\n\nimport { AbstractMethodError } from '../utils/errors';\n\n/**\n * Abstract feature descriptor\n */\nexport class SpeedyDescriptor\n{\n    /**\n     * Abstract constructor\n     */\n    constructor()\n    {\n        /*if(this.constructor === SpeedyDescriptor)\n            throw new AbstractMethodError();*/\n    }\n    \n    /**\n     * Descriptor data\n     * @returns {null}\n     */\n    get data()\n    {\n        return null;\n    }\n\n    /**\n     * Descriptor size, in bytes\n     * @returns {number}\n     */\n    get size()\n    {\n        return 0;\n    }\n}\n\n/**\n * Binary feature descriptor\n */\nexport class BinaryDescriptor extends SpeedyDescriptor\n{\n    /**\n     * Class constructor\n     * @param {Uint8Array} bytes descriptor data\n     */\n    constructor(bytes)\n    {\n        super();\n        this._data = bytes;\n        this._size = bytes.length;\n    }\n\n    /**\n     * Descriptor data\n     * @returns {Uint8Array}\n     */\n    get data()\n    {\n        return this._data;\n    }\n\n    /**\n     * Descriptor size, in bytes\n     * @returns {number}\n     */\n    get size()\n    {\n        return this._size;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-feature-decorator.js\n * A wrapper around a FeatureAlgorithmDecorator\n */\n\nimport { FeatureAlgorithmDecorator } from './keypoints/feature-algorithm-decorator';\nimport { FeatureAlgorithm } from './keypoints/feature-algorithm';\nimport { Utils } from '../utils/utils';\n\n/**\n * A wrapper around a FeatureAlgorithmDecorator\n */\nexport class SpeedyFeatureDecorator\n{\n    /**\n     * Constructor\n     * @param {Function} decorator a FeatureAlgorithmDecorator\n     * @param {any[]} [args] additional arguments to be passed when instantiating the decorator\n     */\n    constructor(decorator, ...args)\n    {\n        this._decorator = decorator;\n        this._args = args;\n    }\n\n    /**\n     * Decorate an algorithm\n     * @param {FeatureAlgorithm} algorithm \n     * @returns {FeatureAlgorithmDecorator}\n     */\n    decorate(algorithm)\n    {\n        const decoratedAlgorithm = Reflect.construct(this._decorator, [ algorithm ].concat(this._args));\n        Utils.assert(decoratedAlgorithm instanceof FeatureAlgorithmDecorator);\n\n        return decoratedAlgorithm;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-feature-descriptor-factory.js\n * Factory of feature descriptors\n */\n\nimport { SpeedyNamespace } from './speedy-namespace';\nimport { SpeedyFeatureDecorator } from './speedy-feature-decorator';\nimport { ORBFeatures } from './keypoints/descriptors/orb';\n\n/**\n * A collection of methods for decorating Feature Detectors &\n * Feature Trackers with Descriptors\n */\nexport class SpeedyFeatureDescriptorFactory extends SpeedyNamespace\n{\n    /**\n     * ORB descriptor\n     * @returns {SpeedyFeatureDecorator}\n     */\n    static ORB()\n    {\n        return new SpeedyFeatureDecorator(ORBFeatures);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-feature-detector-factory.js\n * A collection of methods for instantiating SpeedyFeatureDetectors\n */\n\nimport { SpeedyNamespace } from './speedy-namespace';\nimport {\n    FASTFeatureDetector,\n    MultiscaleFASTFeatureDetector,\n    HarrisFeatureDetector,\n    MultiscaleHarrisFeatureDetector,\n} from './speedy-feature-detector';\nimport { SpeedyFeatureDescriptorFactory } from './speedy-feature-descriptor-factory';\nimport { NotImplementedError } from '../utils/errors';\n\n\n/**\n * A collection of methods for instantiating SpeedyFeatureDetectors\n */\nexport class SpeedyFeatureDetectorFactory extends SpeedyNamespace\n{\n    /**\n     * FAST feature detector\n     * @param {number} [n] Variant of the algorithm. Must be 9, 7 or 5.\n     * @returns {FASTFeatureDetector}\n     */\n    static FAST(n = 9)\n    {\n        return new FASTFeatureDetector(n);\n    }\n\n    /**\n     * FAST feature detector in scale-space\n     * @param {number} [n] Variant of the algorithm. Must be 9.\n     * @returns {MultiscaleFASTFeatureDetector}\n     */\n    static MultiscaleFAST(n = 9)\n    {\n        return new MultiscaleFASTFeatureDetector(n);\n    }\n\n    /**\n     * Harris corner detector\n     * @returns {HarrisFeatureDetector}\n     */\n    static Harris()\n    {\n        return new HarrisFeatureDetector();\n    }\n\n    /**\n     * Harris corner detector in scale-space\n     * @returns {MultiscaleHarrisFeatureDetector}\n     */\n    static MultiscaleHarris()\n    {\n        return new MultiscaleHarrisFeatureDetector();\n    }\n\n    /**\n     * ORB feature detector & descriptor\n     * @returns {MultiscaleHarrisFeatureDetector} decorated with ORB\n     */\n    static ORB()\n    {\n        const orb = SpeedyFeatureDescriptorFactory.ORB();\n        const detector = (new MultiscaleHarrisFeatureDetector()).link(orb);\n        detector.scaleFactor = 1.19; // approx. 2^0.25\n        return detector;\n    }\n\n    /**\n     * BRISK feature detector & descriptor\n     * @returns {BRISKFeatureDetector}\n     */\n    static BRISK()\n    {\n        //return new BRISKFeatureDetector();\n        throw new NotImplementedError();\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-feature-detector.js\n * Feature detection API\n */\n\nimport { IllegalArgumentError, IllegalOperationError, AbstractMethodError, NotSupportedError } from '../utils/errors';\nimport { Utils } from '../utils/utils';\nimport { ColorFormat } from '../utils/types'\nimport { SpeedyFlags } from './speedy-flags';\nimport { SpeedyGPU } from '../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../gpu/speedy-texture';\nimport { SpeedyMedia } from './speedy-media';\nimport { FeatureDetectionAlgorithm } from './keypoints/feature-detection-algorithm';\nimport { FeatureDescriptionAlgorithm } from './keypoints/feature-description-algorithm';\nimport { FeatureDownloader } from './keypoints/feature-downloader';\nimport { FASTFeatures, MultiscaleFASTFeatures } from './keypoints/detectors/fast';\nimport { HarrisFeatures, MultiscaleHarrisFeatures } from './keypoints/detectors/harris';\nimport { SpeedyFeatureDecorator } from './speedy-feature-decorator';\n\n\n\n/**\n * Basic feature detection & description API\n * This is an easy-to-use wrapper around the internal\n * FeatureDetectionAlgorithm class, which deals with encoded\n * textures and is not suitable for end-user usage\n * @abstract\n */\nexport class SpeedyFeatureDetector\n{\n    /**\n     * Class constructor\n     * @param {FeatureDetectionAlgorithm} algorithm\n     */\n    constructor(algorithm)\n    {\n        /** @type {FeatureDetectionAlgorithm} the feature detection algorithm */\n        this._algorithm = algorithm;\n\n        /** @type {FeatureDetectionAlgorithm} the decorated feature detection algorithm */\n        this._decoratedAlgorithm = this._algorithm;\n\n        /** @type {number} sensitivity: the higher the value, the more feature points you get */\n        this._sensitivity = 0; // a value in [0,1]\n\n        /** @type {number|undefined} should we cap the number of keypoints? */\n        this._max = undefined;\n\n        /** @type {Function} internal */\n        this._capKeypoints = this._capKeypoints.bind(this);\n\n        /** @type {object} enhance the image in different ways before detecting the features */\n        this._enhancements = {\n            denoise: true,\n            illumination: false,\n            nightvision: null,\n        };\n\n        /** @type {boolean} optimize downloads when working with dynamic media? */\n        this._useBufferedDownloads = true;\n    }\n\n    /**\n     * Decorate the underlying algorithm\n     * @param {SpeedyFeatureDecorator} decorator\n     * @returns {SpeedyFeatureDetector} this instance, now decorated\n     */\n    link(decorator)\n    {\n        this._decoratedAlgorithm = decorator.decorate(this._decoratedAlgorithm);\n        return this;\n    }\n\n    /**\n     * Detect & describe feature points\n     * @param {SpeedyMedia} media\n     * @returns {Promise<SpeedyFeature[]>}\n     */\n    detect(media)\n    {\n        const gpu = media._gpu;\n        const isStaticMedia = (media.options.usage == 'static');\n        const descriptorSize = this._decoratedAlgorithm.descriptorSize;\n        const extraSize = this._decoratedAlgorithm.extraSize;\n        let downloaderFlags = 0;\n\n        // check if the media has been released\n        if(media.isReleased())\n            throw new IllegalOperationError(`Can't detect features: the SpeedyMedia has been released`);\n\n        // Check usage hint: dynamic or static\n        if(isStaticMedia) {\n            // Allocate encoder space for static media\n            const MAX_KEYPOINT_GUESS = 8192; // hmmmmmmmm...\n            this._algorithm.downloader.reserveSpace(MAX_KEYPOINT_GUESS, descriptorSize, extraSize);\n        }\n        else if(this._useBufferedDownloads) {\n            // Use buffered downloads for dynamic media\n            downloaderFlags |= FeatureDownloader.USE_BUFFERED_DOWNLOADS;\n        }\n\n        /* ----- REMOVED -----\n        // Reset encoder capacity & downloader state\n        if(flags & SpeedyFlags.FEATURE_DETECTOR_RESET_CAPACITY) {\n            // Speedy performs optimizations behind the scenes,\n            // specially when detecting features in videos.\n            // This flag will undo some optimizations. Use it\n            // when you expect a sudden increase in the number\n            // of keypoints (between two consecutive frames).\n            downloaderFlags |= FeatureDownloader.RESET_DOWNLOADER_STATE;\n\n            // since we're resizing the encoder, we can't use\n            // buffered downloads in this framestep\n            downloaderFlags &= ~(FeatureDownloader.USE_BUFFERED_DOWNLOADS);\n        }\n        */\n\n        // Upload & preprocess media\n        const texture = media._upload();\n        const preprocessedTexture = this._preprocessTexture(\n            gpu,\n            texture,\n            this._enhancements.denoise == true,\n            media._colorFormat != ColorFormat.Greyscale\n        );\n\n        // Feature detection & description\n        this._algorithm.setEnhancements(\n            this._enhancements.nightvision || this._enhancements.illumination\n        );\n        const encodedKeypoints = this._decoratedAlgorithm.run(gpu, preprocessedTexture);\n\n        // Download keypoints from the GPU\n        return this._decoratedAlgorithm.download(\n            gpu,\n            encodedKeypoints,\n            downloaderFlags\n        ).then(this._capKeypoints);\n    }\n\n    /**\n     * Get the current detector sensitivity\n     * @returns {number} a value in [0,1]\n     */\n    get sensitivity()\n    {\n        return this._sensitivity;\n    }\n\n    /**\n     * Set the sensitivity of the feature detector\n     * The higher the sensitivity, the more features you get\n     * @param {number} sensitivity a value in [0,1]\n     */\n    set sensitivity(sensitivity)\n    {\n        this._sensitivity = Math.max(0, Math.min(+sensitivity, 1));\n        this._onSensitivityChange(this._sensitivity);\n    }\n\n    /**\n     * The maximum number of keypoints that will be\n     * returned by the feature detector. If it's\n     * undefined, then there is no pre-defined limit\n     * @returns {number | undefined}\n     */\n    get max()\n    {\n        return this._max;\n    }\n\n    /**\n     * The maximum number of keypoints that will be\n     * returned by the feature detector. Set it to\n     * undefined to disable any limits\n     * @param {number | undefined} maxFeaturePoints\n     */\n    set max(maxFeaturePoints)\n    {\n        if(maxFeaturePoints !== undefined)\n            this._max = Math.max(0, maxFeaturePoints | 0);\n        else\n            this._max = undefined;\n    }\n\n    /**\n     * Specify different enhancements to applied\n     * to the image before detecting the features\n     * @param {object} enhancements\n     */\n    enhance(enhancements)\n    {\n        // validate parameter\n        if(typeof enhancements !== 'object')\n            throw new IllegalArgumentError('enhancements must be an object');\n\n        // merge enhancements object\n        this._enhancements = Object.assign(this._enhancements, enhancements);\n    }\n\n    /**\n     * Optimize downloads of data from the GPU\n     * when working with dynamic media\n     * @returns {boolean}\n     */\n    get useBufferedDownloads()\n    {\n        return this._useBufferedDownloads;\n    }\n\n    /**\n     * Optimize downloads of data from the GPU\n     * when working with dynamic media\n     * @param {boolean} value\n     */\n    set useBufferedDownloads(value)\n    {\n        this._useBufferedDownloads = Boolean(value);\n    }\n\n    /**\n     * Preprocess a texture for feature detection & description\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture a RGB or greyscale image\n     * @param {boolean} [denoise] should we smooth the media a bit?\n     * @param {boolean} [convertToGreyscale] set to true if the texture is not greyscale\n     * @returns {SpeedyTexture} pre-processed greyscale image\n     */\n    _preprocessTexture(gpu, inputTexture, denoise = true, convertToGreyscale = true)\n    {\n        let texture = inputTexture;\n\n        if(denoise)\n            texture = gpu.programs.filters.gauss5(texture);\n\n        if(convertToGreyscale)\n            texture = gpu.programs.colors.rgb2grey(texture);\n\n        return texture;\n    }\n\n    /**\n     * Convert a normalized sensitivity into an\n     * algorithm-specific value such as a threshold\n     * \n     * Sensitivity is a generic parameter that can be\n     * mapped to different feature detectors. The\n     * higher the sensitivity, the more features\n     * you should get\n     *\n     * @param {number} sensitivity a value in [0,1]\n     */\n    _onSensitivityChange(sensitivity)\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Compare two keypoints for sorting (higher scores come first)\n     * @param {SpeedyFeature} a\n     * @param {SpeedyFeature} b\n     * @returns {number}\n     */\n    _compareKeypoints(a, b)\n    {\n        return (+(b.score)) - (+(a.score));\n    }\n\n    /**\n     * Cap the number of keypoints, so that only the ones with\n     * the highest scores will be returned to the user\n     * @param {SpeedyFeature[]} keypoints\n     * @returns {SpeedyFeature[]}\n     */\n    _capKeypoints(keypoints)\n    {\n        // nothing to do\n        if(this._max === undefined)\n            return keypoints;\n\n        // cap the number of keypoints\n        keypoints.sort(this._compareKeypoints);\n        keypoints.length = Math.min(keypoints.length, this._max);\n        return keypoints;\n    }\n}\n\n\n\n\n/**\n * FAST feature detector\n */\nexport class FASTFeatureDetector extends SpeedyFeatureDetector\n{\n    /**\n     * Class constructor\n     * @param {number} [n] FAST variant: 9, 7 or 5\n     */\n    constructor(n = 9)\n    {\n        // Create algorithm\n        super(new FASTFeatures());\n\n        // Validate FAST variant\n        if(!(n === 9 || n === 7 || n === 5))\n            throw new NotSupportedError(`Can't create FAST feature detector with n = ${n}`);\n\n        // Set FAST variant\n        this._algorithm.n = n;\n    }\n\n    /**\n     * Get FAST variant\n     * @returns {number}\n     */\n    get n()\n    {\n        return this._algorithm.n;\n    }\n\n    /**\n     * Get FAST threshold\n     * @returns {number} a value in [0,255]\n     */\n    get threshold()\n    {\n        return this._algorithm.threshold;\n    }\n\n    /**\n     * Set FAST threshold\n     * @param {number} threshold an integer in [0,255]\n     */\n    set threshold(threshold)\n    {\n        this._algorithm.threshold = threshold;\n    }\n\n    /**\n     * Convert a normalized sensitivity to a FAST threshold\n     * @param {number} sensitivity \n     */\n    _onSensitivityChange(sensitivity)\n    {\n        this.threshold = Math.round(255.0 * (1.0 - Math.tanh(2.77 * sensitivity)));\n    }\n}\n\n\n\n/**\n * FAST feature detector in an image pyramid\n */\nexport class MultiscaleFASTFeatureDetector extends SpeedyFeatureDetector\n{\n    /**\n     * Class constructor\n     * @param {number} [n] Multiscale FAST variant. Must be 9\n     */\n    constructor(n = 9)\n    {\n        // setup algorithm\n        super(new MultiscaleFASTFeatures());\n\n        // Validate FAST variant\n        if(n !== 9)\n            throw new NotSupportedError(`Can't create Multiscale FAST feature detector with n = ${n}`);\n\n        // Set FAST variant\n        this._algorithm.n = n;\n    }\n\n    /**\n     * Get FAST variant\n     * @returns {number}\n     */\n    get n()\n    {\n        return this._algorithm.n;\n    }\n\n    /**\n     * Get FAST threshold\n     * @returns {number} a value in [0,255]\n     */\n    get threshold()\n    {\n        return this._algorithm.threshold;\n    }\n\n    /**\n     * Set FAST threshold\n     * @param {number} threshold an integer in [0,255]\n     */\n    set threshold(threshold)\n    {\n        this._algorithm.threshold = threshold;\n    }\n\n    /**\n     * Get the depth of the algorithm: how many pyramid layers will be scanned\n     * @returns {number}\n     */\n    get depth()\n    {\n        return this._algorithm.depth;\n    }\n\n    /**\n     * Set the depth of the algorithm: how many pyramid layers will be scanned\n     * @param {number} depth\n     */\n    set depth(depth)\n    {\n        this._algorithm.depth = depth;\n    }\n\n    /**\n     * Get the scale factor between consecutive pyramid layers\n     * @returns {number}\n     */\n    get scaleFactor()\n    {\n        return this._algorithm.scaleFactor;\n    }\n\n    /**\n     * Set the scale factor between consecutive pyramid layers\n     * @param {number} value must be greater than 1 and less than or equal to 2\n     */\n    set scaleFactor(value)\n    {\n        this._algorithm.scaleFactor = value;\n    }\n\n    /**\n     * Convert a normalized sensitivity to a FAST threshold\n     * @param {number} sensitivity \n     */\n    _onSensitivityChange(sensitivity)\n    {\n        this.threshold = Math.round(255.0 * (1.0 - Math.tanh(2.77 * sensitivity)));\n    }\n}\n\n\n\n\n/**\n * Harris corner detector\n */\nexport class HarrisFeatureDetector extends SpeedyFeatureDetector\n{\n    /**\n     * Class constructor\n     */\n    constructor()\n    {\n        // setup the algorithm\n        super(new HarrisFeatures());\n    }\n\n    /**\n     * Get current quality level\n     * We will pick corners having score >= quality * max(score)\n     * @returns {number} a value in [0,1]\n     */\n    get quality()\n    {\n        return this._algorithm.quality;\n    }\n\n    /**\n     * Set quality level\n     * We will pick corners having score >= quality * max(score)\n     * @param {number} quality a value in [0,1]\n     */\n    set quality(quality)\n    {\n        this._algorithm.quality = Math.max(0, Math.min(quality, 1));\n    }\n\n    /**\n     * Convert a normalized sensitivity to a quality value\n     * @param {number} sensitivity \n     */\n    _onSensitivityChange(sensitivity)\n    {\n        this.quality = 1.0 - sensitivity;\n    }\n}\n\n\n\n/**\n * Harris corner detector in an image pyramid\n */\nexport class MultiscaleHarrisFeatureDetector extends SpeedyFeatureDetector\n{\n    /**\n     * Class constructor\n     */\n    constructor()\n    {\n        // setup algorithm\n        super(new MultiscaleHarrisFeatures());\n    }\n\n    /**\n     * Get the depth of the algorithm: how many pyramid layers will be scanned\n     * @returns {number}\n     */\n    get depth()\n    {\n        return this._algorithm.depth;\n    }\n\n    /**\n     * Set the depth of the algorithm: how many pyramid layers will be scanned\n     * @param {number} depth a number between 1 and PYRAMID_MAX_LEVELS, inclusive\n     */\n    set depth(depth)\n    {\n        this._algorithm.depth = depth;\n    }\n\n    /**\n     * Get the scale factor between consecutive pyramid layers\n     * @returns {number}\n     */\n    get scaleFactor()\n    {\n        return this._algorithm.scaleFactor;\n    }\n\n    /**\n     * Set the scale factor between consecutive pyramid layers\n     * @param {number} value must be greater than 1\n     */\n    set scaleFactor(value)\n    {\n        this._algorithm.scaleFactor = value;\n    }\n\n    /**\n     * Get current quality level\n     * We will pick corners having score >= quality * max(score)\n     * @returns {number} a value in [0,1]\n     */\n    get quality()\n    {\n        return this._algorithm.quality;\n    }\n\n    /**\n     * Set quality level\n     * We will pick corners having score >= quality * max(score)\n     * @param {number} quality a value in [0,1]\n     */\n    set quality(quality)\n    {\n        this._algorithm.quality = Math.max(0, Math.min(quality, 1));\n    }\n\n    /**\n     * Convert a normalized sensitivity to a quality value\n     * @param {number} sensitivity \n     */\n    _onSensitivityChange(sensitivity)\n    {\n        this.quality = 1.0 - sensitivity;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-feature-tracker-factory.js\n * A collection of methods for instantiating Feature Trackers\n */\n\nimport { SpeedyNamespace } from './speedy-namespace';\nimport { SpeedyMedia } from './speedy-media';\nimport { LKFeatureTracker } from './speedy-feature-tracker';\n\n/**\n * A collection of methods for instantiating Feature Trackers\n */\nexport class SpeedyFeatureTrackerFactory extends SpeedyNamespace\n{\n    /**\n     * Spawns a LK feature tracker\n     * @param {SpeedyMedia} media\n     * @returns {LKFeatureTracker}\n     */\n    static LK(media)\n    {\n        return new LKFeatureTracker(media);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-feature-tracker.js\n * An easy-to-use class for working with feature trackers\n */\n\nimport { FeatureTrackingAlgorithm } from './keypoints/feature-tracking-algorithm';\nimport { FeatureAlgorithm } from './keypoints/feature-algorithm';\nimport { FeatureDownloader } from './keypoints/feature-downloader';\nimport { SpeedyMedia } from './speedy-media';\nimport { SpeedyGPU } from '../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../gpu/speedy-texture';\nimport { SpeedyVector2 } from './speedy-vector';\nimport { IllegalOperationError, IllegalArgumentError } from '../utils/errors';\nimport { Utils } from '../utils/utils';\nimport { PYRAMID_MAX_LEVELS, KPF_DISCARD } from '../utils/globals';\nimport { LKFeatureTrackingAlgorithm } from './keypoints/trackers/lk';\nimport { SpeedyFeatureDecorator } from './speedy-feature-decorator';\n\n/**\n * An easy-to-use class for working with feature trackers\n * (it performs sparse optical-flow)\n * @abstract\n */\nexport class SpeedyFeatureTracker\n{\n    /**\n     * Class constructor\n     * @param {FeatureTrackingAlgorithm} trackingAlgorithm used to track the features\n     * @param {SpeedyMedia} media the media that holds the features\n     */\n    constructor(trackingAlgorithm, media)\n    {\n        /** @type {FeatureTrackingAlgorithm} tracking algorithm */\n        this._trackingAlgorithm = trackingAlgorithm;\n\n        /** @type {FeatureAlgorithm} decorated tracking algorithm */\n        this._decoratedAlgorithm = this._trackingAlgorithm;\n\n        /** @type {SpeedyMedia} the media we're using to track the features */\n        this._media = media;\n\n        /** @type {SpeedyTexture} image at time t */\n        this._inputTexture = null;\n\n        /** @type {SpeedyTexture} image at time t-1 */\n        this._prevInputTexture = null;\n    }\n\n    /**\n     * Decorate the underlying algorithm\n     * @param {SpeedyFeatureDecorator} decorator\n     * @returns {SpeedyFeatureTracker} this instance, now decorated\n     */\n    link(decorator)\n    {\n        this._decoratedAlgorithm = decorator.decorate(this._decoratedAlgorithm);\n        return this;\n    }\n\n    /**\n     * Track keypoints in the media\n     * @param {SpeedyFeature[]} keypoints the keypoints you want to track\n     * @param {SpeedyVector2[]|null} [flow] output parameter: flow vector for the i-th keypoint\n     * @param {boolean[]|null} [found] output parameter: found[i] will be true if the i-th keypoint has been found\n     * @returns {Promise<SpeedyFeature[]>}\n     */\n    track(keypoints, flow = null, found = null)\n    {\n        const gpu = this._media._gpu; // friend class?!\n        const descriptorSize = this._decoratedAlgorithm.descriptorSize;\n        const extraSize = this._decoratedAlgorithm.extraSize;\n        const flags = 0;\n\n        // validate arguments\n        if(!Array.isArray(keypoints) || (found != null && !Array.isArray(found)) || (flow != null && !Array.isArray(flow)))\n            throw new IllegalArgumentError();\n\n        // upload media to the GPU\n        const [ nextImage, prevImage ] = this._updatedImages(this._media, gpu, this._inputTexture);\n        this._prevInputTexture = prevImage;\n        this._inputTexture = nextImage;\n\n        // adjust the size of the encoder\n        this._trackingAlgorithm.downloader.reserveSpace(keypoints.length, descriptorSize, extraSize, true);\n\n        // upload & track keypoints\n        this._trackingAlgorithm.prevImage = prevImage;\n        this._trackingAlgorithm.prevKeypoints = this._trackingAlgorithm.upload(gpu, keypoints);\n        const encodedKeypoints = this._decoratedAlgorithm.run(gpu, nextImage);\n\n        // download keypoints\n        return this._decoratedAlgorithm.download(gpu, encodedKeypoints, flags).then(trackedKeypoints => {\n            const filteredKeypoints = [];\n\n            // initialize output arrays\n            if(found != null)\n                found.length = trackedKeypoints.length;\n            if(flow != null)\n                flow.length = trackedKeypoints.length;\n\n            // compute additional data and filter out discarded keypoints\n            for(let i = 0; i < trackedKeypoints.length; i++) {\n                const goodFeature = ((trackedKeypoints[i].flags & KPF_DISCARD) == 0);\n\n                if(goodFeature)\n                    filteredKeypoints.push(trackedKeypoints[i]);\n\n                if(found != null)\n                    found[i] = goodFeature;\n\n                if(flow != null) {\n                    flow[i] = goodFeature ? \n                        new SpeedyVector2(trackedKeypoints[i].x - keypoints[i].x, trackedKeypoints[i].y - keypoints[i].y) :\n                        new SpeedyVector2(0, 0);\n                }\n            }\n\n            // done!\n            return filteredKeypoints;\n        });\n    }\n\n    /**\n     * Upload the media to GPU and keep track of the previous frame\n     * @param {SpeedyMedia} media\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture|null} prevImage\n     * @returns {SpeedyTexture[]} [nextImage, prevImage] tuple\n     */\n    _updatedImages(media, gpu, prevImage)\n    {\n        // validate the media\n        if(media.isReleased())\n            throw new IllegalOperationError(`The media has been released`);\n\n        // upload the media\n        const nextImage = media._upload();\n        if(nextImage == null)\n            throw new IllegalOperationError(`Tracking error: can't upload image to the GPU ${media.source}`);\n\n        // done!\n        return [ nextImage, prevImage || nextImage ];\n    }\n}\n\n\n/**\n * LK feature tracker with image pyramids\n */\nexport class LKFeatureTracker extends SpeedyFeatureTracker\n{\n    /**\n     * Class constructor\n     * @param {SpeedyMedia} media media to track\n     */\n    constructor(media)\n    {\n        const algorithm = new LKFeatureTrackingAlgorithm();\n        super(algorithm, media);\n    }\n\n    /**\n     * Neighborhood size\n     * @returns {number}\n     */\n    get windowSize()\n    {\n        return this._trackingAlgorithm.windowSize;\n    }\n\n    /**\n     * Neighborhood size\n     * @param {number} newSize a positive odd integer, typically 21 or 15\n     */\n    set windowSize(newSize)\n    {\n        this._trackingAlgorithm.windowSize = newSize | 0;\n    }\n\n    /**\n     * How many pyramid levels will be scanned\n     * @returns {number}\n     */\n    get depth()\n    {\n        return this._trackingAlgorithm.depth;\n    }\n\n    /**\n     * How many pyramid levels will be scanned\n     * @param {number} newDepth positive integer\n     */\n    set depth(newDepth)\n    {\n        this._trackingAlgorithm.depth = newDepth | 0;\n    }\n\n    /**\n     * A threshold used to discard \"bad\" keypoints\n     * @returns {number}\n     */\n    get discardThreshold()\n    {\n        return this._trackingAlgorithm.discardThreshold;\n    }\n\n    /**\n     * A threshold used to discard \"bad\" keypoints\n     * @param {number} threshold typically 0.0001 - increase to discard more keypoints\n     */\n    set discardThreshold(threshold)\n    {\n        this._trackingAlgorithm.discardThreshold = +threshold;\n    }\n\n    /**\n     * Get the maximum number of iterations of the pyramidal LK algorithm\n     * @returns {number}\n     */\n    get numberOfIterations()\n    {\n        return this._trackingAlgorithm.numberOfIterations;\n    }\n\n    /**\n     * Set the maximum number of iterations of the pyramidal LK algorithm\n     * @param {number} count\n     */\n    set numberOfIterations(count)\n    {\n        this._trackingAlgorithm.numberOfIterations = count | 0;\n    }\n\n    /**\n     * Get the accuracy threshold, used to stop LK iterations\n     * @returns {number}\n     */\n    get epsilon()\n    {\n        return this._trackingAlgorithm.epsilon;\n    }\n\n    /**\n     * Get the accuracy threshold, used to stop LK iterations\n     * @param {number} value\n     */\n    set epsilon(value)\n    {\n        this._trackingAlgorithm.epsilon = +value;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-feature.js\n * Feature Point class\n */\n\nimport { SpeedyDescriptor } from './speedy-descriptor';\nimport { Utils } from '../utils/utils';\n\n// Constants\nconst noBytes = new Uint8Array([]);\n\n\n\n/**\n * A SpeedyFeature is a keypoint in an image,\n * with optional scale, rotation and\n * descriptor bytes / extra bytes\n */\nexport class SpeedyFeature\n{\n    /**\n     * Constructor\n     * @param {number} x X position\n     * @param {number} y Y position\n     * @param {number} [lod] Level-of-detail\n     * @param {number} [rotation] Rotation in radians\n     * @param {number} [score] Cornerness measure\n     * @param {number} [flags] Keypoint flags\n     * @param {Uint8Array} [extraBytes] extra bytes of the header, if any\n     * @param {Uint8Array} [descriptorBytes] bytes of the feature descriptor, if any\n     */\n    constructor(x, y, lod = 0.0, rotation = 0.0, score = 0.0, flags = 0, extraBytes = null, descriptorBytes = null)\n    {\n        this._x = +x;\n        this._y = +y;\n        this._lod = +lod;\n        this._rotation = +rotation;\n        this._score = +score;\n        this._scale = Math.pow(2, +lod);\n        this._flags = flags | 0;\n        this._extraBytes = extraBytes || noBytes;\n        this._descriptorBytes = descriptorBytes || noBytes;\n    }\n\n    /**\n     * Converts a SpeedyFeature to a representative string\n     * @returns {string}\n     */\n    toString()\n    {\n        return `(${this._x},${this._y})`;\n    }\n\n    /**\n     * The X position of the feature point\n     * @returns {number} X position\n     */\n    get x()\n    {\n        return this._x;\n    }\n\n    /**\n     * The y position of the feature point\n     * @returns {number} Y position\n     */\n    get y()\n    {\n        return this._y;\n    }\n\n    /**\n     * The pyramid level-of-detail from which\n     * this feature point was extracted\n     */\n    get lod()\n    {\n        return this._lod;\n    }\n\n    /**\n     * The scale of the feature point\n     * @returns {number} Scale\n     */\n    get scale()\n    {\n        return this._scale;\n    }\n\n    /**\n     * The rotation of the feature point, in radians\n     * @returns {number} Angle in radians\n     */\n    get rotation()\n    {\n        return this._rotation;\n    }\n\n    /**\n     * Score: a cornerness measure\n     * @returns {number} Score\n     */\n    get score()\n    {\n        return this._score;\n    }\n\n    /**\n     * Internal flags\n     * @returns {number}\n     */\n    get flags()\n    {\n        return this._flags;\n    }\n}\n\n/**\n * A feature point with a descriptor\n */\nexport class SpeedyFeatureWithDescriptor extends SpeedyFeature\n{\n    /**\n     * Constructor\n     * @param {SpeedyFeature} feature\n     * @param {function(Uint8Array): SpeedyDescriptor} spawnDescriptor spawns a descriptor given a sequence of bytes\n     */\n    constructor(feature, spawnDescriptor)\n    {\n        // copy values\n        super(\n            feature._x,\n            feature._y,\n            feature._lod,\n            feature._rotation,\n            feature._score,\n            feature._flags,\n            feature._extraBytes,\n            feature._descriptorBytes\n        );\n\n        // setup descriptor\n        this._descriptor = spawnDescriptor(this._descriptorBytes);\n    }\n\n    /**\n     * The descriptor of the feature point\n     * @returns {SpeedyDescriptor} feature descriptor\n     */\n    get descriptor()\n    {\n        return this._descriptor;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-flags.js\n * Flags available to users\n */\n\nexport const SpeedyFlags = Object.freeze({\n\n    // Feature detectors\n    //FEATURE_DETECTOR_RESET_CAPACITY: 0x1, // removed\n\n});","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-keypoint.js\n * Keypoint class\n */\n\nimport { SpeedyPoint2 } from './speedy-point';\n\n// Constants\nconst noBytes = new Uint8Array([]);\n\n/**\n * Represents a keypoint\n */\nexport class SpeedyKeypoint\n{\n    /**\n     * Constructor\n     * @param {number} x X position\n     * @param {number} y Y position\n     * @param {number} [lod] Level-of-detail\n     * @param {number} [rotation] Rotation in radians\n     * @param {number} [score] Cornerness measure\n     * @param {number} [flags] Keypoint flags\n     * @param {Uint8Array} [descriptorBytes] bytes of the feature descriptor, if any\n     * @param {Uint8Array} [extraBytes] extra bytes of the header, if any\n     */\n    constructor(x, y, lod = 0.0, rotation = 0.0, score = 0.0, flags = 0, descriptorBytes = null, extraBytes = null)\n    {\n        this._position = new SpeedyPoint2(+x, +y);\n        this._lod = +lod;\n        this._rotation = +rotation;\n        this._score = +score;\n        this._flags = flags | 0;\n        this._extraBytes = extraBytes || noBytes;\n        this._descriptorBytes = descriptorBytes || noBytes;\n    }\n\n    /**\n     * Converts a SpeedyFeature to a representative string\n     * @returns {string}\n     */\n    toString()\n    {\n        return `(${this.x},${this.y})`;\n    }\n\n    /**\n     * The position of the feature point\n     * @returns {SpeedyPoint2}\n     */\n    get position()\n    {\n        return this._position;\n    }\n\n    /**\n     * X-position of the feature point\n     * @returns {number}\n     */\n    get x()\n    {\n        return this._position.x;\n    }\n\n    /**\n     * Y-position of the feature point\n     * @returns {number}\n     */\n    get y()\n    {\n        return this._position.y;\n    }\n\n    /**\n     * The pyramid level-of-detail from which\n     * this feature point was extracted\n     * @returns {number}\n     */\n    get lod()\n    {\n        return this._lod;\n    }\n\n    /**\n     * Scale: 2^lod\n     * @returns {number}\n     */\n    get scale()\n    {\n        return Math.pow(2, this._lod);\n    }\n\n    /**\n     * The rotation of the feature point, in radians\n     * @returns {number} Angle in radians\n     */\n    get rotation()\n    {\n        return this._rotation;\n    }\n\n    /**\n     * Score: a cornerness measure\n     * @returns {number} Score\n     */\n    get score()\n    {\n        return this._score;\n    }\n\n    /**\n     * Internal flags\n     * @returns {number}\n     */\n    get flags()\n    {\n        return this._flags;\n    }\n\n    /**\n     * Descriptor data\n     * @return {Uint8Array}\n     */\n    get descriptor()\n    {\n        return this._descriptorBytes;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-media-source.js\n * Wrappers around <img>, <video>, <canvas>, etc.\n */\n\nimport { Utils } from '../utils/utils';\nimport { SpeedyPromise } from '../utils/speedy-promise';\nimport { AbstractMethodError, IllegalArgumentError, IllegalOperationError, TimeoutError } from '../utils/errors';\nimport { MediaType } from '../utils/types'\n\n/**\n * An abstract media source: a wrapper around native\n * elements such as: HTMLImageElement, HTMLVideoElement,\n * and so on\n * @abstract\n */\nexport class SpeedyMediaSource\n{\n    /**\n     * Constructor\n     */\n    constructor()\n    {\n        /** @type {HTMLImageElement|HTMLVideoElement|HTMLCanvasElement|ImageBitmap} underlying media object */\n        this._data = null;\n\n        /** @type {number} media width, in pixels */\n        this._width = 0;\n\n        /** @type {number} media height, in pixels */\n        this._height = 0;\n    }\n\n    /**\n     * Load a media source\n     * @param {HTMLImageElement|HTMLVideoElement|HTMLCanvasElement|ImageBitmap} wrapperObject\n     * @returns {SpeedyPromise<SpeedyMediaSource>}\n     */\n    static load(wrappedObject)\n    {\n        const constructor = wrappedObject.constructor.name;\n\n        if(constructor == 'HTMLImageElement')\n            return new SpeedyImageMediaSource()._load(wrappedObject);\n        else if(constructor == 'HTMLVideoElement')\n            return new SpeedyVideoMediaSource()._load(wrappedObject);\n        else if(constructor == 'HTMLCanvasElement')\n            return new SpeedyCanvasMediaSource()._load(wrappedObject);\n        else if(constructor == 'ImageBitmap')\n            return new SpeedyBitmapMediaSource()._load(wrappedObject);\n        else\n            throw new IllegalArgumentError(`Unsupported media type: ${wrappedObject}`);\n    }\n\n    /**\n     * The underlying wrapped object\n     * @returns {HTMLImageElement|HTMLVideoElement|HTMLCanvasElement|ImageBitmap}\n     */\n    get data()\n    {\n        return this._data;\n    }\n\n    /**\n     * Media width, in pixels\n     * @returns {number}\n     */\n    get width()\n    {\n        return this._width;\n    }\n\n    /**\n     * Media height, in pixels\n     * @returns {number}\n     */\n    get height()\n    {\n        return this._height;\n    }\n\n    /**\n     * Is the underlying media loaded?\n     * @returns {boolean}\n     */\n    isLoaded()\n    {\n        return this._data !== null;\n    }\n\n    /**\n     * The type of the underlying media source\n     * @returns {Symbol} MediaType enum\n     */\n    get type()\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Clone this media source\n     * @returns {SpeedyPromise<SpeedyMediaSource>}\n     */\n    clone()\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Load the underlying media\n     * @returns {SpeedyPromise<SpeedyMediaSource>}\n     */\n    _load()\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Wait for an event to be triggered in this._data\n     * @param {Element} element\n     * @param {string} eventName\n     * @param {number} [timeout] in ms\n     * @returns {SpeedyPromise<Element>}\n     */\n    _waitUntil(element, eventName, timeout = 30000)\n    {\n        return new SpeedyPromise((resolve, reject) => {\n            Utils.log(`Waiting for ${eventName} to be triggered in ${element}...`);\n\n            const timer = setTimeout(() => {\n                reject(new TimeoutError(`${eventName} has not been triggered in ${element}: timeout (${timeout}ms)`));\n            }, timeout);\n\n            element.addEventListener(eventName, () => {\n                clearTimeout(timer);\n                resolve(element);\n            }, false);\n        });\n    }\n}\n\n/**\n * Image media source:\n * a wrapper around HTMLImageElement\n */\nclass SpeedyImageMediaSource extends SpeedyMediaSource\n{\n    /**\n     * The type of the underlying media source\n     * @returns {Symbol} MediaType enum\n     */\n    get type()\n    {\n        return MediaType.Image;\n    }\n\n    /**\n     * Clone this media source\n     * @returns {SpeedyPromise<SpeedyMediaSource>}\n     */\n    clone()\n    {\n        if(this._data == null)\n            throw new IllegalOperationError(`Media not loaded`);\n\n        const newNode = this._data.cloneNode(true);\n        const newSource = new SpeedyImageMediaSource();\n        return newSource._load(newNode);\n    }\n\n    /**\n     * Load the underlying media\n     * @param {HTMLImageElement} image\n     * @returns {SpeedyPromise<SpeedyMediaSource>}\n     */\n    _load(image)\n    {\n        if(image.complete && image.naturalWidth !== 0) { // already loaded?\n            return SpeedyPromise.resolve().then(() => {\n                this._data = image;\n                this._width = image.naturalWidth;\n                this._height = image.naturalHeight;\n                return this;\n            });\n        }\n        else {\n            return this._waitUntil(image, 'load').then(() => {\n                this._data = image;\n                this._width = image.naturalWidth;\n                this._height = image.naturalHeight;\n                return this;\n            });\n        }\n    }\n}\n\n/**\n * Video media source:\n * a wrapper around HTMLVideoElement\n */\nclass SpeedyVideoMediaSource extends SpeedyMediaSource\n{\n    /**\n     * The type of the underlying media source\n     * @returns {Symbol} MediaType enum\n     */\n    get type()\n    {\n        return MediaType.Video;\n    }\n\n    /**\n     * Clone this media source\n     * @returns {SpeedyPromise<SpeedyMediaSource>}\n     */\n    clone()\n    {\n        if(this._data == null)\n            throw new IllegalOperationError(`Media not loaded`);\n\n        const newNode = this._data.cloneNode(true);\n        const newSource = new SpeedyVideoMediaSource();\n        return newSource._load(newNode);\n    }\n\n    /**\n     * Load the underlying media\n     * @param {HTMLVideoElement} video\n     * @returns {SpeedyPromise<SpeedyMediaSource>}\n     */\n    _load(video)\n    {\n        if(video.readyState >= 4) { // already loaded?\n            return SpeedyPromise.resolve().then(() => {\n                this._data = video;\n                this._width = video.videoWidth;\n                this._height = video.videoHeight;\n                return this;\n            });\n        }\n        else {\n            // waitUntil('canplay'); // use readyState >= 3\n            return this._waitUntil(video, 'canplaythrough').then(() => {\n                this._data = video;\n                this._width = video.videoWidth;\n                this._height = video.videoHeight;\n                return this;\n            })\n        }\n    }\n}\n\n/**\n * Canvas media source:\n * a wrapper around HTMLCanvasElement\n */\nclass SpeedyCanvasMediaSource extends SpeedyMediaSource\n{\n    /**\n     * The type of the underlying media source\n     * @returns {Symbol} MediaType enum\n     */\n    get type()\n    {\n        return MediaType.Canvas;\n    }\n\n    /**\n     * Clone this media source\n     * @returns {SpeedyPromise<SpeedyMediaSource>}\n     */\n    clone()\n    {\n        if(this._data == null)\n            throw new IllegalOperationError(`Media not loaded`);\n\n        const newCanvas = Utils.createCanvas(this._width, this._height);\n        const newContext = newCanvas.getContext('2d');\n        newContext.draw(this._data, 0, 0);\n\n        const newSource = new SpeedyCanvasMediaSource();\n        return newSource._load(newCanvas);\n    }\n\n    /**\n     * Load the underlying media\n     * @param {HTMLCanvasElement} canvas\n     * @returns {SpeedyPromise<SpeedyMediaSource>}\n     */\n    _load(canvas)\n    {\n        return SpeedyPromise.resolve().then(() => {\n            this._data = canvas;\n            this._width = canvas.width;\n            this._height = canvas.height;\n            return this;\n        });\n    }\n}\n\n/**\n * Bitmap media source:\n * a wrapper around ImageBitmap\n */\nclass SpeedyBitmapMediaSource extends SpeedyMediaSource\n{\n    /**\n     * The type of the underlying media source\n     * @returns {Symbol} MediaType enum\n     */\n    get type()\n    {\n        return MediaType.Bitmap;\n    }\n\n    /**\n     * Clone this media source\n     * @returns {SpeedyPromise<SpeedyMediaSource>}\n     */\n    clone()\n    {\n        if(this._data == null)\n            throw new IllegalOperationError(`Media not loaded`);\n\n        const newSource = new SpeedyBitmapMediaSource();\n        return createImageBitmap(this._data).then(\n            newBitmap => newSource._load(newBitmap)\n        );\n    }\n\n    /**\n     * Load the underlying media\n     * @param {ImageBitmap} bitmap\n     * @returns {SpeedyPromise<SpeedyMediaSource>}\n     */\n    _load(bitmap)\n    {\n        return SpeedyPromise.resolve().then(() => {\n            this._data = bitmap;\n            this._width = bitmap.width;\n            this._height = bitmap.height;\n            return this;\n        });\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-media.js\n * SpeedyMedia implementation\n */\n\nimport { SpeedyGPU } from '../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../gpu/speedy-texture';\nimport { MediaType, ColorFormat } from '../utils/types'\nimport { IllegalArgumentError, IllegalOperationError } from '../utils/errors';\nimport { Utils } from '../utils/utils';\nimport { SpeedyMediaSource } from './speedy-media-source';\nimport { SpeedyPromise } from '../utils/speedy-promise';\n\n/**\n * SpeedyMedia encapsulates a media element\n * (e.g., image, video, canvas)\n */\nexport class SpeedyMedia\n{\n    /**\n     * Constructor. It receives a VALID media source that is ALREADY LOADED.\n     * @private\n     * @param {SpeedyMediaSource} source\n     * @param {object} [options] options object\n     * @param {ColorFormat} [colorFormat]\n     */\n    constructor(source, options = {}, colorFormat = ColorFormat.RGB)\n    {\n        Utils.assert(source.isLoaded());\n\n        /** @type {SpeedyMediaSource} media source */\n        this._source = source;\n\n        /** @type {object} options */\n        this._options = this._buildOptions(options, {\n            usage: (this._source.type == MediaType.Video) ? 'dynamic' : 'static',\n        });\n\n        /** @type {ColorFormat} color format */\n        this._colorFormat = colorFormat;\n\n        /** @type {SpeedyGPU} GPU-accelerated routines */ // FIXME\n        this._gpu = options.lightweight ? Object.create(null) : new SpeedyGPU(this._source.width, this._source.height);\n\n        // warning: loading a canvas without an explicit usage flag\n        if(this._source.type == MediaType.Canvas && this._options.usage === undefined)\n            Utils.warning('Loading a canvas without an explicit usage flag. I will set the usage to \"static\". This will result in suboptimal performance if the canvas is animated');\n    }\n\n    /**\n     * Load a media source\n     * Will wait until the HTML media source is loaded\n     * @param {HTMLImageElement|HTMLVideoElement|HTMLCanvasElement|ImageBitmap} mediaSource An image, video or canvas\n     * @param {object} [options] options object\n     * @returns {SpeedyPromise<SpeedyMedia>}\n     */\n    static load(mediaSource, options = { })\n    {\n        return SpeedyMediaSource.load(mediaSource).then(source => {\n            Utils.assert(source.width !== 0 && source.height !== 0);\n\n            const media = new SpeedyMedia(source, options);\n            Utils.log(`Loaded SpeedyMedia with a ${mediaSource}.`);\n\n            return media;\n        });\n    }\n\n    /**\n     * Loads a camera stream\n     * @param {number} width width of the stream\n     * @param {number} height height of the stream\n     * @param {object} [cameraOptions] additional options to pass to getUserMedia()\n     * @param {object} [mediaOptions] additional options for advanced configuration of the SpeedyMedia\n     * @returns {SpeedyPromise<SpeedyMedia>}\n     */\n    static loadCameraStream(width, height, cameraOptions = { }, mediaOptions = { })\n    {\n        return Utils.requestCameraStream(width, height, cameraOptions).then(\n            video => SpeedyMedia.load(video, mediaOptions)\n        );\n    }\n\n    /**\n     * The media element (image, video, canvas) encapsulated by this SpeedyMedia object\n     * @returns {HTMLImageElement|HTMLVideoElement|HTMLCanvasElement|ImageBitmap} the media element\n     */\n    get source()\n    {\n        return this._source.data;\n    }\n\n    /**\n     * Gets the width of the media\n     * @returns {number} media width\n     */\n    get width()\n    {\n        return this._source.width;\n    }\n\n    /**\n     * Gets the height of the media\n     * @returns {number} media height\n     */\n    get height()\n    {\n        return this._source.height;\n    }\n\n    /**\n     * The type of the media attached to this SpeedyMedia object\n     * @returns {string} \"image\" | \"video\" | \"canvas\" | \"bitmap\"\n     */\n    get type()\n    {\n        switch(this._source.type) {\n            case MediaType.Image:\n                return 'image';\n\n            case MediaType.Video:\n                return 'video';\n\n            case MediaType.Canvas:\n                return 'canvas';\n\n            case MediaType.Bitmap:\n                return 'bitmap';\n\n            default: // this shouldn't happen\n                return 'unknown';\n        }\n    }\n\n    /**\n     * Returns a read-only object featuring advanced options\n     * related to this SpeedyMedia object\n     * @returns {object}\n     */\n    get options()\n    {\n        return this._options;\n    }\n\n    /**\n     * Releases resources associated with this media\n     * @returns {null}\n     */\n    release()\n    {\n        if(!this.isReleased()) {\n            Utils.log('Releasing SpeedyMedia object...');\n            this._gpu = this._gpu.release();\n        }\n\n        return null;\n    }\n\n    /**\n     * Has this media been released?\n     * @returns {boolean}\n     */\n    isReleased()\n    {\n        return this._gpu == null;\n    }\n\n    /**\n     * Clones the SpeedyMedia object\n     * @returns {SpeedyPromise<SpeedyMedia>} a clone object\n     */\n    clone()\n    {\n        // has the media been released?\n        if(this.isReleased())\n            throw new IllegalOperationError(`Can't clone a SpeedyMedia that has been released`);\n\n        // clone the object\n        const clone = new SpeedyMedia(this._source, this.options, this._colorFormat);\n\n        // done!\n        return SpeedyPromise.resolve(clone);\n    }\n\n    /**\n     * Draws the media to a canvas\n     * @param {HTMLCanvasElement} canvas canvas element\n     * @param {number} [x] x-position\n     * @param {number} [y] y-position\n     * @param {number} [width] desired width\n     * @param {number} [height] desired height\n     */\n    draw(canvas, x = 0, y = 0, width = this.width, height = this.height)\n    {\n        // fail silently if the media been released\n        if(this.isReleased())\n            return;\n\n        // validate parameters\n        width = Math.max(+width, 0);\n        height = Math.max(+height, 0);\n\n        // draw\n        const ctx = canvas.getContext('2d');\n        ctx.drawImage(this._source.data, +x, +y, width, height);\n    }\n\n    /**\n     * Converts the media to an ImageBitmap\n     * @returns {SpeedyPromise<ImageBitmap>}\n     */\n    toBitmap()\n    {\n        if(this.isReleased())\n            throw new IllegalOperationError('Can\\'t convert SpeedyMedia to ImageBitmap: the media has been released');\n        else if(!this._source.isLoaded())\n            throw new IllegalOperationError('Can\\'t convert SpeedyMedia to bitmap: the media hasn\\'t been loaded');\n\n        return new SpeedyPromise((resolve, reject) => createImageBitmap(this._source.data).then(resolve, reject));\n    }\n\n    /**\n     * Build & validate options object\n     * @param {object} options\n     * @param {object} defaultOptions\n     * @returns {object}\n     */\n    _buildOptions(options, defaultOptions)\n    {\n        // build options object\n        options = Object.assign({ }, defaultOptions, options);\n\n        // validate\n        if(options.usage != 'dynamic' && options.usage != 'static') {\n            Utils.warning(`Can't load media. Unrecognized usage option: \"${options.usage}\"`);\n            options.usage = defaultOptions.usage;\n            Utils.assert(options.usage == 'dynamic' || options.usage == 'static');\n        }\n\n        // done!\n        return Object.freeze(options); // must be read-only\n    }\n\n    /**\n     * Upload the media to the GPU\n     * @returns {SpeedyTexture}\n     */\n    _upload()\n    {\n        return this._gpu.upload(this._source);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-namespace.js\n * Symbolizes a namespace\n */\n\nimport { AbstractMethodError } from '../utils/errors'\n\n/**\n * An abstract namespace\n * @abstract\n */\nexport class SpeedyNamespace\n{\n    /**\n     * Namespaces can't be instantiated.\n     * Only static methods are allowed.\n     * @throws SpeedyError\n     */\n    constructor()\n    {\n        // only static methods are allowed\n        throw new AbstractMethodError(`Namespaces can't be instantiated`);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-point.js\n * Points in space\n */\n\nimport { SpeedyVector2 } from './speedy-vector';\n\n/**\n * 2D point\n */\nexport class SpeedyPoint2\n{\n    /**\n     * Create a 2D point\n     * @param {number} x\n     * @param {number} y\n     */\n    constructor(x, y)\n    {\n        /** @type {number} x coordinate */\n        this.x = +x;\n\n        /** @type {number} y coordinate */\n        this.y = +y;\n\n        // make it immutable\n        return Object.freeze(this);\n    }\n\n\n\n    //\n    // ===== METHODS =====\n    //\n\n    /**\n     * Convert to string\n     * @returns {string}\n     */\n    toString()\n    {\n        return `SpeedyPoint2(${this.x.toFixed(5)}, ${this.y.toFixed(5)})`;\n    }\n\n    /**\n     * Add a vector to this point\n     * @param {SpeedyVector2} v \n     * @returns {SpeedyPoint2}\n     */\n    plus(v)\n    {\n        return new SpeedyPoint2(this.x + v.x, this.y + v.y);\n    }\n\n    /**\n     * Subtracts a point p from this point\n     * @param {SpeedyPoint2} p \n     * @returns {SpeedyVector2}\n     */\n    minus(p)\n    {\n        return new SpeedyVector2(this.x - p.x, this.y - p.y);\n    }\n\n    /**\n     * Is this point equal to p?\n     * @param {SpeedyPoint2} p\n     * @returns {boolean}\n     */\n    equals(p)\n    {\n        return this.x === p.x && this.y === p.y;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-size.js\n * Size of a rectangle\n */\n\n/**\n * Size of a rectangle\n */\nexport class SpeedySize\n{\n    /**\n     * Constructor\n     * @param {number} width non-negative number\n     * @param {number} height non-negative number\n     */\n    constructor(width, height)\n    {\n        /** @type {number} width */\n        this.width = Math.max(0, +width);\n\n        /** @type {number} height */\n        this.height = Math.max(0, +height);\n\n        // make it immutable\n        return Object.freeze(this);\n    }\n\n\n\n    //\n    // ===== METHODS =====\n    //\n\n    /**\n     * Convert to string\n     * @returns {string}\n     */\n    toString()\n    {\n        return `SpeedySize(${this.width}, ${this.height})`;\n    }\n\n    /**\n     * Is this size equal to anotherSize?\n     * @param {SpeedySize} anotherSize\n     * @returns {boolean}\n     */\n    equals(anotherSize)\n    {\n        return this.width === anotherSize.width && this.height === anotherSize.height;\n    }\n\n    /**\n     * The area of the rectangle\n     * @returns {number}\n     */\n    area()\n    {\n        return this.width * this.height;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-vector.js\n * Vectors\n */\n\n/**\n * 2D vector of floating-point numbers\n */\nexport class SpeedyVector2\n{\n    /**\n     * Create a 2D vector\n     * @param {number} x\n     * @param {number} y\n     */\n    constructor(x, y)\n    {\n        /** @type {number} x coordinate */\n        this.x = +x;\n\n        /** @type {number} y coordinate */\n        this.y = +y;\n\n        // make it immutable\n        return Object.freeze(this);\n    }\n\n\n\n    //\n    // ===== METHODS =====\n    //\n\n    /**\n     * Convert to string\n     * @returns {string}\n     */\n    toString()\n    {\n        return `SpeedyVector2(${this.x.toFixed(5)}, ${this.y.toFixed(5)})`;\n    }\n\n    /**\n     * Is this vector equal to v?\n     * @param {SpeedyVector2} v\n     * @returns {boolean}\n     */\n    equals(v)\n    {\n        return this.x === v.x && this.y === v.y;\n    }\n\n    /**\n     * Dot product between this vector and another vector\n     * @param {SpeedyVector2} v another vector\n     * @returns {number}\n     */\n    dot(v)\n    {\n        return this.x * v.x + this.y * v.y;\n    }\n\n    /**\n     * The distance between this vector and another vector\n     * @param {SpeedyVector2} v another vector\n     * @returns {number}\n     */\n    distanceTo(v)\n    {\n        const dx = this.x - v.x;\n        const dy = this.y - v.y;\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    /**\n     * Euclidean norm\n     * @returns {number}\n     */\n    length()\n    {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n\n    /**\n     * Returns a normalized version of this vector\n     * @returns {SpeedyVector2}\n     */\n    normalized()\n    {\n        const len = this.length();\n\n        if(len > 0.0)\n            return new SpeedyVector2(this.x / len, this.y / len);\n        else\n            return new SpeedyVector2(0.0, 0.0);\n    }\n\n    /**\n     * Returns a copy of this vector translated by offset\n     * @param {SpeedyVector2} offset\n     * @returns {SpeedyVector2}\n     */\n    plus(offset)\n    {\n        return new SpeedyVector2(this.x + offset.x, this.y + offset.y);\n    }\n\n    /**\n     * Returns a copy of this vector translated by -offset\n     * @param {SpeedyVector2} offset\n     * @returns {SpeedyVector2}\n     */\n    minus(offset)\n    {\n        return new SpeedyVector2(this.x - offset.x, this.y - offset.y);\n    }\n\n    /**\n     * Returns a copy of this vector scaled by a scalar\n     * @param {number} scalar\n     * @returns {SpeedyVector2}\n     */\n    times(scalar)\n    {\n        return new SpeedyVector2(this.x * scalar, this.y * scalar);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy.js\n * Speedy's main class\n */\n\nimport { SpeedyMedia } from './speedy-media';\nimport { FPSCounter } from '../utils/fps-counter';\nimport { SpeedyFeatureDetectorFactory } from './speedy-feature-detector-factory';\nimport { SpeedyFeatureTrackerFactory } from './speedy-feature-tracker-factory';\nimport { SpeedyFeatureDescriptorFactory } from './speedy-feature-descriptor-factory';\nimport { SpeedyFlags } from './speedy-flags';\nimport { SpeedyVector2 } from './speedy-vector';\nimport { SpeedyPoint2 } from './speedy-point';\nimport { SpeedySize } from './speedy-size';\nimport { SpeedyMatrixExprFactory } from './matrix/matrix-expression-factory';\nimport { SpeedyPromise } from '../utils/speedy-promise';\nimport { SpeedyPipeline } from './pipeline/pipeline';\nimport { SpeedyPipelineImageFactory } from './pipeline/factories/image-factory';\nimport { SpeedyPipelineFilterFactory } from './pipeline/factories/filter-factory';\nimport { SpeedyPipelineTransformFactory } from './pipeline/factories/transform-factory';\nimport { SpeedyPipelineKeypointFactory } from './pipeline/factories/keypoint-factory';\nimport { Utils } from '../utils/utils';\nimport { LITTLE_ENDIAN } from '../utils/globals';\n\n// Constants\nconst matrixExprFactory = new SpeedyMatrixExprFactory();\n\n/**\n * Speedy's main class\n */\nexport class Speedy\n{\n    /**\n     * Loads a SpeedyMedia object based on the provided source element\n     * @param {HTMLImageElement|HTMLVideoElement|HTMLCanvasElement} sourceElement The source media\n     * @param {object} [options] Additional options for advanced configuration\n     * @returns {Promise<SpeedyMedia>}\n     */\n    static load(sourceElement, options = { })\n    {\n        return SpeedyMedia.load(sourceElement, options);\n    }\n\n    /**\n     * Loads a camera stream\n     * @param {number} [width] width of the stream\n     * @param {number} [height] height of the stream\n     * @param {object} [cameraOptions] additional options to pass to getUserMedia()\n     * @param {object} [mediaOptions] additional options for advanced configuration of the SpeedyMedia\n     * @returns {Promise<SpeedyMedia>}\n     */\n    static camera(width = 640, height = 360, cameraOptions = {}, mediaOptions = {})\n    {\n        return SpeedyMedia.loadCameraStream(width, height, cameraOptions, mediaOptions);\n    }\n\n    /**\n     * The version of the library\n     * @returns {string} The version of the library\n     */\n    static get version()\n    {\n        return __SPEEDY_VERSION__;\n    }\n\n    /**\n     * The FPS rate\n     * @returns {number} Frames per second (FPS)\n     */\n    static get fps()\n    {\n        return FPSCounter.instance.fps;\n    }\n\n    /**\n     * Feature detectors\n     * @returns {SpeedyFeatureDetectorFactory}\n     */\n    static get FeatureDetector()\n    {\n        return SpeedyFeatureDetectorFactory;\n    }\n\n    /**\n     * Feature trackers\n     * @returns {SpeedyFeatureTrackerFactory}\n     */\n    static get FeatureTracker()\n    {\n        return SpeedyFeatureTrackerFactory;\n    }\n\n    /**\n     * Feature descriptors\n     * @returns {SpeedyFeatureDescriptorFactory}\n     */\n    static get FeatureDescriptor()\n    {\n        return SpeedyFeatureDescriptorFactory;\n    }\n\n    /**\n     * Create a 2D vector\n     * @param {number} x\n     * @param {number} y\n     */\n    static Vector2(x, y)\n    {\n        return new SpeedyVector2(x, y);\n    }\n\n    /**\n     * Create a 2D point\n     * @param {number} x\n     * @param {number} y\n     */\n    static Point2(x, y)\n    {\n        return new SpeedyPoint2(x, y);\n    }\n\n    /**\n     * Create a new size object\n     * @param {number} width\n     * @param {number} height\n     */\n    static Size(width, height)\n    {\n        return new SpeedySize(width, height);\n    }\n\n    /**\n     * Matrix routines\n     * @returns {SpeedyMatrixExprFactory}\n     */\n    static get Matrix()\n    {\n        return matrixExprFactory;\n    }\n\n    /**\n     * Speedy Promises\n     * @returns {Function}\n     */\n    static get Promise()\n    {\n        return SpeedyPromise;\n    }\n\n    /**\n     * Create a new Pipeline\n     * @returns {SpeedyPipeline}\n     */\n    static Pipeline()\n    {\n        return new SpeedyPipeline();\n    }\n\n    /**\n     * Image-related nodes\n     * @returns {Function}\n     */\n    static get Image()\n    {\n        return SpeedyPipelineImageFactory;\n    }\n\n    /**\n     * Image filters\n     * @returns {Function}\n     */\n    static get Filter()\n    {\n        return SpeedyPipelineFilterFactory;\n    }\n\n    /**\n     * Image transforms\n     * @returns {Function}\n     */\n    static get Transform()\n    {\n        return SpeedyPipelineTransformFactory;\n    }\n\n    /**\n     * Keypoint-related nodes\n     * @returns {Function}\n     */\n    static get Keypoint()\n    {\n        return SpeedyPipelineKeypointFactory;\n    }\n}\n\n// Mix SpeedyFlags with Speedy\nObject.assign(Speedy.constructor.prototype, SpeedyFlags);\n\n// Big-endian machine? Currently untested.\nif(!LITTLE_ENDIAN)\n    Utils.warn('Running on a big-endian machine');","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * gl-utils.js\n * WebGL utilities\n */\n\nimport { Utils } from '../utils/utils';\nimport { SpeedyPromise } from '../utils/speedy-promise';\nimport { GLError, IllegalArgumentError, IllegalOperationError } from '../utils/errors';\n\n\n\n//\n// Constants\n//\nconst isFirefox = navigator.userAgent.includes('Firefox');\n\n\n\n/**\n * WebGL Utilities\n */\nexport class GLUtils\n{\n    /**\n     * Get an error object describing the latest WebGL error\n     * @param {WebGL2RenderingContext} gl \n     * @returns {GLError}\n     */\n    static getError(gl)\n    {\n        const recognizedErrors = [\n            'NO_ERROR',\n            'INVALID_ENUM',\n            'INVALID_VALUE',\n            'INVALID_OPERATION',\n            'INVALID_FRAMEBUFFER_OPERATION',\n            'OUT_OF_MEMORY',\n            'CONTEXT_LOST_WEBGL',\n        ];\n\n        const glError = gl.getError();\n        const message = recognizedErrors.find(error => gl[error] == glError) || 'Unknown';\n        return new GLError(message);\n    }\n\n    /**\n     * Waits for a sync object to become signaled\n     * @param {WebGL2RenderingContext} gl\n     * @param {WebGLSync} sync sync object\n     * @param {GLbitfield} [flags] may be gl.SYNC_FLUSH_COMMANDS_BIT or 0\n     * @returns {SpeedyPromise} a promise that resolves as soon as the sync object becomes signaled\n     */\n    static clientWaitAsync(gl, sync, flags = 0)\n    {\n        this._checkStatus = this._checkStatus || (this._checkStatus = function checkStatus(gl, sync, flags, resolve, reject) {\n            const status = gl.clientWaitSync(sync, flags, 0);\n            if(status == gl.TIMEOUT_EXPIRED) {\n                Utils.setZeroTimeout(() => checkStatus.call(this, gl, sync, flags, resolve, reject)); // better performance (preferred)\n                //setTimeout(() => checkStatus.call(this, gl, sync, flags, resolve, reject), 0); // easier on the CPU\n            }\n            else if(status == gl.WAIT_FAILED) {\n                if(isFirefox && gl.getError() == gl.NO_ERROR) { // firefox bug?\n                    Utils.setZeroTimeout(() => checkStatus.call(this, gl, sync, flags, resolve, reject));\n                    //setTimeout(() => checkStatus.call(this, gl, sync, flags, resolve, reject), 0);\n                }\n                else {\n                    reject(GLUtils.getError(gl));\n                }\n            }\n            else {\n                resolve();\n            }\n        });\n\n        return new SpeedyPromise((resolve, reject) => {\n            this._checkStatus(gl, sync, flags, resolve, reject);\n        });\n    }\n\n    /**\n     * Reads data from a WebGLBuffer into an ArrayBufferView\n     * This is like gl.getBufferSubData(), but async\n     * @param {WebGL2RenderingContext} gl\n     * @param {WebGLBuffer} glBuffer will be bound to target\n     * @param {GLenum} target\n     * @param {GLintptr} srcByteOffset usually 0\n     * @param {ArrayBufferView} destBuffer\n     * @param {GLuint} [destOffset]\n     * @param {GLuint} [length]\n     * @returns {SpeedyPromise<number>} a promise that resolves to the time it took to read the data (in ms)\n     */\n    static getBufferSubDataAsync(gl, glBuffer, target, srcByteOffset, destBuffer, destOffset = 0, length = 0)\n    {\n        const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);\n        const start = performance.now();\n\n        // empty internal command queues and send them to the GPU asap\n        gl.flush(); // make sure the sync command is read\n\n        // wait for the commands to be processed by the GPU\n        return GLUtils.clientWaitAsync(gl, sync).then(() => {\n            gl.bindBuffer(target, glBuffer);\n            gl.getBufferSubData(target, srcByteOffset, destBuffer, destOffset, length);\n            gl.bindBuffer(target, null);\n            return performance.now() - start;\n        }).catch(err => {\n            throw new IllegalOperationError(`Can't getBufferSubDataAsync(): error in clientWaitAsync()`, err);\n        }).finally(() => {\n            gl.deleteSync(sync);\n        });\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * colors.js\n * Color routines & conversion algorithms\n */\n\nimport { SpeedyProgramGroup } from '../speedy-program-group';\nimport { importShader } from '../shader-declaration';\n\n\n\n//\n// Shaders\n//\n\n// Convert to greyscale\nconst rgb2grey = importShader('colors/rgb2grey.glsl').withArguments('image');\n\n\n\n\n/**\n * GPUColors\n * Color routines & conversion algorithms\n */\nexport class GPUColors extends SpeedyProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            // convert to greyscale\n            .declare('rgb2grey', rgb2grey)\n        ;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * encoders.js\n * Texture encoders\n */\n\nimport { SpeedyProgramGroup } from '../speedy-program-group';\nimport { SpeedyTexture, SpeedyDrawableTexture } from '../speedy-texture';\nimport { SpeedyTextureReader } from '../speedy-texture-reader';\nimport { importShader } from '../shader-declaration';\nimport { SpeedyFeature } from '../../core/speedy-feature';\nimport { FeatureEncoder } from '../../core/keypoints/feature-encoder';\nimport { Utils } from '../../utils/utils'\nimport { SpeedyPromise } from '../../utils/speedy-promise'\nimport { IllegalOperationError, NotSupportedError } from '../../utils/errors';\nimport { MIN_KEYPOINT_SIZE, INITIAL_ENCODER_LENGTH, MAX_ENCODER_CAPACITY } from '../../utils/globals';\n\n// Constants\nconst MIN_PIXELS_PER_KEYPOINT = MIN_KEYPOINT_SIZE / 4; // encodes a keypoint header\nconst UBO_MAX_BYTES = 16384; // UBOs can hold at least 16KB of data: gl.MAX_UNIFORM_BLOCK_SIZE >= 16384 according to the GL ES 3 reference\nconst KEYPOINT_BUFFER_LENGTH = (UBO_MAX_BYTES / 16) | 0; // maximum number of keypoints that can be uploaded to the GPU via UBOs (each keypoint uses 16 bytes)\nconst ENCODER_PASSES = 8; // number of passes of the keypoint encoder: directly impacts performance\nconst LONG_SKIP_OFFSET_PASSES = 2; // number of passes of the long skip offsets shader\nconst MAX_SKIP_OFFSET_ITERATIONS = [ 32, 32 ]; // used when computing skip offsets\n\n\n\n\n//\n// Shaders\n//\n\n// encode keypoint offsets: maxIterations is an experimentally determined integer\nconst encodeKeypointSkipOffsets = importShader('encoders/encode-keypoint-offsets.glsl')\n                                 .withArguments('corners', 'imageSize')\n                                 .withDefines({ 'MAX_ITERATIONS': MAX_SKIP_OFFSET_ITERATIONS[0] });\n\n// encode long offsets for improved performance\nconst encodeKeypointLongSkipOffsets = importShader('encoders/encode-keypoint-long-offsets.glsl')\n                                     .withArguments('offsetsImage', 'imageSize')\n                                     .withDefines({ 'MAX_ITERATIONS': MAX_SKIP_OFFSET_ITERATIONS[1] });\n\n// encode keypoints\nconst encodeKeypoints = importShader('encoders/encode-keypoints.glsl')\n                       .withArguments('offsetsImage', 'imageSize', 'passId', 'numPasses', 'keypointLimit', 'encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength');\n\n// encode null keypoints\nconst encodeNullKeypoints = importShader('encoders/encode-null-keypoints.glsl');\n\n// resize encoded keypoints\nconst resizeEncodedKeypoints = importShader('encoders/resize-encoded-keypoints.glsl')\n                              .withArguments('inputTexture', 'inputDescriptorSize', 'inputExtraSize', 'inputEncoderLength', 'outputDescriptorSize', 'outputExtraSize', 'outputEncoderLength');\n\n// helper for downloading the keypoints\nconst downloadKeypoints = importShader('utils/identity.glsl')\n                         .withArguments('image');\n\n// upload keypoints via UBO\nconst uploadKeypoints = importShader('encoders/upload-keypoints.glsl')\n                       .withArguments('keypointCount', 'descriptorSize', 'extraSize', 'encoderLength')\n                       .withDefines({\n                           'KEYPOINT_BUFFER_LENGTH': KEYPOINT_BUFFER_LENGTH\n                       });\n\n\n\n\n/**\n * GPUEncoders\n * Keypoint encoding\n */\nexport class GPUEncoders extends SpeedyProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            // encode skip offsets\n            .declare('_encodeKeypointSkipOffsets', encodeKeypointSkipOffsets)\n            .declare('_encodeKeypointLongSkipOffsets', encodeKeypointLongSkipOffsets, {\n                ...this.program.usesPingpongRendering()\n            })\n\n            // tiny textures\n            .declare('_encodeKeypoints', encodeKeypoints, {\n                ...this.program.hasTextureSize(INITIAL_ENCODER_LENGTH, INITIAL_ENCODER_LENGTH),\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('_encodeNullKeypoints', encodeNullKeypoints, {\n                ...this.program.hasTextureSize(INITIAL_ENCODER_LENGTH, INITIAL_ENCODER_LENGTH)\n            })\n            .declare('_resizeEncodedKeypoints', resizeEncodedKeypoints, {\n                ...this.program.hasTextureSize(INITIAL_ENCODER_LENGTH, INITIAL_ENCODER_LENGTH)\n            })\n            .declare('_downloadEncodedKeypoints', downloadKeypoints, {\n                ...this.program.hasTextureSize(INITIAL_ENCODER_LENGTH, INITIAL_ENCODER_LENGTH)\n            })\n            .declare('uploadKeypoints', uploadKeypoints, {\n                ...this.program.hasTextureSize(INITIAL_ENCODER_LENGTH, INITIAL_ENCODER_LENGTH)\n            })\n        ;\n\n\n\n        // setup internal data\n\n        /** @type {SpeedyTextureReader} Texture Reader */\n        this._textureReader = new SpeedyTextureReader();\n\n        /** @type {Float32Array} UBO stuff */\n        this._uploadBuffer = null; // lazy spawn\n    }\n\n    /**\n     * Encodes the keypoints of an image into a compressed texture\n     * @param {SpeedyTexture} corners texture with corners\n     * @param {number} descriptorSize in bytes\n     * @param {number} extraSize in bytes\n     * @param {number} encoderLength\n     * @returns {SpeedyDrawableTexture} texture with encoded keypoints\n     */\n    encodeKeypoints(corners, descriptorSize, extraSize, encoderLength)\n    {\n        // parameters\n        const imageSize = [ this._width, this._height ];\n\n        // encode skip offsets\n        let offsets = this._encodeKeypointSkipOffsets(corners, imageSize);\n        for(let i = 0; i < LONG_SKIP_OFFSET_PASSES; i++) // meant to boost performance\n            offsets = this._encodeKeypointLongSkipOffsets(offsets, imageSize);\n\n        /*\n        // debug: view corners\n        let cornerview = corners;\n        cornerview = this._gpu.programs.utils.fillComponents(cornerview, PixelComponent.GREEN, 0);\n        cornerview = this._gpu.programs.utils.identity(cornerview);\n        cornerview = this._gpu.programs.utils.fillComponents(cornerview, PixelComponent.ALPHA, 1);\n        this._gpu.renderToCanvas(cornerview);\n        if(!window._ww) document.body.appendChild(this._gpu.canvas);\n        window._ww = 1;\n        */\n\n        // encode keypoints\n        const keypointLimit = MAX_ENCODER_CAPACITY;\n        const numPasses = ENCODER_PASSES;\n        const pixelsPerKeypointHeader = MIN_PIXELS_PER_KEYPOINT;\n        const keypointCapacity = FeatureEncoder.capacity(descriptorSize, extraSize, encoderLength);\n        const headerEncoderLength = Math.max(1, Math.ceil(Math.sqrt(keypointCapacity * pixelsPerKeypointHeader)));\n        this._encodeKeypoints.setOutputSize(headerEncoderLength, headerEncoderLength);\n        let encodedKeypointHeaders = this._encodeKeypoints.clear();\n        for(let passId = 0; passId < numPasses; passId++)\n            encodedKeypointHeaders = this._encodeKeypoints(offsets, imageSize, passId, numPasses, keypointLimit, encodedKeypointHeaders, 0, 0, headerEncoderLength);\n\n        // transfer keypoints to a elastic tiny texture with storage for descriptors & extra data\n        this._resizeEncodedKeypoints.setOutputSize(encoderLength, encoderLength);\n        return this._resizeEncodedKeypoints(encodedKeypointHeaders, 0, 0, headerEncoderLength, descriptorSize, extraSize, encoderLength);\n    }\n\n    /**\n     * Download RAW encoded keypoint data from the GPU - this is a bottleneck!\n     * @param {SpeedyTexture} encodedKeypoints texture with keypoints that have already been encoded\n     * @param {boolean} [useBufferedDownloads] download keypoints detected in the previous framestep (optimization)\n     * @returns {SpeedyPromise<Uint8Array[]>} pixels in the [r,g,b,a, ...] format\n     */\n    downloadEncodedKeypoints(encodedKeypoints, useBufferedDownloads = true)\n    {\n        // helper shader\n        if(!(encodedKeypoints instanceof SpeedyDrawableTexture)) {\n            this._downloadEncodedKeypoints.setOutputSize(encodedKeypoints.width, encodedKeypoints.height);\n            encodedKeypoints = this._downloadEncodedKeypoints(encodedKeypoints);\n        }\n\n        // read data from the GPU\n        return this._textureReader.readPixelsAsync(encodedKeypoints, useBufferedDownloads).catch(err =>\n            new IllegalOperationError(`Can't download the encoded keypoint texture`, err)\n        );\n    }\n\n    /**\n     * Upload keypoints to the GPU\n     * The descriptor & orientation of the keypoints will be lost\n     * (need to recalculate)\n     * @param {SpeedyFeature[]} keypoints\n     * @param {number} descriptorSize in bytes\n     * @param {number} extraSize in bytes\n     * @param {number} encoderLength\n     * @returns {SpeedyDrawableTexture} encodedKeypoints\n     */\n    uploadKeypointsOld(keypoints, descriptorSize, extraSize, encoderLength)\n    {\n        // Too many keypoints?\n        const keypointCount = keypoints.length;\n        if(keypointCount > KEYPOINT_BUFFER_LENGTH) {\n            // TODO: multipass\n            throw new NotSupportedError(`Can't upload ${keypointCount} keypoints: maximum is currently ${KEYPOINT_BUFFER_LENGTH}`);\n        }\n\n        // Insufficient encoderLength?\n        if(encoderLength < FeatureEncoder.minLength(keypointCount, descriptorSize, extraSize))\n            Utils.warning(`Insufficient encoderLength (${encoderLength}) for ${keypoints.length} keypoints (descriptorSize: ${descriptorSize}, extraSize: ${extraSize})`);\n\n        // Create a buffer for uploading the data\n        if(this._uploadBuffer === null) {\n            const sizeofVec4 = Float32Array.BYTES_PER_ELEMENT * 4; // 16\n            const internalBuffer = new ArrayBuffer(sizeofVec4 * KEYPOINT_BUFFER_LENGTH);\n            Utils.assert(internalBuffer.byteLength <= UBO_MAX_BYTES);\n            this._uploadBuffer = new Float32Array(internalBuffer);\n        }\n\n        // Format data as follows: (xpos, ypos, lod, score)\n        for(let i = 0; i < keypointCount; i++) {\n            const keypoint = keypoints[i];\n            const j = i * 4;\n\n            // this will be uploaded into a vec4\n            this._uploadBuffer[j]   = +(keypoint.x) || 0;\n            this._uploadBuffer[j+1] = +(keypoint.y) || 0;\n            this._uploadBuffer[j+2] = +(keypoint.lod) || 0;\n            this._uploadBuffer[j+3] = +(keypoint.score) || 0;\n        }\n\n        // Upload data\n        this.uploadKeypoints.setOutputSize(encoderLength, encoderLength);\n        this.uploadKeypoints.setUBO('KeypointBuffer', this._uploadBuffer);\n        return this.uploadKeypoints(keypointCount, descriptorSize, extraSize, encoderLength);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * enhancements.js\n * Image enhancement methods\n */\n\nimport { SpeedyProgramGroup } from '../speedy-program-group';\nimport { importShader } from '../shader-declaration';\nimport { convX, convY } from '../shaders/filters/convolution';\nimport { PixelComponent } from '../../utils/types';\nimport { Utils } from '../../utils/utils';\nimport { IllegalArgumentError } from '../../utils/errors';\n\n\n//\n// Shaders\n//\n\n// Normalize image\nconst normalizeGreyscaleImage = importShader('enhancements/normalize-image.glsl')\n                               .withArguments('minmax2d', 'minValue', 'maxValue')\n                               .withDefines({ 'GREYSCALE': 1 });\nconst normalizeColoredImage = importShader('enhancements/normalize-image.glsl')\n                             .withArguments('minmax2dRGB', 'minValue', 'maxValue');\n\n// Nightvision\nconst nightvision = importShader('enhancements/nightvision.glsl')\n                   .withArguments('image', 'illuminationMap', 'gain', 'offset', 'decay');\nconst nightvisionGreyscale = importShader('enhancements/nightvision.glsl')\n                            .withArguments('image', 'illuminationMap', 'gain', 'offset', 'decay')\n                            .withDefines({ 'GREYSCALE': 1 });\n\n\n\n\n/**\n * GPUEnhancements\n * Image enhancement algorithms\n */\nexport class GPUEnhancements extends SpeedyProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            // normalize a greyscale image\n            .declare('_normalizeGreyscaleImage', normalizeGreyscaleImage)\n\n            // normalize a colored image\n            .declare('_normalizeColoredImage', normalizeColoredImage)\n\n            // nightvision\n            .declare('_nightvision', nightvision)\n            .declare('_nightvisionGreyscale', nightvisionGreyscale)\n            .compose('_illuminationMapLo', '_illuminationMapLoX', '_illuminationMapLoY')\n            .declare('_illuminationMapLoX', convX(Utils.gaussianKernel(80, 31)))\n            .declare('_illuminationMapLoY', convY(Utils.gaussianKernel(80, 31)))\n            .compose('_illuminationMap', '_illuminationMapX', '_illuminationMapY')\n            .declare('_illuminationMapX', convX(Utils.gaussianKernel(80, 63)))\n            .declare('_illuminationMapY', convY(Utils.gaussianKernel(80, 63)))\n            .compose('_illuminationMapHi', '_illuminationMapHiX', '_illuminationMapHiY')\n            .declare('_illuminationMapHiX', convX(Utils.gaussianKernel(80, 255)))\n            .declare('_illuminationMapHiY', convY(Utils.gaussianKernel(80, 255)))\n        ;\n    }\n\n    /**\n     * Normalize a greyscale image\n     * @param {SpeedyTexture} image greyscale image (RGB components are the same)\n     * @param {number} [minValue] minimum desired pixel intensity (from 0 to 255, inclusive)\n     * @param {number} [maxValue] maximum desired pixel intensity (from 0 to 255, inclusive)\n     * @returns {SpeedyTexture}\n     */\n    normalizeGreyscaleImage(image, minValue = 0, maxValue = 255)\n    {\n        const gpu = this._gpu;\n        const minmax2d = gpu.programs.utils._scanMinMax(image, PixelComponent.GREEN);\n        return this._normalizeGreyscaleImage(minmax2d, Math.min(minValue, maxValue), Math.max(minValue, maxValue));\n    }\n\n    /**\n     * Normalize a RGB image\n     * @param {SpeedyTexture} image\n     * @param {number} [minValue] minimum desired pixel intensity (from 0 to 255, inclusive)\n     * @param {number} [maxValue] maximum desired pixel intensity (from 0 to 255, inclusive)\n     * @returns {SpeedyTexture}\n     */\n    normalizeColoredImage(image, minValue = 0, maxValue = 255)\n    {\n        const gpu = this._gpu;\n        \n        // TODO: normalize on a luminance channel instead (e.g., use HSL color space)\n        const minmax2d = new Array(3);\n        minmax2d[0] = gpu.programs.utils._scanMinMax(image, PixelComponent.RED).clone();\n        minmax2d[1] = gpu.programs.utils._scanMinMax(image, PixelComponent.GREEN).clone();\n        minmax2d[2] = gpu.programs.utils._scanMinMax(image, PixelComponent.BLUE);\n\n        const normalized = this._normalizeColoredImage(minmax2d, Math.min(minValue, maxValue), Math.max(minValue, maxValue));\n\n        minmax2d[1].release();\n        minmax2d[0].release();\n\n        return normalized;\n    }\n\n    /**\n     * Nightvision filter: \"see in the dark\"\n     * @param {SpeedyTexture} image\n     * @param {number} [gain] typically in [0,1]; higher values => higher contrast\n     * @param {number} [offset] brightness, typically in [0,1]\n     * @param {number} [decay] gain decay, in the [0,1] range\n     * @param {string} [quality] \"high\" | \"medium\" | \"low\" (more quality -> more expensive)\n     * @param {boolean} [greyscale] use the greyscale variant of the algorithm\n     * @returns {SpeedyTexture}\n     */\n    nightvision(image, gain = 0.5, offset = 0.5, decay = 0.0, quality = 'medium', greyscale = false)\n    {\n        // compute illumination map\n        let illuminationMap = null;\n        if(quality == 'medium')\n            illuminationMap = this._illuminationMap(image);\n        else if(quality == 'high')\n            illuminationMap = this._illuminationMapHi(image);\n        else if(quality == 'low')\n            illuminationMap = this._illuminationMapLo(image);\n        else\n            throw new IllegalArgumentError(`Invalid quality level for nightvision: \"${quality}\"`);\n\n        // run nightvision\n        const strategy = greyscale ? this._nightvisionGreyscale : this._nightvision;\n        const enhancedImage = strategy(image, illuminationMap, gain, offset, decay);\n        return enhancedImage;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * filters.js\n * Image filtering on the GPU\n */\n\nimport { SpeedyProgramGroup } from '../speedy-program-group';\nimport { importShader } from '../shader-declaration';\nimport { convX, convY } from '../shaders/filters/convolution';\nimport { Utils } from '../../utils/utils';\n\n\n\n// Convolution\nconst convolution = [3, 5, 7].reduce((obj, ksize) => ((obj[ksize] =\n                        importShader('filters/convolution2d.glsl')\n                       .withDefines({ 'KERNEL_SIZE_SQUARED': ksize * ksize })\n                       .withArguments('image', 'kernel')\n                    ), obj), {});\n\n// Separable convolution\nconst convolutionX = [3, 5, 7, 9, 11, 13, 15].reduce((obj, ksize) => ((obj[ksize] =\n                         importShader('filters/convolution1d.glsl')\n                        .withDefines({ 'KERNEL_SIZE': ksize, 'AXIS': 0 })\n                        .withArguments('image', 'kernel')\n                     ), obj), {});\n\nconst convolutionY = [3, 5, 7, 9, 11, 13, 15].reduce((obj, ksize) => ((obj[ksize] =\n                         importShader('filters/convolution1d.glsl')\n                        .withDefines({ 'KERNEL_SIZE': ksize, 'AXIS': 1 })\n                        .withArguments('image', 'kernel')\n                     ), obj), {});\n// Median filter\nconst median = [3, 5, 7].reduce((obj, ksize) => ((obj[ksize] =\n                   importShader('filters/fast-median.glsl')\n                  .withDefines({ 'KERNEL_SIZE': ksize })\n                  .withArguments('image')\n               ), obj), {});\n\n\n\n//\n// Utilities\n//\n\n// Handy conversion for Gaussian filters\n// (symmetric kernel, approx. zero after 3*sigma)\nconst ksize2sigma = ksize => Math.max(1.0, ksize / 6.0);\n\n/**\n * GPUFilters\n * Image filtering\n */\nexport class GPUFilters extends SpeedyProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            // gaussian filters\n            .compose('gauss3', '_gauss3x', '_gauss3y') // size: 3x3 (sigma ~ 1.0)\n            .compose('gauss5', '_gauss5x', '_gauss5y') // size: 5x5 (sigma ~ 1.0)\n            .compose('gauss7', '_gauss7x', '_gauss7y') // size: 7x7\n            .compose('gauss9', '_gauss9x', '_gauss9y') // size: 9x9\n            .compose('gauss11', '_gauss11x', '_gauss11y') // size: 11x11\n\n            // box filters\n            .compose('box3', '_box3x', '_box3y') // size: 3x3\n            .compose('box5', '_box5x', '_box5y') // size: 5x5\n            .compose('box7', '_box7x', '_box7y') // size: 7x7\n            .compose('box9', '_box9x', '_box9y') // size: 9x9\n            .compose('box11', '_box11x', '_box11y') // size: 11x11\n\n            // median filters\n            .declare('median3', median[3]) // 3x3 window\n            .declare('median5', median[5]) // 5x5 window\n            .declare('median7', median[7]) // 7x7 window\n\n            // convolution\n            .declare('convolution3', convolution[3]) // 3x3 kernel\n            .declare('convolution5', convolution[5]) // 5x5 kernel\n            .declare('convolution7', convolution[7]) // 7x7 kernel\n\n            // separable convolution\n            .declare('convolution3x', convolutionX[3]) // 1x3 kernel\n            .declare('convolution3y', convolutionY[3]) // 3x1 kernel\n            .declare('convolution5x', convolutionX[5]) // 1x5 kernel\n            .declare('convolution5y', convolutionY[5]) // 5x1 kernel\n            .declare('convolution7x', convolutionX[7])\n            .declare('convolution7y', convolutionY[7])\n            .declare('convolution9x', convolutionX[9])\n            .declare('convolution9y', convolutionY[9])\n            .declare('convolution11x', convolutionX[11])\n            .declare('convolution11y', convolutionY[11])\n            .declare('convolution13x', convolutionX[13])\n            .declare('convolution13y', convolutionY[13])\n            .declare('convolution15x', convolutionX[15])\n            .declare('convolution15y', convolutionY[15])\n\n            // separable kernels (Gaussian)\n            // see also: http://dev.theomader.com/gaussian-kernel-calculator/\n            .declare('_gauss3x', convX([ // sigma ~ 1.0\n                0.25, 0.5, 0.25\n                //0.27901, 0.44198, 0.27901\n            ]))\n            .declare('_gauss3y', convY([\n                0.25, 0.5, 0.25\n                //0.27901, 0.44198, 0.27901\n            ]))\n            .declare('_gauss5x', convX([ // sigma ~ 1.0\n                0.05, 0.25, 0.4, 0.25, 0.05\n                //0.06136, 0.24477, 0.38774, 0.24477, 0.06136\n            ]))\n            .declare('_gauss5y', convY([\n                0.05, 0.25, 0.4, 0.25, 0.05\n                //0.06136, 0.24477, 0.38774, 0.24477, 0.06136\n            ]))\n            /*.declare('_gauss5', conv2D([ // for testing\n                1, 4, 7, 4, 1,\n                4, 16, 26, 16, 4,\n                7, 26, 41, 26, 7,\n                4, 16, 26, 16, 4,\n                1, 4, 7, 4, 1,\n            ], 1 / 237))*/\n            .declare('_gauss7x', convX(Utils.gaussianKernel(ksize2sigma(7), 7)))\n            .declare('_gauss7y', convY(Utils.gaussianKernel(ksize2sigma(7), 7)))\n            .declare('_gauss9x', convX(Utils.gaussianKernel(ksize2sigma(9), 9)))\n            .declare('_gauss9y', convY(Utils.gaussianKernel(ksize2sigma(9), 9)))\n            .declare('_gauss11x', convX(Utils.gaussianKernel(ksize2sigma(11), 11)))\n            .declare('_gauss11y', convY(Utils.gaussianKernel(ksize2sigma(11), 11)))\n\n            // separable kernels (Box filter)\n            .declare('_box3x', convX((new Array(3)).fill(1 / 3)))\n            .declare('_box3y', convY((new Array(3)).fill(1 / 3)))\n            .declare('_box5x', convX((new Array(5)).fill(1 / 5)))\n            .declare('_box5y', convY((new Array(5)).fill(1 / 5)))\n            .declare('_box7x', convX((new Array(7)).fill(1 / 7)))\n            .declare('_box7y', convY((new Array(7)).fill(1 / 7)))\n            .declare('_box9x', convX((new Array(9)).fill(1 / 9)))\n            .declare('_box9y', convY((new Array(9)).fill(1 / 9)))\n            .declare('_box11x', convX((new Array(11)).fill(1 / 11)))\n            .declare('_box11y', convY((new Array(11)).fill(1 / 11)))\n        ;\n    }\n}\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * keypoints.js\n * Facade for various keypoint detection algorithms\n */\n\nimport { SpeedyProgramGroup } from '../speedy-program-group';\nimport { SpeedyTexture, SpeedyDrawableTexture } from '../speedy-texture';\nimport { importShader } from '../shader-declaration';\nimport { FeatureEncoder } from '../../core/keypoints/feature-encoder';\nimport { PYRAMID_MAX_LEVELS } from '../../utils/globals';\nimport { Utils } from '../../utils/utils';\n\n\n// FAST corner detector\nconst fast9_16 = importShader('keypoints/fast.glsl')\n                .withDefines({ 'FAST_TYPE': 916 })\n                .withArguments('corners', 'pyramid', 'lod', 'threshold');\n\nconst fastScoreTo8bits = importShader('keypoints/score-8bits.glsl')\n                        .withDefines({ 'METHOD': 0 })\n                        .withArguments('corners');\n\n// Harris corner detector\nconst harris = [1, 3, 5, 7].reduce((obj, win) => ((obj[win] =\n                   importShader('keypoints/harris.glsl')\n                  .withDefines({ 'WINDOW_SIZE': win })\n                  .withArguments('corners', 'derivatives', 'lod')\n               ), obj), {});\n\nconst harrisDerivatives = importShader('keypoints/harris-derivatives.glsl')\n                         .withArguments('pyramid', 'lod');\n\nconst harrisScoreFindMax = importShader('keypoints/score-findmax.glsl')\n                          .withArguments('corners', 'iterationNumber');\n\nconst harrisScoreCutoff = importShader('keypoints/harris-cutoff.glsl')\n                         .withArguments('corners', 'maxScore', 'quality');\n\nconst harrisScoreTo8bits = importShader('keypoints/score-8bits.glsl')\n                          .withDefines({ 'METHOD': 1 })\n                          .withArguments('corners');\n// ORB descriptors\nconst orbDescriptor = importShader('keypoints/orb-descriptor.glsl')\n                     .withArguments('pyramid', 'encodedCorners', 'extraSize', 'encoderLength');\n\nconst orbOrientation = importShader('keypoints/orb-orientation.glsl')\n                      .withArguments('pyramid', 'encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength');\n\n// Non-maximum suppression\nconst nonMaxSuppression = importShader('keypoints/nonmax-suppression.glsl')\n                         .withDefines({ 'MULTISCALE': 0 })\n                         .withArguments('image', 'lodStep');\n\nconst multiscaleNonMaxSuppression = importShader('keypoints/nonmax-suppression.glsl')\n                                   .withDefines({ 'MULTISCALE': 1 })\n                                   .withArguments('image', 'lodStep');\n\n// Keypoint sorting\nconst sortCreatePermutation = importShader('keypoints/sort-createperm.glsl')\n                             .withArguments('encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength');\n\nconst sortMergePermutation = importShader('keypoints/sort-mergeperm.glsl')\n                            .withArguments('permutation', 'blockSize', 'dblLog2BlockSize');\n\nconst sortApplyPermutation = importShader('keypoints/sort-applyperm.glsl')\n                            .withArguments('permutation', 'maxKeypoints', 'encodedKeypoints', 'descriptorSize', 'extraSize');\n\n// Keypoint encoders\nconst expandEncoder = importShader('keypoints/expand-encoder.glsl')\n                     .withArguments('encodedKeypoints', 'inputDescriptorSize', 'inputExtraSize', 'inputEncoderLength', 'outputDescriptorSize', 'outputExtraSize', 'outputEncoderLength');\n\nconst transferOrientation = importShader('keypoints/transfer-orientation.glsl')\n                           .withArguments('encodedOrientations', 'encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength');\n\nconst suppressDescriptors = importShader('keypoints/suppress-descriptors.glsl')\n                           .withArguments('encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength', 'suppressedEncoderLength');\n\nconst uploadKeypoints = importShader('keypoints/upload-keypoints.glsl')\n                       .withDefines({\n                            // UBOs can hold at least 16KB of data;\n                            // gl.MAX_UNIFORM_BLOCK_SIZE >= 16384\n                            // according to the GL ES 3 reference.\n                            // Each keypoint uses 16 bytes (vec4)\n                           'BUFFER_SIZE': 1024 //16384 / 16\n                        })\n                       .withArguments('encodedKeypoints', 'startIndex', 'endIndex', 'descriptorSize', 'extraSize', 'encoderLength');\n\nconst mixKeypoints = importShader('keypoints/mix-keypoints.glsl')\n                    .withArguments('encodedKeypoints', 'encoderLength', 'encoderCapacity', 'descriptorSize', 'extraSize', 'outEncoderLength');\n\n\n\n\n// --- OLD (TODO remove) ---\n\n\n//\n// FAST corner detector\n//\n\n// FAST-9_16: requires 9 contiguous pixels\n// on a circumference of 16 pixels\nconst fast9 = importShader('keypoints/fast/fast9.glsl').withArguments('image', 'threshold');\n\n// FAST-7_12: requires 7 contiguous pixels\n// on a circumference of 12 pixels\nconst fast7 = importShader('keypoints/fast/fast7.glsl').withArguments('image', 'threshold');\n\n// FAST-5_8: requires 5 contiguous pixels\n// on a circumference of 8 pixels\nconst fast5 = importShader('keypoints/fast/fast5.glsl').withArguments('image', 'threshold');\n\n// compute corner score considering a\n// neighboring circumference of 16 pixels\nconst fastScore16 = importShader('keypoints/fast/fast-score16.glsl').withArguments('image', 'threshold');\n\n// compute corner score considering a\n// neighboring circumference of 12 pixels\nconst fastScore12 = importShader('keypoints/fast/fast-score12.glsl').withArguments('image', 'threshold');\n\n// compute corner score considering a\n// neighboring circumference of 8 pixels\nconst fastScore8 = importShader('keypoints/fast/fast-score8.glsl').withArguments('image', 'threshold');\n\n// FAST-9_16 on scale-space\n// Requires image mipmap\nconst multiscaleFast = importShader('keypoints/fast/multiscale-fast.glsl')\n                      .withArguments('pyramid', 'threshold', 'numberOfLayers', 'lodStep');\n\n// encode FAST score in an 8-bit component\nconst encodeFastScore = fastScoreTo8bits;\n\n\n\n//\n// Harris-Shi-Tomasi corner detector\n//\n\n// compute corner responses (score map)\nconst multiscaleHarris = importShader('keypoints/harris/multiscale-harris.glsl')\n                        .withDefines({ 'MAX_LAYERS': 2 * PYRAMID_MAX_LEVELS - 1 })\n                        .withArguments('pyramid', 'windowSize', 'numberOfLayers', 'lodStep', 'sobelDerivatives');\n\n// discard corners below a specified quality level\nconst harrisCutoff = harrisScoreCutoff;\n\n// encode harris score in an 8-bit component\nconst encodeHarrisScore = importShader('keypoints/harris/encode-harris-score.glsl').withArguments('image');\n\n// find the maximum harris score in an image\nconst maxHarrisScore = harrisScoreFindMax;\n\n// Sobel derivatives\nconst multiscaleSobel = importShader('keypoints/harris/multiscale-sobel.glsl').withArguments('pyramid', 'lod');\n\n\n\n//\n// BRISK feature detection\n//\nconst brisk = importShader('keypoints/brisk.glsl')\n             .withArguments('image', 'layerA', 'layerB', 'scaleA', 'scaleB', 'lgM', 'h');\n\n\n\n\n\n\n//\n// Generic keypoint routines\n//\n\n\n\n/**\n * GPUKeypoints\n * Keypoint detection\n */\nexport class GPUKeypoints extends SpeedyProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            //\n            // FAST corner detector\n            //\n            .declare('fast9_16', fast9_16, {\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('fastScoreTo8bits', fastScoreTo8bits)\n\n            //\n            // Harris corner detector\n            //\n            .declare('harris1', harris[1], {\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('harris3', harris[3], {\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('harris5', harris[5], {\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('harris7', harris[7], {\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('harrisDerivatives', harrisDerivatives)\n            .declare('harrisScoreFindMax', harrisScoreFindMax, {\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('harrisScoreCutoff', harrisScoreCutoff)\n            .declare('harrisScoreTo8bits', harrisScoreTo8bits)\n\n            //\n            // ORB descriptors\n            //\n            .declare('orbDescriptor', orbDescriptor)\n            .declare('orbOrientation', orbOrientation)\n\n            //\n            // Non-maximum suppression\n            //\n            .declare('nonmax', nonMaxSuppression)\n            .declare('pyrnonmax', multiscaleNonMaxSuppression)\n\n            //\n            // Keypoint sorting\n            //\n            .declare('sortCreatePermutation', sortCreatePermutation)\n            .declare('sortMergePermutation', sortMergePermutation, {\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('sortApplyPermutation', sortApplyPermutation)\n\n            //\n            // Keypoint encoders\n            //\n            .declare('expandEncoder', expandEncoder)\n            .declare('transferOrientation', transferOrientation)\n            .declare('suppressDescriptors', suppressDescriptors)\n            .declare('uploadKeypoints', uploadKeypoints, {\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('mixKeypoints', mixKeypoints)\n\n\n\n            // --- OLD (TODO remove) ---\n\n            // FAST-9,16\n            .compose('fast9', '_fast9', '_fastScore16')\n            .declare('_fast9', fast9) // find corners\n            .declare('_fastScore16', fastScore16) // compute scores\n\n            // FAST-7,12\n            .compose('fast7', '_fast7', '_fastScore12')\n            .declare('_fast7', fast7)\n            .declare('_fastScore12', fastScore12)\n\n            // FAST-5,8\n            .compose('fast5', '_fast5', '_fastScore8')\n            .declare('_fast5', fast5)\n            .declare('_fastScore8', fastScore8)\n\n            // FAST-9,16 (multi-scale)\n            .declare('multiscaleFast', multiscaleFast)\n            .declare('encodeFastScore', encodeFastScore)\n\n            // BRISK Scale-Space Non-Maximum Suppression & Interpolation\n            .declare('brisk', brisk)\n\n            // Harris-Shi-Tomasi corner detector\n            .declare('multiscaleHarris', multiscaleHarris) // scale-space\n            .declare('harrisCutoff', harrisCutoff)\n            .declare('encodeHarrisScore', encodeHarrisScore)\n            .declare('maxHarrisScore', maxHarrisScore, {\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('multiscaleSobel', multiscaleSobel) // scale-space\n\n            // Non-maximum suppression\n            .declare('_nonMaxSuppression', nonMaxSuppression)\n            .declare('_multiscaleNonMaxSuppression', multiscaleNonMaxSuppression)\n        ;\n    }\n\n    /**\n     * Non-maximum suppression\n     * @param {SpeedyTexture} corners scores are encoded as float16\n     * @param {number} [lodStep] log2(scaleFactor) - specify if multi-scale\n     * @returns {SpeedyDrawableTexture}\n     */\n    nonMaxSuppression(corners, lodStep = 0)\n    {\n        if(lodStep > 0)\n            return this._multiscaleNonMaxSuppression(corners, lodStep);\n        else\n            return this._nonMaxSuppression(corners, 0);\n    }\n\n    /**\n     * Compute ORB descriptor (256 bits)\n     * @param {SpeedyTexture} pyramid pre-smoothed on the intensity channel\n     * @param {SpeedyTexture} encodedKeypoints tiny texture\n     * @param {number} descriptorSize in bytes\n     * @param {number} extraSize in bytes\n     * @param {number} encoderLength\n     * @returns {SpeedyDrawableTexture}\n     */\n    orbOld(pyramid, encodedKeypoints, descriptorSize, extraSize, encoderLength)\n    {\n        Utils.assert(descriptorSize === 32);\n        this.orbDescriptor.setOutputSize(encoderLength, encoderLength);\n        return this.orbDescriptor(pyramid, encodedKeypoints, extraSize, encoderLength);\n    }\n\n    /**\n     * Finds the orientation of all keypoints given a texture with encoded keypoints\n     * (using the centroid method, as in ORB)\n     * @param {SpeedyTexture} pyramid image pyramid\n     * @param {SpeedyTexture} encodedKeypoints tiny texture\n     * @param {number} descriptorSize in bytes\n     * @param {number} extraSize in bytes\n     * @param {number} encoderLength\n     * @returns {SpeedyDrawableTexture}\n     */\n    orbOrientationOld(pyramid, encodedKeypoints, descriptorSize, extraSize, encoderLength)\n    {\n        const numberOfKeypoints = FeatureEncoder.capacity(descriptorSize, extraSize, encoderLength);\n        const orientationEncoderLength = Math.max(1, Math.ceil(Math.sqrt(numberOfKeypoints))); // 1 pixel per keypoint\n\n        this.orbOrientation.setOutputSize(orientationEncoderLength, orientationEncoderLength);\n        const encodedOrientations = this.orbOrientation(pyramid, encodedKeypoints, descriptorSize, extraSize, encoderLength);\n\n        this.transferOrientation.setOutputSize(encoderLength, encoderLength);\n        return this.transferOrientation(encodedOrientations, encodedKeypoints, descriptorSize, extraSize, encoderLength);\n    }\n\n    /**\n     * Suppress feature descriptors from a texture with encoded keypoints\n     * @param {SpeedyTexture} encodedKeypoints tiny texture\n     * @param {number} descriptorSize in bytes\n     * @param {number} extraSize in bytes\n     * @param {number} encoderLength\n     * @param {number} suppressedEncoderLength equivalent to encoderLength, but without the descriptors\n     * @returns {SpeedyDrawableTexture}\n     */\n    suppressDescriptorsOld(encodedKeypoints, descriptorSize, extraSize, encoderLength, suppressedEncoderLength)\n    {\n        Utils.assert(suppressedEncoderLength <= encoderLength);\n        this.suppressDescriptors.setOutputSize(suppressedEncoderLength, suppressedEncoderLength);\n        return this.suppressDescriptors(encodedKeypoints, descriptorSize, extraSize, encoderLength, suppressedEncoderLength);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * pyramids.js\n * Image pyramids\n */\n\nimport { SpeedyProgramGroup } from '../speedy-program-group';\nimport { SpeedyGPU } from '../speedy-gpu';\nimport { SpeedyProgram } from '../speedy-program';\nimport { SpeedyTexture, SpeedyDrawableTexture } from '../speedy-texture';\nimport { importShader } from '../shader-declaration';\nimport { convX, convY } from '../shaders/filters/convolution';\nimport { IllegalOperationError } from '../../utils/errors';\n\n\n\n//\n// Shaders\n//\n\n// pyramid generation\nconst upsample2 = importShader('pyramids/upsample2.glsl').withArguments('image');\nconst downsample2 = importShader('pyramids/downsample2.glsl').withArguments('image');\n//const upsample3 = importShader('pyramids/upsample3.glsl').withArguments('image');\n//const downsample3 = importShader('pyramids/downsample3.glsl').withArguments('image');\n\n// debug\n//const flipY = importShader('utils/flip-y.glsl').withArguments('image');\n\n\n\n/**\n * GPUPyramids\n * Image pyramids\n */\nexport class GPUPyramids extends SpeedyProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            // upsampling & downsampling\n            .declare('upsample2', upsample2, {\n                ...(this.program.hasTextureSize(2 * this._width, 2 * this._height))\n            })\n\n            .declare('downsample2', downsample2, {\n                ...(this.program.hasTextureSize(Math.max(1, Math.floor(this._width / 2)), Math.max(1, Math.floor(this._height / 2))))\n            })\n\n            // separable kernels for gaussian smoothing\n            // use [c, b, a, b, c] where a+2c = 2b and a+2b+2c = 1\n            // pick a = 0.4 for gaussian approximation\n            .declare('smoothX', convX([\n                0.05, 0.25, 0.4, 0.25, 0.05\n            ]))\n            .declare('smoothY', convY([\n                0.05, 0.25, 0.4, 0.25, 0.05\n            ]))\n\n            // smoothing for 2x image\n            // same rules as above with sum(k) = 2\n            .declare('smoothX2', convX([\n                0.1, 0.5, 0.8, 0.5, 0.1 // NOTE: this would saturate the image, but we apply it on a 2x upsampled version with lots of zero pixels\n            ]), {\n                ...(this.program.hasTextureSize(2 * this._width, 2 * this._height))\n            })\n\n            .declare('smoothY2', convY([\n                0.1, 0.5, 0.8, 0.5, 0.1\n            ], 1.0 / 2.0), {\n                ...(this.program.hasTextureSize(2 * this._width, 2 * this._height))\n            })\n\n\n            // --- OLD shaders ---\n\n            // pyramid operations (scale = 2)\n            .compose('_reduce', '_smoothX', '_smoothY', '_downsample2')\n            .compose('_expand', '_upsample2', '_smoothX2', '_smoothY2')\n           \n            /*\n            // intra-pyramid operations (scale = 1.5)\n            .compose('_intraReduce', '_upsample2', '_smoothX2', '_smoothY2', '_downsample3/2')\n            .compose('_intraExpand', '_upsample3', '_smoothX3', '_smoothY3', '_downsample2/3')\n            */\n\n            /*\n            // utilities for debugging\n            .declare('output1', flipY, {\n                ...this.program.hasTextureSize(this._width, this._height),\n                ...this.program.rendersToCanvas()\n            })\n\n            .declare('outputHalf', flipY, {\n                ...this.program.hasTextureSize(Math.floor(this._width / 2), Math.floor(this._height / 2)),\n                ...this.program.rendersToCanvas()\n            })\n\n            .declare('output2', flipY, {\n                ...this.program.hasTextureSize(2 * this._width, 2 * this._height),\n                ...this.program.rendersToCanvas()\n            })\n            */\n            \n            // separable kernels for gaussian smoothing\n            // use [c, b, a, b, c] where a+2c = 2b and a+2b+2c = 1\n            // pick a = 0.4 for gaussian approximation\n            .declare('_smoothX', convX([\n                0.05, 0.25, 0.4, 0.25, 0.05\n            ]))\n            .declare('_smoothY', convY([\n                0.05, 0.25, 0.4, 0.25, 0.05\n            ]))\n\n            // smoothing for 2x image\n            // same rules as above with sum(k) = 2\n            .declare('_smoothX2', convX([\n                0.1, 0.5, 0.8, 0.5, 0.1 // NOTE: this would saturate the image, but we apply it on a 2x upsampled version with lots of zero pixels\n            ]), {\n                ...(this.program.hasTextureSize(2 * this._width, 2 * this._height))\n            })\n\n            .declare('_smoothY2', convY([\n                0.1, 0.5, 0.8, 0.5, 0.1\n            ], 1.0 / 2.0), {\n                ...(this.program.hasTextureSize(2 * this._width, 2 * this._height))\n            })\n\n            /*\n            // smoothing for 3x image\n            // use [1-b, b, 1, b, 1-b], where 0 < b < 1\n            .declare('_smoothX3', convX([\n                0.2, 0.8, 1.0, 0.8, 0.2\n            ]), this.program.hasTextureSize(3 * this._width, 3 * this._height))\n\n            .declare('_smoothY3', convY([\n                0.2, 0.8, 1.0, 0.8, 0.2\n            ], 1.0 / 3.0), this.program.hasTextureSize(3 * this._width, 3 * this._height))\n            */\n\n            // upsampling & downsampling\n            .declare('_upsample2', upsample2, {\n                ...(this.program.hasTextureSize(2 * this._width, 2 * this._height))\n            })\n\n            .declare('_downsample2', downsample2, {\n                ...(this.program.hasTextureSize(Math.max(1, Math.floor(this._width / 2)), Math.max(1, Math.floor(this._height / 2))))\n            })\n\n            /*\n            .declare('_upsample3', upsample3,\n                this.program.hasTextureSize(3 * this._width, 3 * this._height))\n\n            .declare('_downsample3', downsample3,\n                this.program.hasTextureSize(Math.floor(this._width / 3), Math.floor(this._height / 3)))\n\n            .declare('_downsample2/3', downsample2,\n                this.program.hasTextureSize(Math.floor(3 * this._width / 2), Math.floor(3 * this._height / 2)))\n\n            .declare('_downsample3/2', downsample3,\n                this.program.hasTextureSize(Math.floor(2 * this._width / 3), Math.floor(2 * this._height / 3)))\n            */\n        ;\n    }\n\n    /**\n     * Reduce the image (0.5x)\n     * @param {SpeedyTexture} image\n     * @returns {SpeedyDrawableTexture}\n     */\n    reduce(image)\n    {\n        return this._reduce(image);\n    }\n\n    /**\n     * Expand the image (2x)\n     * @param {SpeedyTexture} image\n     * @returns {SpeedyDrawableTexture}\n     */\n    expand(image)\n    {\n        return this._expand(image);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * trackers.js\n * Feature trackers\n */\n\nimport { SpeedyProgramGroup } from '../speedy-program-group';\nimport { importShader } from '../shader-declaration';\nimport { PYRAMID_MAX_LEVELS } from '../../utils/globals';\nimport { FeatureEncoder } from '../../core/keypoints/feature-encoder';\n\n\n\n//\n// Shaders\n//\n\n// LK\nconst LK_MAX_WINDOW_SIZE = 21; // 21x21 window\nconst LK_MAX_WINDOW_SIZE_SMALL = 15; // 15x15 window - the smaller the window, the easier it is on the GPU\nconst LK_MAX_WINDOW_SIZE_SMALLER = 11; // 11x11 window - works best on mobile\nconst LK_MAX_WINDOW_SIZE_SMALLEST = 7; // 7x7 window\nconst LK_MIN_WINDOW_SIZE = 5; // 5x5 window: (-2, -1, 0, 1, 2) x (-2, -1, 0, 1, 2)\n\nconst lk = importShader('trackers/lk.glsl')\n           .withArguments('encodedFlow', 'prevKeypoints', 'nextPyramid', 'prevPyramid', 'windowSize', 'level', 'depth', 'numberOfIterations', 'discardThreshold', 'epsilon', 'descriptorSize', 'extraSize', 'encoderLength')\n           .withDefines({\n               'MAX_WINDOW_SIZE': LK_MAX_WINDOW_SIZE,\n           });\n\nconst lkSmall = importShader('trackers/lk.glsl')\n                .withArguments('encodedFlow', 'prevKeypoints', 'nextPyramid', 'prevPyramid', 'windowSize', 'level', 'depth', 'numberOfIterations', 'discardThreshold', 'epsilon', 'descriptorSize', 'extraSize', 'encoderLength')\n                .withDefines({\n                    'MAX_WINDOW_SIZE': LK_MAX_WINDOW_SIZE_SMALL,\n                });\n\nconst lkSmaller = importShader('trackers/lk.glsl')\n                  .withArguments('encodedFlow', 'prevKeypoints', 'nextPyramid', 'prevPyramid', 'windowSize', 'level', 'depth', 'numberOfIterations', 'discardThreshold', 'epsilon', 'descriptorSize', 'extraSize', 'encoderLength')\n                  .withDefines({\n                      'MAX_WINDOW_SIZE': LK_MAX_WINDOW_SIZE_SMALLER,\n                  });\n\nconst lkSmallest = importShader('trackers/lk.glsl')\n                   .withArguments('encodedFlow', 'prevKeypoints', 'nextPyramid', 'prevPyramid', 'windowSize', 'level', 'depth', 'numberOfIterations', 'discardThreshold', 'epsilon', 'descriptorSize', 'extraSize', 'encoderLength')\n                   .withDefines({\n                       'MAX_WINDOW_SIZE': LK_MAX_WINDOW_SIZE_SMALLEST,\n                   });\n\nconst lkDiscardOld = importShader('trackers/lk-discard-old.glsl')\n                     .withArguments('pyramid', 'encodedKeypoints', 'windowSize', 'discardThreshold', 'descriptorSize', 'extraSize', 'encoderLength');\n\nconst lkDiscard = importShader('trackers/lk-discard.glsl')\n                  .withArguments('pyramid', 'windowSize', 'encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength');\n\nconst transferFlow = importShader('trackers/transfer-flow.glsl')\n                     .withArguments('encodedFlow', 'encodedKeypoints', 'descriptorSize', 'extraSize', 'encoderLength');\n\n\n/**\n * GPUTrackers\n * Feature trackers\n */\nexport class GPUTrackers extends SpeedyProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            // LK optical-flow\n            .declare('lk21', lk, { // up to 21x21 window\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('lk15', lkSmall, { // up to 15x15 window\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('lk11', lkSmaller, { // up to 11x11 window (nice on mobile)\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('lk7', lkSmallest, { // up to 7x7 window (faster)\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('lkDiscard', lkDiscard)\n\n            // Transfer optical-flow\n            .declare('transferFlow', transferFlow)\n\n\n\n\n            // --- old TOOD remove ---\n\n            // LK\n            .declare('_lk', lk, {\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('_lkSmall', lkSmall, {\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('_lkSmaller', lkSmaller, {\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('_lkSmallest', lkSmallest, {\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('_lkDiscard', lkDiscardOld)\n\n            // Transfer optical-flow\n            .declare('_transferFlow', transferFlow)\n        ;\n    }\n\n    /**\n     * LK feature tracker\n     * @param {SpeedyTexture} nextPyramid image pyramid at time t\n     * @param {SpeedyTexture} prevPyramid image pyramid at time t-1\n     * @param {SpeedyTexture} prevKeypoints tiny texture of encoded keypoints at time t-1\n     * @param {number} windowSize neighborhood size, an odd number (5, 7, 9, 11...)\n     * @param {number} depth how many pyramid layers will be scanned\n     * @param {number} numberOfIterations for iterative LK\n     * @param {number} discardThreshold used to discard \"bad\" keypoints, typically 10^(-4)\n     * @param {number} epsilon accuracy threshold to stop iterations, typically 0.01\n     * @param {number} descriptorSize in bytes\n     * @param {number} extraSize in bytes\n     * @param {number} encoderLength\n     * @returns {SpeedyTexture}\n     */\n    lk(nextPyramid, prevPyramid, prevKeypoints, windowSize, depth, numberOfIterations, discardThreshold, epsilon, descriptorSize, extraSize, encoderLength)\n    {\n        // make sure we get a proper depth\n        const MIN_DEPTH = 1, MAX_DEPTH = PYRAMID_MAX_LEVELS;\n        depth = Math.max(MIN_DEPTH, Math.min(depth | 0, MAX_DEPTH));\n\n        // windowSize must be a positive odd number\n        windowSize = windowSize + ((windowSize + 1) % 2);\n        windowSize = Math.max(LK_MIN_WINDOW_SIZE, Math.min(windowSize, LK_MAX_WINDOW_SIZE));\n\n        // we want at least one iteration\n        numberOfIterations = Math.max(1, numberOfIterations);\n\n        // select program\n        let lk = null;\n        if(windowSize <= LK_MAX_WINDOW_SIZE_SMALLEST)\n            lk = this._lkSmallest;\n        else if(windowSize <= LK_MAX_WINDOW_SIZE_SMALLER)\n            lk = this._lkSmaller;\n        else if(windowSize <= LK_MAX_WINDOW_SIZE_SMALL)\n            lk = this._lkSmall;\n        else\n            lk = this._lk;\n\n        //\n        // Optimization!\n        // because this is such a demanding algorithm, we'll\n        // split the work into multiple passes of the shader\n        // (so we don't get WebGL context loss on mobile)\n        //\n        const numKeypoints = FeatureEncoder.capacity(descriptorSize, extraSize, encoderLength);\n        const lkEncoderLength = Math.max(1, Math.ceil(Math.sqrt(numKeypoints)));\n        lk.setOutputSize(lkEncoderLength, lkEncoderLength);\n\n        // compute optical-flow\n        let flow = lk.clear();\n        for(let level = depth - 1; level >= 0; level--)\n            flow = lk(flow, prevKeypoints, nextPyramid, prevPyramid, windowSize, level, depth, numberOfIterations, discardThreshold, epsilon, descriptorSize, extraSize, encoderLength);\n\n        // transfer optical-flow to nextKeypoints\n        this._transferFlow.setOutputSize(encoderLength, encoderLength);\n        const nextKeypoints = this._transferFlow(flow, prevKeypoints, descriptorSize, extraSize, encoderLength);\n\n        // discard \"bad\" keypoints\n        this._lkDiscard.setOutputSize(encoderLength, encoderLength);\n        const goodKeypoints = this._lkDiscard(nextPyramid, nextKeypoints, windowSize, discardThreshold, descriptorSize, extraSize, encoderLength);\n\n        // done!\n        return goodKeypoints;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * transforms.js\n * Geometric transformations\n */\n\nimport { SpeedyProgramGroup } from '../speedy-program-group';\nimport { importShader } from '../shader-declaration';\nimport { IllegalArgumentError } from '../../utils/errors';\n\n\n\n//\n// Shaders\n//\n\n// Perspective warp\nconst warpPerspective = importShader('transforms/warp-perspective.glsl').withArguments('image', 'inverseHomography');\n\n// Resize image\nconst resizeNN = importShader('transforms/resize.glsl')\n                 .withDefines({\n                     'INTERPOLATION_METHOD': 0 // Nearest neighbors\n                 })\n                 .withArguments('image');\n\nconst resizeBI = importShader('transforms/resize.glsl')\n                 .withDefines({\n                     'INTERPOLATION_METHOD': 1 // Bilinear interpolation\n                 })\n                 .withArguments('image');\n\n\n/**\n * GPUTransforms\n * Geometric transformations\n */\nexport class GPUTransforms extends SpeedyProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            .declare('_warpPerspective', warpPerspective)\n            .declare('resizeNN', resizeNN)\n            .declare('resizeBI', resizeBI)\n        ;\n    }\n\n    /**\n     * Dense perspective transform\n     * @param {SpeedyTexture} image\n     * @param {number[]} homography 3x3 homography matrix in column-major format\n     * @returns {SpeedyTexture}\n     */\n    warpPerspective(image, homography)\n    {\n        if(!(Array.isArray(homography) && homography.length == 9))\n            throw new IllegalArgumentError(`Not a homography: ${homography}`);\n\n        const inverseHomography = this._inverse3(homography);\n        if(!Number.isNaN(inverseHomography[0]))\n            return this._warpPerspective(image, inverseHomography);\n        else\n            return this._warpPerspective(image, [0,0,0,0,0,0,0,0,1]); // singular matrix\n    }\n\n    /**\n     * Compute the inverse of a 3x3 matrix\n     * @param {number[]} mat 3x3 matrix in column-major format\n     * @returns {number[]} 3x3 inverse matrix in column-major format\n     */\n    _inverse3(mat)\n    {\n        const nan = Number.NaN, eps = 1e-6;\n        const inv = [ nan, nan, nan, nan, nan, nan, nan, nan, nan ];\n\n        // read the entries of the matrix\n        const a11 = mat[0];\n        const a21 = mat[1];\n        const a31 = mat[2];\n        const a12 = mat[3];\n        const a22 = mat[4];\n        const a32 = mat[5];\n        const a13 = mat[6];\n        const a23 = mat[7];\n        const a33 = mat[8];\n\n        // compute cofactors\n        const b1 = a33 * a22 - a32 * a23; // b11\n        const b2 = a33 * a12 - a32 * a13; // b21\n        const b3 = a23 * a12 - a22 * a13; // b31\n\n        // compute the determinant\n        const det = a11 * b1 - a21 * b2 + a31 * b3;\n\n        // set up the inverse\n        if(!(Math.abs(det) < eps)) {\n            const d = 1.0 / det;\n            inv[0] = b1 * d;\n            inv[1] = -(a33 * a21 - a31 * a23) * d;\n            inv[2] = (a32 * a21 - a31 * a22) * d;\n            inv[3] = -b2 * d;\n            inv[4] = (a33 * a11 - a31 * a13) * d;\n            inv[5] = -(a32 * a11 - a31 * a12) * d;\n            inv[6] = b3 * d;\n            inv[7] = -(a23 * a11 - a21 * a13) * d;\n            inv[8] = (a22 * a11 - a21 * a12) * d;\n        }\n\n        // done!\n        return inv;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * utils.js\n * GPU utilities\n */\n\nimport { SpeedyProgramGroup } from '../speedy-program-group';\nimport { SpeedyTexture, SpeedyDrawableTexture } from '../speedy-texture';\nimport { importShader } from '../shader-declaration';\nimport { PixelComponent, ColorComponentId } from '../../utils/types';\nimport { IllegalArgumentError } from '../../utils/errors';\nimport { Utils } from '../../utils/utils';\n\n\n\n//\n// Shaders\n//\n\n// Identity shader: no-operation\nconst identity = importShader('utils/identity.glsl').withArguments('image');\n\n// Flip y-axis for output\nconst flipY = importShader('utils/flip-y.glsl').withArguments('image');\n\n// Fill image with a constant\nconst fill = importShader('utils/fill.glsl').withArguments('value');\n\n// Fill zero or more color components of the input image with a constant value\nconst fillComponents = importShader('utils/fill-components.glsl').withArguments('image', 'pixelComponents', 'value');\n\n// Copy the src component of src to zero or more color components of a copy of dest\nconst copyComponents = importShader('utils/copy-components.glsl').withArguments('dest', 'src', 'destComponents', 'srcComponentId');\n\n// Scan the entire image and find the minimum & maximum pixel intensity for each row and column\n//const scanMinMax1D = importShader('utils/scan-minmax1d.glsl').withArguments('image', 'iterationNumber');\n\n// Scan the entire image and find the minimum & maximum pixel intensity\nconst scanMinMax2D = importShader('utils/scan-minmax2d.glsl').withArguments('image', 'iterationNumber');\n\n\n\n/**\n * GPUUtils\n * Utility operations\n */\nexport class GPUUtils extends SpeedyProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            // no-operation\n            .declare('identity', identity)\n\n            // render to the canvas\n            .declare('_renderToCanvas', flipY, {\n                ...this.program.rendersToCanvas()\n            })\n                \n            // flip y-axis\n            .declare('flipY', flipY)\n\n            // Fill image with a constant\n            .declare('fill', fill)\n\n            // Fill zero or more color components of the input image with a constant value\n            .declare('fillComponents', fillComponents)\n\n            // Copy the src component of src to zero or more color components of a copy of dest\n            .declare('_copyComponents', copyComponents)\n\n            // find minimum & maximum pixel intensity for each row and column\n            /*.declare('_scanMinMax1D', scanMinMax1D, {\n                ...this.program.usesPingpongRendering()\n            })*/\n\n            // find minimum & maximum pixel intensity\n            .declare('_scanMinMax2D', scanMinMax2D, {\n                ...this.program.usesPingpongRendering()\n            })\n        ;\n    }\n\n    /**\n     * Renders an image to (the bottom-left of) the canvas\n     * @param {SpeedyTexture} image\n     * @returns {HTMLCanvasElement} returned for convenience\n     */\n    renderToCanvas(image)\n    {\n        const width = image.width;\n        const height = image.height;\n        const canvas = this._gpu.canvas;\n\n        // do we need to resize the program?\n        if(width != this._renderToCanvas.width || height != this._renderToCanvas.height)\n            this._renderToCanvas.setOutputSize(width, height);\n\n        // do we need to resize the canvas?\n        if(width > canvas.width || height > canvas.height) {\n            Utils.warning(`Resizing the canvas to ${width} x ${height}`);\n            canvas.width = width;\n            canvas.height = height;\n        }\n\n        // render\n        this._renderToCanvas(image);\n\n        // done!\n        return canvas;\n    }\n\n    /**\n     * Scan a single component in all pixels of the image and find the maximum intensity\n     * @param {SpeedyTexture} image \n     * @param {number} pixelComponent a single PixelComponent flag\n     * @returns {SpeedyDrawableTexture} such that pixel[component] = max(image_pixel[component])\n     *                                                           for all image_pixels\n     */\n    scanMax(image, pixelComponent)\n    {\n        const minmax2d = this._scanMinMax(image, pixelComponent);\n        return this.copyComponents(image, minmax2d, pixelComponent, PixelComponent.RED);\n    }\n\n    /**\n     * Scan a single component in all pixels of the image and find the minimum intensity\n     * @param {SpeedyTexture} image \n     * @param {number} pixelComponent a single PixelComponent flag\n     * @returns {SpeedyDrawableTexture} such that pixel[component] = min(image_pixel[component])\n     *                                                           for all image_pixels\n     */\n    scanMin(image, pixelComponent)\n    {\n        const minmax2d = this._scanMinMax(image, pixelComponent);\n        return this.copyComponents(image, minmax2d, pixelComponent, PixelComponent.GREEN);\n    }\n\n    /**\n     * Copy color component\n     * @param {SpeedyTexture} dest\n     * @param {SpeedyTexture} src \n     * @param {number} destComponents one or more PixelComponent flags\n     * @param {number} srcComponent a single PixelComponent flag\n     * @returns {SpeedyDrawableTexture} a copy of dest with its destComponents replaced by the srcComponent of src\n     */\n    copyComponents(dest, src, destComponents, srcComponent)\n    {\n        if(!Object.prototype.hasOwnProperty.call(ColorComponentId, srcComponent))\n            throw new IllegalArgumentError(`Invalid srcComponent: ${srcComponent}`)\n\n        const srcComponentId = ColorComponentId[srcComponent];\n        return this._copyComponents(dest, src, destComponents, srcComponentId);\n    }\n\n    /**\n     * Scan a single component in all pixels of the image and find the min & max intensities\n     * @param {SpeedyTexture} image \n     * @param {number} pixelComponent a single PixelComponent flag\n     * @returns {SpeedyDrawableTexture} RGBA = (max, min, max - min, original_pixel)\n     */\n    _scanMinMax(image, pixelComponent)\n    {\n        //\n        // FIXME: combinations of PixelComponent (e.g., PixelComponent.ALL)\n        //        are currently unsupported. Make separate calls.\n        //\n        const numIterations = Math.ceil(Math.log2(Math.max(this._width, this._height))) | 0;\n        let texture = this.copyComponents(image, image, PixelComponent.ALL, pixelComponent);\n\n        for(let i = 0; i < numIterations; i++)\n            texture = this._scanMinMax2D(texture, i);\n\n        return texture;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * shader-declaration.js\n * Encapsulates a shader declaration\n */\n\nimport { ShaderPreprocessor } from './shader-preprocessor';\nimport { FileNotFoundError, IllegalArgumentError, IllegalOperationError, ParseError } from '../utils/errors';\n\nconst DEFAULT_ATTRIBUTES = Object.freeze({\n    position: 'a_position',\n    texCoord: 'a_texCoord'\n});\n\nconst DEFAULT_ATTRIBUTES_LOCATION = Object.freeze({\n    position: 0, // use location 0; see https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices\n    texCoord: 1,\n});\n\nconst DEFAULT_VERTEX_SHADER = `#version 300 es\nlayout (location=${DEFAULT_ATTRIBUTES_LOCATION.position}) in vec2 ${DEFAULT_ATTRIBUTES.position};\nlayout (location=${DEFAULT_ATTRIBUTES_LOCATION.texCoord}) in vec2 ${DEFAULT_ATTRIBUTES.texCoord};\nout vec2 texCoord;\n\nvoid main() {\n    gl_Position = vec4(${DEFAULT_ATTRIBUTES.position}, 0.0f, 1.0f);\n    texCoord = ${DEFAULT_ATTRIBUTES.texCoord};\n}\\n`;\n\nconst DEFAULT_FRAGMENT_SHADER_PREFIX = `#version 300 es\nprecision highp int; // int32\nprecision mediump float; // ~float16\nprecision mediump sampler2D;\n\nout vec4 color;\nin vec2 texCoord;\nuniform vec2 texSize;\n\n@include \"global.glsl\"\\n\\n`;\n\n/**\n * Shader Declaration\n */\nexport class ShaderDeclaration\n{\n    /**\n     * @private Constructor\n     * @param {object} options\n     * @param {string} [options.filepath]\n     * @param {string} [options.source]\n     */\n    constructor(options)\n    {\n        const filepath = options.filepath || null;\n        const source = filepath ? require('./shaders/' + filepath) : (options.source || '');\n        if(source.length == 0)\n            throw new IllegalArgumentError(`Can't import shader: empty code`);\n\n        /** @type {string} original source code provided by the user */\n        this._userSource = source;\n\n        /** @type {string} preprocessed source code of the vertex shader */\n        this._vertexSource = ShaderPreprocessor.run(DEFAULT_VERTEX_SHADER);\n\n        /** @type {string} preprocessed source code of the fragment shader */\n        this._fragmentSource = ShaderPreprocessor.run(DEFAULT_FRAGMENT_SHADER_PREFIX + this._userSource);\n\n        /** @type {string} the filepath from which the (fragment) shader was imported */\n        this._filepath = filepath || '<in-memory>';\n\n        /** @type {string[]} an ordered list of uniform names */\n        this._arguments = [];\n\n        /** @type {Map<string,string>} it maps uniform names to their types */\n        this._uniforms = this._autodetectUniforms(this._fragmentSource);\n\n        /** @type {Map<string,number>} it maps externally #defined constants to their values */\n        this._defines = new Map();\n    }\n\n    /**\n     * Creates a new Shader directly from a GLSL source\n     * @param {string} source\n     * @returns {ShaderDeclaration}\n     */\n    static create(source)\n    {\n        return new ShaderDeclaration({ source });\n    }\n\n    /**\n     * Import a Shader from a file containing a GLSL source\n     * @param {string} filepath path to .glsl file relative to the shaders/ folder\n     * @returns {ShaderDeclaration}\n     */\n    static import(filepath)\n    {\n        if(!String(filepath).match(/^[a-zA-Z0-9_\\-\\/]+\\.glsl$/))\n            throw new FileNotFoundError(`Can't import shader: \"${filepath}\"`);\n\n        return new ShaderDeclaration({ filepath });\n    }\n\n    /**\n     * Specify the list & order of arguments to be\n     * passed to the shader\n     * @param  {...string} args argument names\n     * @returns {ShaderDeclaration} this\n     */\n    withArguments(...args)\n    {\n        // the list of arguments may be declared only once\n        if(this._arguments.length > 0)\n            throw new IllegalOperationError(`Redefinition of shader arguments`);\n\n        // get arguments\n        this._arguments = args.map(arg => String(arg));\n\n        // validate\n        for(const argname of this._arguments) {\n            if(!this._uniforms.has(argname)) {\n                if(!this._uniforms.has(argname + '[0]'))\n                    throw new IllegalArgumentError(`Argument \"${argname}\" has not been declared in the shader`);\n            }\n        }\n\n        // done!\n        return this;\n    }\n\n    /**\n     * Specify a set of #defines to be prepended to the fragment shader\n     * @param {Object.<string,number>} defines key-value pairs (define-name: define-value)\n     * @returns {ShaderDeclaration} this\n     */\n    withDefines(defines)\n    {\n        // the list of #defines may be defined only once\n        if(this._defines.size > 0)\n            throw new IllegalOperationError(`Redefinition of externally defined constants of a shader`);\n\n        // store and write the #defines\n        const defs = [];\n        for(const key of Object.keys(defines)) {\n            const value = Number(defines[key]); // force numeric values\n            this._defines.set(key, value);\n            defs.push(`#define ${key} ${value}\\n`);\n        }\n\n        // update the fragment shader & the uniforms\n        const source = DEFAULT_FRAGMENT_SHADER_PREFIX + defs.join('') + this._userSource;\n        this._fragmentSource = ShaderPreprocessor.run(source, this._defines);\n        this._uniforms = this._autodetectUniforms(this._fragmentSource);\n\n        // done!\n        return this;\n    }\n\n    /**\n     * Return the GLSL source of the fragment shader\n     * @returns {string}\n     */\n    get fragmentSource()\n    {\n        return this._fragmentSource;\n    }\n\n    /**\n     * Return the GLSL source of the vertex shader\n     * @returns {string}\n     */\n    get vertexSource()\n    {\n        return this._vertexSource;\n    }\n\n    /**\n     * Get the names of the vertex shader attributes\n     * @returns {Object.<string,string>}\n     */\n    get attributes()\n    {\n        return DEFAULT_ATTRIBUTES;\n    }\n\n    /**\n     * Get the pre-defined locations of the vertex shader attributes\n     * @returns {Object.<string,number>}\n     */\n    get locationOfAttributes()\n    {\n        return DEFAULT_ATTRIBUTES_LOCATION;\n    }\n\n    /**\n     * Names of the arguments that will be passed to the Shader,\n     * corresponding to GLSL uniforms, in the order they will be passed\n     * @returns {string[]}\n     */\n    get arguments()\n    {\n        return this._arguments;\n    }\n\n    /**\n     * Names of the uniforms declared in the shader\n     * @returns {string[]}\n     */\n    get uniforms()\n    {\n        return Array.from(this._uniforms.keys());\n    }\n\n    /**\n     * The GLSL type of a uniform variable declared in the shader\n     * @param {string} name\n     * @returns {string}\n     */\n    uniformType(name)\n    {\n        if(!this._uniforms.has(name))\n            throw new IllegalArgumentError(`Unrecognized uniform variable: \"${name}\"`);\n\n        return this._uniforms.get(name);\n    }\n\n    /**\n     * The value of an externally defined constant, i.e., via withDefines()\n     * @param {string} name \n     * @returns {number}\n     */\n    definedConstant(name)\n    {\n        if(!this._defines.has(name))\n            throw new IllegalArgumentError(`Unrecognized externally defined constant: \"${name}\"`);\n\n        return this._defines.get(name);\n    }\n\n    /**\n     * Parses a GLSL source and detects the uniform variables,\n     * as well as their types\n     * @param {string} preprocessedSource \n     * @returns {Map<string,string>} specifies the types of all uniforms\n     */\n    _autodetectUniforms(preprocessedSource)\n    {\n        const sourceWithoutComments = preprocessedSource; // assume we've preprocessed the source already\n        const regex = /^\\s*uniform\\s+(highp\\s+|mediump\\s+|lowp\\s+)?(\\w+)\\s+([^;]+)/gm;\n        const uniforms = new Map();\n\n        let match;\n        while((match = regex.exec(sourceWithoutComments)) !== null) {\n            const type = match[2];\n            const names = match[3].split(',').map(name => name.trim()).filter(name => name); // trim & remove empty names\n\n            for(const name of names) {\n                if(name.endsWith(']')) {\n                    // is it an array?\n                    if(!(match = name.match(/(\\w+)\\s*\\[\\s*(\\d+)\\s*\\]$/)))\n                        throw new ParseError(`Unspecified array length for uniform \"${name}\" in the shader`);\n\n                    // read array name & size\n                    const [ array, size ] = [ match[1], Number(match[2]) ];\n\n                    // register uniforms\n                    for(let i = 0; i < size; i++)\n                        uniforms.set(`${array}[${i}]`, type);\n                }\n                else {\n                    // register a regular uniform\n                    uniforms.set(name, type);\n                }\n            }\n        }\n\n        return uniforms;\n    }\n}\n\n/**\n * Import a ShaderDeclaration from a GLSL file\n * @param {string} filepath relative to the shaders/ folder\n * @returns {ShaderDeclaration}\n */\nexport function importShader(filepath)\n{\n    return ShaderDeclaration.import(filepath);\n}\n\n/**\n * Create a ShaderDeclaration from a GLSL source\n * @param {string} source\n * @returns {ShaderDeclaration}\n */\nexport function createShader(source)\n{\n    return ShaderDeclaration.create(source);\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * shader-preprocessor.js\n * Custom preprocessor for shaders\n */\n\nimport {\n    PYRAMID_MAX_LEVELS, LOG2_PYRAMID_MAX_SCALE,\n    MAX_TEXTURE_LENGTH,\n    FIX_BITS, FIX_RESOLUTION,\n    MAX_DESCRIPTOR_SIZE, MIN_KEYPOINT_SIZE,\n    KPF_NONE, KPF_ORIENTED, KPF_DISCARD,\n    LITTLE_ENDIAN\n} from '../utils/globals';\nimport { Utils } from '../utils/utils';\nimport { PixelComponent } from '../utils/types';\nimport { FileNotFoundError, ParseError } from '../utils/errors';\n\n// Regular Expressions\nconst commentsRegex = [ /\\/\\*(.|\\s)*?\\*\\//g , /\\/\\/.*$/gm ];\nconst includeRegex = /^\\s*@\\s*include\\s+\"(.*?)\"/gm;\nconst constantRegex = /@(\\w+)@/g;\nconst unrollRegex = [\n    /@\\s*unroll\\s+?for\\s*\\(\\s*(int|)\\s*(?<counter>\\w+)\\s*\\=\\s*(-?\\d+|\\w+)\\s*;\\s*\\k<counter>\\s*(<=?)\\s*(-?\\d+|\\w+)\\s*;\\s*\\k<counter>\\s*\\+\\+()\\s*\\)\\s*\\{\\s*([\\s\\S]+?)\\s*\\}/g,\n    /@\\s*unroll\\s+?for\\s*\\(\\s*(int|)\\s*(?<counter>\\w+)\\s*\\=\\s*(-?\\d+|\\w+)\\s*;\\s*\\k<counter>\\s*(<=?)\\s*(-?\\d+|\\w+)\\s*;\\s*\\k<counter>\\s*\\+=\\s*(-?\\d+)\\s*\\)\\s*\\{\\s*([\\s\\S]+?)\\s*\\}/g,\n];\n\n// Constants accessible by all shaders\nconst constants = Object.freeze({\n    // general\n    'MAX_TEXTURE_LENGTH': MAX_TEXTURE_LENGTH,\n    'LITTLE_ENDIAN': LITTLE_ENDIAN ? 1 : 0,\n\n    // pyramids\n    'PYRAMID_MAX_LEVELS': PYRAMID_MAX_LEVELS,\n    'LOG2_PYRAMID_MAX_SCALE': LOG2_PYRAMID_MAX_SCALE,\n\n    // colors\n    'PIXELCOMPONENT_RED': PixelComponent.RED,\n    'PIXELCOMPONENT_GREEN': PixelComponent.GREEN,\n    'PIXELCOMPONENT_BLUE': PixelComponent.BLUE,\n    'PIXELCOMPONENT_ALPHA': PixelComponent.ALPHA,\n\n    // fixed-point math\n    'FIX_BITS': FIX_BITS,\n    'FIX_RESOLUTION': FIX_RESOLUTION,\n\n    // keypoints\n    'MAX_DESCRIPTOR_SIZE': MAX_DESCRIPTOR_SIZE,\n    'MIN_KEYPOINT_SIZE': MIN_KEYPOINT_SIZE,\n    'KPF_NONE': KPF_NONE,\n    'KPF_ORIENTED': KPF_ORIENTED,\n    'KPF_DISCARD': KPF_DISCARD,\n});\n\n/**\n * Custom preprocessor for shaders\n */\nexport class ShaderPreprocessor\n{\n    /**\n     * Runs the preprocessor\n     * @param {string} code \n     * @param {Map<string,number>} [defines]\n     * @returns {string} preprocessed code\n     */\n    static run(code, defines = new Map())\n    {\n        const errors = []; // compile-time errors\n\n        //\n        // The preprocessor will remove comments from GLSL code,\n        // include requested GLSL files and import global constants\n        // defined for all shaders (see above)\n        //\n        return unrollLoops(\n            String(code)\n                .replace(commentsRegex[0], '')\n                .replace(commentsRegex[1], '')\n                .replace(includeRegex, (_, filename) =>\n                    // FIXME: no cycle detection for @include\n                    ShaderPreprocessor.run(readfileSync(filename), defines)\n                )\n                .replace(constantRegex, (_, name) => String(\n                    // Find a global constant. If not possible, find a defined constant\n                    constants[name] !== undefined ? Number(constants[name]) : (\n                        defines.has(name) ? Number(defines.get(name)) : (\n                            errors.push(`Undefined constant: ${name}`), 0\n                        )\n                    )\n                )),\n            defines\n        ) + (errors.length > 0 ? errors.map(msg => `\\n#error ${msg}\\n`).join('') : '');\n    }\n}\n\n /**\n * Reads a shader from the shaders/include/ folder\n * @param {string} filename\n * @returns {string}\n */\nfunction readfileSync(filename)\n{\n    if(String(filename).match(/^[a-zA-Z0-9_\\-]+\\.glsl$/))\n        return require('./shaders/include/' + filename);\n\n    throw new FileNotFoundError(`Shader preprocessor: can't read file \"${filename}\"`);\n}\n\n/**\n * Unroll for loops in our own preprocessor\n * @param {string} code\n * @param {Map<string,number>} defines\n * @returns {string}\n */\nfunction unrollLoops(code, defines)\n{\n    //\n    // Currently, only integer for loops with positive step values\n    // can be unrolled. (TODO: negative step values?)\n    //\n    // The current implementation does not support curly braces\n    // inside unrolled loops. You may define macros to get around\n    // this, but do you actually need to unroll such loops?\n    //\n    // Loops that don't fit the supported pattern will crash\n    // the preprocessor if you try to unroll them.\n    //\n    const fn = unroll.bind(defines); // CRAZY!\n    const n = unrollRegex.length;\n\n    for(let i = 0; i < n; i++)\n        code = code.replace(unrollRegex[i], fn);\n\n    return code;\n}\n\n/**\n * Unroll a loop pattern (regexp)\n * @param {string} match the matched for loop\n * @param {...string} pi matched expression\n * @returns {string} unrolled loop\n */\nfunction unroll(match, type, counter, start, cmp, end, step, loopcode)\n{\n    const defines = this;\n\n    // check if the loop limits are numeric constants or #defined numbers from the outside\n    start = Number.isFinite(+start) ? start : defines.get(start);\n    end = Number.isFinite(+end) ? end : defines.get(end);\n    if(start === undefined || end === undefined) {\n        if(defines.size > 0)\n            throw new ParseError(`Can't unroll loop: unknown limits (start=${start}, end=${end}). Code:\\n\\n${match}`);\n        else\n            return match; // don't unroll now, because defines is empty - maybe we'll succeed in the next pass\n    }\n\n    // parse limits\n    start = parseInt(start);\n    end = parseInt(end);\n    step = (step.length == 0) ? 1 : parseInt(step);\n    Utils.assert(start <= end && step > 0);\n\n    /*\n    // debug\n    console.log(`Encontrei \"${match}\"`);\n    console.log(`type=\"${type}\"`);\n    console.log(`counter=\"${counter}\"`);\n    console.log(`start=\"${start}\"`);\n    console.log(`cmp=\"${cmp}\"`);\n    console.log(`end=\"${end}\"`);\n    console.log(`step=\"${step}\"`);\n    console.log(`loopcode=\"${loopcode}\"`)\n    console.log('Defines:', defines);\n    */\n\n    // continue statements are not supported inside unrolled loops\n    // and will generate a compiler error. Using break is ok.\n    const hasBreak = (loopcode.match(/\\bbreak\\s*;/) !== null);\n\n    // create a new scope\n    let unrolledCode = hasBreak ? 'switch(1) { default:\\n' : '{\\n';\n\n    // declare counter\n    unrolledCode += `${type} ${counter};\\n`;\n\n    // unroll loop\n    end += (cmp == '<=') ? 1 : 0;\n    for(let i = start; i < end; i += step)\n        unrolledCode += `{\\n${counter} = ${i};\\n${loopcode}\\n}\\n`;\n\n    // close scope\n    unrolledCode += '}\\n';\n    //console.log('Unrolled code:\\n\\n' + unrolledCode);\n\n    // done!\n    return unrolledCode;\n}","var map = {\n\t\"./colors/rgb2grey.glsl\": \"./src/gpu/shaders/colors/rgb2grey.glsl\",\n\t\"./encoders/encode-keypoint-long-offsets.glsl\": \"./src/gpu/shaders/encoders/encode-keypoint-long-offsets.glsl\",\n\t\"./encoders/encode-keypoint-offsets.glsl\": \"./src/gpu/shaders/encoders/encode-keypoint-offsets.glsl\",\n\t\"./encoders/encode-keypoints.glsl\": \"./src/gpu/shaders/encoders/encode-keypoints.glsl\",\n\t\"./encoders/encode-null-keypoints.glsl\": \"./src/gpu/shaders/encoders/encode-null-keypoints.glsl\",\n\t\"./encoders/resize-encoded-keypoints.glsl\": \"./src/gpu/shaders/encoders/resize-encoded-keypoints.glsl\",\n\t\"./encoders/upload-keypoints.glsl\": \"./src/gpu/shaders/encoders/upload-keypoints.glsl\",\n\t\"./enhancements/nightvision.glsl\": \"./src/gpu/shaders/enhancements/nightvision.glsl\",\n\t\"./enhancements/normalize-image.glsl\": \"./src/gpu/shaders/enhancements/normalize-image.glsl\",\n\t\"./filters/convolution\": \"./src/gpu/shaders/filters/convolution.js\",\n\t\"./filters/convolution.js\": \"./src/gpu/shaders/filters/convolution.js\",\n\t\"./filters/convolution1d.glsl\": \"./src/gpu/shaders/filters/convolution1d.glsl\",\n\t\"./filters/convolution2d.glsl\": \"./src/gpu/shaders/filters/convolution2d.glsl\",\n\t\"./filters/fast-median.glsl\": \"./src/gpu/shaders/filters/fast-median.glsl\",\n\t\"./include/colors.glsl\": \"./src/gpu/shaders/include/colors.glsl\",\n\t\"./include/fixed-point.glsl\": \"./src/gpu/shaders/include/fixed-point.glsl\",\n\t\"./include/float16.glsl\": \"./src/gpu/shaders/include/float16.glsl\",\n\t\"./include/global.glsl\": \"./src/gpu/shaders/include/global.glsl\",\n\t\"./include/keypoints.glsl\": \"./src/gpu/shaders/include/keypoints.glsl\",\n\t\"./include/math.glsl\": \"./src/gpu/shaders/include/math.glsl\",\n\t\"./include/orientation.glsl\": \"./src/gpu/shaders/include/orientation.glsl\",\n\t\"./include/pyramids.glsl\": \"./src/gpu/shaders/include/pyramids.glsl\",\n\t\"./include/quickselect.glsl\": \"./src/gpu/shaders/include/quickselect.glsl\",\n\t\"./include/sobel.glsl\": \"./src/gpu/shaders/include/sobel.glsl\",\n\t\"./include/subpixel.glsl\": \"./src/gpu/shaders/include/subpixel.glsl\",\n\t\"./keypoints/brisk.glsl\": \"./src/gpu/shaders/keypoints/brisk.glsl\",\n\t\"./keypoints/expand-encoder.glsl\": \"./src/gpu/shaders/keypoints/expand-encoder.glsl\",\n\t\"./keypoints/fast.glsl\": \"./src/gpu/shaders/keypoints/fast.glsl\",\n\t\"./keypoints/fast/fast-score12.glsl\": \"./src/gpu/shaders/keypoints/fast/fast-score12.glsl\",\n\t\"./keypoints/fast/fast-score16.glsl\": \"./src/gpu/shaders/keypoints/fast/fast-score16.glsl\",\n\t\"./keypoints/fast/fast-score8.glsl\": \"./src/gpu/shaders/keypoints/fast/fast-score8.glsl\",\n\t\"./keypoints/fast/fast5.glsl\": \"./src/gpu/shaders/keypoints/fast/fast5.glsl\",\n\t\"./keypoints/fast/fast7.glsl\": \"./src/gpu/shaders/keypoints/fast/fast7.glsl\",\n\t\"./keypoints/fast/fast9.glsl\": \"./src/gpu/shaders/keypoints/fast/fast9.glsl\",\n\t\"./keypoints/fast/multiscale-fast.glsl\": \"./src/gpu/shaders/keypoints/fast/multiscale-fast.glsl\",\n\t\"./keypoints/harris-cutoff.glsl\": \"./src/gpu/shaders/keypoints/harris-cutoff.glsl\",\n\t\"./keypoints/harris-derivatives.glsl\": \"./src/gpu/shaders/keypoints/harris-derivatives.glsl\",\n\t\"./keypoints/harris.glsl\": \"./src/gpu/shaders/keypoints/harris.glsl\",\n\t\"./keypoints/harris/encode-harris-score.glsl\": \"./src/gpu/shaders/keypoints/harris/encode-harris-score.glsl\",\n\t\"./keypoints/harris/multiscale-harris.glsl\": \"./src/gpu/shaders/keypoints/harris/multiscale-harris.glsl\",\n\t\"./keypoints/harris/multiscale-sobel.glsl\": \"./src/gpu/shaders/keypoints/harris/multiscale-sobel.glsl\",\n\t\"./keypoints/mix-keypoints.glsl\": \"./src/gpu/shaders/keypoints/mix-keypoints.glsl\",\n\t\"./keypoints/nonmax-suppression.glsl\": \"./src/gpu/shaders/keypoints/nonmax-suppression.glsl\",\n\t\"./keypoints/orb-descriptor.glsl\": \"./src/gpu/shaders/keypoints/orb-descriptor.glsl\",\n\t\"./keypoints/orb-orientation.glsl\": \"./src/gpu/shaders/keypoints/orb-orientation.glsl\",\n\t\"./keypoints/score-8bits.glsl\": \"./src/gpu/shaders/keypoints/score-8bits.glsl\",\n\t\"./keypoints/score-findmax.glsl\": \"./src/gpu/shaders/keypoints/score-findmax.glsl\",\n\t\"./keypoints/sort-applyperm.glsl\": \"./src/gpu/shaders/keypoints/sort-applyperm.glsl\",\n\t\"./keypoints/sort-createperm.glsl\": \"./src/gpu/shaders/keypoints/sort-createperm.glsl\",\n\t\"./keypoints/sort-mergeperm.glsl\": \"./src/gpu/shaders/keypoints/sort-mergeperm.glsl\",\n\t\"./keypoints/suppress-descriptors.glsl\": \"./src/gpu/shaders/keypoints/suppress-descriptors.glsl\",\n\t\"./keypoints/transfer-orientation.glsl\": \"./src/gpu/shaders/keypoints/transfer-orientation.glsl\",\n\t\"./keypoints/upload-keypoints.glsl\": \"./src/gpu/shaders/keypoints/upload-keypoints.glsl\",\n\t\"./pyramids/downsample2.glsl\": \"./src/gpu/shaders/pyramids/downsample2.glsl\",\n\t\"./pyramids/upsample2.glsl\": \"./src/gpu/shaders/pyramids/upsample2.glsl\",\n\t\"./trackers/lk-discard-old.glsl\": \"./src/gpu/shaders/trackers/lk-discard-old.glsl\",\n\t\"./trackers/lk-discard.glsl\": \"./src/gpu/shaders/trackers/lk-discard.glsl\",\n\t\"./trackers/lk.glsl\": \"./src/gpu/shaders/trackers/lk.glsl\",\n\t\"./trackers/transfer-flow.glsl\": \"./src/gpu/shaders/trackers/transfer-flow.glsl\",\n\t\"./transforms/resize.glsl\": \"./src/gpu/shaders/transforms/resize.glsl\",\n\t\"./transforms/warp-perspective.glsl\": \"./src/gpu/shaders/transforms/warp-perspective.glsl\",\n\t\"./utils/copy-components.glsl\": \"./src/gpu/shaders/utils/copy-components.glsl\",\n\t\"./utils/fill-components.glsl\": \"./src/gpu/shaders/utils/fill-components.glsl\",\n\t\"./utils/fill.glsl\": \"./src/gpu/shaders/utils/fill.glsl\",\n\t\"./utils/flip-y.glsl\": \"./src/gpu/shaders/utils/flip-y.glsl\",\n\t\"./utils/identity.glsl\": \"./src/gpu/shaders/utils/identity.glsl\",\n\t\"./utils/scan-minmax2d.glsl\": \"./src/gpu/shaders/utils/scan-minmax2d.glsl\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./src/gpu/shaders sync recursive ^\\\\.\\\\/.*$\";","module.exports = \"const vec4 grey = vec4(0.299f, 0.587f, 0.114f, 0.0f);\\nuniform sampler2D image;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nfloat g = dot(pixel, grey);\\ncolor = vec4(g, g, g, 1.0f);\\n}\"","module.exports = \"uniform sampler2D offsetsImage;\\nuniform ivec2 imageSize;\\n#ifndef MAX_ITERATIONS\\n#error Must define MAX_ITERATIONS\\n#endif\\n#define decodeSkipOffset(pixel) (int((pixel).g * 255.0f) | (int((pixel).b * 255.0f) << 8))\\n#define encodeSkipOffset(offset) (vec2((offset) & 255, (offset) >> 8) / 255.0f)\\nvoid main()\\n{\\nvec4 pixel = threadPixel(offsetsImage);\\nivec2 thread = threadLocation();\\nfloat score = pixel.r;\\nfloat scale = pixel.a;\\nint rasterIndex = thread.y * imageSize.x + thread.x;\\nint offset = decodeSkipOffset(pixel);\\nint totalOffset = offset;\\nivec2 pos = thread;\\n#if 0\\nwhile(offset < MAX_ITERATIONS && pos.y < imageSize.y && pixel.r == 0.0f) {\\nrasterIndex += offset;\\npos = ivec2(rasterIndex % imageSize.x, rasterIndex / imageSize.x);\\npixel = pixelAt(offsetsImage, pos);\\noffset = decodeSkipOffset(pixel);\\ntotalOffset += offset;\\n}\\n#else\\nint allow = 1;\\nfor(int i = 0; i < MAX_ITERATIONS; i++) {\\nallow *= int(pos.y < imageSize.y) * int(pixel.r == 0.0f);\\nrasterIndex += allow * offset;\\npos = ivec2(rasterIndex % imageSize.x, rasterIndex / imageSize.x);\\npixel = pixelAt(offsetsImage, pos);\\noffset = decodeSkipOffset(pixel);\\ntotalOffset += allow * offset;\\n}\\n#endif\\ntotalOffset = min(totalOffset, 65535);\\ncolor = vec4(score, encodeSkipOffset(totalOffset), scale);\\n}\"","module.exports = \"uniform sampler2D corners;\\nuniform ivec2 imageSize;\\n#if !defined(MAX_ITERATIONS)\\n#error Must define MAX_ITERATIONS\\n#elif MAX_ITERATIONS > 255\\n#error MAX_ITERATIONS must be less than 256\\n#endif\\nvoid main()\\n{\\nvec4 pixel = threadPixel(corners);\\nivec2 pos = threadLocation();\\nfloat score = pixel.r;\\nfloat scale = pixel.a;\\nint offset = 0;\\n#if 0\\nwhile(offset < MAX_ITERATIONS && pos.y < imageSize.y && pixelAt(corners, pos).r == 0.0f) {\\n++offset;\\npos.x = (pos.x + 1) % imageSize.x;\\npos.y += int(pos.x == 0);\\n}\\n#else\\nint allow = 1;\\nfor(int i = 0; i < MAX_ITERATIONS; i++) {\\nallow *= int(pos.y < imageSize.y) * int(pixel.r == 0.0f);\\noffset += allow;\\npos.x = (pos.x + 1) % imageSize.x;\\npos.y += int(pos.x == 0);\\npixel = pixelAt(corners, pos);\\n}\\n#endif\\ncolor = vec4(score, float(offset) / 255.0f, 0.0f, scale);\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform sampler2D offsetsImage;\\nuniform ivec2 imageSize;\\nuniform int passId;\\nuniform int numPasses;\\nuniform int keypointLimit;\\nuniform sampler2D encodedKeypoints;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int encoderLength;\\n#define decodeSkipOffset(pixel) (int((pixel).g * 255.0f) | (int((pixel).b * 255.0f) << 8))\\nbool findQthKeypoint(int q, int p, inout ivec2 position, out vec4 pixel)\\n{\\nint notFirstPass = int(passId > 0);\\nposition *= notFirstPass;\\np |= -(1 - notFirstPass);\\np -= notFirstPass;\\nint rasterIndex = position.y * imageSize.x + position.x;\\nwhile(position.y < imageSize.y && p != q) {\\nposition = ivec2(rasterIndex % imageSize.x, rasterIndex / imageSize.x);\\npixel = texelFetch(offsetsImage, position, 0);\\np += int(pixel.r > 0.0f);\\nrasterIndex += max(1, decodeSkipOffset(pixel));\\n}\\nreturn (p == q);\\n}\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\\nint q = findKeypointIndex(address, descriptorSize, extraSize);\\ncolor = vec4(0.0f);\\nif(address.offset > 1)\\nreturn;\\ncolor = threadPixel(encodedKeypoints);\\nint numPixels = encoderLength * encoderLength;\\nint maxKeypoints = numPixels / pixelsPerKeypoint;\\nint maxKeypointsPerPass = maxKeypoints / numPasses + int(maxKeypoints % numPasses != 0);\\nint targetPassId = q / maxKeypointsPerPass;\\nif(passId != targetPassId)\\nreturn;\\nint lastIndexFromPrevPass = passId * maxKeypointsPerPass - 1;\\nKeypointAddress lastAddressFromPrevPass = KeypointAddress(max(0, lastIndexFromPrevPass) * pixelsPerKeypoint, 0);\\nKeypoint lastKeypointFromPrevPass = decodeKeypoint(encodedKeypoints, encoderLength, lastAddressFromPrevPass);\\nivec2 position = ivec2(lastKeypointFromPrevPass.position);\\nvec4 pixel;\\ncolor = encodeNullKeypoint();\\nif(q >= min(maxKeypoints, keypointLimit) || !findQthKeypoint(q, lastIndexFromPrevPass, position, pixel))\\nreturn;\\ncolor = (address.offset == 1) ? vec4(\\npixel.a,\\nencodeOrientation(0.0f),\\npixel.r,\\nencodeKeypointFlags(KPF_NONE)\\n) : encodeKeypointPosition(\\nvec2(position)\\n);\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nvoid main()\\n{\\ncolor = encodeNullKeypoint();\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform sampler2D inputTexture;\\nuniform int inputDescriptorSize;\\nuniform int inputExtraSize;\\nuniform int inputEncoderLength;\\nuniform int outputDescriptorSize;\\nuniform int outputExtraSize;\\nuniform int outputEncoderLength;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(inputTexture);\\nivec2 thread = threadLocation();\\nKeypointAddress myAddress = findKeypointAddress(\\nthread,\\noutputEncoderLength,\\noutputDescriptorSize,\\noutputExtraSize\\n);\\nint myIndex = findKeypointIndex(\\nmyAddress,\\noutputDescriptorSize,\\noutputExtraSize\\n);\\nint pixelsPerKeypoint = sizeofEncodedKeypoint(inputDescriptorSize, inputExtraSize) / 4;\\nKeypointAddress otherAddress = KeypointAddress(\\nmyIndex * pixelsPerKeypoint,\\nmyAddress.offset\\n);\\nint head = MIN_KEYPOINT_SIZE / 4;\\ncolor = (myAddress.offset >= head) ? vec4(0.0f) :\\nreadKeypointData(inputTexture, inputEncoderLength, otherAddress);\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform int keypointCount;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int encoderLength;\\n#ifndef KEYPOINT_BUFFER_LENGTH\\n#error Must specify KEYPOINT_BUFFER_LENGTH\\n#endif\\nlayout(std140) uniform KeypointBuffer\\n{\\nvec4 keypointBuffer[KEYPOINT_BUFFER_LENGTH];\\n};\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\\nint index = findKeypointIndex(address, descriptorSize, extraSize);\\ncolor = encodeNullKeypoint();\\nif(index >= keypointCount)\\nreturn;\\nvec4 data = keypointBuffer[index];\\nswitch(address.offset) {\\ncase 0: {\\nfixed2_t pos = vec2tofix(data.xy);\\nfixed2_t lo = pos & 255;\\nfixed2_t hi = (pos >> 8) & 255;\\ncolor = vec4(float(lo.x), float(hi.x), float(lo.y), float(hi.y)) / 255.0f;\\nbreak;\\n}\\ncase 1: {\\nfloat score = clamp(data.w, 0.0f, 1.0f);\\nfloat scale = encodeLod(data.z);\\nfloat rotation = encodeOrientation(0.0f);\\nfloat flags = encodeKeypointFlags(KPF_NONE);\\ncolor = vec4(scale, rotation, score, flags);\\nbreak;\\n}\\ndefault: {\\ncolor = vec4(0.0f);\\nbreak;\\n}\\n}\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform sampler2D illuminationMap;\\nuniform float gain;\\nuniform float offset;\\nuniform float decay;\\nconst mat3 rgb2yuv = mat3(\\n0.299f, -0.14713f, 0.615f,\\n0.587f, -0.28886f, -0.51499f,\\n0.114f, 0.436f, -0.10001f\\n);\\nconst mat3 yuv2rgb = mat3(\\n1.0f, 1.0f, 1.0f,\\n0.0f, -0.39465f, 2.03211f,\\n1.13983f, -0.58060f, 0.0f\\n);\\nconst float eps = 0.0001f;\\nconst float sqrt2 = 1.4142135623730951f;\\nconst float magic = 20.0f;\\nconst vec2 center = vec2(0.5f);\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nvec4 imapPixel = threadPixel(illuminationMap);\\nfloat lambda = -sqrt2 * log(max(1.0f - decay, eps));\\nfloat dist = length(texCoord - center);\\nfloat vgain = gain * exp(-lambda * dist);\\nfloat normalizedGain = 2.0f * vgain;\\nfloat normalizedOffset = 2.0f * offset - 1.0f;\\n#ifdef GREYSCALE\\nfloat luma = 1.0 / (1.0 + exp(-normalizedGain * magic * (pixel.g - imapPixel.g)));\\nluma = clamp(luma + normalizedOffset, 0.0f, 1.0f);\\ncolor = vec4(luma, luma, luma, 1.0f);\\n#else\\nvec3 yuvPixel = rgb2yuv * pixel.rgb;\\nvec3 yuvImapPixel = rgb2yuv * imapPixel.rgb;\\nfloat luma = 1.0 / (1.0 + exp(-normalizedGain * magic * (yuvPixel.r - yuvImapPixel.r)));\\nluma += normalizedOffset;\\nvec3 rgbCorrectedPixel = yuv2rgb * vec3(luma, yuvPixel.gb);\\nrgbCorrectedPixel = clamp(rgbCorrectedPixel, 0.0f, 1.0f);\\ncolor = vec4(rgbCorrectedPixel, 1.0f);\\n#endif\\n}\"","module.exports = \"#ifdef GREYSCALE\\nuniform sampler2D minmax2d;\\n#else\\nuniform sampler2D minmax2dRGB[3];\\n#endif\\nuniform float minValue;\\nuniform float maxValue;\\nconst float eps = 1.0f / 255.0f;\\nvoid main()\\n{\\nvec2 minmax = clamp(vec2(minValue, maxValue), 0.0f, 255.0f) / 255.0f;\\nvec4 newMin = vec4(minmax.x);\\nvec4 newRange = vec4(minmax.y - minmax.x);\\nvec4 alpha = vec4(1.0f, newMin.x, newRange.x, 1.0f);\\n#ifdef GREYSCALE\\nvec4 pixel = threadPixel(minmax2d);\\nmat4 channel = mat4(pixel, pixel, pixel, alpha);\\n#else\\nmat4 channel = mat4(\\nthreadPixel(minmax2dRGB[0]),\\nthreadPixel(minmax2dRGB[1]),\\nthreadPixel(minmax2dRGB[2]),\\nalpha\\n);\\n#endif\\nvec4 oldMin = vec4(channel[0].g, channel[1].g, channel[2].g, channel[3].g);\\nvec4 oldRange = max(vec4(channel[0].b, channel[1].b, channel[2].b, channel[3].b), eps);\\nvec4 oldIntensity = vec4(channel[0].a, channel[1].a, channel[2].a, channel[3].a);\\nvec4 newIntensity = (oldIntensity - oldMin) * newRange / oldRange + newMin;\\ncolor = newIntensity;\\n}\"","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * convolution.js\n * Convolution shader generators\n */\n\nimport { createShader } from '../../shader-declaration';\nimport { Utils } from '../../../utils/utils';\nimport { IllegalArgumentError } from '../../../utils/errors';\n\n\n\n/**\n * Generate a 2D convolution with a square kernel\n * @param {Array<number>} kernel convolution kernel\n * @param {number} [normalizationConstant] will be multiplied by all kernel entries\n */\nexport function conv2D(kernel, normalizationConstant = 1.0)\n{\n    const kernel32 = new Float32Array(kernel.map(x => (+x) * (+normalizationConstant)));\n    const kSize = Math.sqrt(kernel32.length) | 0;\n    const N = kSize >> 1; // idiv 2\n\n    // validate input\n    if(kSize < 1 || kSize % 2 == 0)\n        throw new IllegalArgumentError(`Can't perform a 2D convolution with an invalid kSize of ${kSize}`);\n    else if(kSize * kSize != kernel32.length)\n        throw new IllegalArgumentError(`Invalid 2D convolution kernel of ${kernel32.length} elements (expected: square)`);\n\n    // select the appropriate pixel function\n    const pixelAtOffset = (N <= 7) ? 'pixelAtShortOffset' : 'pixelAtLongOffset';\n\n    // code generator\n    const foreachKernelElement = fn => Utils.cartesian(Utils.symmetricRange(N), Utils.symmetricRange(N)).map(\n        cur => fn(\n            kernel32[(cur[0] + N) * kSize + (cur[1] + N)],\n            cur[0], cur[1]\n        )\n    ).join('\\n');\n\n    const generateCode = (k, dy, dx) => `\n        result += ${pixelAtOffset}(image, ivec2(${(-dx) | 0}, ${(-dy) | 0})) * float(${+k});\n    `;\n\n    // shader\n    const source = `\n    uniform sampler2D image;\n\n    void main()\n    {\n        float alpha = threadPixel(image).a;\n        vec4 result = vec4(0.0f);\n\n        ${foreachKernelElement(generateCode)}\n\n        color = vec4(result.rgb, alpha);\n    }\n    `;\n\n    // done!\n    return createShader(source).withArguments('image');\n}\n\n\n\n\n/**\n * Generate a 1D convolution function on the x-axis\n * @param {Array<number>} kernel convolution kernel\n * @param {number} [normalizationConstant] will be multiplied by all kernel entries\n */\nexport function convX(kernel, normalizationConstant = 1.0)\n{\n    return conv1D('x', kernel, normalizationConstant);\n}\n\n\n\n\n/**\n * Generate a 1D convolution function on the y-axis\n * @param {Array<number>} kernel convolution kernel\n * @param {number} [normalizationConstant] will be multiplied by all kernel entries\n */\nexport function convY(kernel, normalizationConstant = 1.0)\n{\n    return conv1D('y', kernel, normalizationConstant);\n}\n\n\n\n\n/**\n * 1D convolution function generator\n * @param {string} axis either \"x\" or \"y\"\n * @param {Array<number>} kernel convolution kernel\n * @param {number} [normalizationConstant] will be multiplied by all kernel entries\n */\nfunction conv1D(axis, kernel, normalizationConstant = 1.0)\n{\n    const kernel32 = new Float32Array(kernel.map(x => (+x) * (+normalizationConstant)));\n    const kSize = kernel32.length;\n    const N = kSize >> 1; // idiv 2\n\n    // validate input\n    if(kSize < 1 || kSize % 2 == 0)\n        throw new IllegalArgumentError(`Can't perform a 1D convolution with an invalid kSize of ${kSize}`);\n    else if(axis != 'x' && axis != 'y')\n        throw new IllegalArgumentError(`Can't perform 1D convolution: invalid axis \"${axis}\"`); // this should never happen\n\n    // select the appropriate pixel function\n    const pixelAtOffset = (N <= 7) ? 'pixelAtShortOffset' : 'pixelAtLongOffset';\n\n    // code generator\n    const foreachKernelElement = fn => Utils.symmetricRange(N).reduce(\n        (acc, cur) => acc + fn(kernel32[cur + N], cur),\n    '');\n    const generateCode = (k, i) => ((axis == 'x') ? `\n        pixel += ${pixelAtOffset}(image, ivec2(${(-i) | 0}, 0)) * float(${+k});\n    ` : `\n        pixel += ${pixelAtOffset}(image, ivec2(0, ${(-i) | 0})) * float(${+k});\n    `);\n\n    // shader\n    const source = `\n    uniform sampler2D image;\n\n    void main()\n    {\n        float alpha = threadPixel(image).a;\n        vec4 pixel = vec4(0.0f);\n\n        ${foreachKernelElement(generateCode)}\n\n        color = vec4(pixel.rgb, alpha);\n    }\n    `;\n\n    // done!\n    return createShader(source).withArguments('image');\n}","module.exports = \"#if !defined(KERNEL_SIZE) || !defined(AXIS)\\n#define Must define KERNEL_SIZE and AXIS\\n#endif\\nuniform sampler2D image;\\nuniform float kernel[@KERNEL_SIZE@];\\n#define S(x,y,k) result += pixelAtShortOffset(image, ivec2((x),(y))) * kernel[k]\\nvoid main()\\n{\\nvec4 result = vec4(0.0f);\\n#if AXIS == 0 && KERNEL_SIZE == 3\\nS(-1, 0, 2);\\nS( 0, 0, 1);\\nS( 1, 0, 0);\\n#elif AXIS == 1 && KERNEL_SIZE == 3\\nS( 0,-1, 2);\\nS( 0, 0, 1);\\nS( 0, 1, 0);\\n#elif AXIS == 0 && KERNEL_SIZE == 5\\nS(-2, 0, 4);\\nS(-1, 0, 3);\\nS( 0, 0, 2);\\nS( 1, 0, 1);\\nS( 2, 0, 0);\\n#elif AXIS == 1 && KERNEL_SIZE == 5\\nS(0,-2, 4);\\nS(0,-1, 3);\\nS(0, 0, 2);\\nS(0, 1, 1);\\nS(0, 2, 0);\\n#elif AXIS == 0 && KERNEL_SIZE == 7\\nS(-3, 0, 6);\\nS(-2, 0, 5);\\nS(-1, 0, 4);\\nS( 0, 0, 3);\\nS( 1, 0, 2);\\nS( 2, 0, 1);\\nS( 3, 0, 0);\\n#elif AXIS == 1 && KERNEL_SIZE == 7\\nS(0,-3, 6);\\nS(0,-2, 5);\\nS(0,-1, 4);\\nS(0, 0, 3);\\nS(0, 1, 2);\\nS(0, 2, 1);\\nS(0, 3, 0);\\n#elif AXIS == 0 && KERNEL_SIZE == 9\\nS(-4, 0, 8);\\nS(-3, 0, 7);\\nS(-2, 0, 6);\\nS(-1, 0, 5);\\nS( 0, 0, 4);\\nS( 1, 0, 3);\\nS( 2, 0, 2);\\nS( 3, 0, 1);\\nS( 4, 0, 0);\\n#elif AXIS == 1 && KERNEL_SIZE == 9\\nS(0,-4, 8);\\nS(0,-3, 7);\\nS(0,-2, 6);\\nS(0,-1, 5);\\nS(0, 0, 4);\\nS(0, 1, 3);\\nS(0, 2, 2);\\nS(0, 3, 1);\\nS(0, 4, 0);\\n#elif AXIS == 0 && KERNEL_SIZE == 11\\nS(-5, 0, 10);\\nS(-4, 0, 9);\\nS(-3, 0, 8);\\nS(-2, 0, 7);\\nS(-1, 0, 6);\\nS( 0, 0, 5);\\nS( 1, 0, 4);\\nS( 2, 0, 3);\\nS( 3, 0, 2);\\nS( 4, 0, 1);\\nS( 5, 0, 0);\\n#elif AXIS == 1 && KERNEL_SIZE == 11\\nS(0,-5, 10);\\nS(0,-4, 9);\\nS(0,-3, 8);\\nS(0,-2, 7);\\nS(0,-1, 6);\\nS(0, 0, 5);\\nS(0, 1, 4);\\nS(0, 2, 3);\\nS(0, 3, 2);\\nS(0, 4, 1);\\nS(0, 5, 0);\\n#elif AXIS == 0 && KERNEL_SIZE == 13\\nS(-6, 0, 12);\\nS(-5, 0, 11);\\nS(-4, 0, 10);\\nS(-3, 0, 9);\\nS(-2, 0, 8);\\nS(-1, 0, 7);\\nS( 0, 0, 6);\\nS( 1, 0, 5);\\nS( 2, 0, 4);\\nS( 3, 0, 3);\\nS( 4, 0, 2);\\nS( 5, 0, 1);\\nS( 6, 0, 0);\\n#elif AXIS == 1 && KERNEL_SIZE == 13\\nS(0,-6, 12);\\nS(0,-5, 11);\\nS(0,-4, 10);\\nS(0,-3, 9);\\nS(0,-2, 8);\\nS(0,-1, 7);\\nS(0, 0, 6);\\nS(0, 1, 5);\\nS(0, 2, 4);\\nS(0, 3, 3);\\nS(0, 4, 2);\\nS(0, 5, 1);\\nS(0, 6, 0);\\n#elif AXIS == 0 && KERNEL_SIZE == 15\\nS(-7, 0, 14);\\nS(-6, 0, 13);\\nS(-5, 0, 12);\\nS(-4, 0, 11);\\nS(-3, 0, 10);\\nS(-2, 0, 9);\\nS(-1, 0, 8);\\nS( 0, 0, 7);\\nS( 1, 0, 6);\\nS( 2, 0, 5);\\nS( 3, 0, 4);\\nS( 4, 0, 3);\\nS( 5, 0, 2);\\nS( 6, 0, 1);\\nS( 7, 0, 0);\\n#elif AXIS == 1 && KERNEL_SIZE == 15\\nS(0,-7, 14);\\nS(0,-6, 13);\\nS(0,-5, 12);\\nS(0,-4, 11);\\nS(0,-3, 10);\\nS(0,-2, 9);\\nS(0,-1, 8);\\nS(0, 0, 7);\\nS(0, 1, 6);\\nS(0, 2, 5);\\nS(0, 3, 4);\\nS(0, 4, 3);\\nS(0, 5, 2);\\nS(0, 6, 1);\\nS(0, 7, 0);\\n#else\\n#error Invalid parameters\\n#endif\\ncolor = vec4(result.rgb, 1.0f);\\n}\"","module.exports = \"#ifndef KERNEL_SIZE_SQUARED\\n#define Must define KERNEL_SIZE_SQUARED\\n#endif\\nuniform sampler2D image;\\nuniform float kernel[@KERNEL_SIZE_SQUARED@];\\n#define S(x,y,k) result += pixelAtShortOffset(image, ivec2((x),(y))) * kernel[k]\\nvoid main()\\n{\\nvec4 result = vec4(0.0f);\\n#if KERNEL_SIZE_SQUARED == 9\\nS(-1,-1, 8);\\nS(-1, 0, 7);\\nS(-1, 1, 6);\\nS( 0,-1, 5);\\nS( 0, 0, 4);\\nS( 0, 1, 3);\\nS( 1,-1, 2);\\nS( 1, 0, 1);\\nS( 1, 1, 0);\\n#elif KERNEL_SIZE_SQUARED == 25\\nS(-2,-2, 24);\\nS(-2,-1, 23);\\nS(-2, 0, 22);\\nS(-2, 1, 21);\\nS(-2, 2, 20);\\nS(-1,-2, 19);\\nS(-1,-1, 18);\\nS(-1, 0, 17);\\nS(-1, 1, 16);\\nS(-1, 2, 15);\\nS( 0,-2, 14);\\nS( 0,-1, 13);\\nS( 0, 0, 12);\\nS( 0, 1, 11);\\nS( 0, 2, 10);\\nS( 1,-2, 9);\\nS( 1,-1, 8);\\nS( 1, 0, 7);\\nS( 1, 1, 6);\\nS( 1, 2, 5);\\nS( 2,-2, 4);\\nS( 2,-1, 3);\\nS( 2, 0, 2);\\nS( 2, 1, 1);\\nS( 2, 2, 0);\\n#elif KERNEL_SIZE_SQUARED == 49\\nS(-3,-3, 48);\\nS(-3,-2, 47);\\nS(-3,-1, 46);\\nS(-3, 0, 45);\\nS(-3, 1, 44);\\nS(-3, 2, 43);\\nS(-3, 3, 42);\\nS(-2,-3, 41);\\nS(-2,-2, 40);\\nS(-2,-1, 39);\\nS(-2, 0, 38);\\nS(-2, 1, 37);\\nS(-2, 2, 36);\\nS(-2, 3, 35);\\nS(-1,-3, 34);\\nS(-1,-2, 33);\\nS(-1,-1, 32);\\nS(-1, 0, 31);\\nS(-1, 1, 30);\\nS(-1, 2, 29);\\nS(-1, 3, 28);\\nS( 0,-3, 27);\\nS( 0,-2, 26);\\nS( 0,-1, 25);\\nS( 0, 0, 24);\\nS( 0, 1, 23);\\nS( 0, 2, 22);\\nS( 0, 3, 21);\\nS( 1,-3, 20);\\nS( 1,-2, 19);\\nS( 1,-1, 18);\\nS( 1, 0, 17);\\nS( 1, 1, 16);\\nS( 1, 2, 15);\\nS( 1, 3, 14);\\nS( 2,-3, 13);\\nS( 2,-2, 12);\\nS( 2,-1, 11);\\nS( 2, 0, 10);\\nS( 2, 1, 9);\\nS( 2, 2, 8);\\nS( 2, 3, 7);\\nS( 3,-3, 6);\\nS( 3,-2, 5);\\nS( 3,-1, 4);\\nS( 3, 0, 3);\\nS( 3, 1, 2);\\nS( 3, 2, 1);\\nS( 3, 3, 0);\\n#else\\n#error Invalid KERNEL_SIZE_SQUARED\\n#endif\\ncolor = vec4(result.rgb, 1.0f);\\n}\"","module.exports = \"uniform sampler2D image;\\n#define X(i,j) t = vec2(min(p[i], p[j]), max(p[i], p[j])); p[i] = t.x; p[j] = t.y;\\n#define S(i,x,y) p[i] = pixelAtShortOffset(image, ivec2((x),(y))).g\\nvoid main()\\n{\\nfloat median;\\nvec2 t;\\n#if !defined(KERNEL_SIZE)\\n#error Must define KERNEL_SIZE\\n#elif KERNEL_SIZE == 3\\nfloat p[9];\\nS(0,-1,-1);\\nS(1, 0,-1);\\nS(2, 1,-1);\\nS(3,-1, 0);\\nS(4, 0, 0);\\nS(5, 1, 0);\\nS(6,-1, 1);\\nS(7, 0, 1);\\nS(8, 1, 1);\\nX(1,2);X(4,5);X(7,8);X(0,1);X(3,4);X(6,7);X(1,2);X(4,5);X(7,8);X(0,3);X(5,8);X(4,7);X(3,6);X(1,4);X(2,5);X(4,7);X(4,2);X(6,4);X(4,2);\\nmedian = p[4];\\n#elif KERNEL_SIZE == 5\\nfloat p[25];\\nS( 0,-2,-2);\\nS( 1,-1,-2);\\nS( 2, 0,-2);\\nS( 3, 1,-2);\\nS( 4, 2,-2);\\nS( 5,-2,-1);\\nS( 6,-1,-1);\\nS( 7, 0,-1);\\nS( 8, 1,-1);\\nS( 9, 2,-1);\\nS(10,-2, 0);\\nS(11,-1, 0);\\nS(12, 0, 0);\\nS(13, 1, 0);\\nS(14, 2, 0);\\nS(15,-2, 1);\\nS(16,-1, 1);\\nS(17, 0, 1);\\nS(18, 1, 1);\\nS(19, 2, 1);\\nS(20,-2, 2);\\nS(21,-1, 2);\\nS(22, 0, 2);\\nS(23, 1, 2);\\nS(24, 2, 2);\\nX(0,1);X(3,4);X(2,4);X(2,3);X(6,7);X(5,7);X(5,6);X(9,10);X(8,10);X(8,9);X(12,13);X(11,13);X(11,12);X(15,16);X(14,16);X(14,15);X(18,19);X(17,19);X(17,18);X(21,22);X(20,22);X(20,21);X(23,24);X(2,5);X(3,6);X(0,6);X(0,3);X(4,7);X(1,7);X(1,4);X(11,14);X(8,14);X(8,11);X(12,15);X(9,15);X(9,12);X(13,16);X(10,16);X(10,13);X(20,23);X(17,23);X(17,20);X(21,24);X(18,24);X(18,21);X(19,22);X(8,17);X(9,18);X(0,18);X(0,9);X(10,19);X(1,19);X(1,10);X(11,20);X(2,20);X(2,11);X(12,21);X(3,21);X(3,12);X(13,22);X(4,22);X(4,13);X(14,23);X(5,23);X(5,14);X(15,24);X(6,24);X(6,15);X(7,16);X(7,19);X(13,21);X(15,23);X(7,13);X(7,15);X(1,9);X(3,11);X(5,17);X(11,17);X(9,17);X(4,10);X(6,12);X(7,14);X(4,6);X(4,7);X(12,14);X(10,14);X(6,7);X(10,12);X(6,10);X(6,17);X(12,17);X(7,17);X(7,10);X(12,18);X(7,12);X(10,18);X(12,20);X(10,20);X(10,12);\\nmedian = p[12];\\n#elif KERNEL_SIZE == 7\\nfloat p[49];\\nS( 0,-3,-3);\\nS( 1,-2,-3);\\nS( 2,-1,-3);\\nS( 3, 0,-3);\\nS( 4, 1,-3);\\nS( 5, 2,-3);\\nS( 6, 3,-3);\\nS( 7,-3,-2);\\nS( 8,-2,-2);\\nS( 9,-1,-2);\\nS(10, 0,-2);\\nS(11, 1,-2);\\nS(12, 2,-2);\\nS(13, 3,-2);\\nS(14,-3,-1);\\nS(15,-2,-1);\\nS(16,-1,-1);\\nS(17, 0,-1);\\nS(18, 1,-1);\\nS(19, 2,-1);\\nS(20, 3,-1);\\nS(21,-3, 0);\\nS(22,-2, 0);\\nS(23,-1, 0);\\nS(24, 0, 0);\\nS(25, 1, 0);\\nS(26, 2, 0);\\nS(27, 3, 0);\\nS(28,-3, 1);\\nS(29,-2, 1);\\nS(30,-1, 1);\\nS(31, 0, 1);\\nS(32, 1, 1);\\nS(33, 2, 1);\\nS(34, 3, 1);\\nS(35,-3, 2);\\nS(36,-2, 2);\\nS(37,-1, 2);\\nS(38, 0, 2);\\nS(39, 1, 2);\\nS(40, 2, 2);\\nS(41, 3, 2);\\nS(42,-3, 3);\\nS(43,-2, 3);\\nS(44,-1, 3);\\nS(45, 0, 3);\\nS(46, 1, 3);\\nS(47, 2, 3);\\nS(48, 3, 3);\\nX(0,1);X(2,3);X(0,2);X(1,3);X(1,2);X(4,5);X(6,7);X(4,6);X(5,7);X(5,6);X(0,4);X(2,6);X(2,4);X(1,5);X(3,7);X(3,5);X(1,2);X(3,4);X(5,6);X(8,9);X(10,11);X(8,10);X(9,11);X(9,10);X(12,13);X(14,15);X(12,14);X(13,15);X(13,14);X(8,12);X(10,14);X(10,12);X(9,13);X(11,15);X(11,13);X(9,10);X(11,12);X(13,14);X(0,8);X(4,12);X(4,8);X(2,10);X(6,14);X(6,10);X(2,4);X(6,8);X(10,12);X(1,9);X(5,13);X(5,9);X(3,11);X(7,15);X(7,11);X(3,5);X(7,9);X(11,13);X(1,2);X(3,4);X(5,6);X(7,8);X(9,10);X(11,12);X(13,14);X(16,17);X(18,19);X(16,18);X(17,19);X(17,18);X(20,21);X(22,23);X(20,22);X(21,23);X(21,22);X(16,20);X(18,22);X(18,20);X(17,21);X(19,23);X(19,21);X(17,18);X(19,20);X(21,22);X(24,25);X(26,27);X(24,26);X(25,27);X(25,26);X(28,29);X(30,31);X(28,30);X(29,31);X(29,30);X(24,28);X(26,30);X(26,28);X(25,29);X(27,31);X(27,29);X(25,26);X(27,28);X(29,30);X(16,24);X(20,28);X(20,24);X(18,26);X(22,30);X(22,26);X(18,20);X(22,24);X(26,28);X(17,25);X(21,29);X(21,25);X(19,27);X(23,31);X(23,27);X(19,21);X(23,25);X(27,29);X(17,18);X(19,20);X(21,22);X(23,24);X(25,26);X(27,28);X(29,30);X(0,16);X(8,24);X(8,16);X(4,20);X(12,28);X(12,20);X(4,8);X(12,16);X(20,24);X(2,18);X(10,26);X(10,18);X(6,22);X(14,30);X(14,22);X(6,10);X(14,18);X(22,26);X(2,4);X(6,8);X(10,12);X(14,16);X(18,20);X(22,24);X(26,28);X(1,17);X(9,25);X(9,17);X(5,21);X(13,29);X(13,21);X(5,9);X(13,17);X(21,25);X(3,19);X(11,27);X(11,19);X(7,23);X(15,31);X(15,23);X(7,11);X(15,19);X(23,27);X(3,5);X(7,9);X(11,13);X(15,17);X(19,21);X(23,25);X(27,29);X(1,2);X(3,4);X(5,6);X(7,8);X(9,10);X(11,12);X(13,14);X(15,16);X(17,18);X(19,20);X(21,22);X(23,24);X(25,26);X(27,28);X(29,30);X(32,33);X(34,35);X(32,34);X(33,35);X(33,34);X(36,37);X(38,39);X(36,38);X(37,39);X(37,38);X(32,36);X(34,38);X(34,36);X(33,37);X(35,39);X(35,37);X(33,34);X(35,36);X(37,38);X(40,41);X(42,43);X(40,42);X(41,43);X(41,42);X(44,45);X(46,47);X(44,46);X(45,47);X(45,46);X(40,44);X(42,46);X(42,44);X(41,45);X(43,47);X(43,45);X(41,42);X(43,44);X(45,46);X(32,40);X(36,44);X(36,40);X(34,42);X(38,46);X(38,42);X(34,36);X(38,40);X(42,44);X(33,41);X(37,45);X(37,41);X(35,43);X(39,47);X(39,43);X(35,37);X(39,41);X(43,45);X(33,34);X(35,36);X(37,38);X(39,40);X(41,42);X(43,44);X(45,46);X(32,48);X(40,48);X(36,40);X(44,48);X(38,42);X(34,36);X(38,40);X(42,44);X(46,48);X(37,41);X(39,43);X(35,37);X(39,41);X(43,45);X(33,34);X(35,36);X(37,38);X(39,40);X(41,42);X(43,44);X(45,46);X(47,48);X(0,32);X(16,48);X(16,32);X(8,40);X(24,40);X(8,16);X(24,32);X(40,48);X(4,36);X(20,36);X(12,44);X(28,44);X(12,20);X(28,36);X(4,8);X(12,16);X(20,24);X(28,32);X(36,40);X(44,48);X(2,34);X(18,34);X(10,42);X(26,42);X(10,18);X(26,34);X(6,38);X(22,38);X(14,46);X(30,46);X(14,22);X(30,38);X(6,10);X(14,18);X(22,26);X(30,34);X(38,42);X(2,4);X(6,8);X(10,12);X(14,16);X(18,20);X(22,24);X(26,28);X(30,32);X(34,36);X(38,40);X(42,44);X(46,48);X(1,33);X(17,33);X(9,41);X(25,41);X(9,17);X(25,33);X(5,37);X(21,37);X(13,45);X(29,45);X(13,21);X(29,37);X(5,9);X(13,17);X(21,25);X(29,33);X(37,41);X(3,35);X(19,35);X(11,43);X(27,43);X(11,19);X(27,35);X(7,39);X(23,39);X(15,47);X(31,47);X(15,23);X(31,39);X(7,11);X(15,19);X(23,27);X(31,35);X(39,43);X(3,5);X(7,9);X(11,13);X(15,17);X(19,21);X(23,25);X(27,29);X(31,33);X(35,37);X(39,41);X(43,45);X(1,2);X(3,4);X(5,6);X(7,8);X(9,10);X(11,12);X(13,14);X(15,16);X(17,18);X(19,20);X(21,22);X(23,24);\\nmedian = p[24];\\n#else\\n#error Unsupported kernel size\\n#endif\\ncolor = vec4(median, median, median, 1.0f);\\n}\"","var map = {\n\t\"./colors.glsl\": \"./src/gpu/shaders/include/colors.glsl\",\n\t\"./fixed-point.glsl\": \"./src/gpu/shaders/include/fixed-point.glsl\",\n\t\"./float16.glsl\": \"./src/gpu/shaders/include/float16.glsl\",\n\t\"./global.glsl\": \"./src/gpu/shaders/include/global.glsl\",\n\t\"./keypoints.glsl\": \"./src/gpu/shaders/include/keypoints.glsl\",\n\t\"./math.glsl\": \"./src/gpu/shaders/include/math.glsl\",\n\t\"./orientation.glsl\": \"./src/gpu/shaders/include/orientation.glsl\",\n\t\"./pyramids.glsl\": \"./src/gpu/shaders/include/pyramids.glsl\",\n\t\"./quickselect.glsl\": \"./src/gpu/shaders/include/quickselect.glsl\",\n\t\"./sobel.glsl\": \"./src/gpu/shaders/include/sobel.glsl\",\n\t\"./subpixel.glsl\": \"./src/gpu/shaders/include/subpixel.glsl\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./src/gpu/shaders/include sync recursive ^\\\\.\\\\/.*$\";","module.exports = \"#ifndef _COLORS_GLSL\\n#define _COLORS_GLSL\\n#define PIXELCOMPONENT_RED   @PIXELCOMPONENT_RED@\\n#define PIXELCOMPONENT_GREEN @PIXELCOMPONENT_GREEN@\\n#define PIXELCOMPONENT_BLUE  @PIXELCOMPONENT_BLUE@\\n#define PIXELCOMPONENT_ALPHA @PIXELCOMPONENT_ALPHA@\\n#endif\"","module.exports = \"#ifndef _FIXEDPOINT_GLSL\\n#define _FIXEDPOINT_GLSL\\n#define fixed_t int\\n#define fixed2_t ivec2\\nconst int FIX_BITS = int(@FIX_BITS@);\\nconst float FIX_RESOLUTION = float(@FIX_RESOLUTION@);\\n#define itofix(x) fixed_t((x) << FIX_BITS)\\n#define fixtoi(f) int((x) >> FIX_BITS)\\n#define ftofix(x) fixed_t((x) * FIX_RESOLUTION + 0.5f)\\n#define fixtof(f) (float(f) / FIX_RESOLUTION)\\n#define ivec2tofix(x) fixed2_t((x) << FIX_BITS)\\n#define fixtoivec2(f) ivec2((f) >> FIX_BITS)\\n#define vec2tofix(v) fixed2_t((v) * FIX_RESOLUTION + vec2(0.5f))\\n#define fixtovec2(f) (vec2(f) / FIX_RESOLUTION)\\n#endif\"","module.exports = \"#ifndef _FLOAT16_GLSL\\n#define _FLOAT16_GLSL\\n#define encodeFloat16(f) (vec2(packf16(f)) / 255.0f)\\n#define decodeFloat16(v) unpackf16(uvec2((v) * 255.0f))\\nuvec2 packf16( float f)\\n{\\nuint y = packHalf2x16(vec2(f, 0.0f));\\nreturn uvec2(y, y >> 8) & 0xFFu;\\n}\\nfloat unpackf16(uvec2 v)\\n{\\nv &= 0xFFu;\\nreturn unpackHalf2x16(v.x | (v.y << 8)).x;\\n}\\n#endif\"","module.exports = \"#ifndef _GLOBAL_GLSL\\n#define _GLOBAL_GLSL\\n#define threadLocation() ivec2(texCoord * texSize)\\n#define outputSize() ivec2(texSize)\\n#define threadPixel(img) textureLod((img), texCoord, 0.0f)\\n#define pixelAt(img, pos) texelFetch((img), (pos), 0)\\n#define pixelAtShortOffset(img, offset) textureLodOffset((img), texCoord, 0.0f, (offset))\\n#define pixelAtLongOffset(img, offset) textureLod((img), texCoord + vec2(offset) / texSize, 0.0f)\\n#endif\"","module.exports = \"#ifndef _KEYPOINTS_GLSL\\n#define _KEYPOINTS_GLSL\\n@include \\\"pyramids.glsl\\\"\\n@include \\\"orientation.glsl\\\"\\n@include \\\"fixed-point.glsl\\\"\\nstruct Keypoint\\n{\\nvec2 position;\\nfloat orientation;\\nfloat lod;\\nfloat score;\\nint flags;\\n};\\nstruct KeypointAddress\\n{\\nint base;\\nint offset;\\n};\\nconst int MAX_DESCRIPTOR_SIZE = int(@MAX_DESCRIPTOR_SIZE@);\\nconst int MIN_KEYPOINT_SIZE = int(@MIN_KEYPOINT_SIZE@);\\nconst int KPF_NONE = int(@KPF_NONE@);\\nconst int KPF_ORIENTED = int(@KPF_ORIENTED@);\\nconst int KPF_DISCARD = int(@KPF_DISCARD@);\\n#define encodeKeypointFlags(flags) (float(flags) / 255.0f)\\n#define decodeKeypointFlags(encodedFlags) int((encodedFlags) * 255.0f)\\n#define encodeNullKeypoint() (vec4(1.0f))\\n#define encodeDiscardedKeypoint() (vec4(0.0f))\\n#define sizeofEncodedKeypoint(descriptorSize, extraSize) (MIN_KEYPOINT_SIZE + (descriptorSize) + (extraSize))\\n#define findKeypointIndex(address, descriptorSize, extraSize) ((address).base / ((sizeofEncodedKeypoint((descriptorSize), (extraSize))) / 4))\\nvec4 readKeypointData(sampler2D encodedKeypoints, int encoderLength, KeypointAddress address)\\n{\\nint rasterIndex = address.base + address.offset;\\nvec4 data = pixelAt(encodedKeypoints, ivec2(rasterIndex % encoderLength, rasterIndex / encoderLength));\\nreturn rasterIndex < encoderLength * encoderLength ? data : encodeNullKeypoint();\\n}\\nKeypointAddress findKeypointAddress(ivec2 thread, int encoderLength, int descriptorSize, int extraSize)\\n{\\nint threadRaster = thread.y * encoderLength + thread.x;\\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\\nint keypointIndex = int(threadRaster / pixelsPerKeypoint);\\nKeypointAddress address = KeypointAddress(\\nkeypointIndex * pixelsPerKeypoint,\\nthreadRaster % pixelsPerKeypoint\\n);\\nreturn address;\\n}\\nKeypoint decodeKeypoint(sampler2D encodedKeypoints, int encoderLength, KeypointAddress address)\\n{\\nconst vec4 ones = vec4(1.0f);\\nKeypoint keypoint;\\nKeypointAddress positionAddress = KeypointAddress(address.base, 0);\\nKeypointAddress propertiesAddress = KeypointAddress(address.base, 1);\\nvec4 rawEncodedPosition = readKeypointData(encodedKeypoints, encoderLength, positionAddress);\\nivec4 encodedPosition = ivec4(rawEncodedPosition * 255.0f);\\nkeypoint.position = fixtovec2(fixed2_t(\\nencodedPosition.r | (encodedPosition.g << 8),\\nencodedPosition.b | (encodedPosition.a << 8)\\n));\\nvec4 encodedProperties = readKeypointData(encodedKeypoints, encoderLength, propertiesAddress);\\nkeypoint.orientation = decodeOrientation(encodedProperties.g);\\nkeypoint.lod = decodeLod(encodedProperties.r);\\nkeypoint.score = encodedProperties.b;\\nkeypoint.flags = decodeKeypointFlags(encodedProperties.a);\\nbool isNull = all(greaterThanEqual(rawEncodedPosition, ones));\\nkeypoint.score = keypoint.score * float(!isNull) - float(isNull);\\nkeypoint.score -= float(keypoint.score == 0.0f) * float(all(equal(keypoint.position, vec2(0.0f))));\\nreturn keypoint;\\n}\\nvec4 encodeKeypointPosition(vec2 position)\\n{\\nconst vec2 zeros = vec2(0.0f);\\nfixed2_t pos = vec2tofix(max(position, zeros));\\nfixed2_t lo = pos & 255;\\nfixed2_t hi = pos >> 8;\\nreturn vec4(lo.x, hi.x, lo.y, hi.y) / 255.0f;\\n}\\n#define isBadKeypoint(keypoint) ((keypoint).score < 0.0f)\\n#define encodeKeypointPositionAtInfinity() (vec4(254.0f / 255.0f, vec3(1.0f)))\\nbool isKeypointAtInfinity(Keypoint keypoint)\\n{\\nconst vec2 V2_MAX_TEXTURE_LENGTH = vec2(@MAX_TEXTURE_LENGTH@);\\nreturn any(greaterThan(keypoint.position, V2_MAX_TEXTURE_LENGTH));\\n}\\n#endif\"","module.exports = \"#ifndef _MATH_GLSL\\n#define _MATH_GLSL\\n#define TWO_PI          6.28318530718f\\n#define PI              3.14159265359f\\n#define PI_OVER_2       1.57079632679f\\n#define PI_OVER_4       0.78539816339f\\n#define INV_PI          0.3183098861837907f\\n#define USE_FAST_ATAN\\n#ifdef USE_FAST_ATAN\\nfloat fastAtan(float x)\\n{\\nfloat w = 1.0f - abs(x);\\nreturn (w >= 0.0f) ? ((PI_OVER_4 + 0.273 * w) * x) :\\n(sign(x) * PI_OVER_2 - (PI_OVER_4 + 0.273 * (1.0f - abs(1.0f / x))) / x);\\n}\\n#else\\n#define fastAtan(x) atan(x)\\n#endif\\n#ifdef USE_FAST_ATAN\\nfloat fastAtan2(float y, float x)\\n{\\nreturn (x == 0.0f) ? PI_OVER_2 * sign(y) : fastAtan(y / x) + float(x < 0.0f) * PI * sign(y);\\n}\\n#else\\n#define fastAtan2(y, x) atan((y), (x))\\n#endif\\n#endif\"","module.exports = \"#ifndef _ORIENTATION_GLSL\\n#define _ORIENTATION_GLSL\\n@include \\\"math.glsl\\\"\\n#define encodeOrientation(angle) (((angle) * INV_PI + 1.0f) * 0.5f)\\n#define decodeOrientation(value) (((value) * 2.0f - 1.0f) * PI)\\n#endif\"","module.exports = \"#ifndef _PYRAMIDS_GLSL\\n#define _PYRAMIDS_GLSL\\n#define pyrPixel(pyr, lod) textureLod((pyr), texCoord, (lod))\\n#define pyrPixelAtOffset(pyr, lod, pot, offset) textureLod((pyr), texCoord + ((pot) * vec2(offset)) / texSize, (lod))\\n#define pyrPixelAt(pyr, pos, lod) textureLod((pyr), (vec2(pos) + vec2(0.5f)) / texSize, (lod))\\n#define pyrPixelAtEx(pyr, pos, lod, pyrBaseSize) textureLod((pyr), (vec2(pos) + vec2(0.5f)) / vec2(pyrBaseSize), (lod))\\n#define pyrSubpixelAtEx(pyr, pos, lod, pyrBaseSize) textureLod((pyr), ((pos) + vec2(0.5f)) / vec2(pyrBaseSize), (lod))\\n#define pyrSubpixelAtExOffset(pyr, pos, lod, pot, offset, pyrBaseSize) textureLod((pyr), (((pos) + vec2(0.5f)) + ((pot) * vec2(offset))) / vec2(pyrBaseSize), (lod))\\nconst int PYRAMID_MAX_LEVELS = int(@PYRAMID_MAX_LEVELS@);\\nconst float F_PYRAMID_MAX_LEVELS = float(@PYRAMID_MAX_LEVELS@);\\nconst float LOG2_PYRAMID_MAX_SCALE = float(@LOG2_PYRAMID_MAX_SCALE@);\\nfloat encodeLod(float lod)\\n{\\nreturn (LOG2_PYRAMID_MAX_SCALE + lod) / (LOG2_PYRAMID_MAX_SCALE + F_PYRAMID_MAX_LEVELS);\\n}\\nfloat decodeLod(float encodedLod)\\n{\\nfloat lod = encodedLod * (LOG2_PYRAMID_MAX_SCALE + F_PYRAMID_MAX_LEVELS) - LOG2_PYRAMID_MAX_SCALE;\\nreturn lod - lod * step(1.0f, encodedLod);\\n}\\n#define isSameEncodedLod(alpha1, alpha2) (abs((alpha1) - (alpha2)) < encodedLodEps)\\nconst float encodedLodEps = 0.2f / (LOG2_PYRAMID_MAX_SCALE + F_PYRAMID_MAX_LEVELS);\\n#endif\"","module.exports = \"#ifndef _QUICKSELECT_GLSL\\n#define _QUICKSELECT_GLSL\\n#if defined(QUICKSELECT_UNSIGNED) && !defined(QUICKSELECT_SIGNED)\\n#define QS_TYPE uint\\n#define QS_TYPE4 uvec4\\n#elif !defined(QUICKSELECT_UNSIGNED) && defined(QUICKSELECT_SIGNED)\\n#define QS_TYPE int\\n#define QS_TYPE4 ivec4\\n#else\\n#error Must define either QUICKSELECT_SIGNED or QUICKSELECT_UNSIGNED before including quickselect\\n#endif\\n#if defined(QUICKSELECT_ASCENDING) && !defined(QUICKSELECT_DESCENDING)\\n#define QS_ORD(element,pivot) ((element) < (pivot))\\n#elif defined(QUICKSELECT_DESCENDING) && !defined(QUICKSELECT_ASCENDING)\\n#define QS_ORD(element,pivot) ((element) > (pivot))\\n#else\\n#error Must define either QUICKSELECT_ASCENDING or QUICKSELECT_DESCENDING before including quickselect\\n#endif\\n#ifdef QUICKSELECT_ARRAY\\n#define QS_ARRAY QUICKSELECT_ARRAY\\n#else\\n#error Must define QUICKSELECT_ARRAY before including quickselect\\n#endif\\nint qspart(int l, int r, int p)\\n{\\n#define QS_SWAP(a,b) t = QS_ARRAY[(a)]; QS_ARRAY[(a)] = QS_ARRAY[(b)]; QS_ARRAY[(b)] = t\\nhighp QS_TYPE e, t, mask, pivot = QS_ARRAY[p];\\nhighp QS_TYPE4 tmp;\\nint q, cond;\\nQS_SWAP(p, r);\\nq = l;\\nfor(int i = l; i < r; i++) {\\ne = QS_ARRAY[i];\\nt = QS_ARRAY[q];\\ncond = int(QS_ORD(e, pivot));\\nmask = QS_TYPE(-cond);\\ntmp = QS_TYPE4(mask & t, (~mask) & e, mask & e, (~mask) & t);\\nQS_ARRAY[i] = tmp.x | tmp.y;\\nQS_ARRAY[q] = tmp.z | tmp.w;\\nq += cond;\\n}\\nQS_SWAP(q, r);\\nreturn q;\\n}\\nhighp QS_TYPE quickselect(int l, int r, int k)\\n{\\nint p = -1337;\\nivec2 idx = ivec2(l, r);\\nwhile(idx.s < idx.t && p != k) {\\np = qspart(idx.s, idx.t, (idx.s + idx.t) / 2);\\nidx = int(k < p) * ivec2(idx.s, p-1) + int(k >= p) * ivec2(p+1, idx.t);\\n}\\nreturn (p == k) ? QS_ARRAY[k] : QS_ARRAY[idx.s];\\n}\\n#endif\"","module.exports = \"#ifndef _SOBEL_GLSL\\n#define _SOBEL_GLSL\\nvec4 encodeSobel(vec2 df)\\n{\\n#ifdef SOBEL_USE_LOG\\nconst vec2 zero = vec2(0.0f);\\nvec2 dmax = -max(df, zero);\\nvec2 dmin = min(df, zero);\\nreturn exp2(vec4(dmax, dmin));\\n#else\\nuint data = packHalf2x16(df);\\nuvec4 bytes = uvec4(data, data >> 8, data >> 16, data >> 24) & 255u;\\nreturn vec4(bytes) / 255.0f;\\n#endif\\n}\\nvec2 decodeSobel(vec4 encodedSobel)\\n{\\n#ifdef SOBEL_USE_LOG\\nvec4 lg = log2(encodedSobel);\\nreturn vec2(lg.b - lg.r, lg.a - lg.g);\\n#else\\nuvec4 bytes = uvec4(encodedSobel * 255.0f);\\nuint data = bytes.r | (bytes.g << 8) | (bytes.b << 16) | (bytes.a << 24);\\nreturn unpackHalf2x16(data);\\n#endif\\n}\\n#endif\"","module.exports = \"#ifndef _SUBPIXEL_GLSL\\n#define _SUBPIXEL_GLSL\\n#define subpixelAtHW(image, pos) textureLod((image), ((pos) + vec2(0.5f)) / texSize, 0.0f)\\nvec4 subpixelAtBI(sampler2D image, vec2 pos)\\n{\\nvec2 frc = fract(pos);\\nvec2 ifrc = vec2(1.0f) - frc;\\nvec2 p = (floor(pos) + vec2(0.5f)) / vec2(textureSize(image, 0));\\nvec4 pix00 = textureLod(image, p, 0.0f);\\nvec4 pix10 = textureLodOffset(image, p, 0.0f, ivec2(1,0));\\nvec4 pix01 = textureLodOffset(image, p, 0.0f, ivec2(0,1));\\nvec4 pix11 = textureLodOffset(image, p, 0.0f, ivec2(1,1));\\nmat4 pix = mat4(pix00, pix10, pix01, pix11);\\nvec4 mul = vec4(ifrc.x * ifrc.y, frc.x * ifrc.y, ifrc.x * frc.y, frc.x * frc.y);\\nreturn pix * mul;\\n}\\n#endif\"","module.exports = \"uniform sampler2D image, layerA, layerB;\\nuniform float scaleA, scaleB, lgM, h;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nfloat score = pixel.r;\\nivec2 zero = ivec2(0, 0);\\nivec2 sizeA = textureSize(layerA, 0);\\nivec2 sizeB = textureSize(layerB, 0);\\nvec2 mid = (texCoord * texSize) + vec2(0.5f, 0.5f);\\nivec2 pa = clamp(ivec2(ceil(mid * scaleA - 1.0f)), zero, sizeA - 2);\\nivec2 pb = clamp(ivec2(ceil(mid * scaleB - 1.0f)), zero, sizeB - 2);\\nvec4 a00 = pixelAt(layerA, pa);\\nvec4 a10 = pixelAt(layerA, pa + ivec2(1, 0));\\nvec4 a01 = pixelAt(layerA, pa + ivec2(0, 1));\\nvec4 a11 = pixelAt(layerA, pa + ivec2(1, 1));\\nvec4 b00 = pixelAt(layerB, pb);\\nvec4 b10 = pixelAt(layerB, pb + ivec2(1, 0));\\nvec4 b01 = pixelAt(layerB, pb + ivec2(0, 1));\\nvec4 b11 = pixelAt(layerB, pb + ivec2(1, 1));\\nfloat maxScore = max(\\nmax(max(a00.r, a10.r), max(a01.r, a11.r)),\\nmax(max(b00.r, b10.r), max(b01.r, b11.r))\\n);\\ncolor = vec4(0.0f, pixel.gba);\\nif(score < maxScore || score == 0.0f)\\nreturn;\\nvec2 ea = fract(mid * scaleA);\\nvec2 eb = fract(mid * scaleB);\\nfloat isa = a00.b * (1.0f - ea.x) * (1.0f - ea.y) +\\na10.b * ea.x * (1.0f - ea.y) +\\na01.b * (1.0f - ea.x) * ea.y +\\na11.b * ea.x * ea.y;\\nfloat isb = b00.b * (1.0f - eb.x) * (1.0f - eb.y) +\\nb10.b * eb.x * (1.0f - eb.y) +\\nb01.b * (1.0f - eb.x) * eb.y +\\nb11.b * eb.x * eb.y;\\ncolor = (isa > score && isa > isb) ? vec4(isa, pixel.gb, a00.a) : pixel;\\ncolor = (isb > score && isb > isa) ? vec4(isb, pixel.gb, b00.a) : pixel;\\nfloat y1 = isa, y2 = isb, y3 = score;\\nfloat x1 = lgM - (lgM + h) * a00.a;\\nfloat x2 = lgM - (lgM + h) * b00.a;\\nfloat x3 = lgM - (lgM + h) * pixel.a;\\nfloat dn = (x1 - x2) * (x1 - x3) * (x2 - x3);\\nif(abs(dn) < 0.00001f)\\nreturn;\\nfloat a = (x3 * (y2 - y1) + x2 * (y1 - y3) + x1 * (y3 - y2)) / dn;\\nif(a >= 0.0f)\\nreturn;\\nfloat b = (x3 * x3 * (y1 - y2) + x2 * x2 * (y3 - y1) + x1 * x1 * (y2 - y3)) / dn;\\nfloat c = (x2 * x3 * (x2 - x3) * y1 + x3 * x1 * (x3 - x1) * y2 + x1 * x2 * (x1 - x2) * y3) / dn;\\nfloat xv = -b / (2.0f * a);\\nfloat yv = c - (b * b) / (4.0f * a);\\nif(xv < min(x1, min(x2, x3)) || xv > max(x1, max(x2, x3)))\\nreturn;\\nfloat interpolatedScale = (lgM - xv) / (lgM + h);\\nfloat interpolatedScore = clamp(yv, 0.0f, 1.0f);\\ncolor = vec4(interpolatedScore, pixel.gb, interpolatedScale);\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform sampler2D encodedKeypoints;\\nuniform int inputDescriptorSize;\\nuniform int inputExtraSize;\\nuniform int inputEncoderLength;\\nuniform int outputDescriptorSize;\\nuniform int outputExtraSize;\\nuniform int outputEncoderLength;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(encodedKeypoints);\\nivec2 thread = threadLocation();\\nKeypointAddress myAddress = findKeypointAddress(\\nthread,\\noutputEncoderLength,\\noutputDescriptorSize,\\noutputExtraSize\\n);\\nint myIndex = findKeypointIndex(\\nmyAddress,\\noutputDescriptorSize,\\noutputExtraSize\\n);\\nint pixelsPerKeypoint = sizeofEncodedKeypoint(inputDescriptorSize, inputExtraSize) / 4;\\nKeypointAddress otherAddress = KeypointAddress(\\nmyIndex * pixelsPerKeypoint,\\nmyAddress.offset\\n);\\nbool head = myAddress.offset < MIN_KEYPOINT_SIZE / 4;\\nvec4 data = head ? readKeypointData(encodedKeypoints, inputEncoderLength, otherAddress) : vec4(0.0f);\\nbool drop = outputDescriptorSize < inputDescriptorSize || outputExtraSize < inputExtraSize;\\ncolor = drop ? encodeNullKeypoint() : data;\\n}\"","module.exports = \"@include \\\"pyramids.glsl\\\"\\n@include \\\"float16.glsl\\\"\\nuniform sampler2D corners;\\nuniform sampler2D pyramid;\\nuniform float lod;\\nuniform int threshold;\\n#define PIX(x,y) pyrPixelAtOffset(pyramid, lod, pot, ivec2((x),(y))).g\\nvoid main()\\n{\\nfloat pixel = threadPixel(pyramid).g;\\nvec4 prev = threadPixel(corners);\\nivec2 thread = threadLocation();\\nivec2 size = outputSize();\\nfloat pot = exp2(lod);\\nfloat t = float(clamp(threshold, 0, 255)) / 255.0f;\\nfloat ct = pixel + t, c_t = pixel - t;\\ncolor = vec4(prev.r, pixel, prev.ba);\\n#if !defined(FAST_TYPE)\\n#error Must define FAST_TYPE\\n#elif FAST_TYPE == 916\\nconst ivec4 margin = ivec4(3, 3, 4, 4);\\nif(any(lessThan(ivec4(thread, size - thread), margin)))\\nreturn;\\nfloat p0 = PIX(0,3), p4 = PIX(3,0), p8 = PIX(0,-3), p12 = PIX(-3,0);\\nbvec4 brighter = bvec4(p0 > ct, p4 > ct, p8 > ct, p12 > ct);\\nbvec4 darker = bvec4(p0 < c_t, p4 < c_t, p8 < c_t, p12 < c_t);\\nbvec4 bpairs = bvec4(all(brighter.xy), all(brighter.yz), all(brighter.zw), all(brighter.wx));\\nbvec4 dpairs = bvec4(all(darker.xy), all(darker.yz), all(darker.zw), all(darker.wx));\\nif(!(any(bpairs) || any(dpairs)))\\nreturn;\\nfloat p1 = PIX(1,3), p2 = PIX(2,2), p3 = PIX(3,1);\\nfloat p5 = PIX(3,-1), p6 = PIX(2,-2), p7 = PIX(1,-3);\\nfloat p9 = PIX(-1,-3), p10 = PIX(-2,-2), p11 = PIX(-3,-1);\\nfloat p13 = PIX(-3,1), p14 = PIX(-2,2), p15 = PIX(-1,3);\\nbool A=(p0>ct),B=(p1>ct),C=(p2>ct),D=(p3>ct),E=(p4>ct),F=(p5>ct),G=(p6>ct),H=(p7>ct),I=(p8>ct),J=(p9>ct),K=(p10>ct),L=(p11>ct),M=(p12>ct),N=(p13>ct),O=(p14>ct),P=(p15>ct),a=(p0<c_t),b=(p1<c_t),c=(p2<c_t),d=(p3<c_t),e=(p4<c_t),f=(p5<c_t),g=(p6<c_t),h=(p7<c_t),i=(p8<c_t),j=(p9<c_t),k=(p10<c_t),l=(p11<c_t),m=(p12<c_t),n=(p13<c_t),o=(p14<c_t),p=(p15<c_t);\\nbool isCorner=A&&(B&&(K&&L&&J&&(M&&N&&O&&P||G&&H&&I&&(M&&N&&O||F&&(M&&N||E&&(M||D))))||C&&(K&&L&&M&&(N&&O&&P||G&&H&&I&&J&&(N&&O||F&&(N||E)))||D&&(N&&(L&&M&&(K&&G&&H&&I&&J&&(O||F)||O&&P)||k&&l&&m&&e&&f&&g&&h&&i&&j)||E&&(O&&(M&&N&&(K&&L&&G&&H&&I&&J||P)||k&&l&&m&&n&&f&&g&&h&&i&&j)||F&&(P&&(N&&O||k&&l&&m&&n&&o&&g&&h&&i&&j)||G&&(O&&P||H&&(P||I)||k&&l&&m&&n&&o&&p&&h&&i&&j)||k&&l&&m&&n&&o&&h&&i&&j&&(p||g))||k&&l&&m&&n&&h&&i&&j&&(o&&(p||g)||f&&(o&&p||g)))||k&&l&&m&&h&&i&&j&&(n&&(o&&p||g&&(o||f))||e&&(n&&o&&p||g&&(n&&o||f))))||k&&l&&h&&i&&j&&(m&&(n&&o&&p||g&&(n&&o||f&&(n||e)))||d&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e)))))||k&&h&&i&&j&&(l&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d))))))||K&&I&&J&&(L&&M&&N&&O&&P||G&&H&&(L&&M&&N&&O||F&&(L&&M&&N||E&&(L&&M||D&&(L||C)))))||h&&i&&j&&(b&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c)))))||k&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c)))))))||B&&(H&&I&&J&&(K&&L&&M&&N&&O&&P&&a||G&&(K&&L&&M&&N&&O&&a||F&&(K&&L&&M&&N&&a||E&&(K&&L&&M&&a||D&&(K&&L&&a||C)))))||a&&k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||C&&(K&&H&&I&&J&&(L&&M&&N&&O&&P&&a&&b||G&&(L&&M&&N&&O&&a&&b||F&&(L&&M&&N&&a&&b||E&&(L&&M&&a&&b||D))))||a&&b&&k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d)))))||D&&(K&&L&&H&&I&&J&&(M&&N&&O&&P&&a&&b&&c||G&&(M&&N&&O&&a&&b&&c||F&&(M&&N&&a&&b&&c||E)))||a&&b&&k&&l&&m&&c&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e))))||E&&(K&&L&&M&&H&&I&&J&&(N&&O&&P&&a&&b&&c&&d||G&&(N&&O&&a&&b&&c&&d||F))||a&&b&&l&&m&&n&&c&&d&&(k&&g&&h&&i&&j&&(o||f)||o&&p))||F&&(K&&L&&M&&N&&H&&I&&J&&(O&&P&&a&&b&&c&&d&&e||G)||a&&b&&m&&n&&o&&c&&d&&e&&(k&&l&&g&&h&&i&&j||p))||G&&(K&&L&&M&&N&&O&&H&&I&&J||a&&b&&n&&o&&p&&c&&d&&e&&f)||H&&(K&&L&&M&&N&&O&&P&&I&&J||a&&b&&o&&p&&c&&d&&e&&f&&g)||a&&(b&&(k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(k&&l&&m&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e)))||d&&(l&&m&&n&&(k&&g&&h&&i&&j&&(o||f)||o&&p)||e&&(m&&n&&o&&(k&&l&&g&&h&&i&&j||p)||f&&(n&&o&&p||g&&(o&&p||h&&(p||i)))))))||k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||h&&i&&j&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c&&(b||k))))));\\nif(!isCorner)\\nreturn;\\nmat4 mp = mat4(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15);\\nmat4 mct = mp - mat4(ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct);\\nmat4 mc_t = mat4(c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t) - mp;\\nconst vec4 zeros = vec4(0.0f), ones = vec4(1.0f);\\nvec4 bs = max(mct[0], zeros), ds = max(mc_t[0], zeros);\\nbs += max(mct[1], zeros);     ds += max(mc_t[1], zeros);\\nbs += max(mct[2], zeros);     ds += max(mc_t[2], zeros);\\nbs += max(mct[3], zeros);     ds += max(mc_t[3], zeros);\\nfloat thisScore = max(dot(bs, ones), dot(ds, ones)) / 16.0f;\\nfloat prevScore = decodeFloat16(prev.rb);\\nvec3 thisResult = vec3(encodeFloat16(thisScore), encodeLod(lod));\\ncolor.rba = thisScore > prevScore ? thisResult : color.rba;\\n#else\\n#error Unrecognized FAST_TYPE\\n#endif\\n}\"","module.exports = \"@include \\\"float16.glsl\\\"\\nuniform sampler2D image;\\nuniform float threshold;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nfloat t = clamp(threshold, 0.0f, 1.0f);\\nfloat ct = pixel.g + t, c_t = pixel.g - t;\\nfloat p0 = pixelAtShortOffset(image, ivec2(0, 2)).g;\\nfloat p1 = pixelAtShortOffset(image, ivec2(1, 2)).g;\\nfloat p2 = pixelAtShortOffset(image, ivec2(2, 1)).g;\\nfloat p3 = pixelAtShortOffset(image, ivec2(2, 0)).g;\\nfloat p4 = pixelAtShortOffset(image, ivec2(2, -1)).g;\\nfloat p5 = pixelAtShortOffset(image, ivec2(1, -2)).g;\\nfloat p6 = pixelAtShortOffset(image, ivec2(0, -2)).g;\\nfloat p7 = pixelAtShortOffset(image, ivec2(-1, -2)).g;\\nfloat p8 = pixelAtShortOffset(image, ivec2(-2, -1)).g;\\nfloat p9 = pixelAtShortOffset(image, ivec2(-2, 0)).g;\\nfloat p10 = pixelAtShortOffset(image, ivec2(-2, 1)).g;\\nfloat p11 = pixelAtShortOffset(image, ivec2(-1, 2)).g;\\nvec2 scores = vec2(0.0f, 0.0f);\\nscores += vec2(max(c_t - p0, 0.0f), max(p0 - ct, 0.0f));\\nscores += vec2(max(c_t - p1, 0.0f), max(p1 - ct, 0.0f));\\nscores += vec2(max(c_t - p2, 0.0f), max(p2 - ct, 0.0f));\\nscores += vec2(max(c_t - p3, 0.0f), max(p3 - ct, 0.0f));\\nscores += vec2(max(c_t - p4, 0.0f), max(p4 - ct, 0.0f));\\nscores += vec2(max(c_t - p5, 0.0f), max(p5 - ct, 0.0f));\\nscores += vec2(max(c_t - p6, 0.0f), max(p6 - ct, 0.0f));\\nscores += vec2(max(c_t - p7, 0.0f), max(p7 - ct, 0.0f));\\nscores += vec2(max(c_t - p8, 0.0f), max(p8 - ct, 0.0f));\\nscores += vec2(max(c_t - p9, 0.0f), max(p9 - ct, 0.0f));\\nscores += vec2(max(c_t - p10, 0.0f), max(p10 - ct, 0.0f));\\nscores += vec2(max(c_t - p11, 0.0f), max(p11 - ct, 0.0f));\\nscores /= 12.0f;\\nfloat score = max(scores.x, scores.y) * step(1.0f, pixel.r);\\ncolor = pixel;\\ncolor.rb = encodeFloat16(score);\\n}\"","module.exports = \"@include \\\"float16.glsl\\\"\\nuniform sampler2D image;\\nuniform float threshold;\\nconst vec4 zeroes = vec4(0.0f, 0.0f, 0.0f, 0.0f);\\nconst vec4 ones = vec4(1.0f, 1.0f, 1.0f, 1.0f);\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nfloat t = clamp(threshold, 0.0f, 1.0f);\\nfloat ct = pixel.g + t, c_t = pixel.g - t;\\nmat4 mp = mat4(\\npixelAtShortOffset(image, ivec2(0, 3)).g,\\npixelAtShortOffset(image, ivec2(1, 3)).g,\\npixelAtShortOffset(image, ivec2(2, 2)).g,\\npixelAtShortOffset(image, ivec2(3, 1)).g,\\npixelAtShortOffset(image, ivec2(3, 0)).g,\\npixelAtShortOffset(image, ivec2(3, -1)).g,\\npixelAtShortOffset(image, ivec2(2, -2)).g,\\npixelAtShortOffset(image, ivec2(1, -3)).g,\\npixelAtShortOffset(image, ivec2(0, -3)).g,\\npixelAtShortOffset(image, ivec2(-1, -3)).g,\\npixelAtShortOffset(image, ivec2(-2, -2)).g,\\npixelAtShortOffset(image, ivec2(-3, -1)).g,\\npixelAtShortOffset(image, ivec2(-3, 0)).g,\\npixelAtShortOffset(image, ivec2(-3, 1)).g,\\npixelAtShortOffset(image, ivec2(-2, 2)).g,\\npixelAtShortOffset(image, ivec2(-1, 3)).g\\n);\\nmat4 mct = mp - mat4(\\nct, ct, ct, ct,\\nct, ct, ct, ct,\\nct, ct, ct, ct,\\nct, ct, ct, ct\\n), mc_t = mat4(\\nc_t, c_t, c_t, c_t,\\nc_t, c_t, c_t, c_t,\\nc_t, c_t, c_t, c_t,\\nc_t, c_t, c_t, c_t\\n) - mp;\\nvec4 bs = max(mc_t[0], zeroes), ds = max(mct[0], zeroes);\\nbs += max(mc_t[1], zeroes); ds += max(mct[1], zeroes);\\nbs += max(mc_t[2], zeroes); ds += max(mct[2], zeroes);\\nbs += max(mc_t[3], zeroes); ds += max(mct[3], zeroes);\\nfloat score = max(dot(bs, ones), dot(ds, ones)) * step(1.0f, pixel.r);\\nscore /= 16.0f;\\ncolor = pixel;\\ncolor.rb = encodeFloat16(score);\\n}\"","module.exports = \"@include \\\"float16.glsl\\\"\\nuniform sampler2D image;\\nuniform float threshold;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nfloat t = clamp(threshold, 0.0f, 1.0f);\\nfloat ct = pixel.g + t, c_t = pixel.g - t;\\nfloat p0 = pixelAtShortOffset(image, ivec2(0, 1)).g;\\nfloat p1 = pixelAtShortOffset(image, ivec2(1, 1)).g;\\nfloat p2 = pixelAtShortOffset(image, ivec2(1, 0)).g;\\nfloat p3 = pixelAtShortOffset(image, ivec2(1, -1)).g;\\nfloat p4 = pixelAtShortOffset(image, ivec2(0, -1)).g;\\nfloat p5 = pixelAtShortOffset(image, ivec2(-1, -1)).g;\\nfloat p6 = pixelAtShortOffset(image, ivec2(-1, 0)).g;\\nfloat p7 = pixelAtShortOffset(image, ivec2(-1, 1)).g;\\nvec2 scores = vec2(0.0f, 0.0f);\\nscores += vec2(max(c_t - p0, 0.0f), max(p0 - ct, 0.0f));\\nscores += vec2(max(c_t - p1, 0.0f), max(p1 - ct, 0.0f));\\nscores += vec2(max(c_t - p2, 0.0f), max(p2 - ct, 0.0f));\\nscores += vec2(max(c_t - p3, 0.0f), max(p3 - ct, 0.0f));\\nscores += vec2(max(c_t - p4, 0.0f), max(p4 - ct, 0.0f));\\nscores += vec2(max(c_t - p5, 0.0f), max(p5 - ct, 0.0f));\\nscores += vec2(max(c_t - p6, 0.0f), max(p6 - ct, 0.0f));\\nscores += vec2(max(c_t - p7, 0.0f), max(p7 - ct, 0.0f));\\nscores /= 8.0f;\\nfloat score = max(scores.x, scores.y) * step(1.0f, pixel.r);\\ncolor = pixel;\\ncolor.rb = encodeFloat16(score);\\n}\"","module.exports = \"@include \\\"pyramids.glsl\\\"\\nuniform sampler2D image;\\nuniform float threshold;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nivec2 size = outputSize();\\nvec4 pixel = threadPixel(image);\\ncolor = vec4(0.0f, pixel.g, 0.0f, encodeLod(0.0f));\\nif(\\nthread.x >= 3 && thread.x < size.x - 3 &&\\nthread.y >= 3 && thread.y < size.y - 3\\n) {\\nfloat t = clamp(threshold, 0.0f, 1.0f);\\nfloat c = pixel.g;\\nfloat ct = c + t, c_t = c - t;\\nfloat p0 = pixelAtShortOffset(image, ivec2(0, 1)).g;\\nfloat p1 = pixelAtShortOffset(image, ivec2(1, 1)).g;\\nfloat p2 = pixelAtShortOffset(image, ivec2(1, 0)).g;\\nfloat p3 = pixelAtShortOffset(image, ivec2(1, -1)).g;\\nfloat p4 = pixelAtShortOffset(image, ivec2(0, -1)).g;\\nfloat p5 = pixelAtShortOffset(image, ivec2(-1, -1)).g;\\nfloat p6 = pixelAtShortOffset(image, ivec2(-1, 0)).g;\\nfloat p7 = pixelAtShortOffset(image, ivec2(-1, 1)).g;\\nbool possibleCorner =\\n((c_t > p1 || c_t > p5) && (c_t > p3 || c_t > p7)) ||\\n((ct < p1  || ct < p5)  && (ct < p3  || ct < p7))  ;\\nif(possibleCorner) {\\nint bright = 0, dark = 0, bc = 0, dc = 0;\\nif(c_t > p0) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p0) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p1) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p1) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p2) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p2) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p3) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p3) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p4) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p4) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p5) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p5) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p6) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p6) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p7) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p7) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(bright < 5 && dark < 5) {\\nif(bc > 0 && bc < 5) do {\\nif(c_t > p0)           bc += 1; else break;\\nif(c_t > p1 && bc < 5) bc += 1; else break;\\nif(c_t > p2 && bc < 5) bc += 1; else break;\\nif(c_t > p3 && bc < 5) bc += 1; else break;\\n} while(false);\\nif(dc > 0 && dc < 5) do {\\nif(ct < p0)           dc += 1; else break;\\nif(ct < p1 && dc < 5) dc += 1; else break;\\nif(ct < p2 && dc < 5) dc += 1; else break;\\nif(ct < p3 && dc < 5) dc += 1; else break;\\n} while(false);\\nif(bc >= 5 || dc >= 5)\\ncolor.r = 1.0f;\\n}\\nelse {\\ncolor.r = 1.0f;\\n}\\n}\\n}\\n}\"","module.exports = \"@include \\\"pyramids.glsl\\\"\\nuniform sampler2D image;\\nuniform float threshold;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nivec2 size = outputSize();\\nvec4 pixel = threadPixel(image);\\ncolor = vec4(0.0f, pixel.g, 0.0f, encodeLod(0.0f));\\nif(\\nthread.x >= 3 && thread.x < size.x - 3 &&\\nthread.y >= 3 && thread.y < size.y - 3\\n) {\\nfloat t = clamp(threshold, 0.0f, 1.0f);\\nfloat c = pixel.g;\\nfloat ct = c + t, c_t = c - t;\\nfloat p0 = pixelAtShortOffset(image, ivec2(0, 2)).g;\\nfloat p1 = pixelAtShortOffset(image, ivec2(1, 2)).g;\\nfloat p2 = pixelAtShortOffset(image, ivec2(2, 1)).g;\\nfloat p3 = pixelAtShortOffset(image, ivec2(2, 0)).g;\\nfloat p4 = pixelAtShortOffset(image, ivec2(2, -1)).g;\\nfloat p5 = pixelAtShortOffset(image, ivec2(1, -2)).g;\\nfloat p6 = pixelAtShortOffset(image, ivec2(0, -2)).g;\\nfloat p7 = pixelAtShortOffset(image, ivec2(-1, -2)).g;\\nfloat p8 = pixelAtShortOffset(image, ivec2(-2, -1)).g;\\nfloat p9 = pixelAtShortOffset(image, ivec2(-2, 0)).g;\\nfloat p10 = pixelAtShortOffset(image, ivec2(-2, 1)).g;\\nfloat p11 = pixelAtShortOffset(image, ivec2(-1, 2)).g;\\nbool possibleCorner =\\n((c_t > p0 || c_t > p6) && (c_t > p3 || c_t > p9)) ||\\n((ct < p0  || ct < p6)  && (ct < p3  || ct < p9))  ;\\nif(possibleCorner) {\\nint bright = 0, dark = 0, bc = 0, dc = 0;\\nif(c_t > p0) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p0) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p1) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p1) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p2) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p2) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p3) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p3) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p4) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p4) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p5) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p5) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p6) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p6) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p7) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p7) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p8) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p8) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p9) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p9) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p10) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p10) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p11) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p11) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(bright < 7 && dark < 7) {\\nif(bc > 0 && bc < 7) do {\\nif(c_t > p0)           bc += 1; else break;\\nif(c_t > p1 && bc < 7) bc += 1; else break;\\nif(c_t > p2 && bc < 7) bc += 1; else break;\\nif(c_t > p3 && bc < 7) bc += 1; else break;\\nif(c_t > p4 && bc < 7) bc += 1; else break;\\nif(c_t > p5 && bc < 7) bc += 1; else break;\\n} while(false);\\nif(dc > 0 && dc < 7) do {\\nif(ct < p0)           dc += 1; else break;\\nif(ct < p1 && dc < 7) dc += 1; else break;\\nif(ct < p2 && dc < 7) dc += 1; else break;\\nif(ct < p3 && dc < 7) dc += 1; else break;\\nif(ct < p4 && dc < 7) dc += 1; else break;\\nif(ct < p5 && dc < 7) dc += 1; else break;\\n} while(false);\\nif(bc >= 7 || dc >= 7)\\ncolor.r = 1.0f;\\n}\\nelse {\\ncolor.r = 1.0f;\\n}\\n}\\n}\\n}\"","module.exports = \"@include \\\"pyramids.glsl\\\"\\nuniform sampler2D image;\\nuniform float threshold;\\nconst ivec4 margin = ivec4(3, 3, 4, 4);\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nivec2 thread = threadLocation();\\nivec2 size = outputSize();\\ncolor = vec4(0.0f, pixel.g, 0.0f, encodeLod(0.0f));\\nif(any(lessThan(ivec4(thread, size - thread), margin)))\\nreturn;\\nfloat t = clamp(threshold, 0.0f, 1.0f);\\nfloat ct = pixel.g + t, c_t = pixel.g - t;\\nfloat p0 = pixelAtShortOffset(image, ivec2(0, 3)).g;\\nfloat p4 = pixelAtShortOffset(image, ivec2(3, 0)).g;\\nfloat p8 = pixelAtShortOffset(image, ivec2(0, -3)).g;\\nfloat p12 = pixelAtShortOffset(image, ivec2(-3, 0)).g;\\nif(!(\\n((c_t > p0 || c_t > p8) && (c_t > p4 || c_t > p12)) ||\\n((ct < p0  || ct < p8)  && (ct < p4  || ct < p12))\\n))\\nreturn;\\nfloat p1 = pixelAtShortOffset(image, ivec2(1, 3)).g;\\nfloat p2 = pixelAtShortOffset(image, ivec2(2, 2)).g;\\nfloat p3 = pixelAtShortOffset(image, ivec2(3, 1)).g;\\nfloat p5 = pixelAtShortOffset(image, ivec2(3, -1)).g;\\nfloat p6 = pixelAtShortOffset(image, ivec2(2, -2)).g;\\nfloat p7 = pixelAtShortOffset(image, ivec2(1, -3)).g;\\nfloat p9 = pixelAtShortOffset(image, ivec2(-1, -3)).g;\\nfloat p10 = pixelAtShortOffset(image, ivec2(-2, -2)).g;\\nfloat p11 = pixelAtShortOffset(image, ivec2(-3, -1)).g;\\nfloat p13 = pixelAtShortOffset(image, ivec2(-3, 1)).g;\\nfloat p14 = pixelAtShortOffset(image, ivec2(-2, 2)).g;\\nfloat p15 = pixelAtShortOffset(image, ivec2(-1, 3)).g;\\nbool A=(p0>ct),B=(p1>ct),C=(p2>ct),D=(p3>ct),E=(p4>ct),F=(p5>ct),G=(p6>ct),H=(p7>ct),I=(p8>ct),J=(p9>ct),K=(p10>ct),L=(p11>ct),M=(p12>ct),N=(p13>ct),O=(p14>ct),P=(p15>ct),a=(p0<c_t),b=(p1<c_t),c=(p2<c_t),d=(p3<c_t),e=(p4<c_t),f=(p5<c_t),g=(p6<c_t),h=(p7<c_t),i=(p8<c_t),j=(p9<c_t),k=(p10<c_t),l=(p11<c_t),m=(p12<c_t),n=(p13<c_t),o=(p14<c_t),p=(p15<c_t);\\nbool isCorner=A&&(B&&(K&&L&&J&&(M&&N&&O&&P||G&&H&&I&&(M&&N&&O||F&&(M&&N||E&&(M||D))))||C&&(K&&L&&M&&(N&&O&&P||G&&H&&I&&J&&(N&&O||F&&(N||E)))||D&&(N&&(L&&M&&(K&&G&&H&&I&&J&&(O||F)||O&&P)||k&&l&&m&&e&&f&&g&&h&&i&&j)||E&&(O&&(M&&N&&(K&&L&&G&&H&&I&&J||P)||k&&l&&m&&n&&f&&g&&h&&i&&j)||F&&(P&&(N&&O||k&&l&&m&&n&&o&&g&&h&&i&&j)||G&&(O&&P||H&&(P||I)||k&&l&&m&&n&&o&&p&&h&&i&&j)||k&&l&&m&&n&&o&&h&&i&&j&&(p||g))||k&&l&&m&&n&&h&&i&&j&&(o&&(p||g)||f&&(o&&p||g)))||k&&l&&m&&h&&i&&j&&(n&&(o&&p||g&&(o||f))||e&&(n&&o&&p||g&&(n&&o||f))))||k&&l&&h&&i&&j&&(m&&(n&&o&&p||g&&(n&&o||f&&(n||e)))||d&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e)))))||k&&h&&i&&j&&(l&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d))))))||K&&I&&J&&(L&&M&&N&&O&&P||G&&H&&(L&&M&&N&&O||F&&(L&&M&&N||E&&(L&&M||D&&(L||C)))))||h&&i&&j&&(b&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c)))))||k&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c)))))))||B&&(H&&I&&J&&(K&&L&&M&&N&&O&&P&&a||G&&(K&&L&&M&&N&&O&&a||F&&(K&&L&&M&&N&&a||E&&(K&&L&&M&&a||D&&(K&&L&&a||C)))))||a&&k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||C&&(K&&H&&I&&J&&(L&&M&&N&&O&&P&&a&&b||G&&(L&&M&&N&&O&&a&&b||F&&(L&&M&&N&&a&&b||E&&(L&&M&&a&&b||D))))||a&&b&&k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d)))))||D&&(K&&L&&H&&I&&J&&(M&&N&&O&&P&&a&&b&&c||G&&(M&&N&&O&&a&&b&&c||F&&(M&&N&&a&&b&&c||E)))||a&&b&&k&&l&&m&&c&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e))))||E&&(K&&L&&M&&H&&I&&J&&(N&&O&&P&&a&&b&&c&&d||G&&(N&&O&&a&&b&&c&&d||F))||a&&b&&l&&m&&n&&c&&d&&(k&&g&&h&&i&&j&&(o||f)||o&&p))||F&&(K&&L&&M&&N&&H&&I&&J&&(O&&P&&a&&b&&c&&d&&e||G)||a&&b&&m&&n&&o&&c&&d&&e&&(k&&l&&g&&h&&i&&j||p))||G&&(K&&L&&M&&N&&O&&H&&I&&J||a&&b&&n&&o&&p&&c&&d&&e&&f)||H&&(K&&L&&M&&N&&O&&P&&I&&J||a&&b&&o&&p&&c&&d&&e&&f&&g)||a&&(b&&(k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(k&&l&&m&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e)))||d&&(l&&m&&n&&(k&&g&&h&&i&&j&&(o||f)||o&&p)||e&&(m&&n&&o&&(k&&l&&g&&h&&i&&j||p)||f&&(n&&o&&p||g&&(o&&p||h&&(p||i)))))))||k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||h&&i&&j&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c&&(b||k))))));\\ncolor.r = float(isCorner);\\n}\"","module.exports = \"@include \\\"pyramids.glsl\\\"\\n@include \\\"float16.glsl\\\"\\nuniform sampler2D pyramid;\\nuniform float threshold;\\nuniform int numberOfLayers;\\nuniform float lodStep;\\nconst ivec4 margin = ivec4(3, 3, 4, 4);\\nconst vec4 zeroes = vec4(0.0f, 0.0f, 0.0f, 0.0f);\\nconst vec4 ones = vec4(1.0f, 1.0f, 1.0f, 1.0f);\\nvoid main()\\n{\\nvec4 pixel = threadPixel(pyramid);\\nivec2 thread = threadLocation();\\nivec2 size = outputSize();\\nfloat t = clamp(threshold, 0.0f, 1.0f);\\nfloat ct = pixel.g + t, c_t = pixel.g - t;\\nvec2 best = vec2(0.0f);\\ncolor = vec4(0.0f, pixel.g, 0.0f, pixel.a);\\nfloat lod = 0.0f, pot = 1.0f;\\nfor(int layer = 0; layer < numberOfLayers; layer++) {\\npixel = pyrPixel(pyramid, lod);\\nct = pixel.g + t;\\nc_t = pixel.g - t;\\nvec4 p4k = vec4(\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(0, 3)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(3, 0)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(0, -3)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-3, 0)).g\\n);\\nmat4 mp = mat4(\\np4k.x,\\np4k.y,\\np4k.z,\\np4k.w,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(1, 3)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(3, -1)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-1, -3)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-3, 1)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(2, 2)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(2, -2)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-2, -2)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-2, 2)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(3, 1)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(1, -3)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-3, -1)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-1, 3)).g\\n);\\nbool A=(mp[0][0]>ct),B=(mp[1][0]>ct),C=(mp[2][0]>ct),D=(mp[3][0]>ct),E=(mp[0][1]>ct),F=(mp[1][1]>ct),G=(mp[2][1]>ct),H=(mp[3][1]>ct),I=(mp[0][2]>ct),J=(mp[1][2]>ct),K=(mp[2][2]>ct),L=(mp[3][2]>ct),M=(mp[0][3]>ct),N=(mp[1][3]>ct),O=(mp[2][3]>ct),P=(mp[3][3]>ct),a=(mp[0][0]<c_t),b=(mp[1][0]<c_t),c=(mp[2][0]<c_t),d=(mp[3][0]<c_t),e=(mp[0][1]<c_t),f=(mp[1][1]<c_t),g=(mp[2][1]<c_t),h=(mp[3][1]<c_t),i=(mp[0][2]<c_t),j=(mp[1][2]<c_t),k=(mp[2][2]<c_t),l=(mp[3][2]<c_t),m=(mp[0][3]<c_t),n=(mp[1][3]<c_t),o=(mp[2][3]<c_t),p=(mp[3][3]<c_t);\\nbool isCorner=A&&(B&&(K&&L&&J&&(M&&N&&O&&P||G&&H&&I&&(M&&N&&O||F&&(M&&N||E&&(M||D))))||C&&(K&&L&&M&&(N&&O&&P||G&&H&&I&&J&&(N&&O||F&&(N||E)))||D&&(N&&(L&&M&&(K&&G&&H&&I&&J&&(O||F)||O&&P)||k&&l&&m&&e&&f&&g&&h&&i&&j)||E&&(O&&(M&&N&&(K&&L&&G&&H&&I&&J||P)||k&&l&&m&&n&&f&&g&&h&&i&&j)||F&&(P&&(N&&O||k&&l&&m&&n&&o&&g&&h&&i&&j)||G&&(O&&P||H&&(P||I)||k&&l&&m&&n&&o&&p&&h&&i&&j)||k&&l&&m&&n&&o&&h&&i&&j&&(p||g))||k&&l&&m&&n&&h&&i&&j&&(o&&(p||g)||f&&(o&&p||g)))||k&&l&&m&&h&&i&&j&&(n&&(o&&p||g&&(o||f))||e&&(n&&o&&p||g&&(n&&o||f))))||k&&l&&h&&i&&j&&(m&&(n&&o&&p||g&&(n&&o||f&&(n||e)))||d&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e)))))||k&&h&&i&&j&&(l&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d))))))||K&&I&&J&&(L&&M&&N&&O&&P||G&&H&&(L&&M&&N&&O||F&&(L&&M&&N||E&&(L&&M||D&&(L||C)))))||h&&i&&j&&(b&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c)))))||k&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c)))))))||B&&(H&&I&&J&&(K&&L&&M&&N&&O&&P&&a||G&&(K&&L&&M&&N&&O&&a||F&&(K&&L&&M&&N&&a||E&&(K&&L&&M&&a||D&&(K&&L&&a||C)))))||a&&k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||C&&(K&&H&&I&&J&&(L&&M&&N&&O&&P&&a&&b||G&&(L&&M&&N&&O&&a&&b||F&&(L&&M&&N&&a&&b||E&&(L&&M&&a&&b||D))))||a&&b&&k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d)))))||D&&(K&&L&&H&&I&&J&&(M&&N&&O&&P&&a&&b&&c||G&&(M&&N&&O&&a&&b&&c||F&&(M&&N&&a&&b&&c||E)))||a&&b&&k&&l&&m&&c&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e))))||E&&(K&&L&&M&&H&&I&&J&&(N&&O&&P&&a&&b&&c&&d||G&&(N&&O&&a&&b&&c&&d||F))||a&&b&&l&&m&&n&&c&&d&&(k&&g&&h&&i&&j&&(o||f)||o&&p))||F&&(K&&L&&M&&N&&H&&I&&J&&(O&&P&&a&&b&&c&&d&&e||G)||a&&b&&m&&n&&o&&c&&d&&e&&(k&&l&&g&&h&&i&&j||p))||G&&(K&&L&&M&&N&&O&&H&&I&&J||a&&b&&n&&o&&p&&c&&d&&e&&f)||H&&(K&&L&&M&&N&&O&&P&&I&&J||a&&b&&o&&p&&c&&d&&e&&f&&g)||a&&(b&&(k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(k&&l&&m&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e)))||d&&(l&&m&&n&&(k&&g&&h&&i&&j&&(o||f)||o&&p)||e&&(m&&n&&o&&(k&&l&&g&&h&&i&&j||p)||f&&(n&&o&&p||g&&(o&&p||h&&(p||i)))))))||k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||h&&i&&j&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c&&(b||k))))));\\nmat4 mct = mp - mat4(\\nct, ct, ct, ct,\\nct, ct, ct, ct,\\nct, ct, ct, ct,\\nct, ct, ct, ct\\n), mc_t = mat4(\\nc_t, c_t, c_t, c_t,\\nc_t, c_t, c_t, c_t,\\nc_t, c_t, c_t, c_t,\\nc_t, c_t, c_t, c_t\\n) - mp;\\nvec4 bs = max(mc_t[0], zeroes), ds = max(mct[0], zeroes);\\nbs += max(mc_t[1], zeroes); ds += max(mct[1], zeroes);\\nbs += max(mc_t[2], zeroes); ds += max(mct[2], zeroes);\\nbs += max(mc_t[3], zeroes); ds += max(mct[3], zeroes);\\nfloat score = max(dot(bs, ones), dot(ds, ones)) / 16.0f;\\nscore *= float(isCorner);\\nbest = (score > best.x) ? vec2(score, lod) : best;\\nlod += lodStep;\\npot = exp2(lod);\\n}\\ncolor.rb = encodeFloat16(best.x);\\ncolor.a = encodeLod(best.y);\\n}\"","module.exports = \"@include \\\"float16.glsl\\\"\\nuniform sampler2D corners;\\nuniform sampler2D maxScore;\\nuniform float quality;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(corners);\\nfloat score = decodeFloat16(pixel.rb);\\nfloat maxval = decodeFloat16(threadPixel(maxScore).rb);\\nfloat threshold = maxval * clamp(quality, 0.0f, 1.0f);\\ncolor = pixel;\\ncolor.rb = score >= threshold ? color.rb : encodeFloat16(0.0f);\\n}\"","module.exports = \"@include \\\"pyramids.glsl\\\"\\n@include \\\"float16.glsl\\\"\\nuniform sampler2D pyramid;\\nuniform float lod;\\nconst mat3 hkern = mat3(\\n1.0f, 0.0f,-1.0f,\\n2.0f, 0.0f,-2.0f,\\n1.0f, 0.0f,-1.0f\\n), vkern = mat3(\\n1.0f, 2.0f, 1.0f,\\n0.0f, 0.0f, 0.0f,\\n-1.0f,-2.0f,-1.0f\\n);\\n#define PIX(x,y) pyrPixelAtOffset(pyramid, lod, pot, ivec2((x),(y))).g\\nconst vec3 ones = vec3(1.0f);\\nvoid main()\\n{\\nfloat pot = exp2(lod);\\nmat3 win = mat3(\\nPIX(-1,-1), PIX(0,-1), PIX(1,-1),\\nPIX(-1,0), PIX(0,0), PIX(1,0),\\nPIX(-1,1), PIX(0,1), PIX(1,1)\\n);\\nmat3 dx = matrixCompMult(hkern, win);\\nmat3 dy = matrixCompMult(vkern, win);\\nvec2 df = vec2(\\ndot(dx[0] + dx[1] + dx[2], ones),\\ndot(dy[0] + dy[1] + dy[2], ones)\\n);\\ncolor = vec4(encodeFloat16(df.x), encodeFloat16(df.y));\\n}\"","module.exports = \"@include \\\"pyramids.glsl\\\"\\n@include \\\"float16.glsl\\\"\\nuniform sampler2D corners;\\nuniform sampler2D derivatives;\\nuniform float lod;\\n#define H(ox,oy) dpix = pixelAtShortOffset(derivatives, ivec2((ox),(oy))); \\\\\\ndf = vec2(decodeFloat16(dpix.xy), decodeFloat16(dpix.zw)); \\\\\\nh += vec3(df.x * df.x, df.x * df.y, df.y * df.y)\\nvoid main()\\n{\\nvec4 pixel = threadPixel(corners);\\nvec4 dpix = vec4(0.0f);\\nvec2 df = vec2(0.0f);\\nvec3 h = vec3(0.0f);\\ncolor = pixel;\\n#if !defined(WINDOW_SIZE)\\n#error Must define WINDOW_SIZE\\n#elif WINDOW_SIZE == 1\\nH(0,0);\\n#elif WINDOW_SIZE == 3\\nH(-1,-1); H(0,-1); H(1,-1);\\nH(-1,0); H(0,0); H(1,0);\\nH(-1,1); H(0,1); H(1,1);\\n#elif WINDOW_SIZE == 5\\nH(-2,-2); H(-1,-2); H(0,-2); H(1,-2); H(2,-2);\\nH(-2,-1); H(-1,-1); H(0,-1); H(1,-1); H(2,-1);\\nH(-2,0); H(-1,0); H(0,0); H(1,0); H(2,0);\\nH(-2,1); H(-1,1); H(0,1); H(1,1); H(2,1);\\nH(-2,2); H(-1,2); H(0,2); H(1,2); H(2,2);\\n#elif WINDOW_SIZE == 7\\nH(-3,-3); H(-2,-3); H(-1,-3); H(0,-3); H(1,-3); H(2,-3); H(3,-3);\\nH(-3,-2); H(-2,-2); H(-1,-2); H(0,-2); H(1,-2); H(2,-2); H(3,-2);\\nH(-3,-1); H(-2,-1); H(-1,-1); H(0,-1); H(1,-1); H(2,-1); H(3,-1);\\nH(-3,0); H(-2,0); H(-1,0); H(0,0); H(1,0); H(2,0); H(3,0);\\nH(-3,1); H(-2,1); H(-1,1); H(0,1); H(1,1); H(2,1); H(3,1);\\nH(-3,2); H(-2,2); H(-1,2); H(0,2); H(1,2); H(2,2); H(3,2);\\nH(-3,3); H(-2,3); H(-1,3); H(0,3); H(1,3); H(2,3); H(3,3);\\n#else\\n#error Invalid WINDOW_SIZE\\n#endif\\nfloat response = 0.5f * (h.x + h.z - sqrt((h.x - h.z) * (h.x - h.z) + 4.0f * h.y * h.y));\\nvec3 result = vec3(encodeFloat16(response), encodeLod(lod));\\nfloat prevResponse = decodeFloat16(pixel.rb);\\ncolor.rba = response > prevResponse ? result : pixel.rba;\\n}\"","module.exports = \"@include \\\"float16.glsl\\\"\\nuniform sampler2D image;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nfloat score = decodeFloat16(pixel.rb);\\nfloat score8 = 1.0f - exp2(-score);\\ncolor = vec4(score8, pixel.g, 0.0f, pixel.a);\\n}\"","module.exports = \"@include \\\"sobel.glsl\\\"\\n@include \\\"pyramids.glsl\\\"\\n@include \\\"float16.glsl\\\"\\n#if !defined(MAX_LAYERS) || MAX_LAYERS < 7 || MAX_LAYERS > 16 || MAX_LAYERS % 2 == 0\\n#error Invalid MAX_LAYERS\\n#endif\\nuniform sampler2D pyramid;\\nuniform int windowSize;\\nuniform int numberOfLayers;\\nuniform float lodStep;\\nuniform sampler2D sobelDerivatives[@MAX_LAYERS@];\\nvec4 pickSobelDerivatives(int index, ivec2 offset)\\n{\\n#define CASE(k) case k: return textureLod(sobelDerivatives[k], texCoord + vec2(offset) / texSize, 0.0f)\\nswitch(index) {\\n#if MAX_LAYERS > 15\\nCASE(15);\\n#elif MAX_LAYERS > 13\\nCASE(14); CASE(13);\\n#elif MAX_LAYERS > 11\\nCASE(12); CASE(11);\\n#elif MAX_LAYERS > 9\\nCASE(10); CASE(9);\\n#elif MAX_LAYERS > 7\\nCASE(8); CASE(7);\\n#endif\\nCASE(6); CASE(5); CASE(4); CASE(3); CASE(2); CASE(1); CASE(0);\\ndefault: return vec4(0.0f);\\n}\\n}\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nvec4 pixel = threadPixel(pyramid);\\nint r = (windowSize - 1) / 2;\\nfloat windowArea = float(windowSize * windowSize);\\nvec2 tmp = vec2(0.0f);\\nfor(int layer = 0; layer < numberOfLayers; layer++) {\\nvec3 m = vec3(0.0f); vec2 df;\\nfor(int j = 0; j < windowSize; j++) {\\nfor(int i = 0; i < windowSize; i++) {\\ndf = decodeSobel(pickSobelDerivatives(layer, ivec2(i-r, j-r)));\\nm += vec3(df.x * df.x, df.x * df.y, df.y * df.y);\\n}\\n}\\nfloat response = 0.5f * (m.x + m.z - sqrt((m.x - m.z) * (m.x - m.z) + 4.0f * m.y * m.y));\\nfloat normalizer = 9.0f / windowArea;\\nfloat score = response * normalizer;\\nfloat lod = lodStep * float(layer);\\ntmp = mix(tmp, vec2(score, lod), bvec2(score > tmp.x));\\n}\\nvec2 encodedScore = encodeFloat16(tmp.x);\\nfloat encodedScale = encodeLod(tmp.y);\\ncolor = vec4(0.0f, pixel.g, 0.0f, encodedScale);\\ncolor.rb = encodedScore;\\n}\"","module.exports = \"@include \\\"sobel.glsl\\\"\\n@include \\\"pyramids.glsl\\\"\\nuniform sampler2D pyramid;\\nuniform float lod;\\nconst mat3 horizontalKernel = mat3(\\n-1.0f, 0.0f, 1.0f,\\n-2.0f, 0.0f, 2.0f,\\n-1.0f, 0.0f, 1.0f\\n);\\nconst mat3 verticalKernel = mat3(\\n1.0f, 2.0f, 1.0f,\\n0.0f, 0.0f, 0.0f,\\n-1.0f,-2.0f,-1.0f\\n);\\nconst vec3 ones = vec3(1.0f, 1.0f, 1.0f);\\nvoid main()\\n{\\nfloat pot = exp2(lod);\\nmat3 neighbors = mat3(\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-1, -1)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(0, -1)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(1, -1)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-1, 0)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(0, 0)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(1, 0)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-1, 1)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(0, 1)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(1, 1)).g\\n);\\nmat3 sobelX = matrixCompMult(horizontalKernel, neighbors);\\nmat3 sobelY = matrixCompMult(verticalKernel, neighbors);\\nvec2 df = vec2(\\ndot(sobelX[0] + sobelX[1] + sobelX[2], ones),\\ndot(sobelY[0] + sobelY[1] + sobelY[2], ones)\\n);\\ncolor = encodeSobel(df);\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform sampler2D encodedKeypoints[2];\\nuniform int encoderLength[2];\\nuniform int encoderCapacity[2];\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int outEncoderLength;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\\nKeypointAddress outAddr = findKeypointAddress(thread, outEncoderLength, descriptorSize, extraSize);\\nint outIndex = findKeypointIndex(outAddr, descriptorSize, extraSize);\\nint encoderIndex = int(outIndex >= encoderCapacity[0]);\\nint inIndex = (outIndex - encoderCapacity[0] * encoderIndex);\\nKeypointAddress inAddr = KeypointAddress(\\ninIndex * pixelsPerKeypoint,\\noutAddr.offset\\n);\\nvec4 data[2] = vec4[2](\\nreadKeypointData(encodedKeypoints[0], encoderLength[0], inAddr),\\nreadKeypointData(encodedKeypoints[1], encoderLength[1], inAddr)\\n);\\nbool valid = (inIndex < max(encoderCapacity[0], encoderCapacity[1]));\\ncolor = valid ? data[encoderIndex] : encodeNullKeypoint();\\n}\"","module.exports = \"@include \\\"pyramids.glsl\\\"\\n@include \\\"float16.glsl\\\"\\nuniform sampler2D image;\\nuniform float lodStep;\\n#if !defined(MULTISCALE)\\n#error Must define MULTISCALE\\n#elif MULTISCALE != 0\\n#define LOD_STEP (lodStep)\\n#define USE_MIDDLE_RING\\n#else\\n#define LOD_STEP (0.0f)\\n#endif\\n#define PIX(x,y) pixelAtShortOffset(image, ivec2((x),(y)))\\n#define L2(v,i) bvec2(isSameEncodedLod(v[i].a, alphaMinus), isSameEncodedLod(v[i].a, alphaPlus))\\n#define L3(v,i) bvec3(isSameEncodedLod(v[i].a, alpha), isSameEncodedLod(v[i].a, alphaMinus), isSameEncodedLod(v[i].a, alphaPlus))\\n#define S3(v,i) decodeFloat16(v[i].rb) * float(any(L3(v,i)))\\n#define S2(v,i) decodeFloat16(v[i].rb) * float(any(L2(v,i)))\\n#define P(i) S3(p,i)\\n#define Q(i) S2(q,i)\\n#define R(i) S2(r,i)\\nconst vec4 O = vec4(0.0f);\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nfloat lod = decodeLod(pixel.a);\\nfloat score = decodeFloat16(pixel.rb);\\ncolor = pixel;\\nif(score == 0.0f)\\nreturn;\\nvec4 p[8] = vec4[8](\\nPIX(0,1), PIX(1,1), PIX(1,0), PIX(1,-1),\\nPIX(0,-1), PIX(-1,-1), PIX(-1,0), PIX(-1,1)\\n);\\n#ifdef USE_MIDDLE_RING\\nvec4 q[16] = vec4[16](\\nPIX(0,2), PIX(1,2), PIX(2,2), PIX(2,1),\\nPIX(2,0), PIX(2,-1), PIX(2,-2), PIX(1,-2),\\nPIX(0,-2), PIX(-1,-2), PIX(-2,-2), PIX(-2,-1),\\nPIX(-2,0), PIX(-2,1), PIX(-2,2), PIX(-1,2)\\n);\\n#else\\nvec4 q[16] = vec4[16](O,O,O,O,O,O,O,O,O,O,O,O,O,O,O,O);\\n#endif\\n#ifdef USE_OUTER_RING\\nvec4 r[16] = vec4[16](\\nPIX(0,3), PIX(1,3), PIX(3,1), PIX(3,0),\\nPIX(3,-1), PIX(1,-3), PIX(0,-3), PIX(-1,-3),\\nPIX(-3,-1), PIX(-3,0), PIX(-3,1), PIX(-1,3),\\nPIX(0,4), PIX(4,0), PIX(0,-4), PIX(-4,0)\\n);\\n#else\\nvec4 r[16] = vec4[16](O,O,O,O,O,O,O,O,O,O,O,O,O,O,O,O);\\n#endif\\nfloat alphaPlus = encodeLod(lod + LOD_STEP);\\nfloat alphaMinus = encodeLod(lod - LOD_STEP);\\nfloat alpha = encodeLod(lod);\\nmat3 innerScore = mat3(\\nP(0), P(1), P(2), P(3),\\nP(4), P(5), P(6), P(7),\\n0.0f);\\nmat4 middleScore = mat4(\\nQ(0), Q(1), Q(2), Q(3),\\nQ(4), Q(5), Q(6), Q(7),\\nQ(8), Q(9), Q(10), Q(11),\\nQ(12), Q(13), Q(14), Q(15)\\n);\\nmat4 outerScore = mat4(\\nR(0), R(1), R(2), R(3),\\nR(4), R(5), R(6), R(7),\\nR(8), R(9), R(10), R(11),\\nR(12), R(13), R(14), R(15)\\n);\\nvec3 maxInnerScore3 = max(innerScore[0], max(innerScore[1], innerScore[2]));\\nvec4 maxMiddleScore4 = max(max(middleScore[0], middleScore[1]), max(middleScore[2], middleScore[3]));\\nvec4 maxOuterScore4 = max(max(outerScore[0], outerScore[1]), max(outerScore[2], outerScore[3]));\\nfloat maxInnerScore = max(maxInnerScore3.x, max(maxInnerScore3.y, maxInnerScore3.z));\\nfloat maxMiddleScore = max(max(maxMiddleScore4.x, maxMiddleScore4.y), max(maxMiddleScore4.z, maxMiddleScore4.w));\\nfloat maxOuterScore = max(max(maxOuterScore4.x, maxOuterScore4.y), max(maxOuterScore4.z, maxOuterScore4.w));\\nfloat maxScore = max(maxInnerScore, max(maxMiddleScore, maxOuterScore));\\nfloat finalScore = step(maxScore, score) * score;\\ncolor.rb = encodeFloat16(finalScore);\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform sampler2D encodedCorners;\\nuniform int encoderLength;\\nuniform sampler2D pyramid;\\nuniform int extraSize;\\nconst int descriptorSize = 32;\\nconst ivec4 pat31[256] = ivec4[256](\\nivec4(8,-3,9,5),\\nivec4(4,2,7,-12),\\nivec4(-11,9,-8,2),\\nivec4(7,-12,12,-13),\\nivec4(2,-13,2,12),\\nivec4(1,-7,1,6),\\nivec4(-2,-10,-2,-4),\\nivec4(-13,-13,-11,-8),\\nivec4(-13,-3,-12,-9),\\nivec4(10,4,11,9),\\nivec4(-13,-8,-8,-9),\\nivec4(-11,7,-9,12),\\nivec4(7,7,12,6),\\nivec4(-4,-5,-3,0),\\nivec4(-13,2,-12,-3),\\nivec4(-9,0,-7,5),\\nivec4(12,-6,12,-1),\\nivec4(-3,6,-2,12),\\nivec4(-6,-13,-4,-8),\\nivec4(11,-13,12,-8),\\nivec4(4,7,5,1),\\nivec4(5,-3,10,-3),\\nivec4(3,-7,6,12),\\nivec4(-8,-7,-6,-2),\\nivec4(-2,11,-1,-10),\\nivec4(-13,12,-8,10),\\nivec4(-7,3,-5,-3),\\nivec4(-4,2,-3,7),\\nivec4(-10,-12,-6,11),\\nivec4(5,-12,6,-7),\\nivec4(5,-6,7,-1),\\nivec4(1,0,4,-5),\\nivec4(9,11,11,-13),\\nivec4(4,7,4,12),\\nivec4(2,-1,4,4),\\nivec4(-4,-12,-2,7),\\nivec4(-8,-5,-7,-10),\\nivec4(4,11,9,12),\\nivec4(0,-8,1,-13),\\nivec4(-13,-2,-8,2),\\nivec4(-3,-2,-2,3),\\nivec4(-6,9,-4,-9),\\nivec4(8,12,10,7),\\nivec4(0,9,1,3),\\nivec4(7,-5,11,-10),\\nivec4(-13,-6,-11,0),\\nivec4(10,7,12,1),\\nivec4(-6,-3,-6,12),\\nivec4(10,-9,12,-4),\\nivec4(-13,8,-8,-12),\\nivec4(-13,0,-8,-4),\\nivec4(3,3,7,8),\\nivec4(5,7,10,-7),\\nivec4(-1,7,1,-12),\\nivec4(3,-10,5,6),\\nivec4(2,-4,3,-10),\\nivec4(-13,0,-13,5),\\nivec4(-13,-7,-12,12),\\nivec4(-13,3,-11,8),\\nivec4(-7,12,-4,7),\\nivec4(6,-10,12,8),\\nivec4(-9,-1,-7,-6),\\nivec4(-2,-5,0,12),\\nivec4(-12,5,-7,5),\\nivec4(3,-10,8,-13),\\nivec4(-7,-7,-4,5),\\nivec4(-3,-2,-1,-7),\\nivec4(2,9,5,-11),\\nivec4(-11,-13,-5,-13),\\nivec4(-1,6,0,-1),\\nivec4(5,-3,5,2),\\nivec4(-4,-13,-4,12),\\nivec4(-9,-6,-9,6),\\nivec4(-12,-10,-8,-4),\\nivec4(10,2,12,-3),\\nivec4(7,12,12,12),\\nivec4(-7,-13,-6,5),\\nivec4(-4,9,-3,4),\\nivec4(7,-1,12,2),\\nivec4(-7,6,-5,1),\\nivec4(-13,11,-12,5),\\nivec4(-3,7,-2,-6),\\nivec4(7,-8,12,-7),\\nivec4(-13,-7,-11,-12),\\nivec4(1,-3,12,12),\\nivec4(2,-6,3,0),\\nivec4(-4,3,-2,-13),\\nivec4(-1,-13,1,9),\\nivec4(7,1,8,-6),\\nivec4(1,-1,3,12),\\nivec4(9,1,12,6),\\nivec4(-1,-9,-1,3),\\nivec4(-13,-13,-10,5),\\nivec4(7,7,10,12),\\nivec4(12,-5,12,9),\\nivec4(6,3,7,11),\\nivec4(5,-13,6,10),\\nivec4(2,-12,2,3),\\nivec4(3,8,4,-6),\\nivec4(2,6,12,-13),\\nivec4(9,-12,10,3),\\nivec4(-8,4,-7,9),\\nivec4(-11,12,-4,-6),\\nivec4(1,12,2,-8),\\nivec4(6,-9,7,-4),\\nivec4(2,3,3,-2),\\nivec4(6,3,11,0),\\nivec4(3,-3,8,-8),\\nivec4(7,8,9,3),\\nivec4(-11,-5,-6,-4),\\nivec4(-10,11,-5,10),\\nivec4(-5,-8,-3,12),\\nivec4(-10,5,-9,0),\\nivec4(8,-1,12,-6),\\nivec4(4,-6,6,-11),\\nivec4(-10,12,-8,7),\\nivec4(4,-2,6,7),\\nivec4(-2,0,-2,12),\\nivec4(-5,-8,-5,2),\\nivec4(7,-6,10,12),\\nivec4(-9,-13,-8,-8),\\nivec4(-5,-13,-5,-2),\\nivec4(8,-8,9,-13),\\nivec4(-9,-11,-9,0),\\nivec4(1,-8,1,-2),\\nivec4(7,-4,9,1),\\nivec4(-2,1,-1,-4),\\nivec4(11,-6,12,-11),\\nivec4(-12,-9,-6,4),\\nivec4(3,7,7,12),\\nivec4(5,5,10,8),\\nivec4(0,-4,2,8),\\nivec4(-9,12,-5,-13),\\nivec4(0,7,2,12),\\nivec4(-1,2,1,7),\\nivec4(5,11,7,-9),\\nivec4(3,5,6,-8),\\nivec4(-13,-4,-8,9),\\nivec4(-5,9,-3,-3),\\nivec4(-4,-7,-3,-12),\\nivec4(6,5,8,0),\\nivec4(-7,6,-6,12),\\nivec4(-13,6,-5,-2),\\nivec4(1,-10,3,10),\\nivec4(4,1,8,-4),\\nivec4(-2,-2,2,-13),\\nivec4(2,-12,12,12),\\nivec4(-2,-13,0,-6),\\nivec4(4,1,9,3),\\nivec4(-6,-10,-3,-5),\\nivec4(-3,-13,-1,1),\\nivec4(7,5,12,-11),\\nivec4(4,-2,5,-7),\\nivec4(-13,9,-9,-5),\\nivec4(7,1,8,6),\\nivec4(7,-8,7,6),\\nivec4(-7,-4,-7,1),\\nivec4(-8,11,-7,-8),\\nivec4(-13,6,-12,-8),\\nivec4(2,4,3,9),\\nivec4(10,-5,12,3),\\nivec4(-6,-5,-6,7),\\nivec4(8,-3,9,-8),\\nivec4(2,-12,2,8),\\nivec4(-11,-2,-10,3),\\nivec4(-12,-13,-7,-9),\\nivec4(-11,0,-10,-5),\\nivec4(5,-3,11,8),\\nivec4(-2,-13,-1,12),\\nivec4(-1,-8,0,9),\\nivec4(-13,-11,-12,-5),\\nivec4(-10,-2,-10,11),\\nivec4(-3,9,-2,-13),\\nivec4(2,-3,3,2),\\nivec4(-9,-13,-4,0),\\nivec4(-4,6,-3,-10),\\nivec4(-4,12,-2,-7),\\nivec4(-6,-11,-4,9),\\nivec4(6,-3,6,11),\\nivec4(-13,11,-5,5),\\nivec4(11,11,12,6),\\nivec4(7,-5,12,-2),\\nivec4(-1,12,0,7),\\nivec4(-4,-8,-3,-2),\\nivec4(-7,1,-6,7),\\nivec4(-13,-12,-8,-13),\\nivec4(-7,-2,-6,-8),\\nivec4(-8,5,-6,-9),\\nivec4(-5,-1,-4,5),\\nivec4(-13,7,-8,10),\\nivec4(1,5,5,-13),\\nivec4(1,0,10,-13),\\nivec4(9,12,10,-1),\\nivec4(5,-8,10,-9),\\nivec4(-1,11,1,-13),\\nivec4(-9,-3,-6,2),\\nivec4(-1,-10,1,12),\\nivec4(-13,1,-8,-10),\\nivec4(8,-11,10,-6),\\nivec4(2,-13,3,-6),\\nivec4(7,-13,12,-9),\\nivec4(-10,-10,-5,-7),\\nivec4(-10,-8,-8,-13),\\nivec4(4,-6,8,5),\\nivec4(3,12,8,-13),\\nivec4(-4,2,-3,-3),\\nivec4(5,-13,10,-12),\\nivec4(4,-13,5,-1),\\nivec4(-9,9,-4,3),\\nivec4(0,3,3,-9),\\nivec4(-12,1,-6,1),\\nivec4(3,2,4,-8),\\nivec4(-10,-10,-10,9),\\nivec4(8,-13,12,12),\\nivec4(-8,-12,-6,-5),\\nivec4(2,2,3,7),\\nivec4(10,6,11,-8),\\nivec4(6,8,8,-12),\\nivec4(-7,10,-6,5),\\nivec4(-3,-9,-3,9),\\nivec4(-1,-13,-1,5),\\nivec4(-3,-7,-3,4),\\nivec4(-8,-2,-8,3),\\nivec4(4,2,12,12),\\nivec4(2,-5,3,11),\\nivec4(6,-9,11,-13),\\nivec4(3,-1,7,12),\\nivec4(11,-1,12,4),\\nivec4(-3,0,-3,6),\\nivec4(4,-11,4,12),\\nivec4(2,-4,2,1),\\nivec4(-10,-6,-8,1),\\nivec4(-13,7,-11,1),\\nivec4(-13,12,-11,-13),\\nivec4(6,0,11,-13),\\nivec4(0,-1,1,4),\\nivec4(-13,3,-9,-2),\\nivec4(-9,8,-6,-3),\\nivec4(-13,-6,-8,-2),\\nivec4(5,-9,8,10),\\nivec4(2,7,3,-9),\\nivec4(-1,-6,-1,-1),\\nivec4(9,5,11,-2),\\nivec4(11,-3,12,-8),\\nivec4(3,0,3,5),\\nivec4(-1,4,0,10),\\nivec4(3,-6,4,5),\\nivec4(-13,0,-10,5),\\nivec4(5,8,12,11),\\nivec4(8,9,9,-6),\\nivec4(7,-4,8,-12),\\nivec4(-10,4,-10,9),\\nivec4(7,3,12,4),\\nivec4(9,-7,10,-2),\\nivec4(7,0,12,-2),\\nivec4(-1,-6,0,-11)\\n);\\nvoid getPair(int index, mat2 rot, out vec2 p, out vec2 q)\\n{\\nivec4 data = pat31[index];\\nvec2 op = vec2(data.xy);\\nvec2 oq = vec2(data.zw);\\np = rot * op;\\nq = rot * oq;\\n}\\nvoid main()\\n{\\nvec4 pixel = threadPixel(encodedCorners);\\nivec2 thread = threadLocation();\\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\\nint descriptorCell = address.offset - sizeofEncodedKeypoint(0, extraSize) / 4;\\ncolor = pixel;\\nif(descriptorCell < 0)\\nreturn;\\nKeypoint keypoint = decodeKeypoint(encodedCorners, encoderLength, address);\\nif(isBadKeypoint(keypoint))\\nreturn;\\nfloat degreesOrientation = round(360.0f + degrees(keypoint.orientation));\\nfloat orientation = radians(degreesOrientation - mod(degreesOrientation, 12.0f));\\nfloat kcos = cos(orientation);\\nfloat ksin = sin(orientation);\\nmat2 rot = mat2(kcos, ksin, -ksin, kcos);\\nfloat pot = exp2(keypoint.lod);\\nvec2 imageSize = vec2(textureSize(pyramid, 0));\\nint patternStart = 32 * descriptorCell;\\nuint test[4] = uint[4](0u, 0u, 0u, 0u);\\nfor(int t = 0; t < 4; t++) {\\nuint bits = 0u;\\nvec2 p, q;\\nvec4 a, b;\\nint i = t * 8;\\n@unroll\\nfor(int j = 0; j < 8; j++) {\\ngetPair(patternStart + i + j, rot, p, q);\\na = pyrPixelAtEx(pyramid, round(keypoint.position + pot * p), keypoint.lod, imageSize);\\nb = pyrPixelAtEx(pyramid, round(keypoint.position + pot * q), keypoint.lod, imageSize);\\nbits |= uint(a.g < b.g) << j;\\n}\\ntest[t] = bits;\\n}\\ncolor = vec4(test[0], test[1], test[2], test[3]) / 255.0f;\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform sampler2D pyramid;\\nuniform sampler2D encodedKeypoints;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int encoderLength;\\n#define P(x,y) ivec2((x),(y))\\nconst int diskPointCount[16] = int[16](0, 4, 12, 28, 48, 80, 112, 148, 196, 252, 316, 376, 440, 528, 612, 708);\\nconst ivec2 diskPoint[708] = ivec2[708](\\nP(0,-1),P(-1,0),P(1,0),P(0,1),\\nP(-1,-1),P(1,-1),P(-1,1),P(1,1),P(0,-2),P(-2,0),P(2,0),P(0,2),\\nP(-1,-2),P(1,-2),P(-2,-1),P(2,-1),P(-2,1),P(2,1),P(-1,2),P(1,2),P(-2,-2),P(2,-2),P(-2,2),P(2,2),P(0,-3),P(-3,0),P(3,0),P(0,3),\\nP(-1,-3),P(1,-3),P(-3,-1),P(3,-1),P(-3,1),P(3,1),P(-1,3),P(1,3),P(-2,-3),P(2,-3),P(-3,-2),P(3,-2),P(-3,2),P(3,2),P(-2,3),P(2,3),P(0,-4),P(-4,0),P(4,0),P(0,4),\\nP(-1,-4),P(1,-4),P(-4,-1),P(4,-1),P(-4,1),P(4,1),P(-1,4),P(1,4),P(-3,-3),P(3,-3),P(-3,3),P(3,3),P(-2,-4),P(2,-4),P(-4,-2),P(4,-2),P(-4,2),P(4,2),P(-2,4),P(2,4),P(0,-5),P(-3,-4),P(3,-4),P(-4,-3),P(4,-3),P(-5,0),P(5,0),P(-4,3),P(4,3),P(-3,4),P(3,4),P(0,5),\\nP(-1,-5),P(1,-5),P(-5,-1),P(5,-1),P(-5,1),P(5,1),P(-1,5),P(1,5),P(-2,-5),P(2,-5),P(-5,-2),P(5,-2),P(-5,2),P(5,2),P(-2,5),P(2,5),P(-4,-4),P(4,-4),P(-4,4),P(4,4),P(-3,-5),P(3,-5),P(-5,-3),P(5,-3),P(-5,3),P(5,3),P(-3,5),P(3,5),P(0,-6),P(-6,0),P(6,0),P(0,6),\\nP(-1,-6),P(1,-6),P(-6,-1),P(6,-1),P(-6,1),P(6,1),P(-1,6),P(1,6),P(-2,-6),P(2,-6),P(-6,-2),P(6,-2),P(-6,2),P(6,2),P(-2,6),P(2,6),P(-4,-5),P(4,-5),P(-5,-4),P(5,-4),P(-5,4),P(5,4),P(-4,5),P(4,5),P(-3,-6),P(3,-6),P(-6,-3),P(6,-3),P(-6,3),P(6,3),P(-3,6),P(3,6),P(0,-7),P(-7,0),P(7,0),P(0,7),\\nP(-1,-7),P(1,-7),P(-5,-5),P(5,-5),P(-7,-1),P(7,-1),P(-7,1),P(7,1),P(-5,5),P(5,5),P(-1,7),P(1,7),P(-4,-6),P(4,-6),P(-6,-4),P(6,-4),P(-6,4),P(6,4),P(-4,6),P(4,6),P(-2,-7),P(2,-7),P(-7,-2),P(7,-2),P(-7,2),P(7,2),P(-2,7),P(2,7),P(-3,-7),P(3,-7),P(-7,-3),P(7,-3),P(-7,3),P(7,3),P(-3,7),P(3,7),P(-5,-6),P(5,-6),P(-6,-5),P(6,-5),P(-6,5),P(6,5),P(-5,6),P(5,6),P(0,-8),P(-8,0),P(8,0),P(0,8),\\nP(-1,-8),P(1,-8),P(-4,-7),P(4,-7),P(-7,-4),P(7,-4),P(-8,-1),P(8,-1),P(-8,1),P(8,1),P(-7,4),P(7,4),P(-4,7),P(4,7),P(-1,8),P(1,8),P(-2,-8),P(2,-8),P(-8,-2),P(8,-2),P(-8,2),P(8,2),P(-2,8),P(2,8),P(-6,-6),P(6,-6),P(-6,6),P(6,6),P(-3,-8),P(3,-8),P(-8,-3),P(8,-3),P(-8,3),P(8,3),P(-3,8),P(3,8),P(-5,-7),P(5,-7),P(-7,-5),P(7,-5),P(-7,5),P(7,5),P(-5,7),P(5,7),P(-4,-8),P(4,-8),P(-8,-4),P(8,-4),P(-8,4),P(8,4),P(-4,8),P(4,8),P(0,-9),P(-9,0),P(9,0),P(0,9),\\nP(-1,-9),P(1,-9),P(-9,-1),P(9,-1),P(-9,1),P(9,1),P(-1,9),P(1,9),P(-2,-9),P(2,-9),P(-6,-7),P(6,-7),P(-7,-6),P(7,-6),P(-9,-2),P(9,-2),P(-9,2),P(9,2),P(-7,6),P(7,6),P(-6,7),P(6,7),P(-2,9),P(2,9),P(-5,-8),P(5,-8),P(-8,-5),P(8,-5),P(-8,5),P(8,5),P(-5,8),P(5,8),P(-3,-9),P(3,-9),P(-9,-3),P(9,-3),P(-9,3),P(9,3),P(-3,9),P(3,9),P(-4,-9),P(4,-9),P(-9,-4),P(9,-4),P(-9,4),P(9,4),P(-4,9),P(4,9),P(-7,-7),P(7,-7),P(-7,7),P(7,7),P(0,-10),P(-6,-8),P(6,-8),P(-8,-6),P(8,-6),P(-10,0),P(10,0),P(-8,6),P(8,6),P(-6,8),P(6,8),P(0,10),\\nP(-1,-10),P(1,-10),P(-10,-1),P(10,-1),P(-10,1),P(10,1),P(-1,10),P(1,10),P(-2,-10),P(2,-10),P(-10,-2),P(10,-2),P(-10,2),P(10,2),P(-2,10),P(2,10),P(-5,-9),P(5,-9),P(-9,-5),P(9,-5),P(-9,5),P(9,5),P(-5,9),P(5,9),P(-3,-10),P(3,-10),P(-10,-3),P(10,-3),P(-10,3),P(10,3),P(-3,10),P(3,10),P(-7,-8),P(7,-8),P(-8,-7),P(8,-7),P(-8,7),P(8,7),P(-7,8),P(7,8),P(-4,-10),P(4,-10),P(-10,-4),P(10,-4),P(-10,4),P(10,4),P(-4,10),P(4,10),P(-6,-9),P(6,-9),P(-9,-6),P(9,-6),P(-9,6),P(9,6),P(-6,9),P(6,9),P(0,-11),P(-11,0),P(11,0),P(0,11),\\nP(-1,-11),P(1,-11),P(-11,-1),P(11,-1),P(-11,1),P(11,1),P(-1,11),P(1,11),P(-2,-11),P(2,-11),P(-5,-10),P(5,-10),P(-10,-5),P(10,-5),P(-11,-2),P(11,-2),P(-11,2),P(11,2),P(-10,5),P(10,5),P(-5,10),P(5,10),P(-2,11),P(2,11),P(-8,-8),P(8,-8),P(-8,8),P(8,8),P(-3,-11),P(3,-11),P(-7,-9),P(7,-9),P(-9,-7),P(9,-7),P(-11,-3),P(11,-3),P(-11,3),P(11,3),P(-9,7),P(9,7),P(-7,9),P(7,9),P(-3,11),P(3,11),P(-6,-10),P(6,-10),P(-10,-6),P(10,-6),P(-10,6),P(10,6),P(-6,10),P(6,10),P(-4,-11),P(4,-11),P(-11,-4),P(11,-4),P(-11,4),P(11,4),P(-4,11),P(4,11),P(0,-12),P(-12,0),P(12,0),P(0,12),\\nP(-1,-12),P(1,-12),P(-8,-9),P(8,-9),P(-9,-8),P(9,-8),P(-12,-1),P(12,-1),P(-12,1),P(12,1),P(-9,8),P(9,8),P(-8,9),P(8,9),P(-1,12),P(1,12),P(-5,-11),P(5,-11),P(-11,-5),P(11,-5),P(-11,5),P(11,5),P(-5,11),P(5,11),P(-2,-12),P(2,-12),P(-12,-2),P(12,-2),P(-12,2),P(12,2),P(-2,12),P(2,12),P(-7,-10),P(7,-10),P(-10,-7),P(10,-7),P(-10,7),P(10,7),P(-7,10),P(7,10),P(-3,-12),P(3,-12),P(-12,-3),P(12,-3),P(-12,3),P(12,3),P(-3,12),P(3,12),P(-6,-11),P(6,-11),P(-11,-6),P(11,-6),P(-11,6),P(11,6),P(-6,11),P(6,11),P(-4,-12),P(4,-12),P(-12,-4),P(12,-4),P(-12,4),P(12,4),P(-4,12),P(4,12),P(-9,-9),P(9,-9),P(-9,9),P(9,9),P(-8,-10),P(8,-10),P(-10,-8),P(10,-8),P(-10,8),P(10,8),P(-8,10),P(8,10),P(0,-13),P(-5,-12),P(5,-12),P(-12,-5),P(12,-5),P(-13,0),P(13,0),P(-12,5),P(12,5),P(-5,12),P(5,12),P(0,13),\\nP(-1,-13),P(1,-13),P(-7,-11),P(7,-11),P(-11,-7),P(11,-7),P(-13,-1),P(13,-1),P(-13,1),P(13,1),P(-11,7),P(11,7),P(-7,11),P(7,11),P(-1,13),P(1,13),P(-2,-13),P(2,-13),P(-13,-2),P(13,-2),P(-13,2),P(13,2),P(-2,13),P(2,13),P(-3,-13),P(3,-13),P(-13,-3),P(13,-3),P(-13,3),P(13,3),P(-3,13),P(3,13),P(-6,-12),P(6,-12),P(-12,-6),P(12,-6),P(-12,6),P(12,6),P(-6,12),P(6,12),P(-9,-10),P(9,-10),P(-10,-9),P(10,-9),P(-10,9),P(10,9),P(-9,10),P(9,10),P(-4,-13),P(4,-13),P(-8,-11),P(8,-11),P(-11,-8),P(11,-8),P(-13,-4),P(13,-4),P(-13,4),P(13,4),P(-11,8),P(11,8),P(-8,11),P(8,11),P(-4,13),P(4,13),P(-7,-12),P(7,-12),P(-12,-7),P(12,-7),P(-12,7),P(12,7),P(-7,12),P(7,12),P(-5,-13),P(5,-13),P(-13,-5),P(13,-5),P(-13,5),P(13,5),P(-5,13),P(5,13),P(0,-14),P(-14,0),P(14,0),P(0,14),\\nP(-1,-14),P(1,-14),P(-14,-1),P(14,-1),P(-14,1),P(14,1),P(-1,14),P(1,14),P(-2,-14),P(2,-14),P(-10,-10),P(10,-10),P(-14,-2),P(14,-2),P(-14,2),P(14,2),P(-10,10),P(10,10),P(-2,14),P(2,14),P(-9,-11),P(9,-11),P(-11,-9),P(11,-9),P(-11,9),P(11,9),P(-9,11),P(9,11),P(-3,-14),P(3,-14),P(-6,-13),P(6,-13),P(-13,-6),P(13,-6),P(-14,-3),P(14,-3),P(-14,3),P(14,3),P(-13,6),P(13,6),P(-6,13),P(6,13),P(-3,14),P(3,14),P(-8,-12),P(8,-12),P(-12,-8),P(12,-8),P(-12,8),P(12,8),P(-8,12),P(8,12),P(-4,-14),P(4,-14),P(-14,-4),P(14,-4),P(-14,4),P(14,4),P(-4,14),P(4,14),P(-7,-13),P(7,-13),P(-13,-7),P(13,-7),P(-13,7),P(13,7),P(-7,13),P(7,13),P(-5,-14),P(5,-14),P(-10,-11),P(10,-11),P(-11,-10),P(11,-10),P(-14,-5),P(14,-5),P(-14,5),P(14,5),P(-11,10),P(11,10),P(-10,11),P(10,11),P(-5,14),P(5,14),P(0,-15),P(-9,-12),P(9,-12),P(-12,-9),P(12,-9),P(-15,0),P(15,0),P(-12,9),P(12,9),P(-9,12),P(9,12),P(0,15)\\n);\\nconst int DEFAULT_PATCH_RADIUS = 15;\\nconst int MIN_PATCH_RADIUS = 2;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(encodedKeypoints);\\nivec2 thread = threadLocation();\\nint keypointIndex = thread.x + thread.y * outputSize().x;\\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\\nKeypointAddress address = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);\\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\\nvec2 m = vec2(0.0f);\\nfloat pot = exp2(keypoint.lod);\\nivec2 pyrBaseSize = textureSize(pyramid, 0);\\nint scaledRadius = int(ceil(float(DEFAULT_PATCH_RADIUS) / pot));\\nint radius = max(scaledRadius, MIN_PATCH_RADIUS);\\nint count = diskPointCount[radius];\\nfor(int j = 0; j < count; j++) {\\nvec2 offset = vec2(diskPoint[j]);\\nvec2 position = keypoint.position + round(pot * offset);\\nvec4 patchPixel = pyrPixelAtEx(pyramid, position, keypoint.lod, pyrBaseSize);\\nm += offset * patchPixel.g;\\n}\\nfloat angle = fastAtan2(m.y, m.x);\\nfloat encodedOrientation = encodeOrientation(angle);\\nfloat encodedFlags = encodeKeypointFlags(keypoint.flags | KPF_ORIENTED);\\ncolor = vec4(0.0f, encodedOrientation, 0.0f, encodedFlags);\\n}\"","module.exports = \"@include \\\"float16.glsl\\\"\\nuniform sampler2D corners;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(corners);\\nfloat score = decodeFloat16(pixel.rb);\\n#if !defined(METHOD)\\n#error Must define METHOD\\n#elif METHOD == 0\\nfloat score8 = clamp(score, 0.0f, 1.0f);\\n#elif METHOD == 1\\nfloat score8 = 1.0f - exp2(-score);\\n#else\\n#error Invalid METHOD\\n#endif\\ncolor = vec4(score8, pixel.g, 0.0f, pixel.a);\\n}\"","module.exports = \"@include \\\"float16.glsl\\\"\\nuniform sampler2D corners;\\nuniform int iterationNumber;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nivec2 bounds = outputSize();\\nint jump = (1 << iterationNumber);\\nint clusterLength = jump << 1;\\nint clusterMask = clusterLength - 1;\\nivec2 clusterPos = ivec2(thread >> (1 + iterationNumber)) << (1 + iterationNumber);\\nivec2 next1 = clusterPos + ((thread - clusterPos + ivec2(jump, 0)) & clusterMask);\\nivec2 next2 = clusterPos + ((thread - clusterPos + ivec2(0, jump)) & clusterMask);\\nivec2 next3 = clusterPos + ((thread - clusterPos + ivec2(jump, jump)) & clusterMask);\\nvec4 p0 = texelFetch(corners, thread, 0);\\nvec4 p1 = texelFetch(corners, next1 % bounds, 0);\\nvec4 p2 = texelFetch(corners, next2 % bounds, 0);\\nvec4 p3 = texelFetch(corners, next3 % bounds, 0);\\nfloat s0 = decodeFloat16(p0.rb);\\nfloat s1 = decodeFloat16(p1.rb);\\nfloat s2 = decodeFloat16(p2.rb);\\nfloat s3 = decodeFloat16(p3.rb);\\nbool b0 = s0 >= s1 && s0 >= s2 && s0 >= s3;\\nbool b1 = s1 >= s0 && s1 >= s2 && s1 >= s3;\\nbool b2 = s2 >= s0 && s2 >= s1 && s2 >= s3;\\ncolor = vec4(0.0f);\\ncolor.rb = b0 ? p0.rb : (\\nb1 ? p1.rb : (\\nb2 ? p2.rb : p3.rb\\n)\\n);\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform sampler2D permutation;\\nuniform int maxKeypoints;\\nuniform sampler2D encodedKeypoints;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nstruct PermutationElement\\n{\\nint keypointIndex;\\nfloat score;\\nbool valid;\\n};\\nPermutationElement decodePermutationElement(vec4 pixel)\\n{\\nPermutationElement element;\\nelement.keypointIndex = int(pixel.r * 255.0f) | (int(pixel.g * 255.0f) << 8);\\nelement.valid = (pixel.a > 0.0f);\\nelement.score = element.valid ? pixel.b : -1.0f;\\nreturn element;\\n}\\nPermutationElement readPermutationElement(sampler2D permutation, int elementIndex, int stride, int height)\\n{\\nconst vec4 INVALID_PIXEL = vec4(0.0f);\\nivec2 pos = ivec2(elementIndex % stride, elementIndex / stride);\\nvec4 pixel = pos.y < height ? pixelAt(permutation, pos) : INVALID_PIXEL;\\nreturn decodePermutationElement(pixel);\\n}\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nint newEncoderLength = outputSize().x;\\nKeypointAddress myAddress = findKeypointAddress(thread, newEncoderLength, descriptorSize, extraSize);\\nint myKeypointIndex = findKeypointIndex(myAddress, descriptorSize, extraSize);\\nivec2 psize = textureSize(permutation, 0);\\nPermutationElement element = readPermutationElement(permutation, myKeypointIndex, psize.x, psize.y);\\nint oldEncoderLength = textureSize(encodedKeypoints, 0).x;\\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\\nKeypointAddress address = KeypointAddress(element.keypointIndex * pixelsPerKeypoint, myAddress.offset);\\nvec4 keypointData = readKeypointData(encodedKeypoints, oldEncoderLength, address);\\ncolor = myKeypointIndex < maxKeypoints && element.valid ? keypointData : encodeNullKeypoint();\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform sampler2D encodedKeypoints;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int encoderLength;\\nstruct PermutationElement\\n{\\nint keypointIndex;\\nfloat score;\\nbool valid;\\n};\\nvec4 encodePermutationElement(PermutationElement element)\\n{\\nfloat valid = float(element.valid);\\nfloat score = clamp(element.score, 0.0f, 1.0f);\\nvec2 encodedIndex = vec2(element.keypointIndex & 255, (element.keypointIndex >> 8) & 255) / 255.0f;\\nreturn vec4(encodedIndex, score, valid);\\n}\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nint stride = outputSize().x;\\nint keypointIndex = thread.y * stride + thread.x;\\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\\nKeypointAddress address = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);\\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\\nPermutationElement element;\\nelement.valid = !isBadKeypoint(keypoint);\\nelement.score = keypoint.score;\\nelement.keypointIndex = keypointIndex;\\ncolor = encodePermutationElement(element);\\n}\"","module.exports = \"uniform sampler2D permutation;\\nuniform int blockSize;\\nuniform int dblLog2BlockSize;\\nstruct PermutationElement\\n{\\nint keypointIndex;\\nfloat score;\\nbool valid;\\n};\\nPermutationElement decodePermutationElement(vec4 pixel)\\n{\\nPermutationElement element;\\nelement.keypointIndex = int(pixel.r * 255.0f) | (int(pixel.g * 255.0f) << 8);\\nelement.valid = (pixel.a > 0.0f);\\nelement.score = element.valid ? pixel.b : -1.0f;\\nreturn element;\\n}\\nvec4 encodePermutationElement(PermutationElement element)\\n{\\nfloat valid = float(element.valid);\\nfloat score = clamp(element.score, 0.0f, 1.0f);\\nvec2 encodedIndex = vec2(element.keypointIndex & 255, (element.keypointIndex >> 8) & 255) / 255.0f;\\nreturn vec4(encodedIndex, score, valid);\\n}\\nPermutationElement readPermutationElement(sampler2D permutation, int elementIndex, int stride, int height)\\n{\\nconst vec4 INVALID_PIXEL = vec4(0.0f);\\nivec2 pos = ivec2(elementIndex % stride, elementIndex / stride);\\nvec4 pixel = pos.y < height ? pixelAt(permutation, pos) : INVALID_PIXEL;\\nreturn decodePermutationElement(pixel);\\n}\\nPermutationElement selectKth(int k, int la, int ra, int lb, int rb)\\n{\\nPermutationElement a, b;\\nint ha, hb, ma, mb;\\nbool discard1stHalf, altb;\\nbool locked = false;\\nint tmp, result = 0;\\nint stride = outputSize().x;\\nint height = outputSize().y;\\nfor(int i = 0; i < dblLog2BlockSize; i++) {\\ntmp = (lb > rb && !locked) ? (la+k) : result;\\nresult = (la > ra && !locked) ? (lb+k) : tmp;\\nlocked = locked || (la > ra) || (lb > rb);\\nha = (ra - la + 1) / 2;\\nhb = (rb - lb + 1) / 2;\\nma = la + ha;\\nmb = lb + hb;\\na = readPermutationElement(permutation, ma, stride, height);\\nb = readPermutationElement(permutation, mb, stride, height);\\ndiscard1stHalf = (k > ha + hb);\\naltb = (-a.score < -b.score);\\nk -= int(discard1stHalf && altb) * (ha + 1);\\nk -= int(discard1stHalf && !altb) * (hb + 1);\\nla += int(discard1stHalf && altb) * (ma + 1 - la);\\nlb += int(discard1stHalf && !altb) * (mb + 1 - lb);\\nra += int(!discard1stHalf && !altb) * (ma - 1 - ra);\\nrb += int(!discard1stHalf && altb) * (mb - 1 - rb);\\n}\\nreturn readPermutationElement(permutation, result, stride, height);\\n}\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nint stride = outputSize().x;\\nint elementIndex = thread.y * stride + thread.x;\\nint blockIndex = elementIndex / blockSize;\\nint blockOffset = elementIndex % blockSize;\\nint la = blockIndex * blockSize;\\nint lb = la + blockSize / 2;\\nint ra = lb - 1;\\nint rb = (blockIndex + 1) * blockSize - 1;\\nint k = blockOffset;\\nPermutationElement element = selectKth(k, la, ra, lb, rb);\\ncolor = encodePermutationElement(element);\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform sampler2D encodedKeypoints;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int encoderLength;\\nuniform int suppressedEncoderLength;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nKeypointAddress myAddress = findKeypointAddress(thread, suppressedEncoderLength, 0, extraSize);\\nint myIndex = findKeypointIndex(myAddress, 0, extraSize);\\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\\nKeypointAddress otherAddress = KeypointAddress(myIndex * pixelsPerKeypoint, myAddress.offset);\\ncolor = readKeypointData(encodedKeypoints, encoderLength, otherAddress);\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform sampler2D encodedOrientations;\\nuniform sampler2D encodedKeypoints;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int encoderLength;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(encodedKeypoints);\\nivec2 thread = threadLocation();\\nKeypointAddress myAddress = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\\nint myIndex = findKeypointIndex(myAddress, descriptorSize, extraSize);\\nint orientationEncoderLength = textureSize(encodedOrientations, 0).x;\\nivec2 location = ivec2(myIndex % orientationEncoderLength, myIndex / orientationEncoderLength);\\nvec4 targetPixel = pixelAt(encodedOrientations, location);\\nfloat encodedOrientation = targetPixel.g;\\nfloat encodedFlags = targetPixel.a;\\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, myAddress);\\nkeypoint.flags |= decodeKeypointFlags(encodedFlags);\\nbool isValid = !isBadKeypoint(keypoint);\\ncolor = isValid && myAddress.offset == 1 ? vec4(pixel.r, encodedOrientation, pixel.b, encodeKeypointFlags(keypoint.flags)) : pixel;\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform sampler2D encodedKeypoints;\\nuniform int startIndex;\\nuniform int endIndex;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int encoderLength;\\n#ifndef BUFFER_SIZE\\n#error Undefined BUFFER_SIZE\\n#endif\\nlayout(std140) uniform KeypointBuffer\\n{\\nvec4 keypointBuffer[BUFFER_SIZE];\\n};\\nvoid main()\\n{\\nvec4 pixel = threadPixel(encodedKeypoints);\\nivec2 thread = threadLocation();\\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\\nint index = findKeypointIndex(address, descriptorSize, extraSize);\\ncolor = pixel;\\nif(index < startIndex)\\nreturn;\\ncolor = encodeNullKeypoint();\\nif(index >= endIndex)\\nreturn;\\nvec4 data = keypointBuffer[index - startIndex];\\nswitch(address.offset) {\\ncase 0: {\\nfixed2_t pos = vec2tofix(data.xy);\\nfixed2_t lo = pos & 255;\\nfixed2_t hi = (pos >> 8) & 255;\\ncolor = vec4(float(lo.x), float(hi.x), float(lo.y), float(hi.y)) / 255.0f;\\nbreak;\\n}\\ncase 1: {\\nfloat score = clamp(data.w, 0.0f, 1.0f);\\nfloat scale = encodeLod(data.z);\\nfloat rotation = encodeOrientation(0.0f);\\nfloat flags = encodeKeypointFlags(KPF_NONE);\\ncolor = vec4(scale, rotation, score, flags);\\nbreak;\\n}\\ndefault: {\\ncolor = vec4(0.0f);\\nbreak;\\n}\\n}\\n}\"","module.exports = \"uniform sampler2D image;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nivec2 pos = min(thread * 2, textureSize(image, 0) - ivec2(1));\\ncolor = pixelAt(image, pos);\\n}\"","module.exports = \"uniform sampler2D image;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nvec4 pixel = pixelAt(image, thread / 2);\\ncolor = (((thread.x + thread.y) & 1) == 0) ? pixel : vec4(0.0f, 0.0f, 0.0f, pixel.a);\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform sampler2D pyramid;\\nuniform sampler2D encodedKeypoints;\\nuniform int windowSize;\\nuniform float discardThreshold;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int encoderLength;\\nbool isInsideImage(vec2 position)\\n{\\nvec2 imageSize = vec2(textureSize(pyramid, 0));\\nfloat border = float(windowSize);\\nreturn (\\nposition.x > border && position.x < imageSize.x - border &&\\nposition.y > border && position.y < imageSize.y - border\\n);\\n}\\nvoid main()\\n{\\nvec4 pixel = threadPixel(encodedKeypoints);\\nivec2 thread = threadLocation();\\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\\ncolor = pixel;\\nif(address.offset != 1)\\nreturn;\\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\\nif(isBadKeypoint(keypoint))\\nreturn;\\nbool shouldDiscard = isKeypointAtInfinity(keypoint) || !isInsideImage(keypoint.position);\\nint newFlag = shouldDiscard ? KPF_DISCARD : 0;\\ncolor.a = encodeKeypointFlags(keypoint.flags | newFlag);\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform sampler2D pyramid;\\nuniform int windowSize;\\nuniform sampler2D encodedKeypoints;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int encoderLength;\\nbool isInsideImage(vec2 position)\\n{\\nvec2 imageSize = vec2(textureSize(pyramid, 0));\\nfloat border = float(windowSize);\\nreturn (\\nposition.x > border && position.x < imageSize.x - border &&\\nposition.y > border && position.y < imageSize.y - border\\n);\\n}\\nvoid main()\\n{\\nvec4 pixel = threadPixel(encodedKeypoints);\\nivec2 thread = threadLocation();\\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\\nbool shouldDiscard = isBadKeypoint(keypoint) || isKeypointAtInfinity(keypoint) || !isInsideImage(keypoint.position);\\ncolor = shouldDiscard ? encodeDiscardedKeypoint() : pixel;\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\n@include \\\"float16.glsl\\\"\\nuniform sampler2D nextPyramid;\\nuniform sampler2D prevPyramid;\\nuniform sampler2D encodedFlow;\\nuniform sampler2D prevKeypoints;\\nuniform int windowSize;\\nuniform int level;\\nuniform int depth;\\nuniform int numberOfIterations;\\nuniform float discardThreshold;\\nuniform float epsilon;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int encoderLength;\\n#ifndef MAX_WINDOW_SIZE\\n#error Must define MAX_WINDOW_SIZE\\n#endif\\n#define NEXT_IMAGE 1\\n#define PREV_IMAGE 0\\nconst int MAX_WINDOW_SIZE_SQUARED = (MAX_WINDOW_SIZE) * (MAX_WINDOW_SIZE);\\nconst int MAX_WINDOW_SIZE_PLUS = (MAX_WINDOW_SIZE) + 2;\\nconst int MAX_WINDOW_SIZE_PLUS_SQUARED = MAX_WINDOW_SIZE_PLUS * MAX_WINDOW_SIZE_PLUS;\\nconst int DBL_MAX_WINDOW_SIZE_PLUS_SQUARED = 2 * MAX_WINDOW_SIZE_PLUS_SQUARED;\\nconst int MAX_WINDOW_RADIUS_PLUS = (MAX_WINDOW_SIZE_PLUS - 1) / 2;\\nconst int MAX_WINDOW_RADIUS = ((MAX_WINDOW_SIZE) - 1) / 2;\\nconst highp float FLT_SCALE = 0.00000095367431640625f;\\nconst highp float FLT_EPSILON = 0.00000011920929f;\\nconst highp float INFINITY = 1.0f / 0.0f;\\n#define windowRadius() ((windowSize - 1) / 2)\\nfloat pixelBuffer[DBL_MAX_WINDOW_SIZE_PLUS_SQUARED];\\n#define prevPixel(index) pixelBuffer[(index)]\\n#define nextPixel(index) pixelBuffer[MAX_WINDOW_SIZE_PLUS_SQUARED + (index)]\\n#define pixelIndex(i, j) (((j) + MAX_WINDOW_RADIUS_PLUS) * MAX_WINDOW_SIZE_PLUS + ((i) + MAX_WINDOW_RADIUS_PLUS))\\nivec2 derivBuffer[MAX_WINDOW_SIZE_SQUARED];\\n#define derivativesAt(x, y) derivBuffer[((y) + MAX_WINDOW_RADIUS) * MAX_WINDOW_SIZE + ((x) + MAX_WINDOW_RADIUS)]\\nvoid readWindow(vec2 center, float lod)\\n{\\nivec2 pyrBaseSize = textureSize(prevPyramid, 0);\\nfloat pot = exp2(lod);\\nint r = windowRadius();\\nivec2 offset; int idx;\\n#define readPixelsAt(ox, oy) offset = ivec2((ox), (oy)); \\\\\\nidx = pixelIndex(offset.x, offset.y); \\\\\\nnextPixel(idx) = pyrSubpixelAtExOffset(nextPyramid, center, lod, pot, offset, pyrBaseSize).g; \\\\\\nprevPixel(idx) = pyrSubpixelAtExOffset(prevPyramid, center, lod, pot, offset, pyrBaseSize).g\\nfor(int j = 0; j < windowSize; j++) {\\nfor(int i = 0; i < windowSize; i++) {\\nreadPixelsAt(i-r, j-r);\\n}\\n}\\nint r1 = r+1;\\nfor(int k = 0; k < windowSize; k++) {\\nreadPixelsAt(-r1, k-r);\\nreadPixelsAt( r1, k-r);\\nreadPixelsAt(k-r,-r1);\\nreadPixelsAt(k-r, r1);\\n}\\nreadPixelsAt(-r1,-r1);\\nreadPixelsAt( r1,-r1);\\nreadPixelsAt(-r1, r1);\\nreadPixelsAt( r1, r1);\\n}\\nvec2 computeDerivatives(int imageCode, ivec2 offset)\\n{\\nconst mat3 dx = mat3(\\n3, 0, -3,\\n10, 0, -10,\\n3, 0, -3\\n);\\nconst mat3 dy = mat3(\\n3, 10, 3,\\n0, 0, 0,\\n-3, -10, -3\\n);\\nint indexOffset = imageCode * MAX_WINDOW_SIZE_PLUS_SQUARED;\\nmat3 window = mat3(\\npixelBuffer[indexOffset + pixelIndex(offset.x-1, offset.y-1)],\\npixelBuffer[indexOffset + pixelIndex(offset.x+0, offset.y-1)],\\npixelBuffer[indexOffset + pixelIndex(offset.x+1, offset.y-1)],\\npixelBuffer[indexOffset + pixelIndex(offset.x-1, offset.y+0)],\\n0.0f,\\npixelBuffer[indexOffset + pixelIndex(offset.x+1, offset.y+0)],\\npixelBuffer[indexOffset + pixelIndex(offset.x-1, offset.y+1)],\\npixelBuffer[indexOffset + pixelIndex(offset.x+0, offset.y+1)],\\npixelBuffer[indexOffset + pixelIndex(offset.x+1, offset.y+1)]\\n);\\nmat3 fx = matrixCompMult(dx, window);\\nmat3 fy = matrixCompMult(dy, window);\\nconst vec3 ones = vec3(1.0f);\\nreturn vec2(\\ndot(fx[0], ones) + dot(fx[1], ones) + dot(fx[2], ones),\\ndot(fy[0], ones) + dot(fy[1], ones) + dot(fy[2], ones)\\n);\\n}\\nfloat readBufferedPixel(int imageCode, ivec2 offset)\\n{\\nivec2 limit = ivec2(windowRadius());\\noffset = clamp(offset, -limit, limit);\\nint indexOffset = imageCode * MAX_WINDOW_SIZE_PLUS_SQUARED;\\nreturn pixelBuffer[indexOffset + pixelIndex(offset.x, offset.y)];\\n}\\nfloat readBufferedSubpixel(int imageCode, vec2 offset)\\n{\\nivec2 p = ivec2(floor(offset));\\nvec2 frc = fract(offset);\\nvec2 ifrc = vec2(1.0f) - frc;\\nvec4 pix4 = vec4(\\nreadBufferedPixel(imageCode, p),\\nreadBufferedPixel(imageCode, ivec2(p.x + 1, p.y)),\\nreadBufferedPixel(imageCode, ivec2(p.x, p.y + 1)),\\nreadBufferedPixel(imageCode, ivec2(p.x + 1, p.y + 1))\\n);\\nreturn dot(vec4(\\npix4.x * ifrc.x * ifrc.y,\\npix4.y * frc.x * ifrc.y,\\npix4.z * ifrc.x * frc.y,\\npix4.w * frc.x * frc.y\\n), vec4(1.0f));\\n}\\nivec2 computeMismatch(highp vec2 pyrGuess, highp vec2 localGuess)\\n{\\nint timeDerivative;\\nivec2 mismatch = ivec2(0);\\nint x, y, r = windowRadius();\\nhighp vec2 d = pyrGuess + localGuess;\\nfor(int _y = 0; _y < windowSize; _y++) {\\nfor(int _x = 0; _x < windowSize; _x++) {\\nx = _x - r; y = _y - r;\\ntimeDerivative = int(round(255.0f * (\\nreadBufferedSubpixel(NEXT_IMAGE, vec2(x, y) + d) -\\nreadBufferedPixel(PREV_IMAGE, ivec2(x, y))\\n)));\\nmismatch += derivativesAt(x, y) * timeDerivative;\\n}\\n}\\nreturn mismatch;\\n}\\nvec4 encodeFlow(vec2 flow)\\n{\\nreturn vec4(encodeFloat16(flow.x), encodeFloat16(flow.y));\\n}\\nvec2 decodeFlow(vec4 pix)\\n{\\nreturn vec2(decodeFloat16(pix.rg), decodeFloat16(pix.ba));\\n}\\nvoid main()\\n{\\nvec4 pixel = threadPixel(encodedFlow);\\nivec2 thread = threadLocation();\\nfloat windowArea = float(windowSize * windowSize);\\nint r = windowRadius();\\nint keypointIndex = thread.x + thread.y * outputSize().x;\\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\\nKeypointAddress address = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);\\nKeypoint keypoint = decodeKeypoint(prevKeypoints, encoderLength, address);\\ncolor = encodeFlow(vec2(0.0f));\\nif(isBadKeypoint(keypoint))\\nreturn;\\nhighp vec2 pyrGuess = (level < depth - 1) ? decodeFlow(pixel) : vec2(0.0f);\\nreadWindow(keypoint.position, float(level));\\nivec2 derivatives;\\nivec3 harris3i = ivec3(0);\\nfor(int j = 0; j < windowSize; j++) {\\nfor(int i = 0; i < windowSize; i++) {\\nderivatives = ivec2(floor(255.0f * computeDerivatives(PREV_IMAGE, ivec2(i-r, j-r))));\\nharris3i += ivec3(\\nderivatives.x * derivatives.x,\\nderivatives.x * derivatives.y,\\nderivatives.y * derivatives.y\\n);\\nderivativesAt(i-r, j-r) = derivatives;\\n}\\n}\\nhighp vec3 harris = vec3(harris3i) * FLT_SCALE;\\nhighp float det = harris.x * harris.z - harris.y * harris.y;\\nhighp float invDet = 1.0f / det;\\nhighp mat2 invHarris = mat2(harris.z, -harris.y, -harris.y, harris.x);\\nhighp float minEigenvalue = 0.5f * ((harris.x + harris.z) - sqrt(\\n(harris.x - harris.z) * (harris.x - harris.z) + 4.0f * (harris.y * harris.y)\\n));\\nint niceNumbers = int(det >= FLT_EPSILON && minEigenvalue >= discardThreshold * windowArea);\\nbool goodKeypoint = (level > 0) || (niceNumbers != 0);\\nhighp float eps2 = epsilon * epsilon;\\nhighp vec2 mismatch, delta, localGuess = vec2(0.0f);\\nfor(int k = 0; k < numberOfIterations; k++) {\\nmismatch = vec2(computeMismatch(pyrGuess, localGuess)) * FLT_SCALE;\\ndelta = mismatch * invHarris * invDet;\\nniceNumbers *= int(eps2 <= dot(delta, delta));\\nlocalGuess += float(niceNumbers) * delta;\\n}\\npyrGuess = 2.0f * (pyrGuess + localGuess);\\nvec2 opticalFlow = goodKeypoint ? pyrGuess : vec2(INFINITY);\\ncolor = encodeFlow(opticalFlow);\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\n@include \\\"float16.glsl\\\"\\nuniform sampler2D encodedFlow;\\nuniform sampler2D encodedKeypoints;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int encoderLength;\\nvec2 decodeFlow(vec4 pix)\\n{\\nreturn vec2(decodeFloat16(pix.rg), decodeFloat16(pix.ba));\\n}\\nvoid main()\\n{\\nvec4 pixel = threadPixel(encodedKeypoints);\\nivec2 thread = threadLocation();\\nKeypointAddress myAddress = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, myAddress);\\nint myIndex = findKeypointIndex(myAddress, descriptorSize, extraSize);\\nint len = textureSize(encodedFlow, 0).x;\\nivec2 location = ivec2(myIndex % len, myIndex / len);\\nvec4 targetPixel = pixelAt(encodedFlow, location);\\nvec2 flow = decodeFlow(targetPixel);\\nvec4 newPosition = encodeKeypointPosition(keypoint.position + flow);\\nvec4 encodedPosition = any(isinf(flow)) ? encodeKeypointPositionAtInfinity() : newPosition;\\ncolor = myAddress.offset == 0 ? encodedPosition : pixel;\\n}\"","module.exports = \"@include \\\"subpixel.glsl\\\"\\nuniform sampler2D image;\\nvoid main()\\n{\\nvec2 imageSize = vec2(textureSize(image, 0));\\n#if !defined(INTERPOLATION_METHOD)\\n#error Must define INTERPOLATION_METHOD\\n#elif INTERPOLATION_METHOD == 0\\nvec2 pos = texCoord * imageSize;\\ncolor = textureLod(image, (round(pos) + vec2(0.5f)) / imageSize, 0.0f);\\n#elif INTERPOLATION_METHOD == 1\\ncolor = subpixelAtBI(image, texCoord * imageSize);\\n#else\\n#error Invalid INTERPOLATION_METHOD\\n#endif\\n}\"","module.exports = \"@include \\\"subpixel.glsl\\\"\\nuniform sampler2D image;\\nuniform mat3 inverseHomography;\\nconst vec4 emptyColor = vec4(0.0f, 0.0f, 0.0f, 1.0f);\\nvec2 perspectiveWarp(mat3 homography, vec2 p)\\n{\\nvec3 q = homography * vec3(p, 1.0f);\\nreturn q.xy / q.z;\\n}\\nvoid main()\\n{\\nivec2 location = threadLocation();\\nivec2 size = outputSize();\\nconst vec2 zero = vec2(0.0f);\\nvec2 target = perspectiveWarp(inverseHomography, vec2(location));\\nbool withinBounds = all(bvec4(greaterThanEqual(target, zero), lessThan(target, vec2(size))));\\ncolor = withinBounds ? subpixelAtBI(image, target) : emptyColor;\\n}\"","module.exports = \"@include \\\"colors.glsl\\\"\\nuniform sampler2D dest, src;\\nuniform int destComponents;\\nuniform int srcComponentId;\\nvoid main()\\n{\\nvec4 destPixel = threadPixel(dest);\\nvec4 srcPixel = threadPixel(src);\\nbvec4 flags = bvec4(\\n(destComponents & PIXELCOMPONENT_RED) != 0,\\n(destComponents & PIXELCOMPONENT_GREEN) != 0,\\n(destComponents & PIXELCOMPONENT_BLUE) != 0,\\n(destComponents & PIXELCOMPONENT_ALPHA) != 0\\n);\\ncolor = mix(destPixel, vec4(srcPixel[srcComponentId]), flags);\\n}\"","module.exports = \"@include \\\"colors.glsl\\\"\\nuniform sampler2D image;\\nuniform int pixelComponents;\\nuniform float value;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nbvec4 flags = bvec4(\\n(pixelComponents & PIXELCOMPONENT_RED) != 0,\\n(pixelComponents & PIXELCOMPONENT_GREEN) != 0,\\n(pixelComponents & PIXELCOMPONENT_BLUE) != 0,\\n(pixelComponents & PIXELCOMPONENT_ALPHA) != 0\\n);\\ncolor = mix(pixel, vec4(value), flags);\\n}\"","module.exports = \"uniform float value;\\nvoid main()\\n{\\ncolor = vec4(value);\\n}\"","module.exports = \"uniform sampler2D image;\\nvoid main() {\\nivec2 pos = threadLocation();\\npos.y = int(texSize.y) - 1 - pos.y;\\ncolor = pixelAt(image, pos);\\n}\"","module.exports = \"uniform sampler2D image;\\nvoid main()\\n{\\ncolor = threadPixel(image);\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform int iterationNumber;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nivec2 last = outputSize() - ivec2(1);\\nint jump = (1 << iterationNumber);\\nint clusterLength = jump << 1;\\nint clusterMask = clusterLength - 1;\\nivec2 clusterPos = ivec2(thread >> (1 + iterationNumber)) << (1 + iterationNumber);\\nivec2 next1 = clusterPos + ((thread - clusterPos + ivec2(jump, 0)) & clusterMask);\\nivec2 next2 = clusterPos + ((thread - clusterPos + ivec2(0, jump)) & clusterMask);\\nivec2 next3 = clusterPos + ((thread - clusterPos + ivec2(jump, jump)) & clusterMask);\\nvec4 p0 = texelFetch(image, thread, 0);\\nvec4 p1 = texelFetch(image, min(next1, last), 0);\\nvec4 p2 = texelFetch(image, min(next2, last), 0);\\nvec4 p3 = texelFetch(image, min(next3, last), 0);\\nvec4 pmax = max(max(p0, p1), max(p2, p3));\\nvec4 pmin = min(min(p0, p1), min(p2, p3));\\ncolor = vec4(pmax.r, pmin.g, pmax.r - pmin.g, p0.a);\\n}\"","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-gl.js\n * A wrapper around the WebGL Rendering Context\n */\n\nimport { Utils } from '../utils/utils';\nimport { Observable } from '../utils/observable';\nimport { SpeedyPromise } from '../utils/speedy-promise';\nimport { NotSupportedError } from '../utils/errors';\n\n// Constants\nconst CANVAS_WIDTH = 2048; // this size should be compatible with everything...\nconst CANVAS_HEIGHT = 2048;\nconst SINGLETON_KEY = Symbol();\n\n/** @type {SpeedyGL} Singleton */\nlet instance = null;\n\n/**\n * A wrapper around the WebGL Rendering Context\n */\nexport class SpeedyGL extends Observable\n{\n    /**\n     * Constructor\n     * @param {Symbol} key\n     * @private\n     */\n    constructor(key)\n    {\n        Utils.assert(key === SINGLETON_KEY);\n        super();\n\n        // does the browser support WebGL2?\n        if(typeof WebGL2RenderingContext === 'undefined')\n            throw new NotSupportedError(`This application requires WebGL2. Please use a different browser.`);\n\n        /** @type {HTMLCanvasElement} canvas */\n        this._canvas = this._createCanvas(this._reinitialize.bind(this));\n\n        /** @type {WebGL2RenderingContext} WebGL rendering context */\n        this._gl = this._createContext(this._canvas);\n\n        /** @type {boolean} internal flag */\n        this._reinitializeOnContextLoss = true;\n    }\n\n    /**\n     * Get Singleton\n     * @returns {SpeedyGL}\n     */\n    static get instance()\n    {\n        return instance || (instance = new SpeedyGL(SINGLETON_KEY));\n    }\n\n    /**\n     * The WebGL Rendering Context\n     * Be careful not to cache this, as the WebGL Rendering Context may be lost!\n     * @returns {WebGL2RenderingContext}\n     */\n    get gl()\n    {\n        return this._gl;\n    }\n\n    /**\n     * The canvas\n     * @returns {HTMLCanvasElement}\n     */\n    get canvas()\n    {\n        return this._canvas;\n    }\n\n    /**\n     * Create a WebGL-capable canvas\n     * @param {Function} reinitialize to be called if we get a WebGL context loss event\n     * @returns {HTMLCanvasElement}\n     */\n    _createCanvas(reinitialize)\n    {\n        const canvas = Utils.createCanvas(CANVAS_WIDTH, CANVAS_HEIGHT);\n\n        canvas.addEventListener('webglcontextlost', ev => {\n            Utils.warning(`Lost WebGL2 context`);\n            setTimeout(reinitialize, 0);\n            ev.preventDefault();\n        }, false);\n\n        /*canvas.addEventListener('webglcontextrestored', ev => {\n            Utils.warning(`Restored WebGL2 context`);\n            ev.preventDefault();\n        }, false);*/\n\n        return canvas;\n    }\n\n    /**\n     * Create a WebGL2 Rendering Context\n     * @param {HTMLCanvasElement} canvas\n     * @returns {WebGL2RenderingContext}\n     */\n    _createContext(canvas)\n    {\n         const gl = canvas.getContext('webgl2', {\n            premultipliedAlpha: false,\n            preserveDrawingBuffer: false,\n            //preferLowPowerToHighPerformance: false, // TODO user option?\n            alpha: true,\n            antialias: false,\n            depth: false,\n            stencil: false,\n        });\n\n        if(!gl)\n            throw new NotSupportedError(`Can't create a WebGL2 Rendering Context. Try a different browser!`);       \n\n        return gl;\n    }\n\n    /**\n     * Reinitialize WebGL\n     */\n    _reinitialize()\n    {\n        // disable reinitialization?\n        if(!this._reinitializeOnContextLoss)\n            return;\n\n        // warning\n        Utils.warning(`Reinitializing WebGL2...`);\n\n        // create new canvas\n        this._canvas.remove();\n        this._canvas = this._createCanvas(this._reinitialize.bind(this));\n\n        // create new context\n        this._gl = this._createContext(this._canvas);\n\n        // notify observers: we have a new context!\n        // we need to recreate all textures...\n        this._notify(this._gl);\n    }\n\n    /**\n     * Lose the WebGL context. This is used to manually\n     * free resources, and also for purposes of testing\n     * @returns {WEBGL_lose_context}\n     */\n    loseContext()\n    {\n        const gl = this._gl;\n\n        // nothing to do?\n        if(gl.isContextLost())\n            return;\n\n        // find the appropriate extension\n        const ext = gl.getExtension('WEBGL_lose_context');\n        if(!ext)\n            throw new NotSupportedError('WEBGL_lose_context extension is unavailable');\n\n        // disable reinitialization\n        this._reinitializeOnContextLoss = false;\n\n        // lose context\n        ext.loseContext();\n\n        // done!\n        return ext;\n    }\n\n    /**\n     * Lose & restore the WebGL context\n     * @param {number} [secondsToRestore]\n     * @return {SpeedyPromise<WEBGL_lose_context>} resolves as soon as the context is restored\n     */\n    loseAndRestoreContext(secondsToRestore = 1)\n    {\n        const ms = Math.max(secondsToRestore, 0) * 1000;\n        const ext = this.loseContext();\n\n        return new SpeedyPromise(resolve => {\n            setTimeout(() => {\n                //ext.restoreContext();\n                this._reinitializeOnContextLoss = true;\n                this._reinitialize();\n                setTimeout(() => resolve(ext), 0); // next frame\n            }, ms);\n        });\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-gpu.js\n * GPU-accelerated routines for Computer Vision\n */\n\nimport { SpeedyGL } from './speedy-gl';\nimport { SpeedyTexture } from './speedy-texture';\nimport { SpeedyProgramCenter } from './speedy-program-center';\nimport { SpeedyTexturePool } from './speedy-texture-pool';\nimport { SpeedyTextureUploader } from './speedy-texture-uploader';\nimport { SpeedyMediaSource } from '../core/speedy-media-source';\nimport { NotSupportedError, IllegalArgumentError } from '../utils/errors';\nimport { MAX_TEXTURE_LENGTH } from '../utils/globals';\nimport { Utils } from '../utils/utils';\n\n\n/**\n * GPU-accelerated routines for Computer Vision\n */\nexport class SpeedyGPU\n{\n    /**\n     * Constructor\n     * @param {number} width width of the image you're working with\n     * @param {number} height height of the image you're working with\n     */\n    constructor(width, height)\n    {\n        // validate texture size\n        if(width > MAX_TEXTURE_LENGTH || height > MAX_TEXTURE_LENGTH)\n            throw new NotSupportedError(`Maximum texture size exceeded. Using ${width} x ${height}, expected up to ${MAX_TEXTURE_LENGTH} x ${MAX_TEXTURE_LENGTH}.`);\n        else if(width < 1 || height < 1)\n            throw new IllegalArgumentError(`Invalid texture size: ${width} x ${height}`);\n\n\n\n        /** @type {SpeedyGL} cached reference */\n        this._speedyGL = SpeedyGL.instance;\n\n        /** @type {number} width of the textures */\n        this._width = width | 0;\n\n        /** @type {number} height of the textures */\n        this._height = height | 0;\n\n        /** @type {SpeedyProgramCenter} GPU-based programs */\n        this._programs = new SpeedyProgramCenter(this, this._width, this._height);\n\n        /** @type {SpeedyTexturePool} texture pool */\n        this._texturePool = new SpeedyTexturePool(this);\n\n        /** @type {SpeedyTextureUploader} texture uploader */\n        this._textureUploader = new SpeedyTextureUploader(this);\n\n\n\n        // recreate the state if necessary\n        this._speedyGL.subscribe(this._reset = this._reset.bind(this));\n    }\n\n    /**\n     * Access point to all GPU programs\n     * @returns {SpeedyProgramCenter}\n     */\n    get programs()\n    {\n        return this._programs;\n    }\n\n    /**\n     * The WebGL Rendering Context\n     * Be careful not to cache this, as the WebGL Rendering Context may be lost!\n     * @returns {WebGL2RenderingContext}\n     */\n    get gl()\n    {\n        return this._speedyGL.gl;\n    }\n\n    /**\n     * Internal canvas\n     * @returns {HTMLCanvasElement}\n     */\n    get canvas()\n    {\n        return this._speedyGL.canvas;\n    }\n\n    /**\n     * Texture pool\n     * @returns {SpeedyTexturePool}\n     */\n    get texturePool()\n    {\n        return this._texturePool;\n    }\n\n    /**\n     * Renders a texture to the canvas\n     * @param {SpeedyTexture} texture\n     * @returns {HTMLCanvasElement} returned for convenience\n     */\n    renderToCanvas(texture)\n    {\n        return this.programs.utils.renderToCanvas(texture);\n    }\n\n    /**\n     * Upload an image to the GPU\n     * @param {SpeedyMediaSource} source\n     * @param {SpeedyTexture} [outputTexture]\n     * @returns {SpeedyTexture} an internal texture if an output texture is not provided\n     */\n    upload(source, outputTexture = null)\n    {\n        return this._textureUploader.upload(source, outputTexture);\n    }\n\n    /**\n     * Releases resources\n     * @returns {null}\n     */\n    release()\n    {\n        Utils.assert(!this.isReleased());\n\n        // release internal components\n        this._programs = this._programs.release();\n        this._texturePool = this._texturePool.release();\n        this._textureUploader = this._textureUploader.release();\n\n        // unsubscribe\n        this._speedyGL.unsubscribe(this._reset);\n        return null;\n    }\n\n    /**\n     * Has this SpeedyGPU been released?\n     * @returns {boolean}\n     */\n    isReleased()\n    {\n        return this._programs == null;\n    }\n\n    /**\n     * Lose & restore the WebGL context (useful for testing purposes)\n     * @return {SpeedyPromise<void>} resolves as soon as the context is restored\n     */\n    loseAndRestoreWebGLContext()\n    {\n        return this._speedyGL.loseAndRestoreContext().then(() => void(0));\n    }\n\n    /**\n     * Reset the internal state\n     * (called on context reset)\n     */\n    _reset()\n    {\n        if(this.isReleased())\n            return;\n\n        this._programs = new SpeedyProgramCenter(this, this._width, this._height);\n        this._texturePool = new SpeedyTexturePool(this);\n        this._textureUploader = new SpeedyTextureUploader(this);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-program-center.js\n * An access point to all programs that run on the GPU\n */\n\nimport { GPUUtils } from './programs/utils';\nimport { GPUColors } from './programs/colors';\nimport { GPUFilters } from './programs/filters';\nimport { GPUKeypoints } from './programs/keypoints';\nimport { GPUEncoders } from './programs/encoders';\nimport { GPUPyramids } from './programs/pyramids';\nimport { GPUEnhancements } from './programs/enhancements';\nimport { GPUTrackers } from './programs/trackers';\nimport { GPUTransforms } from './programs/transforms';\nimport { SpeedyProgramGroup } from './speedy-program-group';\nimport { PYRAMID_MAX_LEVELS } from '../utils/globals';\nimport { IllegalArgumentError } from '../utils/errors';\n\n/**\n * An access point to all programs that run on the CPU\n * All program groups can be accessed via this class\n */\nexport class SpeedyProgramCenter\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu reference to SpeedyGPU\n     * @param {number} width default width for output textures\n     * @param {number} height default height for output textures\n     */\n    constructor(gpu, width, height)\n    {\n        /** @type {SpeedyGPU} reference to SpeedyGPU */\n        this._gpu = gpu;\n\n        /** @type {number} default width for output textures */\n        this._width = width;\n\n        /** @type {number} default height for output textures */\n        this._height = height;\n\n        // program groups\n        // (lazy instantiation)\n        this._utils = null;\n        this._colors = null;\n        this._filters = null;\n        this._keypoints = null;\n        this._encoders = null;\n        this._descriptors = null;\n        this._enhancements = null;\n        this._trackers = null;\n        this._transforms = null;\n        this._pyramids = (new Array(PYRAMID_MAX_LEVELS)).fill(null);\n    }\n\n    /**\n     * Default width of the output texture of the programs\n     * @returns {number}\n     */\n    get width()\n    {\n        return this._width;\n    }\n\n    /**\n     * Default height of the output texture of the programs\n     * @returns {number}\n     */\n    get height()\n    {\n        return this._height;\n    }\n\n    /**\n     * Utility programs\n     * @returns {GPUUtils}\n     */\n    get utils()\n    {\n        return this._utils || (this._utils = new GPUUtils(this._gpu, this._width, this._height));\n    }\n\n    /**\n     * Programs related to color conversions\n     * @returns {GPUColors}\n     */\n    get colors()\n    {\n        return this._colors || (this._colors = new GPUColors(this._gpu, this._width, this._height));\n    }\n\n    /**\n     * Image filters & convolutions\n     * @returns {GPUFilters}\n     */\n    get filters()\n    {\n        return this._filters || (this._filters = new GPUFilters(this._gpu, this._width, this._height));\n    }\n\n    /**\n     * Keypoint detection & description\n     * @returns {GPUKeypoints}\n     */\n    get keypoints()\n    {\n        return this._keypoints || (this._keypoints = new GPUKeypoints(this._gpu, this._width, this._height));\n    }\n\n    /**\n     * Keypoint encoders\n     * @returns {GPUEncoders}\n     */\n    get encoders()\n    {\n        return this._encoders || (this._encoders = new GPUEncoders(this._gpu, this._width, this._height));\n    }\n\n    /**\n     * Feature trackers\n     * @returns {GPUTrackers}\n     */\n    get trackers()\n    {\n        return this._trackers || (this._trackers = new GPUTrackers(this._gpu, this._width, this._height));\n    }\n\n    /**\n     * Image enhancement algorithms\n     * @returns {GPUEnhancements}\n     */\n    get enhancements()\n    {\n        return this._enhancements || (this._enhancements = new GPUEnhancements(this._gpu, this._width, this._height));\n    }\n\n    /**\n     * Geometric transformations\n     * @returns {GPUTransforms}\n     */\n    get transforms()\n    {\n        return this._transforms || (this._transforms = new GPUTransforms(this._gpu, this._width, this._height));\n    }\n\n    /**\n     * Image pyramids & scale-space\n     * @param {number} [level] level-of-detail: 0, 1, 2, ... (PYRAMID_MAX_LEVELS - 1)\n     * @returns {GPUPyramids}\n     */\n    pyramids(level = 0)\n    {\n        const lod = level | 0;\n        const pot = 1 << lod;\n\n        if(lod < 0 || lod >= PYRAMID_MAX_LEVELS)\n            throw new IllegalArgumentError(`Invalid pyramid level: ${lod} (outside of range [0,${PYRAMID_MAX_LEVELS-1}])`);\n\n        // use max(1, floor(size / 2^lod)), in accordance to the OpenGL ES 3.0 spec sec 3.8.10.4 (Mipmapping)\n        return this._pyramids[lod] || (this._pyramids[lod] = new GPUPyramids(this._gpu,\n            Math.max(1, Math.floor(this._width / pot)),\n            Math.max(1, Math.floor(this._height / pot))\n        ));\n    }\n\n    /**\n     * Release all programs from all groups. You'll\n     * no longer be able to use any of them.\n     * @returns {null}\n     */\n    release()\n    {\n        for(const key in this) {\n            if(Object.prototype.hasOwnProperty.call(this, key)) {\n                if(this[key] != null && (this[key] instanceof SpeedyProgramGroup))\n                    this[key].release();\n            }\n        }\n\n        for(let i = 0; i < this._pyramids.length; i++) {\n            if(this._pyramids[i] != null)\n                this._pyramids[i].release();\n        }\n\n        return null;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-program-group.js\n * An abstract group of programs that run on the GPU\n */\n\nimport { SpeedyProgram } from './speedy-program';\nimport { SpeedyGPU } from './speedy-gpu';\n\n/**\n * SpeedyProgramGroup\n * A semantically correlated group\n * of programs that run on the GPU\n * @abstract\n */\nexport class SpeedyProgramGroup\n{\n    /**\n     * Class constructor\n     * @protected\n     * @param {SpeedyGPU} gpu\n     * @param {number} width Texture width (depends on the pyramid layer)\n     * @param {number} height Texture height (depends on the pyramid layer)\n     */\n    constructor(gpu, width, height)\n    {\n        /** @type {SpeedyGPU} GPU-accelerated routines */\n        this._gpu = gpu;\n\n        /** @type {number} width of the output textures of the programs */\n        this._width = width;\n\n        /** @type {number} height of the output textures of the programs */\n        this._height = height;\n\n        /** @type {object?} helpers for declaring programs */\n        this._helpers = null;\n\n        /** @type {SpeedyProgram[]} the list of all programs that belong to this group */\n        this._programs = [];\n    }\n\n    /**\n     * Declare a program\n     * @protected\n     * @param {string} name Program name\n     * @param {ShaderDeclaration} shaderdecl Shader declaration\n     * @param {object} settings Program settings\n     * @returns {SpeedyProgramGroup} This object\n     */\n    declare(name, shaderdecl, settings = {})\n    {\n        // lazy instantiation of kernels\n        Object.defineProperty(this, name, {\n            get: (() => {\n                const key = '__k_' + name;\n                return (function() {\n                    return this[key] || (this[key] = this._createProgram(shaderdecl, settings));\n                }).bind(this);\n            })()\n        });\n\n        return this;\n    }\n\n    /**\n     * Multi-pass composition\n     * @protected\n     * @param {string} name Program name\n     * @param {string} fn Other programs\n     * @returns {SpeedyProgramGroup} This object\n     */\n    compose(name, ...fn)\n    {\n        // function composition: functions are called in the order they are specified\n        // e.g., compose('h', 'f', 'g') means h(x) = g(f(x))\n        Object.defineProperty(this, name, {\n            get: (() => {\n                const key = '__c_' + name;\n                return (function() {\n                    return this[key] || (this[key] = (fn.length == 2) ? (() => {\n                        fn = fn.map(fi => this[fi]);\n                        return function compose(image, ...args) {\n                            return (fn[1])((fn[0])(image, ...args), ...args);\n                        };\n                    })() : ((fn.length == 3) ? (() => {\n                        fn = fn.map(fi => this[fi]);\n                        return function compose(image, ...args) {\n                            return (fn[2])((fn[1])((fn[0])(image, ...args), ...args), ...args);\n                        };\n                    })() : ((fn.length == 4) ? (() => {\n                        fn = fn.map(fi => this[fi]);\n                        return function compose(image, ...args) {\n                            return (fn[3])((fn[2])((fn[1])((fn[0])(image, ...args), ...args), ...args), ...args);\n                        };\n                    })() : (() => {\n                        fn = fn.map(fi => this[fi]);\n                        return function compose(image, ...args) {\n                            return fn.reduce((img, fi) => fi(img, ...args), image);\n                        };\n                    })())));\n                }).bind(this);\n            })()\n        });\n\n        return this;\n    }\n\n    /**\n     * Neat helpers to be used when declaring programs\n     * @returns {object}\n     */\n    get program()\n    {\n        return this._helpers || (this.helpers = {\n\n            // Set texture input/output size\n            // Dimensions are converted to integers\n            hasTextureSize(width, height) {\n                return {\n                    output: [ Math.max(1, width | 0), Math.max(1, height | 0) ]\n                };\n            },\n\n            // Render to canvas\n            // Use it when we're supposed to see the texture\n            rendersToCanvas() {\n                return {\n                    renderToTexture: false\n                };\n            },\n\n            // Pingpong Rendering: the output texture of a\n            // program cannot be used as an input to itself.\n            // This is a convenient helper in these situations\n            usesPingpongRendering() {\n                return {\n                    pingpong: true\n                };\n            },\n\n        });\n    }\n\n    /**\n     * Releases all programs from this group\n     * @returns {null}\n     */\n    release()\n    {\n        for(let i = 0; i < this._programs.length; i++)\n            this._programs[i].release();\n\n        return null;\n    }\n\n    /**\n     * Spawn a SpeedyProgram\n     * @param {ShaderDeclaration} shaderdecl Shader declaration\n     * @param {object} [settings] Program settings\n     * @returns {SpeedyProgram}\n     */\n    _createProgram(shaderdecl, settings = {})\n    {\n        const program = new SpeedyProgram(this._gpu.gl, shaderdecl, {\n            output: [ this._width, this._height ], // default settings\n            ...settings\n        });\n\n        this._programs.push(program);\n        return program;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-program.js\n * SpeedyProgram class\n */\n\nimport { SpeedyTexture, SpeedyDrawableTexture } from './speedy-texture';\nimport { SpeedyPromise } from '../utils/speedy-promise';\nimport { ShaderDeclaration } from './shader-declaration';\nimport { Utils } from '../utils/utils';\nimport { NotSupportedError, IllegalArgumentError, IllegalOperationError, GLError } from '../utils/errors';\n\n// Map uniform type to a gl function\nconst UNIFORM_SETTERS = Object.freeze({\n    'sampler2D':'uniform1i',\n    'float':    'uniform1f',\n    'int':      'uniform1i',\n    'uint':     'uniform1ui',\n    'bool':     'uniform1i',\n    'vec2':     'uniform2f',\n    'vec3':     'uniform3f',\n    'vec4':     'uniform4f',\n    'ivec2':    'uniform2i',\n    'ivec3':    'uniform3i',\n    'ivec4':    'uniform4i',\n    'uvec2':    'uniform2ui',\n    'uvec3':    'uniform3ui',\n    'uvec4':    'uniform4ui',\n    'bvec2':    'uniform2i',\n    'bvec3':    'uniform3i',\n    'bvec4':    'uniform4i',\n    'mat2':     'uniformMatrix2fv',\n    'mat3':     'uniformMatrix3fv',\n    'mat4':     'uniformMatrix4fv',\n});\n\n\n\n/**\n * A SpeedyProgram is a Function that\n * runs GPU-accelerated GLSL code\n */\nexport class SpeedyProgram extends Function\n{\n    /**\n     * Creates a new SpeedyProgram\n     * @param {WebGL2RenderingContext} gl WebGL context\n     * @param {ShaderDeclaration} shaderdecl Shader declaration\n     * @param {object} [options] user options\n     */\n    constructor(gl, shaderdecl, options = { })\n    {\n        super('...args', 'return this._self._call(...args)');\n        this._self = this.bind(this);\n        this._self._init(gl, shaderdecl, options);\n        return this._self;\n    }\n\n    /**\n     * Initialize the SpeedyProgram\n     * @param {WebGL2RenderingContext} gl WebGL context\n     * @param {ShaderDeclaration} shaderdecl Shader declaration\n     * @param {object} options user options\n     */\n    _init(gl, shaderdecl, options)\n    {\n        // not a valid context?\n        if(gl.isContextLost())\n            throw new IllegalOperationError(`Can't initialize SpeedyProgram: lost context`);\n\n        // options object\n        options = Object.assign({\n            // default options\n            output: [ 1, 1 ], // size of the output texture\n            renderToTexture: true, // render results to a texture?\n            pingpong: false, // alternate output texture between calls\n        }, options);\n\n\n\n        /** @type {WebGL2RenderingContext} */\n        this._gl = gl;\n\n        /** @type {WebGLProgram} vertex shader + fragment shader */\n        this._program = SpeedyProgram._compile(gl, shaderdecl.vertexSource, shaderdecl.fragmentSource);\n\n        /** @type {ProgramGeometry} this is a quad */\n        this._geometry = new ProgramGeometry(gl, {\n            position: shaderdecl.locationOfAttributes.position,\n            texCoord: shaderdecl.locationOfAttributes.texCoord\n        });\n\n        /** @type {string[]} names of the arguments of the SpeedyProgram */\n        this._argnames = shaderdecl.arguments;\n\n        /** @type {boolean[]} tells whether the i-th argument of the SpeedyProgram is an array or not */\n        this._argIsArray = (new Array(this._argnames.length)).fill(false);\n\n        /** @type {UBOHelper} UBO helper (lazy instantiation) */\n        this._ubo = null;\n\n        /** @type {boolean} should we render to a texture? If false, we render to the canvas */\n        this._renderToTexture = Boolean(options.renderToTexture);\n\n        /** @type {number} width of the output texture, in pixels */\n        this._width = options.output[0] | 0;\n\n        /** @type {number} height of the output texture, in pixels */\n        this._height = options.output[1] | 0;\n\n        /** @type {SpeedyDrawableTexture[]} internal texture(s) */\n        this._ownTexture = Array.from({ length: options.pingpong ? 2 : 1 },\n            () => new SpeedyDrawableTexture(gl, this._width, this._height));\n\n        /** @type {SpeedyDrawableTexture[]} output texture(s) */\n        this._texture = [].concat(this._ownTexture);\n\n        /** @type {number} used for pingpong rendering */\n        this._textureIndex = 0;\n\n        /** @type {Map<string,UniformVariable>} uniform variables */\n        this._uniform = new Map();\n\n\n        // autodetect uniforms\n        gl.useProgram(this._program);\n        for(const name of shaderdecl.uniforms) {\n            const type = shaderdecl.uniformType(name);\n            const location = gl.getUniformLocation(this._program, name);\n            this._uniform.set(name, new UniformVariable(type, location));\n        }\n\n        // match arguments & uniforms\n        for(let j = 0; j < this._argnames.length; j++) {\n            const argname = this._argnames[j];\n            if(!this._uniform.has(argname)) {\n                this._argIsArray[j] = this._uniform.has(argname + '[0]');\n                if(!this._argIsArray[j])\n                    throw new IllegalOperationError(`Expected uniform \"${argname}\", as declared in the argument list`);\n            }\n        }\n    }\n\n    /**\n     * Run the SpeedyProgram\n     * @param  {...(number|number[]|SpeedyTexture|SpeedyTexture[])} args\n     * @returns {SpeedyDrawableTexture}\n     */\n    _call(...args)\n    {\n        const gl = this._gl;\n        const argnames = this._argnames;\n\n        // matching arguments?\n        if(args.length != argnames.length)\n            throw new IllegalArgumentError(`Can't run shader: incorrect number of arguments (expected ${argnames.length}, got ${args.length})`);\n\n        // can't use the output texture as an input\n        const flatArgs = args.flat(); // args.reduce((arr, val) => arr.concat(val), []);\n        for(let j = flatArgs.length - 1; j >= 0; j--) {\n            if(flatArgs[j] === this._texture[this._textureIndex])\n                throw new NotSupportedError(`Can't run shader: don't use its output texture as an input to itself. Consider using pingpong rendering!`);\n        }\n\n        // context loss?\n        if(gl.isContextLost())\n            return this._texture[this._textureIndex];\n\n        // use program\n        gl.useProgram(this._program);\n\n        // bind the VAO\n        gl.bindVertexArray(this._geometry.vao);\n\n        // update texSize uniform (available in all fragment shaders)\n        const texSize = this._uniform.get('texSize');\n        gl.uniform2f(texSize.location, this.width, this.height);\n\n        // set uniforms[i] to args[i]\n        for(let i = 0, texNo = 0; i < args.length; i++) {\n            const argname = argnames[i];\n\n            if(!this._argIsArray[i]) {\n                // uniform variable matches argument name\n                const uniform = this._uniform.get(argname);\n                texNo = uniform.setValue(gl, args[i], texNo);\n            }\n            else {\n                // uniform array matches argument name\n                const array = args[i];\n                if(this._uniform.has(`${argname}[${array.length}]`))\n                    throw new IllegalArgumentError(`Can't run shader: too few elements in the \"${argname}\" array`);\n                for(let j = 0, uniform = undefined; (uniform = this._uniform.get(`${argname}[${j}]`)) !== undefined; j++)\n                    texNo = uniform.setValue(gl, array[j], texNo);\n            }\n        }\n\n        // set Uniform Buffer Objects (if any)\n        if(this._ubo !== null)\n            this._ubo.update();\n\n        // select the render target\n        const texture = this._texture[this._textureIndex];\n        const fbo = this._renderToTexture ? texture.glFbo : null;\n\n        // bind the FBO\n        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n\n        // draw call\n        gl.viewport(0, 0, this.width, this.height);\n        gl.drawArrays(gl.TRIANGLES, 0, 6); // mode, offset, count\n\n        // unbind the FBO\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n        // unbind the VAO\n        gl.bindVertexArray(null);\n\n        // we've just changed the texture! discard the pyramid, if any\n        texture.discardMipmaps();\n\n        // ping-pong rendering\n        this._pingpong();\n\n        // done!\n        return texture;\n    }\n\n    /**\n     * Set the output texture(s) and its (their) shape(s)\n     * @param {number} width new width, in pixels\n     * @param {number} height new height, in pixels\n     * @param  {...SpeedyDrawableTexture} texture output texture(s)\n     * @returns {SpeedyProgram} this\n     */\n    outputs(width, height, ...texture)\n    {\n        this.setOutputTexture(...texture);\n        this.setOutputSize(width, height);\n        return this;\n    }\n\n    /**\n     * Set the size of the output\n     * @param {number} width new width, in pixels\n     * @param {number} height new height, in pixels\n     * @returns {SpeedyProgram} this\n     */\n    setOutputSize(width, height)\n    {\n        Utils.assert(width > 0 && height > 0);\n\n        // update size\n        this._width = width | 0;\n        this._height = height | 0;\n\n        // resize the output texture(s)\n        for(let i = 0; i < this._texture.length; i++) {\n            if(this._texture[i] != null)\n                this._texture[i].resize(this._width, this._height);\n        }\n\n        // done!\n        return this;\n    }\n\n    /**\n     * Use the provided texture(s) as output\n     * @param {...SpeedyDrawableTextur} texture set to null to use the internal texture(s)\n     * @returns {SpeedyProgram} this\n     */\n    setOutputTexture(...texture)\n    {\n        const expectedTextures = this._texture.length;\n        Utils.assert(texture.length === expectedTextures, `Incorrect number of textures (expected ${expectedTextures})`);\n\n        /*\n        // FIXME pyramid bug... TODO get rid of ownTextures\n        // we need to keep the current size\n        const width = this.width;\n        const height = this.height;\n        */\n\n        // update output texture(s)\n        const useInternal = texture.every(tex => tex === null);\n        this._texture = !useInternal ? texture : this._ownTexture;\n        this._textureIndex = 0;\n\n        /*\n        // restore previous size\n        this.setOutputSize(width, height);\n        */\n\n        // done!\n        return this;\n    }\n\n    /**\n     * Clear the internal textures\n     * @returns {SpeedyDrawableTexture}\n     */\n    clear()\n    {\n        const texture = this._texture[this._textureIndex];\n\n        // clear internal textures\n        for(let i = 0; i < this._texture.length; i++)\n            this._texture[i].clear();\n\n        // ping-pong rendering\n        this._pingpong();\n\n        // done!\n        return texture;\n    }\n\n    /**\n     * Set data using a Uniform Buffer Object\n     * @param {string} blockName uniform block name\n     * @param {ArrayBufferView} data\n     */\n    setUBO(blockName, data)\n    {\n        if(this._ubo === null)\n            this._ubo = new UBOHelper(this._gl, this._program);\n\n        this._ubo.set(blockName, data);\n    }\n\n    /**\n     * Release the resources associated with this SpeedyProgram\n     * @returns {null}\n     */\n    release()\n    {\n        const gl = this._gl;\n\n        // Release UBOs (if any)\n        if(this._ubo != null)\n            this._ubo = this._ubo.release();\n\n        // Release internal textures\n        for(let i = 0; i < this._ownTexture.length; i++)\n            this._ownTexture[i] = this._ownTexture[i].release();\n        this._texture.fill(null);\n\n        // Release geometry\n        this._geometry = this._geometry.release();\n\n        // Release program\n        gl.deleteProgram(this._program);\n        this._program = null;\n\n        // Need to delete the shaders as well? In sec 5.14.9 Programs and shaders\n        // of the WebGL 1.0 spec, it is mentioned that the underlying GL object\n        // will automatically be marked for deletion when the JS object is\n        // destroyed (i.e., garbage collected)\n\n        // done!\n        return null;\n    }\n\n    /**\n     * Width of the output texture, in pixels\n     * @returns {number}\n     */\n    get width()\n    {\n        return this._width;\n    }\n\n    /**\n     * Height of the output texture, in pixels\n     * @returns {number}\n     */\n    get height()\n    {\n        return this._height;\n    }\n\n    /**\n     * Helper method for pingpong rendering: alternates\n     * the texture index from 0 to 1 and vice-versa\n     */\n    _pingpong()\n    {\n        if(this._texture.length > 1)\n            this._textureIndex = 1 - this._textureIndex;\n    }\n\n    /**\n     * Compile and link GLSL shaders\n     * @param {WebGL2RenderingContext} gl\n     * @param {string} vertexShaderSource GLSL code of the vertex shader\n     * @param {string} fragmentShaderSource GLSL code of the fragment shader\n     * @returns {WebGLProgram}\n     */\n    static _compile(gl, vertexShaderSource, fragmentShaderSource)\n    {\n        const program = gl.createProgram();\n        const vertexShader = gl.createShader(gl.VERTEX_SHADER);\n        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n\n        // compile vertex shader\n        gl.shaderSource(vertexShader, vertexShaderSource);\n        gl.compileShader(vertexShader);\n        gl.attachShader(program, vertexShader);\n\n        // compile fragment shader\n        gl.shaderSource(fragmentShader, fragmentShaderSource);\n        gl.compileShader(fragmentShader);\n        gl.attachShader(program, fragmentShader);\n\n        // link program\n        gl.linkProgram(program);\n        gl.validateProgram(program);\n\n        // got an error?\n        if(!gl.getProgramParameter(program, gl.LINK_STATUS) && !gl.isContextLost()) {\n            const errors = [\n                gl.getShaderInfoLog(fragmentShader),\n                gl.getShaderInfoLog(vertexShader),\n                gl.getProgramInfoLog(program),\n            ];\n\n            gl.deleteProgram(program);\n            gl.deleteShader(fragmentShader);\n            gl.deleteShader(vertexShader);\n\n            // display error\n            const spaces = i => Math.max(0, 2 - Math.floor(Math.log10(i)));\n            const col = k => Array(spaces(k)).fill(' ').join('') + k + '. ';\n            const formattedSource = fragmentShaderSource.split('\\n')\n                .map((line, no) => col(1+no) + line)\n                .join('\\n');\n\n            throw new GLError(\n                `Can't create shader.\\n\\n` +\n                `---------- ERROR ----------\\n` +\n                errors.join('\\n') + '\\n\\n' +\n                `---------- SOURCE CODE ----------\\n` +\n                formattedSource\n            );\n        }\n\n        // done!\n        return program;\n    }\n}\n\n\n\n\n\n// ============================================================================\n//                                  HELPERS\n// ============================================================================\n\n\n\n\n\n\n/**\n * Configure and store the VAO and the VBOs\n * @param {WebGL2RenderingContext} gl\n * @param {LocationOfAttributes} location\n * @returns {ProgramGeometry}\n *\n * @typedef {Object} LocationOfAttributes\n * @property {number} position\n * @property {number} texCoord\n *\n * @typedef {Object} BufferOfAttributes\n * @property {WebGLBuffer} position\n * @property {WebGLBuffer} texCoord\n */\nfunction ProgramGeometry(gl, location)\n{\n    /** @type {WebGLVertexArrayObject} Vertex Array Object */\n    this.vao = gl.createVertexArray();\n\n    /** @type {BufferOfAttributes} Vertex Buffer Objects */\n    this.vbo = Object.freeze({\n        position: gl.createBuffer(),\n        texCoord: gl.createBuffer()\n    });\n\n    /** @type {WebGL2RenderingContext} */\n    this._gl = gl;\n\n\n\n    // bind the VAO\n    gl.bindVertexArray(this.vao);\n\n    // set the position attribute\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.position);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n        // clip coordinates (CCW)\n        -1, -1,\n        1, -1,\n        -1, 1,\n\n        -1, 1,\n        1, -1,\n        1, 1,\n    ]), gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(location.position);\n    gl.vertexAttribPointer(location.position, // attribute location\n                            2,                // 2 components per vertex (x,y)\n                            gl.FLOAT,         // type\n                            false,            // don't normalize\n                            0,                // default stride (tightly packed)\n                            0);               // offset\n\n    // set the texCoord attribute\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo.texCoord);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n        // texture coordinates (CCW)\n        0, 0,\n        1, 0,\n        0, 1,\n\n        0, 1,\n        1, 0,\n        1, 1,\n    ]), gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(location.texCoord);\n    gl.vertexAttribPointer(location.texCoord, // attribute location\n                            2,                // 2 components per vertex (x,y)\n                            gl.FLOAT,         // type\n                            false,            // don't normalize\n                            0,                // default stride (tightly packed)\n                            0);               // offset\n\n    // unbind\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    gl.bindVertexArray(null);\n\n    // done!\n    return Object.freeze(this);\n}\n\n/**\n * Releases the internal resources\n * @returns {null}\n */\nProgramGeometry.prototype.release = function()\n{\n    const gl = this._gl;\n\n    gl.deleteVertexArray(this.vao);\n    gl.deleteBuffer(this.vbo.position);\n    gl.deleteBuffer(this.vbo.texCoord);\n\n    return null;\n}\n\n\n\n\n\n/**\n * Helper class for storing data in GLSL uniform variables\n * @param {string} type\n * @param {WebGLUniformLocation} location\n */\nfunction UniformVariable(type, location)\n{\n    /** @type {string} GLSL data type */\n    this.type = String(type);\n    if(!Object.prototype.hasOwnProperty.call(UNIFORM_SETTERS, this.type))\n        throw new NotSupportedError(`Unsupported uniform type: ${this.type}`);\n\n    /** @type {WebGLUniformLocation} uniform location in a WebGL program */\n    this.location = location;\n\n    /** @type {string} setter function */\n    this.setter = UNIFORM_SETTERS[this.type];\n    const n = Number((this.setter.match(/^uniform(Matrix)?(\\d)/))[2]) | 0;\n\n    /** @type {number} is the uniform a scalar (0), a vector (1) or a matrix (2)? */\n    this.dim = this.type.startsWith('mat') ? 2 : ((this.type.indexOf('vec') >= 0) | 0);\n\n    /** @type {number} required number of scalars */\n    this.length = (this.dim == 2) ? n * n : n;\n\n    // done!\n    return Object.freeze(this);\n}\n\n/**\n * Set the value of a uniform variable\n * @param {WebGL2RenderingContext} gl\n * @param {SpeedyTexture|number|boolean|number[]|boolean[]} value use column-major format for matrices\n * @param {number} texNo current texture index\n * @returns {number} new texture index\n */\nUniformVariable.prototype.setValue = function(gl, value, texNo)\n{\n    const setValue = gl[this.setter];\n\n    // check uniform type\n    if(this.type == 'sampler2D') {\n        // set texture\n        if(texNo > gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS)\n            throw new NotSupportedError(`Can't bind ${texNo} textures to a program: max is ${gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS}`);\n        else if(value == null)\n            throw new IllegalArgumentError(`Can't run shader: cannot use null as an input texture`);\n\n        gl.activeTexture(gl.TEXTURE0 + texNo);\n        gl.bindTexture(gl.TEXTURE_2D, value.glTexture);\n        gl.uniform1i(this.location, texNo);\n        texNo++;\n    }\n    else if(typeof value == 'number' || typeof value == 'boolean') {\n        // set scalar value\n        setValue.call(gl, this.location, value);\n    }\n    else if(Array.isArray(value)) {\n        // set vector or matrix\n        if(value.length === this.length) {\n            if(this.dim == 2)\n                setValue.call(gl, this.location, false, value); // matrix\n            else\n                setValue.call(gl, this.location, ...value); // vector\n        }\n        else\n            throw new IllegalArgumentError(`Can't run shader: incorrect number of values for ${this.type}: \"${value}\"`);\n    }\n    else\n        throw new IllegalArgumentError(`Can't run shader: unrecognized argument \"${value}\"`);\n\n    // done\n    return texNo;\n}\n\n\n\n\n\n\n/**\n * A helper class for handling Uniform Buffer Objects (UBOs)\n * @param {WebGL2RenderingContext} gl\n * @param {WebGLProgram} program\n */\nfunction UBOHelper(gl, program)\n{\n    this._gl = gl;\n    this._program = program;\n    this._nextIndex = 0;\n    this._ubo = Object.create(null);\n}\n\n/**\n * Set Uniform Buffer Object data\n * (the buffer will be uploaded when the program is executed)\n * @param {string} name uniform block name\n * @param {ArrayBufferView} data\n */\nUBOHelper.prototype.set = function(name, data)\n{\n    const gl = this._gl;\n\n    // create UBO entry\n    if(this._ubo[name] === undefined) {\n        this._ubo[name] = {\n            buffer: gl.createBuffer(),\n            blockBindingIndex: this._nextIndex++, // \"global\" binding index\n            blockIndex: null, // UBO \"location\" in the program\n            data: null\n        };\n    }\n\n    // get UBO entry for the given block name\n    const ubo = this._ubo[name];\n\n    // read block index & assign binding point\n    if(ubo.blockIndex === null) {\n        const blockIndex = gl.getUniformBlockIndex(this._program, name);\n        gl.uniformBlockBinding(this._program, blockIndex, ubo.blockBindingIndex);\n        ubo.blockIndex = blockIndex;\n    }\n\n    // store the data - we'll upload it later\n    ubo.data = data;\n}\n\n/**\n * Update UBO data\n * Called when we're using the appropriate WebGLProgram\n */\nUBOHelper.prototype.update = function()\n{\n    const gl = this._gl;\n\n    for(const name in this._ubo) {\n        const ubo = this._ubo[name];\n\n        gl.bindBuffer(gl.UNIFORM_BUFFER, ubo.buffer);\n        gl.bufferData(gl.UNIFORM_BUFFER, ubo.data.byteLength, gl.DYNAMIC_DRAW); // buffer orphaning - needed?\n        gl.bufferData(gl.UNIFORM_BUFFER, ubo.data, gl.DYNAMIC_DRAW);\n        gl.bindBufferBase(gl.UNIFORM_BUFFER, ubo.blockBindingIndex, ubo.buffer);\n        gl.bindBuffer(gl.UNIFORM_BUFFER, null);\n    }\n}\n\n/**\n * Release allocated buffers\n * @returns {null}\n */\nUBOHelper.prototype.release = function()\n{\n    const gl = this._gl;\n\n    for(const name in this._ubo) {\n        const ubo = this._ubo[name];\n\n        gl.deleteBuffer(ubo.buffer);\n        ubo.data = null;\n    }\n\n    return null;\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-texture-pool.js\n * Texture pool\n */\n\nimport { Utils } from '../utils/utils';\nimport { SpeedyGPU } from './speedy-gpu';\nimport { SpeedyDrawableTexture } from './speedy-texture';\nimport { OutOfMemoryError } from '../utils/errors';\n\n// Constants\nconst DEFAULT_CAPACITY = 80;\nconst BUCKET = Symbol('Bucket');\n\n\n/*\n\n=== Heuristics to figure out the capacity of a texture pool ===\n\n1. Decide the maximum amount of VRAM you'd like to use in a pool (say, 64 MB).\n\n2. Figure out the average texture size in your application (say, 640x360 pixels).\n\n3. Figure out the average texture size in bytes (say, 921600 bytes). Each pixel\n   uses 4 bytes (RGBA format).\n\n4. Divide the maximum amount of VRAM by the average texture size in bytes\n   (say, 72). That's the capacity of the pool.\n\nNote that textures are allocated lazily, so VRAM usage is kept to a minimum.\n\nAdapted from: https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices\n\n*/\n\n\n\n/**\n * @typedef {number} TextureBucketIndex index of a bucket in a pool\n */\n\n\n\n/**\n * A bucket\n */\nclass TextureBucket\n{\n    /**\n     * Constructor\n     * @param {SpeedyDrawableTexture} texture managed texture\n     * @param {TextureBucketIndex} index index of this bucket\n     * @param {TextureBucketIndex} next index of the next bucket\n     */\n    constructor(texture, index, next)\n    {\n        /** @type {SpeedyDrawableTexture} managed texture */\n        this.texture = texture;\n\n        /** @type {TextureBucketIndex} index of this bucket */\n        this.index = index;\n\n        /** @type {TextureBucketIndex} index of the next bucket */\n        this.next = next;\n\n        /** @type {boolean} whether the texture is available or not */\n        this.free = true;\n    }\n}\n\n\n\n/**\n * Texture pool\n */\nexport class SpeedyTexturePool\n{\n    /**\n     * Constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} [capacity] number of textures in the pool\n     */\n    constructor(gpu, capacity = DEFAULT_CAPACITY)\n    {\n        Utils.assert(capacity > 0);\n\n        /** @type {TextureBucket[]} buckets */\n        this._bucket = Array.from({ length: capacity }, (_, i) => new TextureBucket(null, i, i - 1));\n\n        /** @type {TextureBucketIndex} index of an available bucket */\n        this._head = capacity - 1;\n\n        /** @type {SpeedyGPU} GPU instance */\n        this._gpu = gpu;\n    }\n\n    /**\n     * Get a texture from the pool\n     * @returns {SpeedyDrawableTexture}\n     */\n    allocate()\n    {\n        if(this._head < 0)\n            throw new OutOfMemoryError(`Exhausted pool (capacity: ${this._bucket.length})`);\n\n        const bucket = this._bucket[this._head];\n        bucket.free = false;\n        this._head = bucket.next;\n\n        if(bucket.texture == null) // lazy instantiation\n            bucket.texture = SpeedyTexturePool._createManagedTexture(this._gpu.gl, bucket);\n\n        return bucket.texture;\n    }\n\n    /**\n     * Put a texture back in the pool\n     * @param {SpeedyDrawableTexture} texture\n     * @returns {null}\n     */\n    free(texture)\n    {\n        const bucket = texture[BUCKET];\n        Utils.assert(bucket !== undefined && !bucket.free, `Unmanaged texture or double free`);\n\n        bucket.next = this._head;\n        bucket.free = true;\n        this._head = bucket.index;\n\n        return null;\n    }\n\n    /**\n     * Release the texture pool\n     * @returns {null}\n     */\n    release()\n    {\n        for(let i = 0; i < this._bucket.length; i++) {\n            if(this._bucket[i].texture != null)\n                this._bucket[i].texture = this._bucket[i].texture.release();\n        }\n\n        return null;\n    }\n\n    /**\n     * Create a texture with a reference to a bucket\n     * @param {WebGL2RenderingContext} gl\n     * @param {TextureBucket} bucket\n     * @returns {SpeedyDrawableTexture}\n     */\n    static _createManagedTexture(gl, bucket)\n    {\n        const texture = new SpeedyDrawableTexture(gl, 1, 1);\n        return Object.defineProperty(texture, BUCKET, {\n            configurable: false,\n            enumerable: false,\n            writable: false,\n            value: bucket\n        });\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-texture-reader.js\n * Reads data from textures\n */\n\nimport { Utils } from '../utils/utils';\nimport { GLUtils } from './gl-utils';\nimport { SpeedyPromise } from '../utils/speedy-promise';\nimport { SpeedyDrawableTexture } from './speedy-texture';\nimport { IllegalArgumentError, IllegalOperationError } from '../utils/errors';\n\n// number of pixel buffer objects\n// used to get a performance boost in gl.readPixels()\n// (1 seems to perform better on mobile, 2 on the PC?)\nconst DEFAULT_NUMBER_OF_BUFFERS = 1; //2;\n\n\n/**\n * Reads data from textures\n */\nexport class SpeedyTextureReader\n{\n    /**\n     * Constructor\n     * @param {number} [numberOfBuffers]\n     */\n    constructor(numberOfBuffers = DEFAULT_NUMBER_OF_BUFFERS)\n    {\n        Utils.assert(numberOfBuffers > 0);\n\n        /** @type {Uint8Array[]} pixel buffers for data transfers (each stores RGBA data) */\n        this._pixelBuffer = (new Array(numberOfBuffers)).fill(null).map(() => new Uint8Array(0));\n\n        /** @type {number[]} for async data transfers (stores buffer indices) */\n        this._consumerQueue = (new Array(numberOfBuffers)).fill(0).map((_, i) => i);\n\n        /** @type {number[]} for async data transfers (stores buffer indices) */\n        this._producerQueue = [];\n    }\n\n    /**\n     * Read pixels from a texture, synchronously.\n     * You may optionally specify a (x,y,width,height) sub-rectangle.\n     * @param {SpeedyDrawableTexture} texture a texture with a FBO\n     * @param {number} [x]\n     * @param {number} [y] \n     * @param {number} [width]\n     * @param {number} [height]\n     * @returns {Uint8Array} pixels in the RGBA format\n     */\n    readPixelsSync(texture, x = 0, y = 0, width = texture.width, height = texture.height)\n    {\n        const gl = texture.gl;\n        const fbo = texture.glFbo;\n\n        // clamp values\n        width = Math.max(0, Math.min(width, texture.width));\n        height = Math.max(0, Math.min(height, texture.height));\n        x = Math.max(0, Math.min(x, texture.width - width));\n        y = Math.max(0, Math.min(y, texture.height - height));\n\n        // buffer allocation\n        const sizeofBuffer = width * height * 4; // 4 bytes per pixel (RGBA)\n        this._reallocate(sizeofBuffer);\n\n        // lost context?\n        if(gl.isContextLost())\n            return this._pixelBuffer[0].subarray(0, sizeofBuffer);\n\n        // read pixels\n        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n        gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, this._pixelBuffer[0]);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n        // done!\n        return this._pixelBuffer[0].subarray(0, sizeofBuffer);\n    }\n\n    /**\n     * Read pixels from a texture, asynchronously, with PBOs.\n     * You may optionally specify a (x,y,width,height) sub-rectangle.\n     * @param {SpeedyDrawableTexture} texture a texture with a FBO\n     * @param {boolean} [useBufferedDownloads] accelerate downloads by returning pixels from the texture of the previous call (useful for streaming)\n     * @param {number} [x]\n     * @param {number} [y] \n     * @param {number} [width]\n     * @param {number} [height]\n     * @returns {SpeedyPromise<Uint8Array>} resolves to an array of pixels in the RGBA format\n     */\n    readPixelsAsync(texture, useBufferedDownloads = false, x = 0, y = 0, width = texture.width, height = texture.height)\n    {\n        const gl = texture.gl;\n        const fbo = texture.glFbo;\n\n        // clamp values\n        width = Math.max(0, Math.min(width, texture.width));\n        height = Math.max(0, Math.min(height, texture.height));\n        x = Math.max(0, Math.min(x, texture.width - width));\n        y = Math.max(0, Math.min(y, texture.height - height));\n\n        // buffer allocation\n        const sizeofBuffer = width * height * 4; // 4 bytes per pixel (RGBA)\n        this._reallocate(sizeofBuffer);\n\n        // lost context?\n        if(gl.isContextLost())\n            return SpeedyPromise.resolve(this._pixelBuffer[0].subarray(0, sizeofBuffer));\n\n        // do not optimize?\n        if(!useBufferedDownloads) {\n            return SpeedyTextureReader._readPixelsViaPBO(gl, this._pixelBuffer[0], fbo, x, y, width, height).then(() =>\n                this._pixelBuffer[0].subarray(0, sizeofBuffer)\n            );\n        }\n\n        // GPU needs to produce data\n        if(this._producerQueue.length > 0) {\n            const nextBufferIndex = this._producerQueue.shift();\n            SpeedyTextureReader._readPixelsViaPBO(gl, this._pixelBuffer[nextBufferIndex], fbo, x, y, width, height).then(() => {\n                this._consumerQueue.push(nextBufferIndex);\n            });\n        }\n        else this._waitForQueueNotEmpty(this._producerQueue).then(() => {\n            const nextBufferIndex = this._producerQueue.shift();\n            SpeedyTextureReader._readPixelsViaPBO(gl, this._pixelBuffer[nextBufferIndex], fbo, x, y, width, height).then(() => {\n                this._consumerQueue.push(nextBufferIndex);\n            });\n        }).turbocharge();\n\n        // CPU needs to consume data\n        if(this._consumerQueue.length > 0) {\n            const readyBufferIndex = this._consumerQueue.shift();\n            return new SpeedyPromise(resolve => {\n                resolve(this._pixelBuffer[readyBufferIndex].subarray(0, sizeofBuffer));\n                this._producerQueue.push(readyBufferIndex); // enqueue AFTER resolve()\n            });\n        }\n        else return new SpeedyPromise(resolve => {\n            this._waitForQueueNotEmpty(this._consumerQueue).then(() => {\n                const readyBufferIndex = this._consumerQueue.shift();\n                resolve(this._pixelBuffer[readyBufferIndex].subarray(0, sizeofBuffer));\n                this._producerQueue.push(readyBufferIndex); // enqueue AFTER resolve()\n            }).turbocharge();\n        });\n    }\n\n    /**\n     * Reallocate the pixel buffers, so that they can hold the required number of bytes\n     * If the pixel buffers already have the required capacity, then nothing is done\n     * @param {number} size in bytes\n     */\n    _reallocate(size)\n    {\n        // no need to reallocate\n        if(size <= this._pixelBuffer[0].byteLength)\n            return;\n\n        // reallocate\n        for(let i = 0; i < this._pixelBuffer.length; i++) {\n            const newBuffer = new Uint8Array(size);\n            newBuffer.set(this._pixelBuffer[i]); // make this optional?\n            this._pixelBuffer[i] = newBuffer;\n        }\n    }\n\n    /**\n     * Wait for a queue to be not empty\n     * @param {Array} queue\n     * @returns {SpeedyPromise<void>}\n     */\n    _waitForQueueNotEmpty(queue)\n    {\n        return new SpeedyPromise(resolve => {\n            (function wait() {\n                if(queue.length > 0)\n                    resolve();\n                else\n                    setTimeout(wait, 0); // Utils.setZeroTimeout may hinder performance (GLUtils already calls it)\n                    //Utils.setZeroTimeout(wait);\n            })();\n        });\n    }\n\n    /**\n     * Read pixels to a Uint8Array, asynchronously, using a Pixel Buffer Object (PBO)\n     * It's assumed that the target texture is in the RGBA8 format\n     * @param {WebGL2RenderingContext} gl\n     * @param {Uint8Array} outputBuffer with size >= width * height * 4\n     * @param {WebGLFramebuffer} fbo\n     * @param {GLint} x\n     * @param {GLint} y\n     * @param {GLsizei} width\n     * @param {GLsizei} height\n     * @returns {SpeedyPromise}\n     */\n    static _readPixelsViaPBO(gl, outputBuffer, fbo, x, y, width, height)\n    {\n        // create temp buffer\n        const pbo = gl.createBuffer();\n\n        // validate outputBuffer\n        if(!(outputBuffer.byteLength >= width * height * 4))\n            throw new IllegalArgumentError(`Can't read pixels: invalid buffer size`);\n\n        // bind the PBO\n        gl.bindBuffer(gl.PIXEL_PACK_BUFFER, pbo);\n        gl.bufferData(gl.PIXEL_PACK_BUFFER, outputBuffer.byteLength, gl.STREAM_READ);\n\n        // read pixels into the PBO\n        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n        gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, 0);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n        // unbind the PBO\n        gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);\n\n        // wait for DMA transfer\n        return GLUtils.getBufferSubDataAsync(gl, pbo,\n            gl.PIXEL_PACK_BUFFER,\n            0,\n            outputBuffer,\n            0,\n            0\n        ).catch(err => {\n            throw new IllegalOperationError(`Can't read pixels`, err);\n        }).finally(() => {\n            gl.deleteBuffer(pbo);\n        });\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-texture-uploader.js\n * A utility that helps uploading data to textures\n */\n\nimport { SpeedyGPU } from './speedy-gpu';\nimport { SpeedyTexture } from './speedy-texture';\nimport { SpeedyMediaSource } from '../core/speedy-media-source';\n\n// Constants\nconst UPLOAD_BUFFER_SIZE = 2; // how many textures we allocate for uploading data\n\n/**\n * A utility that helps uploading data to textures\n */\nexport class SpeedyTextureUploader\n{\n    /**\n     * Constructor\n     * @param {SpeedyGPU} gpu\n     */\n    constructor(gpu)\n    {\n        /** @type {SpeedyGPU} GPU instance */\n        this._gpu = gpu;\n\n        /** @type {SpeedyTexture[]} upload textures (lazy instantiation) */\n        this._texture = (new Array(UPLOAD_BUFFER_SIZE)).fill(null);\n\n        /** @type {number} index of the texture that was just uploaded to the GPU */\n        this._textureIndex = 0;\n    }\n\n    /**\n     * Upload an image to the GPU\n     * @param {SpeedyMediaSource} source\n     * @param {SpeedyTexture} [outputTexture]\n     * @returns {SpeedyTexture} an internal texture if an output texture is not provided\n     */\n    upload(source, outputTexture = null)\n    {\n        const gl = this._gpu.gl;\n        const data = source.data;\n\n        // create upload textures lazily\n        if(outputTexture == null && this._texture[0] == null) {\n            for(let i = 0; i < this._texture.length; i++)\n                this._texture[i] = new SpeedyTexture(gl, source.width, source.height);\n        }\n\n        // bugfix: if the media is a video, we can't really\n        // upload it to the GPU unless it's ready\n        if(data.constructor.name == 'HTMLVideoElement') {\n            if(data.readyState < 2) {\n                // this may happen when the video loops (Firefox)\n                // return the previously uploaded texture\n                //Utils.warning(`Trying to process a video that isn't ready yet`);\n                return outputTexture || this._texture[this._textureIndex];\n            }\n        }\n\n        // upload to the output texture, if one is provided\n        if(outputTexture != null)\n            return outputTexture.upload(data, source.width, source.height);\n\n        // use round-robin to mitigate WebGL's implicit synchronization\n        // and maybe minimize texture upload times\n        this._textureIndex = (this._textureIndex + 1) % UPLOAD_BUFFER_SIZE;\n\n        // upload to an internal texture\n        return this._texture[this._textureIndex].upload(data, source.width, source.height);\n    }\n\n    /**\n     * Release the texture uploader\n     * @returns {null}\n     */\n    release()\n    {\n        for(let i = 0; i < this._texture.length; i++) {\n            if(this._texture[i] != null)\n                this._texture[i] = this._texture[i].release();\n        }\n\n        return null;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-texture.js\n * A wrapper around WebGLTexture\n */\n\nimport { SpeedyGPU } from './speedy-gpu';\nimport { Utils } from '../utils/utils';\nimport { IllegalOperationError, GLError } from '../utils/errors';\nimport { PYRAMID_MAX_LEVELS } from '../utils/globals';\n\n/**\n * Get a buffer filled with zeros\n * @param {number} size number of bytes\n * @returns {Uint8Array}\n */\n/*\nconst zeros = (function() {\n    let buffer = new Uint8Array(4);\n\n    return function(size) {\n        if(size > buffer.length)\n            buffer = new Uint8Array(size);\n\n        return buffer.subarray(0, size);\n    }\n})();\n*/\n\n/**\n * A wrapper around WebGLTexture\n */\nexport class SpeedyTexture\n{\n    /**\n     * Constructor\n     * @param {WebGL2RenderingContext} gl\n     * @param {number} width texture width in pixels\n     * @param {number} height texture height in pixels\n     */\n    constructor(gl, width, height)\n    {\n        /** @type {WebGL2RenderingContext} */\n        this._gl = gl;\n\n        /** @type {number} width of the texture */\n        this._width = Math.max(1, width | 0);\n\n        /** @type {number} height of the texture */\n        this._height = Math.max(1, height | 0);\n\n        /** @type {WebGLTexture} internal texture object */\n        this._glTexture = SpeedyTexture._createTexture(this._gl, this._width, this._height);\n\n        /** @type {boolean} have we generated mipmaps for this texture? */\n        this._hasMipmaps = false;\n    }\n\n    /**\n     * Releases the texture\n     * @returns {null}\n     */\n    release()\n    {\n        const gl = this._gl;\n\n        // already released?\n        if(this._glTexture == null)\n            throw new IllegalOperationError(`The SpeedyTexture has already been released`);\n\n        // release resources\n        this.discardMipmaps();\n        gl.deleteTexture(this._glTexture);\n        this._glTexture = null;\n        this._width = this._height = 0;\n\n        // done!\n        return null;\n    }\n\n    /**\n     * Upload pixel data to the texture. The texture will be resized if needed.\n     * @param {number} [width] in pixels\n     * @param {number} [height] in pixels\n     * @param {ImageBitmap|ImageData|ArrayBufferView|HTMLImageElement|HTMLVideoElement|HTMLCanvasElement} pixels \n     * @return {SpeedyTexture} this\n     */\n    upload(pixels, width = this._width, height = this._height)\n    {\n        Utils.assert(width > 0 && height > 0);\n\n        this.discardMipmaps();\n        this._width = width;\n        this._height = height;\n\n        SpeedyTexture._upload(this._gl, this._glTexture, width, height, pixels, 0);\n        return this;\n    }\n\n    /**\n     * Clear the texture\n     * @returns {SpeedyTexture} this texture\n     */\n    clear()\n    {\n        const gl = this._gl;\n\n        // context loss?\n        if(gl.isContextLost())\n            return this;\n\n        // clear texture data\n        gl.bindTexture(gl.TEXTURE_2D, this._glTexture);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA8, this._width, this._height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n        gl.bindTexture(gl.TEXTURE_2D, null);\n\n        // no mipmaps\n        this.discardMipmaps();\n\n        // done!\n        return this;\n    }\n\n    /**\n     * Resize this texture. Its content will be lost!\n     * @param {number} width new width, in pixels\n     * @param {number} height new height, in pixels\n     * @returns {SpeedyTexture} this texture\n     */\n    resize(width, height)\n    {\n        const gl = this._gl;\n\n        // no need to resize?\n        if(this._width === width && this._height === height)\n            return this;\n\n        // validate size\n        width |= 0; height |= 0;\n        Utils.assert(width > 0 && height > 0);\n\n        // context loss?\n        if(gl.isContextLost())\n            return this;\n\n        // update dimensions\n        this._width = width;\n        this._height = height;\n\n        // resize\n        // Note: this is fast on Chrome, but seems slow on Firefox\n        gl.bindTexture(gl.TEXTURE_2D, this._glTexture);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA8, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n        gl.bindTexture(gl.TEXTURE_2D, null);\n\n        // no mipmaps\n        this.discardMipmaps();\n\n        // done!\n        return this;\n    }\n\n    /**\n     * Generate mipmap\n     * @param {SpeedyDrawableTexture[]} [mipmap] custom texture for each mip level\n     * @returns {SpeedyTexture} this\n     */\n    generateMipmaps(mipmap = [])\n    {\n        const gl = this._gl;\n\n        // nothing to do\n        if(this._hasMipmaps)\n            return this;\n\n        // let the hardware compute the all levels of the pyramid, up to 1x1\n        // we also specify the TEXTURE_MIN_FILTER to be used from now on\n        gl.bindTexture(gl.TEXTURE_2D, this._glTexture);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_LINEAR);\n        gl.generateMipmap(gl.TEXTURE_2D);\n        gl.bindTexture(gl.TEXTURE_2D, null);\n\n        // accept custom textures\n        if(mipmap.length > 0) {\n            const width = this.width, height = this.height;\n\n            // expect number of mipmap images according to the OpenGL ES 3.0 spec (sec 3.8.10.4)\n            const numMipmaps = 1 + Math.floor(Math.log2(Math.max(width, height)));\n            Utils.assert(mipmap.length <= numMipmaps);\n\n            // verify the dimensions of each level\n            for(let level = 1; level < mipmap.length; level++) {\n                // use max(1, floor(size / 2^lod)), in accordance to\n                // the OpenGL ES 3.0 spec sec 3.8.10.4 (Mipmapping)\n                const w = Math.max(1, width >>> level);\n                const h = Math.max(1, height >>> level);\n\n                // verify the dimensions of this level\n                Utils.assert(mipmap[level].width === w && mipmap[level].height === h);\n\n                // copy to mipmap\n                mipmap[level].copyTo(this, level);\n            }\n        }\n\n        // done!\n        this._hasMipmaps = true;\n        return this;\n    }\n\n    /**\n     * Invalidates previously generated mipmap, if any\n     */\n    discardMipmaps()\n    {\n        const gl = this._gl;\n\n        // nothing to do\n        if(!this._hasMipmaps)\n            return;\n\n        // reset the min filter\n        gl.bindTexture(gl.TEXTURE_2D, this._glTexture);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n        gl.bindTexture(gl.TEXTURE_2D, null);\n\n        // done!\n        this._hasMipmaps = false;\n    }\n\n    /**\n     * Does this texture have a mipmap?\n     * @returns {boolean}\n     */\n    hasMipmaps()\n    {\n        return this._hasMipmaps;\n    }\n\n    /**\n     * Has this texture been released?\n     * @returns {boolean}\n     */\n    isReleased()\n    {\n        return this._glTexture == null;\n    }\n\n    /**\n     * The size of this texture, in bytes\n     * @returns {number}\n     */\n    size()\n    {\n        // RGBA8: 32 bits per pixel\n        return 4 * this._width * this._height;\n    }\n\n    /**\n     * The internal WebGLTexture\n     * @returns {WebGLTexture}\n     */\n    get glTexture()\n    {\n        return this._glTexture;\n    }\n\n    /**\n     * The width of the texture, in pixels\n     * @returns {number}\n     */\n    get width()\n    {\n        return this._width;\n    }\n\n    /**\n     * The height of the texture, in pixels\n     * @returns {number}\n     */\n    get height()\n    {\n        return this._height;\n    }\n\n    /**\n     * The WebGL Context\n     * @returns {WebGL2RenderingContext}\n     */\n    get gl()\n    {\n        return this._gl;\n    }\n\n    /**\n     * Create a WebGL texture\n     * @param {WebGL2RenderingContext} gl\n     * @param {number} width in pixels\n     * @param {number} height in pixels\n     * @returns {WebGLTexture}\n     */\n    static _createTexture(gl, width, height)\n    {\n        Utils.assert(width > 0 && height > 0);\n\n        // create & bind texture\n        const texture = gl.createTexture();\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n\n        // setup\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT);\n        //gl.texStorage2D(gl.TEXTURE_2D, 1, gl.RGBA8, width, height);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA8, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n\n        // unbind & return\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        return texture;\n    }\n\n    /**\n     * Upload pixel data to a WebGL texture\n     * @param {WebGL2RenderingContext} gl\n     * @param {WebGLTexture} texture\n     * @param {GLsizei} width texture width\n     * @param {GLsizei} height texture height\n     * @param {ImageBitmap|ImageData|ArrayBufferView|HTMLImageElement|HTMLVideoElement|HTMLCanvasElement} pixels \n     * @param {GLint} [lod] mipmap level-of-detail\n     * @returns {WebGLTexture} texture\n     */\n    static _upload(gl, texture, width, height, pixels, lod = 0)\n    {\n        // Prefer calling _upload() before gl.useProgram() to avoid the\n        // needless switching of GL programs internally. See also:\n        // https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n\n        /*\n        // slower than texImage2D, unlike the spec?\n        gl.texSubImage2D(gl.TEXTURE_2D,     // target\n                         lod,               // mip level\n                         0,                 // x-offset\n                         0,                 // y-offset\n                         width,             // texture width\n                         height,            // texture height\n                         gl.RGBA,           // source format\n                         gl.UNSIGNED_BYTE,  // source type\n                         pixels);           // source data\n        */\n\n        gl.texImage2D(gl.TEXTURE_2D,        // target\n                      lod,                  // mip level\n                      gl.RGBA8,             // internal format\n                      width,              // texture width\n                      height,             // texture height\n                      0,                  // border\n                      gl.RGBA,              // source format\n                      gl.UNSIGNED_BYTE,     // source type\n                      pixels);              // source data\n\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        return texture;\n    }\n}\n\n/**\n * A SpeedyTexture with a framebuffer\n */\nexport class SpeedyDrawableTexture extends SpeedyTexture\n{\n    /**\n     * Constructor\n     * @param {WebGL2RenderingContext} gl\n     * @param {number} width texture width in pixels\n     * @param {number} height texture height in pixels\n     */\n    constructor(gl, width, height)\n    {\n        super(gl, width, height);\n\n        /** @type {WebGLFramebuffer} framebuffer */\n        this._glFbo = SpeedyDrawableTexture._createFramebuffer(gl, this._glTexture);\n    }\n\n    /**\n     * Releases the texture\n     * @returns {null}\n     */\n    release()\n    {\n        const gl = this._gl;\n\n        // already released?\n        if(this._glFbo == null)\n            throw new IllegalOperationError(`The SpeedyDrawableTexture has already been released`);\n\n        // release the framebuffer\n        gl.deleteFramebuffer(this._glFbo);\n        this._glFbo = null;\n\n        // release the SpeedyTexture\n        return super.release();\n    }\n\n    /**\n     * The internal WebGLFramebuffer\n     * @returns {WebGLFramebuffer}\n     */\n    get glFbo()\n    {\n        return this._glFbo;\n    }\n\n    /**\n     * Copy this texture into another\n     * (you may have to discard the mipmaps after calling this function)\n     * @param {SpeedyTexture} texture target texture\n     * @param {number} [lod] level-of-detail of the target texture\n     */\n    copyTo(texture, lod = 0)\n    {\n        const gl = this._gl;\n\n        // context loss?\n        if(gl.isContextLost())\n            return;\n\n        // compute texture size as max(1, floor(size / 2^lod)),\n        // in accordance to the OpenGL ES 3.0 spec sec 3.8.10.4\n        // (Mipmapping)\n        const pot = 1 << (lod |= 0);\n        const expectedWidth = Math.max(1, Math.floor(texture.width / pot));\n        const expectedHeight = Math.max(1, Math.floor(texture.height / pot));\n\n        // validate\n        Utils.assert(this._width === expectedWidth && this._height === expectedHeight);\n\n        // copy to texture\n        SpeedyDrawableTexture._copyToTexture(gl, this._glFbo, texture.glTexture, 0, 0, this._width, this._height, lod);\n    }\n\n    /*\n     **\n     * Clone this texture\n     * @returns {SpeedyDrawableTexture}\n     *\n    drawableClone()\n    {\n        const clone = new SpeedyDrawableTexture(this._gl, this._width, this._height);\n        this.copyTo(clone);\n        return clone;\n    }\n    */\n\n    /**\n     * Clone this texture. Note that the clone doesn't include a framebuffer\n     * @returns {SpeedyTexture} non-drawable\n     */\n    clone()\n    {\n        const clone = new SpeedyTexture(this._gl, this._width, this._height);\n        this.copyTo(clone);\n        return clone;\n    }\n\n    /**\n     * Resize this texture\n     * @param {number} width new width, in pixels\n     * @param {number} height new height, in pixels\n     * @param {boolean} [preserveContent] should we preserve the content of the texture? EXPENSIVE!\n     * @returns {SpeedyDrawableTexture} this texture\n     */\n    /*resize(width, height, preserveContent = false)\n    {\n        const gl = this._gl;\n\n        // no need to preserve the content?\n        if(!preserveContent)\n            return super.resize(width, height);\n\n        // no need to resize?\n        if(this._width === width && this._height === height)\n            return this;\n\n        // validate size\n        width |= 0; height |= 0;\n        Utils.assert(width > 0 && height > 0);\n\n        // context loss?\n        if(gl.isContextLost())\n            return this;\n\n        // allocate new texture\n        const newTexture = SpeedyTexture._createTexture(gl, width, height);\n\n        // initialize the new texture with zeros to avoid a\n        // warning when calling copyTexSubImage2D() on Firefox\n        // this may not be very efficient?\n        SpeedyTexture._upload(gl, newTexture, width, height, zeros(width * height * 4)); // RGBA: 4 bytes per pixel\n\n        // copy the old texture to the new one\n        const oldWidth = this._width, oldHeight = this._height;\n        SpeedyDrawableTexture._copyToTexture(gl, this._glFbo, newTexture, 0, 0, Math.min(width, oldWidth), Math.min(height, oldHeight), 0);\n\n        // bind FBO\n        gl.bindFramebuffer(gl.FRAMEBUFFER, this._glFbo);\n\n        // invalidate old data (is this needed?)\n        gl.invalidateFramebuffer(gl.FRAMEBUFFER, [gl.COLOR_ATTACHMENT0]);\n\n        // attach the new texture to the existing framebuffer\n        gl.framebufferTexture2D(gl.FRAMEBUFFER,         // target\n                                gl.COLOR_ATTACHMENT0,   // color buffer\n                                gl.TEXTURE_2D,          // tex target\n                                newTexture,             // texture\n                                0);                     // mipmap level\n\n        // unbind FBO\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n        // release the old texture and replace it\n        gl.deleteTexture(this._glTexture);\n        this._glTexture = newTexture;\n\n        // update dimensions & discard mipmaps\n        this.discardMipmaps();\n        this._width = width;\n        this._height = height;\n\n        // done!\n        return this;\n    }\n    */\n\n    /**\n     * Clear the texture\n     * @returns {SpeedyDrawableTexture} this texture\n     */\n    clear()\n    {\n        //\n        // When we pass null to texImage2D(), it seems that Firefox\n        // doesn't clear the texture. Instead, it displays this warning:\n        //\n        // \"WebGL warning: drawArraysInstanced:\n        //  Tex image TEXTURE_2D level 0 is incurring lazy initialization.\"\n        //\n        // So here's a workaround:\n        //\n        return this.clearToColor(0, 0, 0, 0);\n    }\n\n    /**\n     * Clear the texture to a color\n     * @param {number} r red component, a value in [0,1]\n     * @param {number} g green component, a value in [0,1]\n     * @param {number} b blue component, a value in [0,1]\n     * @param {number} a alpha component, a value in [0,1]\n     * @returns {SpeedyDrawableTexture} this texture\n     */\n    clearToColor(r, g, b, a)\n    {\n        const gl = this._gl;\n\n        // context loss?\n        if(gl.isContextLost())\n            return this;\n\n        // clamp parameters\n        r = Math.max(0.0, Math.min(+r, 1.0));\n        g = Math.max(0.0, Math.min(+g, 1.0));\n        b = Math.max(0.0, Math.min(+b, 1.0));\n        a = Math.max(0.0, Math.min(+a, 1.0));\n\n        // discard mipmaps, if any\n        this.discardMipmaps();\n\n        // clear the texture\n        gl.bindFramebuffer(gl.FRAMEBUFFER, this._glFbo);\n        gl.viewport(0, 0, this._width, this._height);\n        gl.clearColor(r, g, b, a);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n        // done!\n        return this;\n    }\n\n    /**\n     * Create a FBO associated with an existing texture\n     * @param {WebGL2RenderingContext} gl\n     * @param {WebGLTexture} texture\n     * @returns {WebGLFramebuffer}\n     */\n    static _createFramebuffer(gl, texture)\n    {\n        const fbo = gl.createFramebuffer();\n\n        // setup framebuffer\n        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n        gl.framebufferTexture2D(gl.FRAMEBUFFER,         // target\n                                gl.COLOR_ATTACHMENT0,   // color buffer\n                                gl.TEXTURE_2D,          // tex target\n                                texture,                // texture\n                                0);                     // mipmap level\n\n        // check for errors\n        const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n        if(status != gl.FRAMEBUFFER_COMPLETE) {\n            const error = (() => (([\n                'FRAMEBUFFER_UNSUPPORTED',\n                'FRAMEBUFFER_INCOMPLETE_ATTACHMENT',\n                'FRAMEBUFFER_INCOMPLETE_DIMENSIONS',\n                'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT',\n                'FRAMEBUFFER_INCOMPLETE_MULTISAMPLE'\n            ].filter(err => gl[err] === status))[0] || 'unknown error'))();\n            throw new GLError(`Can't create framebuffer: ${error} (${status})`);\n        }\n\n        // unbind & return\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        return fbo;\n    }\n\n    /**\n     * Copy data from a framebuffer to a texture\n     * @param {WebGL2RenderingContext} gl\n     * @param {WebGLFramebuffer} fbo we'll read the data from this\n     * @param {WebGLTexture} texture destination texture\n     * @param {GLint} x xpos (where to start copying)\n     * @param {GLint} y ypos (where to start copying)\n     * @param {GLsizei} width width of the texture\n     * @param {GLsizei} height height of the texture\n     * @param {GLint} [lod] mipmap level-of-detail\n     * @returns {WebGLTexture} texture\n     */\n    static _copyToTexture(gl, fbo, texture, x, y, width, height, lod = 0)\n    {\n        //gl.activeTexture(gl.TEXTURE0);\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n\n        gl.copyTexSubImage2D(\n            gl.TEXTURE_2D, // target\n            lod, // mipmap level\n            0, // xoffset\n            0, // yoffset\n            x, // xpos (where to start copying)\n            y, // ypos (where to start copying)\n            width, // width of the texture\n            height // height of the texture\n        );\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        gl.bindTexture(gl.TEXTURE_2D, null);\n\n        return texture;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * index.js\n * The entry point of the library\n */\n\nmodule.exports = require('./core/speedy').Speedy;","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * errors.js\n * Error classes\n */\n\n/**\n * Generic error class for Speedy\n */\nexport class SpeedyError extends Error\n{\n    /**\n     * Class constructor\n     * @param {string} message message text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message, cause = null)\n    {\n        super([\n            message,\n            cause ? cause.toString() : '[speedy-vision.js]'\n        ].join('\\n-> '));\n        this._cause = cause;\n    }\n\n    /**\n     * Error name\n     * @returns {string}\n     */\n    get name()\n    {\n        return this.constructor.name;\n    }\n\n    /**\n     * Set error name (ignored)\n     * @param {string} _ ignored\n     */\n    set name(_)\n    {\n        ;\n    }\n\n    /**\n     * Get the cause of the error. Available if\n     * it has been specified in the constructor\n     * @returns {SpeedyError|null}\n     */\n    get cause()\n    {\n        return this._cause;\n    }\n}\n\n/**\n * Unsupported operation error\n * The requested operation is not supported\n */\nexport class NotSupportedError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Unsupported operation. ${message}`, cause);\n    }\n}\n\n/**\n * Not implemented error\n * The called method is not implemented\n */\nexport class NotImplementedError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Method not implemented. ${message}`, cause);\n    }\n}\n\n/**\n * WebGL error\n */\nexport class GLError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`WebGL error. ${message}`, cause);\n    }\n}\n\n/**\n * AbstractMethodError\n * Thrown when one tries to call an abstract method\n */\nexport class AbstractMethodError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Can't call abstract method. ${message}`, cause);\n    }\n}\n\n/**\n * Illegal argument error\n * A method has received one or more illegal arguments\n */\nexport class IllegalArgumentError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Illegal argument. ${message}`, cause);\n    }\n}\n\n/**\n * Illegal operation error\n * The method arguments are valid, but the method can't\n * be called due to the current the state of the object\n */\nexport class IllegalOperationError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Illegal operation. ${message}`, cause);\n    }\n}\n\n/**\n * Out of memory\n */\nexport class OutOfMemoryError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Out of memory. ${message}`, cause);\n    }\n}\n\n/**\n * File not found error\n */\nexport class FileNotFoundError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`File not found. ${message}`, cause);\n    }\n}\n\n/**\n * Timeout error\n */\nexport class TimeoutError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Timeout error. ${message}`, cause);\n    }\n}\n\n/**\n * Parse error\n */\nexport class ParseError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Parse error. ${message}`, cause);\n    }\n}\n\n/**\n * Assertion error\n */\nexport class AssertionError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Assertion failed. ${message}`, cause);\n    }\n}\n\n/**\n * Access denied\n */\nexport class AccessDeniedError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Access denied. ${message}`, cause);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * fps-counter.js\n * A FPS counter\n */\n\nimport { IllegalOperationError } from './errors';\n\nlet instance = null;\nconst UPDATE_INTERVAL = 500; // in ms\n\nexport class FPSCounter\n{\n    /**\n     * Creates a new FPSCounter\n     */\n    /* private */ constructor()\n    {\n        this._fps = 60;\n        this._frames = 0;\n        this._updateInterval = UPDATE_INTERVAL;\n        this._lastUpdate = performance.now();\n        this._boundUpdate = this._update.bind(this);\n\n        // this should never happen...\n        if(instance !== null)\n            throw new IllegalOperationError(`Can't have multiple instances of FPSCounter`);\n\n        // start FPS counter\n        this._boundUpdate();\n    }\n\n    /**\n     * Gets an instance of the FPS counter.\n     * We use lazy loading, i.e., we will not\n     * create a FPS counter unless we need to!\n     * @returns {FPSCounter}\n     */\n    static get instance()\n    {\n        if(instance === null)\n            instance = new FPSCounter();\n\n        return instance;\n    }\n\n    /**\n     * Get the FPS rate\n     * @returns {number} frames per second\n     */\n    get fps()\n    {\n        return this._fps;\n    }\n\n    /**\n     * Updates the FPS counter\n     */\n    _update()\n    {\n        const now = performance.now();\n        const deltaTime = now - this._lastUpdate;\n\n        if(deltaTime >= this._updateInterval) {\n            this._fps = Math.round(this._frames / (deltaTime * 0.001));\n            this._frames = 0;\n            this._lastUpdate = now;\n        }\n\n        this._frames++;\n        requestAnimationFrame(this._boundUpdate);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * globals.js\n * Global constants\n */\n\n// -----------------------------------------------------------------\n// IMAGE PYRAMIDS & SCALE-SPACE\n// -----------------------------------------------------------------\n\n// The maximum number of levels in a pyramid, considering a scale factor of 2x between levels\nexport const PYRAMID_MAX_LEVELS = 8; // i.e., maximum number of octaves\n\n// The maximum supported scale for a pyramid level\nexport const PYRAMID_MAX_SCALE = 1; // preferably a power of 2 (image scale can go up to this value)\n\n// The base-2 logarithm of PYRAMID_MAX_SCALE\nexport const LOG2_PYRAMID_MAX_SCALE = Math.log2(PYRAMID_MAX_SCALE);\n\n\n\n// -----------------------------------------------------------------\n// FIXED-POINT MATH\n// -----------------------------------------------------------------\n\n// How many bits do we use for storing the fractional data\nexport const FIX_BITS = 4; // MAX_TEXTURE_LENGTH depends on this\n\n// Fixed-point resolution\nexport const FIX_RESOLUTION = 1.0 * (1 << FIX_BITS); // float(2^(FIX_BITS))\n\n\n\n// -----------------------------------------------------------------\n// TEXTURE LIMITS\n// -----------------------------------------------------------------\n\n// Maximum texture length\nexport const MAX_TEXTURE_LENGTH = (1 << (16 - FIX_BITS)) - 2; // 2^n - 2 due to keypoint encoding\n\n\n\n// -----------------------------------------------------------------\n// KEYPOINTS\n// -----------------------------------------------------------------\n\n// Maximum size of a descriptor, in bytes (must be divisible by 4)\nexport const MAX_DESCRIPTOR_SIZE = 64;\n\n// Size of a keypoint header, in bytes (must be divisible by 4)\nexport const MIN_KEYPOINT_SIZE = 8;\n\n// Minimum length of a keypoint encoder, in pixels (encodes at least 1 keypoint)\nexport const MIN_ENCODER_LENGTH = Math.ceil(Math.sqrt(MIN_KEYPOINT_SIZE / 4)); // encodes 2, actually\n\n// Maximum number of keypoints we can encode (the actual length of the encoder may vary)\nexport const MAX_ENCODER_CAPACITY = 8192;\n\n// Initial size of the keypoint encoder\nexport const INITIAL_ENCODER_LENGTH = 32; // pick a small number to reduce processing load and not crash things on mobile\n\n// Flag: no special flags\nexport const KPF_NONE = 0x0;\n\n// Flag: the keypoint is oriented\nexport const KPF_ORIENTED = 0x1;\n\n// Flag: should the keypoint be discarded? (in the next frame)\nexport const KPF_DISCARD = 0x80;\n\n\n\n// -----------------------------------------------------------------\n// MISC\n// -----------------------------------------------------------------\n\n// Are we in a little-endian machine?\nexport const LITTLE_ENDIAN = (function() {\n    return 0xCAFE === (new Uint16Array(new Uint8Array([0xFE, 0xCA]).buffer))[0];\n})();","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * observable.js\n * Observer design pattern\n */\n\n/**\n * Implementation of the Observer design pattern\n * @abstract\n */\nexport class Observable\n{\n    /**\n     * Constructor\n     */\n    constructor()\n    {\n        /** @type {Function[]} subscribers / callbacks */\n        this._subscribers = [];\n    }\n\n    /**\n     * Add subscriber\n     * @param {Function} fn callback\n     */\n    subscribe(fn)\n    {\n        if(this._subscribers.indexOf(fn) < 0)\n            this._subscribers.push(fn);\n    }\n\n    /**\n     * Remove subscriber\n     * @param {Function} fn previously added callback\n     */\n    unsubscribe(fn)\n    {\n        this._subscribers = this._subscribers.filter(subscriber => subscriber !== fn);\n    }\n\n    /**\n     * Notify all subscribers about a state change\n     * @param {any} data generic data\n     * @protected\n     */\n    _notify(data)\n    {\n        for(const fn of this._subscribers)\n            fn(data);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * sorting-networks.js\n * Sorting Networks\n */\n\nimport { AbstractMethodError } from './errors';\n\n/**\n * An abstract Sorting Network\n * @abstract\n */\nclass SortingNetwork\n{\n    /**\n     * Generate a sequence of comparators for a\n     * sorting network supporting n data points\n     * @param {number} n number of data points\n     * @returns {Array<number[2]>}\n     */\n    static generate(n)\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Sort the given data points using this network\n     * @param {Array} data data points\n     * @param {Function} [cmp] comparator function, as in Array.prototype.sort()\n     * @returns {Array} sorted data\n     */\n    static sort(data, cmp = ((a, b) => (+a) - (+b)))\n    {\n        const network = this.generate(data.length);\n\n        for(const [a, b] of network) {\n            if(cmp(data[a], data[b]) > 0)\n                [ data[a], data[b] ] = [ data[b], data[a] ];\n        }\n\n        return data;\n    }\n}\n\n/**\n * An implementation of Batcher's Odd-Even Mergesort\n */\nexport class OddEvenMergesort extends SortingNetwork\n{\n    /*\n\n    A reference for this algorithm can be found at:\n    https://www.inf.hs-flensburg.de/lang/algorithmen/sortieren/networks/oemen.htm\n\n    The algorithm will work if the size of the input array is a power of 2. In\n    order to extend the algorithm so that it works with arrays of any size - say\n    it's n - we use a very simple idea: extend the input array so that its size\n    becomes a power of 2. Set the new entries to infinity. Sort the extended\n    array and return its first n elements.\n\n    Any comparator [i,j] where j >= n is comparing some value with infinity,\n    meaning that no exchange will need to take place. Therefore, [i,j] can be\n    dropped from the network.\n\n    */\n\n    /**\n     * Generate a sequence of comparators for a\n     * sorting network supporting n data points\n     * @param {number} n number of data points\n     * @returns {Array<number[2]>}\n     */\n    static generate(n)\n    {\n        const nextPot = 1 << Math.ceil(Math.log2(Math.max(n, 1)));\n        return this._mergesort(n, [], 0, nextPot);\n    }\n\n    /**\n     * Odd-Even Mergesort\n     * @param {number} count number of data points\n     * @param {Array<number[2]>} net sorting network\n     * @param {number} lo starting index\n     * @param {number} n sequence length, a power of 2\n     * @returns {Array<number[2]>} net\n     */\n    static _mergesort(count, net, lo, n)\n    {\n        if(n > 1) {\n            const m = n / 2;\n\n            this._mergesort(count, net, lo, m);\n            this._mergesort(count, net, lo + m, m);\n            this._merge(count, net, lo, n, 1);\n        }\n\n        return net;\n    }\n\n    /**\n     * Odd-Even Merge\n     * @param {number} count number of data points\n     * @param {Array<number[2]>} net sorting network\n     * @param {number} lo starting index\n     * @param {number} n a power of 2\n     * @param {number} jmp a power of 2\n     */\n    static _merge(count, net, lo, n, jmp)\n    {\n        const dbljmp = jmp * 2;\n\n        if(dbljmp < n) {\n            this._merge(count, net, lo, n, dbljmp); // merge even subsequence\n            this._merge(count, net, lo + jmp, n, dbljmp); // merge odd subsequence\n\n            for(let i = lo + jmp; i + jmp < lo + n && i + jmp < count; i += dbljmp)\n                net.push([i, i + jmp]);\n        }\n        else if(lo + jmp < count)\n            net.push([lo, lo + jmp]);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-promise.js\n * Speedy Promises: a fast implementation of Promises\n */\n\nconst PENDING = 0;\nconst FULFILLED = 1;\nconst REJECTED = 2;\n\nconst SUSPEND_ASYNC = 1;\nconst asap = (typeof queueMicrotask !== 'undefined' && queueMicrotask) || // browsers\n             (typeof process !== 'undefined' && process.nextTick) || // node.js\n             (f => Promise.resolve().then(f)); // most compatible\n\n/**\n * SpeedyPromise: Super Fast Promises. SpeedyPromises can\n * interoperate with ES6 Promises. This implementation is\n * based on the Promises/A+ specification.\n * @template\n */\nexport class SpeedyPromise\n{\n    /**\n     * Constructor\n     * @param {Function} callback\n     */\n    constructor(callback)\n    {\n        this._state = PENDING;\n        this._value = undefined;\n\n        this._onFulfillment = null;\n        this._onRejection = null;\n        this._children = 0;\n        this[0] = this;\n        this._parent = undefined;\n        this._flags = 0;\n\n        this._fulfill = this._fulfill.bind(this);\n        this._reject = this._reject.bind(this);\n        this._resolve = this._resolve.bind(this);\n        this._broadcastIfAsync = this._broadcastIfAsync.bind(this);\n\n        callback(this._fulfill, this._reject);\n    }\n\n    /**\n     * Setup handlers\n     * @param {Function} onFulfillment called when the SpeedyPromise is fulfilled\n     * @param {Function} [onRejection] called when the SpeedyPromise is rejected\n     * @returns {SpeedyPromise}\n     */\n    then(onFulfillment, onRejection = null)\n    {\n        const child = new SpeedyPromise(this._nop);\n        child._onFulfillment = typeof onFulfillment === 'function' && onFulfillment;\n        child._onRejection = typeof onRejection === 'function' && onRejection;\n        child._parent = this;\n\n        this[this._children++] = child; // attach child\n        this._flags &= ~SUSPEND_ASYNC; // restore the async behavior\n        this._notify();\n\n        return child;\n    }\n\n    /**\n     * Setup rejection handler\n     * @param {Function} onRejection called when the SpeedyPromise is rejected\n     * @returns {SpeedyPromise}\n     */\n    catch(onRejection)\n    {\n        return this.then(null, onRejection);\n    }\n\n    /**\n     * Execute a callback when the promise is settled\n     * (i.e., fulfilled or rejected)\n     * @param {Function} onFinally\n     * @returns {SpeedyPromise}\n     */\n    finally(onFinally)\n    {\n        const fn = val => { onFinally(); return val; };\n        return this.then(fn, fn);\n    }\n\n    /**\n     * Start the computation immediately, synchronously.\n     * Can't afford to spend any time at all waiting for micro-tasks, etc.\n     * @returns {SpeedyPromise} this\n     */\n    turbocharge()\n    {\n        let my = this;\n\n        // suspend the async behavior\n        this._flags |= SUSPEND_ASYNC;\n        while(my._parent !== undefined) {\n            my = my._parent;\n            my._flags |= SUSPEND_ASYNC;\n        }\n\n        // notify the children of the root\n        my._notify(); // will be synchronous\n\n        // return this SpeedyPromise\n        return this;\n    }\n\n    /**\n     * Convert to string\n     * @returns {string}\n     */\n    toString()\n    {\n        switch(this._state) {\n            case PENDING:\n                return `SpeedyPromise { <pending> }`;\n            case FULFILLED:\n                return `SpeedyPromise { <fulfilled> ${this._value} }`;\n            case REJECTED:\n                return `SpeedyPromise { <rejected> ${this._value} }`;\n            default:\n                return '';\n        }\n    }\n\n    /**\n     * Creates a resolved SpeedyPromise\n     * @param {any} value\n     * @returns {SpeedyPromise}\n     */\n    static resolve(value)\n    {\n        const promise = new SpeedyPromise(this._snop);\n\n        if((typeof value === 'object' && value !== null && 'then' in value) || (typeof value === 'function' && 'then' in value)) {\n            // resolve asynchronously\n            promise._resolve(value);\n        }\n        else {\n            // fulfill synchronously\n            promise._value = value;\n            promise._state = FULFILLED;\n        }\n\n        return promise;\n    }\n\n    /**\n     * Creates a rejected SpeedyPromise\n     * @param {any} reason usually an instance of Error\n     * @returns {SpeedyPromise}\n     */\n    static reject(reason)\n    {\n        const promise = new SpeedyPromise(this._snop);\n        promise._value = reason;\n        promise._state = REJECTED;\n        return promise;\n    }\n\n    /**\n     * Returns a SpeedyPromise that resolves to an array\n     * containing the results of the input promises/values,\n     * in their given order. The returned SpeedyPromise will\n     * resolve if all input promises resolve, or reject if\n     * any input promise rejects.\n     * @param {iterable} iterable e.g., a SpeedyPromise[]\n     * @returns {SpeedyPromise}\n     */\n    static all(iterable)\n    {\n        return new SpeedyPromise((resolve, reject) => {\n            const input = [];\n\n            // get elements\n            for(const element of iterable)\n                input.push(element);\n\n            // resolve synchronously if there are no elements\n            const length = input.length;\n            if(length == 0) {\n                resolve([]);\n                return;\n            }\n\n            // resolve asynchronously\n            let counter = length;\n            const output = new Array(length);\n            const partialResolve = i => (val => { output[i] = val; if(0 == --counter) resolve(output); });\n            for(let i = 0; i < length; i++) {\n                const element = input[i];\n                if(element.__proto__ === SpeedyPromise.prototype || element.__proto__ === Promise.prototype)\n                    element.then(partialResolve(i), reject);\n                else\n                    SpeedyPromise.resolve(element).then(partialResolve(i), reject);\n            }\n        });\n    }\n\n    /**\n     * Returns a promise that gets fulfilled or rejected as soon\n     * as the first promise in the iterable gets fulfilled or\n     * rejected (with its value/reason).\n     * @param {iterable} iterable e.g., a SpeedyPromise[]\n     * @returns {SpeedyPromise}\n     */\n    static race(iterable)\n    {\n        return new SpeedyPromise((resolve, reject) => {\n            const input = [];\n\n            // get elements\n            for(const element of iterable)\n                input.push(element);\n\n            // if the iterable is empty, the promise\n            // will be pending forever...\n\n            // resolve asynchronously\n            const length = input.length;\n            for(let i = 0; i < length; i++) {\n                const element = input[i];\n                if(element.__proto__ === SpeedyPromise.prototype || element.__proto__ === Promise.prototype)\n                    element.then(resolve, reject);\n                else\n                    SpeedyPromise.resolve(element).then(resolve, reject);\n            }\n        });\n    }\n\n    /**\n     * Fulfill this promise with a value\n     * @param {any} value\n     */\n    _fulfill(value)\n    {\n        this._setState(FULFILLED, value);\n    }\n\n    /**\n     * Reject this promise with a reason\n     * @param {any} reason\n     */\n    _reject(reason)\n    {\n        this._setState(REJECTED, reason);\n    }\n\n    /**\n     * Set the state and the value of this promise\n     * @param {number} state\n     * @param {any} value\n     */\n    _setState(state, value)\n    {\n        // the promise is already fulfilled or rejected\n        if(this._state != PENDING)\n            return;\n\n        // set the new state\n        this._state = state;\n        this._value = value;\n        this._notify();\n    }\n\n    /**\n     * Notify my children that this promise is no\n     * longer pending. This is an async operation:\n     * my childen will be notified \"as soon\n     * as possible\" (it will be scheduled).\n     * We may force this to be synchronous, though\n     */\n    _notify()\n    {\n        // nothing to do\n        if(this._state == PENDING)\n            return;\n\n        // have we turbocharged this promise?\n        if(this._flags & SUSPEND_ASYNC) {\n            this._broadcast(); // execute synchronously\n            return;\n        }\n\n        // install a timer (default behavior)\n        asap(this._broadcastIfAsync);\n    }\n\n    /**\n     * Helper method\n     */\n    _broadcastIfAsync()\n    {\n        // we may have installed a timer at some\n        // point, but turbocharged the promise later\n        if(!(this._flags & SUSPEND_ASYNC))\n            this._broadcast();\n    }\n\n    /**\n     * Tell my children that this promise\n     * is either fulfilled or rejected.\n     * This is a synchronous operation\n     */\n    _broadcast()\n    {\n        const children = this._children;\n        const state = this._state;\n\n        if(state === FULFILLED) {\n            for(let i = 0; i < children; i++) {\n                const child = this[i];\n                const callback = child._onFulfillment;\n\n                try {\n                    if(callback) {\n                        if(callback !== child._nop) {\n                            child._resolve(callback(this._value)); // promise resolution procedure\n                            child._onFulfillment = child._nop; // will not be called again\n                        }\n                    }\n                    else\n                        child._fulfill(this._value);\n                }\n                catch(e) {\n                    child._reject(e);\n                }\n            }\n        }\n        else if(state === REJECTED) {\n            for(let i = 0; i < children; i++) {\n                const child = this[i];\n                const callback = child._onRejection;\n\n                try {\n                    if(callback) {\n                        if(callback !== child._nop) {\n                            child._resolve(callback(this._value)); // promise resolution procedure\n                            child._onRejection = child._nop; // will not be called again\n                        }\n                    }\n                    else\n                        child._reject(this._value);\n                }\n                catch(e) {\n                    child._reject(e);\n                }\n            }\n        }\n    }\n\n    /**\n     * Promise Resolution Procedure\n     * based on the Promises/A+ spec\n     * @param {any} x\n     */\n    _resolve(x)\n    {\n        if((typeof x !== 'object' && typeof x !== 'function') || (x === null)) { // if(x !== Object(x))\n            this._fulfill(x);\n            return;\n        }\n\n        if(x === this)\n            throw new TypeError(); // Circular reference\n\n        if(x.__proto__ === SpeedyPromise.prototype || x.__proto__ === Promise.prototype) {\n            x.then(this._resolve, this._reject);\n            return;\n        }\n\n        try {\n            const then = x.then;\n            if(typeof then === 'function') {\n                let resolve = this._resolve, reject = this._reject;\n                try {\n                    then.call(x,\n                        y => { resolve(y); resolve = reject = this._nop; },\n                        r => { reject(r); resolve = reject = this._nop; }\n                    );\n                }\n                catch(e) {\n                    if(resolve !== this._nop && reject !== this._nop)\n                        this._reject(e);\n                }\n            }\n            else {\n                this._fulfill(x);\n            }\n        }\n        catch(e) {\n            this._reject(e);\n        }\n    }\n\n    /**\n     * No-operation\n     */\n    _nop()\n    {\n    }\n\n    /**\n     * Static no-operation\n     */\n    static _snop()\n    {\n    }\n}\n\n//module.exports = { SpeedyPromise };\n\n/*\n// Uncomment to test performance with regular Promises\nmodule.exports = { SpeedyPromise: Promise };\nPromise.prototype.turbocharge = function() { return this };\n*/","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * types.js\n * Types & formats\n */\n\nimport { Utils } from './utils';\n\n/**\n * Media types\n * @enum {MediaType}\n */\nexport const MediaType = Utils.enum(\n    'Image',\n    'Video',\n    'Canvas',\n    'Bitmap'\n);\n\n/**\n * Image formats\n * @enum {number}\n */\nexport const ImageFormat = Object.freeze({\n    RGBA: 0,\n    GREY: 1,\n});\n\n/**\n * Color formats\n * @enum\n */\nexport const ColorFormat = Utils.enum(\n    'RGB',\n    'Greyscale',\n    'Binary'\n);\n\n/**\n * Pixel component (bitwise flags)\n * @typedef {number} PixelComponent\n */\nexport const PixelComponent = Object.freeze({\n    RED:   1,\n    GREEN: 2,\n    BLUE:  4,\n    ALPHA: 8,\n    ALL:   15 // = RED | GREEN | BLUE | ALPHA\n});\n\n/**\n * Component ID utility\n */\nexport const ColorComponentId = Object.freeze({\n    [PixelComponent.RED]:   0,\n    [PixelComponent.GREEN]: 1,\n    [PixelComponent.BLUE]:  2,\n    [PixelComponent.ALPHA]: 3\n});","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * utils.js\n * Generic utilities\n */\n\nimport { IllegalArgumentError, ParseError, AssertionError, AccessDeniedError, NotSupportedError } from './errors'\nimport { SpeedyPromise } from './speedy-promise';\n\n/**\n * Generic utilities\n */\nexport class Utils\n{\n    /**\n     * Generates a warning\n     * @param {string} text message text\n     * @param  {...string} [args] optional text\n     * @returns {string} the message text\n     */\n    static warning(text, ...args)\n    {\n        const message = [ text, ...args ].join(' ');\n        console.warn('[speedy-vision.js]', message);\n        return message;\n    }\n\n    /**\n     * Logs a message\n     * @param {string} text message text\n     * @param  {...string} [args] optional text\n     * @returns {string} the message text\n     */\n    static log(text, ...args)\n    {\n        const message = [ text, ...args ].join(' ');\n        if(__SPEEDY_DEVELOPMENT_MODE__)\n            console.log('[speedy-vision.js]', message);\n        return message;\n    }\n\n    /**\n     * Assertion\n     * @param {boolean} expr expression\n     * @param {string} [text] error message\n     * @throws {AssertionError}\n     */\n    static assert(expr, text = '')\n    {\n        if(!expr)\n            throw new AssertionError(text);\n    }\n\n    /**\n     * Generates an enumeration\n     * @param {...string} values enumeration options\n     * @returns {object} enum object\n     */\n    static enum(...values)\n    {\n        return Object.freeze(\n            values.reduce((acc, cur) => ((acc[cur] = Symbol(cur)), acc), { })\n        );\n    }\n\n    /**\n     * Similar to setTimeout(fn, 0), but without the ~4ms delay.\n     * Although much faster than setTimeout, this may be resource-hungry\n     * (heavy on battery) if used in a loop. Use with caution.\n     * Implementation based on David Baron's, but adapted for ES6 classes\n     * @param {Function} fn\n     */\n    //static setZeroTimeout(fn) { setTimeout(fn, 0); } // easier on the CPU\n    static setZeroTimeout(fn)\n    {\n        const ctx = (Utils._setZeroTimeoutContext = Utils._setZeroTimeoutContext || (Utils._setZeroTimeoutContext = {\n            callbacks: new Map(),\n            _setup: window.addEventListener('message', ev => {\n                if(ev.source === window) {\n                    const ctx = Utils._setZeroTimeoutContext;\n                    const msgId = ev.data;\n                    const fn = ctx.callbacks.get(msgId);\n                    if(fn !== undefined) {\n                        ev.stopPropagation();\n                        fn.call(window);\n                        ctx.callbacks.delete(msgId);\n                    }\n                }\n            }, true)\n        }));\n\n        const msgId = '0%' + Math.random();\n        ctx.callbacks.set(msgId, fn);\n        window.postMessage(msgId, '*');\n    }\n\n    /**\n     * Gets the names of the arguments of the specified function\n     * @param {Function} fun \n     * @returns {Array<string>}\n     */\n    static functionArguments(fun)\n    {\n        const code = fun.toString();\n        const regex = code.startsWith('function') ? 'function\\\\s.*\\\\(([^)]*)\\\\)' :\n                     (code.startsWith('(') ? '\\\\(([^)]*)\\\\).*=>' : '([^=]+).*=>');\n        const match = new RegExp(regex).exec(code);\n\n        if(match !== null) {\n            const args = match[1].replace(/\\/\\*.*?\\*\\//g, ''); // remove comments\n            return args.split(',').map(argname =>\n                argname.replace(/=.*$/, '').trim() // remove default params & trim\n            ).filter(argname =>\n                argname // handle trailing commas\n            );\n        }\n        else\n            throw new ParseError(`Can't detect function arguments of ${code}`);\n\n        return [];\n    }\n\n    /**\n     * Get all property descriptors from an object,\n     * traversing its entire prototype chain\n     * @param {object} obj \n     * @returns {object}\n     */\n    static getAllPropertyDescriptors(obj)\n    {\n        if(obj) {\n            const proto = Object.getPrototypeOf(obj);\n\n            return {\n                ...(Utils.getAllPropertyDescriptors(proto)),\n                ...Object.getOwnPropertyDescriptors(obj)\n            };\n        }\n        else\n            return Object.create(null);\n    }\n\n    /**\n     * Creates a HTMLCanvasElement with the given dimensions\n     * @param {number} width in pixels\n     * @param {number} height in pixels\n     * @returns {HTMLCanvasElement}\n     */\n    static createCanvas(width, height)\n    {\n        const canvas = document.createElement('canvas');\n        canvas.width = width;\n        canvas.height = height;\n        return canvas;\n    }\n\n    /**\n     * Generates a random number with\n     * Gaussian distribution (mu, sigma)\n     * @param {number} mu mean\n     * @param {number} sigma standard deviation\n     * @returns {number} random number\n     */\n    static gaussianNoise(mu = 0, sigma = 1)\n    {\n        // Box-Muller transformation\n        const TWO_PI = 2.0 * Math.PI;\n        \n        let a, b = Math.random();\n        do { a = Math.random(); } while(a <= Number.EPSILON);\n        let z = Math.sqrt(-2 * Math.log(a)) * Math.sin(TWO_PI * b);\n\n        return z * sigma + mu;\n    }\n\n    /**\n     * Generate a 1D gaussian kernel with custom sigma\n     * Tip: use kernelSize >= (5 * sigma), kernelSize odd\n     * @param {number} sigma gaussian sigma\n     * @param {number} [kernelSize] kernel size, odd number\n     * @param {bool} [normalized] normalize entries so that their sum is 1\n     */\n    static gaussianKernel(sigma, kernelSize = 0, normalized = true)\n    {\n        /*\n         * Let G(x) be a Gaussian function centered at 0 with fixed sigma:\n         *\n         * G(x) = (1 / (sigma * sqrt(2 * pi))) * exp(-(x / (sqrt(2) * sigma))^2)\n         * \n         * In addition, let f(p) be a kernel value at pixel p, -k/2 <= p <= k/2:\n         * \n         * f(p) = \\int_{p - 0.5}^{p + 0.5} G(x) dx (integrate around p)\n         *      = \\int_{0}^{p + 0.5} G(x) dx - \\int_{0}^{p - 0.5} G(x) dx\n         * \n         * Setting a constant c := sqrt(2) * sigma, it follows that:\n         * \n         * f(p) = (1 / 2c) * (erf((p + 0.5) / c) - erf((p - 0.5) / c))\n         */\n\n        // default kernel size\n        if(kernelSize == 0) {\n            kernelSize = Math.ceil(5.0 * sigma) | 0;\n            kernelSize += 1 - (kernelSize % 2);\n        }\n\n        // validate input\n        kernelSize |= 0;\n        if(kernelSize < 1 || kernelSize % 2 == 0)\n            throw new IllegalArgumentError(`Invalid kernel size given to gaussianKernel: ${kernelSize} x 1`);\n        else if(sigma <= 0.0)\n            throw new IllegalArgumentError(`Invalid sigma given to gaussianKernel: ${sigma}`);\n\n        // function erf(x) = -erf(-x) can be approximated numerically. See:\n        // https://en.wikipedia.org/wiki/Error_function#Numerical_approximations\n        const kernel = new Array(kernelSize);\n\n        // set constants\n        const N  =  kernelSize >> 1; // integer (floor, div 2)\n        const c  =  (+sigma) * 1.4142135623730951; // sigma * sqrt(2)\n        const m  =  0.3275911;\n        const a1 =  0.254829592;\n        const a2 = -0.284496736;\n        const a3 =  1.421413741;\n        const a4 = -1.453152027;\n        const a5 =  1.061405429;\n\n        // compute the kernel\n        let sum = 0.0;\n        for(let j = 0; j < kernelSize; j++) {\n            let xa = (j - N + 0.5) / c;\n            let xb = (j - N - 0.5) / c;\n            let sa = 1.0, sb = 1.0;\n\n            if(xa < 0.0) { sa = -1.0; xa = -xa; }\n            if(xb < 0.0) { sb = -1.0; xb = -xb; }\n\n            const ta = 1.0 / (1.0 + m * xa);\n            const tb = 1.0 / (1.0 + m * xb);\n            const pa = ((((a5 * ta + a4) * ta + a3) * ta + a2) * ta + a1) * ta;\n            const pb = ((((a5 * tb + a4) * tb + a3) * tb + a2) * tb + a1) * tb;\n            const ya = 1.0 - pa * Math.exp(-xa * xa);\n            const yb = 1.0 - pb * Math.exp(-xb * xb);\n\n            const erfa = sa * ya;\n            const erfb = sb * yb;\n            const fp = (erfa - erfb) / (2.0 * c);\n\n            kernel[j] = fp;\n            sum += fp;\n        }\n\n        // done!\n        return normalized ? kernel.map(k => k / sum) : kernel;\n    }\n\n    /**\n     * Generate a 2D kernel in column-major format using two separable 1D kernels\n     * @param {number[]} ka 1D kernel\n     * @param {number[]} [kb]\n     * @returns {number[]}\n     */\n    static kernel2d(ka, kb = ka)\n    {\n        const ksize = ka.length;\n        Utils.assert(ka.length == ka.length);\n        Utils.assert(ksize >= 1 && ksize % 2 == 1);\n\n        // compute the outer product ka x kb\n        let kernel2d = new Array(ksize * ksize), k = 0;\n        for(let col = 0; col < ksize; col++) {\n            for(let row = 0; row < ksize; row++)\n                kernel2d[k++] = ka[row] * kb[col];\n        }\n\n        return kernel2d;\n    }\n\n    /**\n     * Cartesian product a x b: [ [ai, bj] for all i, j ]\n     * @param {Array<number>} a\n     * @param {Array<number>} b\n     * @returns {Array<number[2]>}\n     */\n    static cartesian(a, b)\n    {\n        return [].concat(...a.map(a => b.map(b => [a, b])));\n    }\n\n    /**\n     * Symmetric range\n     * @param {number} n non-negative integer\n     * @returns {Array<number>} [ -n, ..., n ]\n     */\n    static symmetricRange(n)\n    {\n        if((n |= 0) < 0)\n            throw new IllegalArgumentError(`Expected a non-negative integer as input`);\n\n        return [...(Array(2*n + 1).keys())].map(x => x - n);\n    }\n\n    /**\n     * Compute the [0, n) range of integers\n     * @param {number} n positive integer\n     * @returns {Array<number>} [ 0, 1, ..., n-1 ]\n     */\n    static range(n)\n    {\n        if((n |= 0) <= 0)\n            throw new IllegalArgumentError(`Expected a positive integer as input`);\n\n        return [...(Array(n).keys())];\n    }\n\n    /**\n     * Request webcam access (WebRTC)\n     * @param {number} width in pixels\n     * @param {number} height in pixels\n     * @param {object} [options] will be passed to navigator.mediaDevices.getUserMedia() \n     * @returns {SpeedyPromise<HTMLVideoElement>}\n     */\n    static requestCameraStream(width, height, options = {})\n    {\n        Utils.log('Accessing the webcam...');\n\n        if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia)\n            throw new NotSupportedError('Unsupported browser: no mediaDevices.getUserMedia()');\n\n        return new SpeedyPromise((resolve, reject) => {\n            navigator.mediaDevices.getUserMedia({\n                audio: false,\n                video: {\n                    width: { ideal: width },\n                    height: { ideal: height },\n                    aspectRatio: width / height,\n                    //resizeMode: 'crop-and-scale',\n                    facingMode: 'environment',\n                    frameRate: 30,\n                },\n                ...options\n            })\n            .then(stream => {\n                const video = document.createElement('video');\n                video.onloadedmetadata = () => {\n                    video.play();\n                    Utils.log('The camera device is turned on!');\n                    resolve(video);\n                };\n                video.srcObject = stream;\n            })\n            .catch(err => {\n                reject(new AccessDeniedError(\n                    `Please give access to the camera and reload the page`,\n                    err\n                ));\n            });\n        });\n    }\n}"],"sourceRoot":""}