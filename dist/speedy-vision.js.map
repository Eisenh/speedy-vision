{"version":3,"sources":["webpack://Speedy/webpack/bootstrap","webpack://Speedy/./src/core/algorithms/brisk.js","webpack://Speedy/./src/core/algorithms/fast.js","webpack://Speedy/./src/core/feature-detector.js","webpack://Speedy/./src/core/pipeline-operations.js","webpack://Speedy/./src/core/speedy-feature.js","webpack://Speedy/./src/core/speedy-media.js","webpack://Speedy/./src/core/speedy-pipeline.js","webpack://Speedy/./src/gpu/gl-utils.js","webpack://Speedy/./src/gpu/gpu-instance.js","webpack://Speedy/./src/gpu/gpu-kernel-group.js","webpack://Speedy/./src/gpu/kernels/colors.js","webpack://Speedy/./src/gpu/kernels/encoders.js","webpack://Speedy/./src/gpu/kernels/filters.js","webpack://Speedy/./src/gpu/kernels/keypoints.js","webpack://Speedy/./src/gpu/kernels/pyramids.js","webpack://Speedy/./src/gpu/kernels/shaders/brisk.js","webpack://Speedy/./src/gpu/kernels/shaders/colors.js","webpack://Speedy/./src/gpu/kernels/shaders/colors/rgb2grey.glsl","webpack://Speedy/./src/gpu/kernels/shaders/convolution.js","webpack://Speedy/./src/gpu/kernels/shaders/encoders.js","webpack://Speedy/./src/gpu/kernels/shaders/encoders/encode-keypoint-offsets.glsl","webpack://Speedy/./src/gpu/kernels/shaders/encoders/encode-keypoints.glsl","webpack://Speedy/./src/gpu/kernels/shaders/fast.js","webpack://Speedy/./src/gpu/kernels/shaders/includes sync ^\\.\\/.*$","webpack://Speedy/./src/gpu/kernels/shaders/includes/global.glsl","webpack://Speedy/./src/gpu/kernels/shaders/keypoint-detectors/brisk.glsl","webpack://Speedy/./src/gpu/kernels/shaders/keypoint-detectors/fast-score12.glsl","webpack://Speedy/./src/gpu/kernels/shaders/keypoint-detectors/fast-score16.glsl","webpack://Speedy/./src/gpu/kernels/shaders/keypoint-detectors/fast-score8.glsl","webpack://Speedy/./src/gpu/kernels/shaders/keypoint-detectors/fast-suppression.glsl","webpack://Speedy/./src/gpu/kernels/shaders/keypoint-detectors/fast5.glsl","webpack://Speedy/./src/gpu/kernels/shaders/keypoint-detectors/fast7.glsl","webpack://Speedy/./src/gpu/kernels/shaders/keypoint-detectors/fast9.glsl","webpack://Speedy/./src/gpu/kernels/shaders/keypoint-detectors/fast9ml.glsl","webpack://Speedy/./src/gpu/kernels/shaders/pyramids.js","webpack://Speedy/./src/gpu/kernels/shaders/pyramids/crop.glsl","webpack://Speedy/./src/gpu/kernels/shaders/pyramids/downsample2.glsl","webpack://Speedy/./src/gpu/kernels/shaders/pyramids/downsample3.glsl","webpack://Speedy/./src/gpu/kernels/shaders/pyramids/merge-keypoints-at-consecutive-levels.glsl","webpack://Speedy/./src/gpu/kernels/shaders/pyramids/merge-keypoints.glsl","webpack://Speedy/./src/gpu/kernels/shaders/pyramids/normalize-keypoints.glsl","webpack://Speedy/./src/gpu/kernels/shaders/pyramids/upsample2.glsl","webpack://Speedy/./src/gpu/kernels/shaders/pyramids/upsample3.glsl","webpack://Speedy/./src/gpu/kernels/shaders/utils.js","webpack://Speedy/./src/gpu/kernels/shaders/utils/flip-y.glsl","webpack://Speedy/./src/gpu/kernels/shaders/utils/identity.glsl","webpack://Speedy/./src/gpu/kernels/utils.js","webpack://Speedy/./src/gpu/shader-preprocessor.js","webpack://Speedy/./src/gpu/speedy-gpu-core.js","webpack://Speedy/./src/gpu/speedy-program.js","webpack://Speedy/./src/speedy.js","webpack://Speedy/./src/utils/errors.js","webpack://Speedy/./src/utils/fps-counter.js","webpack://Speedy/./src/utils/tuner.js","webpack://Speedy/./src/utils/types.js","webpack://Speedy/./src/utils/utils.js"],"names":[],"mappings":";;;;;;;;;;;;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0C;;AAE1C;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gEAAgE;AAChE,sBAAsB,oBAAoB;AAC1C;AACA,0EAA0E;AAC1E,sBAAsB,yBAAyB;AAC/C;;AAEA;AACA;AACA;AACA,sBAAsB,2BAA2B;AACjD;AACA;AACA;AACA,sBAAsB,gCAAgC;AACtD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qCAAqC;AAC3D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wDAAwD,QAAQ;AAChE;AACA,6DAA6D,QAAQ;AACrE;AACA;AACA;AACA;;AAEA;AACA,WAAW,KAAsB,EAAE,EAoC1B;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,8BAA8B;;AAE9B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,yBAAyB;AACzB;;AAEA;AACA,SAAS,qBAAqB;AAC9B,SAAS,wBAAwB;AACjC,SAAS,wBAAwB;AACjC,SAAS,wBAAwB;AACjC,SAAS,wBAAwB;AACjC;AACA;;AAEA;AACA;AACA,IAAI,QAAQ;AACZ,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA,WAAW,UAAU;AACrB;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,OAAO;AACzB,sBAAsB,OAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AClRA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0C;;AAE1C;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA,QAAQ,kDAAK;AACb;AACA,qCAAqC,EAAE;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACjFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4C;AACE;AACe;AACtB;;AAEvC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,qBAAqB;AACtC;AACA,oCAAoC;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,wDAAI;AACrC;AACA,iCAAiC,wDAAI;;AAErC;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,wDAAI;AAC9B;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,wDAAI;AACrC;AACA,iCAAiC,wDAAI;;AAErC;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,0DAAK;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA,gBAAgB,6DAAgB,UAAU;AAC1C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;ACrKA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6C;AACN;AACG;;AAEnC,2BAA2B;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,YAAY;AAC3B,eAAe,YAAY;AAC3B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wDAAW;AAC5C;AACA,sCAAsC,wDAAW;AACjD,YAAY,kDAAK;;AAEjB,6BAA6B,wDAAW;AACxC;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,4BAA4B;AAC5B;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,YAAY,kDAAK,+BAA+B,KAAK;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kDAAK,2BAA2B,OAAO;AACnD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,YAAY,kDAAK;AACjB;AACA,YAAY,kDAAK,sDAAsD,IAAI;;AAE3E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,qDAAO;AACnB;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC3LA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,QAAQ,GAAG,QAAQ;AACtC;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AClGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkD;AACK;AACF;AACP;AACP;;AAEvC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,eAAe,4DAA4D;AAC3E,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wDAAW;;AAE3C;AACA,4BAA4B,6DAAW;AACvC,yCAAyC;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,kDAAK;AACjB;;AAEA;AACA;AACA;AACA,eAAe,oDAAoD;AACnE,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kDAAK,kCAAkC,YAAY;AAC3E;AACA;AACA;AACA;AACA;AACA,mCAAmC,yDAAW,kCAAkC,YAAY;AAC5F,iBAAiB;AACjB;AACA;AACA;AACA,2BAA2B,yDAAW,kCAAkC,YAAY;AACpF;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,oDAAoD;AACrE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,iBAAiB,sDAAS;AAC1B;;AAEA,iBAAiB,sDAAS;AAC1B;;AAEA,iBAAiB,sDAAS;AAC1B;;AAEA,iBAAiB,sDAAS;AAC1B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,YAAY;AAC7B;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,eAAe;AAC9B,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA,kCAAkC,oBAAoB;AACtD,sBAAsB,sDAAS;AAC/B;AACA;;AAEA;AACA;AACA,eAAe,kBAAkB;AACjC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA,eAAe;AACf;AACA;;AAEA;AACA,iBAAiB,sDAAS;AAC1B,iBAAiB,sDAAS;AAC1B,iBAAiB,sDAAS;AAC1B;AACA;;AAEA,iBAAiB,sDAAS;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,gCAAgC;AACjD;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,6DAA6D,iEAAe;;AAE5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yDAAW,oBAAoB,OAAO;AACjE,SAAS;AACT;AACA;;AAEA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA,+BAA+B,iDAAiD;AAChF,+BAA+B,6CAA6C;AAC5E,gCAAgC,mCAAmC;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sDAAS;;AAEhC;AACA,uBAAuB,sDAAS;;AAEhC;AACA,uBAAuB,sDAAS;;AAEhC;AACA,uBAAuB,sDAAS;AAChC;AACA;;AAEA,IAAI,kDAAK,sDAAsD,YAAY;AAC3E;AACA;;AAEA;AACA,wDAAwD;AACxD;AACA;AACA,QAAQ,kDAAK;;AAEb;AACA,8BAA8B,yDAAW;;AAEzC;AACA;AACA;AACA,wBAAwB,eAAe;AACvC,yBAAyB,gBAAgB;AACzC,8BAA8B,wBAAwB;AACtD;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gBAAgB,kDAAK;AACrB;AACA;AACA,SAAS;AACT;AACA,uBAAuB,yDAAW;AAClC;AACA,mBAAmB,SAAS,IAAI,YAAY;AAC5C;AACA,SAAS;AACT,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,C;;;;;;;;;;;;AClXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0D;AACf;AACG;AACP;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,wBAAwB;AACzC;AACA;AACA;AACA;AACA,oDAAoD,QAAQ;AAC5D;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,wBAAwB;AACvC,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA,8BAA8B,sDAAS;AACvC;AACA;;AAEA;AACA,8BAA8B,6BAA6B;AAC3D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,yDAAW;AACtC,SAAS;AACT;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,eAAe,eAAe;AAC9B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,kDAAK,4BAA4B,SAAS;AAClD;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,oBAAoB,sEAAiB;AACrC;AACA;;AAEA,QAAQ,kDAAK,iDAAiD,WAAW;AACzE;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA,qBAAqB;AACrB;AACA;AACA,gBAAgB,sEAAiB;AACjC;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,gBAAgB,sEAAiB;AACjC;AACA;AACA,C;;;;;;;;;;;;ACpLA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,aAAa;AAC5B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,aAAa;AAC5B,eAAe,0FAA0F;AACzG,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;;AAEjC;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA,8CAA8C,aAAa,iCAAiC,oCAAoC;;AAEhI,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,aAAa;AAC5B,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,MAAM,IAAI,OAAO;AAC9E;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,iBAAiB;AAChC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACrPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkD;AACX;AACI;AACE;AACE;AACI;AACF;AACA;;AAEjD;AACA,iCAAiC;AACjC;;AAEA;AACA;AACA;AACA,aAAa,uDAAQ;AACrB,cAAc,yDAAS;AACvB,eAAe,2DAAU;AACzB,iBAAiB,+DAAY;AAC7B,gBAAgB,6DAAW;AAC3B,gBAAgB,6DAAW;AAC3B;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kDAAK,iDAAiD,YAAY,KAAK,aAAa;AAChG;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,YAAY,kDAAK,iCAAiC,GAAG;;AAErD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,YAAY,kDAAK,uCAAuC,GAAG;;AAE3D;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,8DAAa;;AAErC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,oBAAoB;AAC1C,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;ACnNA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEsB;AACtB;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,iBAAiB,eAAe;AAChC;AACA,kDAAkD,EAAE;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;;AAET;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb,SAAS;AACT;;AAEA,+CAA+C,EAAE;AACjD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,C;;;;;;;;;;;;ACrJA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqD;AACT;;AAE5C;AACA;AACA;AACA;AACO,wBAAwB,gEAAc;AAC7C;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wDAAQ;AACzC;AACA;AACA,C;;;;;;;;;;;;AC5CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqD;AACuB;AAClB;AACN;AACX;;AAEzC;AACA;AACA,+BAA+B;AAC/B,kDAAkD;AAClD,4DAA4D;AAC5D,+BAA+B;AAC/B;AACA,mCAAmC;AACnC;;;AAGA;AACA;AACA;AACA;AACO,0BAA0B,gEAAc;AAC/C;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,uEAAqB;AACpE,yCAAyC,iEAAe;AACxD;AACA;AACA,aAAa;AACb;;AAEA;AACA,2CAA2C,kDAAK;AAChD,0BAA0B,4DAAe;AACzC;AACA;AACA;AACA;;;;AAIA;AACA;AACA;;;AAGA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA,yFAAyF;AACzF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,mBAAmB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mCAAmC,kEAAa;AAChD;AACA;AACA;AACA;;AAEA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;AC1KA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqD;AACiF;;AAEtI;AACA;AACA;AACA;AACO,yBAAyB,gEAAc;AAC9C;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oCAAoC,sEAAS;AAC7C,mCAAmC,qEAAQ;AAC3C,oCAAoC,sEAAS;AAC7C,mCAAmC,qEAAQ;AAC3C,oCAAoC,sEAAS;AAC7C,mCAAmC,qEAAQ;;AAE3C;AACA;AACA,kCAAkC,qEAAQ;AAC1C,kCAAkC,qEAAQ;AAC1C;AACA,kCAAkC,qEAAQ;AAC1C,kCAAkC,qEAAQ;AAC1C;AACA,kCAAkC,qEAAQ;AAC1C,kCAAkC,qEAAQ;AAC1C;AACA,kCAAkC,qEAAQ;AAC1C,kCAAkC,qEAAQ;AAC1C;AACA,mCAAmC,qEAAQ;AAC3C,mCAAmC,qEAAQ;;AAE3C;AACA,wCAAwC,2EAAc,MAAM;AAC5D;AACA;AACA,aAAa;AACb,wCAAwC,2EAAc,MAAM;AAC5D;AACA;AACA,aAAa;AACb,wCAAwC,2EAAc,MAAM;AAC5D;AACA;AACA,aAAa;AACb,wCAAwC,2EAAc,MAAM;AAC5D;AACA;AACA,aAAa;AACb,wCAAwC,2EAAc,MAAM;AAC5D;AACA;AACA,aAAa;AACb,wCAAwC,2EAAc,MAAM;AAC5D;AACA;AACA,aAAa;AACb,wCAAwC,2EAAc,MAAM;AAC5D;AACA;AACA,aAAa;AACb,yCAAyC,2EAAc,OAAO;AAC9D;AACA;AACA,aAAa;AACb,oDAAoD;AACpD;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;;;;;AAKb;AACA;AACA,iCAAiC,kEAAK;AACtC;AACA;AACA;AACA,iCAAiC,kEAAK;AACtC;AACA;AACA;AACA,iCAAiC,kEAAK;AACtC;AACA;AACA;AACA,iCAAiC,kEAAK;AACtC;AACA;AACA;AACA,iCAAiC,kEAAK;AACtC;AACA;AACA,iCAAiC,kEAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA,+BAA+B,kEAAK;AACpC;AACA;AACA,+BAA+B,kEAAK;AACpC;AACA;AACA,+BAA+B,kEAAK;AACpC;AACA;AACA,+BAA+B,kEAAK;AACpC;AACA;AACA,+BAA+B,kEAAK;AACpC;AACA;AACA,+BAA+B,kEAAK;AACpC;AACA;AACA,+BAA+B,kEAAK;AACpC;AACA;AACA,+BAA+B,kEAAK;AACpC;AACA;AACA,gCAAgC,kEAAK;AACrC;AACA;AACA,gCAAgC,kEAAK;AACrC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjMA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqD;AACyD;AACtE;;AAExC;AACA;AACA;AACA;AACO,2BAA2B,gEAAc;AAChD;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qDAAO;AACtC,qCAAqC,yDAAW;;AAEhD;AACA;AACA,+BAA+B,mDAAK;AACpC,qCAAqC,yDAAW;;AAEhD;AACA;AACA,+BAA+B,mDAAK;AACpC,oCAAoC,wDAAU;;AAE9C;AACA,wCAAwC,6DAAe;;AAEvD;AACA,8BAA8B,oDAAK;AACnC;AACA;AACA;;;;;;;;;;;;;;AC/DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqD;AACb;AACa;AAC+B;AACuB;AAChD;;AAE3D;AACA;AACA;AACA;AACO,0BAA0B,gEAAc;AAC/C;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kEAAQ;;AAExC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uCAAuC,gEAAc;AACrD,0DAA0D,mFAAiC;AAC3F,2CAA2C,oEAAkB;;AAE7D;AACA,6BAA6B,sDAAI;;AAEjC;AACA,+BAA+B,oDAAK;AACpC;AACA;AACA,aAAa;;AAEb,gCAAgC,oDAAK;AACrC;AACA;AACA,aAAa;;AAEb,gCAAgC,oDAAK;AACrC;AACA;AACA,aAAa;;;;AAIb;AACA;AACA;AACA,iCAAiC,kEAAK;AACtC;AACA;AACA,iCAAiC,kEAAK;AACtC;AACA;;AAEA;AACA;AACA,kCAAkC,kEAAK;AACvC;AACA;;AAEA,kCAAkC,kEAAK;AACvC;AACA;;AAEA;AACA;AACA,kCAAkC,kEAAK;AACvC;AACA;;AAEA,kCAAkC,kEAAK;AACvC;AACA;;AAEA;AACA,mCAAmC,2DAAS;AAC5C;;AAEA,qCAAqC,6DAAW;AAChD;;AAEA,mCAAmC,2DAAS;AAC5C;;AAEA,qCAAqC,6DAAW;AAChD;;AAEA,uCAAuC,6DAAW;AAClD;;AAEA,uCAAuC,6DAAW;AAClD;;AAEA;AACA,gCAAgC,+DAAK;AACrC;;AAEA,kCAAkC,+DAAK;AACvC;;AAEA,kCAAkC,+DAAK;AACvC;;AAEA,kCAAkC,+DAAK;AACvC;AACA;AACA;AACA;;;;;;;;;;;;;AChJA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACO,iEAAiE,mBAAO,CAAC,gGAAiC,E;;;;;;;;;;;;AC/BjH;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACO,4BAA4B,mBAAO,CAAC,8EAAwB,E;;;;;;;;;;;ACtBnE,uEAAuE,0BAA0B,gBAAgB,kCAAkC,6BAA6B,8BAA8B,GAAG,C;;;;;;;;;;;;ACAjN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6C;AAC7C,wEAAwE;AACxE,qEAAqE;;AAErE;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ,kDAAK,kEAAkE,MAAM;AACrF;AACA,QAAQ,kDAAK,2CAA2C,gBAAgB;;AAExE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+CAA+C,OAAO,IAAI,OAAO,aAAa,GAAG;AACjF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACO;AACP;AACA;AACA;;AAEA;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ,kDAAK,kEAAkE,MAAM;AACrF;AACA,QAAQ,kDAAK,sDAAsD,KAAK,IAAI;;AAE5E;AACA;AACA;AACA;AACA;AACA,8CAA8C,MAAM,gBAAgB,GAAG;AACvE;AACA,iDAAiD,MAAM,aAAa,GAAG;AACvE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,IAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,OAAO;AAChB;AACA,uBAAuB,KAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,QAAQ,kDAAK,mDAAmD,WAAW;;AAE3E;AACA;AACA,2BAA2B,wBAAwB;;AAEnD;AACA;AACA;AACA,8BAA8B,WAAW;;AAEzC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,QAAQ,kDAAK,mDAAmD,WAAW;;AAE3E;AACA;AACA,2BAA2B,WAAW;;AAEtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA,8BAA8B;AAC9B;AACA,QAAQ,kDAAK,sFAAsF,WAAW;;AAE9G;AACA;AACA;AACA;;AAEA;AACA,4CAA4C,MAAM,IAAI,MAAM;AAC5D;AACA,+CAA+C,EAAE,IAAI,EAAE;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACO;;AAEP;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,QAAQ,kDAAK,sFAAsF,WAAW;AAC9G;AACA,QAAQ,kDAAK,sEAAsE,KAAK,IAAI;;AAE5F;AACA;AACA;AACA,4CAA4C,MAAM;AAClD;AACA,+CAA+C,EAAE;AACjD;AACA,4CAA4C,MAAM;AAClD;AACA,kDAAkD,EAAE;AACpD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA,C;;;;;;;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ACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqC;;AAErC;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,uBAAuB;AAClC,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe,oFAAQ,IAA6B,WAAW,CAAC;;AAEhE,UAAU,iDAAO,iDAAiD,SAAS;AAC3E,C;;;;;;;;;;;;AC/DA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoD;AACZ;AACD;;AAEvC;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,0FAA0F;AACzG,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,kDAAK;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,oDAAO;;AAEzB;AACA;AACA;AACA;AACA,iCAAiC,oDAAO;AACxC;AACA;AACA,YAAY,kDAAK,sCAAsC,MAAM,KAAK,OAAO;AACzE,iCAAiC,oDAAO;AACxC;AACA;;AAEA;AACA;AACA;AACA,QAAQ,oDAAO;AACf;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,iBAAiB,cAAc;AAC/B;AACA,yCAAyC,EAAE;AAC3C;AACA;;AAEA,mBAAmB,gEAAa;AAChC;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,oDAAO;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,cAAc,oDAAO;;AAErB;AACA,C;;;;;;;;;;;;ACnMA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE8D;AACtB;;AAExC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB;AACA,2CAA2C,EAAE;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,4CAA4C,MAAM,KAAK,OAAO;;AAE9D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,YAAY;AAClC,0BAA0B,WAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA,0BAA0B,oDAAO,8CAA8C,UAAU;AACzF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,oDAAO;;AAEzB;AACA;;AAEA;AACA,iCAAiC,iBAAiB;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,QAAQ,GAAG,aAAa;AAC7E,0BAA0B,oDAAO,uDAAuD,QAAQ;AAChG,8BAA8B,+BAA+B,QAAQ,GAAG,EAAE,KAAK;AAC/E;AACA;AACA;AACA,sBAAsB,oDAAO,+CAA+C,QAAQ,KAAK,QAAQ;AACjG;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,oDAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,oDAAO,qBAAqB,MAAM,iCAAiC,oCAAoC;AAC7H;AACA,sBAAsB,oDAAO;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oDAAO,mDAAmD,MAAM;AACtF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,+CAA+C;AAC/C,yCAAyC;AACzC,sBAAsB;;AAEtB;AACA;AACA;AACA,wFAAwF;AACxF;AACA;AACA;AACA;AACA,0BAA0B,oDAAO,gDAAgD,KAAK;AACtF;AACA,8BAA8B,YAAY;AAC1C,gCAAgC,MAAM,GAAG,EAAE,OAAO;AAClD;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oDAAO,6CAA6C,KAAK;;AAEvE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC;AACvC,yDAAyD;AACzD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;;AAEA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;;AAEA;AACA,cAAc;AACd,oFAAoF,EAAE;AACtF;AACA;AACA,mBAAmB,0EAAkB;AACrC,oBAAoB,oDAAO;;AAE3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,oDAAO,gCAAgC,gBAAgB;;AAEzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oDAAO,uCAAuC,MAAM;AAC1E;;AAEA;AACA,YAAY,sCAAsC;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,oDAAO;AAC3B,gBAAgB,oDAAO;;AAEvB;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,QAAQ,oDAAO;AACf;AACA;;AAEA;AACA,QAAQ,oDAAO;AACf;AACA;;AAEA;AACA,C;;;;;;;;;;;;ACziBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkD;AACM;AACP;;AAEjD;AACA;AACA;AACA;AACA,eAAe,oDAAoD;AACnE,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,8DAAW;AAC1B;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA,yDAAyD;AACzD;AACA,eAAe,8DAAW;AAC1B;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,oEAAc;AACjC;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,eAAe,OAAkB;AACjC;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,yBAAyB,QAAQ,6DAAU,cAAc;AACzD;AACA;AACA;;AAEO;AACA;AACA;AACA;AACA,uB;;;;;;;;;;;;ACnFP;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC9CA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgC;AAChC;AACA,4BAA4B;;AAErB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,4CAAK;;AAEjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgC;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,4CAAK,gCAAgC,WAAW;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC,aAAa;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,YAAY,4CAAK,8BAA8B,SAAS,GAAG,SAAS;AACpE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,wBAAwB;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,yBAAyB;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA,sDAAsD;;AAEtD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA,wCAAwC,4CAAK;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,4CAAK,yBAAyB;AACrD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC9vBA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgC;;AAEzB,kBAAkB,4CAAK;AAC9B;AACA;AACA;AACA;AACA;;AAEO,oBAAoB,4CAAK;AAChC;AACA;AACA;AACA,E;;;;;;;;;;;;AClCA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsC;;AAE/B;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,UAAU;AAC1B,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA,kBAAkB,mDAAW;AAC7B;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,UAAU;AAC1B,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,UAAU;AAC1B,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,sBAAsB,mDAAW;AACjC;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,0EAA0E,EAAE;AAC5E;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,mBAAmB,EAAE;AACjC;;AAEA;AACA;AACA,C","file":"speedy-vision.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/speedy.js\");\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * brisk.js\n * Modified BRISK algorithm\n */\n\nimport { Utils } from '../../utils/utils';\n\nlet gaussians = null;\nlet shortPairs = null, longPairs = null;\n\n/**\n * BRISK feature detection\n */\nexport class BRISK\n{\n    /**\n     * BRISK feature detection algorithm\n     * @param {GPUInstance} gpu\n     * @param {Texture} greyscale Greyscale image\n     * @param {object} settings\n     * @returns {Texture} features in a texture\n     */\n    static run(gpu, greyscale, settings)\n    {\n        const MIN_DEPTH = 1, MAX_DEPTH = gpu.pyramidHeight;\n\n        // clamp settings.depth (height of the image pyramid)\n        settings.depth = Math.max(MIN_DEPTH, Math.min(settings.depth, MAX_DEPTH)) | 0;\n\n        // create the pyramid\n        const pyramid = new Array(settings.depth);\n        const intraPyramid = new Array(pyramid.length + 1);\n        pyramid[0] = gpu.pyramid(0).pyramids.setBase(greyscale); // base of the pyramid\n        for(let i = 1; i < pyramid.length; i++)\n            pyramid[i] = gpu.pyramid(i-1).pyramids.reduce(pyramid[i-1]);\n        intraPyramid[0] = gpu.pyramid(0).pyramids.intraExpand(pyramid[0]); // 1.5 * sizeof(base)\n        for(let i = 1; i < intraPyramid.length; i++)\n            intraPyramid[i] = gpu.intraPyramid(i-1).pyramids.reduce(intraPyramid[i-1]);\n\n        // get FAST corners of all pyramid levels\n        const pyramidCorners = new Array(pyramid.length);\n        const intraPyramidCorners = new Array(intraPyramid.length);\n        for(let j = 0; j < pyramidCorners.length; j++) {\n            pyramidCorners[j] = gpu.pyramid(j).keypoints.fast9(pyramid[j], settings.threshold);\n            pyramidCorners[j] = gpu.pyramid(j).keypoints.fastSuppression(pyramidCorners[j]);\n        }\n        for(let j = 0; j < intraPyramidCorners.length; j++) {\n            intraPyramidCorners[j] = gpu.intraPyramid(j).keypoints.fast9(intraPyramid[j], settings.threshold);\n            intraPyramidCorners[j] = gpu.intraPyramid(j).keypoints.fastSuppression(intraPyramidCorners[j]);\n        }\n\n        // scale space non-maximum suppression & interpolation\n        const lgM = Math.log2(gpu.pyramidMaxScale), h = gpu.pyramidHeight;\n        const suppressedPyramidCorners = new Array(pyramidCorners.length);\n        const suppressedIntraPyramidCorners = new Array(intraPyramidCorners.length);\n        suppressedIntraPyramidCorners[0] = gpu.intraPyramid(0).keypoints.brisk(intraPyramidCorners[0], intraPyramidCorners[0], pyramidCorners[0], 1.0, 2.0 / 3.0, lgM, h);\n        for(let j = 0; j < suppressedPyramidCorners.length; j++) {\n            suppressedPyramidCorners[j] = gpu.pyramid(j).keypoints.brisk(pyramidCorners[j], intraPyramidCorners[j], intraPyramidCorners[j+1], 1.5, 0.75, lgM, h);\n            if(j+1 < suppressedPyramidCorners.length)\n                suppressedIntraPyramidCorners[j+1] = gpu.intraPyramid(j+1).keypoints.brisk(intraPyramidCorners[j+1], pyramidCorners[j], pyramidCorners[j+1], 4.0 / 3.0, 2.0 / 3.0, lgM, h);\n            else\n                suppressedIntraPyramidCorners[j+1] = gpu.intraPyramid(j+1).keypoints.brisk(intraPyramidCorners[j+1], pyramidCorners[j], intraPyramidCorners[j+1], 4.0 / 3.0, 1.0, lgM, h);\n        }\n\n        // merge all keypoints\n        for(let j = suppressedPyramidCorners.length - 2; j >= 0; j--)\n            suppressedPyramidCorners[j] = gpu.pyramid(j).pyramids.mergeKeypointsAtConsecutiveLevels(suppressedPyramidCorners[j], suppressedPyramidCorners[j+1]);\n        for(let j = suppressedIntraPyramidCorners.length - 2; j >= 0; j--)\n            suppressedIntraPyramidCorners[j] = gpu.intraPyramid(j).pyramids.mergeKeypointsAtConsecutiveLevels(suppressedIntraPyramidCorners[j], suppressedIntraPyramidCorners[j+1]);\n        suppressedIntraPyramidCorners[0] = gpu.intraPyramid(0).pyramids.normalizeKeypoints(suppressedIntraPyramidCorners[0], 1.5);\n        suppressedIntraPyramidCorners[0] = gpu.pyramid(0).pyramids.crop(suppressedIntraPyramidCorners[0]);\n        const keypoints = gpu.pyramid(0).pyramids.mergeKeypoints(suppressedPyramidCorners[0], suppressedIntraPyramidCorners[0]);\n\n        // create gaussian kernels for different scales and radii\n        if(0 && gaussians == null) {\n            // work with scales: sqrt(2), 1, 1/sqrt(2), 1/2, ...\n            const quantizedScales = [...Array(pyramid.length + intraPyramid.length).keys()]\n                .map(i => Math.pow(2.0, 0.5 * (1 - i))); // i == 1 - 2 * log2(v[i])\n\n            // for each scale, a brisk pattern produces 5 layers with different radii\n            const scaledPatterns = quantizedScales.map(briskPattern);\n            Utils.assert(\n                scaledPatterns[0].length == 5, // scaledPatterns is a n x 5 array\n                'Invalid BRISK pattern'\n            );\n\n            // create gaussian kernels\n            const kernels = scaledPatterns.map(layers => // 2D array\n                //layers.map(layer => gpu.filters.createGaussianKernel11x1(layer.r))\n                layers.map(layer => 0) // FIXME\n            );\n            const sigmas = scaledPatterns.map(layers =>\n                layers.map(layer => layer.r)\n            );\n            const distancesFromKeypoint = scaledPatterns.map(layers =>\n                layers.map(layer => layer.l)\n            );\n\n            // flatten 2D array\n            const flatten = arr => arr.reduce((v, e) => v.concat(e), []);\n\n            // index:   [ 0 , ... , 4 | 5 , ... , 9 | 10 , ... , 14 | ... ]\n            // scale:       sqrt(2)   |       1     |  1 / sqrt(2)  | ...\n            // sigma:  r1,r10,...,r20 | r1,r10,...  | r1,r10,...    | ...\n            gaussians = {\n                kernel: flatten(kernels),\n                sigma: flatten(sigmas),\n                distanceFromKeypoint: flatten(distancesFromKeypoint),\n            };\n            //console.log(gaussians);\n        }\n\n        // done!\n        return keypoints;\n    }\n\n    /**\n     * Short distance pairings,\n     * for scale = 1.0. Format:\n     * [x1,y1,x2,y2, ...]. Thus,\n     * 4 elements for each pair\n     * @returns {Float32Array<number>} flattened array\n     */\n    static get shortDistancePairs()\n    {\n        return shortPairs || (shortPairs = briskShortDistancePairs());\n    };\n\n    /**\n     * Long distance pairings,\n     * for scale = 1.0. Format:\n     * [x1,y1,x2,y2, ...]. Thus,\n     * 4 elements for each pair\n     * @returns {Float32Array<number>} flattened array\n     */\n    static get longDistancePairs()\n    {\n        return longPairs || (longPairs = briskLongDistancePairs());\n    }\n}\n\n/**\n * (Modified) BRISK pattern for 60 points:\n * 5 layers with k_l colliding circles,\n * each at a distance l_l from the origin\n * with radius r_l. For each layer l=0..4,\n * we have k_l = [1,10,14,15,20] circles\n *\n * @param {number} [scale] pattern scale\n *                 (e.g, 1, 0.5, 0.25...)\n * @returns {Array<object>}\n */\nfunction briskPattern(scale = 1.0)\n{\n    const piOverTwo = Math.PI / 2.0;\n    const baseDistance = 4.21; // innermost layer for scale = 1\n\n    const s10 = Math.sin(piOverTwo / 10);\n    const s14 = Math.sin(piOverTwo / 14);\n    const s15 = Math.sin(piOverTwo / 15);\n    const s20 = Math.sin(piOverTwo / 20);\n\n    const l10 = baseDistance * scale;\n    const r10 = 2 * l10 * s10;\n\n    const r14 = (2 * (l10 + r10) * s14) / (1 - 2 * s14);\n    const l14 = l10 + r10 + r14;\n\n    const r15 = (2 * (l14 + r14) * s15) / (1 - 2 * s15);\n    const l15 = l14 + r14 + r15;\n\n    const r20 = (2 * (l15 + r15) * s20) / (1 - 2 * s20);\n    const l20 = l15 + r15 + r20;\n\n    const r1 = r10 * 0.8; // guess & plot!\n    const l1 = 0.0;\n\n    return [\n        { n: 1, r: r1, l: l1 },\n        { n: 10, r: r10, l: l10 },\n        { n: 14, r: r14, l: l14 },\n        { n: 15, r: r15, l: l15 },\n        { n: 20, r: r20, l: l20 },\n    ];\n}\n\n/**\n * BRISK points given a\n * {n, r, l} BRISK layer\n * @param {object} layer\n * @returns {Array<object>}\n */\nfunction briskPoints(layer)\n{\n    const { n, r, l } = layer;\n    const twoPi = 2.0 * Math.PI;\n\n    return [...Array(n).keys()].map(j => ({\n        x: l * Math.cos(twoPi * j / n),\n        y: l * Math.sin(twoPi * j / n),\n        r, l, j, n,\n    }));\n}\n\n/**\n * BRISK pair of points such that\n * the distance of each is greater\n * than (threshold*scale), or less\n * than (-threshold*scale) if\n * threshold < 0\n * @param {number} threshold\n * @param {number} [scale] pattern scale\n * @returns {Float32Array<number>} format [x1,y1,x2,y2, ...]\n */\nfunction briskPairs(threshold, scale = 1.0)\n{\n    const flatten = arr => arr.reduce((v, e) => v.concat(e), []);\n    const p = flatten(briskPattern(scale).map(briskPoints));\n    const n = p.length, t = +threshold * scale;\n\n    const dist2 = (p, q) => (p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y);\n    const wanted = (t < 0) ? ((p,q) => dist2(p,q) < t*t) : ((p,q) => dist2(p,q) > t*t);\n    const pairs = [];\n\n    for(let i = 1; i < n; i++) {\n        for(let j = 0; j < i; j++) {\n            if(wanted(p[i], p[j])) {\n                pairs.push(p[i].x);\n                pairs.push(p[i].y);\n                pairs.push(p[j].x);\n                pairs.push(p[j].y);\n            }\n        }\n    }\n\n    return new Float32Array(pairs);\n}\n\n/**\n * BRISK short distance pairs\n * @param {number} threshold pick pairs with distance < threshold*scale\n * @param {number} [scale] pattern scale\n * @returns {Float32Array<number>} format [x1,y1,x2,y2, ...]\n */\nfunction briskShortDistancePairs(threshold = 9.75, scale = 1.0)\n{\n    return briskPairs(-threshold, scale);\n}\n\n/**\n * BRISK long distance pairs\n * @param {number} threshold pick pairs with distance > threshold*scale\n * @param {number} [scale] pattern scale\n * @returns {Float32Array<number>} format [x1,y1,x2,y2, ...]\n */\nfunction briskLongDistancePairs(threshold = 13.67, scale = 1.0)\n{\n    return briskPairs(threshold, scale);\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * fast.js\n * FAST corner detection\n */\n\nimport { Utils } from '../../utils/utils';\n\n/**\n * FAST corner detection\n */\nexport class FAST\n{\n    /**\n     * Run the FAST corner detection algorithm\n     * @param {number} n FAST parameter: 9, 7 or 5\n     * @param {GPUInstance} gpu\n     * @param {Texture} greyscale Greyscale image\n     * @param {object} settings\n     * @returns {Texture} features in a texture\n     */\n    static run(n, gpu, greyscale, settings)\n    {\n        // validate input\n        Utils.assert(\n            n == 9 || n == 7 || n == 5,\n            `Not implemented: FAST-${n}`\n        );\n\n        // keypoint detection\n        const rawCorners = (({\n            5: () => gpu.keypoints.fast5(greyscale, settings.threshold),\n            7: () => gpu.keypoints.fast7(greyscale, settings.threshold),\n            9: () => gpu.keypoints.fast9(greyscale, settings.threshold),\n        })[n])();\n\n        // non-maximum suppression\n        const corners = gpu.keypoints.fastSuppression(rawCorners);\n        return corners;\n    }\n\n    /**\n     * Sensitivity to threshold conversion\n     * sensitivity in [0,1] -> pixel intensity threshold in [0,1]\n     * performs a non-linear conversion (used for FAST)\n     * @param {number} sensitivity\n     * @returns {number} pixel intensity\n     */\n    static sensitivity2threshold(sensitivity)\n    {\n        // the number of keypoints ideally increases linearly\n        // as the sensitivity is increased\n        sensitivity = Math.max(0, Math.min(sensitivity, 1));\n        return 1 - Math.tanh(2.77 * sensitivity);\n    }\n\n    /**\n     * Normalize a threshold\n     * pixel threshold in [0,255] -> normalized threshold in [0,1]\n     * @returns {number} clamped & normalized threshold\n     */\n    static normalizedThreshold(threshold)\n    {\n        threshold = Math.max(0, Math.min(threshold, 255));\n        return threshold / 255;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * feature-detector.js\n * Feature detection facade\n */\n\nimport { FAST } from './algorithms/fast.js';\nimport { BRISK } from './algorithms/brisk.js';\nimport { OnlineErrorTuner, TestTuner } from '../utils/tuner';\nimport { Utils } from '../utils/utils';\n\n/**\n * FeatureDetector encapsulates\n * feature detection algorithms\n */\nexport class FeatureDetector\n{\n    /**\n     * Class constructor\n     * @param {GPUInstance} gpu\n     */\n    constructor(gpu)\n    {\n        this._gpu = gpu;\n        this._lastKeypointCount = 0;\n        this._sensitivityTuner = null;\n    }\n\n    /**\n     * FAST corner detection\n     * @param {SpeedyMedia} media The media\n     * @param {number} [n] We'll run FAST-n, where n must be 9 (default), 7 or 5\n     * @param {object} [settings] Additional settings\n     * @returns {Array<SpeedyFeature>} keypoints\n     */\n    fast(media, n = 9, settings = {})\n    {\n        const gpu = this._gpu;\n\n        // default settings\n        settings = {\n            threshold: 10,\n            denoise: true,\n            ...settings\n        };\n\n        // convert the expected number of keypoints,\n        // if defined, into a sensitivity value\n        if(settings.hasOwnProperty('expected'))\n            settings.sensitivity = this._findSensitivity(settings.expected);\n\n        // convert a sensitivity value in [0,1],\n        // if it's defined, to a FAST threshold\n        if(settings.hasOwnProperty('sensitivity'))\n            settings.threshold = FAST.sensitivity2threshold(settings.sensitivity);\n        else\n            settings.threshold = FAST.normalizedThreshold(settings.threshold);\n\n        // pre-processing the image...\n        const source = media._gpu.core.upload(media.source);\n        const texture = settings.denoise ? gpu.filters.gauss5(source) : source;\n        const greyscale = gpu.colors.rgb2grey(texture);\n\n        // extract features\n        const keypoints = FAST.run(n, gpu, greyscale, settings);\n        return this._extractKeypoints(keypoints);\n    }\n\n    /**\n     * BRISK feature point detection\n     * @param {SpeedyMedia} media The media\n     * @param {object} [settings]\n     * @returns {Array<SpeedyFeature>}\n     */\n    brisk(media, settings = {})\n    {\n        const gpu = this._gpu;\n\n        // default settings\n        settings = {\n            threshold: 10,\n            denoise: true,\n            depth: 4,\n            ...settings\n        };\n\n        // convert settings.expected to settings.sensitivity\n        if(settings.hasOwnProperty('expected'))\n            settings.sensitivity = this._findSensitivity(settings.expected);\n\n        // convert settings.sensitivity to settings.threshold\n        if(settings.hasOwnProperty('sensitivity'))\n            settings.threshold = FAST.sensitivity2threshold(settings.sensitivity);\n        else\n            settings.threshold = FAST.normalizedThreshold(settings.threshold);\n\n        // pre-processing the image...\n        const source = media._gpu.core.upload(media.source);\n        const texture = settings.denoise ? gpu.filters.gauss5(source) : source;\n        const greyscale = gpu.colors.rgb2grey(texture);\n\n        // extract features\n        const keypoints = BRISK.run(gpu, greyscale, settings);\n        return this._extractKeypoints(keypoints);\n    }\n\n    // given a corner-encoded texture,\n    // return an Array of keypoints\n    _extractKeypoints(corners, gpu = this._gpu)\n    {\n        const encodedKeypoints = gpu.encoders.encodeKeypoints(corners);\n        const keypoints = gpu.encoders.decodeKeypoints(encodedKeypoints);\n        const slack = this._lastKeypointCount > 0 ? // approximates assuming continuity\n            Math.max(1, Math.min(keypoints.length / this._lastKeypointCount), 2) : 1;\n\n        gpu.encoders.optimizeKeypointEncoder(keypoints.length * slack);\n        this._lastKeypointCount = keypoints.length;\n\n        return keypoints;\n    }\n\n    // find a sensitivity value in [0,1] such that\n    // the feature detector returns approximately the\n    // number of features you expect - within a\n    // tolerance, i.e., a percentage value\n    _findSensitivity(param)\n    {\n        // grab the parameters\n        const expected = {\n            number: 0, // how many keypoints do you expect?\n            tolerance: 0.10, // percentage relative to the expected number of keypoints\n            ...(typeof param == 'object' ? param : {\n                number: param | 0,\n            })\n        };\n\n        // spawn the tuner\n        this._sensitivityTuner = this._sensitivityTuner ||\n            new OnlineErrorTuner(0, 1200); // use a slightly wider interval for better stability\n            //new TestTuner(0, 1000);\n        const normalizer = 0.001;\n\n        // update tuner\n        this._sensitivityTuner.tolerance = expected.tolerance;\n        this._sensitivityTuner.feedObservation(this._lastKeypointCount, expected.number);\n        const sensitivity = this._sensitivityTuner.currentValue() * normalizer;\n\n        // return the new sensitivity\n        return Math.max(0, Math.min(sensitivity, 1));\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * pipeline-operations.js\n * A pipeline operation is an element of a SpeedyPipeline\n */\n\nimport { ColorFormat } from '../utils/types';\nimport { Utils } from '../utils/utils';\nimport { GLUtils } from '../gpu/gl-utils';\n\nexport const PipelineOperation = { };\n\n/**\n * Abstract basic operation\n */\n/* abstract */ class SpeedyPipelineOperation\n{\n    /**\n     * Runs the pipeline operation\n     * @param {Texture} texture\n     * @param {GPUInstance} gpu\n     * @param {SpeedyMedia} [media]\n     * @returns {Texture}\n     */\n    run(texture, gpu, media)\n    {\n        return texture;\n    }\n\n    /**\n     * Perform any necessary cleanup\n     */\n    release()\n    {\n    }\n}\n\n\n// =====================================================\n//               COLOR CONVERSIONS\n// =====================================================\n\n/**\n * Convert to greyscale\n */\nPipelineOperation.ConvertToGreyscale = class extends SpeedyPipelineOperation\n{\n    run(texture, gpu, media)\n    {\n        if(media._colorFormat == ColorFormat.RGB)\n            texture = gpu.colors.rgb2grey(texture);\n        else if(media._colorFormat != ColorFormat.Greyscale)\n            Utils.fatal(`Can't convert image to greyscale: unknown color format`);\n\n        media._colorFormat = ColorFormat.Greyscale;\n        return texture;\n    }\n}\n\n\n\n// =====================================================\n//               IMAGE FILTERS\n// =====================================================\n\n/**\n * Blur image\n */\nPipelineOperation.Blur = class extends SpeedyPipelineOperation\n{\n    /**\n     * Blur operation\n     * @param {object} [options]\n     */\n    constructor(options = {})\n    {\n        const { filter, size } = (options = {\n            filter: 'gaussian',     // \"gassuian\" | \"box\"\n            size: 5,                // 3 | 5 | 7\n            ...options\n        });\n        super();\n\n        // validate kernel size\n        if(size != 3 && size != 5 && size != 7)\n            Utils.fatal(`Invalid kernel size: ${size}`);\n\n        // select the appropriate filter\n        if(filter == 'gaussian')\n            this._filter = 'gauss' + size;\n        else if(filter == 'box')\n            this._filter = 'box' + size;\n        else\n            Utils.fatal(`Invalid filter: \"${filter}\"`);\n    }\n\n    run(texture, gpu, media)\n    {\n        return gpu.filters[this._filter](texture);\n    }\n}\n\n/**\n * Image convolution\n */\nPipelineOperation.Convolve = class extends SpeedyPipelineOperation\n{\n    /**\n     * Perform a convolution\n     * Must provide a SQUARE kernel with size: 3x3, 5x5 or 7x7\n     * @param {Array<number>} kernel convolution kernel\n     * @param {number} [divisor] divide all kernel entries by this number\n     */\n    constructor(kernel, divisor = 1.0)\n    {\n        let kern = new Float32Array(kernel).map(x => x / divisor);\n        const len = kern.length;\n        const size = Math.sqrt(len) | 0;\n        const method = ({\n            3: ['createKernel3x3', 'texConv2D3'],\n            5: ['createKernel5x5', 'texConv2D5'],\n            7: ['createKernel7x7', 'texConv2D7'],\n        })[size] || null;\n        super();\n\n        // validate kernel\n        if(len == 1)\n            Utils.fatal(`Cannot convolve with a kernel containing a single element`);\n        else if(size * size != len || !method)\n            Utils.fatal(`Cannot convolve with a non-square kernel of ${len} elements`);\n\n        // normalize kernel entries to [0,1]\n        const min = Math.min(...kern), max = Math.max(...kern);\n        const offset = min;\n        const scale = Math.abs(max - min) > 1e-5 ? max - min : 1;\n        kern = kern.map(x => (x - offset) / scale);\n\n        // store the normalized kernel\n        this._method = method;\n        this._scale = scale;\n        this._offset = offset;\n        this._kernel = kern;\n        this._kernelSize = size;\n        this._texKernel = null;\n        this._gl = null;\n    }\n\n    run(texture, gpu, media)\n    {\n        // instantiate the texture kernel\n        if(this._texKernel == null) {\n            this._texKernel = gpu.filters[this._method[0]](this._kernel);\n            this._gl = gpu.core.gl;\n        }\n\n        // convolve\n        return gpu.filters[this._method[1]](\n            texture,\n            this._texKernel,\n            this._scale,\n            this._offset\n        );\n    }\n\n    release()\n    {\n        if(this._texKernel != null) {\n            GLUtils.destroyTexture(this._gl, this._texKernel);\n            this._texKernel = this._gl = null;\n        }\n        super.release();\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-feature.js\n * SpeedyFeature implementation\n */\n\n/**\n * A SpeedyFeature is a keypoint in an image,\n * with optional scale, rotation and descriptor\n */\nexport class SpeedyFeature\n{\n    /**\n     * Creates a new SpeedyFeature\n     * @param {number} x X position\n     * @param {number} y Y position\n     * @param {number} [scale] Scale\n     * @param {number} [rotation] Rotation in radians\n     * @param {FeatureDescriptor} [descriptor] Feature descriptor\n     */\n    constructor(x, y, scale = 1.0, rotation = 0.0, descriptor = null)\n    {\n        this._x = +x;\n        this._y = +y;\n        this._scale = +scale;\n        this._rotation = +rotation;\n        this._descriptor = descriptor;\n    }\n\n    /**\n     * Converts a SpeedyFeature to a representative string\n     * @returns {string}\n     */\n    toString()\n    {\n        return `(${this._x},${this._y})`;\n    }\n\n    /**\n     * The X position of the feature point\n     * @returns {number} X position\n     */\n    get x()\n    {\n        return this._x;\n    }\n\n    /**\n     * The y position of the feature point\n     * @returns {number} Y position\n     */\n    get y()\n    {\n        return this._y;\n    }\n\n    /**\n     * The scale of the feature point\n     * @returns {number} Scale\n     */\n    get scale()\n    {\n        return this._scale;\n    }\n\n    /**\n     * The rotation of the feature point, in radians\n     * @returns {number} Angle in radians\n     */\n    get rotation()\n    {\n        return this._rotation;\n    }\n\n    /**\n     * The descriptor of the feature point, or null\n     * if there isn't any\n     * @return {FeatureDescriptor|null} feature descriptor\n     */\n    get descriptor()\n    {\n        return this._descriptor;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-media.js\n * SpeedyMedia implementation\n */\n\nimport { GPUInstance } from '../gpu/gpu-instance';\nimport { MediaType, ColorFormat } from '../utils/types'\nimport { FeatureDetector } from './feature-detector';\nimport { SpeedyError } from '../utils/errors';\nimport { Utils } from '../utils/utils';\n\n/**\n * SpeedyMedia encapsulates a media element\n * (e.g., image, video, canvas)\n */\nexport class SpeedyMedia\n{\n    /**\n     * Class constructor\n     * It assumes A VALID (!) media source that is already loaded\n     * @param {HTMLImageElement|HTMLVideoElement|HTMLCanvasElement|Texture} mediaSource An image, video or canvas\n     * @param {number} width media width\n     * @param {number} height media height\n     */\n    /* private */ constructor(mediaSource, width, height)\n    {\n        if(arguments.length > 1) {\n            // store data\n            this._source = mediaSource;\n            this._width = width | 0;\n            this._height = height | 0;\n            this._type = getMediaType(this._source);\n            this._colorFormat = ColorFormat.RGB;\n\n            // spawn relevant components\n            this._gpu = new GPUInstance(this._width, this._height);\n            this._featureDetector = null; // lazy instantiation \n        }\n        else if(arguments.length == 1) {\n            // copy constructor (shallow copy)\n            const media = arguments[0];\n\n            this._source = media._source;\n            this._width = media._width;\n            this._height = media._height;\n            this._type = media._type;\n            this._colorFormat = media._colorFormat;\n\n            this._gpu = media._gpu;\n            this._featureDetector = media._featureDetector;\n        }\n        else\n            Utils.fatal(`Invalid instantiation of SpeedyMedia`);\n    }\n\n    /**\n     * Load a media source\n     * Will wait until the HTML media source is loaded\n     * @param {HTMLImageElement|HTMLVideoElement|HTMLCanvasElement} mediaSource An image, video or canvas\n     * @returns {Promise<SpeedyMedia>}\n     */\n    static load(mediaSource)\n    {\n        return new Promise((resolve, reject) => {\n            const dimensions = getMediaDimensions(mediaSource);\n            if(dimensions != null) {\n                // try to load the media until it's ready\n                (function loadMedia(dimensions, k = 500) {\n                    if(dimensions.width > 0 && dimensions.height > 0) {\n                        const media = new SpeedyMedia(mediaSource, dimensions.width, dimensions.height);\n                        Utils.log(`Loaded SpeedyMedia with a ${mediaSource}.`);\n                        resolve(media);\n                    }\n                    else if(k > 0)\n                        setTimeout(() => loadMedia(getMediaDimensions(mediaSource), k-1), 10);\n                    else\n                        reject(new SpeedyError(`Can't load SpeedyMedia with a ${mediaSource}: timeout.`));\n                })(dimensions);\n            }\n            else {\n                // invalid media source\n                reject(new SpeedyError(`Can't load SpeedyMedia with a ${mediaSource}: invalid media source.`));\n            }\n        });\n    }\n\n    /**\n     * Loads a camera stream\n     * @param {number} [width] width of the stream\n     * @param {number} [height] height of the stream\n     * @param {object} [options] additional options to pass to getUserMedia()\n     * @returns {Promise<SpeedyMedia>}\n     */\n    static loadCameraStream(width = 426, height = 240, options = {})\n    {\n        return requestCameraStream(width, height, options).then(\n            video => SpeedyMedia.load(createCanvasFromVideo(video))\n        );\n    }\n\n    /**\n     * The media element (image, video, canvas) encapsulated by this SpeedyMedia object\n     * @returns {HTMLImageElement|HTMLVideoElement|HTMLCanvasElement} the media element\n     */\n    get source()\n    {\n        return this._source;\n    }\n\n    /**\n     * Gets the width of the media\n     * @returns {number} media width\n     */\n    get width()\n    {\n        return this._width;\n    }\n\n    /**\n     * Gets the height of the media\n     * @returns {number} media height\n     */\n    get height()\n    {\n        return this._height;\n    }\n\n    /**\n     * The type of the media attached to this SpeedyMedia object\n     * @returns {string} \"image\" | \"video\" | \"canvas\" | \"internal\"\n     */\n    get type()\n    {\n        switch(this._type) {\n            case MediaType.Image:\n                return 'image';\n\n            case MediaType.Video:\n                return 'video';\n\n            case MediaType.Canvas:\n                return 'canvas';\n\n            case MediaType.Texture: // the result of pipelining\n                return 'internal';\n\n            default: // this shouldn't happen\n                return 'unknown';\n        }\n    }\n\n    /**\n     * Clones the SpeedyMedia object\n     * @param {object} options options object\n     * @returns {SpeedyMedia} a clone object\n     */\n    clone(options = {})\n    {\n        // Default settings\n        options = {\n            lightweight: false,\n            ...(options)\n        };\n\n        if(options.lightweight) {\n            // shallow copy\n            return new SpeedyMedia(this);\n        }\n        else {\n            // deep copy\n            return new SpeedyMedia(\n                this._source,\n                this._width,\n                this._height\n            );\n        }\n    }\n\n    /**\n     * Runs a pipeline\n     * @param {SpeedyPipeline} pipeline\n     * @returns {Promise<SpeedyMedia>} a promise that resolves to A CLONE of this SpeedyMedia\n     */\n    run(pipeline)\n    {\n        const media = this.clone({ lightweight: true });\n        media._type = MediaType.Texture;\n        return pipeline._run(media);\n    }\n\n    /**\n     * Draws the media to a canvas\n     * @param {HTMLCanvasElement} canvas canvas element\n     * @param {number} [x] x-position\n     * @param {number} [y] y-position\n     * @param {number} [width] desired width\n     * @param {number} [height] desired height\n     */\n    draw(canvas, x = 0, y = 0, width = this.width, height = this.height)\n    {\n        const ctx = canvas.getContext('2d');\n\n        x = +x; y = +y;\n        width = Math.max(width, 0);\n        height = Math.max(height, 0);\n\n        switch(this._type) {\n            case MediaType.Image:\n            case MediaType.Video:\n            case MediaType.Canvas:\n                ctx.drawImage(this._source, x, y, width, height);\n                break;\n\n            case MediaType.Texture:\n                ctx.drawImage(this._gpu.canvas, x, y, width, height);\n                break;\n        }\n    }\n\n    /**\n     * Finds image features\n     * @param {object} [settings] Configuration object\n     * @returns {Promise< Array<SpeedyFeature> >} A Promise returning an Array of SpeedyFeature objects\n     */\n    findFeatures(settings = {})\n    {\n        // Default settings\n        settings = Object.assign({\n            method: 'fast',\n        }, settings);\n\n        // Lazy instantiation\n        this._featureDetector = this._featureDetector || new FeatureDetector(this._gpu);\n\n        // Algorithm table\n        const fn = ({\n            'fast' : (media, settings) => this._featureDetector.fast(media, 9, settings),   // alias for fast9\n            'fast9': (media, settings) => this._featureDetector.fast(media, 9, settings),   // FAST-9,16 (default)\n            'fast7': (media, settings) => this._featureDetector.fast(media, 7, settings),   // FAST-7,12\n            'fast5': (media, settings) => this._featureDetector.fast(media, 5, settings),   // FAST-5,8\n            'brisk': (media, settings) => this._featureDetector.brisk(media, settings),     // BRISK\n        });\n\n        // Run the algorithm\n        return new Promise((resolve, reject) => {\n            const method = String(settings.method).toLowerCase();\n\n            if(fn.hasOwnProperty(method)) {\n                const features = (fn[method])(this, settings);\n                resolve(features);\n            }\n            else\n                reject(new SpeedyError(`Invalid method \"${method}\" for keypoint detection.`));\n        });\n    }\n}\n\n// get the { width, height } of a certain HTML element (image, video, canvas...)\nfunction getMediaDimensions(mediaSource)\n{\n    if(mediaSource && mediaSource.constructor && mediaSource.constructor.name) {\n        const element = mediaSource.constructor.name, key = {\n            HTMLImageElement: { width: 'naturalWidth', height: 'naturalHeight' },\n            HTMLVideoElement: { width: 'videoWidth', height: 'videoHeight' },\n            HTMLCanvasElement: { width: 'width', height: 'height' },\n        };\n\n        if(key.hasOwnProperty(element)) {\n            return {\n                width: mediaSource[key[element].width],\n                height: mediaSource[key[element].height]\n            };\n        }\n    }\n\n    return null;\n}\n\n// get a string corresponding to the media type (image, video, canvas)\nfunction getMediaType(mediaSource)\n{\n    if(mediaSource && mediaSource.constructor) {\n        switch(mediaSource.constructor.name) {\n            case 'HTMLImageElement':\n                return MediaType.Image;\n\n            case 'HTMLVideoElement':\n                return MediaType.Video;\n\n            case 'HTMLCanvasElement':\n                return MediaType.Canvas;\n\n            default:\n                return MediaType.Texture;\n        }\n    }\n\n    Utils.fatal(`Can't get media type: invalid media source. ${mediaSource}`);\n    return null;\n}\n\n// webcam access\nfunction requestCameraStream(width, height, options = {})\n{\n    return new Promise((resolve, reject) => {\n        Utils.log('Accessing the webcam...');\n\n        if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia)\n            return reject(new SpeedyError('Unsupported browser: no mediaDevices.getUserMedia()'));\n\n        navigator.mediaDevices.getUserMedia({\n            audio: false,\n            video: {\n                width: { ideal: width },\n                height: { ideal: height },\n                aspectRatio: { ideal: width / height },\n                facingMode: 'environment',\n            },\n            ...(options)\n        })\n        .then(stream => {\n            const video = document.createElement('video');\n            video.srcObject = stream;\n            video.onloadedmetadata = e => {\n                video.play();\n                Utils.log('The camera device is turned on!');\n                resolve(video, stream);\n            };\n        })\n        .catch(err => {\n            reject(new SpeedyError(\n                `Please give access to the camera and reload the page.\\n` +\n                `${err.name}. ${err.message}.`\n            ));\n        });\n    });\n}\n\n// create a HTMLCanvasElement using a HTMLVideoElement\nfunction createCanvasFromVideo(video)\n{\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    \n    canvas.width = video.videoWidth;\n    canvas.height = video.videoHeight;\n\n    function render() {\n        ctx.drawImage(video, 0, 0);\n        requestAnimationFrame(render);\n    }\n    render();\n\n    return canvas;\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-pipeline.js\n * A pipeline is a sequence of operations that transform the image in some way\n */\n\nimport { PipelineOperation } from './pipeline-operations';\nimport { MediaType } from '../utils/types';\nimport { SpeedyError } from '../utils/errors';\nimport { Utils } from '../utils/utils';\n\n/**\n * A SpeedyPipeline holds a sequence of operations that\n * graphically transform the incoming media in some way\n * \n * SpeedyPipeline's methods are chainable: use them to\n * create your own sequence of image operations\n */\nexport class SpeedyPipeline\n{\n    /* friend class SpeedyMedia */\n\n    /**\n     * Class constructor\n     */\n    constructor()\n    {\n        this._operations = [];\n    }\n\n    /**\n     * The number of the operations of the pipeline\n     * @returns {number}\n     */\n    get length()\n    {\n        return this._operations.length;\n    }\n\n    /**\n     * Cleanup pipeline memory\n     * @returns {Promise<SpeedyPipeline>} resolves as soon as the memory is released\n     */\n    release()\n    {\n        return new Promise((resolve, reject) => {\n            for(let i = this._operations.length - 1; i >= 0; i--)\n                this._operations[i].release();\n            this._operations.length = 0;\n            resolve(this);\n        });\n    }\n\n    /**\n     * Adds a new operation to the end of the pipeline\n     * @param {SpeedyPipelineOperation} operation\n     * @returns {SpeedyPipeline} the pipeline itself\n     */\n    _spawn(operation)\n    {\n        this._operations.push(operation);\n        return this;\n    }\n\n    /**\n     * Runs the pipeline on a target media (it will be modified!)\n     * @param {SpeedyMedia} media media to be modified\n     * @returns {Promise<SpeedyMedia>} a promise that resolves to the provided media\n     */\n    _run(media)\n    {\n        return new Promise((resolve, reject) => {\n            if(media._type == MediaType.Texture) {\n                // upload the media to the GPU\n                let texture = media._gpu.core.upload(media._source);\n\n                // run the pipeline\n                for(let i = 0; i < this._operations.length; i++)\n                    texture = this._operations[i].run(texture, media._gpu, media);\n\n                // end of the pipeline\n                media._gpu.utils.output(texture);\n                media._source = media._gpu.canvas;\n\n                // done!\n                resolve(media);\n            }\n            else\n                reject(new SpeedyError(`Can't run a pipeline on a media that is not a texture`));\n        });\n    }\n\n\n    // =====================================================\n    //                    GENERIC\n    // =====================================================\n\n    /**\n     * Concatenates another pipeline into this one\n     * @param {SpeedyPipeline} pipeline\n     * @returns {SpeedyPipeline}\n     */\n    concat(pipeline)\n    {\n        if(pipeline instanceof SpeedyPipeline) {\n            this._operations = this._operations.concat(pipeline._operations);\n            return this;\n        }\n\n        Utils.fatal(`Invalid argument \"${pipeline}\" given to SpeedyPipeline.concatenate()`);\n        return this;\n    }\n\n\n    // =====================================================\n    //               COLOR CONVERSIONS\n    // =====================================================\n\n    /**\n     * Convert to a color space\n     * @param {string} [colorSpace] 'greyscale' | 'grayscale'\n     * @returns {SpeedyPipeline}\n     */\n    convertTo(colorSpace = null)\n    {\n        if(colorSpace == 'greyscale' || colorSpace == 'grayscale') {\n            return this._spawn(\n                new PipelineOperation.ConvertToGreyscale()\n            );\n        }\n\n        Utils.fatal(`Can't convert to unknown color space: \"${colorSpace}\"`);\n        return this;\n    }\n\n\n\n    // =====================================================\n    //               IMAGE FILTERING\n    // =====================================================\n\n    /**\n     * Image smoothing\n     * @param {object} [options]\n     * @returns {SpeedyPipeline}\n     */\n    blur(options = {})\n    {\n        return this._spawn(\n            new PipelineOperation.Blur(options)\n        );\n    }\n\n    /**\n     * Image convolution\n     * @param {Array<number>} kernel\n     * @param {number} [divisor]\n     * @returns {SpeedyPipeline}\n     */\n    convolve(kernel, divisor = 1.0)\n    {\n        return this._spawn(\n            new PipelineOperation.Convolve(kernel, divisor)\n        );\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * gl-utils.js\n * WebGL utilities\n */\n\n/**\n * WebGL-related error\n */\nexport class GLError extends Error\n{\n    /**\n     * Class constructor\n     * @param {string} message \n     */\n    constructor(message)\n    {\n        super(`[GLError] ${message}`);\n        this.name = this.constructor.name;\n    }\n}\n\n/**\n * WebGL Utilities\n */\nexport class GLUtils\n{\n    /**\n     * Create a new GLError object\n     * @param {string} message \n     */\n    static Error(message)\n    {\n        return new GLError(message);\n    }\n\n    /**\n     * Create a shader\n     * @param {WebGL2RenderingContext} gl\n     * @param {number} type\n     * @param {string} source\n     * @returns {WebGLShader}\n     */\n    static createShader(gl, type, source)\n    {\n        const shader = gl.createShader(type);\n\n        gl.shaderSource(shader, source);\n        gl.compileShader(shader);\n\n        return shader;\n    }\n\n    /**\n     * Create a vertex-shader + fragment-shader program\n     * @param {WebGL2RenderingContext} gl\n     * @param {string} vertexShaderSource\n     * @param {string} fragmentShaderSource\n     * @returns {WebGLProgram}\n     */\n    static createProgram(gl, vertexShaderSource, fragmentShaderSource)\n    {\n        const program = gl.createProgram();\n        const vertexShader = GLUtils.createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n        const fragmentShader = GLUtils.createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n\n        gl.attachShader(program, vertexShader);\n        gl.attachShader(program, fragmentShader);\n        gl.linkProgram(program);\n\n        // error?\n        if(!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n            const errors = [\n                gl.getShaderInfoLog(fragmentShader),\n                gl.getShaderInfoLog(vertexShader),\n                gl.getProgramInfoLog(program),\n            ];\n\n            const spaces = i => Math.max(0, 2 - Math.floor(Math.log10(i)));\n            const col = k => Array(spaces(k)).fill(' ').join('') + k + '. ';\n            const formattedSource = fragmentShaderSource.split('\\n')\n                .map((line, no) => col(1+no) + line)\n                .join('\\n');\n\n            gl.deleteProgram(program);\n            gl.deleteShader(fragmentShader);\n            gl.deleteShader(vertexShader);\n\n            throw GLUtils.Error(\n                `Can't create shader program.\\n\\n` +\n                `---------- ERROR ----------\\n` +\n                errors.join('\\n') + '\\n\\n' +\n                `---------- SOURCE CODE ----------\\n` +\n                formattedSource\n            );\n        }\n\n        return program;\n    }\n\n    /**\n     * Create a WebGL texture\n     * @param {WebGL2RenderingContext} gl \n     * @param {number} width in pixels\n     * @param {number} height in pixels\n     * @param {number} format \n     * @returns {WebGLTexture}\n     */\n    static createTexture(gl, width, height, format = null)\n    {\n        const texture = gl.createTexture();\n\n        // use default format\n        if(format === null)\n            format = gl.RGBA8;\n        \n        // setup texture\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT);\n        gl.texStorage2D(gl.TEXTURE_2D, 1, format, width, height);\n\n        // unbind & return\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        return texture;\n    }\n\n    /**\n     * Destroys a WebGL texture\n     * @param {WebGL2RenderingContext} gl \n     * @param {WebGLTexture} texture \n     * @returns {null}\n     */\n    static destroyTexture(gl, texture)\n    {\n        gl.deleteTexture(texture);\n        return null;\n    }\n\n    /**\n     * Upload pixel data to a WebGL texture\n     * @param {WebGL2RenderingContext} gl \n     * @param {WebGLTexture} texture \n     * @param {ImageBitmap|ImageData|ArrayBufferView|HTMLImageElement|HTMLVideoElement|HTMLCanvasElement} pixels \n     * @returns {WebGLTexture} texture\n     */\n    static uploadToTexture(gl, texture, pixels)\n    {\n        // Prefer calling uploadToTexture() before gl.useProgram() to avoid the\n        // needless switching of GL programs internally. See also:\n        // https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.texSubImage2D(gl.TEXTURE_2D,     // target\n                         0,                 // mip level\n                         0,                 // x-offset\n                         0,                 // y-offset\n                         gl.RGBA,           // source format\n                         gl.UNSIGNED_BYTE,  // source type\n                         pixels);           // source data\n\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        return texture;\n    }\n\n    // bind the textures and assign their numbers\n    // textureMap: { 'textureName': <texture> , ... }\n    // locationMap: { 'textureName': <uniformLocation> , ... }\n    static bindTextures(gl, textureMap, locationMap)\n    {\n        const names = Object.keys(textureMap);\n\n        if(names.length > gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS)\n            throw GLUtils.Error(`Can't bind ${names.length} textures to a program: max is ${gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS}`);\n\n        for(let i = 0; i < names.length; i++) {\n            gl.activeTexture(gl.TEXTURE0 + i);\n            gl.bindTexture(gl.TEXTURE_2D, textureMap[names[i]]);\n            gl.uniform1i(locationMap[names[i]], i);\n        }\n    }\n\n    /**\n     * Creates a framebuffer object (FBO) associated with an existing texture\n     * @param {WebGL2RenderingContext} gl \n     * @param {WebGLTexture} texture \n     * @returns {WebGLFramebuffer}\n     */\n    static createFramebuffer(gl, texture)\n    {\n        const fbo = gl.createFramebuffer();\n\n        // setup framebuffer\n        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n        gl.framebufferTexture2D(gl.FRAMEBUFFER,         // target\n                                gl.COLOR_ATTACHMENT0,   // color buffer\n                                gl.TEXTURE_2D,          // tex target\n                                texture,                // texture\n                                0);                     // mipmap level\n\n        // check for errors\n        const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n        if(status != gl.FRAMEBUFFER_COMPLETE) {\n            const error = (() => (([\n                'FRAMEBUFFER_UNSUPPORTED',\n                'FRAMEBUFFER_INCOMPLETE_ATTACHMENT',\n                'FRAMEBUFFER_INCOMPLETE_DIMENSIONS',\n                'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT',\n                'FRAMEBUFFER_INCOMPLETE_MULTISAMPLE'\n            ].filter(err => gl[err] === status))[0] || 'unknown error'))();\n            throw GLUtils.Error(`Can't create framebuffer: ${error} (${status})`);\n        }\n\n        // unbind & return\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        return fbo;\n    }\n\n    /**\n     * Destroys a framebuffer object (FBO)\n     * @param {WebGL2RenderingContext} gl\n     * @param {WebGLFramebuffer} fbo \n     * @returns {null}\n     */\n    static destroyFramebuffer(gl, fbo)\n    {\n        gl.deleteFramebuffer(fbo);\n        return null;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * gpu-instance.js\n * The set of all GPU kernel groups for accelerated computer vision\n */\n\nimport { SpeedyGPUCore } from './speedy-gpu-core';\nimport { Utils } from '../utils/utils';\nimport { GPUUtils } from './kernels/utils';\nimport { GPUColors } from './kernels/colors';\nimport { GPUFilters } from './kernels/filters';\nimport { GPUKeypoints } from './kernels/keypoints';\nimport { GPUEncoders } from './kernels/encoders';\nimport { GPUPyramids } from './kernels/pyramids';\n\n// Limits\nconst MAX_TEXTURE_LENGTH = 65534; // 2^n - 2 due to encoding\nconst MAX_PYRAMID_LEVELS = 4;\n\n// Available kernel groups\n// (maps group name to class name)\nconst KERNEL_GROUPS = {\n    'utils': GPUUtils,\n    'colors': GPUColors,\n    'filters': GPUFilters,\n    'keypoints': GPUKeypoints,\n    'encoders': GPUEncoders,\n    'pyramids': GPUPyramids,\n};\n\n/**\n * The set of all GPU kernel groups for\n * accelerated computer vision\n */\nexport class GPUInstance\n{\n    /**\n     * Class constructor\n     * @param {number} width Texture width\n     * @param {number} height Texture height\n     */\n    constructor(width, height)\n    {\n        // read & validate texture size\n        this._width = Math.max(1, width | 0);\n        this._height = Math.max(1, height | 0);\n        if(this._width > MAX_TEXTURE_LENGTH || this._height > MAX_TEXTURE_LENGTH) {\n            Utils.warning(`Maximum texture size exceeded (using ${this._width} x ${this._height}).`);\n            this._width = Math.min(this._width, MAX_TEXTURE_LENGTH);\n            this._height = Math.min(this._height, MAX_TEXTURE_LENGTH);\n        }\n\n        // initialize the GPU core\n        this._core = this._spawnGPUCore(this._width, this._height);\n    }\n\n    /**\n     * Texture width\n     * @returns {number}\n     */\n    get width()\n    {\n        return this._width;\n    }\n\n    /**\n     * Texture height\n     * @returns {number}\n     */\n    get height()\n    {\n        return this._height;\n    }\n\n    /**\n     * GPU core\n     * @returns {SpeedyGPUCore}\n     */\n    get core()\n    {\n        return this._core;\n    }\n\n    /**\n     * Access the kernel groups of a pyramid level\n     * sizeof(pyramid(i)) = sizeof(pyramid(0)) / 2^i\n     * @param {number} level a number in 0, 1, ..., MAX_PYRAMID_LEVELS - 1\n     * @returns {Array}\n     */\n    pyramid(level)\n    {\n        const lv = level | 0;\n\n        if(lv < 0 || lv >= MAX_PYRAMID_LEVELS)\n            Utils.fatal(`Invalid pyramid level: ${lv}`);\n\n        return this._pyramid[lv];\n    }\n\n    /**\n     * Access the kernel groups of an intra-pyramid level\n     * The intra-pyramid encodes layers between pyramid layers\n     * sizeof(intraPyramid(0)) = 1.5 * sizeof(pyramid(0))\n     * sizeof(intraPyramid(1)) = 1.5 * sizeof(pyramid(1))\n     * @param {number} level a number in 0, 1, ..., MAX_PYRAMID_LEVELS\n     * @returns {Array}\n     */\n    intraPyramid(level)\n    {\n        const lv = level | 0;\n\n        if(lv < 0 || lv >= MAX_PYRAMID_LEVELS + 1)\n            Utils.fatal(`Invalid intra-pyramid level: ${lv}`);\n\n        return this._intraPyramid[lv];\n    }\n\n    /**\n     * The number of layers of the pyramid\n     * @returns {number}\n     */\n    get pyramidHeight()\n    {\n        return MAX_PYRAMID_LEVELS;\n    }\n\n    /**\n     * The maximum supported scale for a pyramid layer\n     * @returns {number}\n     */\n    get pyramidMaxScale()\n    {\n        // This is preferably a power of 2\n        return 2;\n    }\n\n    /**\n     * Internal canvas\n     * @returns {HTMLCanvasElement}\n     */\n    get canvas()\n    {\n        return this._core.canvas;\n    }\n\n    // spawns a SpeedyGPUCore instance\n    _spawnGPUCore(width, height)\n    {\n        // create GPU\n        const gpu = new SpeedyGPUCore(width, height);\n\n        // spawn kernel groups\n        spawnKernelGroups.call(this, this, width, height);\n\n        // spawn pyramids of kernel groups\n        this._pyramid = this._buildPyramid(gpu, width, height, 1.0, MAX_PYRAMID_LEVELS);\n        this._intraPyramid = this._buildPyramid(gpu, width, height, 1.5, MAX_PYRAMID_LEVELS + 1);\n\n        // done!\n        return gpu;\n    }\n\n    // build a pyramid, where each level stores the kernel groups\n    _buildPyramid(gpu, imageWidth, imageHeight, baseScale, numLevels)\n    {\n        let scale = +baseScale;\n        let width = (imageWidth * scale) | 0, height = (imageHeight * scale) | 0;\n        let pyramid = new Array(numLevels);\n\n        for(let i = 0; i < pyramid.length; i++) {\n            pyramid[i] = { width, height, scale };\n            spawnKernelGroups.call(pyramid[i], this, width, height);\n            width = ((1 + width) / 2) | 0;\n            height = ((1 + height) / 2) | 0;\n            scale /= 2;\n        }\n\n        return pyramid;\n    }\n}\n\n// Spawn kernel groups\nfunction spawnKernelGroups(gpu, width, height)\n{\n    // all kernel groups are available via getters\n    for(let g in KERNEL_GROUPS) {\n        Object.defineProperty(this, g, {\n            get: (() => {\n                const grp = '_' + g;\n                return (function() { // lazy instantiation\n                    return this[grp] || (this[grp] = new (KERNEL_GROUPS[g])(gpu, width, height));\n                }).bind(this);\n            })(),\n            configurable: true // WebGL context may be lost\n        });\n    }\n}\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * gpu-kernel-group.js\n * An abstract group of GPU kernels\n */\n\n/**\n * GPUKernelGroup\n * A semantically correlated group\n * of kernels that run on the GPU\n */\n\nexport /* abstract */ class GPUKernelGroup\n{\n    /**\n     * Class constructor\n     * @param {GPUInstance} gpu\n     * @param {number} width Texture width (depends on the pyramid layer)\n     * @param {number} height Texture height (depends on the pyramid layer)\n     */\n    /* protected */ constructor(gpu, width, height)\n    {\n        this._gpu = gpu;\n        this._width = width;\n        this._height = height;\n    }\n\n    /**\n     * Declare a kernel\n     * @param {string} name Kernel name\n     * @param {Function} fn Kernel code\n     * @param {object} settings Kernel settings\n     * @returns {GPUKernelGroup} This object\n     */\n    /* protected */ declare(name, fn, settings = { })\n    {\n        // lazy instantiation of kernels\n        Object.defineProperty(this, name, {\n            get: (() => {\n                const key = '__k_' + name;\n                return (function() {\n                    return this[key] || (this[key] = this._spawnKernel(fn, settings));\n                }).bind(this);\n            })()\n        });\n\n        return this;\n    }\n\n    /**\n     * Multi-pass composition\n     * @param {string} name Kernel name\n     * @param {string} fn Other kernels\n     * @returns {GPUKernelGroup} This object\n     */\n    /* protected */ compose(name, ...fn)\n    {\n        // function composition: functions are called in the order they are specified\n        // e.g., compose('h', 'f', 'g') means h(x) = g(f(x))\n        Object.defineProperty(this, name, {\n            get: (() => {\n                const key = '__c_' + name;\n                return (function() {\n                    return this[key] || (this[key] = (fn.length == 2) ? (() => {\n                        fn = fn.map(fi => this[fi]);\n                        return function compose(image, ...args) {\n                            return (fn[1])((fn[0])(image, ...args), ...args);\n                        };\n                    })() : ((fn.length == 3) ? (() => {\n                        fn = fn.map(fi => this[fi]);\n                        return function compose(image, ...args) {\n                            return (fn[2])((fn[1])((fn[0])(image, ...args), ...args), ...args);\n                        };\n                    })() : ((fn.length == 4) ? (() => {\n                        fn = fn.map(fi => this[fi]);\n                        return function compose(image, ...args) {\n                            return (fn[3])((fn[2])((fn[1])((fn[0])(image, ...args), ...args), ...args), ...args);\n                        };\n                    })() : (() => {\n                        fn = fn.map(fi => this[fi]);\n                        return function compose(image, ...args) {\n                            return fn.reduce((img, fi) => fi(img, ...args), image);\n                        };\n                    })())));\n                }).bind(this);\n            })()\n        });\n\n        return this;\n    }\n\n    /**\n     * Neat helpers to be used\n     * when defining operations\n     */\n    get operation()\n    {\n        return this._helpers || (this.helpers = {\n\n            // Set texture input/output size\n            // Dimensions are converted to integers\n            hasTextureSize(width, height) {\n                return {\n                    output: [ width|0, height|0 ]\n                };\n            },\n\n            // Render to canvas\n            // Use it when we're supposed to see the texture\n            displaysGraphics() {\n                return {\n                    renderToTexture: false\n                };\n            },\n\n            // Use this when we want to keep the kernel\n            // texture (they are recycled by default)\n            doesNotRecycleTextures() {\n                return {\n                    recycleTexture: false\n                };\n            },\n\n        });\n    }\n\n    /* private */ _spawnKernel(fn, settings = { })\n    {\n        return this._gpu.core.createProgram(fn, {\n            // default settings\n            output: [ this._width, this._height ],\n            ...settings\n        });\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * gpu-colors.js\n * Color conversion algorithms\n */\n\nimport { GPUKernelGroup } from '../gpu-kernel-group';\nimport { rgb2grey } from './shaders/colors';\n\n/**\n * GPUColors\n * Color conversions\n */\nexport class GPUColors extends GPUKernelGroup\n{\n    /**\n     * Class constructor\n     * @param {GPUInstance} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            // convert to greyscale\n            .declare('rgb2grey', rgb2grey)\n        ;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * gpu-encoders.js\n * Texture encoders\n */\n\nimport { GPUKernelGroup } from '../gpu-kernel-group';\nimport { encodeKeypointOffsets, encodeKeypoints } from './shaders/encoders';\nimport { SpeedyFeature } from '../../core/speedy-feature';\nimport { StochasticTuner } from '../../utils/tuner';\nimport { Utils } from '../../utils/utils'\n\n// We won't admit more than MAX_KEYPOINTS per media.\n// The larger this value is, the more data we need to transfer from the GPU.\nconst MAX_DESCRIPTOR_SIZE = 64; // in bytes, must be divisible by 4\nconst MAX_KEYPOINT_SIZE = 8 + MAX_DESCRIPTOR_SIZE; // in bytes, must be divisible by 4\nconst MAX_PIXELS_PER_KEYPOINT = (MAX_KEYPOINT_SIZE / 4) | 0; // in pixels\nconst MAX_ENCODER_LENGTH = 300; // in pixels (if too large, WebGL may lose context - so be careful!)\nconst MAX_KEYPOINTS = ((MAX_ENCODER_LENGTH * MAX_ENCODER_LENGTH) / MAX_PIXELS_PER_KEYPOINT) | 0;\nconst INITIAL_ENCODER_LENGTH = 128; // pick a large value <= MAX (useful on static images when no encoder optimization is performed beforehand)\nconst TWO_PI = 2.0 * Math.PI;\n\n\n/**\n * GPUEncoders\n * Texture encoding\n */\nexport class GPUEncoders extends GPUKernelGroup\n{\n    /**\n     * Class constructor\n     * @param {GPUInstance} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            // Keypoint encoding\n            .declare('_encodeKeypointOffsets', encodeKeypointOffsets)\n            .declare('_encodeKeypoints', encodeKeypoints, {\n                output: [ INITIAL_ENCODER_LENGTH, INITIAL_ENCODER_LENGTH ],\n                renderToTexture: false\n            })\n        ;\n\n        // setup internal data\n        let neighborFn = (s) => Math.round(Utils.gaussianNoise(s, 64)) % 256;\n        this._tuner = new StochasticTuner(48, 32, 255, 0.2, 4, 60, neighborFn);\n        this._keypointEncoderLength = INITIAL_ENCODER_LENGTH;\n        this._descriptorSize = 0;\n        this._spawnedAt = performance.now();\n    }\n\n\n\n    // -------------------------------------------------------------------------\n    //                       KEYPOINT ENCODING\n    // -------------------------------------------------------------------------\n\n\n    /**\n     * Optimizes the keypoint encoder for an expected number of keypoints\n     * @param {number} keypointCount expected number of keypoints\n     * @returns {number} nonzero if the encoder has been optimized\n     */\n    optimizeKeypointEncoder(keypointCount)\n    {\n        const clampedKeypointCount = Math.max(0, Math.min(keypointCount, MAX_KEYPOINTS));\n        const pixelsPerKeypoint = Math.ceil(2 + this._descriptorSize / 4);\n        const len = Math.ceil(Math.sqrt((4 + clampedKeypointCount) * pixelsPerKeypoint)); // add some slack\n        const newEncoderLength = Math.max(1, Math.min(len, MAX_ENCODER_LENGTH));\n        const oldEncoderLength = this._keypointEncoderLength;\n\n        if(newEncoderLength != oldEncoderLength) {\n            this._keypointEncoderLength = newEncoderLength;\n            this._encodeKeypoints.resize(newEncoderLength, newEncoderLength);\n        }\n\n        return newEncoderLength - oldEncoderLength;\n    }\n\n    /**\n     * Encodes the keypoints of an image - this is a bottleneck!\n     * @param {WebGLTexture} corners image with encoded corners\n     * @returns {Array<number>} pixels in the [r,g,b,a, ...] format\n     */\n    encodeKeypoints(corners)\n    {\n        // parameters\n        const encoderLength = this._keypointEncoderLength;\n        const descriptorSize = this._descriptorSize;\n        const imageSize = [ this._width, this._height ];\n        const maxIterations = this._tuner.currentValue();\n\n        // encode keypoint offsets\n        const start = performance.now();\n        const offsets = this._encodeKeypointOffsets(corners, imageSize, maxIterations);\n        this._encodeKeypoints(offsets, imageSize, encoderLength, descriptorSize);\n        const pixels = this._encodeKeypoints.readPixelsSync();\n\n        // tuner: drop noisy feedback when the page loads\n        if(performance.now() >= this._spawnedAt + 2000) {\n            const time = performance.now() - start;\n            this._tuner.feedObservation(time);\n        }\n\n        // debug\n        //console.log(JSON.stringify(this._tuner.info()));\n\n        // done!\n        return pixels;\n    }\n\n    /**\n     * Decodes the keypoints, given a flattened image of encoded pixels\n     * @param {Array<number>} pixels pixels in the [r,g,b,a,...] format\n     * @returns {Array<SpeedyFeature>} keypoints\n     */\n    decodeKeypoints(pixels)\n    {\n        const [ w, h ] = [ this._width, this._height ];\n        const hasRotation = this._descriptorSize > 0;\n        const pixelsPerKeypoint = 2 + this._descriptorSize / 4;\n        const lgM = Math.log2(this._gpu.pyramidMaxScale);\n        const pyrHeight = this._gpu.pyramidHeight;\n        let keypoints = [], x, y, scale, rotation;\n\n        for(let i = 0; i < pixels.length; i += 4 * pixelsPerKeypoint) {\n            x = (pixels[i+1] << 8) | pixels[i];\n            y = (pixels[i+3] << 8) | pixels[i+2];\n            if(x < w && y < h) {\n                scale = pixels[i+4] == 255 ? 1.0 :\n                    Math.pow(2.0, -lgM + (lgM + pyrHeight) * pixels[i+4] / 255.0);\n\n                rotation = !hasRotation ? 0.0 :\n                    pixels[i+5] * TWO_PI / 255.0;\n\n                keypoints.push(new SpeedyFeature(x, y, scale, rotation));\n            }\n            else\n                break;\n        }\n\n        // developer's secret ;)\n        // reset the tuner\n        if(keypoints.length == 0) {\n            if(this._tuner.finished())\n                this._tuner.reset();\n        }\n\n        // done!\n        return keypoints;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * gpu-filters.js\n * Image filtering on the GPU\n */\n\nimport { GPUKernelGroup } from '../gpu-kernel-group';\nimport { conv2D, convX, convY, texConvX, texConvY, texConv2D, idConv2D, createKernel2D, createKernel1D } from './shaders/convolution';\n\n/**\n * GPUFilters\n * Image filtering\n */\nexport class GPUFilters extends GPUKernelGroup\n{\n    /**\n     * Class constructor\n     * @param {GPUInstance} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            // gaussian approximation (sigma approx. 1.0)\n            .compose('gauss5', '_gauss5x', '_gauss5y') // size: 5x5\n            .compose('gauss3', '_gauss3x', '_gauss3y') // size: 3x3\n            .compose('gauss7', '_gauss7x', '_gauss7y') // size: 7x7\n\n            // box filters\n            .compose('box5', '_box5x', '_box5y') // size: 5x5\n            .compose('box3', '_box3x', '_box3y') // size: 3x3\n            .compose('box7', '_box7x', '_box7y') // size: 7x7\n            .compose('box9', '_box9x', '_box9y') // size: 9x9\n            .compose('box11', '_box11x', '_box11y') // size: 11x11\n\n            // texture-based convolutions\n            .compose('texConv2D3', '_idConv2D3', '_texConv2D3') // 2D texture-based 3x3 convolution\n            .compose('texConv2D5', '_idConv2D5', '_texConv2D5') // 2D texture-based 5x5 convolution\n            .compose('texConv2D7', '_idConv2D7', '_texConv2D7') // 2D texture-based 7x7 convolution\n\n            .declare('_texConv2D3', texConv2D(3)) // 3x3 convolution with a texture (not chainable)\n            .declare('_idConv2D3', idConv2D(3)) // identity operation (enables chaining)\n            .declare('_texConv2D5', texConv2D(5)) // 5x5 convolution with a texture (not chainable)\n            .declare('_idConv2D5', idConv2D(5)) // identity operation (enables chaining)\n            .declare('_texConv2D7', texConv2D(7)) // 7x7 convolution with a texture (not chainable)\n            .declare('_idConv2D7', idConv2D(7)) // identity operation (enables chaining)\n\n            // texture-based separable convolutions\n            .compose('texConvXY3', 'texConvX3', 'texConvY3') // 2D convolution with same 1D separable kernel in both axes\n            .declare('texConvX3', texConvX(3)) // 3x1 convolution, x-axis\n            .declare('texConvY3', texConvY(3)) // 1x3 convolution, y-axis\n            .compose('texConvXY5', 'texConvX5', 'texConvY5') // 2D convolution with same 1D separable kernel in both axes\n            .declare('texConvX5', texConvX(5)) // 5x1 convolution, x-axis\n            .declare('texConvY5', texConvY(5)) // 1x5 convolution, y-axis\n            .compose('texConvXY7', 'texConvX7', 'texConvY7') // 2D convolution with same 1D separable kernel in both axes\n            .declare('texConvX7', texConvX(7)) // 7x1 convolution, x-axis\n            .declare('texConvY7', texConvY(7)) // 1x7 convolution, y-axis\n            .compose('texConvXY9', 'texConvX9', 'texConvY9') // 2D convolution with same 1D separable kernel in both axes\n            .declare('texConvX9', texConvX(9)) // 9x1 convolution, x-axis\n            .declare('texConvY9', texConvY(9)) // 1x9 convolution, y-axis\n            .compose('texConvXY11', 'texConvX11', 'texConvY11') // 2D convolution with same 1D separable kernel in both axes\n            .declare('texConvX11', texConvX(11)) // 11x1 convolution, x-axis\n            .declare('texConvY11', texConvY(11)) // 1x11 convolution, y-axis\n\n            // create custom convolution kernels\n            .declare('createKernel3x3', createKernel2D(3), { // 3x3 texture kernel\n                ...(this.operation.hasTextureSize(3, 3)),\n                ...(this.operation.doesNotRecycleTextures())\n            })\n            .declare('createKernel5x5', createKernel2D(5), { // 5x5 texture kernel\n                ...(this.operation.hasTextureSize(5, 5)),\n                ...(this.operation.doesNotRecycleTextures())\n            })\n            .declare('createKernel7x7', createKernel2D(7), { // 7x7 texture kernel\n                ...(this.operation.hasTextureSize(7, 7)),\n                ...(this.operation.doesNotRecycleTextures())\n            })\n            .declare('createKernel3x1', createKernel1D(3), { // 3x1 texture kernel\n                ...(this.operation.hasTextureSize(3, 1)),\n                ...(this.operation.doesNotRecycleTextures())\n            })\n            .declare('createKernel5x1', createKernel1D(5), { // 5x1 texture kernel\n                ...(this.operation.hasTextureSize(5, 1)),\n                ...(this.operation.doesNotRecycleTextures())\n            })\n            .declare('createKernel7x1', createKernel1D(7), { // 7x1 texture kernel\n                ...(this.operation.hasTextureSize(7, 1)),\n                ...(this.operation.doesNotRecycleTextures())\n            })\n            .declare('createKernel9x1', createKernel1D(9), { // 9x1 texture kernel\n                ...(this.operation.hasTextureSize(9, 1)),\n                ...(this.operation.doesNotRecycleTextures())\n            })\n            .declare('createKernel11x1', createKernel1D(11), { // 11x1 texture kernel\n                ...(this.operation.hasTextureSize(11, 1)),\n                ...(this.operation.doesNotRecycleTextures())\n            })\n            /*.declare('_readKernel3x3', identity, { // for testing\n                ...(this.operation.hasTextureSize(3, 3)),\n                ...(this.operation.displaysGraphics())\n            })\n            .declare('_readKernel3x1', identity, {\n                ...(this.operation.hasTextureSize(3, 1)),\n                ...(this.operation.displaysGraphics())\n            })*/\n\n\n\n\n            // separable kernels (Gaussian)\n            // see also: http://dev.theomader.com/gaussian-kernel-calculator/\n            .declare('_gauss5x', convX([\n                0.05, 0.25, 0.4, 0.25, 0.05\n                //0.006, 0.061, 0.242, 0.383, 0.242, 0.061, 0.006\n            ]))\n            .declare('_gauss5y', convY([\n                0.05, 0.25, 0.4, 0.25, 0.05\n                //0.006, 0.061, 0.242, 0.383, 0.242, 0.061, 0.006\n            ]))\n            .declare('_gauss3x', convX([\n                0.25, 0.5, 0.25\n                //0.27901, 0.44198, 0.27901\n            ]))\n            .declare('_gauss3y', convY([\n                0.25, 0.5, 0.25\n                //0.27901, 0.44198, 0.27901\n            ]))\n            .declare('_gauss7x', convX([\n                0.00598, 0.060626, 0.241843, 0.383103, 0.241843, 0.060626, 0.00598\n            ]))\n            .declare('_gauss7y', convY([\n                0.00598, 0.060626, 0.241843, 0.383103, 0.241843, 0.060626, 0.00598\n            ]))\n            /*.declare('_gauss5', conv2D([ // for testing\n                1, 4, 7, 4, 1,\n                4, 16, 26, 16, 4,\n                7, 26, 41, 26, 7,\n                4, 16, 26, 16, 4,\n                1, 4, 7, 4, 1,\n            ], 1 / 237))*/\n\n\n\n            // separable kernels (Box filter)\n            .declare('_box3x', convX([\n                1, 1, 1\n            ], 1 / 3))\n            .declare('_box3y', convY([\n                1, 1, 1\n            ], 1 / 3))\n            .declare('_box5x', convX([\n                1, 1, 1, 1, 1\n            ], 1 / 5))\n            .declare('_box5y', convY([\n                1, 1, 1, 1, 1\n            ], 1 / 5))\n            .declare('_box7x', convX([\n                1, 1, 1, 1, 1, 1, 1\n            ], 1 / 7))\n            .declare('_box7y', convY([\n                1, 1, 1, 1, 1, 1, 1\n            ], 1 / 7))\n            .declare('_box9x', convX([\n                1, 1, 1, 1, 1, 1, 1, 1, 1\n            ], 1 / 9))\n            .declare('_box9y', convY([\n                1, 1, 1, 1, 1, 1, 1, 1, 1\n            ], 1 / 9))\n            .declare('_box11x', convX([\n                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\n            ], 1 / 11))\n            .declare('_box11y', convY([\n                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\n            ], 1 / 11))\n        ;\n    }\n}\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * gpu-keypoints.js\n * Facade for various keypoint detection algorithms\n */\n\nimport { GPUKernelGroup } from '../gpu-kernel-group';\nimport { fast5, fast7, fast9ml, fastScore8, fastScore12, fastScore16, fastSuppression } from './shaders/fast';\nimport { brisk } from './shaders/brisk';\n\n/**\n * GPUKeypoints\n * Keypoint detection\n */\nexport class GPUKeypoints extends GPUKernelGroup\n{\n    /**\n     * Class constructor\n     * @param {GPUInstance} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            // FAST-9,16\n            .compose('fast9', '_fast9', '_fastScore16')\n            .declare('_fast9', fast9ml) // use 'ml' for multiple passes\n            .declare('_fastScore16', fastScore16) // compute scores\n\n            // FAST-7,12\n            .compose('fast7', '_fast7', '_fastScore12')\n            .declare('_fast7', fast7)\n            .declare('_fastScore12', fastScore12)\n\n            // FAST-5,8\n            .compose('fast5', '_fast5', '_fastScore8')\n            .declare('_fast5', fast5)\n            .declare('_fastScore8', fastScore8)\n\n            // FAST Non-Maximum Suppression\n            .declare('fastSuppression', fastSuppression)\n\n            // BRISK Scale-Space Non-Maximum Suppression & Interpolation\n            .declare('brisk', brisk)\n        ;\n    }\n}\n\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * gpu-pyramids.js\n * Image pyramids\n */\n\nimport { GPUKernelGroup } from '../gpu-kernel-group';\nimport { flipY } from './shaders/utils';\nimport { convX, convY } from './shaders/convolution';\nimport { upsample2, downsample2, upsample3, downsample3 } from './shaders/pyramids';\nimport { mergeKeypoints, mergeKeypointsAtConsecutiveLevels, normalizeKeypoints } from './shaders/pyramids';\nimport { setScale, scale, crop } from './shaders/pyramids';\n\n/**\n * GPUPyramids\n * Image pyramids\n */\nexport class GPUPyramids extends GPUKernelGroup\n{\n    /**\n     * Class constructor\n     * @param {GPUInstance} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            // initialize pyramid\n            .declare('setBase', setScale(1.0, gpu.pyramidHeight, gpu.pyramidMaxScale))\n \n            // pyramid operations\n            .compose('reduce', '_smoothX', '_smoothY', '_downsample2', '_scale1/2')\n            .compose('expand', '_upsample2', '_smoothX2', '_smoothY2', '_scale2')\n           \n            // intra-pyramid operations (between two pyramid levels)\n            .compose('intraReduce', '_upsample2', '_smoothX2', '_smoothY2', '_downsample3/2', '_scale2/3')\n            .compose('intraExpand', '_upsample3', '_smoothX3', '_smoothY3', '_downsample2/3', '_scale3/2')\n\n            // Merge keypoints across multiple scales\n            .declare('mergeKeypoints', mergeKeypoints)\n            .declare('mergeKeypointsAtConsecutiveLevels', mergeKeypointsAtConsecutiveLevels)\n            .declare('normalizeKeypoints', normalizeKeypoints)\n\n            // Crop texture to width x height of the current pyramid level\n            .declare('crop', crop)\n\n            // kernels for debugging\n            .declare('output', flipY, {\n                ...this.operation.hasTextureSize(this._width, this._height),\n                ...this.operation.displaysGraphics()\n            })\n\n            .declare('output2', flipY, {\n                ...this.operation.hasTextureSize(2 * this._width, 2 * this._height),\n                ...this.operation.displaysGraphics()\n            })\n\n            .declare('output3', flipY, {\n                ...this.operation.hasTextureSize(3 * this._width, 3 * this._height),\n                ...this.operation.displaysGraphics()\n            })\n\n\n            \n            // separable kernels for gaussian smoothing\n            // use [c, b, a, b, c] where a+2c = 2b and a+2b+2c = 1\n            // pick a = 0.4 for gaussian approximation\n            .declare('_smoothX', convX([\n                0.05, 0.25, 0.4, 0.25, 0.05\n            ]))\n            .declare('_smoothY', convY([\n                0.05, 0.25, 0.4, 0.25, 0.05\n            ]))\n\n            // smoothing for 2x image\n            // same rules as above with sum(k) = 2\n            .declare('_smoothX2', convX([\n                0.1, 0.5, 0.8, 0.5, 0.1\n            ]), this.operation.hasTextureSize(2 * this._width, 2 * this._height))\n\n            .declare('_smoothY2', convY([\n                0.1, 0.5, 0.8, 0.5, 0.1\n            ], 1.0 / 2.0), this.operation.hasTextureSize(2 * this._width, 2 * this._height))\n\n            // smoothing for 3x image\n            // use [1-b, b, 1, b, 1-b], where 0 < b < 1\n            .declare('_smoothX3', convX([\n                0.2, 0.8, 1.0, 0.8, 0.2\n            ]), this.operation.hasTextureSize(3 * this._width, 3 * this._height))\n\n            .declare('_smoothY3', convY([\n                0.2, 0.8, 1.0, 0.8, 0.2\n            ], 1.0 / 3.0), this.operation.hasTextureSize(3 * this._width, 3 * this._height))\n\n            // upsampling & downsampling\n            .declare('_upsample2', upsample2,\n                this.operation.hasTextureSize(2 * this._width, 2 * this._height))\n\n            .declare('_downsample2', downsample2,\n                this.operation.hasTextureSize((1 + this._width) / 2, (1 + this._height) / 2))\n\n            .declare('_upsample3', upsample3,\n                this.operation.hasTextureSize(3 * this._width, 3 * this._height))\n\n            .declare('_downsample3', downsample3,\n                this.operation.hasTextureSize((2 + this._width) / 3, (2 + this._height) / 3))\n\n            .declare('_downsample2/3', downsample2,\n                this.operation.hasTextureSize(3 * this._width / 2, 3 * this._height / 2))\n\n            .declare('_downsample3/2', downsample3,\n                this.operation.hasTextureSize(2 * this._width / 3, 2 * this._height / 3))\n\n            // adjust the scale coefficients\n            .declare('_scale2', scale(2.0, gpu.pyramidHeight, gpu.pyramidMaxScale),\n                this.operation.hasTextureSize(2 * this._width, 2 * this._height))\n\n            .declare('_scale1/2', scale(0.5, gpu.pyramidHeight, gpu.pyramidMaxScale),\n                this.operation.hasTextureSize((1 + this._width) / 2, (1 + this._height) / 2))\n\n            .declare('_scale3/2', scale(1.5, gpu.pyramidHeight, gpu.pyramidMaxScale),\n                this.operation.hasTextureSize(3 * this._width / 2, 3 * this._height / 2))\n\n            .declare('_scale2/3', scale(2.0 / 3.0, gpu.pyramidHeight, gpu.pyramidMaxScale),\n                this.operation.hasTextureSize(2 * this._width / 3, 2 * this._height / 3))\n        ;\n    }\n}\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * brisk.js\n * BRISK feature detection\n */\n\n/*\n * This implements a MODIFIED, GPU-based version\n * of the BRISK [1] feature detection algorithm\n * \n * Reference:\n * \n * [1] Leutenegger, Stefan; Chli, Margarita; Siegwart, Roland Y.\n *     \"BRISK: Binary robust invariant scalable keypoints\"\n *     International Conference on Computer Vision (ICCV-2011)\n */\nexport const brisk = (image, layerA, layerB, scaleA, scaleB, lgM, h) => require('./keypoint-detectors/brisk.glsl');","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * colors.js\n * Color conversions\n */\n\n// Convert to greyscale\nexport const rgb2grey = (image) => require('./colors/rgb2grey.glsl');","module.exports = \"const vec4 grey = vec4(0.299f, 0.587f, 0.114f, 0.0f);\\nuniform sampler2D image;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nfloat g = dot(pixel, grey);\\ncolor = vec4(g, g, g, 1.0f);\\n}\"","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * convolution.js\n * Convolution function generator\n */\n\nimport { Utils } from \"../../../utils/utils\";\nconst cartesian = (a, b) => [].concat(...a.map(a => b.map(b => [a,b]))); // [a] x [b]\nconst symmetricRange = n => [...Array(2*n + 1).keys()].map(x => x-n);    // [-n, ..., n]\n\n// Generate a 2D convolution with a square kernel\nexport function conv2D(kernel, normalizationConstant = 1.0)\n{\n    const kernel32 = new Float32Array(kernel.map(x => (+x) * (+normalizationConstant)));\n    const kSize = Math.sqrt(kernel32.length) | 0;\n    const N = (kSize / 2) | 0;\n\n    // validate input\n    if(kSize < 1 || kSize % 2 == 0)\n        Utils.fatal(`Can't perform a 2D convolution with an invalid kSize of ${kSize}`);\n    else if(kSize * kSize != kernel32.length)\n        Utils.fatal(`Invalid 2D convolution kernel of ${kernel32.length} elements (expected: square)`);\n\n    // code generator\n    const foreachKernelElement = fn => cartesian(symmetricRange(N), symmetricRange(N)).map(\n        cur => fn(\n            kernel32[(cur[0] + N) * kSize + (cur[1] + N)],\n            cur[0], cur[1]\n        )\n    ).join('\\n');\n\n    const generateCode = (k, dy, dx) => `\n        result += pixelAtOffset(image, ivec2(${dx | 0}, ${dy | 0})) * float(${+k});\n    `;\n\n    // shader\n    const shader = `\n    uniform sampler2D image;\n\n    void main()\n    {\n        float alpha = threadPixel(image).a;\n        vec4 result = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n\n        ${foreachKernelElement(generateCode)}\n\n        color = vec4(result.rgb, alpha);\n    }\n    `;\n\n    // done!\n    return (image) => shader;\n}\n\n// Generate a 1D convolution function on the x-axis\nexport function convX(kernel, normalizationConstant = 1.0)\n{\n    return conv1D('x', kernel, normalizationConstant);\n}\n\n// Generate a 1D convolution function on the y-axis\nexport function convY(kernel, normalizationConstant = 1.0)\n{\n    return conv1D('y', kernel, normalizationConstant);\n}\n\n// 1D convolution function generator\nfunction conv1D(axis, kernel, normalizationConstant)\n{\n    const kernel32 = new Float32Array(kernel.map(x => (+x) * (+normalizationConstant)));\n    const kSize = kernel32.length;\n    const N = (kSize / 2) | 0;\n\n    // validate input\n    if(kSize < 1 || kSize % 2 == 0)\n        Utils.fatal(`Can't perform a 1D convolution with an invalid kSize of ${kSize}`);\n    else if(axis != 'x' && axis != 'y')\n        Utils.fatal(`Can't perform 1D convolution: invalid axis \"${axis}\"`); // this should never happen\n\n    // code generator\n    const foreachKernelElement = fn => symmetricRange(N).reduce(\n        (acc, cur) => acc + fn(kernel32[cur + N], cur),\n    '');\n    const generateCode = (k, i) => ((axis == 'x') ? `\n        pixel += pixelAtOffset(image, ivec2(${i | 0}, 0)) * float(${+k});\n    ` : `\n        pixel += pixelAtOffset(image, ivec2(0, ${i | 0})) * float(${+k});\n    `);\n\n    // shader\n    const shader = `\n    uniform sampler2D image;\n\n    void main()\n    {\n        float alpha = threadPixel(image).a;\n        vec4 pixel = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n\n        ${foreachKernelElement(generateCode)}\n\n        color = vec4(pixel.rgb, alpha);\n    }\n    `;\n\n    // done!\n    return (image) => shader;\n}\n\n/*\n * ------------------------------------------------------------------\n * Texture Encoding\n * Encoding a float in [0,1] into RGB[A]\n * ------------------------------------------------------------------\n * Define frac(x) := x - floor(x)\n * Of course, 0 <= frac(x) < 1.\n * \n * Given: x in [0,1]\n * \n * Define e0 := floor(x),\n *        e1 := 256 frac(x)\n *        e2 := 256 frac(e1) = 256 frac(256 frac(x))\n *        e3 := 256 frac(e2) = 256 frac(256 frac(e1)) = 256 frac(256 frac(256 frac(x))),\n *        ...\n *        more generally,\n *        ej := 256 frac(e_{j-1}), j >= 2\n * \n * Since x = frac(x) + floor(x), it follows that\n * x = floor(x) + 256 frac(x) / 256 = e0 + e1 / 256 = e0 + (frac(e1) + floor(e1)) / 256 =\n * e0 + (256 frac(e1) + 256 floor(e1)) / (256^2) = e0 + (e2 + 256 floor(e1)) / (256^2) =\n * e0 + ((256 frac(e2) + 256 floor(e2)) + 256^2 floor(e1)) / (256^3) =\n * e0 + (e3 + 256 floor(e2) + 256^2 floor(e1)) / (256^3) = \n * floor(e0) + floor(e1) / 256 + floor(e2) / (256^2) + e3 / (256^3) = ... =\n * floor(e0) + floor(e1) / 256 + floor(e2) / (256^2) + floor(e3) / (256^3) + e4 / (256^4) = ... ~\n * \\sum_{i >= 0} floor(e_i) / 256^i\n * \n * Observe that e0 in {0, 1} and, for j >= 1, 0 <= e_j < 256, meaning that\n * e0 and (e_j / 256) can be stored in a 8-bit color channel.\n * \n * We now have approximations for x:\n * x ~ x0 <-- first order\n * x ~ x0 + x1 / 256 <-- second order\n * x ~ x0 + x1 / 256 + x2 / (256^2) <-- third order (RGB)\n * x ~ x0 + x1 / 256 + x2 / (256^2) + x3 / (256^3) <-- fourth order (RGBA)\n * where x_i = floor(e_i).\n */\n\n// Generate a texture-based 2D convolution kernel\n// of size (kernelSize x kernelSize), where all\n// entries belong to the [0, 1] range\nexport function createKernel2D(kernelSize)\n{\n    // validate input\n    kernelSize |= 0;\n    if(kernelSize < 1 || kernelSize % 2 == 0)\n        Utils.fatal(`Can't create a 2D texture kernel of size ${kernelSize}`);\n\n    // encode float in the [0,1] range to RGBA\n    const shader = `\n    uniform float kernel[${kernelSize * kernelSize}];\n\n    void main()\n    {\n        ivec2 thread = threadLocation();\n        float val = kernel[(${kernelSize}) * thread.y + thread.x];\n\n        float e0 = floor(val);\n        float e1 = 256.0f * fract(val);\n        float e2 = 256.0f * fract(e1);\n        float e3 = 256.0f * fract(e2);\n\n        color = vec4(e0, floor(e1) / 256.0f, floor(e2) / 256.0f, floor(e3) / 256.0f);\n    }\n    `;\n\n    // IMPORTANT: all entries of the input kernel\n    // are assumed to be in the [0, 1] range AND\n    // kernel.length >= kernelSize * kernelSize\n    //return new Function('arr', body);\n    return (kernel) => shader;\n}\n\n// Generate a texture-based 1D convolution kernel\n// of size (kernelSize x 1), where all entries\n// belong to the [0, 1] range\nexport function createKernel1D(kernelSize)\n{\n    // validate input\n    kernelSize |= 0;\n    if(kernelSize < 1 || kernelSize % 2 == 0)\n        Utils.fatal(`Can't create a 1D texture kernel of size ${kernelSize}`);\n\n    // encode float in the [0,1] range to RGBA\n    const shader = `\n    uniform float kernel[${kernelSize}];\n\n    void main()\n    {\n        ivec2 thread = threadLocation();\n        float val = kernel[thread.x];\n\n        float e0 = floor(val);\n        float e1 = 256.0f * fract(val);\n        float e2 = 256.0f * fract(e1);\n        float e3 = 256.0f * fract(e2);\n\n        color = vec4(e0, floor(e1) / 256.0f, floor(e2) / 256.0f, floor(e3) / 256.0f);\n    }\n    `;\n\n    // IMPORTANT: all entries of the input kernel\n    // are assumed to be in the [0, 1] range AND\n    // kernel.length >= kernelSize\n    //return new Function('arr', body);\n    return (kernel) => shader;\n}\n\n// 2D convolution with a texture-based kernel of size\n// kernelSize x kernelSize, with optional scale & offset\n// By default, scale and offset are 1 and 0, respectively\nexport function texConv2D(kernelSize)\n{\n    // validate input\n    const N = kernelSize >> 1; // idiv 2\n    if(kernelSize < 1 || kernelSize % 2 == 0)\n        Utils.fatal(`Can't perform a texture-based 2D convolution with an invalid kernel size of ${kernelSize}`);\n\n    // utilities\n    const foreachKernelElement = fn => cartesian(symmetricRange(N), symmetricRange(N)).map(\n        ij => fn(ij[0], ij[1])\n    ).join('\\n');\n\n    const generateCode = (i, j) => `\n        kernel = pixelAt(texKernel, ivec2(${i + N}, ${j + N}));\n        value = dot(kernel, magic) * scale + offset;\n        result += pixelAtOffset(image, ivec2(${i}, ${j})) * value;\n    `;\n\n    // image: target image\n    // texKernel: convolution kernel (all entries in [0,1])\n    // scale: multiply the kernel entries by a number (like 1.0)\n    // offset: add a number to all kernel entries (like 0.0)\n    const shader = `\n    const vec4 magic = vec4(1.0f, 1.0f, 1.0f / 256.0f, 1.0f / 65536.0f);\n    uniform sampler2D image, texKernel;\n    uniform float scale, offset;\n\n    void main()\n    {\n        vec4 kernel = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n        vec4 result = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n        float alpha = threadPixel(image).a;\n        float value = 0.0f;\n\n        ${foreachKernelElement(generateCode)}\n\n        result = clamp(result, 0.0f, 1.0f);\n        color = vec4(result.rgb, alpha);\n    }\n    `;\n\n    return (image, texKernel, scale, offset) => shader;\n}\n\n// identity operation with the same parameters as texConv2D()\nexport function idConv2D(kernelSize)\n{\n    return (image, texKernel, scale, offset) => `\n    uniform sampler2D image, texKernel;\n    uniform float scale, offset;\n\n    void main()\n    {\n        color = threadPixel(image);\n    }\n    `;\n}\n\n// Texture-based 1D convolution on the x-axis\nexport const texConvX = kernelSize => texConv1D(kernelSize, 'x');\n\n// Texture-based 1D convolution on the x-axis\nexport const texConvY = kernelSize => texConv1D(kernelSize, 'y');\n\n// texture-based 1D convolution function generator\n// (the convolution kernel is stored in a texture)\nfunction texConv1D(kernelSize, axis)\n{\n    // validate input\n    const N = kernelSize >> 1; // idiv 2\n    if(kernelSize < 1 || kernelSize % 2 == 0)\n        Utils.fatal(`Can't perform a texture-based 2D convolution with an invalid kernel size of ${kernelSize}`);\n    else if(axis != 'x' && axis != 'y')\n        Utils.fatal(`Can't perform a texture-based 1D convolution: invalid axis \"${axis}\"`); // this should never happen\n\n    // utilities\n    const foreachKernelElement = fn => symmetricRange(N).map(fn).join('\\n');\n    const generateCode = i => ((axis == 'x') ? `\n        kernel = pixelAt(texKernel, ivec2(${i + N}, 0));\n        value = dot(kernel, magic) * scale + offset;\n        result += pixelAtOffset(image, ivec2(${i}, 0)) * value;\n    ` : `\n        kernel = pixelAt(texKernel, ivec2(${i + N}, 0));\n        value = dot(kernel, magic) * scale + offset;\n        result += pixelAtOffset(image, ivec2(0, ${i})) * value;\n    `);\n\n    // image: target image\n    // texKernel: convolution kernel (all entries in [0,1])\n    // scale: multiply the kernel entries by a number (like 1.0)\n    // offset: add a number to all kernel entries (like 0.0)\n    const shader = `\n    const vec4 magic = vec4(1.0f, 1.0f, 1.0f / 256.0f, 1.0f / 65536.0f);\n    uniform sampler2D image, texKernel;\n    uniform float scale, offset;\n\n    void main()\n    {\n        vec4 kernel = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n        vec4 result = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n        float alpha = threadPixel(image).a;\n        float value = 0.0f;\n\n        ${foreachKernelElement(generateCode)}\n\n        result = clamp(result, 0.0f, 1.0f);\n        color = vec4(result.rgb, alpha);\n    }\n    `;\n\n    return (image, texKernel, scale, offset) => shader;\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * encoders.js\n * Speedy image encoding algorithms\n */\n\n// encode keypoint offsets: maxIterations is an integer in [1,255], determined experimentally\nexport const encodeKeypointOffsets = (image, imageSize, maxIterations) => require('./encoders/encode-keypoint-offsets.glsl');\n\n// encode keypoints\nexport const encodeKeypoints = (image, imageSize, encoderLength, descriptorSize) => require('./encoders/encode-keypoints.glsl');","module.exports = \"uniform sampler2D image;\\nuniform ivec2 imageSize;\\nuniform int maxIterations;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nivec2 pos = threadLocation();\\nint offset = -1;\\nwhile(offset < maxIterations && pos.y < imageSize.y && pixelAt(image, pos).r == 0.0f) {\\n++offset;\\npos.x = (pos.x + 1) % imageSize.x;\\npos.y += int(pos.x == 0);\\n}\\ncolor = vec4(pixel.rg, float(max(0, offset)) / 255.0f, pixel.a);\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform ivec2 imageSize;\\nuniform int encoderLength;\\nuniform int descriptorSize;\\nbool findQthKeypoint(int q, out ivec2 position, out vec4 pixel)\\n{\\nint i = 0, p = 0;\\nfor(position = ivec2(0, 0); position.y < imageSize.y; ) {\\npixel = pixelAt(image, position);\\nif(pixel.r > 0.0f) {\\nif(p++ == q)\\nreturn true;\\n}\\ni += 1 + int(pixel.b * 255.0f);\\nposition = ivec2(i % imageSize.x, i / imageSize.x);\\n}\\nreturn false;\\n}\\nvoid main()\\n{\\nvec4 pixel;\\nivec2 position;\\nivec2 thread = threadLocation();\\nint p = encoderLength * thread.y + thread.x;\\nint d = 2 + descriptorSize / 4;\\nint q = p / d;\\ncolor = vec4(1.0f, 1.0f, 1.0f, 1.0f);\\nif(findQthKeypoint(q, position, pixel)) {\\nint r = p % d;\\nswitch(r) {\\ncase 0: {\\nivec2 lo = position & 255;\\nivec2 hi = position >> 8;\\ncolor = vec4(float(lo.x), float(hi.x), float(lo.y), float(hi.y)) / 255.0f;\\nbreak;\\n}\\ncase 1: {\\nfloat scale = pixel.a;\\nfloat rotation = 0.0f;\\ncolor = vec4(scale, rotation, 0.0f, 0.0f);\\nbreak;\\n}\\ndefault: {\\nint i = r - 2;\\nbreak;\\n}\\n}\\n}\\n}\"","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * fast.js\n * FAST corner detection\n */\n\n/*\n * This is a GPU implementation of FAST,\n * \"Features from Accelerated Segment Test\" [1]\n *\n * Reference:\n *\n * [1] Rosten, Edward; Drummond, Tom.\n *     \"Machine learning for high-speed corner detection\"\n *     European Conference on Computer Vision (ECCV-2006)\n *\n */\n\n/*\n * Pixels are encoded as follows:\n *\n * R: \"cornerness\" score IF the pixel is a corner, 0 otherwise\n * G: pixel intensity (left untouched)\n * B: \"cornerness\" score regardless if the pixel is a corner or not\n *    (useful for other algorithms)\n * A: left untouched\n */\n\n// FAST-9_16: requires 9 contiguous pixels\n// on a circumference of 16 pixels\nexport const fast9 = (image, threshold) => require('./keypoint-detectors/fast9.glsl');\n\n// FAST-9,16 implementation based on Machine Learning\n// Adapted from New BSD Licensed fast_9.c code found at\n// https://github.com/edrosten/fast-C-src\nexport const fast9ml = (image, threshold) => require('./keypoint-detectors/fast9ml.glsl');\n\n// FAST-7_12: requires 7 contiguous pixels\n// on a circumference of 12 pixels\nexport const fast7 = (image, threshold) => require('./keypoint-detectors/fast7.glsl');\n\n// FAST-5_8: requires 5 contiguous pixels\n// on a circumference of 8 pixels\nexport const fast5 = (image, threshold) => require('./keypoint-detectors/fast5.glsl');\n\n// compute corner score considering a\n// neighboring circumference of 16 pixels\nexport const fastScore16 = (image, threshold) => require('./keypoint-detectors/fast-score16.glsl');\n\n// compute corner score considering a\n// neighboring circumference of 12 pixels\nexport const fastScore12 = (image, threshold) => require('./keypoint-detectors/fast-score12.glsl');\n\n// compute corner score considering a\n// neighboring circumference of 8 pixels\nexport const fastScore8 = (image, threshold) => require('./keypoint-detectors/fast-score8.glsl');\n\n// non-maximum suppression on 8-neighborhood based\n// on the corner score stored on the red channel\nexport const fastSuppression = image => require('./keypoint-detectors/fast-suppression.glsl');","var map = {\n\t\"./global.glsl\": \"./src/gpu/kernels/shaders/includes/global.glsl\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./src/gpu/kernels/shaders/includes sync recursive ^\\\\.\\\\/.*$\";","module.exports = \"#define threadLocation() ivec2(texCoord * texSize)\\n#define outputSize() ivec2(texSize)\\n#define threadPixel(img) textureLod((img), texCoord, 0.0f)\\n#define pixelAt(img, pos) texelFetch((img), (pos), 0)\\n#define pixelAtOffset(img, offset) textureLodOffset((img), texCoord, 0.0f, (offset))\"","module.exports = \"uniform sampler2D image, layerA, layerB;\\nuniform float scaleA, scaleB, lgM, h;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nfloat score = pixel.r;\\nivec2 zero = ivec2(0, 0);\\nivec2 sizeA = textureSize(layerA, 0);\\nivec2 sizeB = textureSize(layerB, 0);\\nvec2 mid = (texCoord * texSize) + vec2(0.5f, 0.5f);\\nivec2 pa = clamp(ivec2(ceil(mid * scaleA - 1.0f)), zero, sizeA - 2);\\nivec2 pb = clamp(ivec2(ceil(mid * scaleB - 1.0f)), zero, sizeB - 2);\\nvec4 a00 = pixelAt(layerA, pa);\\nvec4 a10 = pixelAt(layerA, pa + ivec2(1, 0));\\nvec4 a01 = pixelAt(layerA, pa + ivec2(0, 1));\\nvec4 a11 = pixelAt(layerA, pa + ivec2(1, 1));\\nvec4 b00 = pixelAt(layerB, pb);\\nvec4 b10 = pixelAt(layerB, pb + ivec2(1, 0));\\nvec4 b01 = pixelAt(layerB, pb + ivec2(0, 1));\\nvec4 b11 = pixelAt(layerB, pb + ivec2(1, 1));\\nfloat maxScore = max(\\nmax(max(a00.r, a10.r), max(a01.r, a11.r)),\\nmax(max(b00.r, b10.r), max(b01.r, b11.r))\\n);\\ncolor = vec4(0.0f, pixel.gba);\\nif(score < maxScore || score == 0.0f)\\nreturn;\\nvec2 ea = fract(mid * scaleA);\\nvec2 eb = fract(mid * scaleB);\\nfloat isa = a00.b * (1.0f - ea.x) * (1.0f - ea.y) +\\na10.b * ea.x * (1.0f - ea.y) +\\na01.b * (1.0f - ea.x) * ea.y +\\na11.b * ea.x * ea.y;\\nfloat isb = b00.b * (1.0f - eb.x) * (1.0f - eb.y) +\\nb10.b * eb.x * (1.0f - eb.y) +\\nb01.b * (1.0f - eb.x) * eb.y +\\nb11.b * eb.x * eb.y;\\nbool cond1 = (isa > score && isa > isb);\\nbool cond2 = (isb > score && isb > isa);\\ncolor = mix(\\nmix(\\npixel,\\nvec4(isb, pixel.gb, b00.a),\\nbvec4(cond2, cond2, cond2, cond2)\\n),\\nvec4(isa, pixel.gb, a00.a),\\nbvec4(cond1, cond1, cond1, cond1)\\n);\\nfloat y1 = isa, y2 = isb, y3 = score;\\nfloat x1 = lgM - (lgM + h) * a00.a;\\nfloat x2 = lgM - (lgM + h) * b00.a;\\nfloat x3 = lgM - (lgM + h) * pixel.a;\\nfloat dn = (x1 - x2) * (x1 - x3) * (x2 - x3);\\nif(abs(dn) < 0.00001f)\\nreturn;\\nfloat a = (x3 * (y2 - y1) + x2 * (y1 - y3) + x1 * (y3 - y2)) / dn;\\nif(a >= 0.0f)\\nreturn;\\nfloat b = (x3 * x3 * (y1 - y2) + x2 * x2 * (y3 - y1) + x1 * x1 * (y2 - y3)) / dn;\\nfloat c = (x2 * x3 * (x2 - x3) * y1 + x3 * x1 * (x3 - x1) * y2 + x1 * x2 * (x1 - x2) * y3) / dn;\\nfloat xv = -b / (2.0f * a);\\nfloat yv = c - (b * b) / (4.0f * a);\\nif(xv < min(x1, min(x2, x3)) || xv > max(x1, max(x2, x3)))\\nreturn;\\nfloat interpolatedScale = (lgM - xv) / (lgM + h);\\nfloat interpolatedScore = clamp(yv, 0.0f, 1.0f);\\ncolor = vec4(interpolatedScore, pixel.gb, interpolatedScale);\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform float threshold;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nfloat ifCorner = step(1.0f, pixel.r);\\nfloat t = clamp(threshold, 0.0f, 1.0f);\\nfloat c = pixel.g;\\nfloat ct = c + t, c_t = c - t;\\nfloat p0 = pixelAtOffset(image, ivec2(0, 2)).g;\\nfloat p1 = pixelAtOffset(image, ivec2(1, 2)).g;\\nfloat p2 = pixelAtOffset(image, ivec2(2, 1)).g;\\nfloat p3 = pixelAtOffset(image, ivec2(2, 0)).g;\\nfloat p4 = pixelAtOffset(image, ivec2(2, -1)).g;\\nfloat p5 = pixelAtOffset(image, ivec2(1, -2)).g;\\nfloat p6 = pixelAtOffset(image, ivec2(0, -2)).g;\\nfloat p7 = pixelAtOffset(image, ivec2(-1, -2)).g;\\nfloat p8 = pixelAtOffset(image, ivec2(-2, -1)).g;\\nfloat p9 = pixelAtOffset(image, ivec2(-2, 0)).g;\\nfloat p10 = pixelAtOffset(image, ivec2(-2, 1)).g;\\nfloat p11 = pixelAtOffset(image, ivec2(-1, 2)).g;\\nfloat bs = 0.0f, ds = 0.0f;\\nbs += max(c_t - p0, 0.0f);  ds += max(p0 - ct, 0.0f);\\nbs += max(c_t - p1, 0.0f);  ds += max(p1 - ct, 0.0f);\\nbs += max(c_t - p2, 0.0f);  ds += max(p2 - ct, 0.0f);\\nbs += max(c_t - p3, 0.0f);  ds += max(p3 - ct, 0.0f);\\nbs += max(c_t - p4, 0.0f);  ds += max(p4 - ct, 0.0f);\\nbs += max(c_t - p5, 0.0f);  ds += max(p5 - ct, 0.0f);\\nbs += max(c_t - p6, 0.0f);  ds += max(p6 - ct, 0.0f);\\nbs += max(c_t - p7, 0.0f);  ds += max(p7 - ct, 0.0f);\\nbs += max(c_t - p8, 0.0f);  ds += max(p8 - ct, 0.0f);\\nbs += max(c_t - p9, 0.0f);  ds += max(p9 - ct, 0.0f);\\nbs += max(c_t - p10, 0.0f); ds += max(p10 - ct, 0.0f);\\nbs += max(c_t - p11, 0.0f); ds += max(p11 - ct, 0.0f);\\nfloat score = max(bs, ds) / 12.0f;\\ncolor = vec4(score * ifCorner, pixel.g, score, pixel.a);\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform float threshold;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nfloat ifCorner = step(1.0f, pixel.r);\\nfloat t = clamp(threshold, 0.0f, 1.0f);\\nfloat c = pixel.g;\\nfloat ct = c + t, c_t = c - t;\\nfloat p0 = pixelAtOffset(image, ivec2(0, 3)).g;\\nfloat p1 = pixelAtOffset(image, ivec2(1, 3)).g;\\nfloat p2 = pixelAtOffset(image, ivec2(2, 2)).g;\\nfloat p3 = pixelAtOffset(image, ivec2(3, 1)).g;\\nfloat p4 = pixelAtOffset(image, ivec2(3, 0)).g;\\nfloat p5 = pixelAtOffset(image, ivec2(3, -1)).g;\\nfloat p6 = pixelAtOffset(image, ivec2(2, -2)).g;\\nfloat p7 = pixelAtOffset(image, ivec2(1, -3)).g;\\nfloat p8 = pixelAtOffset(image, ivec2(0, -3)).g;\\nfloat p9 = pixelAtOffset(image, ivec2(-1, -3)).g;\\nfloat p10 = pixelAtOffset(image, ivec2(-2, -2)).g;\\nfloat p11 = pixelAtOffset(image, ivec2(-3, -1)).g;\\nfloat p12 = pixelAtOffset(image, ivec2(-3, 0)).g;\\nfloat p13 = pixelAtOffset(image, ivec2(-3, 1)).g;\\nfloat p14 = pixelAtOffset(image, ivec2(-2, 2)).g;\\nfloat p15 = pixelAtOffset(image, ivec2(-1, 3)).g;\\nfloat bs = 0.0f, ds = 0.0f;\\nbs += max(c_t - p0, 0.0f);  ds += max(p0 - ct, 0.0f);\\nbs += max(c_t - p1, 0.0f);  ds += max(p1 - ct, 0.0f);\\nbs += max(c_t - p2, 0.0f);  ds += max(p2 - ct, 0.0f);\\nbs += max(c_t - p3, 0.0f);  ds += max(p3 - ct, 0.0f);\\nbs += max(c_t - p4, 0.0f);  ds += max(p4 - ct, 0.0f);\\nbs += max(c_t - p5, 0.0f);  ds += max(p5 - ct, 0.0f);\\nbs += max(c_t - p6, 0.0f);  ds += max(p6 - ct, 0.0f);\\nbs += max(c_t - p7, 0.0f);  ds += max(p7 - ct, 0.0f);\\nbs += max(c_t - p8, 0.0f);  ds += max(p8 - ct, 0.0f);\\nbs += max(c_t - p9, 0.0f);  ds += max(p9 - ct, 0.0f);\\nbs += max(c_t - p10, 0.0f); ds += max(p10 - ct, 0.0f);\\nbs += max(c_t - p11, 0.0f); ds += max(p11 - ct, 0.0f);\\nbs += max(c_t - p12, 0.0f); ds += max(p12 - ct, 0.0f);\\nbs += max(c_t - p13, 0.0f); ds += max(p13 - ct, 0.0f);\\nbs += max(c_t - p14, 0.0f); ds += max(p14 - ct, 0.0f);\\nbs += max(c_t - p15, 0.0f); ds += max(p15 - ct, 0.0f);\\nfloat score = max(bs, ds) / 16.0f;\\ncolor = vec4(score * ifCorner, pixel.g, score, pixel.a);\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform float threshold;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nfloat ifCorner = step(1.0f, pixel.r);\\nfloat t = clamp(threshold, 0.0f, 1.0f);\\nfloat c = pixel.g;\\nfloat ct = c + t, c_t = c - t;\\nfloat p0 = pixelAtOffset(image, ivec2(0, 1)).g;\\nfloat p1 = pixelAtOffset(image, ivec2(1, 1)).g;\\nfloat p2 = pixelAtOffset(image, ivec2(1, 0)).g;\\nfloat p3 = pixelAtOffset(image, ivec2(1, -1)).g;\\nfloat p4 = pixelAtOffset(image, ivec2(0, -1)).g;\\nfloat p5 = pixelAtOffset(image, ivec2(-1, -1)).g;\\nfloat p6 = pixelAtOffset(image, ivec2(-1, 0)).g;\\nfloat p7 = pixelAtOffset(image, ivec2(-1, 1)).g;\\nfloat bs = 0.0f, ds = 0.0f;\\nbs += max(c_t - p0, 0.0f); ds += max(p0 - ct, 0.0f);\\nbs += max(c_t - p1, 0.0f); ds += max(p1 - ct, 0.0f);\\nbs += max(c_t - p2, 0.0f); ds += max(p2 - ct, 0.0f);\\nbs += max(c_t - p3, 0.0f); ds += max(p3 - ct, 0.0f);\\nbs += max(c_t - p4, 0.0f); ds += max(p4 - ct, 0.0f);\\nbs += max(c_t - p5, 0.0f); ds += max(p5 - ct, 0.0f);\\nbs += max(c_t - p6, 0.0f); ds += max(p6 - ct, 0.0f);\\nbs += max(c_t - p7, 0.0f); ds += max(p7 - ct, 0.0f);\\nfloat score = max(bs, ds) / 8.0f;\\ncolor = vec4(score * ifCorner, pixel.g, score, pixel.a);\\n}\"","module.exports = \"uniform sampler2D image;\\nvoid main()\\n{\\nfloat p0 = pixelAtOffset(image, ivec2(0, 1)).r;\\nfloat p1 = pixelAtOffset(image, ivec2(1, 1)).r;\\nfloat p2 = pixelAtOffset(image, ivec2(1, 0)).r;\\nfloat p3 = pixelAtOffset(image, ivec2(1, -1)).r;\\nfloat p4 = pixelAtOffset(image, ivec2(0, -1)).r;\\nfloat p5 = pixelAtOffset(image, ivec2(-1, -1)).r;\\nfloat p6 = pixelAtOffset(image, ivec2(-1, 0)).r;\\nfloat p7 = pixelAtOffset(image, ivec2(-1, 1)).r;\\nfloat m = max(\\nmax(max(p0, p1), max(p2, p3)),\\nmax(max(p4, p5), max(p6, p7))\\n);\\nvec4 pixel = threadPixel(image);\\nfloat score = float(pixel.r >= m) * pixel.r;\\ncolor = vec4(score, pixel.gba);\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform float threshold;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nivec2 size = outputSize();\\nvec4 pixel = threadPixel(image);\\ncolor = vec4(0.0f, pixel.gba);\\nif(\\nthread.x >= 3 && thread.x < size.x - 3 &&\\nthread.y >= 3 && thread.y < size.y - 3\\n) {\\nfloat t = clamp(threshold, 0.0f, 1.0f);\\nfloat c = pixel.g;\\nfloat ct = c + t, c_t = c - t;\\nfloat p0 = pixelAtOffset(image, ivec2(0, 1)).g;\\nfloat p1 = pixelAtOffset(image, ivec2(1, 1)).g;\\nfloat p2 = pixelAtOffset(image, ivec2(1, 0)).g;\\nfloat p3 = pixelAtOffset(image, ivec2(1, -1)).g;\\nfloat p4 = pixelAtOffset(image, ivec2(0, -1)).g;\\nfloat p5 = pixelAtOffset(image, ivec2(-1, -1)).g;\\nfloat p6 = pixelAtOffset(image, ivec2(-1, 0)).g;\\nfloat p7 = pixelAtOffset(image, ivec2(-1, 1)).g;\\nbool possibleCorner =\\n((c_t > p1 || c_t > p5) && (c_t > p3 || c_t > p7)) ||\\n((ct < p1  || ct < p5)  && (ct < p3  || ct < p7))  ;\\nif(possibleCorner) {\\nint bright = 0, dark = 0, bc = 0, dc = 0;\\nif(c_t > p0) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p0) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p1) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p1) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p2) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p2) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p3) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p3) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p4) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p4) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p5) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p5) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p6) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p6) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p7) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p7) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(bright < 5 && dark < 5) {\\nif(bc > 0 && bc < 5) do {\\nif(c_t > p0)           bc += 1; else break;\\nif(c_t > p1 && bc < 5) bc += 1; else break;\\nif(c_t > p2 && bc < 5) bc += 1; else break;\\nif(c_t > p3 && bc < 5) bc += 1; else break;\\n} while(false);\\nif(dc > 0 && dc < 5) do {\\nif(ct < p0)           dc += 1; else break;\\nif(ct < p1 && dc < 5) dc += 1; else break;\\nif(ct < p2 && dc < 5) dc += 1; else break;\\nif(ct < p3 && dc < 5) dc += 1; else break;\\n} while(false);\\nif(bc >= 5 || dc >= 5)\\ncolor = vec4(1.0f, pixel.gba);\\n}\\nelse {\\ncolor = vec4(1.0f, pixel.gba);\\n}\\n}\\n}\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform float threshold;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nivec2 size = outputSize();\\nvec4 pixel = threadPixel(image);\\ncolor = vec4(0.0f, pixel.gba);\\nif(\\nthread.x >= 3 && thread.x < size.x - 3 &&\\nthread.y >= 3 && thread.y < size.y - 3\\n) {\\nfloat t = clamp(threshold, 0.0f, 1.0f);\\nfloat c = pixel.g;\\nfloat ct = c + t, c_t = c - t;\\nfloat p0 = pixelAtOffset(image, ivec2(0, 2)).g;\\nfloat p1 = pixelAtOffset(image, ivec2(1, 2)).g;\\nfloat p2 = pixelAtOffset(image, ivec2(2, 1)).g;\\nfloat p3 = pixelAtOffset(image, ivec2(2, 0)).g;\\nfloat p4 = pixelAtOffset(image, ivec2(2, -1)).g;\\nfloat p5 = pixelAtOffset(image, ivec2(1, -2)).g;\\nfloat p6 = pixelAtOffset(image, ivec2(0, -2)).g;\\nfloat p7 = pixelAtOffset(image, ivec2(-1, -2)).g;\\nfloat p8 = pixelAtOffset(image, ivec2(-2, -1)).g;\\nfloat p9 = pixelAtOffset(image, ivec2(-2, 0)).g;\\nfloat p10 = pixelAtOffset(image, ivec2(-2, 1)).g;\\nfloat p11 = pixelAtOffset(image, ivec2(-1, 2)).g;\\nbool possibleCorner =\\n((c_t > p0 || c_t > p6) && (c_t > p3 || c_t > p9)) ||\\n((ct < p0  || ct < p6)  && (ct < p3  || ct < p9))  ;\\nif(possibleCorner) {\\nint bright = 0, dark = 0, bc = 0, dc = 0;\\nif(c_t > p0) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p0) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p1) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p1) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p2) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p2) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p3) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p3) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p4) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p4) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p5) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p5) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p6) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p6) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p7) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p7) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p8) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p8) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p9) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p9) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p10) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p10) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p11) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p11) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(bright < 7 && dark < 7) {\\nif(bc > 0 && bc < 7) do {\\nif(c_t > p0)           bc += 1; else break;\\nif(c_t > p1 && bc < 7) bc += 1; else break;\\nif(c_t > p2 && bc < 7) bc += 1; else break;\\nif(c_t > p3 && bc < 7) bc += 1; else break;\\nif(c_t > p4 && bc < 7) bc += 1; else break;\\nif(c_t > p5 && bc < 7) bc += 1; else break;\\n} while(false);\\nif(dc > 0 && dc < 7) do {\\nif(ct < p0)           dc += 1; else break;\\nif(ct < p1 && dc < 7) dc += 1; else break;\\nif(ct < p2 && dc < 7) dc += 1; else break;\\nif(ct < p3 && dc < 7) dc += 1; else break;\\nif(ct < p4 && dc < 7) dc += 1; else break;\\nif(ct < p5 && dc < 7) dc += 1; else break;\\n} while(false);\\nif(bc >= 7 || dc >= 7)\\ncolor = vec4(1.0f, pixel.gba);\\n}\\nelse {\\ncolor = vec4(1.0f, pixel.gba);\\n}\\n}\\n}\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform float threshold;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nivec2 size = outputSize();\\nvec4 pixel = threadPixel(image);\\ncolor = vec4(0.0f, pixel.gba);\\nif(\\nthread.x >= 3 && thread.x < size.x - 3 &&\\nthread.y >= 3 && thread.y < size.y - 3\\n) {\\nfloat t = clamp(threshold, 0.0f, 1.0f);\\nfloat c = pixel.g;\\nfloat ct = c + t, c_t = c - t;\\nfloat p0 = pixelAtOffset(image, ivec2(0, 3)).g;\\nfloat p1 = pixelAtOffset(image, ivec2(1, 3)).g;\\nfloat p2 = pixelAtOffset(image, ivec2(2, 2)).g;\\nfloat p3 = pixelAtOffset(image, ivec2(3, 1)).g;\\nfloat p4 = pixelAtOffset(image, ivec2(3, 0)).g;\\nfloat p5 = pixelAtOffset(image, ivec2(3, -1)).g;\\nfloat p6 = pixelAtOffset(image, ivec2(2, -2)).g;\\nfloat p7 = pixelAtOffset(image, ivec2(1, -3)).g;\\nfloat p8 = pixelAtOffset(image, ivec2(0, -3)).g;\\nfloat p9 = pixelAtOffset(image, ivec2(-1, -3)).g;\\nfloat p10 = pixelAtOffset(image, ivec2(-2, -2)).g;\\nfloat p11 = pixelAtOffset(image, ivec2(-3, -1)).g;\\nfloat p12 = pixelAtOffset(image, ivec2(-3, 0)).g;\\nfloat p13 = pixelAtOffset(image, ivec2(-3, 1)).g;\\nfloat p14 = pixelAtOffset(image, ivec2(-2, 2)).g;\\nfloat p15 = pixelAtOffset(image, ivec2(-1, 3)).g;\\nbool possibleCorner =\\n((c_t > p0 || c_t > p8) && (c_t > p4 || c_t > p12)) ||\\n((ct < p0  || ct < p8)  && (ct < p4  || ct < p12))  ;\\nif(possibleCorner) {\\nint bright = 0, dark = 0, bc = 0, dc = 0;\\nif(c_t > p0) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p0) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p1) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p1) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p2) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p2) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p3) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p3) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p4) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p4) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p5) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p5) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p6) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p6) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p7) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p7) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p8) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p8) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p9) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p9) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p10) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p10) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p11) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p11) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p12) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p12) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p13) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p13) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p14) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p14) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p15) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p15) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(bright < 9 && dark < 9) {\\nif(bc > 0 && bc < 9) do {\\nif(c_t > p0)           bc += 1; else break;\\nif(c_t > p1 && bc < 9) bc += 1; else break;\\nif(c_t > p2 && bc < 9) bc += 1; else break;\\nif(c_t > p3 && bc < 9) bc += 1; else break;\\nif(c_t > p4 && bc < 9) bc += 1; else break;\\nif(c_t > p5 && bc < 9) bc += 1; else break;\\nif(c_t > p6 && bc < 9) bc += 1; else break;\\nif(c_t > p7 && bc < 9) bc += 1; else break;\\n} while(false);\\nif(dc > 0 && dc < 9) do {\\nif(ct < p0)           dc += 1; else break;\\nif(ct < p1 && dc < 9) dc += 1; else break;\\nif(ct < p2 && dc < 9) dc += 1; else break;\\nif(ct < p3 && dc < 9) dc += 1; else break;\\nif(ct < p4 && dc < 9) dc += 1; else break;\\nif(ct < p5 && dc < 9) dc += 1; else break;\\nif(ct < p6 && dc < 9) dc += 1; else break;\\nif(ct < p7 && dc < 9) dc += 1; else break;\\n} while(false);\\nif(bc >= 9 || dc >= 9)\\ncolor = vec4(1.0f, pixel.gba);\\n}\\nelse {\\ncolor = vec4(1.0f, pixel.gba);\\n}\\n}\\n}\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform float threshold;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nivec2 thread = threadLocation();\\nivec2 size = outputSize();\\ncolor = vec4(0.0f, pixel.gba);\\nif(thread.x < 3 || thread.y < 3 || thread.x >= size.x - 3 || thread.y >= size.y - 3)\\nreturn;\\nfloat t = clamp(threshold, 0.0f, 1.0f);\\nfloat c = pixel.g;\\nfloat ct = c + t, c_t = c - t;\\nfloat p0 = pixelAtOffset(image, ivec2(0, 3)).g;\\nfloat p4 = pixelAtOffset(image, ivec2(3, 0)).g;\\nfloat p8 = pixelAtOffset(image, ivec2(0, -3)).g;\\nfloat p12 = pixelAtOffset(image, ivec2(-3, 0)).g;\\nif(!(\\n((c_t > p0 || c_t > p8) && (c_t > p4 || c_t > p12)) ||\\n((ct < p0  || ct < p8)  && (ct < p4  || ct < p12))\\n))\\nreturn;\\nfloat p1 = pixelAtOffset(image, ivec2(1, 3)).g;\\nfloat p2 = pixelAtOffset(image, ivec2(2, 2)).g;\\nfloat p3 = pixelAtOffset(image, ivec2(3, 1)).g;\\nfloat p5 = pixelAtOffset(image, ivec2(3, -1)).g;\\nfloat p6 = pixelAtOffset(image, ivec2(2, -2)).g;\\nfloat p7 = pixelAtOffset(image, ivec2(1, -3)).g;\\nfloat p9 = pixelAtOffset(image, ivec2(-1, -3)).g;\\nfloat p10 = pixelAtOffset(image, ivec2(-2, -2)).g;\\nfloat p11 = pixelAtOffset(image, ivec2(-3, -1)).g;\\nfloat p13 = pixelAtOffset(image, ivec2(-3, 1)).g;\\nfloat p14 = pixelAtOffset(image, ivec2(-2, 2)).g;\\nfloat p15 = pixelAtOffset(image, ivec2(-1, 3)).g;\\nif(p0 > ct)\\nif(p1 > ct)\\nif(p2 > ct)\\nif(p3 > ct)\\nif(p4 > ct)\\nif(p5 > ct)\\nif(p6 > ct)\\nif(p7 > ct)\\nif(p8 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p15 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse if(p7 < c_t)\\nif(p14 > ct)\\nif(p15 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse if(p14 < c_t)\\nif(p8 < c_t)\\nif(p9 < c_t)\\nif(p10 < c_t)\\nif(p11 < c_t)\\nif(p12 < c_t)\\nif(p13 < c_t)\\nif(p15 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p14 > ct)\\nif(p15 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse if(p6 < c_t)\\nif(p15 > ct)\\nif(p13 > ct)\\nif(p14 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse if(p13 < c_t)\\nif(p7 < c_t)\\nif(p8 < c_t)\\nif(p9 < c_t)\\nif(p10 < c_t)\\nif(p11 < c_t)\\nif(p12 < c_t)\\nif(p14 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p7 < c_t)\\nif(p8 < c_t)\\nif(p9 < c_t)\\nif(p10 < c_t)\\nif(p11 < c_t)\\nif(p12 < c_t)\\nif(p13 < c_t)\\nif(p14 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p13 > ct)\\nif(p14 > ct)\\nif(p15 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse if(p13 < c_t)\\nif(p7 < c_t)\\nif(p8 < c_t)\\nif(p9 < c_t)\\nif(p10 < c_t)\\nif(p11 < c_t)\\nif(p12 < c_t)\\nif(p14 < c_t)\\nif(p15 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse if(p5 < c_t)\\nif(p14 > ct)\\nif(p12 > ct)\\nif(p13 > ct)\\nif(p15 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p6 > ct)\\nif(p7 > ct)\\nif(p8 > ct)\\nif(p9 > ct)\\nif(p10 > ct)\\nif(p11 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse if(p12 < c_t)\\nif(p6 < c_t)\\nif(p7 < c_t)\\nif(p8 < c_t)\\nif(p9 < c_t)\\nif(p10 < c_t)\\nif(p11 < c_t)\\nif(p13 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse if(p14 < c_t)\\nif(p7 < c_t)\\nif(p8 < c_t)\\nif(p9 < c_t)\\nif(p10 < c_t)\\nif(p11 < c_t)\\nif(p12 < c_t)\\nif(p13 < c_t)\\nif(p6 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p15 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p6 < c_t)\\nif(p7 < c_t)\\nif(p8 < c_t)\\nif(p9 < c_t)\\nif(p10 < c_t)\\nif(p11 < c_t)\\nif(p12 < c_t)\\nif(p13 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p12 > ct)\\nif(p13 > ct)\\nif(p14 > ct)\\nif(p15 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p6 > ct)\\nif(p7 > ct)\\nif(p8 > ct)\\nif(p9 > ct)\\nif(p10 > ct)\\nif(p11 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse if(p12 < c_t)\\nif(p7 < c_t)\\nif(p8 < c_t)\\nif(p9 < c_t)\\nif(p10 < c_t)\\nif(p11 < c_t)\\nif(p13 < c_t)\\nif(p14 < c_t)\\nif(p6 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p15 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse if(p4 < c_t)\\nif(p13 > ct)\\nif(p11 > ct)\\nif(p12 > ct)\\nif(p14 > ct)\\nif(p15 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p6 > ct)\\nif(p7 > ct)\\nif(p8 > ct)\\nif(p9 > ct)\\nif(p10 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p5 > ct)\\nif(p6 > ct)\\nif(p7 > ct)\\nif(p8 > ct)\\nif(p9 > ct)\\nif(p10 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse if(p11 < c_t)\\nif(p5 < c_t)\\nif(p6 < c_t)\\nif(p7 < c_t)\\nif(p8 < c_t)\\nif(p9 < c_t)\\nif(p10 < c_t)\\nif(p12 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse if(p13 < c_t)\\nif(p7 < c_t)\\nif(p8 < c_t)\\nif(p9 < c_t)\\nif(p10 < c_t)\\nif(p11 < c_t)\\nif(p12 < c_t)\\nif(p6 < c_t)\\nif(p5 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p14 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\nif(p14 < c_t)\\nif(p15 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p5 < c_t)\\nif(p6 < c_t)\\nif(p7 < c_t)\\nif(p8 < c_t)\\nif(p9 < c_t)\\nif(p10 < c_t)\\nif(p11 < c_t)\\nif(p12 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p11 > ct)\\nif(p12 > ct)\\nif(p13 > ct)\\nif(p14 > ct)\\nif(p15 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p6 > ct)\\nif(p7 > ct)\\nif(p8 > ct)\\nif(p9 > ct)\\nif(p10 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p5 > ct)\\nif(p6 > ct)\\nif(p7 > ct)\\nif(p8 > ct)\\nif(p9 > ct)\\nif(p10 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse if(p11 < c_t)\\nif(p7 < c_t)\\nif(p8 < c_t)\\nif(p9 < c_t)\\nif(p10 < c_t)\\nif(p12 < c_t)\\nif(p13 < c_t)\\nif(p6 < c_t)\\nif(p5 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p14 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\nif(p14 < c_t)\\nif(p15 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse if(p3 < c_t)\\nif(p10 > ct)\\nif(p11 > ct)\\nif(p12 > ct)\\nif(p13 > ct)\\nif(p14 > ct)\\nif(p15 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p6 > ct)\\nif(p7 > ct)\\nif(p8 > ct)\\nif(p9 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p5 > ct)\\nif(p6 > ct)\\nif(p7 > ct)\\nif(p8 > ct)\\nif(p9 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p4 > ct)\\nif(p5 > ct)\\nif(p6 > ct)\\nif(p7 > ct)\\nif(p8 > ct)\\nif(p9 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse if(p10 < c_t)\\nif(p7 < c_t)\\nif(p8 < c_t)\\nif(p9 < c_t)\\nif(p11 < c_t)\\nif(p6 < c_t)\\nif(p5 < c_t)\\nif(p4 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p12 < c_t)\\nif(p13 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\nif(p12 < c_t)\\nif(p13 < c_t)\\nif(p14 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p12 < c_t)\\nif(p13 < c_t)\\nif(p14 < c_t)\\nif(p15 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p10 > ct)\\nif(p11 > ct)\\nif(p12 > ct)\\nif(p13 > ct)\\nif(p14 > ct)\\nif(p15 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p6 > ct)\\nif(p7 > ct)\\nif(p8 > ct)\\nif(p9 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p5 > ct)\\nif(p6 > ct)\\nif(p7 > ct)\\nif(p8 > ct)\\nif(p9 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p4 > ct)\\nif(p5 > ct)\\nif(p6 > ct)\\nif(p7 > ct)\\nif(p8 > ct)\\nif(p9 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse if(p10 < c_t)\\nif(p7 < c_t)\\nif(p8 < c_t)\\nif(p9 < c_t)\\nif(p11 < c_t)\\nif(p12 < c_t)\\nif(p6 < c_t)\\nif(p5 < c_t)\\nif(p4 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p13 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\nif(p13 < c_t)\\nif(p14 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\nif(p13 < c_t)\\nif(p14 < c_t)\\nif(p15 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse if(p2 < c_t)\\nif(p9 > ct)\\nif(p10 > ct)\\nif(p11 > ct)\\nif(p12 > ct)\\nif(p13 > ct)\\nif(p14 > ct)\\nif(p15 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p6 > ct)\\nif(p7 > ct)\\nif(p8 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p5 > ct)\\nif(p6 > ct)\\nif(p7 > ct)\\nif(p8 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p4 > ct)\\nif(p5 > ct)\\nif(p6 > ct)\\nif(p7 > ct)\\nif(p8 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p3 > ct)\\nif(p4 > ct)\\nif(p5 > ct)\\nif(p6 > ct)\\nif(p7 > ct)\\nif(p8 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse if(p9 < c_t)\\nif(p7 < c_t)\\nif(p8 < c_t)\\nif(p10 < c_t)\\nif(p6 < c_t)\\nif(p5 < c_t)\\nif(p4 < c_t)\\nif(p3 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p11 < c_t)\\nif(p12 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\nif(p11 < c_t)\\nif(p12 < c_t)\\nif(p13 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p11 < c_t)\\nif(p12 < c_t)\\nif(p13 < c_t)\\nif(p14 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p11 < c_t)\\nif(p12 < c_t)\\nif(p13 < c_t)\\nif(p14 < c_t)\\nif(p15 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p9 > ct)\\nif(p10 > ct)\\nif(p11 > ct)\\nif(p12 > ct)\\nif(p13 > ct)\\nif(p14 > ct)\\nif(p15 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p6 > ct)\\nif(p7 > ct)\\nif(p8 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p5 > ct)\\nif(p6 > ct)\\nif(p7 > ct)\\nif(p8 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p4 > ct)\\nif(p5 > ct)\\nif(p6 > ct)\\nif(p7 > ct)\\nif(p8 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p3 > ct)\\nif(p4 > ct)\\nif(p5 > ct)\\nif(p6 > ct)\\nif(p7 > ct)\\nif(p8 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse if(p9 < c_t)\\nif(p7 < c_t)\\nif(p8 < c_t)\\nif(p10 < c_t)\\nif(p11 < c_t)\\nif(p6 < c_t)\\nif(p5 < c_t)\\nif(p4 < c_t)\\nif(p3 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p12 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\nif(p12 < c_t)\\nif(p13 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\nif(p12 < c_t)\\nif(p13 < c_t)\\nif(p14 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p12 < c_t)\\nif(p13 < c_t)\\nif(p14 < c_t)\\nif(p15 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse if(p1 < c_t)\\nif(p8 > ct)\\nif(p9 > ct)\\nif(p10 > ct)\\nif(p11 > ct)\\nif(p12 > ct)\\nif(p13 > ct)\\nif(p14 > ct)\\nif(p15 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p6 > ct)\\nif(p7 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\nif(p5 > ct)\\nif(p6 > ct)\\nif(p7 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p4 > ct)\\nif(p5 > ct)\\nif(p6 > ct)\\nif(p7 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p3 > ct)\\nif(p4 > ct)\\nif(p5 > ct)\\nif(p6 > ct)\\nif(p7 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p2 > ct)\\nif(p3 > ct)\\nif(p4 > ct)\\nif(p5 > ct)\\nif(p6 > ct)\\nif(p7 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse if(p8 < c_t)\\nif(p7 < c_t)\\nif(p9 < c_t)\\nif(p6 < c_t)\\nif(p5 < c_t)\\nif(p4 < c_t)\\nif(p3 < c_t)\\nif(p2 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p10 < c_t)\\nif(p11 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\nif(p10 < c_t)\\nif(p11 < c_t)\\nif(p12 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p10 < c_t)\\nif(p11 < c_t)\\nif(p12 < c_t)\\nif(p13 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p10 < c_t)\\nif(p11 < c_t)\\nif(p12 < c_t)\\nif(p13 < c_t)\\nif(p14 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p10 < c_t)\\nif(p11 < c_t)\\nif(p12 < c_t)\\nif(p13 < c_t)\\nif(p14 < c_t)\\nif(p15 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p8 > ct)\\nif(p9 > ct)\\nif(p10 > ct)\\nif(p11 > ct)\\nif(p12 > ct)\\nif(p13 > ct)\\nif(p14 > ct)\\nif(p15 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p6 > ct)\\nif(p7 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\nif(p5 > ct)\\nif(p6 > ct)\\nif(p7 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p4 > ct)\\nif(p5 > ct)\\nif(p6 > ct)\\nif(p7 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p3 > ct)\\nif(p4 > ct)\\nif(p5 > ct)\\nif(p6 > ct)\\nif(p7 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p2 > ct)\\nif(p3 > ct)\\nif(p4 > ct)\\nif(p5 > ct)\\nif(p6 > ct)\\nif(p7 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse if(p8 < c_t)\\nif(p7 < c_t)\\nif(p9 < c_t)\\nif(p10 < c_t)\\nif(p6 < c_t)\\nif(p5 < c_t)\\nif(p4 < c_t)\\nif(p3 < c_t)\\nif(p2 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p11 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\nif(p11 < c_t)\\nif(p12 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\nif(p11 < c_t)\\nif(p12 < c_t)\\nif(p13 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p11 < c_t)\\nif(p12 < c_t)\\nif(p13 < c_t)\\nif(p14 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p11 < c_t)\\nif(p12 < c_t)\\nif(p13 < c_t)\\nif(p14 < c_t)\\nif(p15 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse if(p0 < c_t)\\nif(p1 > ct)\\nif(p8 > ct)\\nif(p7 > ct)\\nif(p9 > ct)\\nif(p6 > ct)\\nif(p5 > ct)\\nif(p4 > ct)\\nif(p3 > ct)\\nif(p2 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p10 > ct)\\nif(p11 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\nif(p10 > ct)\\nif(p11 > ct)\\nif(p12 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p10 > ct)\\nif(p11 > ct)\\nif(p12 > ct)\\nif(p13 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p10 > ct)\\nif(p11 > ct)\\nif(p12 > ct)\\nif(p13 > ct)\\nif(p14 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p10 > ct)\\nif(p11 > ct)\\nif(p12 > ct)\\nif(p13 > ct)\\nif(p14 > ct)\\nif(p15 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse if(p8 < c_t)\\nif(p9 < c_t)\\nif(p10 < c_t)\\nif(p11 < c_t)\\nif(p12 < c_t)\\nif(p13 < c_t)\\nif(p14 < c_t)\\nif(p15 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p6 < c_t)\\nif(p7 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\nif(p5 < c_t)\\nif(p6 < c_t)\\nif(p7 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p4 < c_t)\\nif(p5 < c_t)\\nif(p6 < c_t)\\nif(p7 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p3 < c_t)\\nif(p4 < c_t)\\nif(p5 < c_t)\\nif(p6 < c_t)\\nif(p7 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p2 < c_t)\\nif(p3 < c_t)\\nif(p4 < c_t)\\nif(p5 < c_t)\\nif(p6 < c_t)\\nif(p7 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse if(p1 < c_t)\\nif(p2 > ct)\\nif(p9 > ct)\\nif(p7 > ct)\\nif(p8 > ct)\\nif(p10 > ct)\\nif(p6 > ct)\\nif(p5 > ct)\\nif(p4 > ct)\\nif(p3 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p11 > ct)\\nif(p12 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\nif(p11 > ct)\\nif(p12 > ct)\\nif(p13 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p11 > ct)\\nif(p12 > ct)\\nif(p13 > ct)\\nif(p14 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p11 > ct)\\nif(p12 > ct)\\nif(p13 > ct)\\nif(p14 > ct)\\nif(p15 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse if(p9 < c_t)\\nif(p10 < c_t)\\nif(p11 < c_t)\\nif(p12 < c_t)\\nif(p13 < c_t)\\nif(p14 < c_t)\\nif(p15 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p6 < c_t)\\nif(p7 < c_t)\\nif(p8 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p5 < c_t)\\nif(p6 < c_t)\\nif(p7 < c_t)\\nif(p8 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p4 < c_t)\\nif(p5 < c_t)\\nif(p6 < c_t)\\nif(p7 < c_t)\\nif(p8 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p3 < c_t)\\nif(p4 < c_t)\\nif(p5 < c_t)\\nif(p6 < c_t)\\nif(p7 < c_t)\\nif(p8 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse if(p2 < c_t)\\nif(p3 > ct)\\nif(p10 > ct)\\nif(p7 > ct)\\nif(p8 > ct)\\nif(p9 > ct)\\nif(p11 > ct)\\nif(p6 > ct)\\nif(p5 > ct)\\nif(p4 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p12 > ct)\\nif(p13 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\nif(p12 > ct)\\nif(p13 > ct)\\nif(p14 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p12 > ct)\\nif(p13 > ct)\\nif(p14 > ct)\\nif(p15 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse if(p10 < c_t)\\nif(p11 < c_t)\\nif(p12 < c_t)\\nif(p13 < c_t)\\nif(p14 < c_t)\\nif(p15 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p6 < c_t)\\nif(p7 < c_t)\\nif(p8 < c_t)\\nif(p9 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p5 < c_t)\\nif(p6 < c_t)\\nif(p7 < c_t)\\nif(p8 < c_t)\\nif(p9 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p4 < c_t)\\nif(p5 < c_t)\\nif(p6 < c_t)\\nif(p7 < c_t)\\nif(p8 < c_t)\\nif(p9 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse if(p3 < c_t)\\nif(p4 > ct)\\nif(p13 > ct)\\nif(p7 > ct)\\nif(p8 > ct)\\nif(p9 > ct)\\nif(p10 > ct)\\nif(p11 > ct)\\nif(p12 > ct)\\nif(p6 > ct)\\nif(p5 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p14 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\nif(p14 > ct)\\nif(p15 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse if(p13 < c_t)\\nif(p11 > ct)\\nif(p5 > ct)\\nif(p6 > ct)\\nif(p7 > ct)\\nif(p8 > ct)\\nif(p9 > ct)\\nif(p10 > ct)\\nif(p12 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse if(p11 < c_t)\\nif(p12 < c_t)\\nif(p14 < c_t)\\nif(p15 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p6 < c_t)\\nif(p7 < c_t)\\nif(p8 < c_t)\\nif(p9 < c_t)\\nif(p10 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p5 < c_t)\\nif(p6 < c_t)\\nif(p7 < c_t)\\nif(p8 < c_t)\\nif(p9 < c_t)\\nif(p10 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p5 > ct)\\nif(p6 > ct)\\nif(p7 > ct)\\nif(p8 > ct)\\nif(p9 > ct)\\nif(p10 > ct)\\nif(p11 > ct)\\nif(p12 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse if(p4 < c_t)\\nif(p5 > ct)\\nif(p14 > ct)\\nif(p7 > ct)\\nif(p8 > ct)\\nif(p9 > ct)\\nif(p10 > ct)\\nif(p11 > ct)\\nif(p12 > ct)\\nif(p13 > ct)\\nif(p6 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p15 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse if(p14 < c_t)\\nif(p12 > ct)\\nif(p6 > ct)\\nif(p7 > ct)\\nif(p8 > ct)\\nif(p9 > ct)\\nif(p10 > ct)\\nif(p11 > ct)\\nif(p13 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse if(p12 < c_t)\\nif(p13 < c_t)\\nif(p15 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p6 < c_t)\\nif(p7 < c_t)\\nif(p8 < c_t)\\nif(p9 < c_t)\\nif(p10 < c_t)\\nif(p11 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p6 > ct)\\nif(p7 > ct)\\nif(p8 > ct)\\nif(p9 > ct)\\nif(p10 > ct)\\nif(p11 > ct)\\nif(p12 > ct)\\nif(p13 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse if(p5 < c_t)\\nif(p6 > ct)\\nif(p15 < c_t)\\nif(p13 > ct)\\nif(p7 > ct)\\nif(p8 > ct)\\nif(p9 > ct)\\nif(p10 > ct)\\nif(p11 > ct)\\nif(p12 > ct)\\nif(p14 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse if(p13 < c_t)\\nif(p14 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\nif(p7 > ct)\\nif(p8 > ct)\\nif(p9 > ct)\\nif(p10 > ct)\\nif(p11 > ct)\\nif(p12 > ct)\\nif(p13 > ct)\\nif(p14 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse if(p6 < c_t)\\nif(p7 > ct)\\nif(p14 > ct)\\nif(p8 > ct)\\nif(p9 > ct)\\nif(p10 > ct)\\nif(p11 > ct)\\nif(p12 > ct)\\nif(p13 > ct)\\nif(p15 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse if(p14 < c_t)\\nif(p15 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse if(p7 < c_t)\\nif(p8 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p15 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\nif(p14 < c_t)\\nif(p15 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\nif(p13 > ct)\\nif(p7 > ct)\\nif(p8 > ct)\\nif(p9 > ct)\\nif(p10 > ct)\\nif(p11 > ct)\\nif(p12 > ct)\\nif(p14 > ct)\\nif(p15 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse if(p13 < c_t)\\nif(p14 < c_t)\\nif(p15 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p12 > ct)\\nif(p7 > ct)\\nif(p8 > ct)\\nif(p9 > ct)\\nif(p10 > ct)\\nif(p11 > ct)\\nif(p13 > ct)\\nif(p14 > ct)\\nif(p6 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p15 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse if(p12 < c_t)\\nif(p13 < c_t)\\nif(p14 < c_t)\\nif(p15 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p6 < c_t)\\nif(p7 < c_t)\\nif(p8 < c_t)\\nif(p9 < c_t)\\nif(p10 < c_t)\\nif(p11 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p11 > ct)\\nif(p7 > ct)\\nif(p8 > ct)\\nif(p9 > ct)\\nif(p10 > ct)\\nif(p12 > ct)\\nif(p13 > ct)\\nif(p6 > ct)\\nif(p5 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p14 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\nif(p14 > ct)\\nif(p15 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse if(p11 < c_t)\\nif(p12 < c_t)\\nif(p13 < c_t)\\nif(p14 < c_t)\\nif(p15 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p6 < c_t)\\nif(p7 < c_t)\\nif(p8 < c_t)\\nif(p9 < c_t)\\nif(p10 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p5 < c_t)\\nif(p6 < c_t)\\nif(p7 < c_t)\\nif(p8 < c_t)\\nif(p9 < c_t)\\nif(p10 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p10 > ct)\\nif(p7 > ct)\\nif(p8 > ct)\\nif(p9 > ct)\\nif(p11 > ct)\\nif(p12 > ct)\\nif(p6 > ct)\\nif(p5 > ct)\\nif(p4 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p13 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\nif(p13 > ct)\\nif(p14 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\nif(p13 > ct)\\nif(p14 > ct)\\nif(p15 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse if(p10 < c_t)\\nif(p11 < c_t)\\nif(p12 < c_t)\\nif(p13 < c_t)\\nif(p14 < c_t)\\nif(p15 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p6 < c_t)\\nif(p7 < c_t)\\nif(p8 < c_t)\\nif(p9 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p5 < c_t)\\nif(p6 < c_t)\\nif(p7 < c_t)\\nif(p8 < c_t)\\nif(p9 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p4 < c_t)\\nif(p5 < c_t)\\nif(p6 < c_t)\\nif(p7 < c_t)\\nif(p8 < c_t)\\nif(p9 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p9 > ct)\\nif(p7 > ct)\\nif(p8 > ct)\\nif(p10 > ct)\\nif(p11 > ct)\\nif(p6 > ct)\\nif(p5 > ct)\\nif(p4 > ct)\\nif(p3 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p12 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\nif(p12 > ct)\\nif(p13 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\nif(p12 > ct)\\nif(p13 > ct)\\nif(p14 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p12 > ct)\\nif(p13 > ct)\\nif(p14 > ct)\\nif(p15 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse if(p9 < c_t)\\nif(p10 < c_t)\\nif(p11 < c_t)\\nif(p12 < c_t)\\nif(p13 < c_t)\\nif(p14 < c_t)\\nif(p15 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p6 < c_t)\\nif(p7 < c_t)\\nif(p8 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p5 < c_t)\\nif(p6 < c_t)\\nif(p7 < c_t)\\nif(p8 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p4 < c_t)\\nif(p5 < c_t)\\nif(p6 < c_t)\\nif(p7 < c_t)\\nif(p8 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p3 < c_t)\\nif(p4 < c_t)\\nif(p5 < c_t)\\nif(p6 < c_t)\\nif(p7 < c_t)\\nif(p8 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p8 > ct)\\nif(p7 > ct)\\nif(p9 > ct)\\nif(p10 > ct)\\nif(p6 > ct)\\nif(p5 > ct)\\nif(p4 > ct)\\nif(p3 > ct)\\nif(p2 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p11 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\nif(p11 > ct)\\nif(p12 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\nif(p11 > ct)\\nif(p12 > ct)\\nif(p13 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p11 > ct)\\nif(p12 > ct)\\nif(p13 > ct)\\nif(p14 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p11 > ct)\\nif(p12 > ct)\\nif(p13 > ct)\\nif(p14 > ct)\\nif(p15 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse if(p8 < c_t)\\nif(p9 < c_t)\\nif(p10 < c_t)\\nif(p11 < c_t)\\nif(p12 < c_t)\\nif(p13 < c_t)\\nif(p14 < c_t)\\nif(p15 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p6 < c_t)\\nif(p7 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\nif(p5 < c_t)\\nif(p6 < c_t)\\nif(p7 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p4 < c_t)\\nif(p5 < c_t)\\nif(p6 < c_t)\\nif(p7 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p3 < c_t)\\nif(p4 < c_t)\\nif(p5 < c_t)\\nif(p6 < c_t)\\nif(p7 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p2 < c_t)\\nif(p3 < c_t)\\nif(p4 < c_t)\\nif(p5 < c_t)\\nif(p6 < c_t)\\nif(p7 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p7 > ct)\\nif(p8 > ct)\\nif(p9 > ct)\\nif(p6 > ct)\\nif(p5 > ct)\\nif(p4 > ct)\\nif(p3 > ct)\\nif(p2 > ct)\\nif(p1 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p10 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\nif(p10 > ct)\\nif(p11 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\nif(p10 > ct)\\nif(p11 > ct)\\nif(p12 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p10 > ct)\\nif(p11 > ct)\\nif(p12 > ct)\\nif(p13 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p10 > ct)\\nif(p11 > ct)\\nif(p12 > ct)\\nif(p13 > ct)\\nif(p14 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p10 > ct)\\nif(p11 > ct)\\nif(p12 > ct)\\nif(p13 > ct)\\nif(p14 > ct)\\nif(p15 > ct)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse if(p7 < c_t)\\nif(p8 < c_t)\\nif(p9 < c_t)\\nif(p6 < c_t)\\nif(p5 < c_t)\\nif(p4 < c_t)\\nif(p3 < c_t)\\nif(p2 < c_t)\\nif(p1 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\nif(p10 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\nif(p10 < c_t)\\nif(p11 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\nif(p10 < c_t)\\nif(p11 < c_t)\\nif(p12 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p10 < c_t)\\nif(p11 < c_t)\\nif(p12 < c_t)\\nif(p13 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p10 < c_t)\\nif(p11 < c_t)\\nif(p12 < c_t)\\nif(p13 < c_t)\\nif(p14 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\nif(p10 < c_t)\\nif(p11 < c_t)\\nif(p12 < c_t)\\nif(p13 < c_t)\\nif(p14 < c_t)\\nif(p15 < c_t)\\ncolor = vec4(1.0f, pixel.gba);\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\nelse\\n;\\n}\"","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * pyramids.js\n * Image pyramids & scale-space utilities\n */\n\n// pyramid generation\nexport const upsample2 = image => require('./pyramids/upsample2.glsl');\nexport const downsample2 = image => require('./pyramids/downsample2.glsl');\nexport const upsample3 = image => require('./pyramids/upsample3.glsl');\nexport const downsample3 = image => require('./pyramids/downsample3.glsl');\n\n// utilities for merging keypoints across multiple scales\nexport const mergeKeypoints = (target, source) => require('./pyramids/merge-keypoints.glsl');\nexport const mergeKeypointsAtConsecutiveLevels = (largerImage, smallerImage) => require('./pyramids/merge-keypoints-at-consecutive-levels.glsl');\nexport const normalizeKeypoints = (image, imageScale) => require('./pyramids/normalize-keypoints.glsl');\n\n// misc\nexport const crop = image => require('./pyramids/crop.glsl');\n\n// image scale\n\n/*\n * Image scale is encoded in the alpha channel (a)\n * according to the following model:\n *\n * a(x) = (log2(M) - log2(x)) / (log2(M) + h)\n *\n * where x := scale of the image in the pyramid\n *            it may be 1, 0.5, 0.25, 0.125...\n *            also 1.5, 0.75, 0.375... (intra-layers)\n *\n *       h := height (depth) of the pyramid, an integer\n *\n *       M := scale upper bound: the maximum supported\n *            scale x for a pyramid layer, a constant\n *            that is preferably a power of two\n *            (e.g., M = 2)\n *\n *\n *\n * This model has some neat properties:\n *\n * Scale image by factor s:\n * a(s*x) = a(x) - log2(s) / (log2(M) + h)\n *\n * Log of scale (scale-axis):\n * log2(x) = log2(M) - (log2(M) + h) * a(x)\n *\n * Bounded output:\n * 0 <= a(x) < 1\n *\n * Since x <= M, it follows that a(x) >= 0 for all x\n * Since x > 1/2^h, it follows that a(x) < 1 for all x\n * Thus, if alpha channel = 1.0, we have no scale data\n *\n *\n *\n * A note on image scale:\n *\n * scale = 1 means an image with its original size\n * scale = 2 means double the size (4x the area)\n * scale = 0.5 means half the size (1/4 the area)\n * and so on...\n */\n\nexport function setScale(scale, pyramidHeight, pyramidMaxScale)\n{\n    const lgM = Math.log2(pyramidMaxScale), eps = 1e-5;\n    const pyramidMinScale = Math.pow(2, -pyramidHeight) + eps;\n    const x = Math.max(pyramidMinScale, Math.min(scale, pyramidMaxScale));\n    const alpha = (lgM - Math.log2(x)) / (lgM + pyramidHeight);\n\n    return (image) => `\n    uniform sampler2D image;\n\n    void main()\n    {\n        color = vec4(threadPixel(image).rgb, float(${alpha}));\n    }\n    `;\n}\n\nexport function scale(scaleFactor, pyramidHeight, pyramidMaxScale)\n{\n    const lgM = Math.log2(pyramidMaxScale);\n    const s = Math.max(1e-5, scaleFactor);\n    const delta = -Math.log2(s) / (lgM + pyramidHeight);\n\n    return (image) => `\n    uniform sampler2D image;\n\n    void main()\n    {\n        vec4 pixel = threadPixel(image);\n        float alpha = clamp(pixel.a + float(${delta}), 0.0f, 1.0f);\n\n        color = vec4(pixel.rgb, alpha);\n    }\n    `;\n}","module.exports = \"uniform sampler2D image;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nivec2 size = outputSize();\\nivec2 zero = ivec2(0, 0);\\ncolor = pixelAt(image, clamp(thread, zero, size - 1));\\n}\"","module.exports = \"uniform sampler2D image;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nivec2 pos = min(thread * 2, textureSize(image, 0) - 1);\\ncolor = pixelAt(image, pos);\\n}\"","module.exports = \"uniform sampler2D image;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nivec2 pos = min(thread * 3, textureSize(image, 0) - 1);\\ncolor = pixelAt(image, pos);\\n}\"","module.exports = \"uniform sampler2D largerImage;\\nuniform sampler2D smallerImage;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nvec4 lg = pixelAt(largerImage, min(thread, textureSize(largerImage, 0) - 1));\\nvec4 sm = pixelAt(smallerImage, min(thread / 2, textureSize(smallerImage, 0) - 1));\\nbool cond = (((thread.x & 1) + (thread.y & 1)) == 0) && (sm.r > lg.r);\\ncolor = mix(\\nlg,\\nvec4(sm.r, lg.gb, sm.a),\\nbvec4(cond, cond, cond, cond)\\n);\\n}\"","module.exports = \"uniform sampler2D target;\\nuniform sampler2D source;\\nvoid main()\\n{\\nvec4 a = threadPixel(target);\\nvec4 b = threadPixel(source);\\nbool cond = (b.r > a.r);\\ncolor = mix(\\na,\\nvec4(b.r, a.gb, b.a),\\nbvec4(cond, cond, cond, cond)\\n);\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform float imageScale;\\n#define B2(expr) bvec2((expr),(expr))\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nivec2 size = outputSize();\\nivec2 scaled = ivec2((texCoord * texSize) * imageScale);\\nivec2 imageSize = textureSize(image, 0);\\nvec4 pixel = threadPixel(image);\\nvec4 p0 = pixelAt(image, min(scaled, imageSize-1));\\nvec4 p1 = pixelAt(image, min(scaled + ivec2(0, 1), imageSize-1));\\nvec4 p2 = pixelAt(image, min(scaled + ivec2(1, 0), imageSize-1));\\nvec4 p3 = pixelAt(image, min(scaled + ivec2(1, 1), imageSize-1));\\nbool gotCorner = ((thread.x & 1) + (thread.y & 1) == 0) &&\\n(scaled.x + 1 < size.x && scaled.y + 1 < size.y) &&\\n(p0.r + p1.r + p2.r + p3.r > 0.0f);\\nvec2 best = mix(\\nvec2(0.0f, pixel.a),\\nmix(\\nmix(\\nmix(p3.ra, p1.ra, B2(p1.r > p3.r)),\\nmix(p2.ra, p1.ra, B2(p1.r > p2.r)),\\nB2(p2.r > p3.r)\\n),\\nmix(\\nmix(p3.ra, p0.ra, B2(p0.r > p3.r)),\\nmix(p2.ra, p0.ra, B2(p0.r > p2.r)),\\nB2(p2.r > p3.r)\\n),\\nB2(p0.r > p1.r)\\n),\\nB2(gotCorner)\\n);\\ncolor = vec4(best.x, pixel.gb, best.y);\\n}\"","module.exports = \"uniform sampler2D image;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nvec4 pixel = pixelAt(image, thread / 2);\\nbool cond = (((thread.x + thread.y) & 1) == 0);\\ncolor = mix(\\nvec4(0.0f, 0.0f, 0.0f, pixel.a),\\npixel,\\nbvec4(cond, cond, cond, cond)\\n);\\n}\"","module.exports = \"uniform sampler2D image;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nvec4 pixel = pixelAt(image, thread / 3);\\nbool cond = ((thread.x - (thread.y % 3) + 3) % 3) == 0;\\ncolor = mix(\\nvec4(0.0f, 0.0f, 0.0f, pixel.a),\\npixel,\\nbvec4(cond, cond, cond, cond)\\n);\\n}\"","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * utils.js\n * Utility shaders\n */\n\n// Identity shader: no-operation\nexport const identity = (image) => require('./utils/identity.glsl');\n\n// Flip y-axis for output\nexport const flipY = (image) => require('./utils/flip-y.glsl');","module.exports = \"uniform sampler2D image;\\nvoid main() {\\nivec2 pos = threadLocation();\\npos.y = int(texSize.y) - 1 - pos.y;\\ncolor = pixelAt(image, pos);\\n}\"","module.exports = \"uniform sampler2D image;\\nvoid main()\\n{\\ncolor = threadPixel(image);\\n}\"","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * gpu-utils.js\n * GPU utilities\n */\n\nimport { GPUKernelGroup } from '../gpu-kernel-group';\nimport { identity, flipY } from './shaders/utils';\n\n/**\n * GPUUtils\n * Utility operations\n */\nexport class GPUUtils extends GPUKernelGroup\n{\n    /**\n     * Class constructor\n     * @param {GPUInstance} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            // no-operation\n            .declare('identity', identity)\n\n            // output a texture from a pipeline\n            .declare('output', flipY,\n                this.operation.displaysGraphics())\n        ;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * shader-preprocessor.js\n * Custom preprocessor for shaders\n */\n\nimport { GLUtils } from './gl-utils';\n\n/**\n * Custom preprocessor for shaders\n */\nexport class ShaderPreprocessor\n{\n    /**\n     * Runs the preprocessor\n     * @param {WebGL2RenderingContext} gl\n     * @param {string} code \n     * @returns {string} preprocessed code\n     */\n    static run(gl, code)\n    {\n        ShaderPreprocessor._includeRegex = ShaderPreprocessor._includeRegex ||\n            (ShaderPreprocessor._includeRegex = /^\\s*@\\s*include\\s+\"(.*?)\"/gm);\n\n        ShaderPreprocessor._commentsRegex = ShaderPreprocessor._commentsRegex ||\n            (ShaderPreprocessor._commentsRegex = [ /\\/\\*(.|\\s)*?\\*\\//g , /\\/\\/.*$/gm ]);\n\n        // remove comments and run the preprocessor\n        return String(code).replace(ShaderPreprocessor._commentsRegex[0], '')\n                           .replace(ShaderPreprocessor._commentsRegex[1], '')\n                           .replace(ShaderPreprocessor._includeRegex,\n                                (_, filename) => readfileSync(gl, filename)\n                            );\n    }\n}\n\n /**\n * Reads a shader from the /shaders/include/ folder\n * @param {WebGL2RenderingContext} gl\n * @param {string} filename\n * @returns {string}\n */\nfunction readfileSync(gl, filename)\n{\n    if(String(filename).match(/^[a-zA-Z0-9_\\-]+\\.glsl$/))\n        return require('./kernels/shaders/includes/' + filename);\n\n    throw GLUtils.Error(`Shader preprocessor: can't read file \\\"${filename}\\\"`);\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-gpu-core.js\n * GPGPU core\n */\n\nimport { SpeedyProgram } from './speedy-program.js';\nimport { GLUtils } from './gl-utils.js';\nimport { Utils } from '../utils/utils';\n\n/**\n * Speedy GPGPU core\n */\nexport class SpeedyGPUCore\n{\n    /**\n     * Class constructor\n     * @param {number} width in pixels\n     * @param {number} height in pixels\n     */\n    constructor(width, height)\n    {\n        // set dimensions\n        this._width = Math.max(width | 0, 1);\n        this._height = Math.max(height | 0, 1);\n\n        // setup GPU\n        this._canvas = createCanvas(this._width, this._height);\n        this._gl = createWebGLContext(this._canvas);\n        this._inputTexture = null;\n    }\n\n    /**\n     * WebGL context\n     * @returns {WebGL2RenderingContext}\n     */\n    get gl()\n    {\n        return this._gl;\n    }\n\n    /**\n     * Canvas element\n     * @returns {HTMLCanvasElement|OffscreenCanvas}\n     */\n    get canvas()\n    {\n        return this._canvas;\n    }\n\n    /**\n     * Width in pixels\n     * @returns {number}\n     */\n    get width()\n    {\n        return this._width;\n    }\n\n    /**\n     * Height in pixels\n     * @returns {number}\n     */\n    get height()\n    {\n        return this._height;\n    }\n\n    /**\n     * Upload data to the GPU\n     * @param {ImageBitmap|ImageData|ArrayBufferView|HTMLImageElement|HTMLVideoElement|HTMLCanvasElement} data \n     * @param {number} [width]\n     * @param {number} [height] \n     * @returns {WebGLTexture}\n     */\n    upload(data, width = -1, height = -1)\n    {\n        const gl = this._gl;\n\n        // lost GL context?\n        if(gl.isContextLost()) {\n            Utils.warning('Lost WebGL context');\n            this._gl = createWebGLContext(this._canvas);\n            this._inputTexture = null;\n            return upload(data, width, height);\n        }\n\n        // default values\n        if(width < 0)\n            width = gl.canvas.width;\n        if(height < 0)\n            height = gl.canvas.height;\n\n        // invalid dimensions?\n        if(width == 0 || height == 0)\n            throw GLUtils.Error(`Can't upload an image of area 0`);\n\n        // create or recreate & size texture\n        if(this._inputTexture === null) {\n            gl.canvas.width = Math.max(gl.canvas.width, width);\n            gl.canvas.height = Math.max(gl.canvas.height, height);\n            this._inputTexture = GLUtils.createTexture(gl, gl.canvas.width, gl.canvas.height);\n        }\n        else if(width > gl.canvas.width || height > gl.canvas.height) {\n            Utils.warning(`Resizing input texture to ${width} x ${height}`)\n            this._inputTexture = GLUtils.destroyTexture(gl, inputTexture);\n            return upload(data, width, height);\n        }\n\n        // done! note: the input texture is upside-down, i.e.,\n        // flipped on the y-axis. We need to unflip it on the\n        // output, so that (0,0) becomes the top-left corner\n        GLUtils.uploadToTexture(gl, this._inputTexture, data);\n        return this._inputTexture;\n    }\n\n    /**\n     * Create a SpeedyProgram to be run on this GPGPU core\n     * @param {Function} shaderdecl A function that returns GLSL code\n     * @param {object} [options] SpeedyProgram options\n     * @returns {SpeedyProgram} new instance\n     */\n    createProgram(shaderdecl, options = { })\n    {\n        const gl = this._gl;\n\n        return new SpeedyProgram(gl, shaderdecl, {\n            output: [ gl.canvas.width, gl.canvas.height ],\n            ...options\n        });\n    }\n\n    /**\n     * Clear the internal canvas\n     */\n    clearCanvas()\n    {\n        const gl = this._gl;\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n        gl.clearColor(0, 0, 0, 1);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n    }\n}\n\nfunction createCanvas(width, height)\n{\n    const inWorker = (typeof importScripts === 'function') && (typeof WorkerGlobalScope !== 'undefined');\n\n    if(inWorker) {\n        if(typeof OffscreenCanvas !== 'function')\n            throw GLUtils.Error('OffscreenCanvas is not available in your browser. Please upgrade.');\n\n        return new OffscreenCanvas(width, height);\n    }\n    else {\n        const canvas = document.createElement('canvas');\n        canvas.width = width;\n        canvas.height = height;\n        return canvas;\n    }\n}\n\nfunction createWebGLContext(canvas)\n{\n    const gl = canvas.getContext('webgl2', {\n        premultipliedAlpha: false,\n        preserveDrawingBuffer: false,\n        preferLowPowerToHighPerformance: false,\n        alpha: true,\n        antialias: false,\n        depth: false,\n        stencil: false,\n    });\n\n    if(!gl)\n        throw GLUtils.Error('WebGL2 is not available in your browser. Please upgrade.');\n\n    return gl;\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-program.js\n * SpeedyProgram class\n */\n\nimport { ShaderPreprocessor } from './shader-preprocessor.js';\nimport { GLUtils } from './gl-utils.js';\n\nconst LOCATION_ATTRIB_POSITION = 0;\nconst LOCATION_ATTRIB_TEXCOORD = 1;\n\nconst DEFAULT_VERTEX_SHADER = `#version 300 es\nin vec2 a_position;\nin vec2 a_texCoord;\nout vec2 texCoord;\n \nvoid main() {\n    gl_Position = vec4(a_position, 0, 1);\n    texCoord = a_texCoord;\n}`;\n\nconst DEFAULT_FRAGMENT_SHADER_PREFIX = `#version 300 es\nprecision highp float;\nprecision highp int;\nprecision highp sampler2D;\n \nout vec4 color;\nin vec2 texCoord;\nuniform vec2 texSize;\n\n@include \"global.glsl\"\\n`;\n\nconst UNIFORM_TYPES = {\n    'sampler2D':'uniform1i',\n    'float':    'uniform1f',\n    'int':      'uniform1i',\n    'uint':     'uniform1ui',\n    'bool':     'uniform1i',\n    'vec2':     'uniform2f',\n    'vec3':     'uniform3f',\n    'vec4':     'uniform4f',\n    'ivec2':    'uniform2i',\n    'ivec3':    'uniform3i',\n    'ivec4':    'uniform4i',\n    'uvec2':    'uniform2ui',\n    'uvec3':    'uniform3ui',\n    'uvec4':    'uniform4ui',\n    'bvec2':    'uniform2i',\n    'bvec3':    'uniform3i',\n    'bvec4':    'uniform4i',\n};\n\n/**\n * A SpeedyProgram is a Function that\n * runs GPU-accelerated GLSL code\n */\nexport class SpeedyProgram extends Function\n{\n    /**\n     * Creates a new SpeedyProgram\n     * @param {WebGL2RenderingContext} gl WebGL context\n     * @param {Function} shaderdecl shader declaration\n     * @param {object} [options] user options\n     */\n    constructor(gl, shaderdecl, options = { })\n    {\n        super('...args', 'return this._self._call(...args)');\n        this._self = this.bind(this);\n        this._self._init(gl, shaderdecl, options);\n        return this._self;\n    }\n\n    /**\n     * Resize the output texture\n     * @param {number} width \n     * @param {number} height \n     */\n    resize(width, height)\n    {\n        const gl = this._gl;\n        const options = this._options;\n\n        // no need to resize?\n        if(width === this._stdprog.width && height === this._stdprog.height)\n            return;\n\n        // get size\n        width = Math.max(1, width | 0);\n        height = Math.max(1, height | 0);\n\n        // update options.output\n        options.output[0] = width;\n        options.output[1] = height;\n\n        // resize stdprog\n        if(options.renderToTexture)\n            this._stdprog = detachFBO(this._stdprog);\n\n        this._stdprog.width = width;\n        this._stdprog.height = height;\n\n        if(options.renderToTexture)\n            this._stdprog = attachFBO(this._stdprog);\n\n        // update texSize uniform\n        const uniform = this._stdprog.uniform.texSize;\n        (gl[UNIFORM_TYPES[uniform.type]])(uniform.location, width, height);\n        //console.log(`Resized program to ${width} x ${height}`);\n\n        // invalidate pixel buffers\n        if(this._pixels !== null && this._pixels.length < width * height * 4)\n            this._pixels = null;\n    }\n\n    /**\n     * Read pixels from the output texture.\n     * You may optionally specify a (x,y,width,height) sub-rectangle.\n     * @param {number} [x]\n     * @param {number} [y] \n     * @param {number} [width]\n     * @param {number} [height]\n     * @returns {Uint8Array} pixels in the RGBA format\n     */\n    readPixelsSync(x = 0, y = 0, width = -1, height = -1)\n    {\n        const gl = this._gl;\n        const pixels = this._pixels || (this._pixels = new Uint8Array(this._stdprog.width * this._stdprog.height * 4));\n        //const flippedPixels = this._flippedPixels || (this._flippedPixels = new Uint8Array(pixels.length));\n\n        // default values\n        if(width < 0)\n            width = this._stdprog.width;\n        if(height < 0)\n            height = this._stdprog.height;\n\n        // clamp values\n        width = Math.min(width, this._stdprog.width);\n        height = Math.min(height, this._stdprog.height);\n        x = Math.max(0, Math.min(x, width - 1));\n        y = Math.max(0, Math.min(y, height - 1));\n\n        // read pixels\n        if(this._stdprog.hasOwnProperty('fbo')) {\n            gl.bindFramebuffer(gl.FRAMEBUFFER, this._stdprog.fbo);\n            gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        }\n        else\n            gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n\n        // flip y-axis\n        /*\n        let a, b;\n        for(let i = 0; i < height; i++) {\n            for(let j = 0; j < width; j++) {\n                a = 4 * (i * width + j);\n                b = 4 * ((height - 1 - i) * width + j);\n                pixels[a + 0] = flippedPixels[b + 0];\n                pixels[a + 1] = flippedPixels[b + 1];\n                pixels[a + 2] = flippedPixels[b + 2];\n                pixels[a + 3] = flippedPixels[b + 3];\n            }\n        }\n        return this._flippedPixels;\n        */\n\n        // return cached array\n        return this._pixels;\n    }\n\n    /**\n     * WebGL rendering context\n     * @returns {WebGL2RenderingContext}\n     */\n    get gl()\n    {\n        return this._gl;\n    }\n\n    /**\n     * Read uniforms of the program (metadata)\n     * @returns {object}\n     */\n    get uniforms()\n    {\n        return this._stdprog.uniform;\n    }\n\n    // Prepare the shader\n    _init(gl, shaderdecl, options)\n    {\n        // default options\n        options = {\n            output: [ gl.drawingBufferWidth, gl.drawingBufferHeight ], // size of the output texture\n            uniforms: { }, // user-defined constants (as uniforms)\n            renderToTexture: true, // render results to a texture?\n            recycleTexture: true, // recycle output texture? If false, you must manually destroy the output texture\n            ...options // user-defined options\n        };\n\n        // get size\n        let width = Math.max(1, options.output[0] | 0);\n        let height = Math.max(1, options.output[1] | 0);\n        options.output = [ width, height ];\n\n        // need to resize the canvas?\n        const canvas = gl.canvas;\n        if(width > canvas.width)\n            canvas.width = width;\n        if(height > canvas.height)\n            canvas.height = height;\n\n        // create shader\n        const source = shaderdecl();\n        let stdprog = createStandardProgram(gl, width, height, source, options.uniforms);\n        if(options.renderToTexture)\n            stdprog = attachFBO(stdprog);\n\n        // validate arguments\n        const params = functionArguments(shaderdecl);\n        for(let j = 0; j < params.length; j++) {\n            if(!stdprog.uniform.hasOwnProperty(params[j])) {\n                if(!stdprog.uniform.hasOwnProperty(params[j] + '[0]'))\n                    throw GLUtils.Error(`Can't run shader: expected uniform \"${params[j]}\"`);\n            }\n        }\n\n        // store context\n        this._gl = gl;\n        this._source = source;\n        this._options = options;\n        this._stdprog = stdprog;\n        this._params = params;\n        this._pixels = null;\n    }\n\n    // Run the SpeedyProgram\n    _call(...args)\n    {\n        const gl = this._gl;\n        const options = this._options;\n        const stdprog = this._stdprog;\n        const params = this._params;\n        \n        // matching arguments?\n        if(args.length != params.length)\n            throw GLUtils.Error(`Can't run shader: incorrect number of arguments`);\n\n        // use program\n        gl.useProgram(stdprog.program);\n\n        // set uniforms[i] to args[i]\n        for(let i = 0, texNo = 0; i < args.length; i++) {\n            const argname = params[i];\n            let uniform = stdprog.uniform[argname];\n\n            if(uniform) {\n                // uniform variable matches parameter name\n                texNo = this._setUniform(uniform, args[i], texNo);\n            }\n            else if(stdprog.uniform.hasOwnProperty(argname + '[0]')) {\n                // uniform array matches parameter name\n                const array = args[i];\n                if(stdprog.uniform.hasOwnProperty(`${argname}[${array.length}]`))\n                    throw GLUtils.Error(`Can't run shader: too few elements in array \"${argname}\"`);\n                for(let j = 0; (uniform = stdprog.uniform[`${argname}[${j}]`]); j++)\n                    texNo = this._setUniform(uniform, array[j], texNo);\n            }\n            else\n                throw GLUtils.Error(`Can't run shader: unknown parameter \"${argname}\": ${args[i]}`);\n        }\n\n        // render\n        if(options.renderToTexture)\n            gl.bindFramebuffer(gl.FRAMEBUFFER, stdprog.fbo);\n        else\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n        gl.viewport(0, 0, stdprog.width, stdprog.height);\n        gl.drawArrays(gl.TRIANGLE_STRIP,\n                      0,        // offset\n                      4);       // count       \n\n        // output texture\n        let outputTexture = null;\n        if(options.renderToTexture) {\n            outputTexture = stdprog.texture;\n            if(!options.recycleTexture) {\n                // clone outputTexture using the current framebuffer\n                const cloneTexture = GLUtils.createTexture(gl, stdprog.width, stdprog.height);\n                gl.activeTexture(gl.TEXTURE0);\n                gl.bindTexture(gl.TEXTURE_2D, cloneTexture);\n                gl.copyTexSubImage2D(gl.TEXTURE_2D,     // target\n                                     0,                 // mipmap level\n                                     0,                 // xoffset\n                                     0,                 // yoffset\n                                     0,                 // x\n                                     0,                 // y\n                                     stdprog.width,     // width\n                                     stdprog.height);   // height\n                gl.bindTexture(gl.TEXTURE_2D, null);\n                outputTexture = cloneTexture;\n            }\n        }\n\n        // return texture (if available)\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        return outputTexture;\n    }\n\n    // set uniform to value\n    // arrays of arbitrary size are not supported, only fixed-size vectors (vecX, ivecX, etc.)\n    _setUniform(uniform, value, texNo)\n    {\n        const gl = this._gl;\n\n        if(uniform.type == 'sampler2D') {\n            // set texture\n            if(texNo > gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS)\n                throw GLUtils.Error(`Can't bind ${texNo} textures to a program: max is ${gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS}`);\n            else if(value === this._stdprog.texture)\n                throw GLUtils.Error(`Can't run shader: cannot use its output texture as an input to itself`);\n\n            gl.activeTexture(gl.TEXTURE0 + texNo);\n            gl.bindTexture(gl.TEXTURE_2D, value);\n            gl.uniform1i(uniform.location, texNo);\n            texNo++;\n        }\n        else {\n            // set value\n            if(typeof value == 'number' || typeof value == 'boolean')\n                (gl[UNIFORM_TYPES[uniform.type]])(uniform.location, value);\n            else if(Array.isArray(value))\n                (gl[UNIFORM_TYPES[uniform.type]])(uniform.location, ...value);\n            else\n                throw GLUtils.Error(`Can't run shader: unrecognized argument \"${value}\"`);\n        }\n\n        return texNo;\n    }\n}\n\n// a dictionary specifying the types of all uniforms in the code\nfunction autodetectUniforms(shaderSource)\n{\n    const sourceWithoutComments = shaderSource; // assume we've preprocessed the source already\n    const regex = /uniform\\s+(\\w+)\\s+([^;]+)/g;\n    const uniforms = { };\n\n    let match;\n    while((match = regex.exec(sourceWithoutComments)) !== null) {\n        const type = match[1];\n        const names = match[2].split(',').map(name => name.trim()).filter(name => name); // trim & remove empty names\n        for(const name of names) {\n            if(name.endsWith(']')) {\n                // is it an array?\n                if(!(match = name.match(/(\\w+)\\s*\\[\\s*(\\d+)\\s*\\]$/)))\n                    throw GLUtils.Error(`Unspecified array length for uniform \"${name}\" in the shader`);\n                const [ array, length ] = [ match[1], Number(match[2]) ];\n                for(let i = 0; i < length; i++)\n                    uniforms[`${array}[${i}]`] = { type };\n            }\n            else {\n                // regular uniform\n                uniforms[name] = { type };\n            }\n        }\n    }\n\n    return Object.freeze(uniforms);\n}\n\n// names of function arguments\nfunction functionArguments(fun)\n{\n    const code = fun.toString();\n    const regex = code.startsWith('function') ? 'function\\\\s.*\\\\(([^)]*)\\\\)' :\n                 (code.startsWith('(') ? '\\\\(([^)]*)\\\\).*=>' : '([^=]+).*=>');\n    const match = new RegExp(regex).exec(code);\n\n    if(match !== null) {\n        const args = match[1].replace(/\\/\\*.*?\\*\\//g, ''); // remove comments\n        return args.split(',').map(argname =>\n            argname.replace(/=.*$/, '').trim() // remove default params & trim\n        ).filter(argname =>\n            argname // handle trailing commas\n        );\n    }\n    else\n        throw GLUtils.Error(`Can't detect function arguments of ${code}`);\n\n    return [];\n}\n\n// create VAO & VBO\nfunction createStandardGeometry(gl)\n{\n    // cached values?\n    const f = createStandardGeometry;\n    const cache = f._cache || (f._cache = new WeakMap());\n    if(cache.has(gl))\n        return cache.get(gl);\n\n    // configure the attributes of the vertex shader\n    const vao = gl.createVertexArray(); // vertex array object\n    const vbo = [ gl.createBuffer(), gl.createBuffer() ]; // vertex buffer objects\n    gl.bindVertexArray(vao);\n\n    // set the a_position attribute\n    // using the current vbo\n    gl.bindBuffer(gl.ARRAY_BUFFER, vbo[0]);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n        // clip coordinates\n        -1, -1,\n        1, -1,\n        -1, 1,\n        1, 1,\n    ]), gl.STATIC_DRAW);\n    gl.vertexAttribPointer(LOCATION_ATTRIB_POSITION, // attribute location\n                           2,          // 2 components per vertex (x,y)\n                           gl.FLOAT,   // type\n                           false,      // don't normalize\n                           0,          // default stride (tightly packed)\n                           0);         // offset\n    gl.enableVertexAttribArray(LOCATION_ATTRIB_POSITION);\n\n    // set the a_texCoord attribute\n    // using the current vbo\n    gl.bindBuffer(gl.ARRAY_BUFFER, vbo[1]);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n        // texture coordinates\n        0, 0,\n        1, 0,\n        0, 1,\n        1, 1,\n    ]), gl.STATIC_DRAW);\n    gl.vertexAttribPointer(LOCATION_ATTRIB_TEXCOORD, // attribute location\n                           2,          // 2 components per vertex (x,y)\n                           gl.FLOAT,   // type\n                           false,      // don't normalize\n                           0,          // default stride (tightly packed)\n                           0);         // offset\n    gl.enableVertexAttribArray(LOCATION_ATTRIB_TEXCOORD);\n\n    // unbind & return\n    gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    const result = { vao, vbo };\n    cache.set(gl, result);\n    return result;\n}\n\n// a standard program runs a shader on an \"image\"\n// uniforms: { 'name': <default_value>, ... }\nfunction createStandardProgram(gl, width, height, fragmentShaderSource, uniforms = { })\n{\n    // compile shaders\n    const source = ShaderPreprocessor.run(gl, DEFAULT_FRAGMENT_SHADER_PREFIX + fragmentShaderSource);\n    const program = GLUtils.createProgram(gl, DEFAULT_VERTEX_SHADER, source);\n\n    // setup geometry\n    gl.bindAttribLocation(program, LOCATION_ATTRIB_POSITION, 'a_position');\n    gl.bindAttribLocation(program, LOCATION_ATTRIB_TEXCOORD, 'a_texCoord');\n    const vertexObjects = createStandardGeometry(gl);\n\n    // define texSize\n    width = Math.max(width | 0, 1);\n    height = Math.max(height | 0, 1);\n    uniforms.texSize = [ width, height ];\n\n    // autodetect uniforms, get their locations,\n    // define their setters and set their default values\n    const uniform = autodetectUniforms(source);\n    gl.useProgram(program);\n    for(const u in uniform) {\n        // get location\n        uniform[u].location = gl.getUniformLocation(program, u);\n\n        // validate type\n        if(!UNIFORM_TYPES.hasOwnProperty(uniform[u].type))\n            throw GLUtils.Error(`Unknown uniform type: ${uniform[u].type}`);\n\n        // must set a default value?\n        if(uniforms.hasOwnProperty(u)) {\n            const value = uniforms[u];\n            if(typeof value == 'number' || typeof value == 'boolean')\n                (gl[UNIFORM_TYPES[uniform[u].type]])(uniform[u].location, value);\n            else if(typeof value == 'object')\n                (gl[UNIFORM_TYPES[uniform[u].type]])(uniform[u].location, ...Array.from(value));\n            else\n                throw GLUtils.Error(`Unrecognized uniform value: \"${value}\"`);\n        }\n\n        // note: to set the default value of array arr, pass\n        // { 'arr[0]': val0, 'arr[1]': val1, ... } to uniforms\n    }\n\n    // done!\n    return {\n        program,\n        gl,\n        uniform,\n        width,\n        height,\n        ...vertexObjects,\n    };\n}\n\n// Attach a framebuffer object to a standard program\nfunction attachFBO(stdprog)\n{\n    const gl = stdprog.gl;\n    const width = stdprog.width;\n    const height = stdprog.height;\n\n    const texture = GLUtils.createTexture(gl, width, height);\n    const fbo = GLUtils.createFramebuffer(gl, texture);\n\n    return Object.assign(stdprog, {\n        texture,\n        fbo\n    });\n}\n\n// Detach a framebuffer object from a standard program\nfunction detachFBO(stdprog)\n{\n    if(stdprog.hasOwnProperty('fbo')) {\n        GLUtils.destroyFramebuffer(stdprog.gl, stdprog.fbo);\n        delete stdprog.fbo;\n    }\n\n    if(stdprog.hasOwnProperty('texture')) {\n        GLUtils.destroyTexture(stdprog.gl, stdprog.texture);\n        delete stdprog.texture;\n    }\n\n    return stdprog;\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy.js\n * Speedy's entry point\n */\n\nimport { SpeedyMedia } from './core/speedy-media';\nimport { SpeedyPipeline } from './core/speedy-pipeline';\nimport { FPSCounter } from './utils/fps-counter';\n\nclass Speedy\n{\n    /**\n     * Loads a SpeedyMedia object based on the provided source element\n     * @param {HTMLImageElement|HTMLVideoElement|HTMLCanvasElement} sourceElement The source media\n     * @returns {Promise<SpeedyMedia>}\n     */\n    static load(sourceElement)\n    {\n        return SpeedyMedia.load(sourceElement);\n    }\n\n    /**\n     * Loads a camera stream\n     * @param {number} [width] width of the stream\n     * @param {number} [height] height of the stream\n     * @param {object} [options] additional options to pass to getUserMedia()\n     * @returns {Promise<SpeedyMedia>}\n     */\n    static camera(width = 426, height = 240, options = {})\n    {\n        return SpeedyMedia.loadCameraStream(width, height, options);\n    }\n\n    /**\n     * Creates a new pipeline\n     * @returns {SpeedyPipeline}\n     */\n    static pipeline()\n    {\n        return new SpeedyPipeline();\n    }\n\n    /**\n     * The version of the library\n     * @returns {string} The version of the library\n     */\n    static get version()\n    {\n        return __SPEEDY_VERSION__;\n    }\n\n    /**\n     * The FPS rate. Get it as Speedy.fps.value\n     * @returns {number} Frames per second (FPS)\n     */\n    static get fps()\n    {\n        return {\n            get value() { return FPSCounter.instance.fps; }\n        };\n    }\n}\n\nexport const load = Speedy.load;\nexport const camera = Speedy.camera;\nexport const pipeline = Speedy.pipeline;\nexport const version = Speedy.version;\nexport const fps = Speedy.fps;","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * errors.js\n * Error classes\n */\n\n/**\n * Error class for Speedy\n */\nexport class SpeedyError extends Error\n{\n    /**\n     * Class constructor\n     * @param {string} message message text\n     * @param  {...string} [args] additional text\n     */\n    constructor(message, ...args)\n    {\n        const text = [ message, ...args ].join(' ');\n        console.error('[speedy-vision.js]', text);\n        super(text);\n    }\n\n    /**\n     * Error name\n     * @returns {string}\n     */\n    get name()\n    {\n        return this.constructor.name;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * fps-counter.js\n * A FPS counter\n */\n\nimport { Utils } from './utils';\nlet instance = null;\nconst UPDATE_INTERVAL = 500; // in ms\n\nexport class FPSCounter\n{\n    /**\n     * Creates a new FPSCounter\n     */\n    /* private */ constructor()\n    {\n        this._fps = 60;\n        this._frames = 0;\n        this._updateInterval = UPDATE_INTERVAL;\n        this._lastUpdate = performance.now();\n\n        // this should never happen...\n        if(instance !== null)\n            Utils.fatal(`Can't have multiple instances of FPSCounter`);\n\n        // start FPS counter\n        requestAnimationFrame(this._update.bind(this));\n    }\n\n    /**\n     * Gets an instance of the FPS counter.\n     * Using lazy loading, i.e., we will not\n     * create a FPS counter unless we need to!\n     */\n    static get instance()\n    {\n        if(instance === null)\n            instance = new FPSCounter();\n\n        return instance;\n    }\n\n    /**\n     * Get the FPS rate\n     * @returns {number} frames per second\n     */\n    get fps()\n    {\n        return this._fps;\n    }\n\n    // Updates the FPS counter\n    _update()\n    {\n        const now = performance.now();\n        const deltaTime = now - this._lastUpdate;\n\n        if(deltaTime >= this._updateInterval) {\n            this._fps = Math.round(this._frames / (deltaTime * 0.001));\n            this._frames = 0;\n            this._lastUpdate = now;\n        }\n\n        this._frames++;\n        requestAnimationFrame(this._update.bind(this));\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * tuner.js\n * A device designed to minimize the (noisy) output of a unknown system\n */\n\nimport { Utils } from './utils';\n\n/**\n * A Bucket of observations is used to give\n * statistical treatment to (noisy) data\n */\nclass Bucket\n{\n    /**\n     * Class constructor\n     * @param {number} bucketSize It should be a power of two\n     * @param {number} windowSize An odd positive number for filtering\n     */\n    constructor(bucketSize = 32, windowSize = 5)\n    {\n        // validate parameters\n        this._bucketSize = 1 << Math.ceil(Math.log2(bucketSize));\n        this._windowSize = windowSize + (1 - windowSize % 2);\n\n        // bucketSize should be a power of 2\n        if(bucketSize < this._windowSize)\n            Utils.fatal(`Invalid bucketSize of ${bucketSize}`);\n\n        // Bucket is implemented as a circular vector\n        this._head = this._bucketSize - 1;\n        this._rawData = new Float32Array(this._bucketSize).fill(0);\n        this._smoothedData = new Float32Array(this._bucketSize).fill(0);\n        this._average = 0;\n        this._isSmooth = true;\n    }\n\n    /**\n     * Put a value in the bucket\n     * @param {number} value\n     */\n    put(value)\n    {\n        this._head = (this._head + 1) & (this._bucketSize - 1);\n        this._rawData[this._head] = value;\n        this._isSmooth = false;\n    }\n\n    /**\n     * Bucket size\n     * @returns {number}\n     */\n    get size()\n    {\n        return this._bucketSize;\n    }\n\n    /**\n     * Get smoothed average\n     * @returns {number}\n     */\n    get average()\n    {\n        // need to smooth the signal?\n        if(!this._isSmooth)\n            this._smooth();\n\n        // the median filter does not introduce new data to the signal\n        // this._average approaches the mean of the distribution as bucketSize -> inf\n        return this._average;\n    }\n\n    /**\n     * Fill the bucket with a value\n     * @param {number} value\n     */\n    fill(value)\n    {\n        this._rawData.fill(value);\n        this._smoothedData.fill(value);\n        this._average = value;\n        this._isSmooth = true;\n        this._head = this._bucketSize - 1;\n        return this;\n    }\n\n    // Apply the smoothing filter & compute the average\n    _smooth()\n    {\n        // smooth the signal & compute the average\n        this._average = 0;\n        for(let i = 0; i < this._bucketSize; i++) {\n            this._smoothedData[i] = this._median(this._window(i));\n            this._average += this._smoothedData[i];\n        }\n        this._average /= this._bucketSize;\n        //this._average = this._median(this._rawData);\n\n        // the signal has been smoothed\n        this._isSmooth = true;\n    }\n\n    // A window of size w around i\n    _window(i)\n    {\n        const arr = this._rawData;\n        const win = this._win || (this._win = new Float32Array(this._windowSize));\n        const n = arr.length;\n        const w = win.length;\n        const wOver2 = w >> 1;\n        const head = this._head;\n        const tail = (head + 1) & (n - 1);\n\n        for(let j = 0, k = -wOver2; k <= wOver2; k++) {\n            let pos = i + k;\n\n            // boundary conditions:\n            // reflect values\n            if(i <= head){\n                if(pos > head)\n                    pos = head + (head - pos);\n            }\n            else {\n                if(pos < tail)\n                    pos = tail + (tail - pos);\n            }\n            if(pos < 0)\n                pos += n;\n            else if(pos >= n)\n                pos -= n;\n\n            win[j++] = arr[pos];\n        }\n\n        return win;\n    }\n\n    // return the median of a sequence (note: the input is rearranged)\n    _median(v)\n    {\n        // fast median search for fixed length vectors\n        switch(v.length) {\n            case 1:\n                return v[0];\n\n            case 3:\n                //  v0   v1   v2   [ v0  v1  v2 ]\n                //   \\  / \\   /\n                //   node  node    [ min(v0,v1)  min(max(v0,v1),v2)  max(max(v0,v1),v2) ]\n                //      \\   /\n                //      node       [ min(min(v0,v1),min(max(v0,v1),v2))  max(min(...),min(...))  max(v0,v1,v2) ]\n                //       |\n                //     median      [ min(v0,v1,v2)  median  max(v0,v1,v2) ]\n                if(v[0] > v[1]) [v[0], v[1]] = [v[1], v[0]];\n                if(v[1] > v[2]) [v[1], v[2]] = [v[2], v[1]];\n                if(v[0] > v[1]) [v[0], v[1]] = [v[1], v[0]];\n                return v[1];\n\n            case 5:\n                if(v[0] > v[1]) [v[0], v[1]] = [v[1], v[0]];\n                if(v[3] > v[4]) [v[3], v[4]] = [v[4], v[3]];\n                if(v[0] > v[3]) [v[0], v[3]] = [v[3], v[0]];\n                if(v[1] > v[4]) [v[1], v[4]] = [v[4], v[1]];\n                if(v[1] > v[2]) [v[1], v[2]] = [v[2], v[1]];\n                if(v[2] > v[3]) [v[2], v[3]] = [v[3], v[2]];\n                if(v[1] > v[2]) [v[1], v[2]] = [v[2], v[1]];\n                return v[2];\n\n            case 7:\n                if(v[0] > v[5]) [v[0], v[5]] = [v[5], v[0]];\n                if(v[0] > v[3]) [v[0], v[3]] = [v[3], v[0]];\n                if(v[1] > v[6]) [v[1], v[6]] = [v[6], v[1]];\n                if(v[2] > v[4]) [v[2], v[4]] = [v[4], v[2]];\n                if(v[0] > v[1]) [v[0], v[1]] = [v[1], v[0]];\n                if(v[3] > v[5]) [v[3], v[5]] = [v[5], v[3]];\n                if(v[2] > v[6]) [v[2], v[6]] = [v[6], v[2]];\n                if(v[2] > v[3]) [v[2], v[3]] = [v[3], v[2]];\n                if(v[3] > v[6]) [v[3], v[6]] = [v[6], v[3]];\n                if(v[4] > v[5]) [v[4], v[5]] = [v[5], v[4]];\n                if(v[1] > v[4]) [v[1], v[4]] = [v[4], v[1]];\n                if(v[1] > v[3]) [v[1], v[3]] = [v[3], v[1]];\n                if(v[3] > v[4]) [v[3], v[4]] = [v[4], v[3]];\n                return v[3];\n\n            default:\n                v.sort((a, b) => a - b);\n                return (v[(v.length - 1) >> 1] + v[v.length >> 1]) / 2;\n        }\n    }\n}\n\n/**\n * A Tuner is a device designed to find\n * an integer x that minimizes the output\n * of a unknown system y = F(x) with noise\n */\n/* abstract */ class Tuner\n{\n    /**\n     * Class constructor\n     * @param {number} initialState initial guess to input to the unknown system\n     * @param {number} minState minimum integer accepted by the unknown system\n     * @param {number} maxState maximum integer accepted by the unknown system\n     */\n    constructor(initialState, minState, maxState)\n    {\n        // validate parameters\n        if(minState >= maxState)\n            Utils.fatal(`Invalid boundaries [${minState},${maxState}] given to the Tuner`);\n        initialState = Math.max(minState, Math.min(initialState, maxState));\n\n        // setup object\n        this._state = initialState;\n        this._prevState = initialState;\n        this._prevPrevState = initialState;\n        this._initialState = initialState;\n        this._minState = minState;\n        this._maxState = maxState;\n        this._bucket = new Array(maxState - minState + 1).fill(null).map(x => new Bucket(this._bucketSetup().size, this._bucketSetup().window));\n        this._iterations = 0; // number of iterations in the same state\n        this._epoch = 0; // number of state changes\n    }\n\n    /**\n     * The value to input to the unknown system\n     */\n    currentValue()\n    {\n        return this._state;\n    }\n\n    /**\n     * Feed the output y = F(x) of the unknown system\n     * when given an input x = this.currentValue()\n     */\n    feedObservation(y)\n    {\n        const bucket = this._bucketOf(this._state);\n\n        // feed the observation into the bucket of the current state\n        bucket.put(+y);\n\n        // time to change state?\n        if(++this._iterations >= bucket.size) {\n            // initialize buckets\n            if(this._epoch == 0) {\n                this._bucket.forEach(bk => bk.fill(bucket.average));\n                if(!isFinite(this._costOfBestState))\n                    this._costOfBestState = bucket.average;\n            }\n\n            // compute next state\n            const clip = s => Math.max(this._minState, Math.min(s | 0, this._maxState));\n            const prevPrevState = this._prevState;\n            const prevState = this._state;\n            this._state = clip(this._nextState());\n            this._prevState = prevState;\n            this._prevPrevState = prevPrevState;\n\n            // reset iteration counter\n            // and advance epoch number\n            this._iterations = 0;\n            this._epoch++;\n        }\n    }\n\n    /**\n     * Reset the Tuner to its initial state\n     * Useful if you change on-the-fly the unknown system,\n     * so that there is a new target value you want to find\n     */\n    reset()\n    {\n        this._state = this._initialState;\n        this._prevState = this._initialState;\n        this._prevPrevState = this._initialState;\n        this._iterations = 0;\n        this._epoch = 0;\n    }\n\n    /**\n     * Finished optimization?\n     * @returns {boolean}\n     */\n    finished()\n    {\n        return false;\n    }\n\n    // get the bucket of a state\n    _bucketOf(state)\n    {\n        state = Math.max(this._minState, Math.min(state | 0, this._maxState));\n        return this._bucket[state - this._minState];\n    }\n\n    // the bucket may be reconfigured on subclasses\n    _bucketSetup()\n    {\n        return {\n            \"size\": 32,\n            \"window\": 5\n        };\n    }\n\n    // this is magic\n    /* abstract */ _nextState()\n    {\n        // Subclass responsibility\n        return this._state;\n    }\n\n    /**\n     * Let me see stuff\n     * @returns {object}\n     */\n    info()\n    {\n        const bucket = this._bucketOf(this._state);\n        const prevBucket = this._bucketOf(this._prevState);\n\n        return {\n            now: this._state,\n            avg: bucket.average,\n            itr: [ this._iterations, this._epoch ],\n            bkt: bucket._smoothedData,\n            cur: new Array(bucket.size).fill(0).map((x, i) => i == bucket._head ? 1 : 0),\n            prv: [ this._prevState, prevBucket.average ],\n            fim: this.finished(),\n        };\n    }\n}\n\n/**\n * A Tuner created for testing purposes\n */\nexport class TestTuner extends Tuner\n{\n    /**\n     * Class constructor\n     * @param {number} minState minimum integer accepted by the unknown system\n     * @param {number} maxState maximum integer accepted by the unknown system\n     */\n    constructor(minState, maxState)\n    {\n        super(minState, minState, maxState);\n    }\n\n    // where should I go next?\n    _nextState()\n    {\n        //console.log(this.info());\n        const nextState = this._state + 1;\n        return nextState > this._maxState ? this._minState : nextState;\n    }\n\n    // bucket setup\n    _bucketSetup()\n    {\n        return {\n            \"size\": 4,\n            \"window\": 3\n        };\n    }\n\n    // let me see stuff\n    info()\n    {\n        return {\n            state: [ this._state, this._bucketOf(this._state).average ],\n            data: JSON.stringify(this._bucket.map(b => b.average)),\n        };\n    }\n}\n\n/*\n * Implementation of Simulated Annealing\n */\nexport class StochasticTuner extends Tuner\n{\n    /**\n     * Class constructor\n     * @param {number} initialState initial guess to input to the unknown system\n     * @param {number} minState minimum integer accepted by the unknown system\n     * @param {number} maxState maximum integer accepted by the unknown system\n     * @param {number} [alpha] geometric decrease rate of the temperature\n     * @param {number} [maxIterationsPerTemperature] number of iterations before cooling down by alpha\n     * @param {number} [initialTemperature] initial temperature\n     * @param {Function<number,number?>} [neighborFn] neighbor picking function: state[,F(state)] -> state\n     */\n    constructor(initialState, minState, maxState, alpha = 0.5, maxIterationsPerTemperature = 8, initialTemperature = 100, neighborFn = null)\n    {\n        super(initialState, minState, maxState);\n\n        this._bestState = this._initialState;\n        this._costOfBestState = Infinity;\n        this._initialTemperature = Math.max(0, initialTemperature);\n        this._temperature = this._initialTemperature;\n        this._numIterations = 0; // no. of iterations in the current temperature\n        this._maxIterationsPerTemperature = Math.max(1, maxIterationsPerTemperature);\n        this._alpha = Math.max(0, Math.min(alpha, 1)); // geometric decrease rate\n\n        if(!neighborFn)\n            neighborFn = (s) => this._minState + Math.floor(Math.random() * (this._maxState - this._minState + 1))\n        this._pickNeighbor = neighborFn;\n    }\n\n    /**\n     * Reset the Tuner\n     */\n    reset()\n    {\n        this._temperature = this._initialTemperature;\n        this._numIterations = 0;\n        // we shall not reset the best state...\n    }\n\n    /**\n     * Finished optimization?\n     * @returns {boolean}\n     */\n    finished()\n    {\n        return this._temperature <= 1e-5;\n    }\n\n    // Pick the next state\n    // Simulated Annealing\n    _nextState()\n    {\n        // finished simulation?\n        if(this.finished())\n            return this._bestState;\n\n        // pick a neighbor\n        const f = (s) => this._bucketOf(s).average;\n        let nextState = this._state;\n        let neighbor = this._pickNeighbor(this._state, f(this._state)) | 0;\n        neighbor = Math.max(this._minState, Math.min(neighbor, this._maxState));\n\n        // evaluate the neighbor\n        if(f(neighbor) < f(this._state)) {\n            // the neighbor is better than the current state\n            nextState = neighbor;\n        }\n        else {\n            // the neighbor is not better than the current state,\n            // but we may admit it with a certain probability\n            if(Math.random() < Math.exp((f(this._state) - f(neighbor)) / this._temperature))\n                nextState = neighbor;\n        }\n\n        // update the best state\n        if(f(nextState) < this._costOfBestState) {\n            this._bestState = nextState;\n            this._costOfBestState = f(nextState);\n        }\n\n        // cool down\n        if(++this._numIterations >= this._maxIterationsPerTemperature) {\n            this._temperature *= this._alpha;\n            this._numIterations = 0;\n        }\n\n        // done\n        return nextState;\n    }\n\n    // bucket setup\n    _bucketSetup()\n    {\n        return {\n            \"size\": 4,\n            \"window\": 3\n        };\n    }\n\n    // let me see stuff\n    info()\n    {\n        return {\n            best: [ this._bestState, this._costOfBestState ],\n            state: [ this._state, this._bucketOf(this._state).average ],\n            iterations: [ this._numIterations, this._maxIterationsPerTemperature ],\n            temperature: this._temperature,\n            alpha: this._alpha,\n            cool: this.finished(),\n        };\n    }\n}\n\n/**\n * Golden Section Search\n */\nexport class GoldenSectionTuner extends Tuner\n{\n    /**\n     * Class constructor\n     * @param {number} minState minimum INTEGER accepted by the quadratic error system\n     * @param {number} maxState maximum INTEGER accepted by the quadratic error system\n     * @param {number} tolerance terminating condition (interval size)\n     */\n    constructor(minState, maxState, tolerance = 0.001)\n    {\n        super(minState, minState, maxState);\n        this._invphi = (Math.sqrt(5.0) - 1.0) / 2.0; // 1 / phi\n        this._tolerance = Math.max(0, tolerance);\n        this.reset();\n    }\n\n    /**\n     * Reset the tuner\n     */\n    reset()\n    {\n        this._xlo = Math.max(xlo, this._minState);\n        this._xhi = Math.min(xhi, this._maxState);\n        this._x1 = this._xhi - this._invphi * (this._xhi - this._xlo);\n        this._x2 = this._xlo + this._invphi * (this._xhi - this._xlo);\n\n        this._state = Math.floor(this._x1);\n        this._bestState = this._state;\n    }\n\n    /**\n     * Finished optimizing?\n     * @returns {boolean}\n     */\n    finished()\n    {\n        return this._xhi - this._xlo <= this._tolerance;\n    }\n\n    // Where should I go next?\n    _nextState()\n    {\n        const f = (s) => this._bucketOf(s).average;\n\n        // best state so far\n        if(f(this._state) < f(this._bestState))\n            this._bestState = this._state;\n\n        // finished?\n        if(this.finished())\n            return this._bestState;\n\n        // initial search\n        if(this._epoch == 0)\n            return Math.ceil(this._x2);\n\n        // evaluate the current interval\n        if(f(Math.floor(this._x1)) < f(Math.ceil(this._x2))) {\n            this._xhi = this._x2;\n            this._x2 = this._x1;\n            this._x1 = this._xhi - this._invphi * (this._xhi - this._xlo);\n            return Math.floor(this._x1);\n        }\n        else {\n            this._xlo = this._x1;\n            this._x1 = this._x2;\n            this._x2 = this._xlo + this._invphi * (this._xhi - this._xlo);\n            return Math.ceil(this._x2);\n        }\n    }\n\n    // Bucket setup\n    _bucketSetup()\n    {\n        return {\n            \"size\": 4,\n            \"window\": 3\n        };\n    }\n\n    // let me see stuff\n    info()\n    {\n        return {\n            now: this._state,\n            avg: this._bucketOf(this._state).average,\n            itr: [ this._iterations, this._epoch ],\n            int: [ this._xlo, this._xhi ],\n            sub: [ this._x1, this._x2 ],\n            done: this.finished(),\n        };\n    }\n}\n\n/**\n * A Tuner for minimizing errors between observed and expected values\n * \n * It should be an Online Tuner, that is, it should learn the\n * best responses in real-time, as it goes\n * \n * This is sort of a hill climbing / gradient descent algorithm\n * with random elements and adapted for discrete space\n */\nexport class OnlineErrorTuner extends Tuner\n{\n    /**\n     * Class constructor\n     * @param {number} minState minimum INTEGER accepted by the quadratic error system\n     * @param {number} maxState maximum INTEGER accepted by the quadratic error system\n     * @param {number} tolerance percentage relative to the expected observation\n     * @param {number} learningRate hyperparameter\n     */\n    constructor(minState, maxState, tolerance = 0.1, learningRate = 0.05)\n    {\n        const initialState = Math.round(Utils.gaussianNoise((minState + maxState) / 2, 5));\n        super(initialState, minState, maxState);\n        this._tolerance = Math.max(0, tolerance);\n        this._bestState = this._initialState;\n        this._expected = null;\n        this._learningRate = Math.max(0, learningRate);\n    }\n\n    /**\n     * Reset the tuner\n     */\n    reset()\n    {\n        super.reset();\n        this._expected = null;\n    }\n\n    /**\n     * Feed an observed value and an expected value\n     * @param {number} observedValue\n     * @param {number} expectedValue\n     */\n    feedObservation(observedValue, expectedValue)\n    {\n        const obs = +observedValue;\n        const expected = +expectedValue;\n\n        // must reset the tuner?\n        if(expected !== this._expected)\n            this.reset();\n        this._expected = expected;\n\n        // feed an error measurement to the appropriate bucket\n        const err = ((obs - expected) * (obs - expected)) / (expected * expected);\n        super.feedObservation(err);\n    }\n\n    /**\n     * Finished optimizing?\n     * -- for now, that is...\n     *    it's an online tuner!\n     * @returns {boolean}\n     */\n    finished()\n    {\n        // error function\n        const E = (s) => Math.sqrt(this._bucketOf(s).average) * Math.abs(this._expected);\n\n        // compute values\n        const err = E(this._bestState);\n        const tol = this._tolerance;\n        const exp = this._expected;\n        //console.log('ERR', err, tol * exp);\n\n        // acceptable condition\n        return err <= tol * exp;\n    }\n\n    /**\n     * Tolerance value, a percentage relative\n     * to the expected value that we want\n     * @returns {boolean}\n     */\n    get tolerance()\n    {\n        return this._tolerance;\n    }\n\n    /**\n     * Set the tolerance, a percentage relative\n     * to the expected value that we want\n     */\n    set tolerance(value)\n    {\n        this._tolerance = Math.max(0, value);\n    }\n\n    // Where should I go next?\n    _nextState()\n    {\n        // finished?\n        if(this.finished())\n            return this._bestState;\n\n        // error function\n        const E = (s) => Math.sqrt(this._bucketOf(s).average) * Math.abs(this._expected);\n\n        // best state\n        if(E(this._state) < E(this._bestState))\n            this._bestState = this._state;\n\n        // the algorithm should avoid long hops, as this\n        // would cause discontinuities for the end-user\n        //const stepSize = this._learningRate * E(this._state);\n        const worldScale = Math.abs(this._maxState);\n        const G = (s) => Math.sqrt(this._bucketOf(s).average) * worldScale;\n        const stepSize = this._learningRate * G(this._state);\n\n        // move in the opposite direction of the error or in\n        // the direction of the error with a small probability\n        const sign = x => (x >= 0) - (x < 0); // -1 or 1\n        const direction = (\n            sign(E(this._state) - E(this._prevState)) *\n           -sign(this._state - this._prevState) *\n            sign(Math.random() - 0.15)\n        );\n        //console.warn(\"at state\", this._state, direction > 0 ? '-->' : '<--');\n\n        // pick the next state\n        const weight = Utils.gaussianNoise(1.0, 0.1); // dodge local mimina\n        let newState = Math.round(this._state + direction * weight * stepSize);\n\n        // outside bounds?\n        if(newState > this._maxState)\n            newState = this._bestState;\n        else if(newState < this._minState)\n            newState = this._bestState;\n\n        // done\n        return newState;\n    }\n\n    // Bucket setup\n    _bucketSetup()\n    {\n        return {\n            \"size\": 4,\n            \"window\": 3\n        };\n    }\n\n    // let me see stuff\n    info()\n    {\n        return {\n            now: [ this._state, this._prevState ],\n            bkt: this._bucketOf(this._state)._rawData,\n            cur: this._bucketOf(this._state)._head,\n            err: [ this._bucketOf(this._state).average, this._bucketOf(this._prevState).average ],\n            sqt: Math.sqrt(this._bucketOf(this._state).average),\n            done: this.finished(),\n        };\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * types.js\n * Types & formats\n */\n\nimport { Utils } from './utils';\n\nexport const MediaType = Utils.enum(\n    'Image',\n    'Video',\n    'Canvas',\n    'Texture'\n);\n\nexport const ColorFormat = Utils.enum(\n    'RGB',\n    'Greyscale',\n    'Binary'\n);","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for the web\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * utils.js\n * Generic utilities\n */\n\nimport { SpeedyError } from './errors'\n\nexport class Utils\n{\n    /**\n     * Displays a fatal error\n     * @param {string} text message text\n     * @param  {...string} [args] optional text\n     * @throws {SpeedyError} an error object containing the message text\n     */\n    static fatal(text, ...args)\n    {\n        throw new SpeedyError(text, ...args);\n    }\n\n    /**\n     * Generates a warning\n     * @param {string} text message text\n     * @param  {...string} [args] optional text\n     * @returns {string} the message text\n     */\n    static warning(text, ...args)\n    {\n        const message = [ text, ...args ].join(' ');\n        console.warn('[speedy-vision.js]', message);\n        return message;\n    }\n\n    /**\n     * Logs a message\n     * @param {string} text message text\n     * @param  {...string} [args] optional text\n     * @returns {string} the message text\n     */\n    static log(text, ...args)\n    {\n        const message = [ text, ...args ].join(' ');\n        console.log('[speedy-vision.js]', message);\n        return message;\n    }\n\n    /**\n     * Assertion\n     * @param {boolean} expr expression\n     * @param {string} [text] error message\n     * @throws {SpeedyError}\n     */\n    static assert(expr, text = '')\n    {\n        if(!expr)\n            throw new SpeedyError('Assertion failed.', text);\n    }\n\n    /**\n     * Generates an enumeration\n     * @param {...string} values enumeration options\n     * @returns {object} enum object\n     */\n    static enum(...values)\n    {\n        return Object.freeze(\n            values.reduce((acc, cur) => ((acc[cur] = Symbol(cur)), acc), { })\n        );\n    }\n\n    /**\n     * Generates a random number with\n     * Gaussian distribution (mu, sigma)\n     * @param {number} mu mean\n     * @param {number} sigma standard deviation\n     * @returns {number} random number\n     */\n    static gaussianNoise(mu = 0, sigma = 1)\n    {\n        // Box-Muller transformation\n        const TWO_PI = 2.0 * Math.PI;\n        \n        let a, b = Math.random();\n        do { a = Math.random(); } while(a <= Number.EPSILON);\n        let z = Math.sqrt(-2 * Math.log(a)) * Math.sin(TWO_PI * b);\n\n        return z * sigma + mu;\n    }\n}"],"sourceRoot":""}