{"version":3,"sources":["webpack://Speedy/webpack/bootstrap","webpack://Speedy/./node_modules/process/browser.js","webpack://Speedy/./src/core/keypoints/automatic-sensitivity.js","webpack://Speedy/./src/core/keypoints/descriptors/orb.js","webpack://Speedy/./src/core/keypoints/detectors/fast.js","webpack://Speedy/./src/core/keypoints/detectors/harris.js","webpack://Speedy/./src/core/keypoints/feature-algorithm-decorator.js","webpack://Speedy/./src/core/keypoints/feature-algorithm.js","webpack://Speedy/./src/core/keypoints/feature-description-algorithm.js","webpack://Speedy/./src/core/keypoints/feature-detection-algorithm.js","webpack://Speedy/./src/core/keypoints/feature-downloader.js","webpack://Speedy/./src/core/keypoints/feature-tracking-algorithm.js","webpack://Speedy/./src/core/keypoints/trackers/lk.js","webpack://Speedy/./src/core/math/matrix-buffer.js","webpack://Speedy/./src/core/math/matrix-expressions.js","webpack://Speedy/./src/core/math/matrix-math.js","webpack://Speedy/./src/core/math/matrix-operations-queue.js","webpack://Speedy/./src/core/math/matrix-operations.js","webpack://Speedy/./src/core/math/matrix-worker.js","webpack://Speedy/./src/core/math/matrix.js","webpack://Speedy/./src/core/math/speedy-vector.js","webpack://Speedy/./src/core/pipeline-operations.js","webpack://Speedy/./src/core/speedy-descriptor.js","webpack://Speedy/./src/core/speedy-feature-decorator.js","webpack://Speedy/./src/core/speedy-feature-descriptor-factory.js","webpack://Speedy/./src/core/speedy-feature-detector-factory.js","webpack://Speedy/./src/core/speedy-feature-detector.js","webpack://Speedy/./src/core/speedy-feature-tracker-factory.js","webpack://Speedy/./src/core/speedy-feature-tracker.js","webpack://Speedy/./src/core/speedy-feature.js","webpack://Speedy/./src/core/speedy-flags.js","webpack://Speedy/./src/core/speedy-media.js","webpack://Speedy/./src/core/speedy-namespace.js","webpack://Speedy/./src/core/speedy-pipeline.js","webpack://Speedy/./src/core/speedy.js","webpack://Speedy/./src/core/tuners/sensitivity-tuner.js","webpack://Speedy/./src/core/tuners/stochastic-tuner.js","webpack://Speedy/./src/core/tuners/test-tuner.js","webpack://Speedy/./src/core/tuners/tuner.js","webpack://Speedy/./src/gpu/gl-utils.js","webpack://Speedy/./src/gpu/programs/colors.js","webpack://Speedy/./src/gpu/programs/encoders.js","webpack://Speedy/./src/gpu/programs/enhancements.js","webpack://Speedy/./src/gpu/programs/filters.js","webpack://Speedy/./src/gpu/programs/keypoints.js","webpack://Speedy/./src/gpu/programs/pyramids.js","webpack://Speedy/./src/gpu/programs/trackers.js","webpack://Speedy/./src/gpu/programs/utils.js","webpack://Speedy/./src/gpu/shader-declaration.js","webpack://Speedy/./src/gpu/shader-preprocessor.js","webpack://Speedy/./src/gpu/shaders sync ^\\.\\/.*$","webpack://Speedy/./src/gpu/shaders/colors/rgb2grey.glsl","webpack://Speedy/./src/gpu/shaders/encoders/encode-keypoint-offsets.glsl","webpack://Speedy/./src/gpu/shaders/encoders/encode-keypoints.glsl","webpack://Speedy/./src/gpu/shaders/encoders/upload-keypoints.glsl","webpack://Speedy/./src/gpu/shaders/enhancements/nightvision.glsl","webpack://Speedy/./src/gpu/shaders/enhancements/normalize-image.glsl","webpack://Speedy/./src/gpu/shaders/filters/convolution.js","webpack://Speedy/./src/gpu/shaders/filters/fast-median.glsl","webpack://Speedy/./src/gpu/shaders/filters/median.js","webpack://Speedy/./src/gpu/shaders/filters/multiscale-sobel.glsl","webpack://Speedy/./src/gpu/shaders/include sync ^\\.\\/.*$","webpack://Speedy/./src/gpu/shaders/include/colors.glsl","webpack://Speedy/./src/gpu/shaders/include/fixed-point.glsl","webpack://Speedy/./src/gpu/shaders/include/global.glsl","webpack://Speedy/./src/gpu/shaders/include/keypoints.glsl","webpack://Speedy/./src/gpu/shaders/include/math.glsl","webpack://Speedy/./src/gpu/shaders/include/orientation.glsl","webpack://Speedy/./src/gpu/shaders/include/pyramids.glsl","webpack://Speedy/./src/gpu/shaders/include/sobel.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/brisk.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/fast-score12.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/fast-score16.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/fast-score8.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/fast5.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/fast7.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/fast9lg.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/harris-cutoff.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/multiscale-fast.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/multiscale-harris.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/multiscale-suppression.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/nonmax-suppression.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/orb-descriptor.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/orientation-via-centroid.glsl","webpack://Speedy/./src/gpu/shaders/keypoints/samescale-suppression.glsl","webpack://Speedy/./src/gpu/shaders/pyramids/downsample2.glsl","webpack://Speedy/./src/gpu/shaders/pyramids/downsample3.glsl","webpack://Speedy/./src/gpu/shaders/pyramids/upsample2.glsl","webpack://Speedy/./src/gpu/shaders/pyramids/upsample3.glsl","webpack://Speedy/./src/gpu/shaders/trackers/lk-discard.glsl","webpack://Speedy/./src/gpu/shaders/trackers/lk.glsl","webpack://Speedy/./src/gpu/shaders/utils/copy-components.glsl","webpack://Speedy/./src/gpu/shaders/utils/fill-components.glsl","webpack://Speedy/./src/gpu/shaders/utils/fill.glsl","webpack://Speedy/./src/gpu/shaders/utils/flip-y.glsl","webpack://Speedy/./src/gpu/shaders/utils/identity.glsl","webpack://Speedy/./src/gpu/shaders/utils/scan-minmax2d.glsl","webpack://Speedy/./src/gpu/speedy-gpu.js","webpack://Speedy/./src/gpu/speedy-program-center.js","webpack://Speedy/./src/gpu/speedy-program-group.js","webpack://Speedy/./src/gpu/speedy-program.js","webpack://Speedy/./src/gpu/speedy-texture.js","webpack://Speedy/./src/index.js","webpack://Speedy/./src/utils/errors.js","webpack://Speedy/./src/utils/fps-counter.js","webpack://Speedy/./src/utils/globals.js","webpack://Speedy/./src/utils/observable.js","webpack://Speedy/./src/utils/speedy-promise.js","webpack://Speedy/./src/utils/types.js","webpack://Speedy/./src/utils/utils.js"],"names":[],"mappings":";;;;;;;;;;;;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA,4BAA4B,UAAU;;;;;;;;;;;;;ACvLtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoD;AACF;AACO;AACM;AACd;;AAEjD;AACA,+BAA+B;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,mCAAmC,4DAAU;AACpD;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE;;AAEzE;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA,iCAAiC;;AAEjC;AACA;AACA,mDAAmD;AACnD,8BAA8B,0EAAgB,UAAU;AACxD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;AC/JA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoD;AAC2B;AACvB;;AAExD;AACA,2BAA2B;AAC3B,2CAA2C;;AAE3C;AACA;AACA;AACO,0BAA0B,0FAA2B;AAC5D;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACvFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoD;AACQ;AACe;AACjB;AACb;AACe;;AAE5D;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACO,2BAA2B,sFAAyB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,QAAQ,kDAAK;AACb;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,QAAQ,kDAAK;AACb;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+DAAiB;;AAEvC;AACA;;AAEA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACO,qCAAqC,sFAAyB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,QAAQ,kDAAK;AACb;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,QAAQ,kDAAK;AACb;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,QAAQ,kDAAK,2CAA2C,iEAAkB;AAC1E;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;AC7PA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoD;AACuB;AACrB;AACM;AACf;;AAE7C;AACA,4BAA4B;AAC5B,wBAAwB;AACxB,8BAA8B;AAC9B,0BAA0B;AAC1B,0BAA0B;AAC1B,+BAA+B,iEAAkB,KAAK;;AAEtD;AACA;AACA;AACO,6BAA6B,sFAAyB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,QAAQ,kDAAK;AACb;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,6DAA6D,2DAAc;;AAE3E;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO,uCAAuC,sFAAyB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,QAAQ,kDAAK;AACb;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,QAAQ,kDAAK,2CAA2C,iEAAkB;AAC1E;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sBAAsB,qBAAqB;AAC3C;AACA,oCAAoC,6BAA6B;AACjE,wDAAwD;;AAExD;AACA;;AAEA;AACA,sBAAsB,qBAAqB;AAC3C;;AAEA;AACA,6DAA6D,2DAAc;;AAE3E;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;AC/MA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuD;AACb;;AAE1C;AACA;AACA;AACA;AACA;AACO,wCAAwC,mEAAgB;AAC/D;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA,QAAQ,kDAAK,sCAAsC,mEAAgB;AACnE;AACA;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACvGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiD;AACQ;AACA;AACA;AACf;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA,QAAQ,kDAAK;AACb,QAAQ,kDAAK;;AAEb,+BAA+B,qEAAiB;AAChD,8CAA8C;AAC9C,oCAAoC;AACpC;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,eAAe,QAAQ;AACvB,iBAAiB,yBAAyB;AAC1C;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,gBAAgB;AAC/B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,QAAQ,kDAAK,mCAAmC;AAChD;;AAEA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,QAAQ,kDAAK,wCAAwC;AACrD;AACA,C;;;;;;;;;;;;AC1IA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AACF;AACmB;AACA;AAChC;;AAE1C;AACA;AACA;AACA;AACO,0CAA0C,sFAAyB;AAC1E;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,OAAO;AACtB;AACA;AACA;AACA,QAAQ,kDAAK,sCAAsC,mEAAgB;AACnE,QAAQ,kDAAK;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;AACA,C;;;;;;;;;;;;ACzGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyD;AACF;AACL;AACD;AACQ;AACf;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACO,wCAAwC,mEAAgB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,EAAE;AAClD;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2DAA2D;AAC3D;;AAEA;AACA;AACA,C;;;;;;;;;;;;ACtJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2D;AACP;AACF;AACD;;AAEjD;AACA,iCAAiC;AACjC,oCAAoC;AACpC,yBAAyB;AACzB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC;AAChC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACO,gCAAgC,4DAAU;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,oBAAoB;AAC3D;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,SAAS;AACT,sBAAsB,mEAAqB;AAC3C,SAAS;AACT;;AAEA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACrOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiD;AACQ;AACA;AACF;AACL;;AAElD;AACA;AACA;AACA;AACO,uCAAuC,mEAAgB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,mCAAmC;AACnC;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,iCAAiC;AACnE;AACA;AACA;AACA;AACA,8BAA8B,oBAAoB;AAClD;AACA;;AAEA;AACA,SAAS;AACT;AACA,C;;;;;;;;;;;;ACnIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoD;AACqB;AAC5B;;AAE7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO,yCAAyC,oFAAwB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,QAAQ,kDAAK;AACb;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,QAAQ,kDAAK;AACb;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC9HA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2C;AACyD;AACzC;;AAE3D;AACA,mBAAmB,uDAAU;AAC7B,iBAAiB,uDAAU;AAC3B;AACA,uCAAuC,kCAAkC;AACzE,EAAE;;AAEF;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,yDAAyD;AACxE,eAAe,OAAO;AACtB,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB;;AAE1C;AACA;AACA,sBAAsB,kEAAoB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,kEAAoB;;AAE1C;AACA,iCAAiC;AACjC,2CAA2C;AAC3C,mCAAmC;AACnC,0BAA0B;AAC1B,kCAAkC;;AAElC;AACA,yEAAyE;AACzE,wCAAwC;AACxC,4BAA4B;AAC5B,8BAA8B;AAC9B;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mEAAa;AACpC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,mBAAmB,mEAAa;AAChC;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,iBAAiB,EAAE;AACnC;;AAEA;AACA;;AAEA;AACA,4CAA4C,QAAQ;AACpD;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,iBAAiB,EAAE;AACnC;;AAEA;AACA;AACA,oEAAoE;;AAEpE;AACA;;AAEA,0BAA0B,0BAA0B;AACpD;AACA;AACA,yDAAyD,QAAQ;AACjE;AACA;AACA,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;;AAEA;AACA,4CAA4C,QAAQ;AACpD;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,iBAAiB,EAAE;AACnC;;AAEA;AACA;AACA;;AAEA;AACA,4CAA4C,QAAQ;AACpD;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;;AAEzD;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,C;;;;;;;;;;;;ACzOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwC;AACG;AACuB;AACoC;AAC3C;AAkB9B;;AAE7B;AACA,8BAA8B,8EAAqB;AACnD,mBAAmB,uDAAU;AAC7B,iBAAiB,uDAAU;AAC3B,qBAAqB,uDAAU;AAC/B;AACA,uCAAuC,+BAA+B;AACtE,EAAE;;;;AAIF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,kEAAoB,gDAAgD,WAAW,KAAK,cAAc;AACxH;AACA,sBAAsB,kEAAoB,4CAA4C,wBAAwB;AAC9G;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,uDAAU;AACzB;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB,uCAAuC,uDAAU,4BAA4B,UAAU,WAAW;AAC7I;AACA,sBAAsB,mEAAqB,wCAAwC,aAAa,KAAK,gBAAgB,UAAU,WAAW,KAAK,cAAc;AAC7J;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA,kBAAkB,mEAAqB;AACvC;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA,eAAe,0BAA0B;AACzC,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,mEAAqB;AACvC;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,mEAAqB;AACvC;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;;;AAGA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,iBAAiB;AAChC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,iBAAiB;AAChC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,wBAAwB;AACvC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,iBAAiB;AAChC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,kEAAoB,kDAAkD,KAAK,KAAK,QAAQ;AAC9G;AACA,sBAAsB,kEAAoB,qBAAqB,KAAK,oCAAoC,OAAO,KAAK,UAAU;;AAE9H;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,0BAA0B,kEAAoB,+BAA+B,OAAO;AACpF;AACA;;;;;;;;AAQA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,8BAA8B,oDAAY,iCAAiC;AAC3E;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,iBAAiB;AAChC,eAAe,SAAS;AACxB,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC,eAAe,SAAS;AACxB,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,mEAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;;;;;AAKA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA,eAAe,0BAA0B;AACzC,iBAAiB,0CAA0C;AAC3D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,0BAA0B;AACzC;AACA;AACA;AACA,eAAe,sBAAsB;AACrC;;AAEA;AACA;AACA;AACA,mCAAmC,oDAAY;AAC/C;AACA;AACA;AACA,0BAA0B,kEAAoB,2BAA2B,OAAO;AAChF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,mEAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,mEAAa;AAC5B;;AAEA;AACA;AACA,+BAA+B;AAC/B,eAAe,aAAa;AAC5B,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA,eAAe,mEAAa;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,SAAS;AACT;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,sEAAmB;AAC1D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,SAAS;AACT;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,sEAAmB;AAC1D;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,8BAA8B,sEAAmB;AACjD;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA,6CAA6C,sEAAmB;AAChE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C,2EAAwB;AACrE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC;AACA;AACA;AACA,oEAAoE,qEAAkB;AACtF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC;AACA;AACA;AACA,oEAAoE,0EAAuB;AAC3F;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qEAAqE,0EAAuB;AAC5F;AACA,sBAAsB,kEAAoB,qBAAqB,cAAc,KAAK,iBAAiB,eAAe,eAAe,KAAK,kBAAkB;AACxJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC;AACA;AACA;AACA,wEAAwE,4EAAyB;AACjG;AACA,sBAAsB,kEAAoB,qBAAqB,iBAAiB,KAAK,cAAc,4BAA4B,eAAe,KAAK,kBAAkB;AACrK;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC;AACA;AACA;AACA,kEAAkE,4EAAyB;AAC3F;AACA,sBAAsB,kEAAoB,qBAAqB,cAAc,KAAK,iBAAiB,eAAe,kBAAkB,KAAK,eAAe;AACxJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC;AACA;AACA;AACA,qEAAqE,6EAA0B;AAC/F;AACA,sBAAsB,kEAAoB,qBAAqB,cAAc,KAAK,iBAAiB,eAAe,eAAe,KAAK,kBAAkB;AACxJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,OAAO;AACtB;AACA;AACA;AACA,6CAA6C,uEAAoB;AACjE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC;AACA;AACA;AACA,oEAAoE,0EAAuB;AAC3F;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB,4CAA4C,UAAU,KAAK,aAAa;;AAElH,wCAAwC,oEAAiB;AACzD;AACA;;;;;;;AAOA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB,4CAA4C,aAAa,KAAK,gBAAgB;AACxH;AACA,sBAAsB,kEAAoB,eAAe,aAAa,kCAAkC,aAAa,KAAK,gBAAgB;;AAE1I,mEAAmE,yEAAsB;AACzF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB,eAAe,WAAW,KAAK,eAAe,uBAAuB,WAAW,KAAK,cAAc;;AAE7I,oCAAoC,kFAA+B;AACnE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,kEAAoB,mDAAmD,EAAE,KAAK,EAAE;AACtG;AACA,sBAAsB,kEAAoB,eAAe,EAAE,kCAAkC,aAAa,KAAK,gBAAgB;;AAE/H,sCAAsC,yEAAsB;AAC5D;AACA;;;;;AAKA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,kEAAoB,0BAA0B,MAAM;;AAE1E;AACA;AACA,0BAA0B,kEAAoB,wCAAwC,OAAO;AAC7F;AACA,6BAA6B,oDAAY;AACzC;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,gDAAgD,QAAQ;AACxD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;ACv6CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,WAAW;AAC1B,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,WAAW;AAC1B,eAAe,aAAa;AAC5B;AACA;AACA;AACA,eAAe,gCAAgC;AAC/C,eAAe,QAAQ;;AAEvB;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,aAAa;AACnC;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,WAAW;AAC1B,eAAe,aAAa;AAC5B;AACA;AACA;AACA,eAAe,gCAAgC;AAC/C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,aAAa;AACzC,sBAAsB,UAAU;AAChC;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,WAAW;AAC1B,eAAe,aAAa;AAC5B;AACA;AACA;AACA,eAAe,wBAAwB;AACvC;AACA;;AAEA;AACA,uBAAuB,UAAU;AACjC,2BAA2B,aAAa;AACxC;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,WAAW;AAC1B,eAAe,aAAa;AAC5B;AACA;AACA;AACA,eAAe,wBAAwB;AACvC;AACA;;AAEA;AACA,kBAAkB,aAAa;AAC/B;AACA;AACA;AACA,sBAAsB,UAAU;AAChC;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,WAAW;AAC1B,eAAe,aAAa;AAC5B;AACA;AACA;AACA,eAAe,wBAAwB;AACvC;AACA;;AAEA;AACA,kBAAkB,aAAa;AAC/B;AACA;AACA;AACA,sBAAsB,UAAU;AAChC;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,WAAW;AAC1B,eAAe,aAAa;AAC5B;AACA;AACA;AACA,eAAe,gCAAgC;AAC/C;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,aAAa;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,cAAc;AAC1C,2BAA2B,cAAc;AACzC;AACA,0BAA0B,UAAU;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,WAAW;AAC1B,eAAe,aAAa;AAC5B;AACA;AACA;AACA,eAAe,gCAAgC;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,cAAc;AAC1C,2BAA2B,cAAc;AACzC;AACA,0BAA0B,WAAW;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,WAAW;AAC1B,eAAe,aAAa;AAC5B;AACA;AACA;AACA,eAAe,gCAAgC;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,aAAa;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,cAAc;AAC1C,2BAA2B,WAAW;AACtC;AACA,0BAA0B,UAAU;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,WAAW;AAC1B,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,uBAAuB,cAAc;AACrC;AACA,sBAAsB,WAAW;AACjC;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,WAAW;AAC1B,eAAe,aAAa;AAC5B;AACA;AACA;AACA,eAAe,wBAAwB;AACvC,eAAe,SAAS;AACxB;;AAEA;AACA,kBAAkB,aAAa;AAC/B;AACA,sBAAsB,UAAU;AAChC;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,WAAW;AAC1B,eAAe,aAAa;AAC5B;AACA;AACA;AACA,eAAe,wBAAwB;AACvC;AACA;;AAEA;AACA,kBAAkB,aAAa;AAC/B;AACA;AACA;AACA,sBAAsB,UAAU;AAChC;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,WAAW;AAC1B,eAAe,aAAa;AAC5B;AACA;AACA;AACA,eAAe,wBAAwB;AACvC;AACA,gC;;AAEA;AACA,kBAAkB,aAAa;AAC/B;AACA;AACA,sBAAsB,UAAU;AAChC;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,WAAW;AAC1B,eAAe,aAAa;AAC5B;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,yCAAyC,EAAE,WAAW,eAAe;AACrE;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,uEAAuE,MAAM,KAAK,SAAS;;AAE3F;AACA;AACA,uEAAuE,MAAM,KAAK,SAAS,wCAAwC,MAAM,+BAA+B,MAAM;;AAE9K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,cAAc;AAChC,gCAAgC;AAChC,kCAAkC;;AAElC,0BAA0B;AAC1B,wEAAwE;;AAExE;AACA,sBAAsB,OAAO;AAC7B;AACA,gEAAgE;;AAEhE;AACA;AACA;AACA,gCAAgC,UAAU;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oFAAoF,MAAM,KAAK,SAAS,6CAA6C,MAAM,KAAK,iBAAiB,UAAU,MAAM,KAAK,SAAS;;AAE/M;AACA,0BAA0B,WAAW,OAAO;AAC5C;AACA,wCAAwC;AACxC,yCAAyC,QAAQ,OAAO;AACxD;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,cAAc;AAC7C,qCAAqC,WAAW;AAChD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uFAAuF,MAAM,KAAK,SAAS,6CAA6C,MAAM,KAAK,oBAAoB,UAAU,MAAM,KAAK,SAAS;;AAErN;AACA,0BAA0B,cAAc,OAAO;AAC/C;AACA,wCAAwC;AACxC,yCAAyC,QAAQ,OAAO;AACxD;AACA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4FAA4F,EAAE,eAAe,MAAM,KAAK,SAAS;AACjI;AACA,6FAA6F,EAAE,KAAK,IAAI,WAAW,MAAM,KAAK,SAAS;;AAEvI;AACA,0BAA0B,OAAO;AACjC;;AAEA;AACA,0BAA0B,OAAO,OAAO;AACxC,mCAAmC;AACnC;AACA,8BAA8B,OAAO;AACrC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4FAA4F,EAAE,eAAe,MAAM,KAAK,SAAS;AACjI;AACA,6FAA6F,EAAE,KAAK,IAAI,WAAW,MAAM,KAAK,SAAS;;AAEvI;AACA,0BAA0B,OAAO;AACjC;;AAEA;AACA,8BAA8B,QAAQ,OAAO;AAC7C,mCAAmC;AACnC;AACA,8BAA8B,OAAO;AACrC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD,6CAA6C;AAC7C;;AAEA;AACA;AACA,4FAA4F,EAAE,eAAe,MAAM,KAAK,SAAS;AACjI;AACA,6FAA6F,EAAE,KAAK,IAAI,WAAW,MAAM,KAAK,SAAS;;AAEvI;AACA,0BAA0B,OAAO,OAAO;AACxC;AACA;AACA;;AAEA;AACA,kCAAkC,QAAQ;AAC1C;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mEAAmE,KAAK;AACxE;AACA;;;AAGA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,WAAW;AAC1B,eAAe,aAAa;AAC5B;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;;AAEA;AACA,mEAAmE,MAAM,KAAK,QAAQ,MAAM,WAAW,KAAK,SAAS,qBAAqB,MAAM,KAAK,SAAS;AAC9J;AACA,oEAAoE,MAAM,yBAAyB,KAAK,KAAK,QAAQ;;AAErH;AACA;AACA,yBAAyB;AACzB,6CAA6C;AAC7C,0CAA0C;AAC1C,4CAA4C;;AAE5C;AACA,oBAAoB,QAAQ;AAC5B;AACA,wBAAwB,OAAO;AAC/B;;AAEA;AACA;AACA;AACA;AACA,8DAA8D,IAAI;AAClE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,WAAW;AAC1B,eAAe,aAAa;AAC5B;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA,wCAAwC,EAAE;;AAE1C;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;AAKA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,SAAS;AAC/B;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,WAAW;AAC1B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA,kBAAkB,YAAY;AAC9B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,WAAW;AAC1B,eAAe,aAAa;AAC5B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA,eAAe,wBAAwB;AACvC;AACA;;AAEA;AACA,iCAAiC,aAAa;AAC9C,sBAAsB,UAAU;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,WAAW;AAC1B,eAAe,aAAa;AAC5B,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,UAAU;AACzB,eAAe,iBAAiB;AAChC,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,QAAQ;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;AAOA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA,kBAAkB,c;;;;;;;;;;;;AC56BlB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwC;AACc;AACK;;AAE3D;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,aAAa;AAC5B,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA,mBAAmB,mEAAa;AAChC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,C;;;;;;;;;;;;AC/FA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoG;AACzC;AACnB;AACG;AACI;;AAE/C;AACA,eAAe,uDAAU;AACzB,mBAAmB,uDAAU;AAC7B,0BAA0B;AAC1B;;AAEA;AACA,qBAAqB,2DAAY;;;AAGjC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,eAAe;AAC9B,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,0CAA0C;;AAE1C;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,kEAAoB,gCAAgC,oBAAoB;AAC9F,6BAA6B,uDAAU;AACvC;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,eAAe;AAC9B,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C,6CAA6C,QAAQ;AACrD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,mEAAqB;;AAE/C;AACA;AACA;;AAEA;AACA;;;;;;;AAOA;;;;;;;AAOA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA,eAAe,8BAA8B;AAC7C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gDAAgD;AAChD,6CAA6C,QAAQ;AACrD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,QAAQ;AACzD;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA,eAAe,8BAA8B;AAC7C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C;AAC1C,6CAA6C,QAAQ;AACrD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,mEAAa;AAC5B;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA,eAAe,sBAAsB;;AAErC;AACA;AACA;AACA,sBAAsB,mEAAqB,gCAAgC,0BAA0B,QAAQ,kBAAkB;AAC/H;AACA,sBAAsB,mEAAqB,yBAAyB,KAAK,KAAK,QAAQ,aAAa,aAAa,KAAK,gBAAgB;AACrI;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA,6EAA6E,gBAAgB;AAC7F;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,OAAO;AACtB;AACA;AACA;AACA,mFAAmF,kBAAkB;AACrG;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,OAAO;AACtB;AACA;AACA;AACA,oBAAoB,6CAA6C;AACjE;AACA,sBAAsB,kEAAoB,oCAAoC,KAAK;;AAEnF;AACA,yEAAyE,UAAU;AACnF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,aAAa;AAC5B;AACA;AACA;AACA,iGAAiG,uBAAuB;AACxH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AChkBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2C;AACgB;AACA;;AAE3D;AACA,qCAAqC;AACrC,YAAY,uDAAU;;AAEtB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B,eAAe,cAAc;AAC7B,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA,mBAAmB,mEAAa;;AAEhC;AACA;AACA;AACA;AACA,qBAAqB;;AAErB,mBAAmB,mEAAa;AAChC;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,0CAA0C,uDAAU;AACpD;AACA,uCAAuC,iCAAiC;;AAExE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB,kBAAkB,WAAW;AACxE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,aAAa;AACxB;AACA;AACA;AACA,WAAW,wDAAwD;;AAEnE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA,C;;;;;;;;;;;;ACnIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoG;AACrD;AACJ;AACuB;AACT;AACE;;;;AAI3D;AACA,mBAAmB,uDAAU;AAC7B,iBAAiB,uDAAU;AAC3B,qBAAqB,uDAAU;AAC/B,8BAA8B,8EAAqB;;;;AAInD;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,kEAAoB;AAC1C;AACA,sBAAsB,kEAAoB;AAC1C;AACA,sBAAsB,kEAAoB;AAC1C;AACA,sBAAsB,kEAAoB,kDAAkD,6BAA6B,UAAU,cAAc;;AAEjJ;AACA;AACA;AACA;AACA;AACA,qCAAqC,2DAAY;AACjD;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,iBAAiB,wBAAwB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,UAAU;AACpC,8BAA8B,UAAU;AACxC;AACA;;AAEA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA,sBAAsB,kEAAoB;;AAE1C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,OAAO;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,OAAO;AACtB,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,UAAU;AAChC;AACA,0BAA0B,aAAa;AACvC;AACA;;AAEA;AACA;AACA,6CAA6C,KAAK,SAAS,QAAQ,WAAW,WAAW,aAAa,IAAI;AAC1G;AACA,SAAS;AACT;;;;;;AAMA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,kEAAoB,kDAAkD,SAAS,GAAG,QAAQ,IAAI,YAAY,GAAG,WAAW;AAC9I;AACA,sBAAsB,kEAAoB,4CAA4C,SAAS,GAAG,QAAQ,IAAI,YAAY,GAAG,WAAW,OAAO,KAAK,KAAK,QAAQ;;AAEjK;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,oCAAoC,UAAU,SAAS,aAAa,WAAW,WAAW;AAC1F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kDAAkD,qEAAkB;AACpE;AACA;AACA,C;;;;;;;;;;;;AC9WA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0D;;AAE1D;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,gCAAgC,cAAc,IAAI,cAAc;AAChE;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,C;;;;;;;;;;;;AC3JA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6C;AACN;AACG;AACgC;;AAEnE,2BAA2B;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,UAAU;AACzB,eAAe,YAAY;AAC3B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,kBAAkB;AACjC,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB;AAC1C;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wDAAW;AAC5C;AACA,sCAAsC,wDAAW;AACjD,sBAAsB,+DAAiB;;AAEvC,6BAA6B,wDAAW;AACxC;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA,4BAA4B;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,eAAe;;AAE9B;AACA;AACA,sBAAsB,kEAAoB,qBAAqB,OAAO;AACtE;AACA,sBAAsB,kEAAoB,yBAAyB,KAAK;;AAExE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,sBAAsB,kEAAoB;AAC1C;AACA,sBAAsB,kEAAoB,gDAAgD,IAAI;;AAE9F;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kDAAK;;AAErB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA,4BAA4B;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,WAAW;;AAE1B,iCAAiC,wDAAW;AAC5C;AACA,sCAAsC,wDAAW;AACjD;AACA;AACA,sBAAsB,+DAAiB;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA,4BAA4B;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,+BAA+B;;AAE9C,iCAAiC,wDAAW;AAC5C;AACA,sCAAsC,wDAAW;AACjD;AACA;AACA,sBAAsB,+DAAiB;AACvC;AACA,C;;;;;;;;;;;;ACjTA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsD;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC/GA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoF;AACnB;AAC1B;;AAEvC;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,iBAAiB;AAChC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA,QAAQ,kDAAK,sCAAsC,gGAAyB;;AAE5E;AACA;AACA,C;;;;;;;;;;;;ACrDA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqD;AACe;AACV;;AAE1D;AACA;AACA;AACA;AACO,6CAA6C,iEAAe;AACnE;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,gFAAsB,CAAC,sEAAW;AACrD;AACA,C;;;;;;;;;;;;ACvCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqD;AAMlB;AACuB;AAC2B;;AAErF;AACA;AACA;AACO,2CAA2C,iEAAe;AACjE;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,4EAAmB;AACtC;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,sFAA6B;AAChD;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,8EAAqB;AACxC;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,wFAA+B;AAClD;;AAEA;AACA;AACA,iBAAiB,gCAAgC;AACjD;AACA;AACA;AACA,oBAAoB,iGAA8B;AAClD,oBAAoB,wFAA+B;AACnD;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC5FA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsH;AAC/E;AACK;AACC;AACC;AACQ;AACT;AAC4B;AACW;AACI;AACN;AACM;AACpB;;;;AAIpE;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;;AAE9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C;AAC1C;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C;AACA,mBAAmB,yDAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wDAAW;AAC7C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB;;AAE1C;AACA;AACA;;AAEA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,qFAAoB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,kBAAkB,uEAAY;;AAE9B;AACA;AACA,sBAAsB,+DAAiB,gDAAgD,EAAE;;AAEzF;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,kBAAkB,iFAAsB;;AAExC;AACA;AACA,sBAAsB,+DAAiB,2DAA2D,EAAE;;AAEpG;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2EAAc;AAChC;;AAEA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qFAAwB;AAC1C;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AChjBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqD;AACR;AACe;;AAE5D;AACA;AACA;AACO,0CAA0C,iEAAe;AAChE;AACA;AACA;AACA,eAAe,YAAY;AAC3B,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,wEAAgB;AACnC;AACA,C;;;;;;;;;;;;ACvCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkF;AACrC;AACC;AACO;AACyB;AACvC;AAC8B;AACD;;AAEpE;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,yBAAyB;AACxC,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,qBAAqB;AACpC,eAAe,eAAe;AAC9B,iBAAiB;AACjB;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,kEAAoB;;AAE1C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,6BAA6B;AACvD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,4BAA4B,iEAAa;AACzC,4BAA4B,iEAAa;AACzC;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,mEAAqB,kDAAkD,aAAa;;AAE1G;AACA,oDAAoD;AACpD;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA,8BAA8B,iFAA0B;AACxD;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB;;AAE1C;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB,mBAAmB,SAAS;;AAEtE;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB;;AAE1C;AACA;AACA,C;;;;;;;;;;;;AC7OA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqD;;AAErD;AACA,2BAA2B,iEAAc;;;;AAIzC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,QAAQ,GAAG,QAAQ;AACtC;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC7HA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgD;;AAEzC;;AAEP;AACA;;AAEA;AACA,QAAQ,4DAAU;;AAElB,CAAC,E;;;;;;;;;;;;AC/BD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE8C;AACS;AAC2E;AAC3F;AAC0C;;AAEjF;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,eAAe,gEAAgE;AAC/E,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA,qEAAqE,EAAE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wDAAW;;AAE3C;AACA,6BAA6B,sDAAS;AACtC,gBAAgB,kDAAK;;AAErB;AACA;AACA,sCAAsC,sDAAS;AAC/C,aAAa;;AAEb;AACA,4BAA4B,yDAAS;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,kEAAoB;AAC1C;;AAEA;AACA;AACA;AACA,eAAe,gEAAgE;AAC/E,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA,wCAAwC,EAAE;AAC1C;AACA;AACA;AACA;AACA,0BAA0B,mEAAqB;;AAE/C;AACA,YAAY,kDAAK,kCAAkC,YAAY;;AAE/D;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA,wEAAwE,EAAE,kBAAkB,EAAE;AAC9F;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,gEAAgE;AACjF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,iBAAiB,sDAAS;AAC1B;;AAEA,iBAAiB,sDAAS;AAC1B;;AAEA,iBAAiB,sDAAS;AAC1B;;AAEA,iBAAiB,sDAAS;AAC1B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA,YAAY,kDAAK;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,qBAAqB;AACtC;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sDAAS;AACtC;AACA;AACA,kB;AACA;AACA,kCAAkC,sDAAS;AAC3C,qCAAqC,kDAAK;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,eAAe;AAC9B,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C;AACA,2BAA2B,oBAAoB;AAC/C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B,sDAAS;AACvC;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA,eAAe,kBAAkB;AACjC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B;AAC5B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,yBAAyB;AAC1C;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,6FAA4B;AAChD,+BAA+B,6FAA4B;AAC3D,sBAAsB,6FAA4B;AAClD,iCAAiC,6FAA4B;AAC7D,mBAAmB,6FAA4B;AAC/C,qBAAqB,6FAA4B;AACjD;;AAEA;AACA;AACA,sBAAsB,kEAAoB,oBAAoB,gBAAgB;;AAE9E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,qCAAqC;AAChF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA,+BAA+B,iDAAiD;AAChF,+BAA+B,6CAA6C;AAC5E,gCAAgC,mCAAmC;AACnE,0BAA0B,mCAAmC;AAC7D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sDAAS;;AAEhC;AACA,uBAAuB,sDAAS;;AAEhC;AACA,uBAAuB,sDAAS;;AAEhC;AACA,uBAAuB,sDAAS;AAChC;AACA;;AAEA,cAAc,kEAAoB,gDAAgD,YAAY;AAC9F;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ,kDAAK,sBAAsB,YAAY;;AAE/C;AACA,uBAAuB,0DAAY,eAAe,YAAY,aAAa,QAAQ;AACnF,SAAS;;AAET;AACA;AACA;AACA,SAAS;AACT,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kDAAkD;;AAElD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,cAAc,kEAAoB,mDAAmD,YAAY;AACjG;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ,kDAAK,0DAA0D,cAAc;AACrF;AACA;;AAEA;AACA,kCAAkC;AAClC;;AAEA;AACA,wDAAwD;AACxD;AACA;AACA,QAAQ,kDAAK;;AAEb;AACA,8BAA8B,+DAAiB;;AAE/C;AACA;AACA;AACA,wBAAwB,eAAe;AACvC,yBAAyB,gBAAgB;AACzC,8BAA8B,wBAAwB;AACtD;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gBAAgB,kDAAK;AACrB;AACA;AACA,SAAS;AACT;AACA,uBAAuB,+DAAiB;AACxC;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,C;;;;;;;;;;;;ACzfA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqD;;AAErD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;AACA,C;;;;;;;;;;;;ACvCA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0D;AACf;AACa;AACD;;;AAGvD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,wBAAwB;AACzC;AACA;AACA;AACA;AACA,oDAAoD,QAAQ;AAC5D;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,wBAAwB;AACvC,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,UAAU;AACzB,eAAe,YAAY;AAC3B,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA,sBAAsB,6BAA6B;AACnD;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,eAAe,eAAe;AAC9B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,kEAAoB,sBAAsB,SAAS;AACrE;;;AAGA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,oBAAoB,sEAAiB;AACrC;AACA;;AAEA,kBAAkB,kEAAoB,2CAA2C,WAAW;AAC5F;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA,qBAAqB;AACrB;AACA;AACA,gBAAgB,sEAAiB;AACjC;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,gBAAgB,sEAAiB;AACjC;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA,0BAA0B;AAC1B;AACA;AACA,gBAAgB,sEAAiB;AACjC;AACA;;AAEA;AACA;AACA,eAAe,wBAAwB;AACvC,iBAAiB;AACjB;AACA,4BAA4B;AAC5B;AACA;AACA,gBAAgB,sEAAiB;AACjC;AACA;AACA,C;;;;;;;;;;;;AC5LA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6C;AACM;AACD;AAC+B;AACF;AACM;AACxC;AACQ;AACe;AACZ;AACD;;AAEvD;AACA,8BAA8B,gFAAuB;;AAErD;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,oDAAoD;AACnE,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA,0CAA0C,EAAE;AAC5C;AACA,eAAe,yDAAW;AAC1B;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA,+DAA+D,mBAAmB;AAClF;AACA,eAAe,yDAAW;AAC1B;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mBAAmB,+DAAc;AACjC;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,eAAe,WAAkB;AACjC;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,eAAe,6DAAU;AACzB;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,6FAA4B;AAC3C;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,2FAA2B;AAC1C;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,iGAA8B;AAC7C;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA,mBAAmB,iEAAa;AAChC;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,eAAe,mEAAa;AAC5B;AACA;;AAEA;AACA,4CAA4C,yDAAW,E;;;;;;;;;;;;ACrJvD;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0C;AACV;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,+BAA+B,4CAAK;AAC3C;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA,wCAAwC,kDAAK;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,kDAAK,yBAAyB;AACrD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC1MA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgC;;AAEhC;AACA;AACA;AACO,8BAA8B,4CAAK;AAC1C;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,yBAAyB;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA,sDAAsD;;AAEtD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtIA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgC;;AAEhC;AACA;AACA;AACO,wBAAwB,4CAAK;AACpC;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACtDA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE+E;;AAE/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,kEAAoB,0BAA0B,WAAW;;AAE/E;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC,aAAa;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACsB;AACtB;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,sBAAsB,iEAAmB;;AAEzC;AACA;AACA,sBAAsB,kEAAoB,wBAAwB,SAAS,GAAG,SAAS;AACvF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,wBAAwB;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,kBAAkB,iEAAmB;AACrC;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACvXA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuC;AACgD;;;;AAIvF;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,qDAAO;AAC1B;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,qDAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C;AAC3C,6DAA6D;AAC7D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;;AAElC;AACA;;AAEA;AACA,wBAAwB;AACxB;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB;;AAE1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,aAAa;AAC5B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,aAAa;AAC5B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,0FAA0F;AACzG,eAAe,MAAM;AACrB,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;;AAE9B;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAsB,qDAAO,eAAe,aAAa,iCAAiC,oCAAoC;;AAE9H,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,aAAa;AAC5B,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qDAAO,8BAA8B,MAAM,IAAI,OAAO;AAC5E;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,iBAAiB;AAChC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,UAAU;AACzB,eAAe,WAAW;AAC1B,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kDAAK,gFAAgF;AACrG,gGAAgG;AAChG;AACA;AACA,+DAA+D;AAC/D,oBAAoB,kDAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,YAAY;AAC3B,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,gBAAgB;AAC/B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,sBAAsB,mEAAqB;AAC3C,SAAS;AACT;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,WAAW;AAC1B,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,iBAAiB;AAChC,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,kEAAoB;;AAE1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,sBAAsB,mEAAqB;AAC3C,SAAS;AACT;AACA,SAAS;AACT;AACA,C;;;;;;;;;;;;AC/dA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6D;AACR;;;;AAIrD;AACA;AACA;;AAEA;AACA,iBAAiB,wEAAY;;;;;AAK7B;AACA;AACA;AACA;AACO,wBAAwB,wEAAkB;AACjD;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACxDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6D;AACR;AACK;AACM;AACK;AAC5B;AACkB;AAC0D;;AAErH;AACA;AACA,+BAA+B;AAC/B,kDAAkD;AAClD,4DAA4D;AAC5D;AACA,+BAA+B;AAC/B;AACA,kCAAkC;AAClC,oCAAoC;AACpC,4BAA4B;;;;;AAK5B;AACA;AACA;;AAEA;AACA,8BAA8B,wEAAY;AAC1C;;AAEA;AACA,wBAAwB,wEAAY;AACpC;;AAEA;AACA,0BAA0B,wEAAY;AACtC;;AAEA;AACA,wBAAwB,wEAAY;AACpC;AACA;AACA;AACA,wBAAwB;;;;;AAKxB;AACA;AACA;AACA;AACO,0BAA0B,wEAAkB;AACnD;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;;AAEA;AACA,2CAA2C,kDAAK;AAChD,0BAA0B,6EAAe;AACzC;AACA;AACA,kCAAkC;AAClC;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;;AAEzD;AACA;;AAEA;AACA;AACA,gDAAgD;AAChD;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB,eAAe,UAAU;AACzB,iBAAiB,gBAAgB;AACjC;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,UAAU;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA,iBAAiB,6DAAc;AAC/B,iBAAiB,6DAAc;;AAE/B;AACA,6CAA6C,iEAAkB,QAAQ,iEAAkB;AACzF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,qEAAsB,IAAI,qEAAsB,GAAG,iEAAkB;;AAEtF;AACA,iCAAiC;AACjC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAuC,wEAAgB;AACvD,mCAAmC,kEAAa;AAChD;AACA;AACA,mCAAmC,kEAAa;AAChD;;AAEA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA,YAAY,kDAAK;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA,wDAAwD,cAAc,mCAAmC,uBAAuB;AAChI;;AAEA;AACA,sBAAsB,mBAAmB;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,C;;;;;;;;;;;;AC7XA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6D;AACR;AACS;AACX;AACT;AACgB;;;AAG1D;AACA;AACA;;AAEA;AACA,gCAAgC,wEAAY;AAC5C;AACA,6CAA6C,iBAAiB;AAC9D,8BAA8B,wEAAY;AAC1C;;AAEA;AACA,oBAAoB,wEAAY;AAChC;AACA,6BAA6B,wEAAY;AACzC;AACA,0CAA0C,iBAAiB;;;;;AAK3D;AACA;AACA;AACA;AACO,8BAA8B,wEAAkB;AACvD;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,4CAA4C,0EAAK,CAAC,kDAAK;AACvD,4CAA4C,0EAAK,CAAC,kDAAK;AACvD;AACA,0CAA0C,0EAAK,CAAC,kDAAK;AACrD,0CAA0C,0EAAK,CAAC,kDAAK;AACrD;AACA,4CAA4C,0EAAK,CAAC,kDAAK;AACvD,4CAA4C,0EAAK,CAAC,kDAAK;AACvD;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,+DAA+D,2DAAc;AAC7E;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,qFAAqF,2DAAc;AACnG,qFAAqF,2DAAc;AACnG,4DAA4D,2DAAc;;AAE1E;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO,2BAA2B;AACjD,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB,4CAA4C,QAAQ;;AAE9F;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC1JA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6D;AACR;AACwE;AAC1E;AACT;;;;AAI1C;AACA;AACA;;AAEA;AACA,oBAAoB,wEAAY;AAChC;AACA,iCAAiC,mBAAmB;;AAEpD;AACA,oBAAoB,wEAAY;AAChC;AACA,iCAAiC,mBAAmB;;;;AAIpD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACO,yBAAyB,wEAAkB;AAClD;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gCAAgC,sEAAM;;AAEtC;AACA;;AAEA;AACA,mCAAmC,8EAAS,MAAM;AAClD;AACA,aAAa;AACb,mCAAmC,8EAAS,MAAM;AAClD;AACA,aAAa;AACb,mCAAmC,8EAAS,MAAM;AAClD;AACA,aAAa;;AAEb;AACA;AACA,kCAAkC,6EAAQ;AAC1C,kCAAkC,6EAAQ;AAC1C;AACA,kCAAkC,6EAAQ;AAC1C,kCAAkC,6EAAQ;AAC1C;AACA,kCAAkC,6EAAQ;AAC1C,kCAAkC,6EAAQ;AAC1C;AACA,kCAAkC,6EAAQ;AAC1C,kCAAkC,6EAAQ;AAC1C;AACA,mCAAmC,6EAAQ;AAC3C,mCAAmC,6EAAQ;;AAE3C;AACA,wCAAwC,mFAAc,MAAM;AAC5D;AACA;AACA,aAAa;AACb,wCAAwC,mFAAc,MAAM;AAC5D;AACA;AACA,aAAa;AACb,wCAAwC,mFAAc,MAAM;AAC5D;AACA;AACA,aAAa;AACb,wCAAwC,mFAAc,MAAM;AAC5D;AACA;AACA,aAAa;AACb,wCAAwC,mFAAc,MAAM;AAC5D;AACA;AACA,aAAa;AACb,wCAAwC,mFAAc,MAAM;AAC5D;AACA;AACA,aAAa;AACb,wCAAwC,mFAAc,MAAM;AAC5D;AACA;AACA,aAAa;AACb,yCAAyC,mFAAc,OAAO;AAC9D;AACA;AACA,aAAa;AACb,oDAAoD;AACpD;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;;;;;AAKb;AACA;AACA,iCAAiC,0EAAK;AACtC;AACA;AACA;AACA,iCAAiC,0EAAK;AACtC;AACA;AACA;AACA,iCAAiC,0EAAK;AACtC;AACA;AACA;AACA,iCAAiC,0EAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,0EAAK,CAAC,kDAAK;AAC5C,iCAAiC,0EAAK,CAAC,kDAAK;AAC5C,iCAAiC,0EAAK,CAAC,kDAAK;AAC5C,iCAAiC,0EAAK,CAAC,kDAAK;AAC5C,kCAAkC,0EAAK,CAAC,kDAAK;AAC7C,kCAAkC,0EAAK,CAAC,kDAAK;;;;;AAK7C;AACA,+BAA+B,0EAAK;AACpC;AACA;AACA,+BAA+B,0EAAK;AACpC;AACA;AACA,+BAA+B,0EAAK;AACpC;AACA;AACA,+BAA+B,0EAAK;AACpC;AACA;AACA,+BAA+B,0EAAK;AACpC;AACA;AACA,+BAA+B,0EAAK;AACpC;AACA;AACA,+BAA+B,0EAAK;AACpC;AACA;AACA,+BAA+B,0EAAK;AACpC;AACA;AACA,gCAAgC,0EAAK;AACrC;AACA;AACA,gCAAgC,0EAAK;AACrC;AACA;;;AAGA;AACA;AACA,kCAAkC,0EAAK;AACvC;AACA;AACA,kCAAkC,0EAAK;AACvC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjPA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6D;AACR;AACX;;;;AAI1C;AACA;AACA;;AAEA;AACA;AACA,cAAc,wEAAY;;AAE1B;AACA;AACA,cAAc,wEAAY;;AAE1B;AACA;AACA,cAAc,wEAAY;;AAE1B;AACA;AACA,oBAAoB,wEAAY;;AAEhC;AACA;AACA,oBAAoB,wEAAY;;AAEhC;AACA;AACA,mBAAmB,wEAAY;;AAE/B;AACA;AACA,uBAAuB,wEAAY;AACnC;;AAEA;AACA;AACA,iCAAiC,wEAAY;AAC7C;AACA;AACA;AACA,iCAAiC;;;;AAIjC;AACA;AACA;;AAEA;AACA,yBAAyB,wEAAY;AACrC;;AAEA;AACA,qBAAqB,wEAAY;;;;AAIjC;AACA;AACA;AACA,cAAc,wEAAY;AAC1B;;;;AAIA;AACA;AACA;AACA,YAAY,wEAAY;AACxB;;;;AAIA;AACA;AACA;;AAEA;AACA,0BAA0B,wEAAY;AACtC,8BAA8B,wEAAY;AAC1C,6BAA6B,wEAAY;;AAEzC;AACA,wBAAwB,wEAAY;;AAEpC;AACA,+BAA+B,wEAAY;AAC3C;;;;;AAKA;AACA;AACA;AACA;AACO,2BAA2B,wEAAkB;AACpD;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,QAAQ,kDAAK;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AClNA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6D;AACR;AACS;;;;AAI9D;AACA;AACA;;AAEA;AACA,kBAAkB,wEAAY;AAC9B,oBAAoB,wEAAY;AAChC,kBAAkB,wEAAY;AAC9B,oBAAoB,wEAAY;;AAEhC;AACA,cAAc,wEAAY;;;;AAI1B;AACA;AACA;AACA;AACO,0BAA0B,wEAAkB;AACnD;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;;;AAIb;AACA;AACA;AACA,iCAAiC,0EAAK;AACtC;AACA;AACA,iCAAiC,0EAAK;AACtC;AACA;;AAEA;AACA;AACA,kCAAkC,0EAAK;AACvC;AACA;;AAEA,kCAAkC,0EAAK;AACvC;AACA;;AAEA;AACA;AACA,kCAAkC,0EAAK;AACvC;AACA;;AAEA,kCAAkC,0EAAK;AACvC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACtIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6D;AACR;AACI;;;;AAIzD;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B,oCAAoC;AACpC,sCAAsC;AACtC,sCAAsC;AACtC,6BAA6B;AAC7B;;AAEA,WAAW,wEAAY;AACvB;AACA;AACA;AACA,YAAY;;AAEZ,kBAAkB,wEAAY;AAC9B;AACA;AACA;AACA,mBAAmB;;AAEnB,gBAAgB,wEAAY;AAC5B;AACA;AACA;AACA,iBAAiB;;AAEjB,uBAAuB,wEAAY;AACnC;AACA;AACA;AACA,wBAAwB;;AAExB,kBAAkB,wEAAY;AAC9B;AACA;AACA;AACA,mBAAmB;;AAEnB,yBAAyB,wEAAY;AACrC;AACA;AACA;AACA,0BAA0B;;AAE1B,mBAAmB,wEAAY;AAC/B;AACA;AACA;AACA,oBAAoB;;AAEpB,0BAA0B,wEAAY;AACtC;AACA;AACA;AACA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACO,0BAA0B,wEAAkB;AACnD;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,yCAAyC,iEAAkB;AAC3D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,4BAA4B;AAC5B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,eAAe;AACrC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;ACrLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6D;AACR;AACf;AAC+B;AACX;;;;AAI1D;AACA;AACA;;AAEA;AACA,iBAAiB,wEAAY;;AAE7B;AACA,cAAc,wEAAY;;AAE1B;AACA,aAAa,wEAAY;;AAEzB;AACA,uBAAuB,wEAAY;;AAEnC;AACA,uBAAuB,wEAAY;;AAEnC;AACA;;AAEA;AACA,qBAAqB,wEAAY;;;;AAIjC;AACA;AACA;AACA;AACO,uBAAuB,wEAAkB;AAChD;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA,oEAAoE,2DAAc;AAClF;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA,oEAAoE,2DAAc;AAClF;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA,YAAY,6DAAgB;AAC5B,sBAAsB,kEAAoB,0BAA0B,aAAa;;AAEjF,+BAA+B,6DAAgB;AAC/C;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,OAAO;AACtB,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,2DAAc;;AAEtE,sBAAsB,mBAAmB;AACzC;;AAEA;AACA;AACA,C;;;;;;;;;;;;AC5KA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2D;AAC2B;;AAEtF;AACA;;AAEA;AACA,UAAU;AACV,UAAU;AACV;;AAEA;AACA,yBAAyB,gBAAgB;AACzC,iBAAiB;AACjB,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mEAAQ,IAAY,WAAW,CAAC;;AAElE;AACA,+BAA+B,uEAAkB;AACjD,6BAA6B,uEAAkB;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,+DAAiB,0BAA0B,SAAS;;AAE1E,sCAAsC,WAAW;AACjD;;AAEA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B,kEAAoB,cAAc,QAAQ;AACxE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,IAAI,GAAG,aAAa;;AAErD;AACA;AACA,+BAA+B,uEAAkB;AACjD;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB,kEAAoB,oCAAoC,KAAK;;AAEnF;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,yDAAyD;AACzD,+EAA+E;AAC/E,0BAA0B;;AAE1B;AACA;AACA;AACA,4FAA4F;;AAE5F;AACA;AACA;AACA;AACA,kCAAkC,wDAAU,0CAA0C,KAAK;AAC3F;AACA,kCAAkC,YAAY;AAC9C,oCAAoC,MAAM,GAAG,EAAE;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;AACA;AACA,C;;;;;;;;;;;;AC3PA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuH;AAC3D;AACZ;AACI;;AAEpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,iEAAkB;;AAE5C;AACA,0BAA0B,iEAAkB;AAC5C,8BAA8B,qEAAsB;AACpD,2BAA2B,kEAAmB;;AAE9C;AACA,0BAA0B,2DAAc;AACxC,4BAA4B,2DAAc;AAC1C,2BAA2B,2DAAc;AACzC,4BAA4B,2DAAc;;AAE1C;AACA,gBAAgB,uDAAQ;AACxB,sBAAsB,6DAAc;AACpC;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe,2EAAQ,IAAoB,WAAW,CAAC;;AAEvD,cAAc,+DAAiB,2CAA2C,SAAS;AACnF,C;;;;;;;;;;;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kE;;;;;;;;;;;ACpEA,uEAAuE,0BAA0B,gBAAgB,kCAAkC,6BAA6B,8BAA8B,GAAG,C;;;;;;;;;;;ACAjN,0CAA0C,0BAA0B,4BAA4B,gBAAgB,kCAAkC,+BAA+B,kBAAkB,yFAAyF,WAAW,oCAAoC,2BAA2B,GAAG,kEAAkE,GAAG,C;;;;;;;;;;;ACA9a,uEAAuE,0BAA0B,4BAA4B,6BAA6B,wBAAwB,oEAAoE,oBAAoB,yBAAyB,mCAAmC,yCAAyC,2BAA2B,0BAA0B,iCAAiC,qDAAqD,GAAG,eAAe,GAAG,gBAAgB,kCAAkC,kGAAkG,gEAAgE,iBAAiB,aAAa,qBAAqB,iCAAiC,uCAAuC,mDAAmD,4IAA4I,GAAG,C;;;;;;;;;;;ACAhiC,yEAAyE,4BAA4B,6BAA6B,wBAAwB,8HAA8H,8CAA8C,IAAI,gBAAgB,kCAAkC,kGAAkG,gEAAgE,qBAAqB,iCAAiC,gCAAgC,0BAA0B,WAAW,oCAAoC,0BAA0B,yBAAyB,4EAA4E,QAAQ,GAAG,WAAW,uBAAuB,kCAAkC,2CAA2C,6CAA6C,QAAQ,GAAG,YAAY,qBAAqB,QAAQ,GAAG,GAAG,GAAG,C;;;;;;;;;;;ACAhiC,0CAA0C,oCAAoC,qBAAqB,uBAAuB,sBAAsB,sHAAsH,0GAA0G,4BAA4B,0CAA0C,4BAA4B,iCAAiC,gBAAgB,kCAAkC,gDAAgD,sDAAsD,yCAAyC,2CAA2C,sCAAsC,gDAAgD,sGAAsG,oDAAoD,uCAAuC,6CAA6C,8CAA8C,0FAA0F,2BAA2B,6DAA6D,2DAA2D,wCAAwC,WAAW,C;;;;;;;;;;;ACAj3C,+DAA+D,0CAA0C,iCAAiC,yBAAyB,kCAAkC,gBAAgB,uEAAuE,+BAA+B,4CAA4C,sDAAsD,uDAAuD,kDAAkD,kIAAkI,qFAAqF,yFAAyF,mFAAmF,6EAA6E,uBAAuB,GAAG,C;;;;;;;;;;;;ACAh/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwD;AACX;AACgB;;;;AAI7D;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB;AACO;AACP;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA,kBAAkB,kEAAoB,4DAA4D,MAAM;AACxG;AACA,kBAAkB,kEAAoB,qCAAqC,gBAAgB;;AAE3F;AACA;;AAEA;AACA,uCAAuC,kDAAK,WAAW,kDAAK,oBAAoB,kDAAK;AACrF;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,cAAc,gBAAgB,OAAO,IAAI,OAAO,aAAa,GAAG;AACpF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA,WAAW,wEAAY;AACvB;;;;;AAKA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB;AACO;AACP;AACA;AACA;;;;;AAKA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB;AACO;AACP;AACA;AACA;;;;;AAKA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA,kBAAkB,kEAAoB,4DAA4D,MAAM;AACxG;AACA,kBAAkB,kEAAoB,gDAAgD,KAAK,IAAI;;AAE/F;AACA;;AAEA;AACA,uCAAuC,kDAAK;AAC5C;AACA;AACA;AACA,mBAAmB,cAAc,gBAAgB,MAAM,gBAAgB,GAAG;AAC1E;AACA,mBAAmB,cAAc,mBAAmB,MAAM,aAAa,GAAG;AAC1E;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA,WAAW,wEAAY;AACvB;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,IAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,OAAO;AAChB;AACA,uBAAuB,KAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACO;AACP;AACA;AACA;AACA;AACA,kBAAkB,kEAAoB,6CAA6C,WAAW;;AAE9F;AACA;AACA,2BAA2B,wBAAwB;;AAEnD;AACA;AACA;AACA,8BAA8B,WAAW;;AAEzC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,wEAAY;AACvB;;;;;AAKA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACO;AACP;AACA;AACA;AACA;AACA,kBAAkB,kEAAoB,6CAA6C,WAAW;;AAE9F;AACA;AACA,2BAA2B,WAAW;;AAEtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,wEAAY;AACvB;;;;;AAKA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACO;AACP;AACA;AACA,8BAA8B;AAC9B;AACA,kBAAkB,kEAAoB,gFAAgF,WAAW;;AAEjI;AACA;;AAEA;AACA,uCAAuC,kDAAK,WAAW,kDAAK,oBAAoB,kDAAK;AACrF;AACA;;AAEA;AACA,4CAA4C,MAAM,IAAI,MAAM;AAC5D;AACA,oBAAoB,cAAc,gBAAgB,EAAE,IAAI,EAAE;AAC1D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA,WAAW,wEAAY;AACvB;;;;;AAKA;AACA;AACA,WAAW,OAAO;AAClB;AACO;;;;AAIP;AACA;AACA,WAAW,OAAO;AAClB;AACO;;;;;AAKP;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,kBAAkB,kEAAoB,gFAAgF,WAAW;AACjI;AACA,kBAAkB,kEAAoB,gEAAgE,KAAK,IAAI;;AAE/G;AACA;;AAEA;AACA,uCAAuC,kDAAK;AAC5C;AACA,4CAA4C,MAAM;AAClD;AACA,oBAAoB,cAAc,gBAAgB,EAAE;AACpD;AACA,4CAA4C,MAAM;AAClD;AACA,oBAAoB,cAAc,mBAAmB,EAAE;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA,WAAW,wEAAY;AACvB,C;;;;;;;;;;;AC1ZA,0CAA0C,qCAAqC,wBAAwB,iBAAiB,gBAAgB,kBAAkB,mCAAmC,mDAAmD,kDAAkD,kDAAkD,kDAAkD,iDAAiD,iDAAiD,kDAAkD,iDAAiD,iDAAiD,YAAY,YAAY,YAAY,YAAY,YAAY,YAAY,YAAY,YAAY,YAAY,YAAY,YAAY,YAAY,YAAY,YAAY,YAAY,YAAY,YAAY,YAAY,YAAY,gBAAgB,sCAAsC,mDAAmD,mDAAmD,kDAAkD,kDAAkD,kDAAkD,mDAAmD,mDAAmD,kDAAkD,kDAAkD,kDAAkD,mDAAmD,mDAAmD,kDAAkD,kDAAkD,kDAAkD,mDAAmD,mDAAmD,kDAAkD,kDAAkD,kDAAkD,mDAAmD,mDAAmD,kDAAkD,kDAAkD,kDAAkD,YAAY,YAAY,YAAY,YAAY,YAAY,YAAY,YAAY,aAAa,aAAa,YAAY,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,YAAY,YAAY,YAAY,YAAY,YAAY,YAAY,YAAY,cAAc,aAAa,aAAa,cAAc,aAAa,aAAa,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,cAAc,aAAa,aAAa,aAAa,YAAY,cAAc,aAAa,aAAa,cAAc,aAAa,aAAa,cAAc,aAAa,aAAa,cAAc,aAAa,aAAa,cAAc,aAAa,aAAa,cAAc,aAAa,aAAa,aAAa,aAAa,cAAc,cAAc,aAAa,aAAa,YAAY,aAAa,aAAa,cAAc,aAAa,aAAa,aAAa,aAAa,YAAY,YAAY,cAAc,cAAc,YAAY,cAAc,aAAa,aAAa,cAAc,aAAa,aAAa,cAAc,aAAa,cAAc,cAAc,cAAc,cAAc,iBAAiB,4FAA4F,GAAG,C;;;;;;;;;;;;ACAhhH;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwD;AACX;AACgB;;AAE7D;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACO;AACP;AACA;AACA;AACA;AACA,kBAAkB,kEAAoB,sCAAsC,WAAW,GAAG,WAAW;;AAErG;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,kDAAK;AAC5C,QAAQ,kDAAK,4BAA4B,kDAAK;AAC9C;AACA;AACA;AACA;AACA,YAAY,EAAE,MAAM,cAAc,gBAAgB,EAAE,IAAI,EAAE;AAC1D;;AAEA;AACA;AACA,uCAAuC,kDAAK;AAC5C,6BAA6B,kDAAK;AAClC,qBAAqB,EAAE,gBAAgB,EAAE;AACzC;AACA;AACA,cAAc;AACd,UAAU;AACV,mBAAmB,EAAE;AACrB,YAAY,EAAE;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,EAAE;AACpB;;AAEA;AACA,UAAU;;AAEV;AACA,UAAU;;AAEV;AACA,yBAAyB,IAAI,OAAO,IAAI,OAAO,IAAI;AACnD;AACA;;AAEA;AACA,WAAW,wEAAY;AACvB,C;;;;;;;;;;;AC1FA,iGAAiG,oBAAoB,oGAAoG,gGAAgG,2CAA2C,gBAAgB,wBAAwB,8fAA8f,4DAA4D,0DAA0D,kHAAkH,0BAA0B,GAAG,C;;;;;;;;;;;ACA/oC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0E;;;;;;;;;;;AC7BA,sR;;;;;;;;;;;ACAA,wJAAwJ,uDAAuD,sZ;;;;;;;;;;;ACA/M,iLAAiL,+CAA+C,QAAQ,EAAE,6Z;;;;;;;;;;;ACA1O,gLAAgL,gBAAgB,oBAAoB,YAAY,cAAc,IAAI,2BAA2B,WAAW,aAAa,IAAI,yhBAAyhB,yDAAyD,+EAA+E,0BAA0B,4DAA4D,mDAAmD,oDAAoD,iBAAiB,GAAG,oGAAoG,oBAAoB,qCAAqC,2CAA2C,+FAA+F,6DAA6D,2IAA2I,gGAAgG,gEAAgE,gDAAgD,uCAAuC,kBAAkB,GAAG,+CAA+C,qCAAqC,0BAA0B,yBAAyB,2EAA2E,GAAG,wLAAwL,iEAAiE,kGAAkG,GAAG,S;;;;;;;;;;;ACAz8E,8UAA8U,0BAA0B,gIAAgI,GAAG,wGAAwG,8FAA8F,GAAG,gE;;;;;;;;;;;ACAprB,yO;;;;;;;;;;;ACAA,0yBAA0yB,2DAA2D,iEAAiE,uEAAuE,+BAA+B,0FAA0F,GAAG,sCAAsC,iIAAiI,GAAG,0KAA0K,S;;;;;;;;;;;ACA77C,wFAAwF,uCAAuC,+BAA+B,8BAA8B,gCAAgC,GAAG,wCAAwC,+BAA+B,wCAAwC,GAAG,S;;;;;;;;;;;ACAjV,0DAA0D,uCAAuC,gBAAgB,kCAAkC,wBAAwB,2BAA2B,uCAAuC,uCAAuC,qDAAqD,sEAAsE,sEAAsE,iCAAiC,+CAA+C,+CAA+C,+CAA+C,iCAAiC,+CAA+C,+CAA+C,+CAA+C,kHAAkH,gCAAgC,gDAAgD,gCAAgC,gCAAgC,2IAA2I,2IAA2I,0EAA0E,0EAA0E,uCAAuC,qCAAqC,qCAAqC,uCAAuC,+CAA+C,iCAAiC,oEAAoE,wBAAwB,mFAAmF,kGAAkG,6BAA6B,sCAAsC,qEAAqE,mDAAmD,kDAAkD,+DAA+D,GAAG,C;;;;;;;;;;;ACArwE,0CAA0C,0BAA0B,gBAAgB,kCAAkC,yCAAyC,4CAA4C,sDAAsD,sDAAsD,sDAAsD,sDAAsD,uDAAuD,uDAAuD,uDAAuD,wDAAwD,wDAAwD,uDAAuD,wDAAwD,wDAAwD,iCAAiC,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,4DAA4D,4DAA4D,gDAAgD,qEAAqE,GAAG,C;;;;;;;;;;;ACAprD,0CAA0C,0BAA0B,mDAAmD,iDAAiD,gBAAgB,kCAAkC,yCAAyC,4CAA4C,ktBAAktB,uMAAuM,2DAA2D,6BAA6B,2BAA2B,6BAA6B,2BAA2B,6BAA6B,2BAA2B,0DAA0D,qEAAqE,GAAG,C;;;;;;;;;;;ACA7iD,0CAA0C,0BAA0B,gBAAgB,kCAAkC,yCAAyC,4CAA4C,sDAAsD,sDAAsD,sDAAsD,uDAAuD,uDAAuD,wDAAwD,uDAAuD,uDAAuD,iCAAiC,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,+CAA+C,qEAAqE,GAAG,C;;;;;;;;;;;ACAzuC,0CAA0C,0BAA0B,gBAAgB,kCAAkC,4BAA4B,kCAAkC,gCAAgC,6FAA6F,yCAAyC,oBAAoB,gCAAgC,sDAAsD,sDAAsD,sDAAsD,uDAAuD,uDAAuD,wDAAwD,uDAAuD,uDAAuD,oIAAoI,sBAAsB,2CAA2C,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,8BAA8B,2BAA2B,iCAAiC,YAAY,iCAAiC,YAAY,iCAAiC,YAAY,iCAAiC,YAAY,GAAG,cAAc,2BAA2B,gCAAgC,YAAY,gCAAgC,YAAY,gCAAgC,YAAY,gCAAgC,YAAY,GAAG,cAAc,wDAAwD,GAAG,QAAQ,gCAAgC,GAAG,GAAG,GAAG,GAAG,C;;;;;;;;;;;ACA1tF,0CAA0C,0BAA0B,gBAAgB,kCAAkC,4BAA4B,kCAAkC,gCAAgC,6FAA6F,yCAAyC,oBAAoB,gCAAgC,sDAAsD,sDAAsD,sDAAsD,sDAAsD,uDAAuD,uDAAuD,uDAAuD,wDAAwD,wDAAwD,uDAAuD,wDAAwD,wDAAwD,oIAAoI,sBAAsB,2CAA2C,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,gBAAgB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,cAAc,SAAS,yBAAyB,EAAE,aAAa,EAAE,iBAAiB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,eAAe,SAAS,yBAAyB,EAAE,aAAa,EAAE,iBAAiB,QAAQ,SAAS,6BAA6B,EAAE,QAAQ,QAAQ,eAAe,SAAS,yBAAyB,EAAE,aAAa,EAAE,8BAA8B,2BAA2B,iCAAiC,YAAY,iCAAiC,YAAY,iCAAiC,YAAY,iCAAiC,YAAY,iCAAiC,YAAY,iCAAiC,YAAY,GAAG,cAAc,2BAA2B,gCAAgC,YAAY,gCAAgC,YAAY,gCAAgC,YAAY,gCAAgC,YAAY,gCAAgC,YAAY,gCAAgC,YAAY,GAAG,cAAc,wDAAwD,GAAG,QAAQ,gCAAgC,GAAG,GAAG,GAAG,GAAG,C;;;;;;;;;;;ACAlrH,0CAA0C,0BAA0B,yCAAyC,gBAAgB,kCAAkC,kCAAkC,4BAA4B,gCAAgC,kEAAkE,yCAAyC,4CAA4C,sDAAsD,sDAAsD,uDAAuD,wDAAwD,gIAAgI,sDAAsD,sDAAsD,sDAAsD,uDAAuD,uDAAuD,uDAAuD,wDAAwD,yDAAyD,yDAAyD,wDAAwD,wDAAwD,wDAAwD,mWAAmW,8vEAA8vE,2CAA2C,GAAG,C;;;;;;;;;;;ACAvhI,4CAA4C,6BAA6B,wBAAwB,gBAAgB,oCAAoC,yEAAyE,mDAAmD,iCAAiC,GAAG,C;;;;;;;;;;;ACArT,wEAAwE,0BAA0B,8BAA8B,yCAAyC,mDAAmD,iDAAiD,gBAAgB,oCAAoC,kCAAkC,4BAA4B,yCAAyC,4CAA4C,kCAAkC,oRAAoR,sBAAsB,gBAAgB,qBAAqB,OAAO,8BAA8B,wBAAwB,+DAA+D,6CAA6C,8DAA8D,6CAA6C,8DAA8D,6CAA6C,8DAA8D,6CAA6C,6DAA6D,6CAA6C,6DAA6D,6CAA6C,8DAA8D,6CAA6C,6DAA6D,6CAA6C,6DAA6D,6CAA6C,GAAG,qDAAqD,+BAA+B,qBAAqB,0BAA0B,qCAAqC,iCAAiC,mBAAmB,oBAAoB,2OAA2O,4rBAA4rB,uhBAAuhB,8vEAA8vE,qBAAqB,qNAAqN,uBAAuB,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,0DAA0D,mGAAmG,iCAAiC,yDAAyD,8DAA8D,8MAA8M,2DAA2D,6BAA6B,2BAA2B,6BAA6B,2BAA2B,6BAA6B,2BAA2B,oDAAoD,mCAAmC,sCAAsC,iDAAiD,+BAA+B,sDAAsD,GAAG,uBAAuB,GAAG,C;;;;;;;;;;;ACAx8O,iGAAiG,yBAAyB,8BAA8B,4DAA4D,uDAAuD,iBAAiB,2FAA2F,2FAA2F,2FAA2F,2FAA2F,2FAA2F,2FAA2F,2FAA2F,2FAA2F,GAAG,GAAG,gBAAgB,kCAAkC,oCAAoC,kCAAkC,+BAA+B,oDAAoD,qBAAqB,0BAA0B,YAAY,kCAAkC,gBAAgB,gBAAgB,OAAO,gBAAgB,gBAAgB,OAAO,uEAAuE,mDAAmD,GAAG,GAAG,2FAA2F,uCAAuC,yDAAyD,mCAAmC,+BAA+B,sDAAsD,GAAG,yCAAyC,GAAG,C;;;;;;;;;;;ACAl1D,sEAAsE,kGAAkG,kCAAkC,iCAAiC,uBAAuB,gBAAgB,8BAA8B,6EAA6E,mDAAmD,mDAAmD,oDAAoD,oDAAoD,qDAAqD,oDAAoD,oDAAoD,6CAA6C,uEAAuE,sFAAsF,mDAAmD,mDAAmD,mDAAmD,mDAAmD,oDAAoD,oDAAoD,oDAAoD,oDAAoD,qDAAqD,sDAAsD,sDAAsD,qDAAqD,qDAAqD,qDAAqD,qDAAqD,mFAAmF,qHAAqH,qFAAqF,mDAAmD,mDAAmD,mDAAmD,oDAAoD,oDAAoD,oDAAoD,qDAAqD,qDAAqD,oDAAoD,qDAAqD,qDAAqD,oDAAoD,oDAAoD,qDAAqD,qDAAqD,mFAAmF,sHAAsH,0EAA0E,4CAA4C,uCAAuC,yCAAyC,muBAAmuB,+6CAA+6C,86CAA86C,8EAA8E,uGAAuG,kGAAkG,uFAAuF,mHAAmH,8GAA8G,0EAA0E,oDAAoD,mCAAmC,GAAG,C;;;;;;;;;;;ACAj7O,0CAA0C,gBAAgB,sDAAsD,sDAAsD,sDAAsD,uDAAuD,uDAAuD,wDAAwD,uDAAuD,uDAAuD,mFAAmF,kCAAkC,2CAA2C,iCAAiC,GAAG,C;;;;;;;;;;;ACAprB,gFAAgF,4BAA4B,4BAA4B,wBAAwB,gCAAgC,ikKAAikK,8EAA8E,4BAA4B,0BAA0B,0BAA0B,gFAAgF,gFAAgF,GAAG,gBAAgB,2CAA2C,kCAAkC,kGAAkG,sDAAsD,gBAAgB,iCAAiC,6EAA6E,kDAAkD,iCAAiC,yCAAyC,yCAAyC,iDAAiD,yCAAyC,yCAAyC,gBAAgB,OAAO,OAAO,iBAAiB,aAAa,YAAY,gBAAgB,gBAAgB,OAAO,OAAO,kDAAkD,+FAA+F,+FAA+F,+BAA+B,GAAG,iBAAiB,GAAG,wFAAwF,GAAG,C;;;;;;;;;;;ACAptN,yEAAyE,qCAAqC,0BAA0B,6BAA6B,wBAAwB,4BAA4B,mEAAmE,wEAAwE,mpMAAmpM,iCAAiC,iCAAiC,gBAAgB,6CAA6C,kCAAkC,kGAAkG,gBAAgB,kCAAkC,+EAA+E,iCAAiC,sBAAsB,8CAA8C,yDAAyD,uEAAuE,iCAAiC,sCAAsC,gBAAgB,WAAW,OAAO,2CAA2C,0DAA0D,+EAA+E,6BAA6B,GAAG,oCAAoC,qCAAqC,GAAG,C;;;;;;;;;;;ACAz+O,sEAAsE,gBAAgB,kCAAkC,kCAAkC,iCAAiC,wBAAwB,gBAAgB,8BAA8B,mDAAmD,mDAAmD,mDAAmD,oDAAoD,oDAAoD,qDAAqD,oDAAoD,oDAAoD,8ZAA8Z,0DAA0D,mEAAmE,oDAAoD,mCAAmC,GAAG,C;;;;;;;;;;;ACApxC,0CAA0C,gBAAgB,kCAAkC,yDAAyD,8BAA8B,GAAG,C;;;;;;;;;;;ACAtL,0CAA0C,gBAAgB,kCAAkC,yDAAyD,8BAA8B,GAAG,C;;;;;;;;;;;ACAtL,0CAA0C,gBAAgB,kCAAkC,0CAA0C,uFAAuF,GAAG,C;;;;;;;;;;;ACAhO,0CAA0C,gBAAgB,kCAAkC,0CAA0C,yDAAyD,iGAAiG,GAAG,C;;;;;;;;;;;ACAnS,yEAAyE,qCAAqC,yBAAyB,iCAAiC,oDAAoD,6BAA6B,wBAAwB,4BAA4B,4HAA4H,uFAAuF,oEAAoE,sDAAsD,kDAAkD,8MAA8M,8CAA8C,wBAAwB,yBAAyB,sKAAsK,gBAAgB,OAAO,gBAAgB,gBAAgB,OAAO,wBAAwB,GAAG,GAAG,eAAe,gBAAgB,gBAAgB,OAAO,wBAAwB,wBAAwB,uBAAuB,uBAAuB,GAAG,uBAAuB,uBAAuB,uBAAuB,uBAAuB,GAAG,0CAA0C,iEAAiE,iEAAiE,+aAA+a,2CAA2C,2CAA2C,+BAA+B,mIAAmI,GAAG,gBAAgB,6CAA6C,kCAAkC,kGAAkG,yBAAyB,gBAAgB,kCAAkC,+EAA+E,kDAAkD,kEAAkE,kEAAkE,8CAA8C,gCAAgC,6CAA6C,gBAAgB,gBAAgB,OAAO,gBAAgB,gBAAgB,OAAO,oDAAoD,kKAAkK,GAAG,GAAG,4CAA4C,uHAAuH,2CAA2C,oDAAoD,oDAAoD,6CAA6C,GAAG,C;;;;;;;;;;;ACAnkH,6EAA6E,gCAAgC,kCAAkC,yBAAyB,oBAAoB,oDAAoD,6BAA6B,wBAAwB,4BAA4B,6RAA6R,uFAAuF,gFAAgF,oEAAoE,qGAAqG,4RAA4R,kDAAkD,wBAAwB,yBAAyB,eAAe,SAAS,0DAA0D,sCAAsC,8FAA8F,6GAA6G,gBAAgB,OAAO,gBAAgB,gBAAgB,OAAO,yBAAyB,GAAG,GAAG,eAAe,gBAAgB,gBAAgB,OAAO,yBAAyB,yBAAyB,wBAAwB,wBAAwB,GAAG,wBAAwB,wBAAwB,wBAAwB,wBAAwB,GAAG,yDAAyD,iEAAiE,iEAAiE,6DAA6D,+hBAA+hB,2CAA2C,2CAA2C,+BAA+B,mIAAmI,GAAG,yDAAyD,sCAAsC,wCAAwC,6DAA6D,mEAAmE,GAAG,gBAAgB,0CAA0C,kCAAkC,kGAAkG,yBAAyB,gBAAgB,iCAAiC,4EAA4E,kDAAkD,kEAAkE,kEAAkE,6BAA6B,gBAAgB,WAAW,OAAO,mCAAmC,qCAAqC,sDAAsD,gBAAgB,gBAAgB,OAAO,gBAAgB,gBAAgB,OAAO,qEAAqE,uJAAuJ,GAAG,GAAG,gCAAgC,0FAA0F,qCAAqC,gBAAgB,oBAAoB,OAAO,oCAAoC,iBAAiB,iBAAiB,QAAQ,iBAAiB,iBAAiB,QAAQ,iBAAiB,gBAAgB,uEAAuE,yJAAyJ,kDAAkD,GAAG,GAAG,6FAA6F,iCAAiC,GAAG,4CAA4C,GAAG,8BAA8B,sDAAsD,qDAAqD,uCAAuC,sLAAsL,gHAAgH,GAAG,C;;;;;;;;;;;ACAl+K,wEAAwE,6BAA6B,6BAA6B,gBAAgB,qCAAqC,mCAAmC,kNAAkN,gEAAgE,GAAG,C;;;;;;;;;;;ACA/e,oEAAoE,8BAA8B,sBAAsB,gBAAgB,kCAAkC,sNAAsN,yCAAyC,GAAG,C;;;;;;;;;;;ACA5a,sCAAsC,gBAAgB,sBAAsB,GAAG,C;;;;;;;;;;;ACA/E,0CAA0C,eAAe,+BAA+B,qCAAqC,8BAA8B,GAAG,C;;;;;;;;;;;ACA9J,0CAA0C,gBAAgB,6BAA6B,GAAG,C;;;;;;;;;;;ACA1F,0CAA0C,8BAA8B,gBAAgB,kCAAkC,uCAAuC,oCAAoC,gCAAgC,sCAAsC,qFAAqF,oFAAoF,oFAAoF,uFAAuF,yCAAyC,mDAAmD,mDAAmD,mDAAmD,4CAA4C,4CAA4C,sDAAsD,GAAG,C;;;;;;;;;;;;ACAl7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwC;AACS;AACV;AACuB;AACR;AACoB;;AAE1E;AACA,6BAA6B;;AAE7B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB,iEAAkB,mBAAmB,iEAAkB;AAChF,YAAY,kDAAK,iDAAiD,YAAY,KAAK,aAAa;AAChG,gDAAgD,iEAAkB;AAClE,kDAAkD,iEAAkB;AACpE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,0FAA0F;AACzG,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,kDAAK;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,kEAAoB;;AAE1C;AACA;AACA;AACA;AACA;AACA,oBAAoB,6DAAa;AACjC;AACA;AACA,YAAY,kDAAK,kCAAkC,MAAM,KAAK,OAAO;AACrE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kDAAK;AACzB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD,qBAAqB;AACrB;AACA;AACA,8BAA8B;AAC9B,aAAa;AACb;AACA;AACA,sBAAsB,+DAAiB;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,kDAAK;AACrB;AACA,SAAS;AACT;AACA;AACA,gBAAgB,kDAAK;AACrB;AACA,SAAS;;AAET;AACA;;AAEA;AACA,6BAA6B,0EAAmB;AAChD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,+DAAiB;;AAEvC;AACA;;AAEA,WAAW,kDAAK;AAChB;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,+DAAiB;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,kBAAkB,+DAAiB;;AAEnC;AACA,C;;;;;;;;;;;;ACvSA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4C;AACE;AACE;AACI;AACF;AACA;AACQ;AACR;;AAElD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iDAAiD,wDAAQ;AACzD;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mDAAmD,0DAAS;AAC5D;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,qDAAqD,4DAAU;AAC/D;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yDAAyD,gEAAY;AACrE;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,uDAAuD,8DAAW;AAClE;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,uDAAuD,8DAAW;AAClE;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,uDAAuD,8DAAW;AAClE;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,+DAA+D,sEAAe;AAC9E;AACA,C;;;;;;;;;;;;ACvJA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiD;;AAEjD;AACA;AACA;AACA;AACA;;AAEsB;AACtB;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,kBAAkB;AACjC,eAAe,OAAO;AACtB,iBAAiB,mBAAmB;AACpC;AACA,0DAA0D,EAAE;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;;AAET;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb,SAAS;AACT;;AAEA,yDAAyD,EAAE;AAC3D;AACA,mBAAmB,6DAAa;AAChC;AACA;AACA;AACA,SAAS;AACT;AACA,C;;;;;;;;;;;;ACjKA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwC;AACS;AACgD;;AAEjG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,kBAAkB;AACjC,eAAe,OAAO;AACtB;AACA,2CAA2C,EAAE;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,oDAAO;AAC1B;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA,YAAY,oDAAO;AACnB;AACA,aAAa;AACb;AACA;AACA;AACA,YAAY,oDAAO;AACnB;AACA,aAAa;AACb,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA,8BAA8B,mEAAqB,wCAAwC,UAAU;AACrG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,kEAAoB;;AAE1C;AACA;;AAEA;AACA,+BAA+B;AAC/B;AACA;AACA;;AAEA;AACA,iCAAiC,iBAAiB;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,QAAQ,GAAG,aAAa;AAC7E,8BAA8B,kEAAoB,iDAAiD,QAAQ;AAC3G,8BAA8B,+BAA+B,QAAQ,GAAG,EAAE,KAAK;AAC/E;AACA;AACA;AACA,0BAA0B,kEAAoB,yCAAyC,QAAQ,KAAK,QAAQ;AAC5G;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,6DAAa;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,+DAAiB,eAAe,MAAM,iCAAiC,oCAAoC;AACrI;AACA,0BAA0B,+DAAiB;AAC3C;AACA,0BAA0B,kEAAoB;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kEAAoB,6CAA6C,MAAM;AACjG;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sBAAsB,eAAe;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA,cAAc;AACd,oEAAoE,EAAE;AACtE;AACA;AACA,oBAAoB,oDAAO;;AAE3B;AACA;AACA;AACA,0BAA0B,oDAAO;;AAEjC;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,+DAAiB,0BAA0B,gBAAgB;;AAEjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kEAAoB,iCAAiC,MAAM;AACrF;;AAEA;AACA,YAAY,sCAAsC;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC,+BAA+B,6DAAa;AAC5C,uBAAuB,oDAAO;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,oDAAO;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,iBAAiB;AACvC,gCAAgC,6DAAa;;AAE7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;;AAE9D;AACA;AACA;;AAEA,wBAAwB,oDAAO;AAC/B;;AAEA;AACA;AACA,YAAY,oDAAO;;AAEnB;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wCAAwC,MAAM,KAAK,OAAO;AAC1D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA,KAAK;AACL;;;;;AAKA;AACA;AACA;;AAEA;AACA;AACA,WAAW,uBAAuB;AAClC,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kEAAkE;AAClE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,+EAA+E;AAC/E;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC70BA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqC;AACmB;;AAExD;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,uBAAuB;AACtC,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iDAAO;AACjC;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,YAAY,iDAAO;AACnB;AACA;AACA;AACA;AACA,sBAAsB,mEAAqB;;AAE3C;AACA;;AAEA;AACA;AACA,eAAe,0FAA0F;AACzG,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,QAAQ,iDAAO;AACf;;AAEA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA,YAAY,iDAAO;AACnB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;ACnIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,2CAAe,S;;;;;;;;;;;;ACrBxC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,8BAA8B,QAAQ;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,8BAA8B,QAAQ;AACtC;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,YAAY;AAC3B;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA,C;;;;;;;;;;;;ACzPA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiD;;AAEjD;AACA,4BAA4B;;AAErB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,6DAAqB;;AAE3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;ACvFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACO,6BAA6B;;AAEpC;AACO,uDAAuD;;AAE9D;AACO,4BAA4B;;AAEnC;AACO;;;;AAIP;AACA;AACA;;AAEA;AACO,mBAAmB;;AAE1B;AACO,6CAA6C;;;;AAIpD;AACA;AACA;;AAEA;AACO,sDAAsD,oC;;;;;;;;;;;;ACxD7D;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,IAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8CAA8C;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC;AACvC,sCAAsC;AACtC;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA,2BAA2B,aAAa,YAAY;AACpD;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;;AAErB;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,uCAAuC,YAAY;AACnD;AACA,uCAAuC,eAAe,YAAY,EAAE;AACpE;AACA,uCAAuC,cAAc,YAAY,EAAE;AACnE;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,IAAI;AACnB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,IAAI;AACnB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iDAAiD,iBAAiB,oCAAoC,EAAE;AACxG,0BAA0B,YAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe,IAAI;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,IAAI;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,IAAI;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,cAAc;AACxC;AACA;;AAEA;AACA;AACA;AACA,kEAAkE;AAClE,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,cAAc;AACxC;AACA;;AAEA;AACA;AACA;AACA,kEAAkE;AAClE,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,IAAI;AACnB;AACA;AACA;AACA,gFAAgF;AAChF;AACA;AACA;;AAEA;AACA,kCAAkC;;AAElC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,YAAY,8BAA8B,EAAE;AAC1E,8BAA8B,WAAW,8BAA8B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;;AAElB;AACA;AACA,kBAAkB;AAClB,4CAA4C;AAC5C,E;;;;;;;;;;;;;ACtbA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgC;;AAEzB,kBAAkB,4CAAK;AAC9B;AACA;AACA;AACA;AACA;;AAEO,oBAAoB,4CAAK;AAChC;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC;;AAEM;AACP;AACA;AACA;AACA;AACA,CAAC,E;;;;;;;;;;;;ACjDD;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2E;;AAE3E;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,UAAU;AAC1B,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,UAAU;AAC1B,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,WAAW,IAA2B;AACtC;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,OAAO;AACtB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,sBAAsB,sDAAc;AACpC;;AAEA;AACA;AACA,eAAe,UAAU;AACzB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,0EAA0E,EAAE;AAC5E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA,iCAAiC,mBAAmB,EAAE;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kDAAU,uCAAuC,KAAK;;AAE5E;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB;;AAErB;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,mBAAmB,EAAE;AACjC;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ,EAAE,QAAQ;AAC1C,wBAAwB,EAAE,EAAE,QAAQ,iBAAiB,EAAE,EAAE,QAAQ;AACjE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,4DAAoB,iDAAiD,WAAW;AACtG;AACA,sBAAsB,4DAAoB,2CAA2C,MAAM;;AAE3F;AACA;AACA;;AAEA;AACA,oCAAoC;AACpC,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;;AAEA,0BAA0B,WAAW,UAAU;AAC/C,0BAA0B,WAAW,UAAU;;AAE/C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA,sBAAsB,4DAAoB;;AAE1C;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA,sBAAsB,4DAAoB;;AAE1C;AACA;AACA,C","file":"speedy-vision.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * automatic-sensitivity.js\n * Automatic sensitivity component\n */\n\nimport { Observable } from '../../utils/observable';\nimport { SpeedyFeature } from '../speedy-feature';\nimport { FeatureDownloader } from './feature-downloader';\nimport { SensitivityTuner } from '../tuners/sensitivity-tuner';\nimport { TestTuner } from '../tuners/test-tuner';\n\n// constants\nconst DEFAULT_TOLERANCE = 0.10; // 10% on the expected number of keypoints\n\n/**\n * This component adds automatic sensitivity\n * support to a feature detector.\n * \n * Give it an expected number of keypoints &\n * an optional tolerance margin. It will\n * predict a value in [0,1] called sensitivity\n * that gives you, approximately, the number\n * of keypoints you have asked for.\n * \n * The feature detector must support reading\n * sensitivity values for this to work - i.e.,\n * translating sensitivity to some sort of\n * detector-specific threshold. It's ideal if\n * the number of keypoints and the sensitivity\n * value are (roughly) proportional.\n */\nexport class AutomaticSensitivity extends Observable\n{\n    /**\n     * Class constructor\n     * @param {FeatureDownloader} downloader\n     */\n    constructor(downloader)\n    {\n        super();\n        this._sensitivity = 0;\n        this._expected = 0;\n        this._tolerance = DEFAULT_TOLERANCE;\n        this._tuner = null;\n        this._downloader = downloader;\n        this._onDownloadKeypoints = this._onDownloadKeypoints.bind(this); // subscriber\n\n        // enable the AI\n        this.enable();\n    }\n\n    /**\n     * Get the current predicted sensitivity value\n     * @returns {number} a value in [0,1]\n     */\n    get sensitivity()\n    {\n        return this._sensitivity;\n    }\n\n    /**\n     * Get the expected number of keypoints\n     * @returns {number}\n     */\n    get expected()\n    {\n        return this._expected;\n    }\n\n    /**\n     * Set the expected number of keypoints\n     * @param {number} numberOfKeypoints\n     */\n    set expected(numberOfKeypoints)\n    {\n        this._expected = Math.max(0, numberOfKeypoints | 0);\n    }\n\n    /**\n     * Get the acceptable relative error tolerance used when finding\n     * a sensitivity value for an expected number of keypoints\n     * @returns {number}\n     */\n    get tolerance()\n    {\n        return this._tolerance;\n    }\n\n    /**\n     * Set the acceptable relative error tolerance used when finding\n     * a sensitivity value for an expected number of keypoints\n     * @param {number} percentage a value such as 0.10 (10%)\n     */\n    set tolerance(percentage)\n    {\n        this._tolerance = Math.max(0, +percentage);\n    }\n\n    /**\n     * Enable Automatic Sensitivity\n     */\n    enable()\n    {\n        this._downloader.subscribe(this._onDownloadKeypoints);\n    }\n\n    /**\n     * Disable Automatic Sensitivity\n     */\n    disable()\n    {\n        this._downloader.unsubscribe(this._onDownloadKeypoints);\n    }\n\n    /**\n     * Called whenever the feature detector finds new keypoints\n     * This routine updates the sensitivity value\n     * @param {SpeedyFeature[]} keypoints \n     */\n    _onDownloadKeypoints(keypoints)\n    {\n        const normalizer = 0.001; // convert from discrete state space\n\n        // tuner: lazy spawn\n        if(this._tuner == null) {\n            //this._tuner = new TestTuner(0, 1000); // debug\n            this._tuner = new SensitivityTuner(0, 1200); // use a slightly wider interval for better stability\n        }\n\n        // compute prediction\n        this._tuner.tolerance = this._tolerance;\n        this._tuner.feedObservation(keypoints.length, this._expected);\n        const prediction = this._tuner.currentValue();\n\n        // update sensitivity\n        this._sensitivity = Math.max(0, Math.min(prediction * normalizer, 1));\n\n        // debug\n        //console.log(JSON.stringify(this._tuner.info()));\n\n        // notify observers\n        this._notify(this._sensitivity);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * orb.js\n * ORB features\n */\n\nimport { SpeedyGPU } from '../../../gpu/speedy-gpu';\nimport { FeatureDescriptionAlgorithm } from '../feature-description-algorithm';\nimport { FeatureAlgorithm } from '../feature-algorithm';\n\n// constants\nconst DESCRIPTOR_SIZE = 32; // 256 bits\nconst DEFAULT_ORIENTATION_PATCH_RADIUS = 7; // for computing keypoint orientation\n\n/**\n * ORB features\n */\nexport class ORBFeatures extends FeatureDescriptionAlgorithm\n{\n    /**\n     * Constructor\n     * @param {FeatureAlgorithm} decoratedAlgorithm preferably Multiscale Harris\n     */\n    constructor(decoratedAlgorithm)\n    {\n        super(decoratedAlgorithm, DESCRIPTOR_SIZE);\n    }\n\n    /**\n     * Compute ORB feature descriptors\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture pre-processed greyscale image\n     * @param {SpeedyTexture} detectedKeypoints tiny texture with appropriate size for the descriptors\n     * @returns {SpeedyTexture} tiny texture with encoded keypoints & descriptors\n     */\n    _describe(gpu, inputTexture, detectedKeypoints)\n    {\n        const descriptorSize = this.descriptorSize;\n        const extraSize = this.extraSize;\n\n        // get oriented keypoints\n        const orientedKeypoints = this._computeOrientation(gpu, inputTexture, detectedKeypoints);\n\n        // smooth the image before computing the descriptors\n        const smoothTexture = gpu.programs.filters.gauss7(inputTexture);\n        const smoothPyramid = smoothTexture.generateMipmap();\n\n        // compute ORB feature descriptors\n        const encoderLength = gpu.programs.encoders.encoderLength;\n        return gpu.programs.keypoints.orb(smoothPyramid, orientedKeypoints, descriptorSize, extraSize, encoderLength);\n    }\n\n    /**\n     * Compute the orientation of the keypoints\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture pre-processed greyscale image\n     * @param {SpeedyTexture} detectedKeypoints tiny texture with appropriate size for the descriptors\n     * @returns {SpeedyTexture} tiny texture with encoded keypoints & descriptors\n     */\n    _computeOrientation(gpu, inputTexture, detectedKeypoints)\n    {\n        const descriptorSize = this.descriptorSize;\n        const extraSize = this.extraSize;\n        const orientationPatchRadius = DEFAULT_ORIENTATION_PATCH_RADIUS;\n\n        // generate pyramid\n        const pyramid = inputTexture.generateMipmap();\n\n        // compute orientation\n        const encoderLength = gpu.programs.encoders.encoderLength;\n        return gpu.programs.keypoints.orientationViaCentroid(pyramid, detectedKeypoints, orientationPatchRadius, descriptorSize, extraSize, encoderLength);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * fast.js\n * FAST corner detector\n */\n\nimport { SpeedyGPU } from '../../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../../gpu/speedy-texture';\nimport { FeatureDetectionAlgorithm } from '../feature-detection-algorithm';\nimport { NotSupportedError } from '../../../utils/errors';\nimport { Utils } from '../../../utils/utils';\nimport { PYRAMID_MAX_LEVELS } from '../../../utils/globals';\n\n// constants\nconst DEFAULT_FAST_VARIANT = 9;\nconst DEFAULT_FAST_THRESHOLD = 10;\nconst DEFAULT_DEPTH = 3;\n\n\n\n/**\n * FAST corner detector\n */\nexport class FASTFeatures extends FeatureDetectionAlgorithm\n{\n    /**\n     * Constructor\n     */\n    constructor()\n    {\n        super();\n        this._n = DEFAULT_FAST_VARIANT;\n        this._threshold = DEFAULT_FAST_THRESHOLD;\n    }\n\n    /**\n     * Get FAST variant\n     * @returns {number}\n     */\n    get n()\n    {\n        return this._n;\n    }\n\n    /**\n     * Set FAST variant\n     * @param {number} value 9, 7 or 5\n     */\n    set n(value)\n    {\n        this._n = value | 0;\n        Utils.assert(this._n === 9 || this._n === 7 || this._n === 5);\n    }\n\n    /**\n     * Get FAST threshold\n     * @returns {number}\n     */\n    get threshold()\n    {\n        return this._threshold;\n    }\n\n    /**\n     * Set FAST threshold\n     * @param {number} value a number in [0,255]\n     */\n    set threshold(value)\n    {\n        this._threshold = value | 0;\n        Utils.assert(this._threshold >= 0 && this._threshold <= 255);\n    }\n\n    /**\n     * Detect feature points\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture pre-processed greyscale image\n     * @returns {SpeedyTexture} encoded keypoints\n     */\n    _detect(gpu, inputTexture)\n    {\n        const n = this._n;\n        const threshold = this._threshold;\n        const normalizedThreshold = threshold / 255.0;\n        const descriptorSize = this.descriptorSize;\n        const extraSize = this.extraSize;\n\n        // find corners\n        let corners = null;\n        if(n == 9)\n            corners = gpu.programs.keypoints.fast9(inputTexture, normalizedThreshold);\n        else if(n == 7)\n            corners = gpu.programs.keypoints.fast7(inputTexture, normalizedThreshold);\n        else if(n == 5)\n            corners = gpu.programs.keypoints.fast5(inputTexture, normalizedThreshold);\n        else\n            throw new NotSupportedError();\n\n        // non-maximum suppression\n        corners = gpu.programs.keypoints.nonmaxSuppression(corners);\n\n        // encode corners\n        return gpu.programs.encoders.encodeKeypoints(corners, descriptorSize, extraSize);\n    }\n}\n\n\n\n\n\n/**\n * FAST corner detector in an image pyramid\n */\nexport class MultiscaleFASTFeatures extends FeatureDetectionAlgorithm\n{\n    /**\n     * Constructor\n     */\n    constructor()\n    {\n        super();\n        this._n = DEFAULT_FAST_VARIANT;\n        this._threshold = DEFAULT_FAST_THRESHOLD;\n        this._depth = DEFAULT_DEPTH;\n        this._useHarrisScore = false;\n    }\n\n    /**\n     * Get FAST variant\n     * @returns {number}\n     */\n    get n()\n    {\n        return this._n;\n    }\n\n    /**\n     * Set FAST variant\n     * @param {number} value only 9 is supported at this time\n     */\n    set n(value)\n    {\n        this._n = value | 0;\n        Utils.assert(this._n === 9);\n    }\n\n    /**\n     * Get FAST threshold\n     * @returns {number}\n     */\n    get threshold()\n    {\n        return this._threshold;\n    }\n\n    /**\n     * Set FAST threshold\n     * @param {number} value a number in [0,255]\n     */\n    set threshold(value)\n    {\n        this._threshold = value | 0;\n        Utils.assert(this._threshold >= 0 && this._threshold <= 255);\n    }\n\n    /**\n     * Get depth: how many pyramid levels we will scan\n     * @returns {number}\n     */\n    get depth()\n    {\n        return this._depth;\n    }\n\n    /**\n     * Set depth: how many pyramid levels we will scan\n     * @param {number} value 1, 2, 3...\n     */\n    set depth(value)\n    {\n        this._depth = value | 0;\n        Utils.assert(this._depth >= 1 && this._depth <= PYRAMID_MAX_LEVELS);\n    }\n\n    /**\n     * Use Harris scoring function?\n     * @returns {boolean}\n     */\n    get useHarrisScore()\n    {\n        return this._useHarrisScore;\n    }\n\n    /**\n     * Use Harris scoring function?\n     * @param {boolean} value\n     */\n    set useHarrisScore(value)\n    {\n        this._useHarrisScore = !!value;\n    }\n\n    /**\n     * Detect feature points\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture pre-processed greyscale image\n     * @returns {SpeedyTexture} encoded keypoints\n     */\n    _detect(gpu, inputTexture)\n    {\n        const threshold = this._threshold;\n        const depth = this._depth;\n        const useHarrisScore = this._useHarrisScore;\n        const normalizedThreshold = threshold / 255.0;\n        const numberOfOctaves = 2 * depth - 1;\n        const descriptorSize = this.descriptorSize;\n        const extraSize = this.extraSize;\n\n        // generate pyramid\n        const pyramid = inputTexture.generateMipmap();\n\n        // find corners\n        let corners = null;\n        if(!useHarrisScore)\n            corners = gpu.programs.keypoints.multiscaleFast(pyramid, normalizedThreshold, numberOfOctaves);\n        else\n            corners = gpu.programs.keypoints.multiscaleFastWithHarris(pyramid, normalizedThreshold, numberOfOctaves);\n\n        // non-maximum suppression\n        corners = gpu.programs.keypoints.samescaleSuppression(corners);\n        corners = gpu.programs.keypoints.multiscaleSuppression(corners);\n\n        // encode keypoints\n        const detectedKeypoints = gpu.programs.encoders.encodeKeypoints(corners, descriptorSize, extraSize);\n\n        // done\n        return detectedKeypoints;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * harris.js\n * Harris corner detector\n */\n\nimport { SpeedyGPU } from '../../../gpu/speedy-gpu';\nimport { FeatureDetectionAlgorithm } from '../feature-detection-algorithm';\nimport { PixelComponent } from '../../../utils/types';\nimport { PYRAMID_MAX_LEVELS } from '../../../utils/globals';\nimport { Utils } from '../../../utils/utils';\n\n// constants\nconst DEFAULT_QUALITY = 0.1; // default quality metric\nconst DEFAULT_DEPTH = 3; // default depth for multiscale feature detection\nconst DEFAULT_WINDOW_SIZE = 3; // compute Harris autocorrelation matrix within a 3x3 window\nconst MIN_WINDOW_SIZE = 0; // minimum window size when computing the autocorrelation matrix\nconst MAX_WINDOW_SIZE = 7; // maximum window size when computing the autocorrelation matrix\nconst SOBEL_OCTAVE_COUNT = 2 * PYRAMID_MAX_LEVELS - 1; // Sobel derivatives for each pyramid layer\n\n/**\n * Harris corner detector\n */\nexport class HarrisFeatures extends FeatureDetectionAlgorithm\n{\n    /**\n     * Constructor\n     */\n    constructor()\n    {\n        super();\n        this._quality = DEFAULT_QUALITY;\n    }\n\n    /**\n     * Get detector quality\n     * @returns {number}\n     */\n    get quality()\n    {\n        return this._quality;\n    }\n\n    /**\n     * Set detector quality\n     * @param {number} value a number in [0,1]: we will pick corners having score >= quality * max(score)\n     */\n    set quality(value)\n    {\n        this._quality = +value;\n        Utils.assert(this._quality >= 0 && this._quality <= 1);\n    }\n\n    /**\n     * Run the Harris corner detector\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture pre-processed greyscale image\n     * @returns {SpeedyTexture} encoded keypoints\n     */\n    _detect(gpu, inputTexture)\n    {\n        const quality = this._quality;\n        const descriptorSize = this.descriptorSize;\n        const extraSize = this.extraSize;\n        const windowSize = DEFAULT_WINDOW_SIZE;\n        const lod = 0, numberOfOctaves = 1;\n\n        // compute derivatives\n        const df = gpu.programs.keypoints.multiscaleSobel(inputTexture, lod);\n        const sobelDerivatives = Array(SOBEL_OCTAVE_COUNT).fill(df);\n\n        // corner detection\n        const corners = gpu.programs.keypoints.multiscaleHarris(inputTexture, windowSize, numberOfOctaves, sobelDerivatives);\n\n        // release derivatives\n        df.release();\n\n        // find the maximum corner response\n        const maxScore = gpu.programs.utils.scanMax(corners, PixelComponent.RED);\n\n        // discard corners according to quality level\n        const filteredCorners = gpu.programs.keypoints.harrisCutoff(corners, maxScore, quality);\n\n        // non-maximum suppression\n        const suppressedCorners = gpu.programs.keypoints.nonmaxSuppression(filteredCorners);\n\n        // encode corners\n        return gpu.programs.encoders.encodeKeypoints(suppressedCorners, descriptorSize, extraSize);\n    }\n}\n\n/**\n * Harris corner detector in an image pyramid\n */\nexport class MultiscaleHarrisFeatures extends FeatureDetectionAlgorithm\n{\n    /**\n     * Constructor\n     */\n    constructor()\n    {\n        super();\n        this._quality = DEFAULT_QUALITY;\n        this._depth = DEFAULT_DEPTH;\n    }\n\n    /**\n     * Get detector quality\n     * @returns {number}\n     */\n    get quality()\n    {\n        return this._quality;\n    }\n\n    /**\n     * Set detector quality\n     * @param {number} value a number in [0,1]: we will pick corners having score >= quality * max(score)\n     */\n    set quality(value)\n    {\n        this._quality = +value;\n        Utils.assert(this._quality >= 0 && this._quality <= 1);\n    }\n\n    /**\n     * Get depth: how many pyramid levels we will scan\n     * @returns {number}\n     */\n    get depth()\n    {\n        return this._depth;\n    }\n\n    /**\n     * Set depth: how many pyramid levels we will scan\n     * @param {number} value 1, 2, 3...\n     */\n    set depth(value)\n    {\n        this._depth = value | 0;\n        Utils.assert(this._depth >= 1 && this._depth <= PYRAMID_MAX_LEVELS);\n    }\n\n    /**\n     * Detect feature points\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture pre-processed greyscale image\n     * @returns {SpeedyTexture} encoded keypoints\n     */\n    _detect(gpu, inputTexture)\n    {\n        const quality = this._quality;\n        const depth = this._depth;\n        const descriptorSize = this.descriptorSize;\n        const extraSize = this.extraSize;\n        const windowSize = DEFAULT_WINDOW_SIZE;\n        const numberOfOctaves = 2 * depth - 1;\n\n        // generate pyramid\n        const pyramid = inputTexture.generateMipmap();\n\n        // compute derivatives\n        const sobelDerivatives = Array(SOBEL_OCTAVE_COUNT);\n        for(let j = 0; j < numberOfOctaves; j++)\n            sobelDerivatives[j] = gpu.programs.keypoints.multiscaleSobel(pyramid, j * 0.5);\n        for(let k = numberOfOctaves; k < sobelDerivatives.length; k++)\n            sobelDerivatives[k] = sobelDerivatives[k-1]; // can't call shaders with null pointers\n\n        // corner detection\n        const corners = gpu.programs.keypoints.multiscaleHarris(pyramid, windowSize, numberOfOctaves, sobelDerivatives);\n\n        // release derivatives\n        for(let i = 0; i < numberOfOctaves; i++)\n            sobelDerivatives[i].release();\n\n        // find the maximum corner response\n        const maxScore = gpu.programs.utils.scanMax(corners, PixelComponent.RED);\n\n        // discard corners according to the quality level\n        const filteredCorners = gpu.programs.keypoints.harrisCutoff(corners, maxScore, quality);\n\n        // non-maximum suppression\n        const suppressed1 = gpu.programs.keypoints.samescaleSuppression(filteredCorners);\n        const suppressed2 = gpu.programs.keypoints.multiscaleSuppression(suppressed1);\n\n        // encode keypoints\n        const detectedKeypoints = gpu.programs.encoders.encodeKeypoints(suppressed2, descriptorSize, extraSize);\n\n        // done\n        return detectedKeypoints;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * feature-algorithm-decorator.js\n * Decorator pattern applied to the FeatureAlgorithm class\n */\n\nimport { FeatureAlgorithm } from './feature-algorithm';\nimport { Utils } from '../../utils/utils';\n\n/**\n * This decorator lets us extend and combine\n * the FeatureAlgorithm class in many ways\n * @abstract\n */\nexport class FeatureAlgorithmDecorator extends FeatureAlgorithm\n{\n    /**\n     * Constructor\n     * @param {FeatureAlgorithm} decoratedAlgorithm \n     * @param {number} [descriptorSize] in bytes, required for GPU algorithms\n     * @param {number} [extraSize] in bytes, required for GPU algorithms\n     */\n    constructor(decoratedAlgorithm, descriptorSize = 0, extraSize = 0)\n    {\n        super(descriptorSize, extraSize);\n\n        Utils.assert(decoratedAlgorithm instanceof FeatureAlgorithm);\n        this._decoratedAlgorithm = decoratedAlgorithm;\n    }\n\n    /**\n     * Abstract \"run\" operation:\n     * runs something on the GPU\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture\n     * @returns {SpeedyTexture}\n     */\n    run(gpu, inputTexture)\n    {\n        return this._decoratedAlgorithm.run(gpu, inputTexture);\n    }\n\n    /**\n     * The decorated algorithm\n     * @returns {FeatureAlgorithm}\n     */\n    get decoratedAlgorithm()\n    {\n        return this._decoratedAlgorithm;\n    }\n\n    /**\n     * Extra size of the headers of the encoded keypoint texture\n     * @return {number} in bytes\n     */\n    get extraSize()\n    {\n        return super.extraSize;\n    }\n\n    /**\n     * Set the extra size of the headers of the encoded keypoint texture\n     * @param {number} bytes a multiple of 4 (32 bits)\n     */\n    set extraSize(bytes)\n    {\n        super.extraSize = bytes;\n        this._decoratedAlgorithm.extraSize = bytes;\n    }\n\n    /**\n     * Descriptor size\n     * @return {number} in bytes\n     */\n    get descriptorSize()\n    {\n        return super.descriptorSize;\n    }\n\n    /**\n     * Set the descriptor size, in bytes\n     * @param {number} bytes a multiple of 4 (32 bits)\n     */\n    set descriptorSize(bytes)\n    {\n        super.descriptorSize = bytes;\n        this._decoratedAlgorithm.descriptorSize = bytes;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * feature-algorithm.js\n * An abstract algorithm related to feature points\n */\n\nimport { SpeedyGPU } from '../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../gpu/speedy-texture';\nimport { FeatureDownloader } from './feature-downloader';\nimport { AbstractMethodError } from '../../utils/errors';\nimport { Utils } from '../../utils/utils';\n\n/**\n * An abstract algorithm that deals with\n * feature points in any way (detection,\n * tracking, etc.)\n * @abstract\n */\nexport class FeatureAlgorithm\n{\n    /**\n     * Class constructor\n     * @param {number} [descriptorSize] in bytes, required for GPU algorithms\n     * @param {number} [extraSize] in bytes, required for GPU algorithms\n     */\n    constructor(descriptorSize = 0, extraSize = 0)\n    {\n        Utils.assert(descriptorSize % 4 === 0);\n        Utils.assert(extraSize % 4 === 0);\n\n        this._downloader = new FeatureDownloader();\n        this._descriptorSize = descriptorSize; // for encoded keypoint textures\n        this._extraSize = extraSize; // for encoded keypoint textures\n    }\n\n    /**\n     * Abstract \"run\" operation:\n     * runs something on the GPU\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture\n     * @returns {SpeedyTexture}\n     */\n    run(gpu, inputTexture)\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Download feature points from the GPU\n     * Needs to be overridden in subclasses\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} encodedKeypoints tiny texture\n     * @param {boolean} [useAsyncTransfer]\n     * @returns {Promise<SpeedyFeature[]>} feature points\n     */\n    download(gpu, encodedKeypoints, useAsyncTransfer = true)\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Reset the capacity of the keypoint downloader\n     * Needs to be overridden in subclasses\n     * @param {SpeedyGPU} gpu \n     */\n    resetDownloader(gpu)\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Upload feature points to the GPU\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyFeature[]} keypoints feature points\n     * @returns {SpeedyTexture} tiny texture\n     */\n    upload(gpu, keypoints)\n    {\n        return gpu.programs.encoders.uploadKeypoints(keypoints, this.descriptorSize, this.extraSize);\n    }\n\n    /**\n     * Extra size of the headers of the encoded keypoint texture\n     * By default, this is set to zero\n     * @return {number} in bytes\n     */\n    get extraSize()\n    {\n        return this._extraSize;\n    }\n\n    /**\n     * Set the extra size of the headers of the encoded keypoint texture\n     * By default, this is set to zero\n     * This is low-level stuff!\n     * @param {number} bytes a multiple of 4 (32 bits)\n     */\n    set extraSize(bytes)\n    {\n        this._extraSize = Math.max(0, bytes | 0);\n        Utils.assert(this._extraSize % 4 === 0); // multiple of 32 bits (RGBA pixel)\n    }\n\n    /**\n     * Descriptor size\n     * By default, this is set to zero\n     * @return {number} in bytes\n     */\n    get descriptorSize()\n    {\n        return this._descriptorSize;\n    }\n\n    /**\n     * Set the descriptor size, in bytes\n     * By default, this is set to zero\n     * @param {number} bytes a multiple of 4 (32 bits)\n     */\n    set descriptorSize(bytes)\n    {\n        this._descriptorSize = Math.max(0, bytes | 0);\n        Utils.assert(this._descriptorSize % 4 === 0); // multiple of 32 bits (RGBA pixel)\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * feature-description-algorithm.js\n * Abstract feature description algorithm\n */\n\nimport { AbstractMethodError } from '../../utils/errors';\nimport { FeatureAlgorithm } from './feature-algorithm';\nimport { FeatureAlgorithmDecorator } from './feature-algorithm-decorator';\nimport { FeatureDetectionAlgorithm } from './feature-detection-algorithm';\nimport { Utils } from '../../utils/utils';\n\n/**\n * Abstract feature description algorithm\n * @abstract\n */\nexport class FeatureDescriptionAlgorithm extends FeatureAlgorithmDecorator\n{\n    /**\n     * Constructor\n     * @param {FeatureAlgorithm} decoratedAlgorithm usually the feature detection algorithm \n     * @param {number} descriptorSize in bytes, required for GPU algorithms\n     */\n    constructor(decoratedAlgorithm, descriptorSize)\n    {\n        Utils.assert(decoratedAlgorithm instanceof FeatureAlgorithm);\n        Utils.assert(descriptorSize > 0);\n\n        super(decoratedAlgorithm, descriptorSize, 0);\n        decoratedAlgorithm.descriptorSize = this.descriptorSize;\n        decoratedAlgorithm.extraSize = this.extraSize;\n    }\n\n    /**\n     * To \"run\" this algorithm means: to describe feature points\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture pre-processed greyscale image\n     * @returns {SpeedyTexture} tiny texture with encoded keypoints & descriptors\n     */\n    run(gpu, inputTexture)\n    {\n        // run decorated algorithm (e.g., feature detection)\n        const detectedKeypoints = this.decoratedAlgorithm.run(gpu, inputTexture);\n\n        // run feature description algorithm\n        return this._describe(gpu, inputTexture, detectedKeypoints);\n    }\n\n    /**\n     * Download feature points from the GPU\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} encodedKeypoints tiny texture with encoded keypoints\n     * @param {boolean} [useAsyncTransfer] transfer feature points asynchronously\n     * @returns {Promise<SpeedyFeature[]>}\n     */\n    download(gpu, encodedKeypoints, useAsyncTransfer = true)\n    {\n        return this.decoratedAlgorithm.download(gpu, encodedKeypoints, useAsyncTransfer);\n    }\n\n    /**\n     * Reset the capacity of the keypoint downloader\n     * @param {SpeedyGPU} gpu \n     */\n    resetDownloader(gpu)\n    {\n        this.decoratedAlgorithm.resetDownloader(gpu);\n    }\n\n    /**\n     * Setup enhancements to be applied when **DETECTING** (not describing) features\n     * @param {object|boolean} [enhancements] fix irregular lighting in the scene?\n     */\n    setEnhancements(enhancements)\n    {\n        //if(this.decoratedAlgorithm instanceof FeatureDetectionAlgorithm)\n        this.decoratedAlgorithm.setEnhancements(enhancements);\n    }\n\n    /**\n     * Describe feature points\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture pre-processed greyscale image\n     * @param {SpeedyTexture} detectedKeypoints tiny texture with appropriate size for the descriptors\n     * @returns {SpeedyTexture} tiny texture with encoded keypoints & descriptors\n     */\n    _describe(gpu, inputTexture, detectedKeypoints)\n    {\n        throw new AbstractMethodError();\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * feature-detection-algorithm.js\n * Feature detection & description: abstract class\n */\n\nimport { AbstractMethodError } from '../../utils/errors';\nimport { FeatureAlgorithm } from './feature-algorithm';\nimport { SpeedyFeature } from '../speedy-feature';\nimport { SpeedyGPU } from '../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../gpu/speedy-texture';\nimport { Utils } from '../../utils/utils';\n\n// Constants\nconst DEFAULT_ENHANCEMENTS = Object.freeze({\n    gain: 0.9,\n    offset: 0.5,\n    decay: 0.85,\n    quality: 'low'\n});\n\n/**\n * An abstract class for feature\n * detection & description\n * @abstract\n */\nexport class FeatureDetectionAlgorithm extends FeatureAlgorithm\n{\n    /**\n     * Class constructor\n     */\n    constructor()\n    {\n        super(0, 0);\n        this._downloader.enableBufferedDownloads();\n        this._enhancements = null;\n    }\n\n    /**\n     * To \"run\" this algorithm means: to detect feature points\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture pre-processed greyscale image\n     * @returns {SpeedyTexture} tiny texture with encoded keypoints\n     */\n    run(gpu, inputTexture)\n    {\n        const enhancedInputTexture = this._enhanceTexture(gpu, inputTexture);\n        return this._detect(gpu, enhancedInputTexture);\n    }\n\n    /**\n     * Download feature points from the GPU\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} encodedKeypoints tiny texture with encoded keypoints\n     * @param {boolean} [useAsyncTransfer] transfer feature points asynchronously\n     * @returns {Promise<SpeedyFeature[]>}\n     */\n    download(gpu, encodedKeypoints, useAsyncTransfer = true)\n    {\n        // download feature points\n        const keypoints = this._downloader.download(gpu, encodedKeypoints, this.descriptorSize, this.extraSize, useAsyncTransfer);\n\n        // restore buffered downloads (if previously disabled) for improved performance\n        if(!this._downloader.usingBufferedDownloads())\n            this._downloader.enableBufferedDownloads();\n\n        // done!\n        return keypoints;\n    }\n\n    /**\n     * Reset the capacity of the keypoint downloader\n     * @param {SpeedyGPU} gpu \n     */\n    resetDownloader(gpu)\n    {\n        // temporarily disable buffered downloads,\n        // so we get fresh results in the next\n        // call to download()\n        this._downloader.disableBufferedDownloads();\n\n        // reset the downloader\n        this._downloader.reset(gpu, this.descriptorSize, this.extraSize);\n\n        /*\n        // note: buffered responses imply a 1-frame delay\n        if(this._downloader.usingBufferedDownloads())\n            Utils.warning(`The feature downloader has been reset, but buffered downloads are enabled and cause a 1-frame delay`);\n        */\n    }\n\n    /**\n     * Setup enhancements to be applied when detecting features\n     * @param {object|boolean} [enhancements] fix irregular lighting in the scene?\n     */\n    setEnhancements(enhancements)\n    {\n        if(enhancements === true)\n            this._enhancements = DEFAULT_ENHANCEMENTS;\n        else if(typeof enhancements === 'object' && enhancements !== null)\n            this._enhancements = Object.assign({ }, DEFAULT_ENHANCEMENTS, enhancements);\n        else\n            this._enhancements = null;\n    }\n\n    /**\n     * Detect feature points\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture pre-processed greyscale image\n     * @returns {SpeedyTexture} tiny texture with encoded keypoints\n     */\n    _detect(gpu, inputTexture)\n    {\n        // This must be implemented in subclasses\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Enhances a texture specifically for feature detection\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture\n     * @returns {SpeedyTexture}\n     */\n    _enhanceTexture(gpu, inputTexture)\n    {\n        let texture = inputTexture;\n        const options = this._enhancements;\n\n        if(options !== null) {\n            texture = gpu.programs.enhancements.nightvision(texture, options.gain, options.offset, options.decay, options.quality, true);\n            texture = gpu.programs.filters.gauss3(texture); // blur a bit more\n        }\n\n        return texture;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * feature-downloader.js\n * Download features from the GPU\n */\n\nimport { IllegalOperationError } from '../../utils/errors';\nimport { Observable } from '../../utils/observable';\nimport { SpeedyFeature } from '../speedy-feature';\nimport { SpeedyGPU } from '../../gpu/speedy-gpu';\n\n// constants\nconst INITIAL_FILTER_GAIN = 0.85; // a number in [0,1]\nconst INITIAL_KEYPOINTS_GUESS = 600; // a guess about the initial number of keypoints\nconst MIN_KEYPOINTS = 32; // at any point in time, the encoder will have space for\n                          // at least this number of keypoints\n\n\n/**\n * A filter used to estimate the future number of\n * keypoints given past measurements\n */\nclass FeatureCountEstimator\n{\n    /**\n     * Class constructor\n     */\n    constructor()\n    {\n        this._gain = INITIAL_FILTER_GAIN;\n        this._state = INITIAL_KEYPOINTS_GUESS;\n        this._prevState = this._state;\n    }\n\n    /**\n     * Estimate the number of keypoints on the next time-step\n     * @param {number} measurement\n     * @returns {number}\n     */\n    estimate(measurement)\n    {\n        // extrapolate the current state\n        const prediction = Math.max(0, this._state + (this._state - this._prevState));\n    \n        // estimate the new state\n        const gain = this._gain; // do we trust more the prediction or the measurement?\n        const newState = prediction + gain * (measurement - prediction);\n\n        // update gain\n        this._gain = Math.min(INITIAL_FILTER_GAIN, this._gain + 0.3);\n\n        // testing\n        /*\n        this._cnt = Math.round(measurement - this._state) >= 1 ? (this._cnt||0) + 1 : 0;\n        const diff = Math.abs(Math.round(measurement - this._state));\n        const ratio = measurement / this._state-1;\n        console.log(JSON.stringify({\n            gain,\n            prediction: Math.round(prediction),\n            newState: Math.round(newState),\n            measurement,\n            diff,\n            ratio: Math.round(100*ratio)+'%'\n        }).replace(/,/g,',\\n'));\n        if(ratio+1 > this.maxGrowth) console.log('maxGrowth exceeded!');\n        */\n\n        // save state\n        this._prevState = this._state;\n        this._state = newState;\n\n        // return\n        return Math.round(this._state);\n    }\n\n    /**\n     * Reset the filter to its initial state\n     */\n    reset()\n    {\n        // trust the prediction, not the measurement\n        this._gain = 0;\n\n        // reset state & prev state\n        this._state = this._prevState = INITIAL_KEYPOINTS_GUESS;\n    }\n\n    /**\n     * We expect measurement <= maxGrowth * previousState\n     * to be true (almost) all the time, so we can\n     * accomodate the encoder\n     * @returns {number} greater than 1\n     */\n    get maxGrowth()\n    {\n        // If you increase this number, you'll get\n        // more robust responses to abrupt and significant\n        // increases in the number of keypoints, but you'll\n        // also increase the amount of data going back and\n        // forth from the GPU, thus impacting performance.\n        // We would like to keep this value low.\n        return 1.5;\n    }\n}\n\n\n\n/**\n * The FeatureDownloader receives a texture of encoded\n * keypoints and returns a corresponding array of keypoints\n */\nexport class FeatureDownloader extends Observable\n{\n    /**\n     * Class constructor\n     */\n    constructor()\n    {\n        super();\n        this._useBufferedDownloads = false;\n        this._estimator = new FeatureCountEstimator();\n    }\n\n    /**\n     * Download feature points from the GPU\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} encodedKeypoints tiny texture with encoded keypoints\n     * @param {number} descriptorSize in bytes (set it to zero if there is no descriptor)\n     * @param {number} extraSize in bytes (set it to zero if there is no extra data)\n     * @param {boolean} [useAsyncTransfer] transfer keypoints asynchronously\n     * @param {object} [output] output object with additional info about the keypoints (see the encoder for details)\n     * @returns {Promise<SpeedyFeature[]>}\n     */\n    download(gpu, encodedKeypoints, descriptorSize, extraSize, useAsyncTransfer = true, output = undefined)\n    {\n        return gpu.programs.encoders.downloadEncodedKeypoints(encodedKeypoints, useAsyncTransfer, this._useBufferedDownloads).then(data => {\n\n            // decode the keypoints\n            const out = Object.assign({ discardCount: [0] }, output);\n            const keypoints = gpu.programs.encoders.decodeKeypoints(data, descriptorSize, extraSize, out);\n\n            // how many keypoints do we expect in the next frame?\n            const nextCount = this._estimator.estimate(keypoints.length - out.discardCount[0]);\n\n            // optimize the keypoint encoder\n            //console.log('Encoder Length', gpu.programs.encoders.encoderLength);\n            if(useAsyncTransfer) {\n                // add slack (maxGrowth) to accomodate abrupt changes in the number of keypoints\n                const capacity = Math.max(nextCount, MIN_KEYPOINTS);\n                const extraCapacity = this._estimator.maxGrowth * capacity;\n                gpu.programs.encoders.optimize(extraCapacity, descriptorSize, extraSize);\n            }\n            else {\n                // static usage\n                const capacity = Math.max(nextCount, MIN_KEYPOINTS);\n                gpu.programs.encoders.reserveSpace(capacity, descriptorSize, extraSize);\n            }\n\n            // notify observers\n            this._notify(keypoints);\n\n            // done!\n            return keypoints;\n\n        }).catch(err => {\n            throw new IllegalOperationError(`Can't download keypoints`, err);\n        });\n    }\n\n    /**\n     * Resets the capacity of the downloader\n     * (i.e., how many keypoints it can deliver)\n     * @param {SpeedyGPU} gpu\n     * @param {number} descriptorSize in bytes\n     * @param {number} extraSize in bytes\n     */\n    reset(gpu, descriptorSize, extraSize)\n    {\n        const capacity = INITIAL_KEYPOINTS_GUESS;\n\n        this._estimator.reset();\n        gpu.programs.encoders.reserveSpace(capacity, descriptorSize, extraSize);\n    }\n\n    /**\n     * Enable buffered downloads\n     * It's an optimization technique that implies a 1-frame delay\n     * in the downloads when using async transfers; it may or may\n     * not be acceptable, depending on what you're trying to do\n     */\n    enableBufferedDownloads()\n    {\n        this._useBufferedDownloads = true;\n    }\n\n    /**\n     * Disable buffered downloads\n     * It's an optimization technique that implies a 1-frame delay\n     * in the downloads when using async transfers; it may or may\n     * not be acceptable, depending on what you're trying to do\n     */\n    disableBufferedDownloads()\n    {\n        this._useBufferedDownloads = false;\n    }\n\n    /**\n     * Whether we're using the buffered responses or not\n     * @returns {boolean}\n     */\n    usingBufferedDownloads()\n    {\n        return this._useBufferedDownloads;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * feature-tracking-algorithm.js\n * Abstract feature tracking algorithm\n */\n\nimport { SpeedyGPU } from '../../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../../gpu/speedy-texture';\nimport { AbstractMethodError } from '../../utils/errors';\nimport { FeatureAlgorithm } from './feature-algorithm';\nimport { SpeedyFeature } from '../speedy-feature';\n\n/**\n * Abstract feature tracking algorithm\n * @abstract\n */\nexport class FeatureTrackingAlgorithm extends FeatureAlgorithm\n{\n    /**\n     * Class constructor\n     */\n    constructor()\n    {\n        super(0, 0);\n        this._prevImage = null; // previous image\n        this._prevKeypoints = null; // tiny texture with encoded keypoints\n        this._downloader.disableBufferedDownloads();\n    }\n\n    /**\n     * To \"run\" this algorithm means: to track feature points\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture pre-processed greyscale image (nextImage)\n     * @returns {SpeedyTexture} tiny texture with encoded keypoints (the result of tracking)\n     */\n    run(gpu, inputTexture)\n    {\n        return this._track(gpu, inputTexture);\n    }\n\n    /**\n     * Get previous image (time: t-1)\n     * @returns {SpeedyTexture}\n     */\n    get prevImage()\n    {\n        return this._prevImage;\n    }\n\n    /**\n     * Set previous image (time: t-1)\n     * @param {SpeedyTexture} texture\n     */\n    set prevImage(texture)\n    {\n        this._prevImage = texture;\n    }\n\n    /**\n     * Get previous keypoints (time: t-1)\n     * as a tiny texture with encoded data\n     * @returns {SpeedyTexture}\n     */\n    get prevKeypoints()\n    {\n        return this._prevKeypoints;\n    }\n\n    /**\n     * Set previous keypoints (time: t-1)\n     * as a tiny texture with encoded data\n     * @param {SpeedyTexture} texture\n     */\n    set prevKeypoints(texture)\n    {\n        this._prevKeypoints = texture;\n    }\n\n    /**\n     * Track a set of feature points\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} nextImage next image (time: t)\n     * @returns {SpeedyTexture} nextKeypoints tiny texture with encoded keypoints (time: t)\n     */\n    _track(gpu, nextImage)\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Download feature points from the GPU\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} encodedKeypoints tiny texture with encoded keypoints\n     * @param {boolean} [useAsyncTransfer] transfer feature points asynchronously\n     * @param {boolean[]} [discard] i-th element will be set to true if the i-th should be discarded\n     * @returns {Promise<SpeedyFeature[]>}\n     */\n    download(gpu, encodedKeypoints, useAsyncTransfer = true, discard = undefined)\n    {\n        if(this._downloader.usingBufferedDownloads()) {\n            Utils.warning(`Feature trackers shouldn't use buffered downloads`);\n            this._downloader.disableBufferedDownloads();\n        }\n\n        const output = discard ? { discard: discard, userData: [] } : undefined;\n        return this._downloader.download(gpu, encodedKeypoints, this.descriptorSize, this.extraSize, useAsyncTransfer, output).then(keypoints => {\n            // discard keypoints if they are outside\n            // the image or if they are of \"bad quality\"\n            if(discard) {\n                for(let i = 0; i < discard.length; i++)\n                    discard[i] = discard[i] || (output.userData[i] > 0);\n            }\n\n            return keypoints;\n        });\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * lk.js\n * Lucas-Kanade feature tracker in a pyramid\n */\n\nimport { SpeedyGPU } from '../../../gpu/speedy-gpu';\nimport { FeatureTrackingAlgorithm } from '../feature-tracking-algorithm';\nimport { Utils } from '../../../utils/utils';\n\n// Constants\nconst DEFAULT_WINDOW_SIZE = 15;\nconst DEFAULT_DEPTH = 5;\nconst DEFAULT_DISCARD_THRESHOLD = 0.0001;\n\n/**\n * Lucas-Kanade feature tracker in a pyramid\n */\nexport class LKFeatureTrackingAlgorithm extends FeatureTrackingAlgorithm\n{\n    /**\n     * Constructor\n     */\n    constructor()\n    {\n        super();\n        this._windowSize = DEFAULT_WINDOW_SIZE;\n        this._depth = DEFAULT_DEPTH;\n        this._discardThreshold = DEFAULT_DISCARD_THRESHOLD;\n    }\n\n    /**\n     * Get neighborhood size\n     * @returns {number}\n     */\n    get windowSize()\n    {\n        return this._windowSize;\n    }\n\n    /**\n     * Set neighborhood size\n     * @param {number} value positive odd number\n     */\n    set windowSize(value)\n    {\n        this._windowSize = value | 0;\n        Utils.assert(this._windowSize % 2 === 1 && this._windowSize >= 1);\n    }\n\n    /**\n     * Get depth, i.e., how many pyramid levels will be scanned\n     * @returns {number}\n     */\n    get depth()\n    {\n        return this._depth;\n    }\n\n    /**\n     * Set depth, i.e., how many pyramid levels will be scanned\n     * @param {number} value positive integer (1, 2, 3, 4...)\n     */\n    set depth(value)\n    {\n        this._depth = value | 0;\n        Utils.assert(this._depth >= 1);\n    }\n\n    /**\n     * Get the discard threshold, used to discard \"bad\" keypoints\n     * @returns {number}\n     */\n    get discardThreshold()\n    {\n        return this._discardThreshold;\n    }\n\n    /**\n     * Set the discard threshold, used to discard \"bad\" keypoints\n     * @param {number} value typically 10^(-4) - increase to discard more\n     */\n    set discardThreshold(value)\n    {\n        this._discardThreshold = Math.max(0, +value);\n    }\n\n    /**\n     * Track a set of feature points\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} nextImage next image (time: t)\n     * @returns {SpeedyTexture} nextKeypoints tiny texture with encoded keypoints (time: t)\n     */\n    _track(gpu, nextImage)\n    {\n        const prevImage = this.prevImage;\n        const prevKeypoints = this.prevKeypoints;\n        const descriptorSize = this.descriptorSize;\n        const extraSize = this.extraSize;\n        const windowSize = this.windowSize;\n        const depth = this.depth;\n        const discardThreshold = this.discardThreshold;\n\n        // create pyramids\n        const nextPyramid = nextImage.generateMipmap();\n        const prevPyramid = prevImage.generateMipmap();\n\n        // track feature points\n        const encoderLength = gpu.programs.encoders.encoderLength;\n        return gpu.programs.trackers.lk(nextPyramid, prevPyramid, prevKeypoints, windowSize, depth, discardThreshold, descriptorSize, extraSize, encoderLength);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * matrix-buffer.js\n * Storage for elements of matrices\n */\n\nimport { MatrixMath } from './matrix-math';\nimport { IllegalArgumentError, IllegalOperationError, NotSupportedError } from '../../utils/errors';\nimport { SpeedyPromise } from '../../utils/speedy-promise';\n\n// constants\nconst MatrixType = MatrixMath.MatrixType;\nconst DataType = MatrixMath.DataType;\nconst TypedArray2DataType = Object.freeze(Object.keys(DataType).reduce(\n    (obj, type) => Object.assign(obj, { [DataType[type].name]: type | 0 }),\n{}));\n\n/**\n * Stores the contents of a matrix\n */\nexport class MatrixBuffer\n{\n    /**\n     * Class constructor\n     * @param {number} length number of elements of the buffer\n     * @param {number[]|Float64Array|Float32Array|Int32Array|Uint8Array} [values] initial values in column-major format\n     * @param {number} [type] the type of the elements of the matrix: F64, F32, etc.\n     * @param {MatrixBuffer} [parent] the buffer that originated this one, if any\n     */\n    constructor(length, values = null, type = MatrixType.F32, parent = null)\n    {\n        let data;\n        length = length | 0;\n\n        // type inference\n        if(values != null && !Array.isArray(values))\n            type = TypedArray2DataType[values.constructor.name];\n        const dataType = DataType[type];\n        if(dataType === undefined)\n            throw new IllegalArgumentError(`Unknown matrix type`);\n\n        // validate length\n        if(length <= 0)\n            throw new IllegalArgumentError(`Invalid matrix length`);\n\n        // allocate new TypedArray\n        if(values == null)\n            data = new dataType(length);\n        else if(Array.isArray(values))\n            data = new dataType(values);\n        else\n            data = values;\n\n        // check if it's a proper TypedArray\n        if(!(data.buffer instanceof ArrayBuffer))\n            throw new IllegalArgumentError(`Invalid matrix type`);\n\n        // store data\n        this._type = type & (~3); // F64, F32, etc.\n        this._byteOffset = data.byteOffset; // assumed to be constant\n        this._length = data.length; // assumed to be constant\n        this._data = data; // a reference to the TypedArray\n        this._dataType = dataType; // TypedArray class\n\n        // concurrency control\n        this._pendingOperations = parent ? parent._pendingOperations : 0; // number of pending operations that read from or write to the buffer\n        this._pendingAccessesQueue = []; // a list of Function<void> to be called as soon as there are no pending operations\n        this._children = []; // a list of MatrixBuffers that share their internal memory with this one\n        this._parent = parent; // the buffer that originated this one, if any\n    }\n\n    /**\n     * Data type\n     * @returns {number}\n     */\n    get type()\n    {\n        return this._type;\n    }\n\n    /**\n     * Get the internal TypedArray that holds the entries of the Matrix\n     * Make sure the buffer is ready() before accessing this property\n     * @returns {Float32Array|Float64Array|Int32Array|Uint8Array}\n     */\n    get data()\n    {\n        return this._data;\n    }\n\n    /**\n     * Wait for buffer readiness. Since the buffer holds\n     * a Transferable object, the data may or may not be\n     * available right now. The returned SpeedyPromise will be\n     * resolved as soon as the buffer is available for\n     * reading and writing\n     * @returns {SpeedyPromise<MatrixBuffer>}\n     */\n    ready()\n    {\n        if(this._pendingOperations > 0) {\n            // we're not ready yet: there are calculations taking place...\n            // we'll resolve this promise as soon as there are no pending calculations\n            return new SpeedyPromise(resolve => {\n                this._pendingAccessesQueue.push(() => resolve(this));\n            });\n        }\n        else {\n            // we're ready to go!\n            // no pending operations\n            return SpeedyPromise.resolve(this);\n        }\n    }\n\n    /**\n     * Lock the buffer, so it can't be read from nor written to\n     * @param {boolean} [ascend] internal\n     */\n    lock(ascend = true)\n    {\n        let my = this;\n\n        // climb the tree\n        if(my._parent && ascend) {\n            do { my = my._parent; } while(my._parent);\n        }\n\n        // lock this buffer\n        ++my._pendingOperations;\n\n        // broadcast\n        for(let i = my._children.length - 1; i >= 0; i--)\n            my._children[i].lock(false);\n    }\n\n    /**\n     * Unlock the buffer and resolve all pending read/write operations\n     * @param {boolean} [ascend] internal\n     */\n    unlock(ascend = true)\n    {\n        let my = this;\n\n        // climb the tree\n        if(my._parent && ascend) {\n            do { my = my._parent; } while(my._parent);\n        }\n\n        // unlock this buffer\n        if(--my._pendingOperations <= 0) {\n            const callbackQueue = my._pendingAccessesQueue.slice(0); // fast clone\n\n            my._pendingOperations = 0;\n            my._pendingAccessesQueue.length = 0;\n\n            for(let i = 0; i < callbackQueue.length; i++) {\n                // if the buffer has been locked again, put the functions back in the queue\n                if(my._pendingOperations > 0) {\n                    for(let j = callbackQueue.length - 1; j >= i; j--) {\n                        my._pendingAccessesQueue.unshift(callbackQueue[j]);\n                    }\n                    break; // note: for each lock() we need an unlock()\n                }\n\n                // if the buffer remains unlocked, we're cool\n                callbackQueue[i].call(my);\n            }\n        }\n\n        // broadcast\n        for(let i = my._children.length - 1; i >= 0; i--)\n            my._children[i].unlock(false);\n    }\n\n    /**\n     * Replace the internal buffer of the TypedArray\n     * @param {ArrayBuffer} arrayBuffer new internal buffer\n     * @param {boolean} [ascend] internal\n     */\n    replace(arrayBuffer, ascend = true)\n    {\n        let my = this;\n\n        // climb the tree\n        if(my._parent && ascend) {\n            do { my = my._parent; } while(my._parent);\n        }\n\n        // replace the internal buffer\n        const dataType = this._dataType;\n        my._data = new dataType(arrayBuffer, my._byteOffset, my._length);\n\n        // broadcast\n        for(let i = my._children.length - 1; i >= 0; i--)\n            my._children[i].replace(arrayBuffer, false);\n    }\n\n    /**\n     * Create a MatrixBuffer that shares its internal memory with this one\n     * @param {number} [begin] index of the first element of the TypedArray\n     * @param {number} [length] number of elements of the TypedArray\n     * @returns {SpeedyPromise<MatrixBuffer>}\n     */\n    createSharedBuffer(begin = 0, length = this._length)\n    {\n        return this.ready().then(() => {\n            // obtain shared area of memory\n            const end = Math.min(begin + length, this._length);\n            const data = this._data.subarray(begin, end); // the main thread must own this._data\n\n            // create shared buffer\n            const sharedBuffer = new MatrixBuffer(length, data, this._type, this);\n            this._children.push(sharedBuffer);\n\n            // done!\n            return sharedBuffer;\n        });\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * matrix-expressions.js\n * Abstract Matrix Algebra\n */\n\nimport { SpeedyMatrix } from './matrix';\nimport { MatrixMath } from './matrix-math';\nimport { MatrixOperationsQueue } from './matrix-operations-queue';\nimport { AbstractMethodError, IllegalArgumentError, IllegalOperationError } from '../../utils/errors';\nimport { SpeedyPromise } from '../../utils/speedy-promise';\nimport {\n    MatrixOperationNop,\n    MatrixOperationFill,\n    MatrixOperationCopy,\n    MatrixOperationTranspose,\n    MatrixOperationAdd,\n    MatrixOperationSubtract,\n    MatrixOperationMultiply,\n    MatrixOperationMultiplyLT,\n    MatrixOperationMultiplyRT,\n    MatrixOperationMultiplyVec,\n    MatrixOperationScale,\n    MatrixOperationCompMult,\n    MatrixOperationQR,\n    MatrixOperationQRSolve,\n    MatrixOperationBackSubstitution,\n    MatrixOperationLSSolve,\n} from './matrix-operations';\n\n// constants\nconst matrixOperationsQueue = MatrixOperationsQueue.instance;\nconst MatrixType = MatrixMath.MatrixType;\nconst DataType = MatrixMath.DataType;\nconst DataTypeName = MatrixMath.DataTypeName;\nconst DataTypeName2DataType = Object.freeze(Object.keys(DataTypeName).reduce(\n    (obj, type) => Object.assign(obj, { [ DataTypeName[type] ]: type }),\n{}));\n\n\n\n// ================================================\n// ABSTRACT TYPES\n// ================================================\n\n/**\n * An abstract algebraic expression with matrices\n * All expressions must be immutable from the outside\n * @abstract\n */\nclass SpeedyMatrixExpr\n{\n    /**\n     * Constructor\n     * @param {number} rows expected number of rows of the resulting expression\n     * @param {number} columns expected number of columns of the resulting expression\n     * @param {number} type matrix type: F32, F64, etc.\n     */\n    constructor(rows, columns, type)\n    {\n        this._rows = rows | 0;\n        this._columns = columns | 0;\n        this._type = type | 0;\n        this._readbuf = null;\n\n        if(this._rows <= 0 || this._columns <= 0)\n            throw new IllegalArgumentError(`Invalid dimensions for a matrix expression: ${this._rows} x ${this._columns}`);\n        else if(DataType[this._type] === undefined)\n            throw new IllegalArgumentError(`Invalid type for a matrix expression: 0x${this._type.toString(16)}`);\n    }\n\n    /**\n     * Number of rows of the resulting matrix\n     * @returns {number}\n     */\n    get rows()\n    {\n        return this._rows;\n    }\n\n    /**\n     * Number of columns of the resulting matrix\n     * @returns {number}\n     */\n    get columns()\n    {\n        return this._columns;\n    }\n\n    /**\n     * Type of the resulting matrix\n     * @returns {number}\n     */\n    get type()\n    {\n        return this._type;\n    }\n\n    /**\n     * Type of the resulting matrix, as a string\n     * @returns {string}\n     */\n    get dtype()\n    {\n        return MatrixMath.DataTypeName[this._type];\n    }\n\n    /**\n     * Assert matrix shape and type\n     * @param {number} requiredRows\n     * @param {number} requiredColumns\n     * @param {number} [requiredType]\n     */\n    _assertCompatibility(requiredRows, requiredColumns, requiredType = this._type)\n    {\n        if(requiredRows === this._rows && requiredColumns === this._columns && requiredType === this._type)\n            return;\n        else if(requiredType !== this._type)\n            throw new IllegalOperationError(`Incompatible matrix type (expected ${MatrixMath.DataTypeName[requiredType]}, found ${this.dtype})`);\n        else\n            throw new IllegalOperationError(`Incompatible matrix shape (expected ${requiredRows} x ${requiredColumns}, found ${this._rows} x ${this._columns})`);\n    }\n\n    /**\n     * Evaluate the expression\n     * @returns {SpeedyPromise<SpeedyMatrixExpr>}\n     */\n    _evaluate()\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Get the matrix associated with the result of this expression\n     * This matrix must be guaranteed to be available after evaluating this expression\n     * @returns {SpeedyMatrix}\n     */\n    get _matrix()\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Assign a matrix\n     * @param {SpeedyMatrix} matrix\n     * @returns {SpeedyPromise<void>} resolves as soon as the assignment is done\n     */\n    _assign(matrix)\n    {\n        throw new IllegalOperationError(`Can't assign matrix: not a l-value`);\n    }\n\n\n\n    //\n    // GENERIC UTILITIES\n    //\n\n    /**\n     * Assign an expression (i.e., this := expr)\n     * @param {SpeedyMatrixExpr|number[]} expr\n     * @returns {SpeedyPromise<SpeedyMatrixAssignmentExpr>}\n     */\n    assign(expr)\n    {\n        throw new IllegalOperationError(`Can't assign matrix: not a l-value`);\n    }\n\n    /**\n     * Fill the matrix with a constant value\n     * @param {number} value\n     * @returns {SpeedyPromise<SpeedyMatrixAssignmentExpr>}\n     */\n    fill(value)\n    {\n        throw new IllegalOperationError(`Can't fill matrix: not a l-value`);\n    }\n\n    /**\n     * Read the entries of this matrix\n     * Results are given in column-major format\n     * @returns {SpeedyPromise<number[]>}\n     */\n    read()\n    {\n        this._readbuf = this._readbuf || [];\n        return this._evaluate().then(expr => expr._matrix.read(undefined, this._readbuf)).turbocharge();\n    }\n\n    /**\n     * Print the result of this matrix expression to the console\n     * @param {Function} [printFunction] prints a string\n     * @param {number} [decimals] format numbers to a number of decimals\n     * @returns {SpeedyPromise<void>} a promise that resolves as soon as the matrix is printed\n     */\n    print(printFunction = undefined, decimals = undefined)\n    {\n        return this._evaluate().then(expr => expr._matrix.print(printFunction, decimals)).turbocharge();\n    }\n\n\n\n\n\n    //\n    // ACCESS BY BLOCK\n    //\n\n    /**\n     * Extract a (lastRow - firstRow + 1) x (lastColumn - firstColumn + 1)\n     * block from the matrix. All indices are 0-based. Note that the\n     * memory of the block is shared with the memory of the matrix.\n     * @param {number} firstRow\n     * @param {number} lastRow\n     * @param {number} firstColumn\n     * @param {number} lastColumn\n     * @returns {SpeedyMatrixReadonlyBlockExpr}\n     */\n    block(firstRow, lastRow, firstColumn, lastColumn)\n    {\n        return new SpeedyMatrixReadonlyBlockExpr(this, firstRow, lastRow, firstColumn, lastColumn);\n    }\n\n    /**\n     * Get the i-th row of the matrix\n     * @param {number} i 0-based index\n     */\n    row(i)\n    {\n        return this.block(i, i, 0, this._columns - 1);\n    }\n\n    /**\n     * Get the j-th column of the matrix\n     * @param {number} j 0-based index\n     */\n    column(j)\n    {\n        return this.block(0, this._rows - 1, j, j);\n    }\n\n    /**\n     * Get (lastRow - firstRow + 1) contiguous rows. Both indices are inclusive.\n     * @param {number} firstRow\n     * @param {number} lastRow\n     */\n    rowSet(firstRow, lastRow)\n    {\n        return this.block(firstRow, lastRow, 0, this._columns - 1);\n    }\n\n    /**\n     * Get (lastColumn - firstColumn + 1) contiguous columns. Both indices are inclusive.\n     * @param {number} firstColumn\n     * @param {number} lastColumn\n     */\n    columnSet(firstColumn, lastColumn)\n    {\n        return this.block(0, this._rows - 1, firstColumn, lastColumn);\n    }\n\n    /**\n     * Get the main diagonal of the matrix. Internal buffer is shared.\n     * @returns {SpeedyMatrixReadonlyDiagonalExpr}\n     */\n    diagonal()\n    {\n        return new SpeedyMatrixReadonlyDiagonalExpr(this);\n    }\n\n\n\n\n    //\n    // GENERAL OPERATIONS\n    //\n\n\n    /**\n     * Clone matrix\n     * @returns {SpeedyMatrixExpr}\n     */\n    clone()\n    {\n        return new SpeedyMatrixCloneExpr(this);\n    }\n\n    /**\n     * Transpose matrix\n     * @returns {SpeedyMatrixExpr}\n     */\n    transpose()\n    {\n        return new SpeedyMatrixTransposeExpr(this);\n    }\n\n    /**\n     * Add this matrix to another\n     * @param {SpeedyMatrixExpr} expr\n     * @returns {SpeedyMatrixExpr}\n     */\n    plus(expr)\n    {\n        return new SpeedyMatrixAddExpr(this, expr);\n    }\n\n    /**\n     * Subtract another matrix from this\n     * @param {SpeedyMatrixExpr} expr\n     * @returns {SpeedyMatrixExpr}\n     */\n    minus(expr)\n    {\n        return new SpeedyMatrixSubtractExpr(this, expr);\n    }\n\n    /**\n     * Multiply by a matrix or by a number\n     * @param {SpeedyMatrixExpr|number} expr\n     * @returns {SpeedyMatrixExpr}\n     */\n    times(expr)\n    {\n        if(expr instanceof SpeedyMatrixExpr)\n            return new SpeedyMatrixMultiplyExpr(this, expr);\n        else\n            return new SpeedyMatrixScaleExpr(this, expr);\n    }\n\n    /**\n     * Component-wise multiplication\n     * @param {SpeedyMatrixExpr} expr\n     * @returns {SpeedyMatrixExpr}\n     */\n    compMult(expr)\n    {\n        return new SpeedyMatrixCompMultExpr(this, expr);\n    }\n\n\n\n    //\n    // Linear Algebra\n    //\n\n    /**\n     * QR decomposition\n     * @param {string} [mode] 'full' | 'reduced'\n     * @returns {SpeedyMatrixExpr}\n     */\n    qr(mode = 'reduced')\n    {\n        return new SpeedyMatrixQRExpr(this, mode);\n    }\n\n    /**\n     * Find least squares solution for a system of linear equations,\n     * i.e., find x such that the 2-norm |b - Ax| is minimized.\n     * A is this (m x n) matrix expression, satisfying m >= n\n     * m is the number of equations and n is the number of unknowns\n     * @param {SpeedyMatrixExpr} b m x 1 matrix\n     */\n    lssolve(b)\n    {\n        return new SpeedyMatrixLSSolveNodeExpr(this, b);\n    }\n\n    /**\n     * Solve a linear system of equations,\n     * i.e., solve Ax = b for x. A is this\n     * (m x m) expression and b is m x 1\n     * @param {SpeedyMatrixExpr} b\n     * @param {string} [method] 'qr'\n     */\n    solve(b, method = 'qr')\n    {\n        // m: rows (number of equations), n: columns (number of unknowns)\n        const rows = this._rows, columns = this._columns;\n\n        // validate size\n        if(rows !== columns)\n            throw new IllegalArgumentError(`solve expects a square matrix, but received a ${rows} x ${columns} matrix`);\n        else if(b.rows !== rows || b.columns !== 1)\n            throw new IllegalArgumentError(`solve expected a ${rows} x 1 input vector, but received a ${b.rows} x ${b.columns} matrix`);\n\n        // solve system of equations\n        switch(method)\n        {\n            case 'qr':\n                return this.lssolve(b);\n\n            // TODO: Gaussian elimination\n            //case 'lu':\n\n            default:\n                throw new IllegalArgumentError(`Unknown method for solve: \"${method}\"`);\n        }\n    }\n\n\n\n\n\n\n\n    //\n    // Internal utilities\n    //\n\n    /**\n     * Internal QR solver: Ax = b\n     * This creates a matrix [ (Q^T) b | R ] using reduced QR\n     * All (m-n) entries at the bottom are zeros\n     * @param {SpeedyMatrixExpr} b\n     * @returns {SpeedyMatrixExpr}\n     */\n    _qrSolve(b)\n    {\n        return new SpeedyMatrixQRSolverNodeExpr(this, b);\n    }\n\n    /**\n     * Internal back-substitution algorithm. It assumes this\n     * matrix expression is of the form [ b | R ] for some\n     * upper-triangular R matrix and some column-vector b\n     */\n    _backSubstitution()\n    {\n        return new SpeedyMatrixBackSubstitutionNodeExpr(this);\n    }\n}\n\n/**\n * The result of an intermediate calculation (e.g., A + B)\n * A temporary matrix for storing the result of the calculation is created\n * @abstract\n */\nclass SpeedyMatrixTempExpr extends SpeedyMatrixExpr\n{\n    /**\n     * Constructor\n     * @param {number} rows number of rows of the output matrix\n     * @param {number} columns number of columns of the output matrix\n     * @param {number} type type of the output matrix\n     */\n    constructor(rows, columns, type)\n    {\n        super(rows, columns, type);\n        this._tmpmatrix = new SpeedyMatrix(rows, columns, undefined, type); // used for temporary calculations\n    }\n\n    /**\n     * Get the matrix associated with this expression\n     * This matrix must be guaranteed to be available after evaluating this expression\n     * @returns {SpeedyMatrix}\n     */\n    get _matrix()\n    {\n        return this._tmpmatrix;\n    }\n}\n\n/**\n * Unary expression\n * @abstract\n */\nclass SpeedyMatrixUnaryExpr extends SpeedyMatrixTempExpr\n{\n    /**\n     * Constructor\n     * @param {number} rows number of rows of the resulting (output) matrix\n     * @param {number} columns number of columns of the resulting (output) matrix\n     * @param {SpeedyMatrixExpr} expr input expression\n     * @param {Function} operationClass unary operation\n     * @param {any[]} [...args] will be used when instantiating the unary operation\n     */\n    constructor(rows, columns, expr, operationClass, ...args)\n    {\n        super(rows, columns, expr.type);\n        this._expr = expr;\n        this._operationClass = operationClass;\n        this._operation = null; // cache the MatrixOperation object\n        this._args = args;\n    }\n\n    /**\n     * Evaluate expression\n     * @returns {SpeedyPromise<SpeedyMatrixExpr>}\n     */\n    _evaluate()\n    {\n        return this._expr._evaluate().then(result =>\n            matrixOperationsQueue.enqueue(\n                (\n                    this._operation ? this._operation.update([ result._matrix ]) :\n                    (this._operation = new (this._operationClass)(result._matrix, ...(this._args)))\n                ),\n                this._matrix\n            )\n        ).then(() => this);\n    }\n\n    /**\n     * Input expression\n     * @returns {SpeedyMatrixExpr}\n     */\n    get child()\n    {\n        return this._expr;\n    }\n}\n\n/**\n * Binary expression\n * @abstract\n */\nclass SpeedyMatrixBinaryExpr extends SpeedyMatrixTempExpr\n{\n    /**\n     * Constructor\n     * @param {number} rows number of rows of the resulting (output) matrix\n     * @param {number} columns number of columns of the resulting (output) matrix\n     * @param {SpeedyMatrixExpr} leftExpr left operand/expression\n     * @param {SpeedyMatrixExpr} rightExpr right operand/expression\n     * @param {Function} operationClass binary operation\n     * @param {any[]} [...args] will be used when instantiating the binary operation\n     */\n    constructor(rows, columns, leftExpr, rightExpr, operationClass, ...args)\n    {\n        super(rows, columns, leftExpr.type);\n        this._leftExpr = leftExpr;\n        this._rightExpr = rightExpr;\n        this._operationClass = operationClass;\n        this._operation = null; // cache the MatrixOperation object\n        this._args = args;\n\n        if(rightExpr.type !== leftExpr.type) // just in case...\n            this._assertCompatibility(rows, columns, rightExpr.type);\n    }\n\n    /**\n     * Evaluate expression\n     * @returns {SpeedyPromise<SpeedyMatrixExpr>}\n     */\n    _evaluate()\n    {\n        return SpeedyPromise.all([\n            this._leftExpr._evaluate().turbocharge(),\n            this._rightExpr._evaluate().turbocharge()\n        ]).then(([ leftResult, rightResult ]) =>\n            matrixOperationsQueue.enqueue(\n                (\n                    this._operation ? this._operation.update([ leftResult._matrix, rightResult._matrix ]) :\n                    (this._operation = new (this._operationClass)(leftResult._matrix, rightResult._matrix, ...(this._args)))\n                ),\n                this._matrix\n            )\n        ).then(() => this);\n    }\n\n    /**\n     * Left input expression\n     * @returns {SpeedyMatrixExpr}\n     */\n    get leftChild()\n    {\n        return this._leftExpr;\n    }\n\n    /**\n     * Right input expression\n     * @returns {SpeedyMatrixExpr}\n     */\n    get rightChild()\n    {\n        return this._rightExpr;\n    }\n}\n\n/**\n * Extract a read-only block submatrix from a matrix expression\n */\nclass SpeedyMatrixReadonlyBlockExpr extends SpeedyMatrixExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} expr originating matrix expression\n     * @param {number} firstRow indexed by 0\n     * @param {number} lastRow\n     * @param {number} firstColumn\n     * @param {number} lastColumn\n     */\n    constructor(expr, firstRow, lastRow, firstColumn, lastColumn)\n    {\n        super(lastRow - firstRow + 1, lastColumn - firstColumn + 1, expr.type);\n\n        this._expr = expr;\n        this._firstRow = firstRow;\n        this._lastRow = lastRow;\n        this._firstColumn = firstColumn;\n        this._lastColumn = lastColumn;\n        this._submatrix = null;\n        this._cachedMatrix = null;\n    }\n\n    /**\n     * Get the matrix associated with this expression\n     * This matrix must be guaranteed to be available after evaluating this expression\n     * @returns {SpeedyMatrix}\n     */\n    get _matrix()\n    {\n        return this._submatrix;\n    }\n\n    /**\n     * Evaluate the expression\n     * @returns {SpeedyPromise<SpeedyMatrixExpr>}\n     */\n    _evaluate()\n    {\n        return this._expr._evaluate().then(result => {\n            if(result._matrix !== this._cachedMatrix || this._submatrix === null) {\n                this._cachedMatrix = result._matrix;\n                return this._cachedMatrix.block(this._firstRow, this._lastRow, this._firstColumn, this._lastColumn);\n            }\n            return this._submatrix; // we've already extracted the submatrix\n        }).then(submatrix => {\n            this._submatrix = submatrix;\n            return this;\n        });\n    }\n}\n\n/**\n * Extract a read-only diagonal from a matrix expression\n */\nclass SpeedyMatrixReadonlyDiagonalExpr extends SpeedyMatrixExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} expr originating matrix expression\n     */\n    constructor(expr)\n    {\n        const diagonalLength = Math.min(expr.rows, expr.columns);\n        super(1, diagonalLength, expr.type);\n\n        this._expr = expr;\n        this._diagonal = null;\n        this._cachedMatrix = null;\n    }\n\n    /**\n     * Get the matrix associated with this expression\n     * This matrix must be guaranteed to be available after evaluating this expression\n     * @returns {SpeedyMatrix}\n     */\n    get _matrix()\n    {\n        return this._diagonal;\n    }\n\n    /**\n     * Evaluate the expression\n     * @returns {SpeedyPromise<SpeedyMatrixExpr>}\n     */\n    _evaluate()\n    {\n        return this._expr._evaluate().then(result => {\n            if(result._matrix !== this._cachedMatrix || this._diagonal === null) {\n                this._cachedMatrix = result._matrix;\n                return this._cachedMatrix.diagonal();\n            }\n            return this._diagonal; // we've already extracted the diagonal\n        }).then(diagonal => {\n            this._diagonal = diagonal;\n            return this;\n        });\n    }\n}\n\n\n\n\n// ================================================\n// L-VALUES\n// ================================================\n\n/**\n * An lvalue (locator value) expression represents a user-owned object stored in memory\n * @abstract\n */\nclass SpeedyMatrixLvalueExpr extends SpeedyMatrixExpr\n{\n    /**\n     * Get the matrix associated with this lvalue expression\n     * This matrix must be guaranteed to be available after evaluating this expression\n     * @returns {SpeedyMatrix}\n     */\n    get _matrix()\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Assign a matrix\n     * @param {SpeedyMatrix} matrix\n     * @returns {SpeedyPromise<void>} resolves as soon as the assignment is done\n     */\n    _assign(matrix)\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Assign an expression to this lvalue\n     * @param {SpeedyMatrixExpr|number[]} expr\n     * @returns {SpeedyPromise<SpeedyMatrixAssignmentExpr>} resolves as soon as the assignment is done\n     */\n    assign(expr)\n    {\n        const assignment = new SpeedyMatrixAssignmentExpr(this, expr);\n        return assignment._evaluate().turbocharge();\n    }\n\n    /**\n     * Fill the matrix with a constant value\n     * @param {number} value\n     * @returns {SpeedyPromise<SpeedyMatrixAssignmentExpr>}\n     */\n    fill(value)\n    {\n        return this.assign(new SpeedyMatrixFillExpr(this._rows, this._columns, this._type, +value));\n    }\n\n    /**\n     * Extract a (lastRow - firstRow + 1) x (lastColumn - firstColumn + 1)\n     * block from the matrix. All indices are 0-based. Note that the\n     * memory of the block is shared with the memory of the matrix.\n     * @param {number} firstRow\n     * @param {number} lastRow\n     * @param {number} firstColumn\n     * @param {number} lastColumn\n     * @returns {SpeedyMatrixReadwriteBlockExpr}\n     */\n    block(firstRow, lastRow, firstColumn, lastColumn)\n    {\n        return new SpeedyMatrixReadwriteBlockExpr(this, firstRow, lastRow, firstColumn, lastColumn);\n    }\n\n    /**\n     * Get the main diagonal of the matrix. Internal buffer is shared.\n     * @returns {SpeedyMatrixReadwriteDiagonalExpr}\n     */\n    diagonal()\n    {\n        return new SpeedyMatrixReadwriteDiagonalExpr(this);\n    }\n}\n\n/**\n * Assignment expression\n * Assign rvalue to lvalue (i.e., lvalue := rvalue)\n */\nclass SpeedyMatrixAssignmentExpr extends SpeedyMatrixLvalueExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixLvalueExpr} lvalue\n     * @param {SpeedyMatrixExpr|number[]} rvalue matrix expression or array of numbers in column-major format\n     */\n    constructor(lvalue, rvalue)\n    {\n        const { rows, columns, type } = lvalue;\n        super(rows, columns, type);\n\n        // convert rvalue to SpeedyMatrixExpr\n        if(!(rvalue instanceof SpeedyMatrixExpr)) {\n            if(Array.isArray(rvalue)) {\n                const matrix = new SpeedyMatrix(rows, columns, rvalue, type);\n                rvalue = new SpeedyMatrixElementaryExpr(rows, columns, type, matrix);\n            }\n            else\n                throw new IllegalArgumentError(`Can't assign matrix to ${rvalue}`)\n        }\n\n        this._assertCompatibility(rvalue.rows, rvalue.columns, rvalue.type);\n        this._lvalue = lvalue;\n        this._rvalue = rvalue;\n    }\n\n    /**\n     * Evaluate expression\n     * @returns {SpeedyPromise<SpeedyMatrixAssignmentExpr>}\n     */\n    _evaluate()\n    {\n        return SpeedyPromise.all([\n            this._lvalue._evaluate().turbocharge(),\n            this._rvalue._evaluate().turbocharge()\n        ]).then(([ lvalue, rvalue ]) =>\n            lvalue._assign(rvalue._matrix).turbocharge()\n        ).then(() => this);\n    }\n}\n\n/**\n * An elementary expression representing a single matrix\n * (e.g., expression 'A' represents a single matrix)\n */\nclass SpeedyMatrixElementaryExpr extends SpeedyMatrixLvalueExpr\n{\n    /**\n     * Constructor\n     * @param {number} rows\n     * @param {number} columns\n     * @param {number} type\n     * @param {SpeedyMatrix} [matrix] user matrix\n     */\n    constructor(rows, columns, type, matrix = null)\n    {\n        super(rows, columns, type);\n        this._usermatrix = null;\n\n        if(matrix != null) {\n            this._assertCompatibility(matrix.rows, matrix.columns, matrix.type);\n            this._usermatrix = matrix;\n        }\n    }\n\n    /**\n     * Get the matrix associated with this lvalue expression\n     * This matrix must be guaranteed to be available after evaluating this expression\n     * @returns {SpeedyMatrix}\n     */\n    get _matrix()\n    {\n        if(this._usermatrix == null)\n            throw new IllegalOperationError(`Matrix doesn't have any data. Make sure you assign data to it.`);\n\n        return this._usermatrix;\n    }\n\n    /**\n     * Evaluate the expression\n     * @returns {SpeedyPromise<SpeedyMatrixExpr>}\n     */\n    _evaluate()\n    {\n        return SpeedyPromise.resolve(this);\n    }\n\n    /**\n     * Assign a matrix\n     * We just change pointers; no actual copying of data takes place\n     * @param {SpeedyMatrix} matrix\n     * @returns {SpeedyPromise<void>} resolves as soon as the assignment is done\n     */\n    _assign(matrix)\n    {\n        this._usermatrix = matrix;\n        return SpeedyPromise.resolve();\n    }\n}\n\n/**\n * Extract a read-write block submatrix from a matrix expression\n */\nclass SpeedyMatrixReadwriteBlockExpr extends SpeedyMatrixLvalueExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} expr originating matrix expression\n     * @param {number} firstRow indexed by 0\n     * @param {number} lastRow\n     * @param {number} firstColumn\n     * @param {number} lastColumn\n     */\n    constructor(expr, firstRow, lastRow, firstColumn, lastColumn)\n    {\n        super(lastRow - firstRow + 1, lastColumn - firstColumn + 1, expr.type);\n\n        this._expr = expr;\n        this._firstRow = firstRow;\n        this._lastRow = lastRow;\n        this._firstColumn = firstColumn;\n        this._lastColumn = lastColumn;\n        this._submatrix = null;\n        this._cachedMatrix = null;\n        this._operation = null; // cached operation\n    }\n\n    /**\n     * Get the matrix associated with this lvalue expression\n     * This matrix must be guaranteed to be available after evaluating this expression\n     * @returns {SpeedyMatrix}\n     */\n    get _matrix()\n    {\n        return this._submatrix;\n    }\n\n    /**\n     * Evaluate the expression\n     * @returns {SpeedyPromise<SpeedyMatrixExpr>}\n     */\n    _evaluate()\n    {\n        return this._expr._evaluate().then(result => {\n            if(result._matrix !== this._cachedMatrix || this._submatrix === null) {\n                this._cachedMatrix = result._matrix;\n                return this._cachedMatrix.block(this._firstRow, this._lastRow, this._firstColumn, this._lastColumn);\n            }\n            return this._submatrix; // we've already extracted the submatrix\n        }).then(submatrix => {\n            this._submatrix = submatrix;\n            return this;\n        });\n    }\n\n    /**\n     * Assign a matrix\n     * Since this is a submatrix, we can't just assign pointers.\n     * We need to copy the data\n     * @param {SpeedyMatrix} matrix\n     * @returns {SpeedyPromise<void>} resolves as soon as the assignment is done\n     */\n    _assign(matrix)\n    {\n        return matrixOperationsQueue.enqueue(\n            (\n                this._operation ? this._operation.update([ matrix ]) :\n                (this._operation = new MatrixOperationCopy(matrix))\n            ),\n            this._submatrix\n        );\n    }\n}\n\n/**\n * Extract a read-write diagonal from a matrix expression\n */\nclass SpeedyMatrixReadwriteDiagonalExpr extends SpeedyMatrixLvalueExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} expr originating matrix expression\n     */\n    constructor(expr)\n    {\n        const diagonalLength = Math.min(expr.rows, expr.columns);\n        super(1, diagonalLength, expr.type);\n\n        this._expr = expr;\n        this._diagonal = null;\n        this._cachedMatrix = null;\n    }\n\n    /**\n     * Get the matrix associated with this expression\n     * This matrix must be guaranteed to be available after evaluating this expression\n     * @returns {SpeedyMatrix}\n     */\n    get _matrix()\n    {\n        return this._diagonal;\n    }\n\n    /**\n     * Evaluate the expression\n     * @returns {SpeedyPromise<SpeedyMatrixExpr>}\n     */\n    _evaluate()\n    {\n        return this._expr._evaluate().then(result => {\n            if(result._matrix !== this._cachedMatrix || this._diagonal === null) {\n                this._cachedMatrix = result._matrix;\n                return this._cachedMatrix.diagonal();\n            }\n            return this._diagonal; // we've already extracted the diagonal\n        }).then(diagonal => {\n            this._diagonal = diagonal;\n            return this;\n        });\n    }\n\n    /**\n     * Assign a matrix\n     * Since this is a diagonal, we can't just assign pointers.\n     * We need to copy the data\n     * @param {SpeedyMatrix} matrix\n     * @returns {SpeedyPromise<void>} resolves as soon as the assignment is done\n     */\n    _assign(matrix)\n    {\n        return matrixOperationsQueue.enqueue(\n            (\n                this._operation ? this._operation.update([ matrix ]) :\n                (this._operation = new MatrixOperationCopy(matrix))\n            ),\n            this._diagonal\n        );\n    }\n}\n\n\n// ================================================\n// BASIC OPERATIONS\n// ================================================\n\n/**\n * Fill the output matrix with a constant value\n */\nclass SpeedyMatrixFillExpr extends SpeedyMatrixTempExpr\n{\n    /**\n     * Constructor\n     * @param {number} rows number of rows of the resulting (output) matrix\n     * @param {number} columns number of columns of the resulting (output) matrix\n     * @param {number} type type of the resulting (output) matrix\n     * @param {number} value will fill the output matrix with this constant value\n     */\n    constructor(rows, columns, type, value)\n    {\n        super(rows, columns, type);\n        this._operation = new MatrixOperationFill(rows, columns, type, value);\n    }\n\n    /**\n     * Evaluate expression\n     * @returns {SpeedyPromise<SpeedyMatrixExpr>}\n     */\n    _evaluate()\n    {\n        return matrixOperationsQueue.enqueue(\n            this._operation,\n            this._matrix\n        ).then(() => this);\n    }\n}\n\n/**\n * Clone a matrix, copying individual entries\n * e.g., A = B.clone()\n */\nclass SpeedyMatrixCloneExpr extends SpeedyMatrixUnaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} expr\n     */\n    constructor(expr)\n    {\n        super(expr.rows, expr.columns, expr, MatrixOperationCopy);\n    }\n}\n\n/**\n * Tranpose a matrix,\n * e.g., A = A^T\n */\nclass SpeedyMatrixTransposeExpr extends SpeedyMatrixUnaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} expr\n     */\n    constructor(expr)\n    {\n        // optimize if the input expression is a transposition\n        if(expr instanceof SpeedyMatrixTransposeExpr) {\n            // A = (A^T)^T\n            return expr.child;\n        }\n\n        // regular transposition\n        super(expr.columns, expr.rows, expr, MatrixOperationTranspose);\n    }\n}\n\n/**\n * Add two matrix expressions,\n * e.g., A = B + C\n */\nclass SpeedyMatrixAddExpr extends SpeedyMatrixBinaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} leftExpr\n     * @param {SpeedyMatrixExpr} rightExpr\n     */\n    constructor(leftExpr, rightExpr)\n    {\n        super(leftExpr.rows, leftExpr.columns, leftExpr, rightExpr, MatrixOperationAdd);\n        this._assertCompatibility(rightExpr.rows, rightExpr.columns);\n    }\n}\n\n/**\n * Subtract two matrix expressions,\n * e.g., A = B - C\n */\nclass SpeedyMatrixSubtractExpr extends SpeedyMatrixBinaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} leftExpr\n     * @param {SpeedyMatrixExpr} rightExpr\n     */\n    constructor(leftExpr, rightExpr)\n    {\n        super(leftExpr.rows, leftExpr.columns, leftExpr, rightExpr, MatrixOperationSubtract);\n        this._assertCompatibility(rightExpr.rows, rightExpr.columns);\n    }\n}\n\n/**\n * Multiply two matrix expressions,\n * e.g., A = B * C\n */\nclass SpeedyMatrixMultiplyExpr extends SpeedyMatrixBinaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} leftExpr\n     * @param {SpeedyMatrixExpr} rightExpr\n     */\n    constructor(leftExpr, rightExpr)\n    {\n        // optimize if the input expressions are transposed\n        const lt = leftExpr instanceof SpeedyMatrixTransposeExpr;\n        const rt = rightExpr instanceof SpeedyMatrixTransposeExpr;\n        if(lt && rt) {\n            // A = (B^T) (C^T) = (C B)^T\n            return new SpeedyMatrixTransposeExpr(\n                new SpeedyMatrixMultiplyExpr(rightExpr.child, leftExpr.child)\n            );\n        }\n        else if(lt && !rt) {\n            // A = (B^T) C\n            return new SpeedyMatrixMultiplyLTExpr(leftExpr.child, rightExpr);\n        }\n        else if(!lt && rt) {\n            // A = B (C^T)\n            return new SpeedyMatrixMultiplyRTExpr(leftExpr, rightExpr.child);\n        }\n\n        // multiply by a column-vector\n        if(rightExpr.columns === 1)\n            return new SpeedyMatrixMultiplyVecExpr(leftExpr, rightExpr);\n\n        // regular multiplication\n        super(leftExpr.rows, rightExpr.columns, leftExpr, rightExpr, MatrixOperationMultiply);\n        if(leftExpr.columns !== rightExpr.rows)\n            throw new IllegalArgumentError(`Can't multiply a ${leftExpr.rows} x ${leftExpr.columns} matrix by a ${rightExpr.rows} x ${rightExpr.columns} matrix`);\n    }\n}\n\n/**\n * Multiply two matrix expressions, transposing the left operand\n * e.g., A = B^T * C\n */\nclass SpeedyMatrixMultiplyLTExpr extends SpeedyMatrixBinaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} leftExpr\n     * @param {SpeedyMatrixExpr} rightExpr\n     */\n    constructor(leftExpr, rightExpr)\n    {\n        super(leftExpr.columns, rightExpr.columns, leftExpr, rightExpr, MatrixOperationMultiplyLT);\n        if(leftExpr.rows !== rightExpr.rows)\n            throw new IllegalArgumentError(`Can't multiply a ${leftExpr.columns} x ${leftExpr.rows} (transposed) matrix by a ${rightExpr.rows} x ${rightExpr.columns} matrix`);\n    }\n}\n\n/**\n * Multiply two matrix expressions, transposing the right operand\n * e.g., A = B * C^T\n */\nclass SpeedyMatrixMultiplyRTExpr extends SpeedyMatrixBinaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} leftExpr\n     * @param {SpeedyMatrixExpr} rightExpr\n     */\n    constructor(leftExpr, rightExpr)\n    {\n        super(leftExpr.rows, rightExpr.rows, leftExpr, rightExpr, MatrixOperationMultiplyRT);\n        if(leftExpr.columns !== rightExpr.columns)\n            throw new IllegalArgumentError(`Can't multiply a ${leftExpr.rows} x ${leftExpr.columns} matrix by a ${rightExpr.columns} x ${rightExpr.rows} (transposed) matrix`);\n    }\n}\n\n/**\n * Multiply a matrix A by a column-vector x,\n * e.g., y = A x\n */\nclass SpeedyMatrixMultiplyVecExpr extends SpeedyMatrixBinaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} leftExpr\n     * @param {SpeedyMatrixExpr} rightExpr\n     */\n    constructor(leftExpr, rightExpr)\n    {\n        super(leftExpr.rows, rightExpr.columns, leftExpr, rightExpr, MatrixOperationMultiplyVec);\n        if(leftExpr.columns !== rightExpr.rows || rightExpr.columns !== 1)\n            throw new IllegalArgumentError(`Can't multiply a ${leftExpr.rows} x ${leftExpr.columns} matrix by a ${rightExpr.rows} x ${rightExpr.columns} matrix / column-vector`);\n    }\n}\n\n/**\n * Multiply a matrix expression by a number,\n * e.g., A = alpha B\n */\nclass SpeedyMatrixScaleExpr extends SpeedyMatrixUnaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} expr\n     * @param {number} scalar\n     */\n    constructor(expr, scalar)\n    {\n        super(expr.rows, expr.columns, expr, MatrixOperationScale, scalar);\n    }\n}\n\n/**\n * Component-wise multiplication of two matrix expressions\n */\nclass SpeedyMatrixCompMultExpr extends SpeedyMatrixBinaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} leftExpr\n     * @param {SpeedyMatrixExpr} rightExpr\n     */\n    constructor(leftExpr, rightExpr)\n    {\n        super(leftExpr.rows, leftExpr.columns, leftExpr, rightExpr, MatrixOperationCompMult);\n        this._assertCompatibility(rightExpr.rows, rightExpr.columns);\n    }\n}\n\n/**\n * QR decomposition\n */\nclass SpeedyMatrixQRExpr extends SpeedyMatrixUnaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} expr\n     * @param {string} mode 'full' | 'reduced'\n     */\n    constructor(expr, mode)\n    {\n        const columns = mode == 'full' ? expr.columns + expr.rows : 2 * expr.columns;\n        if(expr.rows < expr.columns)\n            throw new IllegalArgumentError(`Can't compute the QR decomposition of a ${expr.rows} x ${expr.columns} matrix`);\n\n        super(expr.rows, columns, expr, MatrixOperationQR, mode);\n    }\n}\n\n\n\n\n\n\n// ==============================================\n// INTERNAL UTILITIES\n// ==============================================\n\n/**\n * Internal QR solver (Ax = b)\n */\nclass SpeedyMatrixQRSolverNodeExpr extends SpeedyMatrixBinaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} matrixA m x n matrix\n     * @param {SpeedyMatrixExpr} vectorB m x 1 vector\n     */\n    constructor(matrixA, vectorB)\n    {\n        if(matrixA.rows < matrixA.columns)\n            throw new IllegalArgumentError(`Can't compute the QR decomposition of a ${matrixA.rows} x ${matrixA.columns} matrix`);\n        else if(vectorB.columns != 1 || vectorB.rows != matrixA.rows)\n            throw new IllegalArgumentError(`Expected a ${matrixA.rows} x 1 column-vector, but found a ${vectorB.rows} x ${vectorB.columns} matrix`);\n\n        super(matrixA.rows, matrixA.columns + 1, matrixA, vectorB, MatrixOperationQRSolve);\n    }\n}\n\n/**\n * Back-substitution algorithm\n * (solve Rx = b for x, R is upper-triangular)\n */\nclass SpeedyMatrixBackSubstitutionNodeExpr extends SpeedyMatrixUnaryExpr\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrixExpr} input [b | R] matrix\n     */\n    constructor(input)\n    {\n        if(input.columns != input.rows + 1)\n            throw new IllegalArgumentError(`Expected a ${input.rows} x ${input.rows + 1} matrix, but found a ${input.rows} x ${input.columns} matrix`);\n\n        super(input.rows, 1, input, MatrixOperationBackSubstitution);\n    }\n}\n\n/**\n * Find best-fit solution x of Ax = b with least-squares method\n * A is m x n, b is m x 1, output x is n x 1\n * (m equations, n unknowns, m >= n)\n */\nclass SpeedyMatrixLSSolveNodeExpr extends SpeedyMatrixBinaryExpr\n{\n    constructor(matrixA, vectorB)\n    {\n        const [ m, n ] = [ matrixA.rows, matrixA.columns ];\n\n        if(m < n)\n            throw new IllegalArgumentError(`Input matrix has more columns than rows - it's ${m} x ${n}`);\n        else if(vectorB.rows != m || vectorB.columns != 1)\n            throw new IllegalArgumentError(`Expected a ${m} x 1 column-vector, but found a ${vectorB.rows} x ${vectorB.columns} matrix`);\n\n        super(n, 1, matrixA, vectorB, MatrixOperationLSSolve);\n    }\n}\n\n\n\n\n// ================================================\n// MATRIX FACTORY\n// ================================================\n\n/**\n * A Factory of matrix expressions\n */\nexport class SpeedyMatrixExprFactory extends Function\n{\n    /**\n     * Create a new SpeedyMatrixExpr that evaluates to a user-defined matrix\n     * (or to a matrix without data if its entries are not provided)\n     * @param {number} rows number of rows\n     * @param {number} [columns] number of columns (defaults to the number of rows)\n     * @param {number[]} [values] initial values in column-major format\n     * @param {string} [dtype] 'float32' | 'float64' | 'int32' | 'uint8'\n     * @returns {SpeedyMatrixElementaryExpr}\n     */\n    _create(rows, columns = rows, values = null, dtype = 'float32')\n    {\n        let type = DataTypeName2DataType[dtype];\n        let matrix = null;\n\n        if(type === undefined)\n            throw new IllegalArgumentError(`Unknown matrix type: \"${dtype}\"`);\n\n        if(values != null) {\n            if(!Array.isArray(values))\n                throw new IllegalArgumentError(`Can't initialize Matrix with values ${values}`);\n            if(values.length > 0)\n                matrix = new SpeedyMatrix(rows, columns, values, type);\n        }\n\n        return new SpeedyMatrixElementaryExpr(rows, columns, type, matrix);\n    }\n\n    /**\n     * Create a new matrix filled with zeroes\n     * @param {number} rows number of rows\n     * @param {number} [columns] number of columns (defaults to the number of rows)\n     * @param {number[]} [values] initial values in column-major format\n     * @param {string} [dtype] 'float32' | 'float64' | 'int32' | 'uint8'\n     * @returns {SpeedyMatrixElementaryExpr}\n     */\n    Zeros(rows, columns = rows, dtype = 'float32')\n    {\n        const values = (new Array(rows * columns)).fill(0);\n        return this._create(rows, columns, values, dtype);\n    }\n\n    /**\n     * Create a new matrix filled with ones\n     * @param {number} rows number of rows\n     * @param {number} [columns] number of columns (defaults to the number of rows)\n     * @param {number[]} [values] initial values in column-major format\n     * @param {string} [dtype] 'float32' | 'float64' | 'int32' | 'uint8'\n     * @returns {SpeedyMatrixElementaryExpr}\n     */\n    Ones(rows, columns = rows, dtype = 'float32')\n    {\n        const values = (new Array(rows * columns)).fill(1);\n        return this._create(rows, columns, values, dtype);\n    }\n\n    /**\n     * Create a new identity matrix\n     * @param {number} rows number of rows\n     * @param {number} [columns] number of columns (defaults to the number of rows)\n     * @param {number[]} [values] initial values in column-major format\n     * @param {string} [dtype] 'float32' | 'float64' | 'int32' | 'uint8'\n     * @returns {SpeedyMatrixElementaryExpr}\n     */\n    Eye(rows, columns = rows, dtype = 'float32')\n    {\n        const values = (new Array(rows * columns)).fill(0);\n        for(let j = Math.min(rows, columns) - 1; j >= 0; j--)\n            values[j * rows + j] = 1;\n\n        return this._create(rows, columns, values, dtype);\n    }\n\n    /**\n     * The factory can be invoked as a function\n     * This is an alias to SpeedyMatrixExprFactory._create()\n     */\n    constructor()\n    {\n        super('...args', 'return this._create(...args)');\n        return this.bind(this);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * matrix-math.js\n * Linear algebra routines\n */\n\n//! No imports here\n\n/**\n * Matrix math routines\n * All routines are stateless\n */\nclass MatrixMath\n{\n    // ========================================================\n    // Math routines\n    // ========================================================\n\n    /**\n     * No-operation\n     * @param {object} header\n     * @param {TypedArray} output\n     * @param {TypedArray[]} inputs\n     */\n    static nop(header, output, inputs)\n    {\n        ;\n    }\n\n    /**\n     * Fill the matrix with a constant value\n     * @param {object} header\n     * @param {TypedArray} output\n     * @param {TypedArray[]} inputs\n     */\n    static fill(header, output, inputs)\n    {\n        const { rows, columns, stride, length } = header;\n        const { value } = header.custom;\n\n        // use a memset-like operation if possible\n        if(rows * columns == length) {\n            output.fill(value, 0, length);\n            return;\n        }\n\n        // fill the columns one by one\n        for(let j = 0; j < columns; j++)\n            output.fill(value, j * stride, j * stride + rows);\n    }\n\n    /**\n     * Copy matrix\n     * @param {object} header\n     * @param {TypedArray} output\n     * @param {TypedArray[]} inputs\n     */\n    static copy(header, output, inputs)\n    {\n        const { rows, columns, stride, length } = header;\n        const [ istride ] = header.strideOfInputs;\n        const [ input ] = inputs;\n\n        // use a memcpy-like operation if possible\n        if(length == header.lengthOfInputs[0] && rows * columns == length) {\n            output.set(input, 0, length);\n            return;\n        }\n\n        // copy values one by one\n        let i, j, oj, ij;\n        for(oj = ij = j = 0; j < columns; j++, oj += stride, ij += istride) {\n            for(i = 0; i < rows; i++)\n                output[oj + i] = input[ij + i];\n        }\n    }\n\n    /**\n     * Transpose matrix\n     * @param {object} header\n     * @param {TypedArray} output\n     * @param {TypedArray[]} inputs\n     */\n    static transpose(header, output, inputs)\n    {\n        const { rows, columns, stride } = header;\n        const [ strideT ] = header.strideOfInputs;\n        const [ input ] = inputs;\n\n        let i, j, ii, oj;\n        for(ii = i = 0; i < rows; i++, ii += strideT) {\n            for(oj = j = 0; j < columns; j++, oj += stride)\n                output[oj + i] = input[ii + j];\n        }\n    }\n\n    /**\n     * Add two matrices\n     * @param {object} header\n     * @param {TypedArray} output\n     * @param {TypedArray[]} inputs\n     */\n    static add(header, output, inputs)\n    {\n        const { rows, columns, stride } = header;\n        const [ strideA, strideB ] = header.strideOfInputs;\n        const [ a, b ] = inputs;\n\n        let i, j, oj, aj, bj;\n        for(j = 0; j < columns; j++) {\n            oj = j * stride;\n            aj = j * strideA;\n            bj = j * strideB;\n            for(i = 0; i < rows; i++)\n                output[oj + i] = a[aj + i] + b[bj + i];\n        }\n    }\n\n    /**\n     * Subtract two matrices\n     * @param {object} header\n     * @param {TypedArray} output\n     * @param {TypedArray[]} inputs\n     */\n    static subtract(header, output, inputs)\n    {\n        const { rows, columns, stride } = header;\n        const [ strideA, strideB ] = header.strideOfInputs;\n        const [ a, b ] = inputs;\n\n        let i, j, oj, aj, bj;\n        for(j = 0; j < columns; j++) {\n            oj = j * stride;\n            aj = j * strideA;\n            bj = j * strideB;\n            for(i = 0; i < rows; i++)\n                output[oj + i] = a[aj + i] - b[bj + i];\n        }\n    }\n\n    /**\n     * Multiply two matrices (e.g., C = A B)\n     * @param {object} header\n     * @param {TypedArray} output\n     * @param {TypedArray[]} inputs\n     */\n    static multiply(header, output, inputs)\n    {\n        const { rows, columns, stride, length } = header;\n        const [ columnsA, columnsB ] = header.columnsOfInputs;\n        const [ strideA, strideB ] = header.strideOfInputs;\n        const [ a, b ] = inputs;\n\n        // clear matrix\n        if(rows * columns != length) {\n            for(let c = 0; c < columns; c++)\n                output.fill(0, c * stride, c * stride + rows);\n        }\n        else\n            output.fill(0, 0, length);\n\n        // multiply taking cache locality into account\n        let i, j, k, ok, aj, bk, bjk;\n        for(ok = bk = k = 0; k < columnsB; k++, ok += stride, bk += strideB) {\n            for(aj = j = 0; j < columnsA; j++, aj += strideA) {\n                bjk = b[bk + j];\n                for(i = 0; i < rows; i++)\n                    output[ok + i] += a[aj + i] * bjk;\n            }\n        }\n    }\n\n    /**\n     * Multiply two matrices, transposing the left operand\n     * (e.g., C = A^T B)\n     * @param {object} header\n     * @param {TypedArray} output\n     * @param {TypedArray[]} inputs\n     */\n    static multiplylt(header, output, inputs)\n    {\n        const { rows, columns, stride, length } = header;\n        const [ columnsA, columnsB ] = header.columnsOfInputs;\n        const [ rowsA, rowsB ] = header.rowsOfInputs;\n        const [ strideA, strideB ] = header.strideOfInputs;\n        const [ a, b ] = inputs;\n\n        // multiply taking cache locality into account\n        let i, j, k, aj, bk, ok, ojk;\n        for(ok = bk = k = 0; k < columnsB; k++, ok += stride, bk += strideB) {\n            for(aj = j = 0; j < columnsA; j++, aj += strideA) {\n                output[ojk = ok + j] = 0;\n                for(i = 0; i < rowsB; i++)\n                    output[ojk] += a[aj + i] * b[bk + i];\n            }\n        }\n    }\n\n    /**\n     * Multiply two matrices, transposing the right operand\n     * (e.g., C = A B^T)\n     * @param {object} header\n     * @param {TypedArray} output\n     * @param {TypedArray[]} inputs\n     */\n    static multiplyrt(header, output, inputs)\n    {\n        const { rows, columns, stride, length } = header;\n        const [ columnsA, columnsB ] = header.columnsOfInputs;\n        const [ rowsA, rowsB ] = header.rowsOfInputs;\n        const [ strideA, strideB ] = header.strideOfInputs;\n        const [ a, b ] = inputs;\n\n        // clear matrix\n        if(rows * columns != length) {\n            for(let c = 0; c < columns; c++)\n                output.fill(0, c * stride, c * stride + rows);\n        }\n        else\n            output.fill(0, 0, length);\n\n        // multiply taking cache locality into account\n        let i, j, k, ok, aj, bj, bkj;\n        for(aj = bj = j = 0; j < columnsA; j++, aj += strideA, bj += strideB) {\n            for(ok = k = 0; k < rowsB; k++, ok += stride) {\n                bkj = b[bj + k];\n                for(i = 0; i < rows; i++)\n                    output[ok + i] += a[aj + i] * bkj;\n            }\n        }\n    }\n\n    /**\n     * Multiply by a column-vector\n     * (i.e., y = A x)\n     * @param {object} header\n     * @param {TypedArray} output\n     * @param {TypedArray[]} inputs\n     */\n    static multiplyvec(header, output, inputs)\n    {\n        const [ irows ] = header.rowsOfInputs;\n        const [ icolumns ] = header.columnsOfInputs;\n        const [ istride ] = header.strideOfInputs;\n        const [ a, x ] = inputs;\n\n        output.fill(0, 0, irows);\n\n        let i, j, aj, xj;\n        for(aj = j = 0; j < icolumns; j++, aj += istride) {\n            xj = x[j];\n            for(i = 0; i < irows; i++)\n                output[i] += a[aj + i] * xj;\n        }\n    }\n\n    /**\n     * Multiply by a constant\n     * @param {object} header\n     * @param {TypedArray} output\n     * @param {TypedArray[]} inputs\n     */\n    static scale(header, output, inputs)\n    {\n        const { rows, columns, stride } = header;\n        const { scalar } = header.custom;\n        const [ input ] = inputs;\n\n        let i, j, oj;\n        for(j = 0; j < columns; j++) {\n            oj = j * stride;\n            for(i = 0; i < rows; i++)\n                output[oj + i] = input[oj + i] * scalar;\n        }\n    }\n\n    /**\n     * Component-wise multiplication\n     * @param {object} header\n     * @param {TypedArray} output\n     * @param {TypedArray[]} inputs\n     */\n    static compmult(header, output, inputs)\n    {\n        const { rows, columns, stride } = header;\n        const [ strideA, strideB ] = header.strideOfInputs;\n        const [ a, b ] = inputs;\n\n        let i, j, oj, aj, bj;\n        for(j = 0; j < columns; j++) {\n            oj = j * stride;\n            aj = j * strideA;\n            bj = j * strideB;\n            for(i = 0; i < rows; i++)\n                output[oj + i] = a[aj + i] * b[bj + i];\n        }\n    }\n\n    /**\n     * Outer product (m x 1 vector by 1 x n vector)\n     * @param {object} header \n     * @param {TypedArray} output \n     * @param {TypedArray[]} inputs \n     */\n    static outer(header, output, inputs)\n    {\n        const { rows, columns, stride } = header;\n        const [ strideA, strideB ] = header.strideOfInputs;\n        const [ a, b ] = inputs;       \n\n        let i, j, bj, oj;\n        for(j = 0; j < columns; j++) {\n            bj = b[j * strideB];\n            oj = j * stride;\n            for(i = 0; i < rows; i++)\n                output[oj + i] = a[i] * bj;\n        }\n    }\n\n    /**\n     * QR decomposition\n     * @param {object} header\n     * @param {TypedArray} output becomes [ Q | R ] or [ Q'x | R ] or [ Qx | R ]\n     * @param {TypedArray[]} inputs\n     */\n    static qr(header, output, inputs)\n    {\n        const { stride, type } = header;\n        const [ orows, ocolumns ] = [ header.rows, header.columns ];\n        const [ irows, xrows ] = header.rowsOfInputs;\n        const [ icolumns, xcolumns ] = header.columnsOfInputs;\n        const [ istride ] = header.strideOfInputs;\n        const [ input, x ] = inputs;\n        const { mode } = header.custom;\n        const subheader = Object.assign({ }, header, { custom: null });\n        const wantMatrices = (mode == 'full-qr' || mode == 'reduced-qr');\n        let submatrices = [ null, null, null ];\n\n        // create temporary storage\n        const storage = this._createTypedArray(2 * irows * icolumns + icolumns, type);\n        const reflect = storage.subarray(0, irows * icolumns);\n        const tmprow = storage.subarray(irows * icolumns, irows * icolumns + icolumns);\n        const tmp = storage.subarray(irows * icolumns + icolumns, 2 * irows * icolumns + icolumns);\n\n        // create soon-to-be upper triangular matrix R\n        const rstride = stride;\n        const triangular = !wantMatrices ? output.subarray(stride) :\n            output.subarray(((mode == 'reduced-qr') ? icolumns : irows) * stride);\n\n        // input matrix is m x n and should be such that m >= n\n        if(irows < icolumns)\n            throw new Error(`Can't compute the QR decomposition of a ${irows} x ${icolumns} matrix`);\n\n        // validate the number of rows of the output\n        if(orows != irows)\n            throw new Error(`Can't compute the QR decomposition of a ${irows} x ${icolumns} matrix: expected an output matrix of ${irows} rows, but found a matrix of ${orows} rows`);\n\n        // copy input[:,:] to triangular[:,:]\n        if(input.length != triangular.length) {\n            submatrices = this._submatrices(subheader, triangular, [ input ], rstride, [ istride ],\n                [ 0, irows-1, 0, icolumns-1 ],\n                [[ 0, irows-1, 0, icolumns-1 ]]\n            );\n            this.copy(submatrices[0], submatrices[1], submatrices[2]);\n        }\n        else\n            triangular.set(input, 0, input.length);\n\n        // Compute the reflection vectors and the upper triangular matrix R\n        let i, j, k, n, norm, sign, fkk, rkk;\n        for(k = 0; k < icolumns; k++) {\n            fkk = k * irows + k; // reflector index\n            rkk = k * rstride + k; // upper-triangular R\n\n            n = irows - k; // the k-th reflection vector has n components\n            sign = (+(triangular[rkk] >= 0)) - (+(triangular[rkk] < 0)); // sign(triangular[k,k]) is +1 or -1\n\n            // use reflect[k:irows-1,k] to temporarily store the k-th reflection vector\n            for(i = 0; i < n; i++) // copy triangular[k:irows-1,k] to reflect[k:irows-1,k]\n                reflect[fkk + i] = triangular[rkk + i];\n            reflect[fkk] += sign * this._norm2(reflect, fkk, n); // 1st coordinate\n\n            // normalize the k-th reflection vector\n            norm = this._norm2(reflect, fkk, n);\n            // if(norm > 0) // error\n            for(i = fkk + n - 1; i >= fkk; i--)\n                reflect[i] /= norm;\n\n            // extract reflect[k:irows-1,k], triangular[k:irows-1,k:icolumns-1] and tmprow[0,0:icolumns-k-1]\n            submatrices = this._submatrices(subheader, tmprow, [ reflect, triangular ], 1, [ irows, rstride ],\n                [ 0, 0, 0, icolumns-k-1 ], // row vector tmprow[0,0:icolumns-k-1]\n                [\n                    [ k, irows-1, k, k ], // reflect[k:irows-1,k]\n                    [ k, irows-1, k, icolumns-1 ] // triangular[k:irows-1,k:icolumns-1]\n                ]\n            );\n\n            // compute tmprow[0,0:icolumns-k-1] = reflect[k:irows-1,k]^T * triangular[k:irows-1,k:icolumns-1]\n            this.multiplylt(submatrices[0], submatrices[1], submatrices[2]);\n\n            // extract reflect[k:irows-1,k], tmprow[0,0:icolumns-k-1] and tmp[0:irows-k-1,0:icolumns-k-1]\n            submatrices = this._submatrices(subheader, tmp, [ reflect, tmprow ], irows, [ irows, 1 ],\n                [ 0, irows-k-1, 0, icolumns-k-1 ], // tmp[0:irows-k-1,0:icolumns-k-1]\n                [\n                    [ k, irows-1, k, k ], // reflect[k:irows-1,k]\n                    [ 0, 0, 0, icolumns-k-1] // tmprow[0,0:icolumns-k-1], the result of the previous calculation\n                ]\n            );\n\n            // compute tmp[0:irows-k-1,0:icolumns-k-1] = reflect[k:irows-1,k] * tmprow[0,0:icolumns-k-1]\n            this.outer(submatrices[0], submatrices[1], submatrices[2]);\n\n            // extract tmp[0:irows-k-1,0:icolumns-k-1] and triangular[k:irows-1,k:icolumns-1] (compute in-place)\n            submatrices = this._submatrices(subheader, triangular, [ triangular, tmp ], rstride, [ rstride, irows ],\n                [ k, irows-1, k, icolumns-1 ], // triangular[k:irows-1,k:icolumns-1]\n                [\n                    [ k, irows-1, k, icolumns-1 ], // triangular[k:irows-1,k:icolumns-1]\n                    [ 0, irows-k-1, 0, icolumns-k-1 ] // tmp[0:irows-k-1,0:icolumns-k-1], the result of the previous calculation\n                ]\n            );\n\n            // apply Householder reflector to set the column vector triangular[k+1:irows-1,k] to zero\n            this._addInPlace(submatrices[0], submatrices[1], submatrices[2], 1, -2);\n        }\n\n        // Compute the unitary matrix Q\n        switch(mode) {\n\n            //\n            // Full QR decomposition\n            // Q: m x m, R: m x n\n            //\n            case 'full-qr': {\n                const qstride = stride;\n                const unitary = output.subarray(0, qstride * irows).fill(0);\n                let fk, qj, dot;\n\n                // validate output size\n                if(orows != irows || ocolumns != icolumns + irows)\n                    throw new Error(`Can't compute the full QR decomposition of a ${irows} x ${icolumns} matrix: expected an output matrix of size ${irows} x ${icolumns + irows}, found ${orows} x ${ocolumns}`);\n\n                // apply Householder reflectors to e_j = e_1, ... , e_m\n                for(j = 0; j < irows; j++) { // for each e_j\n                    qj = j * qstride;\n                    unitary[qj + j] = 1; // setup e_j = [ 0 0 0 ... 1 ... 0 0 0 ]^T\n                    for(k = icolumns - 1; k >= 0; k--) { // compute Q e_j = ( Q_1 ... Q_n ) e_j\n                        fk = k * irows;\n                        dot = -2 * this._dot(unitary, reflect, qj + k, fk + k, irows - k);\n                        for(i = irows - 1; i >= k; i--)\n                            unitary[qj + i] += dot * reflect[fk + i];\n                    }\n                }\n\n                /*\n                // fill the lower part of R with zeros\n                let rk;\n                for(rk = k = 0; k < icolumns; k++, rk += rstride) {\n                    for(i = icolumns; i < irows; i++)\n                        triangular[rk + i] = 0;\n                }\n                */\n\n                break;\n            }\n\n            //\n            // Reduced QR decomposition\n            // Q: m x n, R: n x n\n            //\n            case 'reduced-qr': {\n                const qstride = stride;\n                const unitary = output.subarray(0, qstride * icolumns).fill(0);\n                let fk, qj, dot;\n\n                // validate output size\n                if(orows != irows || ocolumns != icolumns + icolumns)\n                    throw new Error(`Can't compute the reduced QR decomposition of a ${irows} x ${icolumns} matrix: expected an output matrix of size ${irows} x ${icolumns + icolumns}, found ${orows} x ${ocolumns}`);\n\n                // apply Householder reflectors to e_j = e_1, ... , e_n (n <= m)\n                for(j = 0; j < icolumns; j++) { // for each e_j\n                    qj = j * qstride;\n                    unitary[qj + j] = 1; // setup e_j = [ 0 0 0 ... 1 ... 0 0 0 ]^T\n                    for(k = icolumns - 1; k >= 0; k--) { // compute Q e_j = ( Q_1 ... Q_n ) e_j\n                        fk = k * irows;\n                        dot = -2 * this._dot(unitary, reflect, qj + k, fk + k, irows - k);\n                        for(i = irows - 1; i >= k; i--)\n                            unitary[qj + i] += dot * reflect[fk + i];\n                    }\n                }\n\n                break;\n            }\n\n            //\n            // Compute y = Q'x for an input vector x (Q' means Q^T)\n            // x: m x 1, y: m x 1\n            //\n            case 'Q\\'x': {\n                const ystride = stride;\n                const y = output.subarray(0, ystride);\n                const m = irows, n = icolumns;\n                let fk, dot;\n\n                // validate input / output size\n                if(m != xrows || 1 != xcolumns)\n                    throw new Error(`QR decomposition: the input vector is expected to be ${m} x 1, but is ${xrows} x ${xcolumns}`);\n                else if(m != orows || 1 + n != ocolumns)\n                    throw new Error(`QR decomposition: the output matrix is expected to be ${m} x ${1+n}, but is ${orows} x ${ocolumns}`);\n\n                // initialize output vector\n                for(i = 0; i < m; i++)\n                    y[i] = x[i];\n\n                // apply Householder reflectors to input x\n                for(k = 0; k < n; k++) { // compute Q'x = ( Q_n ... Q_1 ) x\n                    fk = k * irows; // get the k-th reflector\n                    dot = -2 * this._dot(y, reflect, k, fk + k, m - k);\n                    for(i = k; i < m; i++)\n                        y[i] += dot * reflect[fk + i];\n                }\n\n                break;\n            }\n\n            //\n            // Compute Qx for an input vector x\n            // x: m x 1, y: m x 1\n            //\n            case 'Qx': {\n                const ystride = stride;\n                const y = output.subarray(0, ystride);\n                const m = irows, n = icolumns;\n                let fk, dot;\n\n                // validate input / output size\n                if(m != xrows || 1 != xcolumns)\n                    throw new Error(`QR decomposition: the input vector is expected to be ${m} x 1, but is ${xrows} x ${xcolumns}`);\n                else if(m != orows || 1 + n != ocolumns)\n                    throw new Error(`QR decomposition: the output matrix is expected to be ${m} x ${1+n}, but is ${orows} x ${ocolumns}`);\n\n                // initialize output vector\n                for(i = 0; i < m; i++)\n                    y[i] = x[i];\n\n                // apply Householder reflectors to input x\n                for(k = n - 1; k >= 0; k--) { // compute Qx = ( Q_1 ... Q_n ) x\n                    fk = k * irows; // get the k-th reflector\n                    dot = -2 * this._dot(y, reflect, k, fk + k, m - k);\n                    for(i = k; i < m; i++)\n                        y[i] += dot * reflect[fk + i];\n                }\n\n                break;\n            }\n\n            //\n            // Compute y = Q'x for an input vector x using reduced QR\n            // x: m x 1, y: m x 1\n            //\n            case 'reduced-Q\\'x': {\n                const m = irows, n = icolumns;\n                const y = output.subarray(0, n); // output[n..m-1] is unused\n                const e = tmp.subarray(0, m); // e_j is m x 1, for all j = 0, 1 .. n-1\n                let fk, dot;\n\n                // validate input / output size\n                if(m != xrows || 1 != xcolumns)\n                    throw new Error(`QR decomposition: the input vector is expected to be ${m} x 1, but is ${xrows} x ${xcolumns}`);\n                else if(m != orows || 1 + n != ocolumns)\n                    throw new Error(`QR decomposition: the output matrix is expected to be ${m} x ${1+n}, but is ${orows} x ${ocolumns}`);\n\n                // apply Householder reflectors\n                for(j = 0; j < n; j++) { // for each e_j\n                    // setup e_j = [ 0 0 0 ... 1 ... 0 0 0 ]^T\n                    e.fill(0);\n                    e[j] = 1;\n\n                    // compute Q e_j = ( Q_1 ... Q_n ) e_j\n                    for(k = n - 1; k >= 0; k--) {\n                        fk = k * irows;\n                        dot = -2 * this._dot(e, reflect, k, fk + k, m - k);\n                        for(i = m - 1; i >= k; i--)\n                            e[i] += dot * reflect[fk + i];\n                    }\n\n                    // compute y_j = dot(x, Q e_j)\n                    y[j] = this._dot(x, e, 0, 0, m);\n                }\n\n                break;\n            }\n\n            default:\n                throw new Error(`QR decomposition: unknown mode \"${mode}\"`);\n        }\n    }\n\n\n    /**\n     * Back-substitution: solve Rx = b for x,\n     * where R is n x n upper triangular\n     * @param {object} header\n     * @param {TypedArray} output\n     * @param {TypedArray[]} inputs a single input of the form [ b | R ]\n     */\n    static backsub(header, output, inputs)\n    {\n        const { rows, columns } = header;\n        const [ input ] = inputs;\n        const [ irows ] = header.rowsOfInputs;\n        const [ icolumns ] = header.columnsOfInputs;\n        const [ istride ] = header.strideOfInputs;\n\n        if(icolumns !== irows + 1)\n            throw new Error(`Invalid input for backsub: expected ${irows} x ${irows+1} or ${icolumns-1} x ${icolumns} matrix, but found ${irows} x ${icolumns} matrix`);\n        else if(rows !== irows || columns !== 1)\n            throw new Error(`Invalid output for backsub: expected ${irows} x 1 matrix, but found ${rows} x ${columns} matrix`);\n\n        // Back-substitution\n        const n = irows;\n        const x = output; // x is n x 1 vector (output)\n        const b = input.subarray(0, istride); // b is n x 1 vector\n        const r = input.subarray(istride); // R is n x n upper triangular\n        let i, j, rjj, rj = (n-1) * istride; // column index\n\n        x[n-1] = b[n-1] / r[rj + (n-1)];\n        for(j = n-2; j >= 0; j--) {\n            x[j] = b[j];\n            for(i = j+1; i < n; i++)\n                x[j] -= x[i] * r[istride * i + j];\n\n            rj -= istride;\n            rjj = r[rj + j];\n            /*\n            if(rjj === 0)\n                throw new Error(`Invalid input for backsub: ${j+1}-th diagonal element of the upper triangular matrix is zero`);\n            */\n            x[j] /= rjj;\n        }\n    }\n\n    /**\n     * Find best-fit solution of Ax = b with least-squares method\n     * A is m x n, b is m x 1, output x is n x 1\n     * (m equations, n unknowns, m >= n)\n     * @param {object} header\n     * @param {TypedArray} output\n     * @param {TypedArray[]} inputs [ A, b [,tmp] ] where optional tmp is m x (n+1)\n     */\n    static lssolve(header, output, inputs)\n    {\n        const { stride } = header;\n        const [ m, n ] = [ header.rowsOfInputs[0], header.columnsOfInputs[0] ];\n        const tmp = inputs[2] || this._createTypedArray(m * (n+1), header.type);\n        const lsHeader = Object.assign({ }, header);\n\n        // find [ Q'b | R ] with reduced QR of A\n        lsHeader.rows = m;\n        lsHeader.columns = n+1;\n        lsHeader.stride = m;\n        lsHeader.custom = { mode: 'reduced-Q\\'x' };\n        lsHeader.byteOffset = 0;\n        lsHeader.length = tmp.length;\n        this.qr(lsHeader, tmp, [ inputs[0], inputs[1] ]);\n\n        // extract the top n x (n+1) submatrix of [ Q'b | R ]\n        // (the bottom rows are zeros)\n        const triangsys = this._submatrices(lsHeader, output, [ tmp ], stride, [ m ],\n            [ 0, n-1, 0, 0 ],\n            [\n                [ 0, n-1, 0, n ]\n            ]\n        );\n\n        // solve R x = Q'b for x\n        this.backsub(triangsys[0], triangsys[1], triangsys[2]);\n    }\n\n\n\n\n    // ========================================================\n    // Internal low-level utilities\n    // ========================================================\n\n    /**\n     * Create a new TypedArray with the specified length\n     * @param {number} length \n     * @param {number} type \n     * @returns {TypedArray}\n     */\n    static _createTypedArray(length, type)\n    {\n        const dataType = this.DataType[type];\n        return new dataType(length);\n    }\n\n    /**\n     * The 2-norm of a column vector\n     * @param {TypedArray} column \n     * @param {number} [begin] first index\n     * @param {number} [length]\n     * @returns {number}\n     */\n    static _norm2(column, begin = 0, length = column.length)\n    {\n        let norm = 0, end = begin + length, i;\n\n        // Since we store data in column-major format,\n        // we don't need to use stride\n        for(i = begin; i < end; i++)\n            norm += column[i] * column[i];\n\n        return Math.sqrt(norm);\n    }\n\n    /**\n     * The dot product of two column vectors\n     * @param {TypedArray} u \n     * @param {TypedArray} v \n     * @param {number} [uBegin] first index \n     * @param {number} [vBegin] first index \n     * @param {number} [length] \n     */\n    static _dot(u, v, uBegin = 0, vBegin = 0, length = u.length)\n    {\n        let dot = 0, i;\n\n        for(i = 0; i < length; i++)\n            dot += u[uBegin + i] * v[vBegin + i];\n\n        return dot;\n    }\n\n    /**\n     * Given matrices A and B, scalars alpha and beta,\n     * compute the sum (alpha A + beta B). The output\n     * array is allowed to be one of the input arrays\n     * @param {object} header\n     * @param {TypedArray} output\n     * @param {TypedArray[]} inputs\n     * @param {number} alpha\n     * @param {number} beta\n     */\n    static _addInPlace(header, output, inputs, alpha, beta)\n    {\n        const { rows, columns, stride } = header;\n        const [ strideA, strideB ] = header.strideOfInputs;\n        const [ a, b ] = inputs;\n\n        let i, j, oj, aj, bj;\n        for(aj = bj = oj = j = 0; j < columns; j++, oj += stride, aj += strideA, bj += strideB) {\n            for(i = 0; i < rows; i++)\n                output[oj + i] = alpha * a[aj + i] + beta * b[bj + i];\n        }\n    }\n\n    /**\n     * Create submatrices / block-views with shared memory\n     * Low-level stuff. Make sure you pass valid indices...\n     * @param {object} header will be modified!\n     * @param {TypedArray} output contains data\n     * @param {TypedArray[]} inputs contains data\n     * @param {number} stride of output\n     * @param {number[]} strideOfInputs\n     * @param {number[4]} outputIndices [firstRow, lastRow, firstColumn, lastColumn] inclusive\n     * @param {Array<number[4]>} inputsIndices for each input matrix\n     * @returns {Array} a triple [ header, output, inputs ]\n     */\n    static _submatrices(header, output, inputs, stride, strideOfInputs, outputIndices, inputsIndices)\n    {\n        let i, inputIndices;\n\n        header.rows = outputIndices[1] - outputIndices[0] + 1;\n        header.columns = outputIndices[3] - outputIndices[2] + 1;\n        header.stride = stride;\n        output = output.subarray(\n            outputIndices[2] * stride + outputIndices[0],\n            outputIndices[3] * stride + outputIndices[1] + 1\n        );\n        header.length = output.length;\n        header.byteOffset = output.byteOffset;\n\n        for(i = inputs.length - 1; i >= 0; i--) {\n            inputIndices = inputsIndices[i];\n\n            header.rowsOfInputs[i] = inputIndices[1] - inputIndices[0] + 1;\n            header.columnsOfInputs[i] = inputIndices[3] - inputIndices[2] + 1;\n            header.strideOfInputs[i] = strideOfInputs[i];\n            inputs[i] = inputs[i].subarray(\n                inputIndices[2] * strideOfInputs[i] + inputIndices[0],\n                inputIndices[3] * strideOfInputs[i] + inputIndices[1] + 1\n            );\n            header.lengthOfInputs[i] = inputs[i].length;\n            header.byteOffsetOfInputs[i] = inputs[i].byteOffset;\n        }\n\n        return [ header, output, inputs ];\n    }\n\n\n\n\n\n\n    // ========================================================\n    // Enums & utilities\n    // ========================================================\n\n    /**\n     * Types of matrices\n     * @returns {object} enum\n     */\n    static get MatrixType()\n    {\n        return this._MatrixType || (this._MatrixType = Object.freeze({\n            F32: 0x0,         // 32-bit float, 1 channel\n            //F32C1: 0x0 | 0x0, // 32-bit float, 1 channel\n            //F32C2: 0x0 | 0x1, // 32-bit float, 2 channels\n            //F32C3: 0x0 | 0x2, // 32-bit float, 3 channels\n            //F32C4: 0x0 | 0x3, // 32-bit float, 4 channels\n            F64: 0x4,         // 64-bit float, 1 channel\n            //F64C1: 0x4 | 0x0, // 64-bit float, 1 channel\n            //F64C2: 0x4 | 0x1, // 64-bit float, 2 channels\n            //F64C3: 0x4 | 0x2, // 64-bit float, 3 channels\n            //F64C4: 0x4 | 0x3, // 64-bit float, 4 channels\n            I32: 0x8,         // 32-bit signed integer, 1 channel\n            //I32C1: 0x8 | 0x0, // 32-bit signed integer, 1 channel\n            //I32C2: 0x8 | 0x1, // 32-bit signed integer, 2 channels\n            //I32C3: 0x8 | 0x2, // 32-bit signed integer, 3 channels\n            //I32C4: 0x8 | 0x3, // 32-bit signed integer, 4 channels\n            U8: 0xC,          // 8-bit unsigned integer, 1 channel\n            //U8C1: 0xC | 0x0,  // 8-bit unsigned integer, 1 channel\n            //U8C2: 0xC | 0x1,  // 8-bit unsigned integer, 2 channels\n            //U8C3: 0xC | 0x2,  // 8-bit unsigned integer, 3 channels\n            //U8C4: 0xC | 0x3,  // 8-bit unsigned integer, 4 channels\n        }));\n    }\n\n    /**\n     * A mapping between MatrixTypes and TypedArrays\n     * @returns {object}\n     */\n    static get DataType()\n    {\n        return this._DataType || (this._DataType = Object.freeze({\n            [this.MatrixType.F32]: Float32Array,\n            //[this.MatrixType.F32C1]: Float32Array,\n            //[this.MatrixType.F32C2]: Float32Array,\n            //[this.MatrixType.F32C3]: Float32Array,\n            //[this.MatrixType.F32C4]: Float32Array,\n            [this.MatrixType.F64]: Float64Array,\n            [this.MatrixType.I32]: Int32Array,\n            [this.MatrixType.U8]:  Uint8Array,\n        }));\n    }\n\n    /**\n     * A mapping between MatrixTypes and descriptive strings\n     * @returns {object}\n     */\n    static get DataTypeName()\n    {\n        return this._DataTypeName || (this._DataTypeName = Object.freeze({\n            [this.MatrixType.F32]: 'float32',\n            [this.MatrixType.F64]: 'float64',\n            [this.MatrixType.I32]: 'int32',\n            [this.MatrixType.U8]:  'uint8',\n        }));\n    }\n\n    /**\n     * Each operation is mapped to a unique number, called an operation code\n     * @returns {object}\n     */\n    static get Opcode()\n    {\n        return this._Opcode || (this._Opcode = Object.freeze({\n            NOP: 0x0,        // no-operation\n            //EYE: 0x1,      // identity matrix\n            FILL: 0x2,       // fill the matrix with a constant\n            COPY: 0x3,       // copy matrix\n            TRANSPOSE: 0x4,  // transpose matrix\n            ADD: 0x5,        // add two matrices\n            SUBTRACT: 0x6,   // subtract two matrices\n            MULTIPLY: 0x7,   // multiply two matrices\n            SCALE: 0x8,      // multiply by scalar\n            COMPMULT: 0x9,   // component-wise product\n            MULTIPLYLT: 0xA, // multiply tranposing the left operand\n            MULTIPLYRT: 0xB, // multiply tranposing the right operand\n            MULTIPLYVEC: 0xC,// multiply by a column-vector\n            OUTER: 0xD,      // outer product\n            QR: 0x10,        // QR decomposition (Householder)\n            BACKSUB: 0x11,   // back-substitution\n            LSSOLVE: 0x12,   // least-squares (Ax = b)\n        }));\n    }\n\n    /**\n     * A mapping between operation codes and functions\n     * @returns {object}\n     */\n    static get Opcode2fun()\n    {\n        return this._Opcode2fun || (this._Opcode2fun = Object.freeze({\n            [this.Opcode.NOP]: this.nop,\n            [this.Opcode.FILL]: this.fill,\n            [this.Opcode.COPY]: this.copy,\n            [this.Opcode.TRANSPOSE]: this.transpose,\n            [this.Opcode.ADD]: this.add,\n            [this.Opcode.SUBTRACT]: this.subtract,\n            [this.Opcode.MULTIPLY]: this.multiply,\n            [this.Opcode.SCALE]: this.scale,\n            [this.Opcode.COMPMULT]: this.compmult,\n            [this.Opcode.MULTIPLYLT]: this.multiplylt,\n            [this.Opcode.MULTIPLYRT]: this.multiplyrt,\n            [this.Opcode.MULTIPLYVEC]: this.multiplyvec,\n            [this.Opcode.OUTER]: this.outer,\n            [this.Opcode.QR]: this.qr,\n            [this.Opcode.BACKSUB]: this.backsub,\n            [this.Opcode.LSSOLVE]: this.lssolve,\n        }));\n    }\n}\n\nmodule.exports = { MatrixMath };","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * matrix-operations-queue.js\n * Run matrix operations in a FIFO fashion\n */\n\nimport { SpeedyMatrix } from './matrix';\nimport { MatrixOperation } from './matrix-operations';\nimport { SpeedyPromise } from '../../utils/speedy-promise';\n\n/**\n * Used to run matrix operations in a FIFO fashion\n */\nexport class MatrixOperationsQueue\n{\n    /**\n     * Class constructor\n     */\n    constructor()\n    {\n        this._queue = [];\n        this._busy = false;\n    }\n\n    /**\n     * Get Singleton\n     * @returns {MatrixOperationsQueue}\n     */\n    static get instance()\n    {\n        return this._instance || (this._instance = new MatrixOperationsQueue());\n    }\n\n    /**\n     * Enqueue matrix operation\n     * @param {MatrixOperation} matrixOperation \n     * @param {SpeedyMatrix} outputMatrix\n     * @returns {SpeedyPromise<void>} a promise that resolves as soon as the operation is complete\n     */\n    enqueue(matrixOperation, outputMatrix)\n    {\n        // enqueue operation\n        return new SpeedyPromise(resolve => {\n            this._queue.push([ matrixOperation, outputMatrix, resolve ]);\n            if(!this._busy) {\n                this._busy = true;\n                this._resolveAll();\n            }\n        });\n    }\n\n    /**\n     * Run all enqueued matrix operations\n     */\n    _resolveAll()\n    {\n        // finished the processing?\n        if(this._queue.length == 0) {\n            this._busy = false;\n            return;\n        }\n\n        // obtain the next operation\n        const [ matrixOperation, outputMatrix, resolve ] = this._queue.shift();\n\n        // lock matrices\n        outputMatrix.lock();\n        matrixOperation.inputMatrices.forEach(inputMatrix => inputMatrix.lock());\n\n        // run the next operation\n        matrixOperation.run(outputMatrix).then(() => {\n            // unlock matrices\n            matrixOperation.inputMatrices.forEach(inputMatrix => inputMatrix.unlock());\n            outputMatrix.unlock();\n\n            // this operation is done\n            resolve();\n            this._resolveAll();\n        }).turbocharge();\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * matrix-operations.js\n * Matrix operations\n */\n\nimport { IllegalArgumentError, IllegalOperationError, NotSupportedError } from '../../utils/errors';\nimport { SpeedyPromise } from '../../utils/speedy-promise';\nimport { SpeedyMatrix } from './matrix';\nimport { MatrixMath } from './matrix-math';\nimport { MatrixWorker } from './matrix-worker';\n\n// Constants\nconst Opcode = MatrixMath.Opcode;\nconst Opcode2fun = MatrixMath.Opcode2fun;\nconst SMALL_WORKLOAD = 40; // what is \"small\"? further experimental testing is desirable\n                           // a binary operation for 3x3 matrices, e.g. C = A + B, has \"small\" workload\n\n// Worker\nconst matrixWorker = MatrixWorker.instance;\n\n\n/**\n * Abstract matrix operation\n * @abstract\n */\nexport class MatrixOperation\n{\n    /**\n     * (protected) Class constructor\n     * @param {number} opcode MatrixMath.OperationCode enum\n     * @param {number} requiredRows required number of rows of the output matrix\n     * @param {number} requiredColumns required number of columns of the output matrix\n     * @param {number} requiredType required type of the output matrix\n     * @param {SpeedyMatrix[]} [inputMatrices] input matrices, if any\n     * @param {object|null} [userData] custom user-data, serializable\n     */\n    constructor(opcode, requiredRows, requiredColumns, requiredType, inputMatrices = [], userData = null)\n    {\n        // handy vars\n        const n = inputMatrices.length;\n        const hasInput = n > 0;\n\n        // obtain the shape of the input matrices\n        const rowsOfInputs = hasInput && inputMatrices.map(matrix => matrix.rows);\n        const columnsOfInputs = hasInput && inputMatrices.map(matrix => matrix.columns);\n        const strideOfInputs = hasInput && new Array(n);\n        const byteOffsetOfInputs = hasInput && new Array(n);\n        const lengthOfInputs = hasInput && new Array(n);\n\n        // the header stores metadata related to the operation\n        // (all fields are serializable)\n        this._header = {\n            opcode: opcode, // operation code\n            type: requiredType, // type of the output matrix (the same as the input matrices)\n\n            rows: requiredRows, // number of rows of the output matrix\n            columns: requiredColumns, // number of columns of the output matrix\n            stride: null, // stride of the output matrix (unknown)\n            byteOffset: null, // used to recover the data view (unknown)\n            length: null, // used to recover the data view (unknown)\n\n            rowsOfInputs: rowsOfInputs, // number of rows of the input matrices\n            columnsOfInputs: columnsOfInputs, // number of columns of the input matrices\n            strideOfInputs: strideOfInputs, // strides of the input matrices\n            byteOffsetOfInputs: byteOffsetOfInputs, // used to recover the data view (to be determined later - buffer may be locked)\n            lengthOfInputs: lengthOfInputs, // used to recover the data view (to be determined layer - buffer may be locked)\n\n            custom: userData // custom user-data\n        };\n\n        // save the input matrices\n        this._inputMatrices = inputMatrices;\n        this._inputBuffers = new Array(n); // temporary storage\n\n        // compute a measure of (a fraction of) the workload of this operation\n        this._workloadOfInputs = inputMatrices.reduce((w, m) => w + this._workload(m), 0);\n\n        // is it a valid opcode?\n        const fun = Opcode2fun[opcode];\n        if(fun === undefined)\n            throw new IllegalArgumentError(`Invalid matrix operation (0x${opcode.toString(16)})`);\n        this._fun = fun.bind(MatrixMath);\n    }\n\n    /**\n     * The required number of rows of the output matrix\n     * @returns {number}\n     */\n    get rows()\n    {\n        return this._header.rows;\n    }\n\n    /**\n     * The required number of columns of the output matrix\n     * @returns {number}\n     */\n    get columns()\n    {\n        return this._header.columns;\n    }\n\n    /**\n     * The required type of the output matrix\n     * @returns {number}\n     */\n    get type()\n    {\n        return this._header.type;\n    }\n\n    /**\n     * Replace input matrices\n     * @param {SpeedyMatrix[]} inputMatrices \n     * @returns {MatrixOperation} this\n     */\n    update(inputMatrices)\n    {\n        if(this._inputMatrices.length !== inputMatrices.length)\n            throw new IllegalOperationError();\n\n        for(let i = inputMatrices.length - 1; i >= 0; i--) {\n            const inputMatrix = inputMatrices[i];\n            const prevInputMatrix = this._inputMatrices[i];\n\n            // i-th matrix didn't change\n            if(inputMatrix === prevInputMatrix)\n                continue;\n\n            // can't change shape\n            if(inputMatrix.rows !== prevInputMatrix.rows || inputMatrix.columns !== prevInputMatrix.columns || inputMatrix.type !== prevInputMatrix.type)\n                throw new IllegalOperationError(`Can't change the input matrix shape / type`);\n\n            // update input matrix\n            this._inputMatrices[i] = inputMatrix;\n        }\n\n        return this;\n    }\n\n\n\n\n\n\n    // =======================================================\n\n\n\n\n\n\n    /**\n     * Run the matrix operation in a Web Worker\n     * The internal buffers of the input & the output matrices are assumed to be locked\n     * @param {SpeedyMatrix} outputMatrix\n     * @returns {SpeedyPromise<void>} a promise that resolves to outbuf as soon as the operation is completed\n     */\n    run(outputMatrix)\n    {\n        const { rows, columns, stride, type } = outputMatrix;\n        const header = this._header;\n\n        // run locally if the matrices are \"small enough\"\n        const workload = this._workloadOfInputs + this._workload(outputMatrix);\n        if(workload <= SMALL_WORKLOAD) {\n            // there's an overhead for passing data\n            // back and forth to the Web Worker, and\n            // we don't want to pay it if we're\n            // dealing with \"small\" matrices\n            return this._runLocally(outputMatrix);\n        }\n\n        // do we have a compatible output matrix?\n        this._assertCompatibility(rows, columns, type);\n\n        // save output metadata\n        const output = outputMatrix.buffer.data;\n        header.stride = stride;\n        header.byteOffset = output.byteOffset;\n        header.length = output.length;\n\n        // save input metadata & buffers\n        const inputMatrices = this._inputMatrices;\n        const inputBuffers = this._inputBuffers; // new Array(inputMatrices.length);\n        for(let i = inputMatrices.length - 1; i >= 0; i--) {\n            const inputMatrix = inputMatrices[i];\n            const input = inputMatrix.buffer.data;\n\n            header.strideOfInputs[i] = inputMatrix.stride;\n            header.byteOffsetOfInputs[i] = input.byteOffset;\n            header.lengthOfInputs[i] = input.length;\n\n            inputBuffers[i] = input.buffer;\n        }\n\n        // run matrix operation\n        return matrixWorker.run(\n            header,\n            output.buffer,\n            inputBuffers\n        ).then(([newOutputBuffer, newInputBuffers]) => {\n            // update the internal buffers with the new data\n            outputMatrix.buffer.replace(newOutputBuffer);\n            for(let i = inputMatrices.length - 1; i >= 0; i--)\n                inputMatrices[i].buffer.replace(newInputBuffers[i]);\n        });\n    }\n\n    /**\n     * Run matrix operation in the same thread\n     * @param {SpeedyMatrix} outputMatrix\n     * @returns {SpeedyPromise<void>} a promise that resolves to outbuf as soon as the operation is completed\n     */\n    _runLocally(outputMatrix)\n    {\n        // obtain properties of the output matrix\n        const { rows, columns, stride, type } = outputMatrix;\n        const header = this._header;\n\n        // do we have a compatible output matrix?\n        this._assertCompatibility(rows, columns, type);\n\n        // save output metadata\n        const output = outputMatrix.buffer.data;\n        header.stride = stride;\n        header.byteOffset = output.byteOffset;\n        header.length = output.length;\n\n        // save input metadata & buffers\n        const inputMatrices = this._inputMatrices;\n        const inputs = this._inputBuffers; // new Array(inputMatrices.length);\n        for(let i = inputMatrices.length - 1; i >= 0; i--) {\n            const inputMatrix = inputMatrices[i];\n            const input = inputMatrix.buffer.data;\n\n            header.strideOfInputs[i] = inputMatrix.stride;\n            header.byteOffsetOfInputs[i] = input.byteOffset;\n            header.lengthOfInputs[i] = input.length;\n\n            inputs[i] = input;\n        }\n\n        // run matrix operation\n        this._fun(header, output, inputs);\n        return SpeedyPromise.resolve();\n    }\n\n    /**\n     * The matrices that belong to the operation,\n     * with the exception of the output matrix\n     * @returns {SpeedyMatrix[]}\n     */\n    get inputMatrices()\n    {\n        return this._inputMatrices;\n    }\n\n    /**\n     * Assert matrix size and type\n     * @param {number} requiredRows \n     * @param {number} requiredColumns \n     * @param {number} [requiredType] \n     */\n    _assertCompatibility(requiredRows, requiredColumns, requiredType = this._header.type)\n    {\n        const { rows, columns, type } = this._header;\n\n        if(requiredRows === rows && requiredColumns === columns && requiredType === type)\n            return;\n        else if(requiredType !== type)\n            throw new IllegalOperationError(`Incompatible matrix type (0x${requiredType.toString(16)} vs 0x${type.toString(16)})`);\n        else\n            throw new IllegalOperationError(`Invalid matrix size: ${rows} x ${columns} (expected ${requiredRows} x ${requiredColumns})`);\n    }\n\n    /**\n     * Compute a measure of the workload of an operation involving this matrix\n     * @param {SpeedyMatrix} matrix\n     * @returns {number}\n     */\n    _workload(matrix)\n    {\n        return matrix.rows * matrix.columns;\n    }\n}\n\n/**\n * No-operation\n */\nexport class MatrixOperationNop extends MatrixOperation\n{\n    /**\n     * Class constructor\n     * @param {number} requiredRows required number of rows of the output matrix\n     * @param {number} requiredColumns required number of columns of the output matrix\n     * @param {number} requiredType required type of the output matrix\n     */\n    constructor(requiredRows, requiredColumns, requiredType)\n    {\n        super(Opcode.NOP, requiredRows, requiredColumns, requiredType);\n    }\n}\n\n/**\n * Fill matrix with a number\n */\nexport class MatrixOperationFill extends MatrixOperation\n{\n    /**\n     * Class constructor\n     * @param {number} requiredRows required number of rows of the output matrix\n     * @param {number} requiredColumns required number of columns of the output matrix\n     * @param {number} requiredType required type of the output matrix\n     * @param {number} value the value we'll use to fill the matrix\n     */\n    constructor(requiredRows, requiredColumns, requiredType, value)\n    {\n        super(Opcode.FILL, requiredRows, requiredColumns, requiredType, [], { value: +value });\n    }\n}\n\n/**\n * Copy matrix\n */\nexport class MatrixOperationCopy extends MatrixOperation\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrix} matrix \n     */\n    constructor(matrix)\n    {\n        super(Opcode.COPY, matrix.rows, matrix.columns, matrix.type, [ matrix ]);\n    }\n}\n\n/**\n * Transpose Matrix\n */\nexport class MatrixOperationTranspose extends MatrixOperation\n{\n    /**\n     * Class constructor\n     * @param {SpeedyMatrix} matrix the matrix that we'll transpose\n     */\n    constructor(matrix)\n    {\n        super(Opcode.TRANSPOSE, matrix.columns, matrix.rows, matrix.type, [ matrix ]);\n    }\n}\n\n/**\n * Add two matrices\n * e.g., A + B\n */\nexport class MatrixOperationAdd extends MatrixOperation\n{\n    /**\n     * Class constructor\n     * @param {SpeedyMatrix} matrixA\n     * @param {SpeedyMatrix} matrixB\n     */\n    constructor(matrixA, matrixB)\n    {\n        super(Opcode.ADD, matrixA.rows, matrixA.columns, matrixA.type, [ matrixA, matrixB ]);\n    }\n}\n\n/**\n * Subtract two matrices\n * e.g., A - B\n */\nexport class MatrixOperationSubtract extends MatrixOperation\n{\n    /**\n     * Class constructor\n     * @param {SpeedyMatrix} matrixA\n     * @param {SpeedyMatrix} matrixB\n     */\n    constructor(matrixA, matrixB)\n    {\n        super(Opcode.SUBTRACT, matrixA.rows, matrixA.columns, matrixA.type, [ matrixA, matrixB ]);\n    }\n}\n\n/**\n * Multiply two matrices\n * e.g., A * B\n */\nexport class MatrixOperationMultiply extends MatrixOperation\n{\n    /**\n     * Class constructor\n     * @param {SpeedyMatrix} matrixA left matrix\n     * @param {SpeedyMatrix} matrixB right matrix\n     */\n    constructor(matrixA, matrixB)\n    {\n        super(Opcode.MULTIPLY, matrixA.rows, matrixB.columns, matrixA.type, [ matrixA, matrixB ]);\n    }\n}\n\n/**\n * Multiply by a scalar\n * e.g., alpha * A\n */\nexport class MatrixOperationScale extends MatrixOperation\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrix} matrix\n     * @param {number} scalar\n     */\n    constructor(matrix, scalar)\n    {\n        super(Opcode.SCALE, matrix.rows, matrix.columns, matrix.type, [ matrix ], { scalar: +scalar });\n    }\n}\n\n/**\n * Component-wise multiplication\n */\nexport class MatrixOperationCompMult extends MatrixOperation\n{\n    /**\n     * Class constructor\n     * @param {SpeedyMatrix} matrixA\n     * @param {SpeedyMatrix} matrixB\n     */\n    constructor(matrixA, matrixB)\n    {\n        super(Opcode.COMPMULT, matrixA.rows, matrixA.columns, matrixA.type, [ matrixA, matrixB ]);\n    }\n}\n\n/**\n * Multiply two matrices, transposing the left operand\n * e.g., A^T * B\n */\nexport class MatrixOperationMultiplyLT extends MatrixOperation\n{\n    /**\n     * Class constructor\n     * @param {SpeedyMatrix} matrixA left matrix\n     * @param {SpeedyMatrix} matrixB right matrix\n     */\n    constructor(matrixA, matrixB)\n    {\n        super(Opcode.MULTIPLYLT, matrixA.columns, matrixB.columns, matrixA.type, [ matrixA, matrixB ]);\n    }\n}\n\n/**\n * Multiply two matrices, transposing the right operand\n * e.g., A * B^T\n */\nexport class MatrixOperationMultiplyRT extends MatrixOperation\n{\n    /**\n     * Class constructor\n     * @param {SpeedyMatrix} matrixA left matrix\n     * @param {SpeedyMatrix} matrixB right matrix\n     */\n    constructor(matrixA, matrixB)\n    {\n        super(Opcode.MULTIPLYRT, matrixA.rows, matrixB.rows, matrixA.type, [ matrixA, matrixB ]);\n    }\n}\n\n/**\n * Multiply by a column vector,\n * e.g., y = A x\n */\nexport class MatrixOperationMultiplyVec extends MatrixOperation\n{\n    /**\n     * Class constructor\n     * @param {SpeedyMatrix} matrixA left matrix\n     * @param {SpeedyMatrix} vectorX column-vector\n     */\n    constructor(matrixA, vectorX)\n    {\n        super(Opcode.MULTIPLYVEC, matrixA.rows, 1, matrixA.type, [ matrixA, vectorX ]);\n    }\n}\n\n/**\n * QR decomposition\n */\nexport class MatrixOperationQR extends MatrixOperation\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrix} matrix\n     * @param {string} mode 'full' | 'reduced'\n     */\n    constructor(matrix, mode)\n    {\n        const m = ({ 'full': 'full-qr', 'reduced': 'reduced-qr' })[mode];\n        if(m === undefined)\n            throw new IllegalArgumentError(`QR decomposition: unknown mode \"${mode}\"`)\n\n        const columns = m == 'full-qr' ? matrix.columns + matrix.rows : 2 * matrix.columns;\n        super(Opcode.QR, matrix.rows, columns, matrix.type, [ matrix ], { mode: m });\n    }\n}\n\n/**\n * Internal QR solver (Ax = b) produces\n * the matrix [(Q^T)b | R] using reduced QR(*)\n * A is m x n (m >= n), b is m x 1,\n * (Q^T)b is m x 1 and R is m x n\n *\n * (*) The last (m-n) rows of the output matrix\n * will be filled with zeros. Those rows are\n * required by the calculation. You may extract\n * the first n rows\n */\nexport class MatrixOperationQRSolve extends MatrixOperation\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrix} matrixA\n     * @param {SpeedyMatrix} vectorB\n     */\n    constructor(matrixA, vectorB)\n    {\n        super(Opcode.QR, matrixA.rows, matrixA.columns + 1, matrixA.type, [ matrixA, vectorB ], { mode: 'reduced-Q\\'x' });\n    }\n}\n\n/**\n * Given an input matrix of the form [b | R]\n * where b is n x 1 and R is an n x n upper\n * triangular matrix, solve Rx = b for x\n */\nexport class MatrixOperationBackSubstitution extends MatrixOperation\n{\n    /**\n     * Constructor\n     * @param {SpeedyMatrix} input\n     */\n    constructor(input)\n    {\n        super(Opcode.BACKSUB, input.rows, 1, input.type, [ input ]);\n    }\n}\n\n/**\n * Find best-fit solution x of Ax = b with least-squares method\n * A is m x n, b is m x 1, output x is n x 1\n * (m equations, n unknowns, m >= n)\n */\nexport class MatrixOperationLSSolve extends MatrixOperation\n{\n    constructor(matrixA, vectorB)\n    {\n        super(Opcode.LSSOLVE, matrixA.columns, 1, matrixA.type, [ matrixA, vectorB ]);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * matrix-worker.js\n * Web Worker bridge\n */\n\nimport { MatrixMath } from './matrix-math';\nimport { IllegalOperationError } from '../../utils/errors';\nimport { SpeedyPromise } from '../../utils/speedy-promise';\n\n// Constants\nconst MAX_MESSAGE_ID = (1 << 30) - 1; // use the form 2^n - 1\nconst NOP = MatrixMath.Opcode.NOP;\n\n/**\n * A bridge between the main thread and a Web Worker\n * that performs matrix computations\n */\nexport class MatrixWorker\n{\n    /**\n     * Get Singleton\n     * @returns {MatrixWorker}\n     */\n    static get instance()\n    {\n        return this._instance || (this._instance = new MatrixWorker());\n    }\n\n    /**\n     * Class constructor\n     */\n    constructor()\n    {\n        this._msgId = 0;\n        this._callbackTable = new Map();\n        this._worker = this._createWorker();\n    }\n\n    /**\n     * Run computation in a Web Worker\n     * @param {object} header serializable\n     * @param {ArrayBuffer} outputBuffer data of the output matrix\n     * @param {ArrayBuffer[]} inputBuffers data of the input matrices\n     * @returns {SpeedyPromise<Array>} resolves as soon as the computation is complete\n     */\n    run(header, outputBuffer, inputBuffers)\n    {\n        if(header.opcode === NOP) // save some time\n            return SpeedyPromise.resolve([outputBuffer, inputBuffers]);\n\n        const id = (this._msgId = (this._msgId + 1) & MAX_MESSAGE_ID);\n        const transferables = [ outputBuffer, ...inputBuffers ].filter(\n            (x, i, arr) => arr.indexOf(x) === i // remove duplicates\n        );\n        const msg = { id, header, outputBuffer, inputBuffers, transferables };\n\n        return new SpeedyPromise(resolve => {\n            this._callbackTable.set(id, (outputBuffer, inputBuffers) => {\n                resolve([outputBuffer, inputBuffers]);\n                this._callbackTable.delete(id);\n            });\n            this._worker.postMessage(msg, transferables);\n        }, true);\n    }\n\n    /**\n     * Create a Web Worker capable of performing Matrix computations\n     * @returns {Worker}\n     */\n    _createWorker()\n    {\n        // setup the code\n        const js = 'self.MatrixMath = ' + MatrixMath.toString() + '\\n' +\n                   'self.onmessage = ' + onmessage.toString();\n        const blob = new Blob([ js ], { type: 'application/javascript' });\n\n        // setup the Worker\n        const worker = new Worker(URL.createObjectURL(blob));\n        worker.onmessage = ev => {\n            const msg = ev.data;\n            const done = this._callbackTable.get(msg.id);\n            done(msg.outputBuffer, msg.inputBuffers);\n        };\n        worker.onerror = ev => {\n            throw new IllegalOperationError(`Worker error: ${ev.message}`);\n        };\n\n        // done!\n        return worker;\n    }\n}\n\n/**\n * This function runs in the Web Worker\n * @param {MessageEvent} ev\n */\nfunction onmessage(ev)\n{\n    const { id, header, outputBuffer, inputBuffers, transferables } = ev.data;\n\n    // wrap the incoming buffers with the appropriate TypedArrays\n    const dataType = self.MatrixMath.DataType[header.type];\n    const output = new dataType(outputBuffer, header.byteOffset, header.length);\n    const inputs = inputBuffers.map((inputBuffer, i) =>\n        new dataType(inputBuffer, header.byteOffsetOfInputs[i], header.lengthOfInputs[i])\n    );\n\n    // perform the computation\n    const compute = self.MatrixMath.Opcode2fun[header.opcode];\n    //console.log('mensagem do worker', output, inputs);\n    compute.call(self.MatrixMath, header, output, inputs);\n\n    // send the result of the computation back to the main thread\n    const msg = { id, outputBuffer, inputBuffers };\n    self.postMessage(msg, transferables);\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * matrix.js\n * Matrix type\n */\n\nimport { IllegalArgumentError, IllegalOperationError, NotSupportedError } from '../../utils/errors';\nimport { MatrixBuffer } from './matrix-buffer';\nimport { MatrixMath } from './matrix-math';\nimport { MatrixOperationsQueue } from './matrix-operations-queue';\nimport { MatrixOperationNop } from './matrix-operations';\nimport { SpeedyPromise } from '../../utils/speedy-promise';\n\n\n\n// Constants\nconst MatrixType = MatrixMath.MatrixType;\nconst DataType = MatrixMath.DataType;\nconst DataTypeName = MatrixMath.DataTypeName;\nconst matrixOperationsQueue = MatrixOperationsQueue.instance;\n\n\n\n/**\n * Matrix class\n */\nexport class SpeedyMatrix\n{\n    /**\n     * Class constructor\n     * @param {number} rows number of rows\n     * @param {number} [columns] number of columns (defaults to the number of rows)\n     * @param {number[]} [values] initial values in column-major format\n     * @param {number} [type] F64, F32, etc.\n     * @param {number} [stride] custom stride\n     * @param {MatrixBuffer} [buffer] custom buffer\n     */\n    constructor(rows, columns = rows, values = null, type = MatrixType.F32, stride = rows, buffer = null)\n    {\n        const dataType = DataType[type];\n        const numChannels = 1 + (type & 3);\n\n        if(rows <= 0 || columns <= 0)\n            throw new IllegalArgumentError(`Invalid dimensions`);\n        else if(stride < rows)\n            throw new IllegalArgumentError(`Invalid stride`);\n        else if(dataType == undefined)\n            throw new IllegalArgumentError(`Invalid data type`);\n        else if(Array.isArray(values) && values.length != rows * columns * numChannels)\n            throw new IllegalArgumentError(`Incorrect number of matrix elements (expected ${rows * columns * numChannels}, found ${values.length})`);\n\n        this._rows = rows | 0;\n        this._columns = columns | 0;\n        this._type = type | 0;\n        this._channels = numChannels;\n        this._stride = stride | 0;\n        this._buffer = buffer || new MatrixBuffer(this._stride * this._columns * this._channels, values, this._type);\n        this._nop = null;\n    }\n\n\n\n    // ====================================\n    // MATRIX PROPERTIES\n    // ====================================\n\n    /**\n     * Number of rows of the matrix\n     * @returns {number}\n     */\n    get rows()\n    {\n        return this._rows;\n    }\n\n    /**\n     * Number of columns of the matrix\n     * @returns {number}\n     */\n    get columns()\n    {\n        return this._columns;\n    }\n\n    /**\n     * Number of channels\n     * @returns {number} defaults to 1\n     */\n    get channels()\n    {\n        return this._channels;\n    }\n\n    /**\n     * The number of entries, in the MatrixBuffer,\n     * between the beginning of two columns\n     * @returns {number}\n     */\n    get stride()\n    {\n        return this._stride;\n    }\n\n    /**\n     * Data type\n     * @returns {number}\n     */\n    get type()\n    {\n        return this._type;\n    }\n\n    /**\n     * Data type (string)\n     * @returns {string}\n     */\n    get dtype()\n    {\n        return DataTypeName[this._type];\n    }\n\n\n\n    // ====================================\n    // READ MATRIX\n    // ====================================\n\n    /**\n     * Read entries of the matrix. Note that this method is asynchronous.\n     * It will read the data as soon as all relevant calculations have been\n     * completed. Make sure you await.\n     *\n     * If the entries parameter is left unspecified, the entire matrix will\n     * be read and its contents will be returned as a flattened array in\n     * column-major format.\n     *\n     * @param {number[]} [entries] a flattened array of (row,col) indices, indexed by zero\n     * @param {number[]} [result] pre-allocated array where we'll store the results\n     * @returns {SpeedyPromise<number[]>} a promise that resolves to the requested entries\n     */\n    read(entries = undefined, result = undefined)\n    {\n        const rows = this._rows, cols = this._columns;\n        const stride = this._stride;\n\n        // read the entire array\n        if(entries === undefined)\n        {\n            return this.sync().then(() => this._buffer.ready().turbocharge()).then(buffer => {\n                const data = buffer.data;\n                const n = rows * cols;\n\n                // resize result array\n                result = result || new Array(n);\n                if(result.length != n)\n                    result.length = n;\n\n                // write entries in column-major format\n                let i, j, k = 0;\n                for(j = 0; j < cols; j++) {\n                    for(i = 0; i < rows; i++)\n                        result[k++] = data[j * stride + i];\n                }\n\n                // done!\n                return result;\n            }).turbocharge();\n        }\n\n        // read specific entries\n        if(entries.length % 2 > 0)\n            throw new IllegalArgumentError(`Can't read matrix entries: missing index`);\n\n        return this.sync().then(() => this._buffer.ready().turbocharge()).then(buffer => {\n            const data = buffer.data;\n            const n = entries.length >> 1;\n\n            // resize result array\n            result = result || new Array(n);\n            if(result.length != n)\n                result.length = n;\n\n            // read entries\n            let row, col;\n            for(let i = 0; i < n; i++) {\n                row = entries[i << 1] | 0;\n                col = entries[1 + (i << 1)] | 0;\n                result[i] = ((row >= 0 && row < rows && col >= 0 && col < cols) &&\n                    data[col * stride + row]\n                ) || undefined;\n            }\n\n            // done!\n            return result;\n        }).turbocharge();\n    }\n\n    /**\n     * Read a single entry of the matrix. This is provided for your convenience.\n     * It's much faster to use read() if you need to read multiple entries\n     * @param {number} row the row you want to read, indexed by zero\n     * @param {number} column the column you want to read, indexed by zero\n     * @returns {SpeedyPromise<number>} a promise that resolves to the requested entry\n     */\n    at(row, column)\n    {\n        return this.read([ row, column ]).then(nums => nums[0]).turbocharge();\n    }\n\n    /**\n     * Print the matrix. Useful for debugging\n     * @param {Function} [printFunction] prints a string\n     * @param {number} [decimals] format numbers to a number of decimals\n     * @returns {SpeedyPromise<void>} a promise that resolves as soon as the matrix is printed\n     */\n    print(printFunction = console.log, decimals = undefined)\n    {\n        return this.read().then(data => {\n            const rows = this._rows, columns = this._columns;\n            const row = new Array(rows);\n            let i, j;\n\n            for(i = 0; i < rows; i++) {\n                row[i] = new Array(columns);\n                for(j = 0; j < columns; j++)\n                    row[i][j] = data[j * rows + i];\n            }\n\n            const fix = decimals !== undefined ? x => x.toFixed(decimals) : x => x;\n            const fmt = row.map(r => '    ' + r.map(fix).join(', ')).join(',\\n');\n            const str = `SpeedyMatrix(rows=${rows}, cols=${columns}, dtype=\"${this.dtype}\", data=[\\n${fmt}\\n])`;\n            printFunction(str);\n        });\n    }\n\n\n\n\n\n    // ====================================\n    // ACCESS BY BLOCK\n    // ====================================\n\n    /**\n     * Create a submatrix using the range [firstRow:lastRow, firstColumn:lastColumn].\n     * It will have size (lastRow - firstRow + 1) x (lastColumn - firstColumn + 1).\n     * The internal buffer of the matrix will be shared with the submatrix,\n     * so if you modify one, you'll modify the other.\n     * @param {number} firstRow indexed by 0\n     * @param {number} lastRow indexed by 0\n     * @param {number} firstColumn indexed by 0\n     * @param {number} lastColumn indexed by 0\n     * @returns {SpeedyPromise<SpeedyMatrix>}\n     */\n    block(firstRow, lastRow, firstColumn, lastColumn)\n    {\n        const rows = this._rows, columns = this._columns;\n\n        // validate range\n        if(lastRow < firstRow || lastColumn < firstColumn)\n            throw new IllegalArgumentError(`Can't create empty submatrix - invalid range [${firstRow}:${lastRow}, ${firstColumn}:${lastColumn}]`);\n        else if(firstRow < 0 || lastRow >= rows || firstColumn < 0 || lastColumn >= columns)\n            throw new IllegalArgumentError(`Can't create submatrix - invalid range [${firstRow}:${lastRow}, ${firstColumn}:${lastColumn}] of ${rows} x ${columns} matrix`);\n\n        // compute the dimensions of the new submatrix\n        const subRows = lastRow - firstRow + 1;\n        const subColumns = lastColumn - firstColumn + 1;\n\n        // obtain the relevant portion of the data\n        const stride = this._stride;\n        const begin = firstColumn * stride + firstRow;\n        const length = (lastColumn - firstColumn) * stride + subRows;\n\n        // create submatrix\n        return this._buffer.createSharedBuffer(begin, length).then(sharedBuffer =>\n            new SpeedyMatrix(subRows, subColumns, undefined, this._type, stride, sharedBuffer)\n        ).turbocharge();\n    }\n\n    /**\n     * Creates a column-vector featuring the elements of the main diagonal\n     * of the matrix. The internal buffers of the column-vector and of the\n     * matrix are shared, so if you change the data in one, you'll change\n     * the data in the other.\n     * @returns {SpeedyPromise<SpeedyMatrix>}\n     */\n    diagonal()\n    {\n        const rows = this._rows, stride = this._stride;\n        const diagonalLength = Math.min(rows, this._columns);\n        const bufferLength = (diagonalLength - 1) * stride + rows;\n\n        return this._buffer.createSharedBuffer(0, bufferLength).then(sharedBuffer =>\n            new SpeedyMatrix(1, diagonalLength, undefined, this._type, stride + 1, sharedBuffer)\n        ).turbocharge();\n    }\n\n\n\n\n\n    // ====================================\n    // MATRIX UTILITIES\n    // ====================================\n\n    /**\n     * Convert to string\n     * @returns {string}\n     */\n    toString()\n    {\n        return `SpeedyMatrix(rows=${this.rows}, cols=${this.columns}, dtype=\"${this.dtype}\")`;\n    }\n\n    /**\n     * Locks the internal buffer of this matrix,\n     * so it can't be read from nor written to\n     */\n    lock()\n    {\n        this._buffer.lock();\n    }\n\n    /**\n     * Unlocks the internal buffer of this matrix and\n     * resolves all pending read/write operations\n     */\n    unlock()\n    {\n        this._buffer.unlock();\n    }\n\n    /**\n     * The internal buffer of this matrix\n     * @returns {MatrixBuffer}\n     */\n    get buffer()\n    {\n        return this._buffer;\n    }\n\n    /**\n     * Returns a promise that resolves as soon as all\n     * operations submitted UP TO NOW have finished\n     * @returns {SpeedyPromise<void>}\n     */\n    sync()\n    {\n        this._nop = this._nop || (this._nop = new MatrixOperationNop(this._rows, this._columns, this._type));\n        return matrixOperationsQueue.enqueue(this._nop, this);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-vector.js\n * Vectors\n */\n\nimport { IllegalArgumentError } from '../../utils/errors';\n\n/**\n * 2D vector of floating-point numbers\n */\nexport class SpeedyVector2\n{\n    /**\n     * Create a 2D vector\n     * @param {number} x\n     * @param {number} y\n     */\n    constructor(x, y)\n    {\n        this._data = new Float32Array([x, y]);\n    }\n\n\n    //\n    // ===== PROPERTIES =====\n    //\n\n    /**\n     * Get x-coordinate\n     * @returns {number}\n     */\n    get x()\n    {\n        return this._data[0];\n    }\n\n    /**\n     * Set x-coordinate\n     * @param {number} value\n     */\n    set x(value)\n    {\n        this._data[0] = value;\n    }\n\n    /**\n     * Get y-coordinate\n     * @returns {number}\n     */\n    get y()\n    {\n        return this._data[1];\n    }\n\n    /**\n     * Set y-coordinate\n     * @param {number} value\n     */\n    set y(value)\n    {\n        this._data[1] = value;\n    }\n\n\n\n\n    //\n    // ===== METHODS =====\n    //\n\n    /**\n     * Convert to string\n     * @returns {string}\n     */\n    toString()\n    {\n        return `SpeedyVector2(${this._data[0]}, ${this._data[1]})`;\n    }\n\n    /**\n     * Get vector coordinate\n     * @param {number} row 0 or 1\n     * @returns {number}\n     */\n    at(row)\n    {\n        return this._data[row];\n    }\n\n    /**\n     * Dot product between this vector and another vector\n     * @param {SpeedyVector2} v another vector\n     * @returns {number}\n     */\n    dot(v)\n    {\n        return this._data[0] * v._data[0] + this._data[1] * v._data[1];\n    }\n\n    /**\n     * The distance between this vector and another vector\n     * @param {SpeedyVector2} v another vector\n     * @returns {number}\n     */\n    distanceTo(v)\n    {\n        const dx = this._data[0] - v._data[0];\n        const dy = this._data[1] - v._data[1];\n\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    /**\n     * Euclidean norm\n     * @returns {number}\n     */\n    length()\n    {\n        return Math.sqrt(this._data[0] * this._data[0] + this._data[1] * this._data[1]);\n    }\n\n    /**\n     * Normalizes this vector\n     * @returns {SpeedyVector2} this vector, normalized\n     */\n    normalize()\n    {\n        const l = this.length();\n\n        if(l == 0.0) {\n            this._data.fill(0.0);\n            return this;\n        }\n\n        this._data[0] /= l;\n        this._data[1] /= l;\n\n        return this;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * pipeline-operations.js\n * A pipeline operation is an element of a SpeedyPipeline\n */\n\nimport { ColorFormat } from '../utils/types';\nimport { Utils } from '../utils/utils';\nimport { GLUtils } from '../gpu/gl-utils';\nimport { NotSupportedError, IllegalArgumentError } from '../utils/errors';\n\nexport const PipelineOperation = { };\n\n/**\n * Abstract basic operation\n */\n/* abstract */ class SpeedyPipelineOperation\n{\n    /**\n     * Class constructor\n     */\n    constructor()\n    {\n        // lambda: load options object\n        this._loadOptions = () => ({});\n    }\n\n    /**\n     * Runs the pipeline operation\n     * @param {SpeedyTexture} texture\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyMedia} [media]\n     * @returns {SpeedyTexture}\n     */\n    run(texture, gpu, media)\n    {\n        return texture;\n    }\n\n    /**\n     * Perform any necessary cleanup\n     */\n    release()\n    {\n    }\n\n    /**\n     * Save an options object\n     * @param {object|()=>object} options user-passed parameter\n     * @param {object} [defaultOptions]\n     * @returns {()=>object}\n     */\n    _saveOptions(options, defaultOptions = {})\n    {\n        if(typeof options == 'object') {\n            // evaluate when instantiating the pipeline\n            const storedOptions = Object.assign(defaultOptions, options);\n            this._loadOptions = () => storedOptions;\n        }\n        else if(typeof options == 'function') {\n            // evaluate when running the pipeline\n            this._loadOptions = () => Object.assign(defaultOptions, options());\n        }\n        else\n            throw new IllegalArgumentError(`Expected an options object | function`);\n    }\n}\n\n\n// =====================================================\n//               COLOR CONVERSIONS\n// =====================================================\n\n/**\n * Convert to greyscale\n */\nPipelineOperation.ConvertToGreyscale = class extends SpeedyPipelineOperation\n{\n    run(texture, gpu, media)\n    {\n        if(media._colorFormat == ColorFormat.RGB)\n            texture = gpu.programs.colors.rgb2grey(texture);\n        else if(media._colorFormat != ColorFormat.Greyscale)\n            throw new NotSupportedError(`Can't convert image to greyscale: unknown color format`);\n\n        media._colorFormat = ColorFormat.Greyscale;\n        return texture;\n    }\n}\n\n\n\n// =====================================================\n//               IMAGE FILTERS\n// =====================================================\n\n/**\n * Blur image\n */\nPipelineOperation.Blur = class extends SpeedyPipelineOperation\n{\n    /**\n     * Blur operation\n     * @param {object|()=>object} [options]\n     */\n    constructor(options = {})\n    {\n        super();\n\n        // save options\n        this._saveOptions(options, {\n            filter: 'gaussian', // \"gassuian\" | \"box\"\n            size: 5             // 3 | 5 | 7\n        });\n    }\n\n    run(texture, gpu, media)\n    {\n        const { filter, size } = this._loadOptions();\n\n        // validate options\n        if(filter != 'gaussian' && filter != 'box')\n            throw new IllegalArgumentError(`Invalid filter: \"${filter}\"`);\n        else if(size != 3 && size != 5 && size != 7)\n            throw new IllegalArgumentError(`Invalid kernel size: ${size}`);\n        \n        // run filter\n        let fname = filter == 'gaussian' ? 'gauss' : 'box';\n        return gpu.programs.filters[fname + size](texture);\n    }\n}\n\n/**\n * Image convolution\n */\nPipelineOperation.Convolve = class extends SpeedyPipelineOperation\n{\n    /**\n     * Perform a convolution\n     * Must provide a SQUARE kernel with size: 3x3, 5x5 or 7x7\n     * @param {Array<number>} kernel convolution kernel\n     * @param {number} [divisor] divide all kernel entries by this number\n     */\n    constructor(kernel, divisor = 1.0)\n    {\n        let kern = new Float32Array(kernel).map(x => x / divisor);\n        const len = kern.length;\n        const size = Math.sqrt(len) | 0;\n        const method = ({\n            3: ['createKernel3x3', 'texConv2D3'],\n            5: ['createKernel5x5', 'texConv2D5'],\n            7: ['createKernel7x7', 'texConv2D7'],\n        })[size] || null;\n        super();\n\n        // validate kernel\n        if(len == 1)\n            throw new IllegalArgumentError(`Cannot convolve with a kernel containing a single element`);\n        else if(size * size != len || !method)\n            throw new IllegalArgumentError(`Cannot convolve with a non-square kernel of ${len} elements`);\n\n        // normalize kernel entries to [0,1]\n        const min = Math.min(...kern), max = Math.max(...kern);\n        const offset = min;\n        const scale = Math.abs(max - min) > 1e-5 ? max - min : 1;\n        kern = kern.map(x => (x - offset) / scale);\n\n        // store the normalized kernel\n        this._method = method;\n        this._scale = scale;\n        this._offset = offset;\n        this._kernel = kern;\n        this._kernelSize = size;\n        this._texKernel = null;\n        this._gl = null;\n    }\n\n    run(texture, gpu, media)\n    {\n        // lost context?\n        if(gpu.gl.isContextLost()) {\n            this._texKernel = null;\n            this._gl = null;\n            // convolve with a null texKernel anyway,\n            // SpeedyProgram handles lost contexts\n        }\n\n        // instantiate the texture kernel\n        else if(this._texKernel == null || (this._gl !== gpu.gl && this._gl !== null)) {\n            // warn about performance\n            if(this._gl !== gpu.gl && this._gl !== null && !this._gl.isContextLost()) {\n                const warn = 'Performance warning: need to recreate the texture kernel. ' +\n                             'Consider duplicating the pipeline when using convolutions ' +\n                             'for different media objects.';\n                Utils.warning(warn);\n\n                // release old texture\n                this._texKernel.release();\n            }\n\n            this._texKernel = gpu.programs.filters[this._method[0]](this._kernel);\n            this._gl = gpu.gl;\n        }\n\n        // convolve\n        return gpu.programs.filters[this._method[1]](\n            texture,\n            this._texKernel,\n            this._scale,\n            this._offset\n        );\n    }\n\n    release()\n    {\n        if(this._texKernel != null) {\n            this._texKernel.release();\n            this._texKernel = this._gl = null;\n        }\n\n        super.release();\n    }\n}\n\n/**\n * Normalize image\n */\nPipelineOperation.Normalize = class extends SpeedyPipelineOperation\n{\n    /**\n     * Normalize operation\n     * @param {object|()=>object} [options]\n     */\n    constructor(options = {})\n    {\n        super();\n\n        // save options\n        this._saveOptions(options, {\n            min: undefined, // min. desired pixel intensity, a value in [0,255]\n            max: undefined  // max. desired pixel intensity, a value in [0,255]\n        });\n    }\n\n    run(texture, gpu, media)\n    {\n        const { min, max } = this._loadOptions();\n\n        if(media._colorFormat == ColorFormat.RGB)\n            return gpu.programs.enhancements.normalizeColoredImage(texture, min, max);\n        else if(media._colorFormat == ColorFormat.Greyscale)\n            return gpu.programs.enhancements.normalizeGreyscaleImage(texture, min, max);\n        else\n            throw new NotSupportedError('Invalid color format');\n    }\n}\n\n/**\n * Nightvision: \"see in the dark\"\n */\nPipelineOperation.Nightvision = class extends SpeedyPipelineOperation\n{\n    /**\n     * Class constructor\n     * @param {object|()=>object} [options]\n     */\n    constructor(options = {})\n    {\n        super();\n\n        // save options\n        this._saveOptions(options, {\n            gain: undefined,    // controls the contrast\n            offset: undefined,  // controls the brightness\n            decay: undefined,   // gain decay from the center\n            quality: undefined, // \"high\" | \"medium\" | \"low\"\n        });\n    }\n\n    run(texture, gpu, media)\n    {\n        const { gain, offset, decay, quality } = this._loadOptions();\n\n        if(media._colorFormat == ColorFormat.RGB)\n            return gpu.programs.enhancements.nightvision(texture, gain, offset, decay, quality, false);\n        else if(media._colorFormat == ColorFormat.Greyscale)\n            return gpu.programs.enhancements.nightvision(texture, gain, offset, decay, quality, true);\n        else\n            throw new NotSupportedError('Invalid color format');\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-descriptor.js\n * Feature descriptor\n */\n\nimport { AbstractMethodError } from '../utils/errors';\n\n/**\n * Abstract feature descriptor\n */\nclass SpeedyDescriptor\n{\n    /**\n     * Abstract constructor\n     */\n    constructor()\n    {\n        /*if(this.constructor === SpeedyDescriptor)\n            throw new AbstractMethodError();*/\n    }\n    \n    /**\n     * Descriptor data\n     * @returns {null}\n     */\n    get data()\n    {\n        return null;\n    }\n\n    /**\n     * Descriptor size, in bytes\n     * @returns {number}\n     */\n    get size()\n    {\n        return 0;\n    }\n}\n\n/**\n * Null feature descriptor\n */\nexport class NullDescriptor extends SpeedyDescriptor\n{\n    /**\n     * Class constructor\n     */\n    constructor()\n    {\n        super();\n    }\n\n    /**\n     * Descriptor data\n     * @returns {null}\n     */\n    get data()\n    {\n        return null;\n    }\n}\n\n/**\n * Binary feature descriptor\n */\nexport class BinaryDescriptor extends SpeedyDescriptor\n{\n    /**\n     * Class constructor\n     * @param {Uint8Array} bytes descriptor data\n     */\n    constructor(bytes)\n    {\n        super();\n        this._data = bytes;\n    }\n\n    /**\n     * Descriptor data\n     * @returns {Uint8Array}\n     */\n    get data()\n    {\n        return this._data;\n    }\n\n    /**\n     * Descriptor size, in bytes\n     * @returns {number}\n     */\n    get size()\n    {\n        return this._data.length;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-feature-decorator.js\n * A wrapper around a FeatureAlgorithmDecorator\n */\n\nimport { FeatureAlgorithmDecorator } from './keypoints/feature-algorithm-decorator';\nimport { FeatureAlgorithm } from './keypoints/feature-algorithm';\nimport { Utils } from '../utils/utils';\n\n/**\n * A wrapper around a FeatureAlgorithmDecorator\n */\nexport class SpeedyFeatureDecorator\n{\n    /**\n     * Constructor\n     * @param {Function} decorator a FeatureAlgorithmDecorator\n     */\n    constructor(decorator)\n    {\n        this._decorator = decorator;\n    }\n\n    /**\n     * Decorate an algorithm\n     * @param {FeatureAlgorithm} algorithm \n     * @returns {FeatureAlgorithmDecorator}\n     */\n    decorate(algorithm)\n    {\n        const decorator = this._decorator;\n        const decoratedAlgorithm = new decorator(algorithm);\n\n        Utils.assert(decoratedAlgorithm instanceof FeatureAlgorithmDecorator);\n\n        return decoratedAlgorithm;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-feature-descriptor-factory.js\n * Factory of feature descriptors\n */\n\nimport { SpeedyNamespace } from './speedy-namespace';\nimport { SpeedyFeatureDecorator } from './speedy-feature-decorator';\nimport { ORBFeatures } from './keypoints/descriptors/orb';\n\n/**\n * A collection of methods for decorating Feature Detectors &\n * Feature Trackers with Descriptors\n */\nexport class SpeedyFeatureDescriptorFactory extends SpeedyNamespace\n{\n    /**\n     * ORB descriptor\n     * @returns {SpeedyFeatureDecorator}\n     */\n    static ORB()\n    {\n        return new SpeedyFeatureDecorator(ORBFeatures);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-feature-detector-factory.js\n * A collection of methods for instantiating SpeedyFeatureDetectors\n */\n\nimport { SpeedyNamespace } from './speedy-namespace';\nimport {\n    FASTFeatureDetector,\n    MultiscaleFASTFeatureDetector,\n    HarrisFeatureDetector,\n    MultiscaleHarrisFeatureDetector,\n} from './speedy-feature-detector';\nimport { ORBFeatures } from './keypoints/descriptors/orb';\nimport { SpeedyFeatureDescriptorFactory } from './speedy-feature-descriptor-factory';\n\n/**\n * A collection of methods for instantiating SpeedyFeatureDetectors\n */\nexport class SpeedyFeatureDetectorFactory extends SpeedyNamespace\n{\n    /**\n     * FAST feature detector\n     * @param {number} [n] Variant of the algorithm. Must be 9, 7 or 5.\n     * @returns {FASTFeatureDetector}\n     */\n    static FAST(n = 9)\n    {\n        return new FASTFeatureDetector(n);\n    }\n\n    /**\n     * FAST feature detector in scale-space\n     * @param {number} [n] Variant of the algorithm. Must be 9.\n     * @returns {MultiscaleFASTFeatureDetector}\n     */\n    static MultiscaleFAST(n = 9)\n    {\n        return new MultiscaleFASTFeatureDetector(n);\n    }\n\n    /**\n     * Harris corner detector\n     * @returns {HarrisFeatureDetector}\n     */\n    static Harris()\n    {\n        return new HarrisFeatureDetector();\n    }\n\n    /**\n     * Harris corner detector in scale-space\n     * @returns {MultiscaleHarrisFeatureDetector}\n     */\n    static MultiscaleHarris()\n    {\n        return new MultiscaleHarrisFeatureDetector();\n    }\n\n    /**\n     * ORB feature detector & descriptor\n     * @returns {MultiscaleHarrisFeatureDetector} decorated with ORB\n     */\n    static ORB()\n    {\n        const orb = SpeedyFeatureDescriptorFactory.ORB();\n        return (new MultiscaleHarrisFeatureDetector()).link(orb);\n    }\n\n    /**\n     * BRISK feature detector & descriptor\n     * @returns {BRISKFeatureDetector}\n     */\n    static BRISK()\n    {\n        return new BRISKFeatureDetector();\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-feature-detector.js\n * Feature detection API\n */\n\nimport { IllegalArgumentError, IllegalOperationError, AbstractMethodError, NotSupportedError } from '../utils/errors';\nimport { Utils } from '../utils/utils';\nimport { ColorFormat } from '../utils/types'\nimport { SpeedyFlags } from './speedy-flags';\nimport { SpeedyGPU } from '../gpu/speedy-gpu';\nimport { SpeedyTexture } from '../gpu/speedy-texture';\nimport { SpeedyMedia } from './speedy-media';\nimport { AutomaticSensitivity } from './keypoints/automatic-sensitivity';\nimport { FeatureDetectionAlgorithm } from './keypoints/feature-detection-algorithm';\nimport { FeatureDescriptionAlgorithm } from './keypoints/feature-description-algorithm';\nimport { FASTFeatures, MultiscaleFASTFeatures } from './keypoints/detectors/fast';\nimport { HarrisFeatures, MultiscaleHarrisFeatures } from './keypoints/detectors/harris';\nimport { SpeedyFeatureDecorator } from './speedy-feature-decorator';\n\n\n\n/**\n * Basic feature detection & description API\n * This is an easy-to-use wrapper around the internal\n * FeatureDetectionAlgorithm class, which deals with encoded\n * textures and is not suitable for end-user usage\n * @abstract\n */\nexport class SpeedyFeatureDetector\n{\n    /**\n     * Class constructor\n     * @param {FeatureDetectionAlgorithm} algorithm\n     */\n    constructor(algorithm)\n    {\n        // Set the algorithm\n        this._algorithm = algorithm;\n        this._decoratedAlgorithm = this._algorithm;\n\n        // sensitivity: the higher the value, the more feature points you get\n        this._sensitivity = 0; // a value in [0,1]\n\n        // cap the number of keypoints?\n        this._max = undefined;\n        this._capKeypoints = this._capKeypoints.bind(this);\n\n        // enhance the image in different ways before detecting the features\n        this._enhancements = {\n            denoise: true,\n            illumination: false,\n            nightvision: null,\n        };\n\n        // misc\n        this._automaticSensitivity = null; // automatic sensitivity (lazy instantiation)\n    }\n\n    /**\n     * Decorate the underlying algorithm\n     * @param {SpeedyFeatureDecorator} decorator\n     * @returns {SpeedyFeatureDetector} this instance, now decorated\n     */\n    link(decorator)\n    {\n        this._decoratedAlgorithm = decorator.decorate(this._decoratedAlgorithm);\n        return this;\n    }\n\n    /**\n     * Detect & describe feature points\n     * @param {SpeedyMedia} media\n     * @param {number} [flags]\n     * @returns {Promise<SpeedyFeature[]>}\n     */\n    detect(media, flags = 0)\n    {\n        const gpu = media._gpu;\n        const isStaticMedia = (media.options.usage == 'static');\n        const descriptorSize = this._decoratedAlgorithm.descriptorSize;\n        const extraSize = this._decoratedAlgorithm.extraSize;\n\n        // check if the media has been released\n        if(media.isReleased())\n            throw new IllegalOperationError(`Can't detect features: the SpeedyMedia has been released`);\n\n        // Reset downloader capacity?\n        if(flags & SpeedyFlags.FEATURE_DETECTOR_RESET_CAPACITY) {\n            // Speedy performs optimizations behind the scenes,\n            // specially when detecting features in videos.\n            // This flag will undo these optimizations. Use it\n            // when you expect a sudden increase in the number\n            // of keypoints (between two consecutive frames).\n            this._decoratedAlgorithm.resetDownloader(gpu);\n        }\n\n        // Allocate encoder space for static media\n        if(isStaticMedia) {\n            const INITIAL_KEYPOINT_GUESS = 1024 * 3;\n            gpu.programs.encoders.reserveSpace(INITIAL_KEYPOINT_GUESS, descriptorSize, extraSize);\n        }\n\n        // Upload & preprocess media\n        const texture = gpu.upload(media.source);\n        const preprocessedTexture = this._preprocessTexture(\n            gpu,\n            texture,\n            this._enhancements.denoise == true,\n            media._colorFormat != ColorFormat.Greyscale\n        );\n\n        // Feature detection & description\n        this._algorithm.setEnhancements(\n            this._enhancements.nightvision || this._enhancements.illumination\n        );\n        const encodedKeypoints = this._decoratedAlgorithm.run(gpu, preprocessedTexture);\n\n        // Download keypoints from the GPU\n        return this._algorithm.download(\n            gpu,\n            encodedKeypoints,\n            !isStaticMedia\n        ).then(this._capKeypoints);\n    }\n\n    /**\n     * Get the current detector sensitivity\n     * @returns {number} a value in [0,1]\n     */\n    get sensitivity()\n    {\n        return this._sensitivity;\n    }\n\n    /**\n     * Set the sensitivity of the feature detector\n     * The higher the sensitivity, the more features you get\n     * @param {number} sensitivity a value in [0,1]\n     */\n    set sensitivity(sensitivity)\n    {\n        this._sensitivity = Math.max(0, Math.min(+sensitivity, 1));\n        this._onSensitivityChange(this._sensitivity);\n    }\n\n    /**\n     * The maximum number of keypoints that will be\n     * returned by the feature detector. If it's\n     * undefined, then there is no pre-defined limit\n     * @returns {number | undefined}\n     */\n    get max()\n    {\n        return this._max;\n    }\n\n    /**\n     * The maximum number of keypoints that will be\n     * returned by the feature detector. Set it to\n     * undefined to disable any limits\n     * @param {number | undefined} maxFeaturePoints\n     */\n    set max(maxFeaturePoints)\n    {\n        if(maxFeaturePoints !== undefined)\n            this._max = Math.max(0, maxFeaturePoints | 0);\n        else\n            this._max = undefined;\n    }\n\n    /**\n     * Specify different enhancements to applied\n     * to the image before detecting the features\n     * @param {object} enhancements\n     */\n    enhance(enhancements)\n    {\n        // validate parameter\n        if(typeof enhancements !== 'object')\n            throw new IllegalArgumentError('enhancements must be an object');\n\n        // merge enhancements object\n        this._enhancements = Object.assign(this._enhancements, enhancements);\n    }\n\n    /**\n     * Set automatic sensitivity\n     * @param {number|undefined} numberOfFeaturePoints if set to undefined, we'll disable automatic sensitivity\n     * @param {number} [tolerance] percentage\n     */\n    expect(numberOfFeaturePoints, tolerance = 0.10)\n    {\n        if(numberOfFeaturePoints !== undefined) {\n            // enable automatic sensitivity\n            if(this._automaticSensitivity == null) {\n                this._automaticSensitivity = new AutomaticSensitivity(this._algorithm._downloader);\n                this._automaticSensitivity.subscribe(value => this.sensitivity = value);\n            }\n            this._automaticSensitivity.expected = numberOfFeaturePoints;\n            this._automaticSensitivity.tolerance = tolerance;\n        }\n        else {\n            // disable automatic sensitivity\n            if(this._automaticSensitivity != null)\n                this._automaticSensitivity.disable();\n            this._automaticSensitivity = null;\n        }\n    }\n\n    /**\n     * Preprocess a texture for feature detection & description\n     * @param {SpeedyGPU} gpu\n     * @param {SpeedyTexture} inputTexture a RGB or greyscale image\n     * @param {boolean} [denoise] should we smooth the media a bit?\n     * @param {boolean} [convertToGreyscale] set to true if the texture is not greyscale\n     * @returns {SpeedyTexture} pre-processed greyscale image\n     */\n    _preprocessTexture(gpu, inputTexture, denoise = true, convertToGreyscale = true)\n    {\n        let texture = inputTexture;\n\n        if(denoise)\n            texture = gpu.programs.filters.gauss5(texture);\n\n        if(convertToGreyscale)\n            texture = gpu.programs.colors.rgb2grey(texture);\n\n        return texture;\n    }\n\n    /**\n     * Convert a normalized sensitivity into an\n     * algorithm-specific value such as a threshold\n     * \n     * Sensitivity is a generic parameter that can be\n     * mapped to different feature detectors. The\n     * higher the sensitivity, the more features\n     * you should get\n     *\n     * @param {number} sensitivity a value in [0,1]\n     */\n    _onSensitivityChange(sensitivity)\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Compare two keypoints for sorting (higher scores come first)\n     * @param {SpeedyFeature} a\n     * @param {SpeedyFeature} b\n     * @returns {number}\n     */\n    _compareKeypoints(a, b)\n    {\n        return (+(b.score)) - (+(a.score));\n    }\n\n    /**\n     * Cap the number of keypoints, so that only the ones with\n     * the highest scores will be returned to the user\n     * @param {SpeedyFeature[]} keypoints\n     * @returns {SpeedyFeature[]}\n     */\n    _capKeypoints(keypoints)\n    {\n        // nothing to do\n        if(this._max === undefined)\n            return keypoints;\n\n        // cap the number of keypoints\n        return keypoints.sort(this._compareKeypoints).slice(0, this._max);\n    }\n}\n\n\n\n\n/**\n * FAST feature detector\n */\nexport class FASTFeatureDetector extends SpeedyFeatureDetector\n{\n    /**\n     * Class constructor\n     * @param {number} [n] FAST variant: 9, 7 or 5\n     */\n    constructor(n = 9)\n    {\n        // Create algorithm\n        super(new FASTFeatures());\n\n        // Validate FAST variant\n        if(!(n === 9 || n === 7 || n === 5))\n            throw new NotSupportedError(`Can't create FAST feature detector with n = ${n}`);\n\n        // Set FAST variant\n        this._algorithm.n = n;\n    }\n\n    /**\n     * Get FAST variant\n     * @returns {number}\n     */\n    get n()\n    {\n        return this._algorithm.n;\n    }\n\n    /**\n     * Get FAST threshold\n     * @returns {number} a value in [0,255]\n     */\n    get threshold()\n    {\n        return this._algorithm.threshold;\n    }\n\n    /**\n     * Set FAST threshold\n     * @param {number} threshold an integer in [0,255]\n     */\n    set threshold(threshold)\n    {\n        this._algorithm.threshold = threshold;\n    }\n\n    /**\n     * Convert a normalized sensitivity to a FAST threshold\n     * @param {number} sensitivity \n     */\n    _onSensitivityChange(sensitivity)\n    {\n        this.threshold = Math.round(255.0 * (1.0 - Math.tanh(2.77 * sensitivity)));\n    }\n}\n\n\n\n/**\n * FAST feature detector in an image pyramid\n */\nexport class MultiscaleFASTFeatureDetector extends SpeedyFeatureDetector\n{\n    /**\n     * Class constructor\n     * @param {number} [n] Multiscale FAST variant. Must be 9\n     */\n    constructor(n = 9)\n    {\n        // setup algorithm\n        super(new MultiscaleFASTFeatures());\n\n        // Validate FAST variant\n        if(n !== 9)\n            throw new NotSupportedError(`Can't create Multiscale FAST feature detector with n = ${n}`);\n\n        // Set FAST variant\n        this._algorithm.n = n;\n    }\n\n    /**\n     * Get FAST variant\n     * @returns {number}\n     */\n    get n()\n    {\n        return this._algorithm.n;\n    }\n\n    /**\n     * Get FAST threshold\n     * @returns {number} a value in [0,255]\n     */\n    get threshold()\n    {\n        return this._algorithm.threshold;\n    }\n\n    /**\n     * Set FAST threshold\n     * @param {number} threshold an integer in [0,255]\n     */\n    set threshold(threshold)\n    {\n        this._algorithm.threshold = threshold;\n    }\n\n    /**\n     * Get the depth of the algorithm: how many pyramid layers will be scanned\n     * @returns {number}\n     */\n    get depth()\n    {\n        return this._algorithm.depth;\n    }\n\n    /**\n     * Set the depth of the algorithm: how many pyramid layers will be scanned\n     * @param {number} depth\n     */\n    set depth(depth)\n    {\n        this._algorithm.depth = depth;\n    }\n\n    /**\n     * Whether or not we're using an approximation of\n     * Harris corner responses for keypoint scores\n     * @returns {boolean}\n     */\n    get useHarrisScore()\n    {\n        return this._algorithm.useHarrisScore;\n    }\n\n    /**\n     * Should we use an approximation of Harris corner\n     * responses for keypoint scores?\n     * @param {boolean} useHarris\n     */\n    set useHarrisScore(useHarris)\n    {\n        this._algorithm.useHarrisScore = useHarris;\n    }\n\n    /**\n     * Convert a normalized sensitivity to a FAST threshold\n     * @param {number} sensitivity \n     */\n    _onSensitivityChange(sensitivity)\n    {\n        this.threshold = Math.round(255.0 * (1.0 - Math.tanh(2.77 * sensitivity)));\n    }\n}\n\n\n\n\n/**\n * Harris corner detector\n */\nexport class HarrisFeatureDetector extends SpeedyFeatureDetector\n{\n    /**\n     * Class constructor\n     */\n    constructor()\n    {\n        // setup the algorithm\n        super(new HarrisFeatures());\n    }\n\n    /**\n     * Get current quality level\n     * We will pick corners having score >= quality * max(score)\n     * @returns {number} a value in [0,1]\n     */\n    get quality()\n    {\n        return this._algorithm.quality;\n    }\n\n    /**\n     * Set quality level\n     * We will pick corners having score >= quality * max(score)\n     * @param {number} quality a value in [0,1]\n     */\n    set quality(quality)\n    {\n        this._algorithm.quality = Math.max(0, Math.min(quality, 1));\n    }\n\n    /**\n     * Convert a normalized sensitivity to a quality value\n     * @param {number} sensitivity \n     */\n    _onSensitivityChange(sensitivity)\n    {\n        this.quality = 1.0 - Math.tanh(2.3 * sensitivity);\n    }\n}\n\n\n\n/**\n * Harris corner detector in an image pyramid\n */\nexport class MultiscaleHarrisFeatureDetector extends SpeedyFeatureDetector\n{\n    /**\n     * Class constructor\n     */\n    constructor()\n    {\n        // setup algorithm\n        super(new MultiscaleHarrisFeatures());\n    }\n\n    /**\n     * Get the depth of the algorithm: how many pyramid layers will be scanned\n     * @returns {number}\n     */\n    get depth()\n    {\n        return this._algorithm.depth;\n    }\n\n    /**\n     * Set the depth of the algorithm: how many pyramid layers will be scanned\n     * @param {number} depth a number between 1 and PYRAMID_MAX_LEVELS, inclusive\n     */\n    set depth(depth)\n    {\n        this._algorithm.depth = depth;\n    }\n\n    /**\n     * Get current quality level\n     * We will pick corners having score >= quality * max(score)\n     * @returns {number} a value in [0,1]\n     */\n    get quality()\n    {\n        return this._algorithm.quality;\n    }\n\n    /**\n     * Set quality level\n     * We will pick corners having score >= quality * max(score)\n     * @param {number} quality a value in [0,1]\n     */\n    set quality(quality)\n    {\n        this._algorithm.quality = Math.max(0, Math.min(quality, 1));\n    }\n\n    /**\n     * Convert a normalized sensitivity to a quality value\n     * @param {number} sensitivity \n     */\n    _onSensitivityChange(sensitivity)\n    {\n        this.quality = 1.0 - Math.tanh(2.3 * sensitivity);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-feature-tracker-factory.js\n * A collection of methods for instantiating Feature Trackers\n */\n\nimport { SpeedyNamespace } from './speedy-namespace';\nimport { SpeedyMedia } from './speedy-media';\nimport { LKFeatureTracker } from './speedy-feature-tracker';\n\n/**\n * A collection of methods for instantiating Feature Trackers\n */\nexport class SpeedyFeatureTrackerFactory extends SpeedyNamespace\n{\n    /**\n     * Spawns a LK feature tracker\n     * @param {SpeedyMedia} media\n     * @returns {LKFeatureTracker}\n     */\n    static LK(media)\n    {\n        return new LKFeatureTracker(media);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-feature-tracker.js\n * An easy-to-use class for working with feature trackers\n */\n\nimport { FeatureTrackingAlgorithm } from './keypoints/feature-tracking-algorithm';\nimport { SpeedyMedia } from './speedy-media';\nimport { SpeedyGPU } from '../gpu/speedy-gpu';\nimport { SpeedyVector2 } from './math/speedy-vector';\nimport { IllegalOperationError, IllegalArgumentError } from '../utils/errors';\nimport { Utils } from '../utils/utils';\nimport { LKFeatureTrackingAlgorithm } from './keypoints/trackers/lk';\nimport { SpeedyFeatureDecorator } from './speedy-feature-decorator';\n\n/**\n * An easy-to-use class for working with feature trackers\n * (it performs sparse optical-flow)\n * @abstract\n */\nexport class SpeedyFeatureTracker\n{\n    /**\n     * Class constructor\n     * @param {FeatureTrackingAlgorithm} trackingAlgorithm used to track the features\n     * @param {SpeedyMedia} media the media that holds the features\n     */\n    constructor(trackingAlgorithm, media)\n    {\n        this._media = media;\n        this._trackingAlgorithm = trackingAlgorithm;\n        this._decoratedAlgorithm = this._trackingAlgorithm;\n        this._inputTexture = null;\n        this._prevInputTexture = null;\n        this._updateLock = false;\n    }\n\n    /**\n     * Decorate the underlying algorithm\n     * @param {SpeedyFeatureDecorator} decorator\n     * @returns {SpeedyFeatureDetector} this instance, now decorated\n     */\n    link(decorator)\n    {\n        this._decoratedAlgorithm = decorator.decorate(this._decoratedAlgorithm);\n        return this;\n    }\n\n    /**\n     * Track keypoints in the media\n     * @param {SpeedyFeature[]} keypoints the keypoints you want to track\n     * @param {SpeedyVector2[]|null} [flow] output parameter: flow vector for the i-th keypoint\n     * @param {boolean[]|null} [found] output parameter: found[i] will be true if the i-th keypoint has been found\n     * @returns {Promise<SpeedyFeature[]>}\n     */\n    track(keypoints, flow = null, found = null)\n    {\n        const gpu = this._media._gpu; // friend class?!\n        const descriptorSize = this._decoratedAlgorithm.descriptorSize;\n        const extraSize = this._decoratedAlgorithm.extraSize;\n        const useAsyncTransfer = (this._media.options.usage != 'static');\n\n        // validate arguments\n        if(!Array.isArray(keypoints) || (found != null && !Array.isArray(found)) || (flow != null && !Array.isArray(flow)))\n            throw new IllegalArgumentError();\n\n        // upload media to the GPU\n        this._updateMedia(this._media, gpu);\n\n        // get the input images\n        const nextImage = this._inputTexture;\n        const prevImage = this._prevInputTexture;\n\n        // adjust the size of the encoder\n        gpu.programs.encoders.optimize(keypoints.length, descriptorSize, extraSize);\n\n        // upload & track keypoints\n        this._trackingAlgorithm.prevImage = prevImage;\n        this._trackingAlgorithm.prevKeypoints = this._trackingAlgorithm.upload(gpu, keypoints);\n        const trackedKeypoints = this._decoratedAlgorithm.run(gpu, nextImage);\n\n        // download keypoints\n        const discard = [];\n        return this._trackingAlgorithm.download(gpu, trackedKeypoints, useAsyncTransfer, discard).then(trackedKeypoints => {\n            const filteredKeypoints = [];\n\n            // initialize output arrays\n            if(found != null)\n                found.length = trackedKeypoints.length;\n            if(flow != null)\n                flow.length = trackedKeypoints.length;\n\n            // compute additional data and\n            // filter out discarded keypoints\n            for(let i = 0; i < trackedKeypoints.length; i++) {\n                const goodFeature = !discard[i];\n\n                if(goodFeature)\n                    filteredKeypoints.push(trackedKeypoints[i]);\n\n                if(found != null)\n                    found[i] = goodFeature;\n\n                if(flow != null) {\n                    flow[i] = goodFeature ? \n                        new SpeedyVector2(trackedKeypoints[i].x - keypoints[i].x, trackedKeypoints[i].y - keypoints[i].y) :\n                        new SpeedyVector2(0, 0);\n                }\n            }\n\n            // done!\n            return filteredKeypoints;\n        });\n    }\n\n    /**\n     * Upload the media to GPU and keep track of the previous frame\n     * @param {SpeedyMedia} media\n     * @param {SpeedyGPU} gpu\n     */\n    _updateMedia(media, gpu)\n    {\n        // validate the media\n        if(media.isReleased())\n            throw new IllegalOperationError(`The media has been released`);\n\n        // it's too early to change the input texture\n        if(this._updateLock)\n            return;\n        setTimeout(() => this._updateLock = false, 1000.0 / 50.0);\n        this._updateLock = true;\n\n        // upload the media\n        const newInputTexture = gpu.upload(media.source);\n        if(newInputTexture == null)\n            throw new IllegalOperationError(`Tracking error: can't upload image to the GPU ${media.source}`);\n\n        // store the textures\n        const prevInputTexture = this._inputTexture; // may be null (1st frame)\n        this._inputTexture = newInputTexture;\n        this._prevInputTexture = prevInputTexture || newInputTexture;\n    }\n}\n\n\n/**\n * LK feature tracker with image pyramids\n */\nexport class LKFeatureTracker extends SpeedyFeatureTracker\n{\n    /**\n     * Class constructor\n     * @param {SpeedyMedia} media media to track\n     */\n    constructor(media)\n    {\n        const algorithm = new LKFeatureTrackingAlgorithm();\n        super(algorithm, media);\n    }\n\n    /**\n     * Neighborhood size\n     * @returns {number}\n     */\n    get windowSize()\n    {\n        return this._trackingAlgorithm.windowSize;\n    }\n\n    /**\n     * Neighborhood size\n     * @param {number} newSize a positive odd number, typically 21 or 15\n     */\n    set windowSize(newSize)\n    {\n        if(typeof newSize !== 'number' || newSize < 1 || newSize % 2 == 0)\n            throw new IllegalArgumentError(`Window size must be a positive odd number`);\n\n        this._trackingAlgorithm.windowSize = newSize;\n    }\n\n    /**\n     * How many pyramid levels will be scanned\n     * @returns {number}\n     */\n    get depth()\n    {\n        return this._trackingAlgorithm.depth;\n    }\n\n    /**\n     * How many pyramid levels will be scanned\n     * @param {number} newDepth positive integer\n     */\n    set depth(newDepth)\n    {\n        if(typeof newDepth !== 'number' || newDepth < 1)\n            throw new IllegalArgumentError(`Invalid depth: ${newDepth}`);\n\n        this._trackingAlgorithm.depth = newDepth;\n    }\n\n    /**\n     * A threshold used to discard \"bad\" keypoints\n     * @returns {number}\n     */\n    get discardThreshold()\n    {\n        return this._trackingAlgorithm.discardThreshold;\n    }\n\n    /**\n     * A threshold used to discard \"bad\" keypoints\n     * @param {number} threshold typically 0.0001 - increase to discard more keypoints\n     */\n    set discardThreshold(threshold)\n    {\n        if(typeof threshold !== 'number' || threshold < 0)\n            throw new IllegalArgumentError(`Invalid discardThreshold`);\n\n        this._trackingAlgorithm.discardThreshold = threshold;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-feature.js\n * Feature Point class\n */\n\nimport { NullDescriptor } from './speedy-descriptor';\n\n// Constants\nconst nullDescriptor = new NullDescriptor();\n\n\n\n/**\n * A SpeedyFeature is a keypoint in an image,\n * with optional scale, rotation and descriptor\n */\nexport class SpeedyFeature\n{\n    /**\n     * Creates a new SpeedyFeature\n     * @param {number} x X position\n     * @param {number} y Y position\n     * @param {number} [lod] Level-of-detail\n     * @param {number} [rotation] Rotation in radians\n     * @param {number} [score] Cornerness measure\n     * @param {SpeedyDescriptor} [descriptor] Feature descriptor\n     */\n    constructor(x, y, lod = 0.0, rotation = 0.0, score = 0.0, descriptor = null)\n    {\n        this._x = +x;\n        this._y = +y;\n        this._lod = +lod;\n        this._rotation = +rotation;\n        this._score = +score;\n        this._scale = Math.pow(2, +lod);\n        this._descriptor = descriptor === null ? nullDescriptor : descriptor;\n    }\n\n    /**\n     * Converts a SpeedyFeature to a representative string\n     * @returns {string}\n     */\n    toString()\n    {\n        return `(${this._x},${this._y})`;\n    }\n\n    /**\n     * The X position of the feature point\n     * @returns {number} X position\n     */\n    get x()\n    {\n        return this._x;\n    }\n\n    /**\n     * The y position of the feature point\n     * @returns {number} Y position\n     */\n    get y()\n    {\n        return this._y;\n    }\n\n    /**\n     * The pyramid level-of-detail from which\n     * this feature point was extracted\n     */\n    get lod()\n    {\n        return this._lod;\n    }\n\n    /**\n     * The scale of the feature point\n     * @returns {number} Scale\n     */\n    get scale()\n    {\n        return this._scale;\n    }\n\n    /**\n     * The rotation of the feature point, in radians\n     * @returns {number} Angle in radians\n     */\n    get rotation()\n    {\n        return this._rotation;\n    }\n\n    /**\n     * Score: a cornerness measure\n     * @returns {number} Score\n     */\n    get score()\n    {\n        return this._score;\n    }\n\n    /**\n     * The descriptor of the feature point\n     * @return {SpeedyDescriptor} feature descriptor\n     */\n    get descriptor()\n    {\n        return this._descriptor;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-flags.js\n * Flags available to users\n */\n\nimport { MatrixMath } from './math/matrix-math';\n\nexport const SpeedyFlags = Object.freeze({\n\n    // Feature detectors\n    FEATURE_DETECTOR_RESET_CAPACITY: 0x1,\n\n    // Matrix types\n    ...(MatrixMath.MatrixType),\n\n});","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-media.js\n * SpeedyMedia implementation\n */\n\nimport { SpeedyGPU } from '../gpu/speedy-gpu';\nimport { MediaType, ColorFormat } from '../utils/types'\nimport { TimeoutError, IllegalArgumentError, IllegalOperationError, NotSupportedError, AccessDeniedError } from '../utils/errors';\nimport { Utils } from '../utils/utils';\nimport { SpeedyFeatureDetectorFactory } from './speedy-feature-detector-factory';\n\n/**\n * SpeedyMedia encapsulates a media element\n * (e.g., image, video, canvas)\n */\nexport class SpeedyMedia\n{\n    /**\n     * Class constructor\n     * It assumes A VALID (!) media source that is already loaded\n     * @param {HTMLImageElement|HTMLVideoElement|HTMLCanvasElement|ImageBitmap} mediaSource Image or video\n     * @param {number} width media width\n     * @param {number} height media height\n     * @param {object} [options] options object\n     */\n    /* private */ constructor(mediaSource, width, height, options = { })\n    {\n        if(arguments.length > 1) {\n            // store data\n            this._source = mediaSource;\n            this._width = width | 0;\n            this._height = height | 0;\n            this._type = getMediaType(this._source);\n            this._colorFormat = ColorFormat.RGB;\n\n            // warning: loading canvas without explicit usage option\n            if(this._type == MediaType.Canvas && options.usage === undefined)\n                Utils.warning('Loading a canvas without an explicit usage flag. I will set the usage to \"static\", resulting in suboptimal performance if the canvas is animated');\n\n            // set options\n            this._options = buildOptions(options, {\n                usage: (this._type == MediaType.Video) ? 'dynamic' : 'static',\n            });\n\n            // spawn relevant components\n            this._gpu = new SpeedyGPU(this._width, this._height);\n        }\n        else if(arguments.length == 1) {\n            // copy constructor (shallow copy)\n            const media = arguments[0];\n\n            this._source = media._source;\n            this._width = media._width;\n            this._height = media._height;\n            this._type = media._type;\n            this._colorFormat = media._colorFormat;\n            this._options = media._options;\n\n            this._gpu = media._gpu;\n        }\n        else\n            throw new IllegalArgumentError(`Invalid instantiation of SpeedyMedia`);\n    }\n\n    /**\n     * Load a media source\n     * Will wait until the HTML media source is loaded\n     * @param {HTMLImageElement|HTMLVideoElement|HTMLCanvasElement|ImageBitmap} mediaSource An image, video or canvas\n     * @param {object} [options] options object\n     * @returns {Promise<SpeedyMedia>}\n     */\n    static load(mediaSource, options = { })\n    {\n        return waitMediaToLoad(mediaSource).then(() => {\n            const dimensions = getMediaDimensions(mediaSource);\n            if(dimensions.width == 0 || dimensions.height == 0)\n                throw new IllegalOperationError(`Can't load media: invalid dimensions`);\n\n            const media = new SpeedyMedia(mediaSource, dimensions.width, dimensions.height, options);\n            Utils.log(`Loaded SpeedyMedia with a ${mediaSource}.`);\n\n            return media;\n        });\n    }\n\n    /**\n     * Loads a camera stream\n     * @param {number} [width] width of the stream\n     * @param {number} [height] height of the stream\n     * @param {object} [cameraOptions] additional options to pass to getUserMedia()\n     * @param {object} [mediaOptions] additional options for advanced configuration of the SpeedyMedia\n     * @returns {Promise<SpeedyMedia>}\n     */\n    static loadCameraStream(width = 426, height = 240, cameraOptions = { }, mediaOptions = { })\n    {\n        return requestCameraStream(width, height, cameraOptions).then(\n            video => SpeedyMedia.load(video, mediaOptions)\n        );\n    }\n\n    /**\n     * The media element (image, video, canvas) encapsulated by this SpeedyMedia object\n     * @returns {HTMLImageElement|HTMLVideoElement|HTMLCanvasElement|ImageBitmap} the media element\n     */\n    get source()\n    {\n        return this._source;\n    }\n\n    /**\n     * Gets the width of the media\n     * @returns {number} media width\n     */\n    get width()\n    {\n        return this._width;\n    }\n\n    /**\n     * Gets the height of the media\n     * @returns {number} media height\n     */\n    get height()\n    {\n        return this._height;\n    }\n\n    /**\n     * The type of the media attached to this SpeedyMedia object\n     * @returns {string} \"image\" | \"video\" | \"canvas\" | \"bitmap\"\n     */\n    get type()\n    {\n        switch(this._type) {\n            case MediaType.Image:\n                return 'image';\n\n            case MediaType.Video:\n                return 'video';\n\n            case MediaType.Canvas:\n                return 'canvas';\n\n            case MediaType.Bitmap:\n                return 'bitmap';\n\n            default: // this shouldn't happen\n                return 'unknown';\n        }\n    }\n\n    /**\n     * Returns a read-only object featuring advanced options\n     * related to this SpeedyMedia object\n     * @returns {object}\n     */\n    get options()\n    {\n        return this._options;\n    }\n\n    /**\n     * Releases resources associated with this media.\n     * You will no longer be able to use it, nor any of its lightweight clones.\n     * @returns {Promise} resolves as soon as the resources are released\n     */\n    release()\n    {\n        if(!this.isReleased()) {\n            Utils.log('Releasing SpeedyMedia object...');\n            this._gpu.loseWebGLContext();\n            this._gpu = null;\n            this._source = null;\n        }\n\n        return Promise.resolve();\n    }\n\n    /**\n     * Is this SpeedyMedia released?\n     * @returns {bool}\n     */\n    isReleased()\n    {\n        return this._gpu == null;\n    }\n\n    /**\n     * Clones the SpeedyMedia object\n     * @param {object} options options object\n     * @returns {Promise<SpeedyMedia>} a clone object\n     */\n    clone(options = {})\n    {\n        // Default settings\n        options = {\n            lightweight: false,\n            ...(options)\n        };\n\n        // has the media been released?\n        if(this.isReleased())\n            throw new IllegalOperationError('Can\\'t clone a SpeedyMedia that has been released');\n\n        // clone the object\n        if(options.lightweight) {\n            // shallow copy\n            return Promise.resolve(new SpeedyMedia(this));\n        }\n        else {\n            // deep copy\n            if(this._type == MediaType.Bitmap) {\n                return createImageBitmap(this._source).then(\n                    bitmap => new SpeedyMedia(bitmap, this._width, this._height)\n                );               \n            }\n            else if(this._type == MediaType.Canvas) {\n                const clonedCanvas = Utils.createCanvas(this._width, this._height);\n                this.draw(clonedCanvas);\n                return Promise.resolve(new SpeedyMedia(clonedCanvas, this._width, this._height));\n            }\n            else {\n                const clonedSource = this._source.cloneNode(true);\n                return Promise.resolve(new SpeedyMedia(clonedSource, this._width, this._height));\n            }\n        }\n    }\n\n    /**\n     * Runs a pipeline\n     * @param {SpeedyPipeline} pipeline\n     * @returns {Promise<SpeedyMedia>} a promise that resolves to A CLONE of this SpeedyMedia\n     */\n    run(pipeline)\n    {\n        // has the media been released?\n        if(this.isReleased())\n            throw new IllegalOperationError('Can\\'t run pipeline: SpeedyMedia has been released');\n\n        // run the pipeline on a cloned SpeedyMedia\n        return this.clone({ lightweight: true }).then(media => {\n            // upload media to the GPU\n            let texture = media._gpu.upload(media._source);\n\n            // run the pipeline\n            texture = pipeline._run(texture, media._gpu, media);\n\n            // convert to bitmap\n            media._gpu.programs.utils.output(texture);\n            return createImageBitmap(media._gpu.canvas, 0, 0, media.width, media.height).then(bitmap => {\n                media._type = MediaType.Bitmap;\n                media._source = bitmap;\n                return media;\n            });\n        });\n    }\n\n    /**\n     * Draws the media to a canvas\n     * @param {HTMLCanvasElement} canvas canvas element\n     * @param {number} [x] x-position\n     * @param {number} [y] y-position\n     * @param {number} [width] desired width\n     * @param {number} [height] desired height\n     */\n    draw(canvas, x = 0, y = 0, width = this.width, height = this.height)\n    {\n        // fail silently if the media been released\n        if(this.isReleased())\n            return;\n\n        // validate parameters\n        x = Math.max(+x, 0); y = Math.max(+y, 0);\n        width = Math.max(+width, 0);\n        height = Math.max(+height, 0);\n\n        // draw\n        const ctx = canvas.getContext('2d');\n        ctx.drawImage(this._source, x, y, width, height);\n    }\n\n    /**\n     * Converts the media to an ImageBitmap\n     * @returns {Promise<ImageBitmap>}\n     */\n    toBitmap()\n    {\n        if(this.isReleased())\n            throw new IllegalOperationError('Can\\'t convert to SpeedyMedia to ImageBitmap: the media has been released');\n\n        return createImageBitmap(this._source);\n    }\n\n    /**\n     * Finds feature points\n     * @deprecated Use the Feature Detection objects instead\n     * \n     * @param {object} [settings] Configuration object\n     * @returns {Promise<SpeedyFeature[]>} A Promise returning an Array of SpeedyFeature objects\n     */\n    findFeatures(settings = {})\n    {\n        // Default settings\n        if(!settings.hasOwnProperty('method'))\n            settings.method = 'fast';\n        settings.method = String(settings.method);\n\n        // map: method string -> feature detector & descriptor\n        const createFeatureDetector = {\n            'fast': SpeedyFeatureDetectorFactory.FAST,\n            'multiscale-fast': SpeedyFeatureDetectorFactory.MultiscaleFAST,\n            'harris': SpeedyFeatureDetectorFactory.Harris,\n            'multiscale-harris': SpeedyFeatureDetectorFactory.MultiscaleHarris,\n            'orb': SpeedyFeatureDetectorFactory.ORB,\n            'brisk': SpeedyFeatureDetectorFactory.BRISK,\n        };\n\n        // Validate method\n        if(!createFeatureDetector.hasOwnProperty(settings.method))\n            throw new IllegalArgumentError(`Invalid method \"${settings.method}\" for feature detection`);\n\n        // Setup feature detector & descriptor\n        if(this._featureDetector == null || this._currFeatureDetector !== createFeatureDetector[settings.method]) {\n            const featureDetector = createFeatureDetector[settings.method];\n            this._currFeatureDetector = featureDetector;\n            this._featureDetector = featureDetector();\n        }\n\n        // Settings\n        if(settings.hasOwnProperty('sensitivity'))\n            this._featureDetector.sensitivity = +settings.sensitivity;\n        if(settings.hasOwnProperty('max'))\n            this._featureDetector.max = settings.max | 0;\n        if(settings.hasOwnProperty('denoise'))\n            this._featureDetector.enhance({ denoise: Boolean(settings.denoise) });\n        if(settings.hasOwnProperty('expected')) {\n            if(typeof settings.expected == 'object')\n                this._featureDetector.expect(settings.expected.number | 0, +settings.expected.tolerance);\n            else\n                this._featureDetector.expect(settings.expected | 0);\n        }\n\n        // Find features\n        return this._featureDetector.detect(this);\n    }\n}\n\n// get the { width, height } of a certain HTML element (image, video, canvas...)\nfunction getMediaDimensions(mediaSource)\n{\n    if(mediaSource && mediaSource.constructor && mediaSource.constructor.name) {\n        const element = mediaSource.constructor.name, key = {\n            HTMLImageElement: { width: 'naturalWidth', height: 'naturalHeight' },\n            HTMLVideoElement: { width: 'videoWidth', height: 'videoHeight' },\n            HTMLCanvasElement: { width: 'width', height: 'height' },\n            ImageBitmap: { width: 'width', height: 'height' },\n        };\n\n        if(key.hasOwnProperty(element)) {\n            return {\n                width: mediaSource[key[element].width],\n                height: mediaSource[key[element].height]\n            };\n        }\n    }\n\n    return null;\n}\n\n// get a string corresponding to the media type (image, video, canvas)\nfunction getMediaType(mediaSource)\n{\n    if(mediaSource && mediaSource.constructor) {\n        switch(mediaSource.constructor.name) {\n            case 'HTMLImageElement':\n                return MediaType.Image;\n\n            case 'HTMLVideoElement':\n                return MediaType.Video;\n\n            case 'HTMLCanvasElement':\n                return MediaType.Canvas;\n\n            case 'ImageBitmap':\n                return MediaType.Bitmap;\n        }\n    }\n\n    throw new IllegalArgumentError(`Can't get media type: invalid media source. ${mediaSource}`);\n}\n\n// wait until a media source is loaded\nfunction waitMediaToLoad(mediaSource, timeout = 30000)\n{\n    // a promise that resolves as soon as the media is loaded\n    const waitUntil = eventName => new Promise((resolve, reject) => {\n        Utils.log(`Loading media ${mediaSource} ...`);\n\n        const timer = setTimeout(() => {\n            reject(new TimeoutError(`Can't load ${mediaSource}: timeout (${timeout}ms)`));\n        }, timeout);\n\n        mediaSource.addEventListener(eventName, ev => {\n            clearTimeout(timer);\n            resolve(mediaSource);\n        });\n    });\n\n    // check if the media is already loaded\n    // if it's not, wait until it is\n    if(mediaSource && mediaSource.constructor) {\n        switch(mediaSource.constructor.name) {\n            case 'HTMLImageElement':\n                if(mediaSource.complete && mediaSource.naturalWidth !== 0)\n                    return Promise.resolve(mediaSource);\n                else\n                    return waitUntil('load');\n\n            case 'HTMLVideoElement':\n                if(mediaSource.readyState >= 4)\n                    return Promise.resolve(mediaSource);\n                else\n                    return waitUntil('canplaythrough');\n                    //return waitUntil('canplay'); // use readyState >= 3\n\n            case 'HTMLCanvasElement':\n                return Promise.resolve(mediaSource);\n\n            case 'ImageBitmap':\n                return Promise.resolve(mediaSource);\n        }\n    }\n\n    // unrecognized media type\n    throw new IllegalArgumentError(`Can't load the media: unrecognized media type. ${mediaSource}`);\n}\n\n// build & validate options object\nfunction buildOptions(options, defaultOptions)\n{\n    // build options object\n    options = Object.assign(defaultOptions, options);\n\n    // validate\n    if(options.usage != 'dynamic' && options.usage != 'static') {\n        Utils.warning(`Can't load media. Unrecognized usage option: \"${options.usage}\"`);\n        options.usage = defaultOptions.usage;\n    }\n\n    // done!\n    return Object.freeze(options); // must be read-only\n}\n\n// webcam access\nfunction requestCameraStream(width, height, options = {})\n{\n    return new Promise((resolve, reject) => {\n        Utils.log('Accessing the webcam...');\n\n        if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia)\n            return reject(new NotSupportedError('Unsupported browser: no mediaDevices.getUserMedia()'));\n\n        navigator.mediaDevices.getUserMedia({\n            audio: false,\n            video: {\n                width: { ideal: width },\n                height: { ideal: height },\n                aspectRatio: { ideal: width / height },\n                facingMode: 'environment',\n                frameRate: 30,\n            },\n            ...(options)\n        })\n        .then(stream => {\n            const video = document.createElement('video');\n            video.srcObject = stream;\n            video.onloadedmetadata = e => {\n                video.play();\n                Utils.log('The camera device is turned on!');\n                resolve(video, stream);\n            };\n        })\n        .catch(err => {\n            reject(new AccessDeniedError(\n                `Please give access to the camera and reload the page`,\n                err\n            ));\n        });\n    });\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-namespace.js\n * Symbolizes a namespace\n */\n\nimport { AbstractMethodError } from '../utils/errors'\n\n/**\n * An abstract namespace\n * @abstract\n */\nexport class SpeedyNamespace\n{\n    /**\n     * Namespaces can't be instantiated.\n     * Only static methods are allowed.\n     * @throws SpeedyError\n     */\n    constructor()\n    {\n        // only static methods are allowed\n        throw new AbstractMethodError(`Namespaces can't be instantiated`);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-pipeline.js\n * A pipeline is a sequence of operations that transform the image in some way\n */\n\nimport { PipelineOperation } from './pipeline-operations';\nimport { MediaType } from '../utils/types';\nimport { IllegalOperationError } from '../utils/errors';\nimport { IllegalArgumentError } from '../utils/errors';\n\n\n/**\n * A SpeedyPipeline holds a sequence of operations that\n * graphically transform the incoming media in some way\n * \n * SpeedyPipeline's methods are chainable: use them to\n * create your own sequence of image operations\n */\nexport class SpeedyPipeline\n{\n    /**\n     * Class constructor\n     */\n    constructor()\n    {\n        this._operations = [];\n    }\n\n    /**\n     * The number of the operations of the pipeline\n     * @returns {number}\n     */\n    get length()\n    {\n        return this._operations.length;\n    }\n\n    /**\n     * Cleanup pipeline memory\n     * @returns {Promise<SpeedyPipeline>} resolves as soon as the memory is released\n     */\n    release()\n    {\n        return new Promise((resolve, reject) => {\n            for(let i = this._operations.length - 1; i >= 0; i--)\n                this._operations[i].release();\n            this._operations.length = 0;\n            resolve(this);\n        });\n    }\n\n    /**\n     * Adds a new operation to the end of the pipeline\n     * @param {SpeedyPipelineOperation} operation\n     * @returns {SpeedyPipeline} the pipeline itself\n     */\n    _spawn(operation)\n    {\n        this._operations.push(operation);\n        return this;\n    }\n\n    /**\n     * Runs the pipeline\n     * @param {SpeedyTexture} texture input texture\n     * @param {SpeedyGPU} gpu gpu attached to the media\n     * @param {SpeedyMedia} media media object\n     * @returns {SpeedyTexture} output texutre\n     */\n    _run(texture, gpu, media)\n    {\n        for(let i = 0; i < this._operations.length; i++)\n            texture = this._operations[i].run(texture, gpu, media);\n\n        return texture;\n    }\n\n\n    // =====================================================\n    //                    GENERIC\n    // =====================================================\n\n    /**\n     * Concatenates another pipeline into this one\n     * @param {SpeedyPipeline} pipeline\n     * @returns {SpeedyPipeline}\n     */\n    concat(pipeline)\n    {\n        if(pipeline instanceof SpeedyPipeline) {\n            this._operations = this._operations.concat(pipeline._operations);\n            return this;\n        }\n\n        throw new IllegalArgumentError(`Invalid argument \"${pipeline}\" given to SpeedyPipeline.concatenate()`);\n    }\n\n\n    // =====================================================\n    //               COLOR CONVERSIONS\n    // =====================================================\n\n    /**\n     * Convert to a color space\n     * @param {string} [colorSpace] 'greyscale' | 'grayscale'\n     * @returns {SpeedyPipeline}\n     */\n    convertTo(colorSpace = null)\n    {\n        if(colorSpace == 'greyscale' || colorSpace == 'grayscale') {\n            return this._spawn(\n                new PipelineOperation.ConvertToGreyscale()\n            );\n        }\n\n        throw new IllegalArgumentError(`Can't convert to unknown color space: \"${colorSpace}\"`);\n    }\n\n\n\n    // =====================================================\n    //               IMAGE FILTERING\n    // =====================================================\n\n    /**\n     * Image smoothing\n     * @param {object} [options]\n     * @returns {SpeedyPipeline}\n     */\n    blur(options = {})\n    {\n        return this._spawn(\n            new PipelineOperation.Blur(options)\n        );\n    }\n\n    /**\n     * Image convolution\n     * @param {Array<number>} kernel\n     * @param {number} [divisor]\n     * @returns {SpeedyPipeline}\n     */\n    convolve(kernel, divisor = 1.0)\n    {\n        return this._spawn(\n            new PipelineOperation.Convolve(kernel, divisor)\n        );\n    }\n\n    /**\n     * Image normalization\n     * @param {object} [options]\n     * @returns {SpeedyPipeline}\n     */\n    normalize(options = {})\n    {\n        return this._spawn(\n            new PipelineOperation.Normalize(options)\n        );\n    }\n\n    /**\n     * Nightvision\n     * @param {object|Function<object>} [options]\n     * @returns {SpeedyPipeline}\n     */\n    nightvision(options = {})\n    {\n        return this._spawn(\n            new PipelineOperation.Nightvision(options)\n        );\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy.js\n * Speedy's main class\n */\n\nimport { SpeedyMedia } from './speedy-media';\nimport { SpeedyPipeline } from './speedy-pipeline';\nimport { FPSCounter } from '../utils/fps-counter';\nimport { SpeedyFeatureDetectorFactory } from './speedy-feature-detector-factory';\nimport { SpeedyFeatureTrackerFactory } from './speedy-feature-tracker-factory';\nimport { SpeedyFeatureDescriptorFactory } from './speedy-feature-descriptor-factory';\nimport { SpeedyFlags } from './speedy-flags';\nimport { SpeedyVector2 } from './math/speedy-vector';\nimport { SpeedyMatrixExprFactory } from './math/matrix-expressions';\nimport { SpeedyPromise } from '../utils/speedy-promise';\nimport { IllegalArgumentError } from '../utils/errors';\n\n// Constants\nconst matrixExprFactory = new SpeedyMatrixExprFactory();\n\n/**\n * Speedy's main class\n */\nexport class Speedy\n{\n    /**\n     * Loads a SpeedyMedia object based on the provided source element\n     * @param {HTMLImageElement|HTMLVideoElement|HTMLCanvasElement} sourceElement The source media\n     * @param {object} [options] Additional options for advanced configuration\n     * @returns {Promise<SpeedyMedia>}\n     */\n    static load(sourceElement, options = { })\n    {\n        return SpeedyMedia.load(sourceElement, options);\n    }\n\n    /**\n     * Loads a camera stream\n     * @param {number} [width] width of the stream\n     * @param {number} [height] height of the stream\n     * @param {object} [cameraOptions] additional options to pass to getUserMedia()\n     * @param {object} [mediaOptions] additional options for advanced configuration of the SpeedyMedia\n     * @returns {Promise<SpeedyMedia>}\n     */\n    static camera(width = 426, height = 240, cameraOptions = {}, mediaOptions = {})\n    {\n        return SpeedyMedia.loadCameraStream(width, height, cameraOptions, mediaOptions);\n    }\n\n    /**\n     * Creates a new pipeline\n     * @returns {SpeedyPipeline}\n     */\n    static pipeline()\n    {\n        return new SpeedyPipeline();\n    }\n\n    /**\n     * The version of the library\n     * @returns {string} The version of the library\n     */\n    static get version()\n    {\n        return __SPEEDY_VERSION__;\n    }\n\n    /**\n     * The FPS rate\n     * @returns {number} Frames per second (FPS)\n     */\n    static get fps()\n    {\n        return FPSCounter.instance.fps;\n    }\n\n    /**\n     * Feature detectors\n     * @returns {SpeedyFeatureDetectorFactory}\n     */\n    static get FeatureDetector()\n    {\n        return SpeedyFeatureDetectorFactory;\n    }\n\n    /**\n     * Feature trackers\n     * @returns {SpeedyFeatureTrackerFactory}\n     */\n    static get FeatureTracker()\n    {\n        return SpeedyFeatureTrackerFactory;\n    }\n\n    /**\n     * Feature descriptors\n     * @returns {SpeedyFeatureDescriptorFactory}\n     */\n    static get FeatureDescriptor()\n    {\n        return SpeedyFeatureDescriptorFactory;\n    }\n\n    /**\n     * Create a 2D vector\n     * @param {number} x\n     * @param {number} [y]\n     */\n    static Vector2(x, y = x)\n    {\n        return new SpeedyVector2(x, y);\n    }\n\n    /**\n     * Create a matrix expression\n     * @returns {SpeedyMatrixExprFactory}\n     */\n    static get Matrix()\n    {\n        return matrixExprFactory;\n    }\n\n    /**\n     * Speedy Promises\n     * @returns {Function}\n     */\n    static get Promise()\n    {\n        return SpeedyPromise;\n    }\n}\n\n// Mix SpeedyFlags with Speedy\nObject.assign(Speedy.constructor.prototype, SpeedyFlags);","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * sensitivity-tuner.js\n * A tuner designed for automatic sensitivity of keypoint detection\n */\n\nimport { Utils } from '../../utils/utils';\nimport { Tuner } from './tuner';\n\n/**\n * A Tuner for minimizing errors between observed and expected values\n * It's an online tuner: it learns the best responses in real-time\n * \n * This is sort of a hill climbing / gradient descent algorithm\n * with random elements and adapted for discrete space\n * \n * FIXME: currently it's a bit unstable in its results...\n *        Think it over.\n */\nexport class SensitivityTuner extends Tuner\n{\n    /**\n     * Class constructor\n     * @param {number} minState minimum INTEGER accepted by the quadratic error system\n     * @param {number} maxState maximum INTEGER accepted by the quadratic error system\n     * @param {number} tolerance percentage relative to the expected observation\n     * @param {number} learningRate hyperparameter\n     */\n    constructor(minState, maxState, tolerance = 0.1, learningRate = 0.05)\n    {\n        const initialState = Math.round(Utils.gaussianNoise((minState + maxState) / 2, 5));\n        super(initialState, minState, maxState);\n        this._tolerance = Math.max(0, tolerance);\n        this._bestState = this._initialState;\n        this._expected = null;\n        this._learningRate = Math.max(0, learningRate);\n        this._lastObservation = 0;\n    }\n\n    /**\n     * Reset the tuner\n     */\n    reset()\n    {\n        super.reset();\n        this._expected = null;\n    }\n\n    /**\n     * Feed an observed value and an expected value\n     * @param {number} observedValue\n     * @param {number} expectedValue\n     */\n    feedObservation(observedValue, expectedValue)\n    {\n        const obs = +observedValue;\n        const expected = +expectedValue;\n\n        // must reset the tuner?\n        if(expected !== this._expected)\n            this.reset();\n        this._expected = expected;\n\n        // discard noise\n        const possibleNoise = (Math.abs(obs) > 2 * Math.abs(this._lastObservation));\n        this._lastObservation = obs;\n        if(possibleNoise)\n            return;\n\n        // feed an error measurement to the appropriate bucket\n        const err = ((obs - expected) * (obs - expected)) / (expected * expected);\n        super.feedObservation(err);\n    }\n\n    /**\n     * Finished optimizing?\n     * @returns {boolean}\n     */\n    finished()\n    {\n        // error function\n        const E = (s) => Math.sqrt(this._bucketOf(s).average) * Math.abs(this._expected);\n\n        // compute values\n        const err = E(this._bestState);\n        const tol = this._tolerance;\n        const exp = this._expected;\n        //console.log('ERR', err, tol * exp);\n\n        // acceptable condition\n        return err <= tol * exp;\n    }\n\n    /**\n     * Tolerance value, a percentage relative\n     * to the expected value that we want\n     * @returns {boolean}\n     */\n    get tolerance()\n    {\n        return this._tolerance;\n    }\n\n    /**\n     * Set the tolerance, a percentage relative\n     * to the expected value that we want\n     * @param {number} value\n     */\n    set tolerance(value)\n    {\n        this._tolerance = Math.max(0, value);\n    }\n\n    /**\n     * Where should I go next?\n     * @returns {number} next state represented by an integer\n     */\n    _nextState()\n    {\n        // debug\n        /*\n        const dE = (s) => Math.sqrt(this._bucketOf(s).average) * Math.abs(this._expected);\n        let dnewState=(this._prevState+1)%(this._maxState+1)+this._minState;\n        this._arr = this._arr || [];\n        this._arr[dnewState] = dE(dnewState);\n        if(dnewState==this._minState) console.log(JSON.stringify(this._arr));\n        return dnewState;\n        */\n\n        // finished?\n        if(this.finished())\n            return this._bestState;\n\n        // error function\n        const E = (s) => Math.sqrt(this._bucketOf(s).average) * Math.abs(this._expected);\n\n        // best state\n        if(E(this._state) < E(this._bestState))\n            this._bestState = this._state;\n\n        // the algorithm should avoid long hops, as this\n        // would cause discontinuities for the end-user\n        //const stepSize = this._learningRate * E(this._state);\n        const worldScale = Math.abs(this._maxState);\n        const G = (s) => Math.sqrt(this._bucketOf(s).average) * worldScale;\n        const stepSize = this._learningRate * G(this._state);\n\n        // move in the opposite direction of the error or in\n        // the direction of the error with a small probability\n        const sign = x => Number(x >= 0) - Number(x < 0); // -1 or 1\n        const derr = E(this._state) - E(this._prevState);\n        const direction = (\n            sign(derr) *\n            sign(derr != 0 ? -(this._state - this._prevState) : 1) *\n            sign(Math.random() - 0.15)\n        );\n        //console.warn(\"at state\", this._state, direction > 0 ? '-->' : '<--');\n\n        // pick the next state\n        const weight = Utils.gaussianNoise(1.0, 0.1); // dodge local mimina\n        let newState = Math.round(this._state + direction * weight * stepSize);\n\n        // outside bounds?\n        if(newState > this._maxState)\n            newState = this._bestState;\n        else if(newState < this._minState)\n            newState = this._bestState;\n\n        // done\n        return newState;\n    }\n\n    /**\n     * Let me see debugging data\n     * @returns {object}\n     */\n    info()\n    {\n        return {\n            now: [ this._state, this._prevState ],\n            bkt: this._bucketOf(this._state)._rawData,\n            cur: this._bucketOf(this._state)._head,\n            err: [ this._bucketOf(this._state).average, this._bucketOf(this._prevState).average ],\n            sqt: Math.sqrt(this._bucketOf(this._state).average),\n            done: this.finished(),\n        };\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * stochastic-tuner.js\n * A tuner that implements Simulated Annealing\n */\n\nimport { Tuner } from './tuner';\n\n/*\n * A tuner that implements Simulated Annealing\n */\nexport class StochasticTuner extends Tuner\n{\n    /**\n     * Class constructor\n     * @param {number} initialState initial guess to input to the unknown system\n     * @param {number} minState minimum integer accepted by the unknown system\n     * @param {number} maxState maximum integer accepted by the unknown system\n     * @param {number} [alpha] geometric decrease rate of the temperature\n     * @param {number} [maxIterationsPerTemperature] number of iterations before cooling down by alpha\n     * @param {number} [initialTemperature] initial temperature\n     * @param {Function<number,number?>} [neighborFn] neighbor picking function: state[,F(state)] -> state\n     */\n    constructor(initialState, minState, maxState, alpha = 0.5, maxIterationsPerTemperature = 8, initialTemperature = 100, neighborFn = null)\n    {\n        super(initialState, minState, maxState);\n\n        this._bestState = this._initialState;\n        this._costOfBestState = Infinity;\n        this._initialTemperature = Math.max(0, initialTemperature);\n        this._temperature = this._initialTemperature;\n        this._numIterations = 0; // no. of iterations in the current temperature\n        this._maxIterationsPerTemperature = Math.max(1, maxIterationsPerTemperature);\n        this._alpha = Math.max(0, Math.min(alpha, 1)); // geometric decrease rate\n\n        if(!neighborFn)\n            neighborFn = (s) => this._minState + Math.floor(Math.random() * (this._maxState - this._minState + 1))\n        this._pickNeighbor = neighborFn;\n    }\n\n    /**\n     * Reset the Tuner\n     */\n    reset()\n    {\n        this._temperature = this._initialTemperature;\n        this._numIterations = 0;\n        // we shall not reset the best state...\n    }\n\n    /**\n     * Finished optimization?\n     * @returns {boolean}\n     */\n    finished()\n    {\n        return this._temperature <= 1e-5;\n    }\n\n    /**\n     * Pick the next state\n     * Simulated Annealing\n     * @returns {number}\n     */\n    _nextState()\n    {\n        // finished simulation?\n        if(this.finished())\n            return this._bestState;\n\n        // pick a neighbor\n        const f = (s) => this._bucketOf(s).average;\n        let nextState = this._state;\n        let neighbor = this._pickNeighbor(this._state, f(this._state)) | 0;\n        neighbor = Math.max(this._minState, Math.min(neighbor, this._maxState));\n\n        // evaluate the neighbor\n        if(f(neighbor) < f(this._state)) {\n            // the neighbor is better than the current state\n            nextState = neighbor;\n        }\n        else {\n            // the neighbor is not better than the current state,\n            // but we may admit it with a certain probability\n            if(Math.random() < Math.exp((f(this._state) - f(neighbor)) / this._temperature))\n                nextState = neighbor;\n        }\n\n        // update the best state\n        if(f(nextState) < this._costOfBestState) {\n            this._bestState = nextState;\n            this._costOfBestState = f(nextState);\n        }\n\n        // cool down\n        if(++this._numIterations >= this._maxIterationsPerTemperature) {\n            this._temperature *= this._alpha;\n            this._numIterations = 0;\n        }\n\n        // done\n        return nextState;\n    }\n\n    /**\n     * Debugging info\n     * @returns {object}\n     */\n    info()\n    {\n        return {\n            best: [ this._bestState, this._costOfBestState ],\n            state: [ this._state, this._bucketOf(this._state).average ],\n            iterations: [ this._numIterations, this._maxIterationsPerTemperature ],\n            temperature: this._temperature,\n            alpha: this._alpha,\n            cool: this.finished(),\n        };\n    }\n}\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * test-tuner.js\n * A tuner created for testing purposes\n */\n\nimport { Tuner } from './tuner';\n\n/**\n * A Tuner created for testing purposes\n */\nexport class TestTuner extends Tuner\n{\n    /**\n     * Class constructor\n     * @param {number} minState minimum integer accepted by the unknown system\n     * @param {number} maxState maximum integer accepted by the unknown system\n     */\n    constructor(minState, maxState)\n    {\n        super(minState, minState, maxState);\n    }\n\n    // where should I go next?\n    _nextState()\n    {\n        //console.log(this.info());\n        const nextState = this._state + 1;\n        return nextState > this._maxState ? this._minState : nextState;\n    }\n\n    // let me see stuff\n    info()\n    {\n        return {\n            state: [ this._state, this._bucketOf(this._state).average ],\n            data: JSON.stringify(this._bucket.map(b => b.average)),\n        };\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * tuner.js\n * An abstract device designed to minimize the (noisy) output of a unknown system\n */\n\nimport { IllegalArgumentError, AbstractMethodError } from '../../utils/errors';\n\n/**\n * A Bucket of observations is used to give\n * statistical treatment to (noisy) data\n */\nclass Bucket\n{\n    /**\n     * Class constructor\n     * @param {number} bucketSize It should be a power of two\n     * @param {number} windowSize An odd positive number for filtering\n     */\n    constructor(bucketSize = 32, windowSize = 5)\n    {\n        // validate parameters\n        this._bucketSize = 1 << Math.ceil(Math.log2(bucketSize));\n        this._windowSize = windowSize + (1 - windowSize % 2);\n\n        // bucketSize should be a power of 2\n        if(bucketSize < this._windowSize)\n            throw new IllegalArgumentError(`Invalid bucketSize of ${bucketSize}`);\n\n        // Bucket is implemented as a circular vector\n        this._head = this._bucketSize - 1;\n        this._rawData = new Float32Array(this._bucketSize).fill(0);\n        this._smoothedData = new Float32Array(this._bucketSize).fill(0);\n        this._average = 0;\n        this._isSmooth = true;\n    }\n\n    /**\n     * Put a value in the bucket\n     * @param {number} value\n     */\n    put(value)\n    {\n        this._head = (this._head + 1) & (this._bucketSize - 1);\n        this._rawData[this._head] = value;\n        this._isSmooth = false;\n    }\n\n    /**\n     * Bucket size\n     * @returns {number}\n     */\n    get size()\n    {\n        return this._bucketSize;\n    }\n\n    /**\n     * Get smoothed average\n     * @returns {number}\n     */\n    get average()\n    {\n        // need to smooth the signal?\n        if(!this._isSmooth)\n            this._smooth();\n\n        // the median filter does not introduce new data to the signal\n        // this._average approaches the mean of the distribution as bucketSize -> inf\n        return this._average;\n    }\n\n    /**\n     * Fill the bucket with a value\n     * @param {number} value\n     */\n    fill(value)\n    {\n        this._rawData.fill(value);\n        this._smoothedData.fill(value);\n        this._average = value;\n        this._isSmooth = true;\n        this._head = this._bucketSize - 1;\n        return this;\n    }\n\n    /**\n     * Apply the smoothing filter & compute the average\n     */\n    _smooth()\n    {\n        // smooth the signal & compute the average\n        this._average = 0;\n        for(let i = 0; i < this._bucketSize; i++) {\n            this._smoothedData[i] = this._median(this._window(i));\n            this._average += this._smoothedData[i];\n        }\n        this._average /= this._bucketSize;\n        //this._average = this._median(this._rawData);\n\n        // the signal has been smoothed\n        this._isSmooth = true;\n    }\n\n    /**\n     * Give me a window of size this._windowSize around this._rawData[i]\n     * @param {number} i central index\n     * @returns {Float32Array} will reuse the same buffer on each call\n     */\n    _window(i)\n    {\n        const arr = this._rawData;\n        const win = this._win || (this._win = new Float32Array(this._windowSize));\n        const n = arr.length;\n        const w = win.length;\n        const wOver2 = w >> 1;\n        const head = this._head;\n        const tail = (head + 1) & (n - 1);\n\n        for(let j = 0, k = -wOver2; k <= wOver2; k++) {\n            let pos = i + k;\n\n            // boundary conditions:\n            // reflect values\n            if(i <= head){\n                if(pos > head)\n                    pos = head + (head - pos);\n            }\n            else {\n                if(pos < tail)\n                    pos = tail + (tail - pos);\n            }\n            if(pos < 0)\n                pos += n;\n            else if(pos >= n)\n                pos -= n;\n\n            win[j++] = arr[pos];\n        }\n\n        return win;\n    }\n\n    /**\n     * Return the median of a sequence. Do it fast.\n     * Note: the input is rearranged\n     * @param {number[]} v sequence\n     * @returns {number}\n     */\n    _median(v)\n    {\n        // fast median search for fixed length vectors\n        switch(v.length) {\n            case 1:\n                return v[0];\n\n            case 3:\n                //  v0   v1   v2   [ v0  v1  v2 ]\n                //   \\  / \\   /\n                //   node  node    [ min(v0,v1)  min(max(v0,v1),v2)  max(max(v0,v1),v2) ]\n                //      \\   /\n                //      node       [ min(min(v0,v1),min(max(v0,v1),v2))  max(min(...),min(...))  max(v0,v1,v2) ]\n                //       |\n                //     median      [ min(v0,v1,v2)  median  max(v0,v1,v2) ]\n                if(v[0] > v[1]) [v[0], v[1]] = [v[1], v[0]];\n                if(v[1] > v[2]) [v[1], v[2]] = [v[2], v[1]];\n                if(v[0] > v[1]) [v[0], v[1]] = [v[1], v[0]];\n                return v[1];\n\n            case 5:\n                if(v[0] > v[1]) [v[0], v[1]] = [v[1], v[0]];\n                if(v[3] > v[4]) [v[3], v[4]] = [v[4], v[3]];\n                if(v[0] > v[3]) [v[0], v[3]] = [v[3], v[0]];\n                if(v[1] > v[4]) [v[1], v[4]] = [v[4], v[1]];\n                if(v[1] > v[2]) [v[1], v[2]] = [v[2], v[1]];\n                if(v[2] > v[3]) [v[2], v[3]] = [v[3], v[2]];\n                if(v[1] > v[2]) [v[1], v[2]] = [v[2], v[1]];\n                return v[2];\n\n            case 7:\n                if(v[0] > v[5]) [v[0], v[5]] = [v[5], v[0]];\n                if(v[0] > v[3]) [v[0], v[3]] = [v[3], v[0]];\n                if(v[1] > v[6]) [v[1], v[6]] = [v[6], v[1]];\n                if(v[2] > v[4]) [v[2], v[4]] = [v[4], v[2]];\n                if(v[0] > v[1]) [v[0], v[1]] = [v[1], v[0]];\n                if(v[3] > v[5]) [v[3], v[5]] = [v[5], v[3]];\n                if(v[2] > v[6]) [v[2], v[6]] = [v[6], v[2]];\n                if(v[2] > v[3]) [v[2], v[3]] = [v[3], v[2]];\n                if(v[3] > v[6]) [v[3], v[6]] = [v[6], v[3]];\n                if(v[4] > v[5]) [v[4], v[5]] = [v[5], v[4]];\n                if(v[1] > v[4]) [v[1], v[4]] = [v[4], v[1]];\n                if(v[1] > v[3]) [v[1], v[3]] = [v[3], v[1]];\n                if(v[3] > v[4]) [v[3], v[4]] = [v[4], v[3]];\n                return v[3];\n\n            default:\n                v.sort((a, b) => a - b);\n                return (v[(v.length - 1) >> 1] + v[v.length >> 1]) / 2;\n        }\n    }\n}\n\n/**\n * A Tuner is a device designed to find\n * an integer x that minimizes the output\n * of a unknown system y = F(x) with noise\n */\nexport /* abstract */ class Tuner\n{\n    /**\n     * Class constructor\n     * @param {number} initialState initial guess to input to the unknown system\n     * @param {number} minState minimum integer accepted by the unknown system\n     * @param {number} maxState maximum integer accepted by the unknown system\n     */\n    constructor(initialState, minState, maxState)\n    {\n        // you must not spawn an instance of an abstract class!\n        if(this.constructor === Tuner)\n            throw new AbstractMethodError();\n\n        // validate parameters\n        if(minState >= maxState)\n            throw new IllegalArgumentError(`Invalid boundaries [${minState},${maxState}] given to the Tuner`);\n        initialState = Math.max(minState, Math.min(initialState, maxState));\n\n        // setup object\n        this._state = initialState;\n        this._prevState = initialState;\n        this._prevPrevState = initialState;\n        this._initialState = initialState;\n        this._minState = minState;\n        this._maxState = maxState;\n        this._bucket = new Array(maxState - minState + 1).fill(null).map(x => new Bucket(this._bucketSetup().size, this._bucketSetup().window));\n        this._iterations = 0; // number of iterations in the same state\n        this._epoch = 0; // number of state changes\n    }\n\n    /**\n     * The value to input to the unknown system\n     */\n    currentValue()\n    {\n        return this._state;\n    }\n\n    /**\n     * Feed the output y = F(x) of the unknown system\n     * when given an input x = this.currentValue()\n     */\n    feedObservation(y)\n    {\n        const bucket = this._bucketOf(this._state);\n\n        // feed the observation into the bucket of the current state\n        bucket.put(+y);\n\n        // time to change state?\n        if(++this._iterations >= bucket.size) {\n            // initialize buckets\n            if(this._epoch == 0) {\n                this._bucket.forEach(bk => bk.fill(bucket.average));\n                if(!isFinite(this._costOfBestState))\n                    this._costOfBestState = bucket.average;\n            }\n\n            // compute next state\n            const clip = s => Math.max(this._minState, Math.min(s | 0, this._maxState));\n            const prevPrevState = this._prevState;\n            const prevState = this._state;\n            this._state = clip(this._nextState());\n            this._prevState = prevState;\n            this._prevPrevState = prevPrevState;\n\n            // reset iteration counter\n            // and advance epoch number\n            this._iterations = 0;\n            this._epoch++;\n        }\n    }\n\n    /**\n     * Reset the Tuner to its initial state\n     * Useful if you change on-the-fly the unknown system,\n     * so that there is a new target value you want to find\n     */\n    reset()\n    {\n        this._state = this._initialState;\n        this._prevState = this._initialState;\n        this._prevPrevState = this._initialState;\n        this._iterations = 0;\n        this._epoch = 0;\n    }\n\n    /**\n     * Finished optimization?\n     * @returns {boolean}\n     */\n    finished()\n    {\n        return false;\n    }\n\n    /**\n     * Get the bucket of a state\n     * @param {number} state \n     * @returns {Bucket}\n     */\n    _bucketOf(state)\n    {\n        state = Math.max(this._minState, Math.min(state | 0, this._maxState));\n        return this._bucket[state - this._minState];\n    }\n\n    /**\n     * Setup bucket shape. This may\n     * be reconfigured in subclasses.\n     * @returns {object}\n     */\n    _bucketSetup()\n    {\n        return {\n            size: 4,\n            window: 3\n        };\n        /*return {\n            size: 32,\n            window: 5\n        };*/\n    }\n\n    /**\n     * Template method magic\n     * @returns {number} next state\n     */\n    /* abstract */ _nextState()\n    {\n        throw new AbstractMethodError();\n    }\n\n    /**\n     * Let me see debugging stuff\n     * @returns {object}\n     */\n    info()\n    {\n        const bucket = this._bucketOf(this._state);\n        const prevBucket = this._bucketOf(this._prevState);\n\n        return {\n            now: this._state,\n            avg: bucket.average,\n            itr: [ this._iterations, this._epoch ],\n            bkt: bucket._smoothedData,\n            cur: new Array(bucket.size).fill(0).map((x, i) => i == bucket._head ? 1 : 0),\n            prv: [ this._prevState, prevBucket.average ],\n            fim: this.finished(),\n        };\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * gl-utils.js\n * WebGL utilities\n */\n\nimport { Utils } from '../utils/utils';\nimport { GLError, IllegalArgumentError, IllegalOperationError } from '../utils/errors';\n\n\n\n//\n// Constants\n//\nconst isFirefox = navigator.userAgent.includes('Firefox');\n\n\n\n/**\n * WebGL Utilities\n */\nexport class GLUtils\n{\n    /**\n     * Get an error object describing the latest WebGL error\n     * @param {WebGL2RenderingContext} gl \n     * @returns {GLError}\n     */\n    static getError(gl)\n    {\n        const recognizedErrors = [\n            'NO_ERROR',\n            'INVALID_ENUM',\n            'INVALID_VALUE',\n            'INVALID_OPERATION',\n            'INVALID_FRAMEBUFFER_OPERATION',\n            'OUT_OF_MEMORY',\n            'CONTEXT_LOST_WEBGL',\n        ];\n\n        const glError = gl.getError();\n        const message = recognizedErrors.find(error => gl[error] == glError) || 'Unknown';\n        return new GLError(message);\n    }\n\n    /**\n     * Create a shader\n     * @param {WebGL2RenderingContext} gl\n     * @param {number} type\n     * @param {string} source\n     * @returns {WebGLShader}\n     */\n    static createShader(gl, type, source)\n    {\n        const shader = gl.createShader(type);\n\n        gl.shaderSource(shader, source);\n        gl.compileShader(shader);\n\n        return shader;\n    }\n\n    /**\n     * Create a vertex-shader + fragment-shader program\n     * @param {WebGL2RenderingContext} gl\n     * @param {string} vertexShaderSource\n     * @param {string} fragmentShaderSource\n     * @returns {WebGLProgram}\n     */\n    static createProgram(gl, vertexShaderSource, fragmentShaderSource)\n    {\n        const program = gl.createProgram();\n        const vertexShader = GLUtils.createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n        const fragmentShader = GLUtils.createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n\n        gl.attachShader(program, vertexShader);\n        gl.attachShader(program, fragmentShader);\n        gl.linkProgram(program);\n        gl.validateProgram(program);\n\n        // error?\n        if(!gl.getProgramParameter(program, gl.LINK_STATUS) && !gl.isContextLost()) {\n            const errors = [\n                gl.getShaderInfoLog(fragmentShader),\n                gl.getShaderInfoLog(vertexShader),\n                gl.getProgramInfoLog(program),\n            ];\n\n            gl.deleteProgram(program);\n            gl.deleteShader(fragmentShader);\n            gl.deleteShader(vertexShader);\n\n            // display error\n            const spaces = i => Math.max(0, 2 - Math.floor(Math.log10(i)));\n            const col = k => Array(spaces(k)).fill(' ').join('') + k + '. ';\n            const formattedSource = fragmentShaderSource.split('\\n')\n                .map((line, no) => col(1+no) + line)\n                .join('\\n');\n\n            throw new GLError(\n                `Can't create shader.\\n\\n` +\n                `---------- ERROR ----------\\n` +\n                errors.join('\\n') + '\\n\\n' +\n                `---------- SOURCE CODE ----------\\n` +\n                formattedSource\n            );\n        }\n\n        return program;\n    }\n\n    /**\n     * Create the standard geometry for the vertex shader\n     * (i.e., vertices of a rectangle crafted for image processing)\n     * @param {WebGL2RenderingContext} gl\n     * @param {GLint} locationOfPositionAttribute\n     * @param {GLint} locationOfTexcoordAttribute\n     * @returns {object} with keys vao & vbo\n     */\n    static createStandardGeometry(gl, locationOfPositionAttribute, locationOfTexcoordAttribute)\n    {\n        // got cached values for this WebGL context?\n        const f = GLUtils.createStandardGeometry;\n        const cache = f._cache || (f._cache = new WeakMap());\n        if(cache.has(gl))\n            return cache.get(gl);\n\n        // configure the attributes of the vertex shader\n        const vao = gl.createVertexArray(); // vertex array object\n        const vbo = [ gl.createBuffer(), gl.createBuffer() ]; // vertex buffer objects\n        gl.bindVertexArray(vao);\n\n        // set the a_position attribute\n        // using the current vbo\n        gl.bindBuffer(gl.ARRAY_BUFFER, vbo[0]);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n            // clip coordinates\n            -1, -1,\n            1, -1,\n            -1, 1,\n            1, 1,\n        ]), gl.STATIC_DRAW);\n        gl.enableVertexAttribArray(locationOfPositionAttribute);\n        gl.vertexAttribPointer(locationOfPositionAttribute, // attribute location\n                               2,          // 2 components per vertex (x,y)\n                               gl.FLOAT,   // type\n                               false,      // don't normalize\n                               0,          // default stride (tightly packed)\n                               0);         // offset\n\n        // set the a_texCoord attribute\n        // using the current vbo\n        gl.bindBuffer(gl.ARRAY_BUFFER, vbo[1]);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n            // texture coordinates\n            0, 0,\n            1, 0,\n            0, 1,\n            1, 1,\n        ]), gl.STATIC_DRAW);\n        gl.enableVertexAttribArray(locationOfTexcoordAttribute);\n        gl.vertexAttribPointer(locationOfTexcoordAttribute, // attribute location\n                               2,          // 2 components per vertex (x,y)\n                               gl.FLOAT,   // type\n                               false,      // don't normalize\n                               0,          // default stride (tightly packed)\n                               0);         // offset\n\n        // unbind\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n\n        // cache & return\n        const result = { vao, vbo };\n        cache.set(gl, result);\n        return result;\n    }\n\n    /**\n     * Create a WebGL texture\n     * @param {WebGL2RenderingContext} gl \n     * @param {number} width in pixels\n     * @param {number} height in pixels\n     * @returns {WebGLTexture}\n     */\n    static createTexture(gl, width, height)\n    {\n        // validate dimensions\n        if(width <= 0 || height <= 0)\n            throw new IllegalArgumentError(`Invalid dimensions given to createTexture()`);\n\n        // create texture\n        const texture = gl.createTexture();\n\n        // setup texture\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT);\n        //gl.texStorage2D(gl.TEXTURE_2D, 1, gl.RGBA8, width, height);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA8, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n\n        // unbind & return\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        return texture;\n    }\n\n    /**\n     * Destroys a WebGL texture\n     * @param {WebGL2RenderingContext} gl \n     * @param {WebGLTexture} texture \n     * @returns {null}\n     */\n    static destroyTexture(gl, texture)\n    {\n        gl.deleteTexture(texture);\n        return null;\n    }\n\n    /**\n     * Upload pixel data to a WebGL texture\n     * @param {WebGL2RenderingContext} gl \n     * @param {WebGLTexture} texture \n     * @param {GLsizei} width texture width\n     * @param {GLsizei} height texture height\n     * @param {ImageBitmap|ImageData|ArrayBufferView|HTMLImageElement|HTMLVideoElement|HTMLCanvasElement} pixels \n     * @param {GLint} [lod] mipmap level-of-detail\n     * @returns {WebGLTexture} texture\n     */\n    static uploadToTexture(gl, texture, width, height, pixels, lod = 0)\n    {\n        // Prefer calling uploadToTexture() before gl.useProgram() to avoid the\n        // needless switching of GL programs internally. See also:\n        // https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n\n        /*\n        // slower than texImage2D, unlike the spec?\n        gl.texSubImage2D(gl.TEXTURE_2D,     // target\n                         lod,               // mip level\n                         0,                 // x-offset\n                         0,                 // y-offset\n                         width,             // texture width\n                         height,            // texture height\n                         gl.RGBA,           // source format\n                         gl.UNSIGNED_BYTE,  // source type\n                         pixels);           // source data\n        */\n\n        gl.texImage2D(gl.TEXTURE_2D,        // target\n                      lod,                  // mip level\n                      gl.RGBA8,             // internal format\n                      width,              // texture width\n                      height,             // texture height\n                      0,                  // border\n                      gl.RGBA,              // source format\n                      gl.UNSIGNED_BYTE,     // source type\n                      pixels);              // source data\n\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        return texture;\n    }\n\n    /**\n     * Generate texture mipmap with bilinear interpolation\n     * @param {WebGL2RenderingContext} gl \n     * @param {WebGLTexture} texture \n     */\n    static generateMipmap(gl, texture)\n    {\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);\n        gl.generateMipmap(gl.TEXTURE_2D);\n        gl.bindTexture(gl.TEXTURE_2D, null);\n    }\n\n    // bind the textures and assign their numbers\n    // textureMap: { 'textureName': <texture> , ... }\n    // locationMap: { 'textureName': <uniformLocation> , ... }\n    static bindTextures(gl, textureMap, locationMap)\n    {\n        const names = Object.keys(textureMap);\n\n        if(gl.isContextLost())\n            return;\n\n        if(names.length > gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS)\n            throw new GLError(`Can't bind ${names.length} textures to a program: max is ${gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS}`);\n\n        for(let i = 0; i < names.length; i++) {\n            gl.activeTexture(gl.TEXTURE0 + i);\n            gl.bindTexture(gl.TEXTURE_2D, textureMap[names[i]]);\n            gl.uniform1i(locationMap[names[i]], i);\n        }\n    }\n\n    /**\n     * Creates a framebuffer object (FBO) associated with an existing texture\n     * @param {WebGL2RenderingContext} gl \n     * @param {WebGLTexture} texture \n     * @returns {WebGLFramebuffer}\n     */\n    static createFramebuffer(gl, texture)\n    {\n        const fbo = gl.createFramebuffer();\n\n        // setup framebuffer\n        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n        gl.framebufferTexture2D(gl.FRAMEBUFFER,         // target\n                                gl.COLOR_ATTACHMENT0,   // color buffer\n                                gl.TEXTURE_2D,          // tex target\n                                texture,                // texture\n                                0);                     // mipmap level\n\n        // check for errors\n        const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n        if(status != gl.FRAMEBUFFER_COMPLETE) {\n            const error = (() => (([\n                'FRAMEBUFFER_UNSUPPORTED',\n                'FRAMEBUFFER_INCOMPLETE_ATTACHMENT',\n                'FRAMEBUFFER_INCOMPLETE_DIMENSIONS',\n                'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT',\n                'FRAMEBUFFER_INCOMPLETE_MULTISAMPLE'\n            ].filter(err => gl[err] === status))[0] || 'unknown error'))();\n            throw new GLError(`Can't create framebuffer: ${error} (${status})`);\n        }\n\n        // unbind & return\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        return fbo;\n    }\n\n    /**\n     * Destroys a framebuffer object (FBO)\n     * @param {WebGL2RenderingContext} gl\n     * @param {WebGLFramebuffer} fbo \n     * @returns {null}\n     */\n    static destroyFramebuffer(gl, fbo)\n    {\n        gl.deleteFramebuffer(fbo);\n        return null;\n    }\n\n    /**\n     * Waits for a sync object to become signaled\n     * @param {WebGL2RenderingContext} gl\n     * @param {WebGLSync} sync sync object\n     * @param {GLbitfield} [flags] may be gl.SYNC_FLUSH_COMMANDS_BIT or 0\n     * @returns {Promise} a promise that resolves as soon as the sync object becomes signaled\n     */\n    static clientWaitAsync(gl, sync, flags = 0)\n    {\n        this._checkStatus = this._checkStatus || (this._checkStatus = function checkStatus(gl, sync, flags, resolve, reject) {\n            const status = gl.clientWaitSync(sync, flags, 0);\n            if(status == gl.TIMEOUT_EXPIRED) {\n                Utils.setZeroTimeout(() => checkStatus.call(this, gl, sync, flags, resolve, reject)); // better performance (preferred)\n                //setTimeout(() => checkStatus.call(this, gl, sync, flags, resolve, reject), 0); // easier on the CPU\n            }\n            else if(status == gl.WAIT_FAILED) {\n                if(isFirefox && gl.getError() == gl.NO_ERROR) { // firefox bug?\n                    Utils.setZeroTimeout(() => checkStatus.call(this, gl, sync, flags, resolve, reject));\n                    //setTimeout(() => checkStatus.call(this, gl, sync, flags, resolve, reject), 0);\n                }\n                else {\n                    reject(GLUtils.getError(gl));\n                }\n            }\n            else {\n                resolve();\n            }\n        });\n\n        return new Promise((resolve, reject) => {\n            this._checkStatus(gl, sync, flags, resolve, reject);\n        });\n    }\n\n    /**\n     * Reads data from a WebGLBuffer into an ArrayBufferView\n     * This is like gl.getBufferSubData(), but async\n     * @param {WebGL2RenderingContext} gl\n     * @param {WebGLBuffer} glBuffer will be bound to target\n     * @param {GLenum} target\n     * @param {GLintptr} srcByteOffset usually 0\n     * @param {ArrayBufferView} destBuffer\n     * @param {GLuint} [destOffset]\n     * @param {GLuint} [length]\n     * @returns {Promise<number>} a promise that resolves to the time it took to read the data (in ms)\n     */\n    static getBufferSubDataAsync(gl, glBuffer, target, srcByteOffset, destBuffer, destOffset = 0, length = 0)\n    {\n        const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);\n        const start = performance.now();\n\n        // empty internal command queues and send them to the GPU asap\n        gl.flush(); // make sure the sync command is read\n\n        // wait for the commands to be processed by the GPU\n        return GLUtils.clientWaitAsync(gl, sync).then(() => {\n            gl.bindBuffer(target, glBuffer);\n            gl.getBufferSubData(target, srcByteOffset, destBuffer, destOffset, length);\n            gl.bindBuffer(target, null);\n            return performance.now() - start;\n        }).catch(err => {\n            throw new IllegalOperationError(`Can't getBufferSubDataAsync(): error in clientWaitAsync()`, err);\n        }).finally(() => {\n            gl.deleteSync(sync);\n        });\n    }\n\n    /**\n     * Read pixels to a Uint8Array using a Pixel Buffer Object (PBO)\n     * You may optionally specify a FBO to read pixels from a texture\n     * @param {WebGL2RenderingContext} gl\n     * @param {Uint8Array} arrayBuffer with size >= width * height * 4\n     * @param {GLint} x\n     * @param {GLint} y\n     * @param {GLsizei} width\n     * @param {GLsizei} height\n     * @param {WebGLFramebuffer} [fbo]\n     * @returns {Promise<number>} a promise that resolves to the time it took to read the data (in ms)\n     */\n    static readPixelsViaPBO(gl, arrayBuffer, x, y, width, height, fbo = null)\n    {\n        // create temp buffer\n        const pbo = gl.createBuffer();\n\n        // validate arrayBuffer\n        if(!(arrayBuffer.byteLength >= width * height * 4))\n            throw new IllegalArgumentError(`Can't read pixels: invalid buffer size`);\n\n        // bind the PBO\n        gl.bindBuffer(gl.PIXEL_PACK_BUFFER, pbo);\n        gl.bufferData(gl.PIXEL_PACK_BUFFER, arrayBuffer.byteLength, gl.STREAM_READ);\n\n        // read pixels into the PBO\n        if(fbo) {\n            gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n            gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, 0);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        }\n        else {\n            gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, 0);\n        }\n\n        // unbind the PBO\n        gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);\n\n        // wait for DMA transfer\n        return GLUtils.getBufferSubDataAsync(gl, pbo,\n            gl.PIXEL_PACK_BUFFER,\n            0,\n            arrayBuffer,\n            0,\n            0\n        ).then(timeInMs => {\n            return timeInMs;\n        }).catch(err => {\n            throw new IllegalOperationError(`Can't read pixels`, err);\n        }).finally(() => {\n            gl.deleteBuffer(pbo);\n        });\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * colors.js\n * Color routines & conversion algorithms\n */\n\nimport { SpeedyProgramGroup } from '../speedy-program-group';\nimport { importShader } from '../shader-declaration';\n\n\n\n//\n// Shaders\n//\n\n// Convert to greyscale\nconst rgb2grey = importShader('colors/rgb2grey.glsl').withArguments('image');\n\n\n\n\n/**\n * GPUColors\n * Color routines & conversion algorithms\n */\nexport class GPUColors extends SpeedyProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            // convert to greyscale\n            .declare('rgb2grey', rgb2grey)\n        ;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * encoders.js\n * Texture encoders\n */\n\nimport { SpeedyProgramGroup } from '../speedy-program-group';\nimport { importShader } from '../shader-declaration';\nimport { SpeedyFeature } from '../../core/speedy-feature';\nimport { BinaryDescriptor } from '../../core/speedy-descriptor';\nimport { StochasticTuner } from '../../core/tuners/stochastic-tuner';\nimport { Utils } from '../../utils/utils'\nimport { IllegalOperationError } from '../../utils/errors';\nimport { FIX_RESOLUTION, PYRAMID_MAX_LEVELS, LOG2_PYRAMID_MAX_SCALE, MAX_TEXTURE_LENGTH } from '../../utils/globals';\n\n// We won't admit more than MAX_KEYPOINTS per media.\n// The larger this value is, the more data we need to transfer from the GPU.\nconst MAX_DESCRIPTOR_SIZE = 64; // in bytes, must be divisible by 4 (1 pixel = 4 bytes)\nconst MAX_KEYPOINT_SIZE = 8 + MAX_DESCRIPTOR_SIZE; // in bytes, must be divisible by 4\nconst MAX_PIXELS_PER_KEYPOINT = (MAX_KEYPOINT_SIZE / 4) | 0; // in pixels\nconst MIN_ENCODER_LENGTH = 1;\nconst MAX_ENCODER_LENGTH = 300; // in pixels (if too large, WebGL may lose context - so be careful!)\nconst MAX_KEYPOINTS = ((MAX_ENCODER_LENGTH * MAX_ENCODER_LENGTH) / MAX_PIXELS_PER_KEYPOINT) | 0;\nconst INITIAL_ENCODER_LENGTH = 16; // pick a small number to reduce processing load and not crash things on mobile (WebGL lost context)\nconst KEYPOINT_BUFFER_LENGTH = 1024; // maximum number of keypoints that can be uploaded to the GPU via UBOs\nconst UBO_MAX_BYTES = 16384; // UBOs can hold at least 16KB of data (each keypoint uses 16 bytes)\n\n\n\n\n//\n// Shaders\n//\n\n// encode keypoint offsets: maxIterations is an integer in [1,255], determined experimentally\nconst encodeKeypointOffsets = importShader('encoders/encode-keypoint-offsets.glsl')\n                             .withArguments('image', 'imageSize', 'maxIterations');\n\n// encode keypoints\nconst encodeKeypoints = importShader('encoders/encode-keypoints.glsl')\n                       .withArguments('image', 'imageSize', 'encoderLength', 'descriptorSize', 'extraSize');\n\n// helper for downloading the keypoints\nconst downloadKeypoints = importShader('utils/identity.glsl')\n                         .withArguments('image');\n\n// upload keypoints via UBO\nconst uploadKeypoints = importShader('encoders/upload-keypoints.glsl')\n                       .withArguments('keypointCount', 'encoderLength', 'descriptorSize', 'extraSize')\n                       .withDefines({\n                           'KEYPOINT_BUFFER_LENGTH': KEYPOINT_BUFFER_LENGTH\n                       });\n\n\n\n\n/**\n * GPUEncoders\n * Keypoint encoding\n */\nexport class GPUEncoders extends SpeedyProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            .declare('_encodeKeypointOffsets', encodeKeypointOffsets)\n\n            // tiny textures\n            .declare('_encodeKeypoints', encodeKeypoints, {\n                ...this.program.hasTextureSize(INITIAL_ENCODER_LENGTH, INITIAL_ENCODER_LENGTH)\n            })\n            .declare('_downloadKeypoints', downloadKeypoints, {\n                ...this.program.hasTextureSize(INITIAL_ENCODER_LENGTH, INITIAL_ENCODER_LENGTH)\n            })\n            .declare('_uploadKeypoints', uploadKeypoints, {\n                ...this.program.hasTextureSize(INITIAL_ENCODER_LENGTH, INITIAL_ENCODER_LENGTH)\n            })\n        ;\n\n        // setup internal data\n        let neighborFn = (s) => Math.round(Utils.gaussianNoise(s, 64)) % 256;\n        this._tuner = new StochasticTuner(48, 32, 48, 0.2, 8, 60, neighborFn);\n        this._encoderLength = INITIAL_ENCODER_LENGTH;\n        this._spawnedAt = performance.now();\n        this._uploadBuffer = null; // lazy spawn\n    }\n\n    /**\n     * Keypoint encoder length\n     * @returns {number}\n     */\n    get encoderLength()\n    {\n        return this._encoderLength;\n    }\n\n    /**\n     * Optimizes the keypoint encoder for an expected number of keypoints\n     * @param {number} keypointCount expected number of keypoints (< 0 resets the encoder)\n     * @param {number} descriptorSize in bytes\n     * @param {number} extraSize in bytes\n     * @returns {boolean} true if the encoder has been optimized\n     */\n    optimize(keypointCount, descriptorSize, extraSize)\n    {\n        const newEncoderLength = this._minimumEncoderLength(keypointCount, descriptorSize, extraSize);\n        const oldEncoderLength = this._encoderLength;\n\n        this._encoderLength = newEncoderLength;\n        //console.log('optimized for', keypointCount, 'keypoints. length:', newEncoderLength);\n\n        return (newEncoderLength - oldEncoderLength) != 0;\n    }\n\n    /**\n     * Ensures that the encoder has enough capacity to deliver the specified number of keypoints\n     * @param {number} keypointCount the number of keypoints\n     * @param {number} descriptorSize in bytes\n     * @param {number} extraSize in bytes\n     * @returns {boolean} true if there was any change to the length of the encoder\n     */\n    reserveSpace(keypointCount, descriptorSize, extraSize)\n    {\n        // resize if not enough space\n        if(this._minimumEncoderLength(keypointCount, descriptorSize, extraSize) > this._encoderLength)\n            return this.optimize(keypointCount, descriptorSize, extraSize);\n\n        return false;\n    }\n\n    /**\n     * Encodes the keypoints of an image into a compressed texture\n     * @param {SpeedyTexture} corners texture with corners\n     * @param {number} descriptorSize in bytes\n     * @param {number} extraSize in bytes\n     * @returns {SpeedyTexture} texture with encoded keypoints\n     */\n    encodeKeypoints(corners, descriptorSize, extraSize)\n    {\n        // parameters\n        const encoderLength = this._encoderLength;\n        const imageSize = [ this._width, this._height ];\n        const maxIterations = this._tuner.currentValue(); // any value between 32 and 48 should work on PC & mobile\n\n        // encode offsets\n        const offsets = this._encodeKeypointOffsets(corners, imageSize, maxIterations);\n\n        // encode keypoints\n        this._encodeKeypoints.resize(this._encoderLength, this._encoderLength);\n        this._encodeKeypoints.clear(0, 0, 0, 0); // clear all pixels to 0\n        return this._encodeKeypoints(offsets, imageSize, encoderLength, descriptorSize, extraSize);\n    }\n\n    /**\n     * Decodes the keypoints, given a flattened image of encoded pixels\n     * @param {Uint8Array[]} pixels pixels in the [r,g,b,a,...] format\n     * @param {number} descriptorSize in bytes\n     * @param {number} extraSize in bytes\n     * @param {object} [output] optional output object\n     * @param {number[]} [output.userData] generic user-data related to the i-th keypoint\n     * @param {boolean[]} [output.discard] signals that the i-th keypoint should be discarded\n     * @returns {SpeedyFeature[]} keypoints\n     */\n    decodeKeypoints(pixels, descriptorSize, extraSize, output = {})\n    {\n        const pixelsPerKeypoint = 2 + (descriptorSize + extraSize) / 4;\n        let x, y, lod, rotation, score;\n        let hasLod, hasRotation;\n        let discardCount = 0;\n        const keypoints = [];\n\n        // initialize output arrays\n        if(output.userData != undefined)\n            output.userData.length = 0;\n        if(output.discard != undefined)\n            output.discard.length = 0;\n\n        // how many bytes should we read?\n        const e = this._encoderLength;\n        const e2 = e * e * pixelsPerKeypoint * 4;\n        const size = Math.min(pixels.length, e2);\n\n        // for each encoded keypoint\n        for(let i = 0; i < size; i += 4 /* RGBA */ * pixelsPerKeypoint) {\n            // extract fixed-point coordinates\n            x = (pixels[i+1] << 8) | pixels[i];\n            y = (pixels[i+3] << 8) | pixels[i+2];\n            if(x >= 0xFFFF && y >= 0xFFFF) // if end of list\n                break;\n\n            // We've cleared the texture to black.\n            // Likely to be incorrect black pixels\n            // due to resize. Bad for encoderLength\n            if(x + y == 0 && pixels[i+6] + pixels[i+5] == 0)\n                continue; // discard, it's noise\n\n            // convert from fixed-point\n            x /= FIX_RESOLUTION;\n            y /= FIX_RESOLUTION;\n\n            // emit signal to discard keypoints outside the image\n            const isDiscardedKeypoint = (x > MAX_TEXTURE_LENGTH || y > MAX_TEXTURE_LENGTH || x < 0 || y < 0);\n            if(output.discard != undefined)\n                output.discard.push(isDiscardedKeypoint);\n            if(output.discardCount != undefined && isDiscardedKeypoint)\n                output.discardCount[0] = ++discardCount;\n\n            // extract LOD\n            hasLod = (pixels[i+4] < 255);\n            lod = !hasLod ? 0.0 :\n                -LOG2_PYRAMID_MAX_SCALE + (LOG2_PYRAMID_MAX_SCALE + PYRAMID_MAX_LEVELS) * pixels[i+4] / 255.0;\n\n            // extract orientation\n            hasRotation = hasLod; // think of a better solution\n            rotation = !hasRotation ? 0.0 :\n                ((2 * pixels[i+5]) / 255.0 - 1.0) * Math.PI;\n\n            // extract score\n            score = pixels[i+6] / 255.0;\n\n            // extract generic user-data\n            if(output.userData != undefined) {\n                const data = pixels[i+7] / 255.0;\n                output.userData.push(data);\n            }\n\n            // extra pixels (TODO)\n            if(extraSize > 0) {\n                ;\n            }\n\n            // register keypoint, possibly with a descriptor\n            if(descriptorSize > 0) {\n                const offset = 8 + extraSize + i;\n                const bytes = new Uint8Array(pixels.slice(offset, offset + descriptorSize));\n                const descriptor = new BinaryDescriptor(bytes);\n                keypoints.push(new SpeedyFeature(x, y, lod, rotation, score, descriptor));\n            }\n            else\n                keypoints.push(new SpeedyFeature(x, y, lod, rotation, score));\n        }\n\n        // developer's secret ;)\n        // reset the tuner\n        if(keypoints.length == 0) {\n            if(this._tuner.finished())\n                this._tuner.reset();\n        }\n\n        // done!\n        return keypoints;\n    }\n\n    /**\n     * Download RAW encoded keypoint data from the GPU - this is a bottleneck!\n     * @param {SpeedyTexture} encodedKeypoints texture with keypoints that have already been encoded\n     * @param {boolean} [useAsyncTransfer] transfer data from the GPU without blocking the CPU\n     * @param {boolean} [useBufferedDownloads] optimize async transfers\n     * @returns {Promise<Uint8Array[]>} pixels in the [r,g,b,a, ...] format\n     */\n    async downloadEncodedKeypoints(encodedKeypoints, useAsyncTransfer = true, useBufferedDownloads = true)\n    {\n        try {\n            // helper shader for reading the data\n            this._downloadKeypoints.resize(this._encoderLength, this._encoderLength);\n            this._downloadKeypoints(encodedKeypoints);\n\n            // read data from the GPU\n            let downloadTime = performance.now(), pixels;\n            if(useAsyncTransfer)\n                pixels = await this._downloadKeypoints.readPixelsAsync(0, 0, -1, -1, useBufferedDownloads);\n            else\n                pixels = this._downloadKeypoints.readPixelsSync(); // bottleneck!\n            downloadTime = performance.now() - downloadTime;\n\n            // tuner: drop noisy feedback when the page loads\n            if(performance.now() >= this._spawnedAt + 2000)\n                this._tuner.feedObservation(downloadTime);\n\n            // debug\n            /*\n            window._p = window._p || 0;\n            window._m = window._m || 0;\n            window._m = 0.9 * window._m + 0.1 * downloadTime;\n            if(window._p++ % 50 == 0)\n                console.log(window._m, ' | ', maxIterations);\n            //console.log(JSON.stringify(this._tuner.info()));\n            */\n\n            // done!\n            return pixels;\n        }\n        catch(err) {\n            throw new IllegalOperationError(`Can't download encoded keypoint texture`, err);\n        }\n    }\n\n    /**\n     * Upload keypoints to the GPU\n     * The descriptor & orientation of the keypoints will be lost\n     * (need to recalculate)\n     * @param {SpeedyFeature[]} keypoints\n     * @param {number} descriptorSize in bytes\n     * @param {number} extraSize in bytes\n     * @returns {SpeedyTexture} encodedKeypoints\n     */\n    uploadKeypoints(keypoints, descriptorSize, extraSize)\n    {\n        // Create a buffer for uploading the data\n        if(this._uploadBuffer === null) {\n            const sizeofVec4 = Float32Array.BYTES_PER_ELEMENT * 4; // 16\n            const internalBuffer = new ArrayBuffer(sizeofVec4 * KEYPOINT_BUFFER_LENGTH);\n            Utils.assert(internalBuffer.byteLength <= UBO_MAX_BYTES);\n            this._uploadBuffer = new Float32Array(internalBuffer);\n        }\n\n        // Too many keypoints?\n        const keypointCount = keypoints.length;\n        if(keypointCount > KEYPOINT_BUFFER_LENGTH) {\n            // TODO: multipass\n            throw new NotSupportedError(`Can't upload ${keypointCount} keypoints: maximum is currently ${KEYPOINT_BUFFER_LENGTH}`);\n        }\n\n        // Format data as follows: (xpos, ypos, lod, score)\n        for(let i = 0; i < keypointCount; i++) {\n            const keypoint = keypoints[i];\n            const j = i * 4;\n\n            // this will be uploaded into a vec4\n            this._uploadBuffer[j]   = +(keypoint.x) || 0;\n            this._uploadBuffer[j+1] = +(keypoint.y) || 0;\n            this._uploadBuffer[j+2] = +(keypoint.lod) || 0;\n            this._uploadBuffer[j+3] = +(keypoint.score) || 0;\n        }\n\n        // Reserve space for the keypoints\n        this.reserveSpace(keypointCount, descriptorSize, extraSize);\n\n        // Upload data\n        this._uploadKeypoints.resize(this._encoderLength, this._encoderLength);\n        this._uploadKeypoints.setUBO('KeypointBuffer', this._uploadBuffer);\n        return this._uploadKeypoints(keypointCount, this._encoderLength, descriptorSize, extraSize);\n    }\n\n    /**\n     * The minimum encoder length for a set of keypoints\n     * @param {number} keypointCount\n     * @param {number} descriptorSize\n     * @param {number} extraSize\n     * @returns {number} between 1 and MAX_ENCODER_LENGTH\n     */\n    _minimumEncoderLength(keypointCount, descriptorSize, extraSize)\n    {\n        const clampedKeypointCount = Math.max(0, Math.min(Math.ceil(keypointCount), MAX_KEYPOINTS));\n        const pixelsPerKeypoint = Math.ceil(2 + (descriptorSize + extraSize) / 4);\n        const len = Math.ceil(Math.sqrt(clampedKeypointCount * pixelsPerKeypoint));\n\n        return Math.max(MIN_ENCODER_LENGTH, Math.min(len, MAX_ENCODER_LENGTH));\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * enhancements.js\n * Image enhancement methods\n */\n\nimport { SpeedyProgramGroup } from '../speedy-program-group';\nimport { importShader } from '../shader-declaration';\nimport { convX, convY } from '../shaders/filters/convolution';\nimport { PixelComponent } from '../../utils/types';\nimport { Utils } from '../../utils/utils';\nimport { IllegalArgumentError } from '../../utils/errors';\n\n\n//\n// Shaders\n//\n\n// Normalize image\nconst normalizeGreyscaleImage = importShader('enhancements/normalize-image.glsl')\n                               .withArguments('minmax2d', 'minValue', 'maxValue')\n                               .withDefines({ 'GREYSCALE': 1 });\nconst normalizeColoredImage = importShader('enhancements/normalize-image.glsl')\n                             .withArguments('minmax2dRGB', 'minValue', 'maxValue');\n\n// Nightvision\nconst nightvision = importShader('enhancements/nightvision.glsl')\n                   .withArguments('image', 'illuminationMap', 'gain', 'offset', 'decay');\nconst nightvisionGreyscale = importShader('enhancements/nightvision.glsl')\n                            .withArguments('image', 'illuminationMap', 'gain', 'offset', 'decay')\n                            .withDefines({ 'GREYSCALE': 1 });\n\n\n\n\n/**\n * GPUEnhancements\n * Image enhancement algorithms\n */\nexport class GPUEnhancements extends SpeedyProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            // normalize a greyscale image\n            .declare('_normalizeGreyscaleImage', normalizeGreyscaleImage)\n\n            // normalize a colored image\n            .declare('_normalizeColoredImage', normalizeColoredImage)\n\n            // nightvision\n            .declare('_nightvision', nightvision)\n            .declare('_nightvisionGreyscale', nightvisionGreyscale)\n            .compose('_illuminationMapLo', '_illuminationMapLoX', '_illuminationMapLoY')\n            .declare('_illuminationMapLoX', convX(Utils.gaussianKernel(80, 31)))\n            .declare('_illuminationMapLoY', convY(Utils.gaussianKernel(80, 31)))\n            .compose('_illuminationMap', '_illuminationMapX', '_illuminationMapY')\n            .declare('_illuminationMapX', convX(Utils.gaussianKernel(80, 63)))\n            .declare('_illuminationMapY', convY(Utils.gaussianKernel(80, 63)))\n            .compose('_illuminationMapHi', '_illuminationMapHiX', '_illuminationMapHiY')\n            .declare('_illuminationMapHiX', convX(Utils.gaussianKernel(80, 255)))\n            .declare('_illuminationMapHiY', convY(Utils.gaussianKernel(80, 255)))\n        ;\n    }\n\n    /**\n     * Normalize a greyscale image\n     * @param {SpeedyTexture} image greyscale image (RGB components are the same)\n     * @param {number} [minValue] minimum desired pixel intensity (from 0 to 255, inclusive)\n     * @param {number} [maxValue] maximum desired pixel intensity (from 0 to 255, inclusive)\n     * @returns {SpeedyTexture}\n     */\n    normalizeGreyscaleImage(image, minValue = 0, maxValue = 255)\n    {\n        const gpu = this._gpu;\n        const minmax2d = gpu.programs.utils._scanMinMax(image, PixelComponent.GREEN);\n        return this._normalizeGreyscaleImage(minmax2d, Math.min(minValue, maxValue), Math.max(minValue, maxValue));\n    }\n\n    /**\n     * Normalize a RGB image\n     * @param {SpeedyTexture} image\n     * @param {number} [minValue] minimum desired pixel intensity (from 0 to 255, inclusive)\n     * @param {number} [maxValue] maximum desired pixel intensity (from 0 to 255, inclusive)\n     * @returns {SpeedyTexture}\n     */\n    normalizeColoredImage(image, minValue = 0, maxValue = 255)\n    {\n        const gpu = this._gpu;\n        \n        // TODO: normalize on a luminance channel instead (e.g., use HSL color space)\n        const minmax2d = new Array(3);\n        minmax2d[0] = gpu.programs.utils.clone(gpu.programs.utils._scanMinMax(image, PixelComponent.RED));\n        minmax2d[1] = gpu.programs.utils.clone(gpu.programs.utils._scanMinMax(image, PixelComponent.GREEN));\n        minmax2d[2] = gpu.programs.utils._scanMinMax(image, PixelComponent.BLUE);\n\n        const normalized = this._normalizeColoredImage(minmax2d, Math.min(minValue, maxValue), Math.max(minValue, maxValue));\n\n        minmax2d[1].release();\n        minmax2d[0].release();\n\n        return normalized;\n    }\n\n    /**\n     * Nightvision filter: \"see in the dark\"\n     * @param {SpeedyTexture} image\n     * @param {number} [gain] typically in [0,1]; higher values => higher contrast\n     * @param {number} [offset] brightness, typically in [0,1]\n     * @param {number} [decay] gain decay, in the [0,1] range\n     * @param {string} [quality] \"high\" | \"medium\" | \"low\" (more quality -> more expensive)\n     * @param {boolean} [greyscale] use the greyscale variant of the algorithm\n     * @returns {SpeedyTexture}\n     */\n    nightvision(image, gain = 0.5, offset = 0.5, decay = 0.0, quality = 'medium', greyscale = false)\n    {\n        // compute illumination map\n        let illuminationMap = null;\n        if(quality == 'medium')\n            illuminationMap = this._illuminationMap(image);\n        else if(quality == 'high')\n            illuminationMap = this._illuminationMapHi(image);\n        else if(quality == 'low')\n            illuminationMap = this._illuminationMapLo(image);\n        else\n            throw new IllegalArgumentError(`Invalid quality level for nightvision: \"${quality}\"`);\n\n        // run nightvision\n        const strategy = greyscale ? this._nightvisionGreyscale : this._nightvision;\n        const enhancedImage = strategy(image, illuminationMap, gain, offset, decay);\n        return enhancedImage;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * filters.js\n * Image filtering on the GPU\n */\n\nimport { SpeedyProgramGroup } from '../speedy-program-group';\nimport { importShader } from '../shader-declaration';\nimport { convX, convY, texConvX, texConvY, texConv2D, createKernel2D, createKernel1D } from '../shaders/filters/convolution';\nimport { median } from '../shaders/filters/median';\nimport { Utils } from '../../utils/utils';\n\n\n\n//\n// Fast median filters\n//\n\n// Fast median filter: 3x3 window\nconst fastMedian3 = importShader('filters/fast-median.glsl')\n                   .withArguments('image')\n                   .withDefines({ 'WINDOW_SIZE': 3 });\n\n// Fast median filter: 5x5 window\nconst fastMedian5 = importShader('filters/fast-median.glsl')\n                   .withArguments('image')\n                   .withDefines({ 'WINDOW_SIZE': 5 });\n\n\n\n//\n// Utilities\n//\n\n// Handy conversion for Gaussian filters\nconst ksize2sigma = ksize => Math.max(1.0, ksize / 6.0);\n\n/**\n * GPUFilters\n * Image filtering\n */\nexport class GPUFilters extends SpeedyProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            // gaussian filters\n            .compose('gauss3', '_gauss3x', '_gauss3y') // size: 3x3 (sigma ~ 1.0)\n            .compose('gauss5', '_gauss5x', '_gauss5y') // size: 5x5 (sigma ~ 1.0)\n            .compose('gauss7', '_gauss7x', '_gauss7y') // size: 7x7\n            .compose('gauss9', '_gauss9x', '_gauss9y') // size: 9x9\n            .compose('gauss11', '_gauss11x', '_gauss11y') // size: 11x11\n\n            // box filters\n            .compose('box3', '_box3x', '_box3y') // size: 3x3\n            .compose('box5', '_box5x', '_box5y') // size: 5x5\n            .compose('box7', '_box7x', '_box7y') // size: 7x7\n            .compose('box9', '_box9x', '_box9y') // size: 9x9\n            .compose('box11', '_box11x', '_box11y') // size: 11x11\n\n            // median filters\n            .declare('median3', fastMedian3) // 3x3 window\n            .declare('median5', fastMedian5) // 5x5 window\n            .declare('median7', median(7)) // 7x7 window\n\n            // difference of gaussians\n            .compose('dog16_1', '_dog16_1x', '_dog16_1y') // sigma_2 / sigma_1 = 1.6 (approx. laplacian with sigma = 1)\n\n            // texture-based convolutions\n            .declare('texConv2D3', texConv2D(3), { // 2D convolution with a 3x3 texture-based kernel\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('texConv2D5', texConv2D(5), { // 2D convolution with a 5x5 texture-based kernel\n                ...this.program.usesPingpongRendering()\n            })\n            .declare('texConv2D7', texConv2D(7), { // 2D convolution with a 7x7 texture-based kernel\n                ...this.program.usesPingpongRendering()\n            })\n\n            // texture-based separable convolutions\n            .compose('texConvXY3', 'texConvX3', 'texConvY3') // 2D convolution with same 1D separable kernel in both axes\n            .declare('texConvX3', texConvX(3)) // 3x1 convolution, x-axis\n            .declare('texConvY3', texConvY(3)) // 1x3 convolution, y-axis\n            .compose('texConvXY5', 'texConvX5', 'texConvY5') // 2D convolution with same 1D separable kernel in both axes\n            .declare('texConvX5', texConvX(5)) // 5x1 convolution, x-axis\n            .declare('texConvY5', texConvY(5)) // 1x5 convolution, y-axis\n            .compose('texConvXY7', 'texConvX7', 'texConvY7') // 2D convolution with same 1D separable kernel in both axes\n            .declare('texConvX7', texConvX(7)) // 7x1 convolution, x-axis\n            .declare('texConvY7', texConvY(7)) // 1x7 convolution, y-axis\n            .compose('texConvXY9', 'texConvX9', 'texConvY9') // 2D convolution with same 1D separable kernel in both axes\n            .declare('texConvX9', texConvX(9)) // 9x1 convolution, x-axis\n            .declare('texConvY9', texConvY(9)) // 1x9 convolution, y-axis\n            .compose('texConvXY11', 'texConvX11', 'texConvY11') // 2D convolution with same 1D separable kernel in both axes\n            .declare('texConvX11', texConvX(11)) // 11x1 convolution, x-axis\n            .declare('texConvY11', texConvY(11)) // 1x11 convolution, y-axis\n\n            // create custom convolution kernels\n            .declare('createKernel3x3', createKernel2D(3), { // 3x3 texture kernel\n                ...(this.program.hasTextureSize(3, 3)),\n                ...(this.program.doesNotRecycleTextures())\n            })\n            .declare('createKernel5x5', createKernel2D(5), { // 5x5 texture kernel\n                ...(this.program.hasTextureSize(5, 5)),\n                ...(this.program.doesNotRecycleTextures())\n            })\n            .declare('createKernel7x7', createKernel2D(7), { // 7x7 texture kernel\n                ...(this.program.hasTextureSize(7, 7)),\n                ...(this.program.doesNotRecycleTextures())\n            })\n            .declare('createKernel3x1', createKernel1D(3), { // 3x1 texture kernel\n                ...(this.program.hasTextureSize(3, 1)),\n                ...(this.program.doesNotRecycleTextures())\n            })\n            .declare('createKernel5x1', createKernel1D(5), { // 5x1 texture kernel\n                ...(this.program.hasTextureSize(5, 1)),\n                ...(this.program.doesNotRecycleTextures())\n            })\n            .declare('createKernel7x1', createKernel1D(7), { // 7x1 texture kernel\n                ...(this.program.hasTextureSize(7, 1)),\n                ...(this.program.doesNotRecycleTextures())\n            })\n            .declare('createKernel9x1', createKernel1D(9), { // 9x1 texture kernel\n                ...(this.program.hasTextureSize(9, 1)),\n                ...(this.program.doesNotRecycleTextures())\n            })\n            .declare('createKernel11x1', createKernel1D(11), { // 11x1 texture kernel\n                ...(this.program.hasTextureSize(11, 1)),\n                ...(this.program.doesNotRecycleTextures())\n            })\n            /*.declare('_readKernel3x3', identity, { // for testing\n                ...(this.program.hasTextureSize(3, 3)),\n                ...(this.program.displaysGraphics())\n            })\n            .declare('_readKernel3x1', identity, {\n                ...(this.program.hasTextureSize(3, 1)),\n                ...(this.program.displaysGraphics())\n            })*/\n\n\n\n\n            // separable kernels (Gaussian)\n            // see also: http://dev.theomader.com/gaussian-kernel-calculator/\n            .declare('_gauss3x', convX([ // sigma ~ 1.0\n                0.25, 0.5, 0.25\n                //0.27901, 0.44198, 0.27901\n            ]))\n            .declare('_gauss3y', convY([\n                0.25, 0.5, 0.25\n                //0.27901, 0.44198, 0.27901\n            ]))\n            .declare('_gauss5x', convX([ // sigma ~ 1.0\n                0.05, 0.25, 0.4, 0.25, 0.05\n                //0.06136, 0.24477, 0.38774, 0.24477, 0.06136\n            ]))\n            .declare('_gauss5y', convY([\n                0.05, 0.25, 0.4, 0.25, 0.05\n                //0.06136, 0.24477, 0.38774, 0.24477, 0.06136\n            ]))\n            /*.declare('_gauss5', conv2D([ // for testing\n                1, 4, 7, 4, 1,\n                4, 16, 26, 16, 4,\n                7, 26, 41, 26, 7,\n                4, 16, 26, 16, 4,\n                1, 4, 7, 4, 1,\n            ], 1 / 237))*/\n            .declare('_gauss7x', convX(Utils.gaussianKernel(ksize2sigma(7), 7)))\n            .declare('_gauss7y', convY(Utils.gaussianKernel(ksize2sigma(7), 7)))\n            .declare('_gauss9x', convX(Utils.gaussianKernel(ksize2sigma(9), 9)))\n            .declare('_gauss9y', convY(Utils.gaussianKernel(ksize2sigma(9), 9)))\n            .declare('_gauss11x', convX(Utils.gaussianKernel(ksize2sigma(11), 11)))\n            .declare('_gauss11y', convY(Utils.gaussianKernel(ksize2sigma(11), 11)))\n\n\n\n\n            // separable kernels (Box filter)\n            .declare('_box3x', convX([\n                1, 1, 1\n            ], 1 / 3))\n            .declare('_box3y', convY([\n                1, 1, 1\n            ], 1 / 3))\n            .declare('_box5x', convX([\n                1, 1, 1, 1, 1\n            ], 1 / 5))\n            .declare('_box5y', convY([\n                1, 1, 1, 1, 1\n            ], 1 / 5))\n            .declare('_box7x', convX([\n                1, 1, 1, 1, 1, 1, 1\n            ], 1 / 7))\n            .declare('_box7y', convY([\n                1, 1, 1, 1, 1, 1, 1\n            ], 1 / 7))\n            .declare('_box9x', convX([\n                1, 1, 1, 1, 1, 1, 1, 1, 1\n            ], 1 / 9))\n            .declare('_box9y', convY([\n                1, 1, 1, 1, 1, 1, 1, 1, 1\n            ], 1 / 9))\n            .declare('_box11x', convX([\n                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\n            ], 1 / 11))\n            .declare('_box11y', convY([\n                1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\n            ], 1 / 11))\n\n\n            // difference of gaussians (DoG)\n            // sigma_2 (1.6) - sigma_1 (1.0) => approximates laplacian of gaussian (LoG)\n            .declare('_dog16_1x', convX([\n                0.011725, 0.038976, 0.055137, -0.037649, -0.136377, -0.037649, 0.055137, 0.038976, 0.011725\n            ]))\n            .declare('_dog16_1y', convY([\n                0.011725, 0.038976, 0.055137, -0.037649, -0.136377, -0.037649, 0.055137, 0.038976, 0.011725\n            ]))\n        ;\n    }\n}\n","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * keypoints.js\n * Facade for various keypoint detection algorithms\n */\n\nimport { SpeedyProgramGroup } from '../speedy-program-group';\nimport { importShader } from '../shader-declaration';\nimport { Utils } from '../../utils/utils';\n\n\n\n//\n// FAST corner detector\n//\n\n// FAST-9_16: requires 9 contiguous pixels\n// on a circumference of 16 pixels\nconst fast9 = importShader('keypoints/fast9lg.glsl').withArguments('image', 'threshold');\n\n// FAST-7_12: requires 7 contiguous pixels\n// on a circumference of 12 pixels\nconst fast7 = importShader('keypoints/fast7.glsl').withArguments('image', 'threshold');\n\n// FAST-5_8: requires 5 contiguous pixels\n// on a circumference of 8 pixels\nconst fast5 = importShader('keypoints/fast5.glsl').withArguments('image', 'threshold');\n\n// compute corner score considering a\n// neighboring circumference of 16 pixels\nconst fastScore16 = importShader('keypoints/fast-score16.glsl').withArguments('image', 'threshold');\n\n// compute corner score considering a\n// neighboring circumference of 12 pixels\nconst fastScore12 = importShader('keypoints/fast-score12.glsl').withArguments('image', 'threshold');\n\n// compute corner score considering a\n// neighboring circumference of 8 pixels\nconst fastScore8 = importShader('keypoints/fast-score8.glsl').withArguments('image', 'threshold');\n\n// FAST-9_16 on scale-space\n// Requires image mipmap\nconst multiscaleFast = importShader('keypoints/multiscale-fast.glsl')\n                      .withArguments('pyramid', 'threshold', 'numberOfOctaves');\n\n// FAST-9_16 on scale-space\n// with Harris scoring\nconst multiscaleFastWithHarris = importShader('keypoints/multiscale-fast.glsl')\n                                .withArguments('pyramid', 'threshold', 'numberOfOctaves')\n                                .withDefines({\n                                    'USE_HARRIS_SCORE': 1\n                                });\n\n\n\n//\n// Harris-Shi-Tomasi corner detector\n//\n\n// compute corner responses (score map)\nconst multiscaleHarris = importShader('keypoints/multiscale-harris.glsl')\n                        .withArguments('pyramid', 'windowSize', 'numberOfOctaves', 'sobelDerivatives');\n\n// discard corners below a specified quality level\nconst harrisCutoff = importShader('keypoints/harris-cutoff.glsl').withArguments('corners', 'maxScore', 'quality');\n\n\n\n//\n// BRISK feature detection\n//\nconst brisk = importShader('keypoints/brisk.glsl')\n             .withArguments('image', 'layerA', 'layerB', 'scaleA', 'scaleB', 'lgM', 'h');\n\n\n\n//\n// ORB feature description\n//\nconst orb = importShader('keypoints/orb-descriptor.glsl')\n           .withArguments('pyramid', 'encodedCorners', 'extraSize', 'encoderLength');\n\n\n\n//\n// Generic keypoint routines\n//\n\n// non-maximum suppression\nconst nonmaxSuppression = importShader('keypoints/nonmax-suppression.glsl').withArguments('image');\nconst multiscaleSuppression = importShader('keypoints/multiscale-suppression.glsl').withArguments('image');\nconst samescaleSuppression = importShader('keypoints/samescale-suppression.glsl').withArguments('image');\n\n// Sobel derivatives\nconst multiscaleSobel = importShader('filters/multiscale-sobel.glsl').withArguments('pyramid', 'lod');\n\n// compute keypoint orientation\nconst orientationViaCentroid = importShader('keypoints/orientation-via-centroid.glsl')\n                              .withArguments('pyramid', 'encodedKeypoints', 'patchRadius', 'descriptorSize', 'extraSize', 'encoderLength')\n\n\n\n\n/**\n * GPUKeypoints\n * Keypoint detection\n */\nexport class GPUKeypoints extends SpeedyProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            // FAST-9,16\n            .compose('fast9', '_fast9', '_fastScore16')\n            .declare('_fast9', fast9) // find corners\n            .declare('_fastScore16', fastScore16) // compute scores\n\n            // FAST-7,12\n            .compose('fast7', '_fast7', '_fastScore12')\n            .declare('_fast7', fast7)\n            .declare('_fastScore12', fastScore12)\n\n            // FAST-5,8\n            .compose('fast5', '_fast5', '_fastScore8')\n            .declare('_fast5', fast5)\n            .declare('_fastScore8', fastScore8)\n\n            // FAST-9,16 (multi-scale)\n            .declare('multiscaleFast', multiscaleFast)\n            .declare('multiscaleFastWithHarris', multiscaleFastWithHarris)\n\n            // BRISK Scale-Space Non-Maximum Suppression & Interpolation\n            .declare('brisk', brisk)\n\n            // Harris-Shi-Tomasi corner detector\n            .declare('multiscaleHarris', multiscaleHarris) // scale-space\n            .declare('harrisCutoff', harrisCutoff)\n\n            // ORB\n            .declare('_orb', orb)\n\n            // Generic non-maximum suppression\n            .declare('nonmaxSuppression', nonmaxSuppression)\n            .declare('multiscaleSuppression', multiscaleSuppression) // scale-space\n            .declare('samescaleSuppression', samescaleSuppression) // scale-space\n\n            // Sobel derivatives\n            .declare('multiscaleSobel', multiscaleSobel, {\n                ...this.program.doesNotRecycleTextures()\n            }) // scale-space\n\n            // Compute keypoint orientation\n            .declare('_orientationViaCentroid', orientationViaCentroid);\n        ;\n    }\n\n    /**\n     * Compute ORB descriptor (256 bits)\n     * @param {SpeedyTexture} pyramid pre-smoothed on the intensity channel\n     * @param {SpeedyTexture} encodedKeypoints tiny texture\n     * @param {number} descriptorSize in bytes\n     * @param {number} extraSize in bytes\n     * @param {number} encoderLength\n     * @returns {SpeedyTexture}\n     */\n    orb(pyramid, encodedKeypoints, descriptorSize, extraSize, encoderLength)\n    {\n        Utils.assert(descriptorSize === 32);\n        this._orb.resize(encoderLength, encoderLength);\n        return this._orb(pyramid, encodedKeypoints, extraSize, encoderLength);\n    }\n\n    /**\n     * Finds the orientation of all keypoints given a texture with encoded keypoints\n     * (using the centroid method)\n     * @param {SpeedyTexture} pyramid image pyramid\n     * @param {SpeedyTexture} encodedKeypoints tiny texture\n     * @param {number} patchRadius radius of a circular patch used to compute the radius when lod = 0 (e.g., 7)\n     * @param {number} descriptorSize in bytes\n     * @param {number} extraSize in bytes\n     * @param {number} encoderLength\n     * @returns {SpeedyTexture}\n     */\n    orientationViaCentroid(pyramid, encodedKeypoints, patchRadius, descriptorSize, extraSize, encoderLength)\n    {\n        this._orientationViaCentroid.resize(encoderLength, encoderLength);\n        return this._orientationViaCentroid(pyramid, encodedKeypoints, patchRadius, descriptorSize, extraSize, encoderLength);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * pyramids.js\n * Image pyramids\n */\n\nimport { SpeedyProgramGroup } from '../speedy-program-group';\nimport { importShader } from '../shader-declaration';\nimport { convX, convY } from '../shaders/filters/convolution';\n\n\n\n//\n// Shaders\n//\n\n// pyramid generation\nconst upsample2 = importShader('pyramids/upsample2.glsl').withArguments('image');\nconst downsample2 = importShader('pyramids/downsample2.glsl').withArguments('image');\nconst upsample3 = importShader('pyramids/upsample3.glsl').withArguments('image');\nconst downsample3 = importShader('pyramids/downsample3.glsl').withArguments('image');\n\n// debug\nconst flipY = importShader('utils/flip-y.glsl').withArguments('image');\n\n\n\n/**\n * GPUPyramids\n * Image pyramids\n */\nexport class GPUPyramids extends SpeedyProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            // pyramid operations (scale = 2)\n            .compose('reduce', '_smoothX', '_smoothY', '_downsample2')\n            .compose('expand', '_upsample2', '_smoothX2', '_smoothY2')\n           \n            // intra-pyramid operations (scale = 1.5)\n            .compose('intraReduce', '_upsample2', '_smoothX2', '_smoothY2', '_downsample3/2')\n            .compose('intraExpand', '_upsample3', '_smoothX3', '_smoothY3', '_downsample2/3')\n\n            // kernels for debugging\n            .declare('output1', flipY, {\n                ...this.program.hasTextureSize(this._width, this._height),\n                ...this.program.displaysGraphics()\n            })\n\n            .declare('output2', flipY, {\n                ...this.program.hasTextureSize(2 * this._width, 2 * this._height),\n                ...this.program.displaysGraphics()\n            })\n\n            .declare('output3', flipY, {\n                ...this.program.hasTextureSize(3 * this._width, 3 * this._height),\n                ...this.program.displaysGraphics()\n            })\n\n\n            \n            // separable kernels for gaussian smoothing\n            // use [c, b, a, b, c] where a+2c = 2b and a+2b+2c = 1\n            // pick a = 0.4 for gaussian approximation\n            .declare('_smoothX', convX([\n                0.05, 0.25, 0.4, 0.25, 0.05\n            ]))\n            .declare('_smoothY', convY([\n                0.05, 0.25, 0.4, 0.25, 0.05\n            ]))\n\n            // smoothing for 2x image\n            // same rules as above with sum(k) = 2\n            .declare('_smoothX2', convX([\n                0.1, 0.5, 0.8, 0.5, 0.1\n            ]), this.program.hasTextureSize(2 * this._width, 2 * this._height))\n\n            .declare('_smoothY2', convY([\n                0.1, 0.5, 0.8, 0.5, 0.1\n            ], 1.0 / 2.0), this.program.hasTextureSize(2 * this._width, 2 * this._height))\n\n            // smoothing for 3x image\n            // use [1-b, b, 1, b, 1-b], where 0 < b < 1\n            .declare('_smoothX3', convX([\n                0.2, 0.8, 1.0, 0.8, 0.2\n            ]), this.program.hasTextureSize(3 * this._width, 3 * this._height))\n\n            .declare('_smoothY3', convY([\n                0.2, 0.8, 1.0, 0.8, 0.2\n            ], 1.0 / 3.0), this.program.hasTextureSize(3 * this._width, 3 * this._height))\n\n            // upsampling & downsampling\n            .declare('_upsample2', upsample2,\n                this.program.hasTextureSize(2 * this._width, 2 * this._height))\n\n            .declare('_downsample2', downsample2,\n                this.program.hasTextureSize((1 + this._width) / 2, (1 + this._height) / 2))\n\n            .declare('_upsample3', upsample3,\n                this.program.hasTextureSize(3 * this._width, 3 * this._height))\n\n            .declare('_downsample3', downsample3,\n                this.program.hasTextureSize((2 + this._width) / 3, (2 + this._height) / 3))\n\n            .declare('_downsample2/3', downsample2,\n                this.program.hasTextureSize(3 * this._width / 2, 3 * this._height / 2))\n\n            .declare('_downsample3/2', downsample3,\n                this.program.hasTextureSize(2 * this._width / 3, 2 * this._height / 3))\n        ;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * trackers.js\n * Feature trackers\n */\n\nimport { SpeedyProgramGroup } from '../speedy-program-group';\nimport { importShader } from '../shader-declaration';\nimport { PYRAMID_MAX_LEVELS } from '../../utils/globals';\n\n\n\n//\n// Shaders\n//\n\n// LK\nconst LK_MAX_WINDOW_SIZE = 21; // 21x21 window\nconst LK_MAX_WINDOW_SIZE_SMALL = 15; // 15x15 window - the smaller the window, the easier it is on the GPU\nconst LK_MAX_WINDOW_SIZE_SMALLER = 11; // 11x11 window - works best on mobile\nconst LK_MAX_WINDOW_SIZE_SMALLEST = 7; // 7x7 window\nconst LK_MIN_WINDOW_SIZE = 5; // 5x5 window: (-2, -1, 0, 1, 2) x (-2, -1, 0, 1, 2)\nconst LK_MAX_KEYPOINTS_PER_PASS = 100;\n\nconst lk = importShader('trackers/lk.glsl')\n           .withArguments('nextPyramid', 'prevPyramid', 'prevKeypoints', 'windowSize', 'depth', 'firstKeypointIndex', 'lastKeypointIndex', 'descriptorSize', 'extraSize', 'encoderLength')\n           .withDefines({\n               'MAX_WINDOW_SIZE': LK_MAX_WINDOW_SIZE\n           });\n\nconst lkDiscard = importShader('trackers/lk-discard.glsl')\n                  .withArguments('pyramid', 'encodedKeypoints', 'windowSize', 'discardThreshold', 'firstKeypointIndex', 'lastKeypointIndex', 'descriptorSize', 'extraSize', 'encoderLength')\n                  .withDefines({\n                      'MAX_WINDOW_SIZE': LK_MAX_WINDOW_SIZE\n                  });\n\nconst lkSmall = importShader('trackers/lk.glsl')\n                .withArguments('nextPyramid', 'prevPyramid', 'prevKeypoints', 'windowSize', 'depth', 'firstKeypointIndex', 'lastKeypointIndex', 'descriptorSize', 'extraSize', 'encoderLength')\n                .withDefines({\n                    'MAX_WINDOW_SIZE': LK_MAX_WINDOW_SIZE_SMALL\n                });\n\nconst lkDiscardSmall = importShader('trackers/lk-discard.glsl')\n                       .withArguments('pyramid', 'encodedKeypoints', 'windowSize', 'discardThreshold', 'firstKeypointIndex', 'lastKeypointIndex', 'descriptorSize', 'extraSize', 'encoderLength')\n                       .withDefines({\n                           'MAX_WINDOW_SIZE': LK_MAX_WINDOW_SIZE_SMALL\n                       });\n\nconst lkSmaller = importShader('trackers/lk.glsl')\n                  .withArguments('nextPyramid', 'prevPyramid', 'prevKeypoints', 'windowSize', 'depth', 'firstKeypointIndex', 'lastKeypointIndex', 'descriptorSize', 'extraSize', 'encoderLength')\n                  .withDefines({\n                      'MAX_WINDOW_SIZE': LK_MAX_WINDOW_SIZE_SMALLER\n                  });\n\nconst lkDiscardSmaller = importShader('trackers/lk-discard.glsl')\n                         .withArguments('pyramid', 'encodedKeypoints', 'windowSize', 'discardThreshold', 'firstKeypointIndex', 'lastKeypointIndex', 'descriptorSize', 'extraSize', 'encoderLength')\n                         .withDefines({\n                             'MAX_WINDOW_SIZE': LK_MAX_WINDOW_SIZE_SMALLER\n                         });\n\nconst lkSmallest = importShader('trackers/lk.glsl')\n                   .withArguments('nextPyramid', 'prevPyramid', 'prevKeypoints', 'windowSize', 'depth', 'firstKeypointIndex', 'lastKeypointIndex', 'descriptorSize', 'extraSize', 'encoderLength')\n                   .withDefines({\n                       'MAX_WINDOW_SIZE': LK_MAX_WINDOW_SIZE_SMALLEST\n                   });\n\nconst lkDiscardSmallest = importShader('trackers/lk-discard.glsl')\n                          .withArguments('pyramid', 'encodedKeypoints', 'windowSize', 'discardThreshold', 'firstKeypointIndex', 'lastKeypointIndex', 'descriptorSize', 'extraSize', 'encoderLength')\n                          .withDefines({\n                              'MAX_WINDOW_SIZE': LK_MAX_WINDOW_SIZE_SMALLEST\n                          });\n\n/**\n * GPUTrackers\n * Feature trackers\n */\nexport class GPUTrackers extends SpeedyProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            // LK\n            .declare('_lk', lk)\n            .declare('_lkSmall', lkSmall)\n            .declare('_lkSmaller', lkSmaller)\n            .declare('_lkSmallest', lkSmallest)\n            .declare('_lkDiscard', lkDiscard)\n            .declare('_lkDiscardSmall', lkDiscardSmall)\n            .declare('_lkDiscardSmaller', lkDiscardSmaller)\n            .declare('_lkDiscardSmallest', lkDiscardSmallest)\n        ;\n    }\n\n    /**\n     * LK feature tracker\n     * @param {SpeedyTexture} nextPyramid image pyramid at time t\n     * @param {SpeedyTexture} prevPyramid image pyramid at time t-1\n     * @param {SpeedyTexture} prevKeypoints tiny texture of encoded keypoints at time t-1\n     * @param {number} windowSize neighborhood size, an odd number (5, 7, 9, 11...)\n     * @param {number} depth how many pyramid layers will be scanned\n     * @param {number} discardThreshold used to discard \"bad\" keypoints, typically 10^(-4)\n     * @param {number} descriptorSize in bytes\n     * @param {number} extraSize in bytes\n     * @param {number} encoderLength\n     * @returns {SpeedyTexture}\n     */\n    lk(nextPyramid, prevPyramid, prevKeypoints, windowSize, depth, discardThreshold, descriptorSize, extraSize, encoderLength)\n    {\n        // make sure we get a proper depth\n        const MIN_DEPTH = 1, MAX_DEPTH = PYRAMID_MAX_LEVELS;\n        depth = Math.max(MIN_DEPTH, Math.min(depth | 0, MAX_DEPTH));\n\n        // windowSize must be a positive odd number\n        windowSize = windowSize + ((windowSize + 1) % 2);\n        windowSize = Math.max(LK_MIN_WINDOW_SIZE, Math.min(windowSize, LK_MAX_WINDOW_SIZE));\n\n        // select programs\n        let lk = '_lk', lkDiscard = '_lkDiscard';\n        if(windowSize <= LK_MAX_WINDOW_SIZE_SMALLEST) {\n            lk = '_lkSmallest'; lkDiscard = '_lkDiscardSmallest';\n        }\n        else if(windowSize <= LK_MAX_WINDOW_SIZE_SMALLER) {\n            lk = '_lkSmaller'; lkDiscard = '_lkDiscardSmaller';\n        }\n        else if(windowSize <= LK_MAX_WINDOW_SIZE_SMALL) {\n            lk = '_lkSmall'; lkDiscard = '_lkDiscardSmall';\n        }\n\n        // resize programs\n        this[lk].resize(encoderLength, encoderLength);\n        this[lkDiscard].resize(encoderLength, encoderLength);\n\n        //\n        // Optimization!\n        // because this is such a demanding algorithm, we'll\n        // split the work into multiple passes of the shaders\n        // (so we don't get WebGL context loss on mobile)\n        //\n        const pixelsPerKeypoint = 2 + (descriptorSize + extraSize) / 4;\n        const numKeypointsApprox = encoderLength * encoderLength / pixelsPerKeypoint;\n        const numPasses = Math.ceil(Math.max(1, numKeypointsApprox) / LK_MAX_KEYPOINTS_PER_PASS);\n        //console.log('num passes', numPasses, lk);\n\n        // for each pass\n        let nextKeypoints = prevKeypoints;\n        for(let i = 0; i < numPasses; i++) {\n            const firstKeypointIndex = i * LK_MAX_KEYPOINTS_PER_PASS;\n            const lastKeypointIndex = firstKeypointIndex + LK_MAX_KEYPOINTS_PER_PASS - 1;\n\n            // compute optical-flow\n            nextKeypoints = (this[lk])(nextPyramid, prevPyramid, nextKeypoints, windowSize, depth, firstKeypointIndex, lastKeypointIndex, descriptorSize, extraSize, encoderLength);\n\n            // discard \"bad\" keypoints\n            nextKeypoints = (this[lkDiscard])(nextPyramid, nextKeypoints, windowSize, discardThreshold, firstKeypointIndex, lastKeypointIndex, descriptorSize, extraSize, encoderLength);\n        }\n\n        // done!\n        return nextKeypoints;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * utils.js\n * GPU utilities\n */\n\nimport { SpeedyProgramGroup } from '../speedy-program-group';\nimport { importShader } from '../shader-declaration';\nimport { GLUtils } from '../gl-utils';\nimport { PixelComponent, ColorComponentId } from '../../utils/types';\nimport { IllegalArgumentError } from '../../utils/errors';\n\n\n\n//\n// Shaders\n//\n\n// Identity shader: no-operation\nconst identity = importShader('utils/identity.glsl').withArguments('image');\n\n// Flip y-axis for output\nconst flipY = importShader('utils/flip-y.glsl').withArguments('image');\n\n// Fill image with a constant\nconst fill = importShader('utils/fill.glsl').withArguments('value');\n\n// Fill zero or more color components of the input image with a constant value\nconst fillComponents = importShader('utils/fill-components.glsl').withArguments('image', 'pixelComponents', 'value');\n\n// Copy the src component of src to zero or more color components of a copy of dest\nconst copyComponents = importShader('utils/copy-components.glsl').withArguments('dest', 'src', 'destComponents', 'srcComponentId');\n\n// Scan the entire image and find the minimum & maximum pixel intensity for each row and column\n//const scanMinMax1D = importShader('utils/scan-minmax1d.glsl').withArguments('image', 'iterationNumber');\n\n// Scan the entire image and find the minimum & maximum pixel intensity\nconst scanMinMax2D = importShader('utils/scan-minmax2d.glsl').withArguments('image', 'iterationNumber');\n\n\n\n/**\n * GPUUtils\n * Utility operations\n */\nexport class GPUUtils extends SpeedyProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} width\n     * @param {number} height\n     */\n    constructor(gpu, width, height)\n    {\n        super(gpu, width, height);\n        this\n            // no-operation\n            .declare('identity', identity)\n\n            // output a texture from a pipeline\n            .declare('output', flipY, {\n                ...this.program.displaysGraphics()\n            })\n                \n            // clone a texture (release it afterwards)\n            .declare('clone', identity, {\n                ...this.program.doesNotRecycleTextures()\n            })\n\n            // flip y-axis\n            .declare('flipY', flipY)\n\n            // Fill image with a constant\n            .declare('fill', fill)\n\n            // Fill zero or more color components of the input image with a constant value\n            .declare('fillComponents', fillComponents)\n\n            // Copy the src component of src to zero or more color components of a copy of dest\n            .declare('_copyComponents', copyComponents)\n\n            // find minimum & maximum pixel intensity for each row and column\n            /*.declare('_scanMinMax1D', scanMinMax1D, {\n                ...this.program.usesPingpongRendering()\n            })*/\n\n            // find minimum & maximum pixel intensity\n            .declare('_scanMinMax2D', scanMinMax2D, {\n                ...this.program.usesPingpongRendering()\n            })\n        ;\n    }\n\n    /**\n     * Scan a single component in all pixels of the image and find the maximum intensity\n     * @param {SpeedyTexture} image \n     * @param {number} pixelComponent a single PixelComponent flag\n     * @returns {SpeedyTexture} such that pixel[component] = max(image_pixel[component])\n     *                                                           for all image_pixels\n     */\n    scanMax(image, pixelComponent)\n    {\n        const minmax2d = this._scanMinMax(image, pixelComponent);\n        return this.copyComponents(image, minmax2d, pixelComponent, PixelComponent.RED);\n    }\n\n    /**\n     * Scan a single component in all pixels of the image and find the minimum intensity\n     * @param {SpeedyTexture} image \n     * @param {number} pixelComponent a single PixelComponent flag\n     * @returns {SpeedyTexture} such that pixel[component] = min(image_pixel[component])\n     *                                                           for all image_pixels\n     */\n    scanMin(image, pixelComponent)\n    {\n        const minmax2d = this._scanMinMax(image, pixelComponent);\n        return this.copyComponents(image, minmax2d, pixelComponent, PixelComponent.GREEN);\n    }\n\n    /**\n     * Copy color component\n     * @param {SpeedyTexture} dest\n     * @param {SpeedyTexture} src \n     * @param {number} destComponents one or more PixelComponent flags\n     * @param {number} srcComponent a single PixelComponent flag\n     * @returns {SpeedyTexture} a copy of dest with its destComponents replaced by the srcComponent of src\n     */\n    copyComponents(dest, src, destComponents, srcComponent)\n    {\n        if(!ColorComponentId.hasOwnProperty(srcComponent))\n            throw new IllegalArgumentError(`Invalid srcComponent: ${srcComponent}`)\n\n        const srcComponentId = ColorComponentId[srcComponent];\n        return this._copyComponents(dest, src, destComponents, srcComponentId);\n    }\n\n    /**\n     * Scan a single component in all pixels of the image and find the min & max intensities\n     * @param {SpeedyTexture} image \n     * @param {number} pixelComponent a single PixelComponent flag\n     * @returns {SpeedyTexture} RGBA = (max, min, max - min, original_pixel)\n     */\n    _scanMinMax(image, pixelComponent)\n    {\n        //\n        // FIXME: combinations of PixelComponent (e.g., PixelComponent.ALL)\n        //        are currently unsupported. Make separate calls.\n        //\n        const numIterations = Math.ceil(Math.log2(Math.max(this._width, this._height))) | 0;\n        let texture = this.copyComponents(image, image, PixelComponent.ALL, pixelComponent);\n\n        for(let i = 0; i < numIterations; i++)\n            texture = this._scanMinMax2D(texture, i);\n\n        return texture;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * shader-declaration.js\n * Encapsulates a shader declaration\n */\n\nimport { ShaderPreprocessor } from './shader-preprocessor';\nimport { FileNotFoundError, IllegalArgumentError, ParseError } from '../utils/errors';\n\nconst ATTRIB_POSITION = 'a_position';\nconst ATTRIB_TEXCOORD = 'a_texCoord';\n\nconst DEFAULT_VERTEX_SHADER = `#version 300 es\nin vec2 ${ATTRIB_POSITION};\nin vec2 ${ATTRIB_TEXCOORD};\nout vec2 texCoord;\n\nvoid main() {\n    gl_Position = vec4(${ATTRIB_POSITION}, 0.0, 1.0);\n    texCoord = ${ATTRIB_TEXCOORD};\n}`;\n\nconst DEFAULT_FRAGMENT_SHADER_PREFIX = `#version 300 es\nprecision highp int;\nprecision mediump float;\nprecision mediump sampler2D;\n\nout vec4 color;\nin vec2 texCoord;\nuniform vec2 texSize;\n\n@include \"global.glsl\"\\n`;\n\n/**\n * Shader Declaration\n */\nclass ShaderDeclaration\n{\n    /* private */ constructor(options)\n    {\n        const filepath = options.filepath || null;\n        const source = filepath ? require('./shaders/' + filepath) : (options.source || '');\n\n        this._userSource = source;\n        this._fragmentSource = ShaderPreprocessor.run(DEFAULT_FRAGMENT_SHADER_PREFIX + source);\n        this._vertexSource = ShaderPreprocessor.run(DEFAULT_VERTEX_SHADER);\n        this._filepath = filepath || '<in-memory>';\n        this._uniform = this._autodetectUniforms(this._fragmentSource);\n        this._arguments = [];\n    }\n\n    /**\n     * Creates a new Shader directly from a GLSL source\n     * @param {string} source\n     * @returns {Shader}\n     */\n    static create(source)\n    {\n        return new ShaderDeclaration({ source });\n    }\n\n    /**\n     * Import a Shader from a file containing a GLSL source\n     * @param {string} filepath path to .glsl file relative to the shaders/ folder\n     * @returns {Shader}\n     */\n    static import(filepath)\n    {\n        if(!String(filepath).match(/^[a-zA-Z0-9_\\-\\/]+\\.glsl$/))\n            throw new FileNotFoundError(`Can't import shader: \"${filepath}\"`);\n\n        return new ShaderDeclaration({ filepath });\n    }\n\n    /**\n     * Specify the list & order of arguments to be\n     * passed to the shader\n     * @param  {...string} args argument names\n     * @returns {ShaderDeclaration} this\n     */\n    withArguments(...args)\n    {\n        // get arguments\n        this._arguments = args.map(arg => String(arg));\n\n        // validate\n        for(const argname of this._arguments) {\n            if(!this._uniform.hasOwnProperty(argname)) {\n                if(!this._uniform.hasOwnProperty(argname + '[0]'))\n                    throw new IllegalArgumentError(`Argument \"${argname}\" has not been declared in the shader`);\n            }\n        }\n\n        // done!\n        return this;\n    }\n\n    /**\n     * Specify a set of #defines to be prepended to\n     * the fragment shader\n     * @param {object} defines key-value pairs (define-name: define-value)\n     * @returns {ShaderDeclaration} this\n     */\n    withDefines(defines)\n    {\n        // write the #defines\n        const defs = [];\n        for(const key of Object.keys(defines))\n            defs.push(`#define ${key} ${defines[key]}\\n`);\n\n        // change the fragment shader\n        const source = DEFAULT_FRAGMENT_SHADER_PREFIX + defs.join('') + this._userSource;\n        this._fragmentSource = ShaderPreprocessor.run(source);\n        // is it necessary to rescan the code for uniforms? hmm....\n\n        // done!\n        return this;\n    }\n\n    /**\n     * Return the GLSL source of the fragment shader\n     * @returns {string}\n     */\n    get fragmentSource()\n    {\n        return this._fragmentSource;\n    }\n\n    /**\n     * Return the GLSL source of the vertex shader\n     * @returns {string}\n     */\n    get vertexSource()\n    {\n        return this._vertexSource;\n    }\n\n    /**\n     * Get the names of the vertex shader attributes\n     * @returns {object}\n     */\n    get attributes()\n    {\n        return ShaderDeclaration._attr || (ShaderDeclaration._attr = Object.freeze({\n            position: ATTRIB_POSITION,\n            texCoord: ATTRIB_TEXCOORD,\n        }));\n    }\n\n    /**\n     * Names of the arguments that will be passed to the Shader,\n     * corresponding to GLSL uniforms, in the order they will be passed\n     * @returns {Array<string>}\n     */\n    get arguments()\n    {\n        return this._arguments;\n    }\n\n    /**\n     * Names of the uniforms declared in the shader\n     * @returns {Array<string>}\n     */\n    get uniforms()\n    {\n        return Object.keys(this._uniform);\n    }\n\n    /**\n     * The GLSL type of an uniform variable declared in the shader\n     * @param {string} name\n     * @returns {string}\n     */\n    uniformType(name)\n    {\n        if(!this._uniform.hasOwnProperty(name))\n            throw new IllegalArgumentError(`Unrecognized uniform variable: \"${name}\"`);\n\n        return this._uniform[name];\n    }\n\n    /**\n     * Parses a GLSL source and detects the uniform variables,\n     * as well as their types\n     * @param {string} preprocessedSource \n     * @returns {object} specifies the types of all uniforms\n     */\n    _autodetectUniforms(preprocessedSource)\n    {\n        const sourceWithoutComments = preprocessedSource; // assume we've preprocessed the source already\n        const regex = /^\\s*uniform\\s+(highp\\s+|mediump\\s+|lowp\\s+)?(\\w+)\\s+([^;]+)/gm;\n        const uniforms = { };\n\n        let match;\n        while((match = regex.exec(sourceWithoutComments)) !== null) {\n            const type = match[2];\n            const names = match[3].split(',').map(name => name.trim()).filter(name => name); // trim & remove empty names\n\n            for(const name of names) {\n                if(name.endsWith(']')) {\n                    // is it an array?\n                    if(!(match = name.match(/(\\w+)\\s*\\[\\s*(\\d+)\\s*\\]$/)))\n                        throw new ParseError(`Unspecified array length for uniform \"${name}\" in the shader`);\n                    const [ array, length ] = [ match[1], Number(match[2]) ];\n                    for(let i = 0; i < length; i++)\n                        uniforms[`${array}[${i}]`] = type;\n                }\n                else {\n                    // regular uniform\n                    uniforms[name] = type;\n                }\n            }\n        }\n\n        return Object.freeze(uniforms);\n    }\n}\n\n/**\n * Import a ShaderDeclaration from a GLSL file\n * @param {string} filepath relative to the shaders/ folder\n * @returns {ShaderDeclaration}\n */\nexport function importShader(filepath)\n{\n    return ShaderDeclaration.import(filepath);\n}\n\n/**\n * Create a ShaderDeclaration from a GLSL source\n * @param {string} source\n * @returns {ShaderDeclaration}\n */\nexport function createShader(source)\n{\n    return ShaderDeclaration.create(source);\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * shader-preprocessor.js\n * Custom preprocessor for shaders\n */\n\nimport { PYRAMID_MAX_LEVELS, PYRAMID_MAX_OCTAVES, LOG2_PYRAMID_MAX_SCALE, MAX_TEXTURE_LENGTH } from '../utils/globals';\nimport { FIX_BITS, FIX_RESOLUTION } from '../utils/globals';\nimport { PixelComponent } from '../utils/types';\nimport { FileNotFoundError } from '../utils/errors';\n\n// Regular Expressions\nconst commentsRegex = [ /\\/\\*(.|\\s)*?\\*\\//g , /\\/\\/.*$/gm ];\nconst includeRegex = /^\\s*@\\s*include\\s+\"(.*?)\"/gm;\nconst constantRegex = /@(\\w+)@/g;\n\n// Constants accessible by all shaders\nconst constants = {\n    // general\n    'MAX_TEXTURE_LENGTH': MAX_TEXTURE_LENGTH,\n\n    // pyramids\n    'PYRAMID_MAX_LEVELS': PYRAMID_MAX_LEVELS,\n    'LOG2_PYRAMID_MAX_SCALE': LOG2_PYRAMID_MAX_SCALE,\n    'PYRAMID_MAX_OCTAVES': PYRAMID_MAX_OCTAVES,\n\n    // colors\n    'PIXELCOMPONENT_RED': PixelComponent.RED,\n    'PIXELCOMPONENT_GREEN': PixelComponent.GREEN,\n    'PIXELCOMPONENT_BLUE': PixelComponent.BLUE,\n    'PIXELCOMPONENT_ALPHA': PixelComponent.ALPHA,\n\n    // fixed-point math\n    'FIX_BITS': FIX_BITS,\n    'FIX_RESOLUTION': FIX_RESOLUTION,\n};\n\n/**\n * Custom preprocessor for shaders\n */\nexport class ShaderPreprocessor\n{\n    /**\n     * Runs the preprocessor\n     * @param {string} code \n     * @returns {string} preprocessed code\n     */\n    static run(code)\n    {\n        // remove comments and run the preprocessor\n        return String(code).replace(commentsRegex[0], '')\n                           .replace(commentsRegex[1], '')\n                           .replace(includeRegex, (_, filename) =>\n                                // FIXME: no cycle detection for @include\n                                ShaderPreprocessor.run(readfileSync(filename))\n                            )\n                            .replace(constantRegex, (_, name) =>\n                                String(constants[name] || 'UNDEFINED_CONSTANT')\n                            );\n    }\n}\n\n /**\n * Reads a shader from the shaders/include/ folder\n * @param {string} filename\n * @returns {string}\n */\nfunction readfileSync(filename)\n{\n    if(String(filename).match(/^[a-zA-Z0-9_\\-]+\\.glsl$/))\n        return require('./shaders/include/' + filename);\n\n    throw new FileNotFoundError(`Shader preprocessor: can't read file \\\"${filename}\\\"`);\n}","var map = {\n\t\"./colors/rgb2grey.glsl\": \"./src/gpu/shaders/colors/rgb2grey.glsl\",\n\t\"./encoders/encode-keypoint-offsets.glsl\": \"./src/gpu/shaders/encoders/encode-keypoint-offsets.glsl\",\n\t\"./encoders/encode-keypoints.glsl\": \"./src/gpu/shaders/encoders/encode-keypoints.glsl\",\n\t\"./encoders/upload-keypoints.glsl\": \"./src/gpu/shaders/encoders/upload-keypoints.glsl\",\n\t\"./enhancements/nightvision.glsl\": \"./src/gpu/shaders/enhancements/nightvision.glsl\",\n\t\"./enhancements/normalize-image.glsl\": \"./src/gpu/shaders/enhancements/normalize-image.glsl\",\n\t\"./filters/convolution\": \"./src/gpu/shaders/filters/convolution.js\",\n\t\"./filters/convolution.js\": \"./src/gpu/shaders/filters/convolution.js\",\n\t\"./filters/fast-median.glsl\": \"./src/gpu/shaders/filters/fast-median.glsl\",\n\t\"./filters/median\": \"./src/gpu/shaders/filters/median.js\",\n\t\"./filters/median.js\": \"./src/gpu/shaders/filters/median.js\",\n\t\"./filters/multiscale-sobel.glsl\": \"./src/gpu/shaders/filters/multiscale-sobel.glsl\",\n\t\"./include/colors.glsl\": \"./src/gpu/shaders/include/colors.glsl\",\n\t\"./include/fixed-point.glsl\": \"./src/gpu/shaders/include/fixed-point.glsl\",\n\t\"./include/global.glsl\": \"./src/gpu/shaders/include/global.glsl\",\n\t\"./include/keypoints.glsl\": \"./src/gpu/shaders/include/keypoints.glsl\",\n\t\"./include/math.glsl\": \"./src/gpu/shaders/include/math.glsl\",\n\t\"./include/orientation.glsl\": \"./src/gpu/shaders/include/orientation.glsl\",\n\t\"./include/pyramids.glsl\": \"./src/gpu/shaders/include/pyramids.glsl\",\n\t\"./include/sobel.glsl\": \"./src/gpu/shaders/include/sobel.glsl\",\n\t\"./keypoints/brisk.glsl\": \"./src/gpu/shaders/keypoints/brisk.glsl\",\n\t\"./keypoints/fast-score12.glsl\": \"./src/gpu/shaders/keypoints/fast-score12.glsl\",\n\t\"./keypoints/fast-score16.glsl\": \"./src/gpu/shaders/keypoints/fast-score16.glsl\",\n\t\"./keypoints/fast-score8.glsl\": \"./src/gpu/shaders/keypoints/fast-score8.glsl\",\n\t\"./keypoints/fast5.glsl\": \"./src/gpu/shaders/keypoints/fast5.glsl\",\n\t\"./keypoints/fast7.glsl\": \"./src/gpu/shaders/keypoints/fast7.glsl\",\n\t\"./keypoints/fast9lg.glsl\": \"./src/gpu/shaders/keypoints/fast9lg.glsl\",\n\t\"./keypoints/harris-cutoff.glsl\": \"./src/gpu/shaders/keypoints/harris-cutoff.glsl\",\n\t\"./keypoints/multiscale-fast.glsl\": \"./src/gpu/shaders/keypoints/multiscale-fast.glsl\",\n\t\"./keypoints/multiscale-harris.glsl\": \"./src/gpu/shaders/keypoints/multiscale-harris.glsl\",\n\t\"./keypoints/multiscale-suppression.glsl\": \"./src/gpu/shaders/keypoints/multiscale-suppression.glsl\",\n\t\"./keypoints/nonmax-suppression.glsl\": \"./src/gpu/shaders/keypoints/nonmax-suppression.glsl\",\n\t\"./keypoints/orb-descriptor.glsl\": \"./src/gpu/shaders/keypoints/orb-descriptor.glsl\",\n\t\"./keypoints/orientation-via-centroid.glsl\": \"./src/gpu/shaders/keypoints/orientation-via-centroid.glsl\",\n\t\"./keypoints/samescale-suppression.glsl\": \"./src/gpu/shaders/keypoints/samescale-suppression.glsl\",\n\t\"./pyramids/downsample2.glsl\": \"./src/gpu/shaders/pyramids/downsample2.glsl\",\n\t\"./pyramids/downsample3.glsl\": \"./src/gpu/shaders/pyramids/downsample3.glsl\",\n\t\"./pyramids/upsample2.glsl\": \"./src/gpu/shaders/pyramids/upsample2.glsl\",\n\t\"./pyramids/upsample3.glsl\": \"./src/gpu/shaders/pyramids/upsample3.glsl\",\n\t\"./trackers/lk-discard.glsl\": \"./src/gpu/shaders/trackers/lk-discard.glsl\",\n\t\"./trackers/lk.glsl\": \"./src/gpu/shaders/trackers/lk.glsl\",\n\t\"./utils/copy-components.glsl\": \"./src/gpu/shaders/utils/copy-components.glsl\",\n\t\"./utils/fill-components.glsl\": \"./src/gpu/shaders/utils/fill-components.glsl\",\n\t\"./utils/fill.glsl\": \"./src/gpu/shaders/utils/fill.glsl\",\n\t\"./utils/flip-y.glsl\": \"./src/gpu/shaders/utils/flip-y.glsl\",\n\t\"./utils/identity.glsl\": \"./src/gpu/shaders/utils/identity.glsl\",\n\t\"./utils/scan-minmax2d.glsl\": \"./src/gpu/shaders/utils/scan-minmax2d.glsl\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./src/gpu/shaders sync recursive ^\\\\.\\\\/.*$\";","module.exports = \"const vec4 grey = vec4(0.299f, 0.587f, 0.114f, 0.0f);\\nuniform sampler2D image;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nfloat g = dot(pixel, grey);\\ncolor = vec4(g, g, g, 1.0f);\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform ivec2 imageSize;\\nuniform int maxIterations;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nivec2 pos = threadLocation();\\nint offset = -1;\\nwhile(offset < maxIterations && pos.y < imageSize.y && pixelAt(image, pos).r == 0.0f) {\\n++offset;\\npos.x = (pos.x + 1) % imageSize.x;\\npos.y += int(pos.x == 0);\\n}\\ncolor = vec4(pixel.r, float(max(0, offset)) / 255.0f, pixel.ba);\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform sampler2D image;\\nuniform ivec2 imageSize;\\nuniform int encoderLength;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nbool findQthKeypoint(int q, out ivec2 position, out vec4 pixel)\\n{\\nint i = 0, p = -1;\\nposition = ivec2(0, 0);\\nwhile(position.y < imageSize.y) {\\npixel = texelFetch(image, position, 0);\\np += int(pixel.r > 0.0f);\\nif(p == q)\\nreturn true;\\ni += 1 + int(pixel.g * 255.0f);\\nposition = ivec2(i % imageSize.x, i / imageSize.x);\\n}\\nreturn false;\\n}\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\\nint q = findKeypointIndex(address, descriptorSize, extraSize);\\nivec2 position;\\nvec4 pixel;\\ncolor = vec4(0.0f);\\nif(address.offset > 1)\\nreturn;\\ncolor = encodeNullKeypointPosition();\\nif(!findQthKeypoint(q, position, pixel))\\nreturn;\\ncolor = (address.offset == 1) ? vec4(\\npixel.a,\\nencodeOrientation(0.0f),\\npixel.r,\\n0.0f\\n) : encodeKeypointPosition(\\nvec2(position)\\n);\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform int keypointCount;\\nuniform int encoderLength;\\nuniform int descriptorSize;\\nuniform int extraSize;\\n#ifndef KEYPOINT_BUFFER_LENGTH\\n#error Must specify KEYPOINT_BUFFER_LENGTH\\n#endif\\nlayout(std140) uniform KeypointBuffer\\n{\\nvec4 keypointBuffer[KEYPOINT_BUFFER_LENGTH];\\n};\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\\nint q = findKeypointIndex(address, descriptorSize, extraSize);\\ncolor = vec4(1.0f);\\nif(q >= keypointCount)\\nreturn;\\nvec4 data = keypointBuffer[q];\\nswitch(address.offset) {\\ncase 0: {\\nfixed2_t pos = vec2tofix(data.xy);\\nfixed2_t lo = pos & 255;\\nfixed2_t hi = pos >> 8;\\ncolor = vec4(float(lo.x), float(hi.x), float(lo.y), float(hi.y)) / 255.0f;\\nbreak;\\n}\\ncase 1: {\\nfloat score = data.w;\\nfloat scale = encodeLod(data.z);\\nfloat rotation = encodeOrientation(0.0f);\\ncolor = vec4(scale, rotation, score, 0.0f);\\nbreak;\\n}\\ndefault: {\\ncolor = vec4(0.0f);\\nbreak;\\n}\\n}\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform sampler2D illuminationMap;\\nuniform float gain;\\nuniform float offset;\\nuniform float decay;\\nconst mat3 rgb2yuv = mat3(\\n0.299f, -0.14713f, 0.615f,\\n0.587f, -0.28886f, -0.51499f,\\n0.114f, 0.436f, -0.10001f\\n);\\nconst mat3 yuv2rgb = mat3(\\n1.0f, 1.0f, 1.0f,\\n0.0f, -0.39465f, 2.03211f,\\n1.13983f, -0.58060f, 0.0f\\n);\\nconst float eps = 0.0001f;\\nconst float sqrt2 = 1.4142135623730951f;\\nconst float magic = 20.0f;\\nconst vec2 center = vec2(0.5f);\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nvec4 imapPixel = threadPixel(illuminationMap);\\nfloat lambda = -sqrt2 * log(max(1.0f - decay, eps));\\nfloat dist = length(texCoord - center);\\nfloat vgain = gain * exp(-lambda * dist);\\nfloat normalizedGain = 2.0f * vgain;\\nfloat normalizedOffset = 2.0f * offset - 1.0f;\\n#ifdef GREYSCALE\\nfloat luma = 1.0 / (1.0 + exp(-normalizedGain * magic * (pixel.g - imapPixel.g)));\\nluma = clamp(luma + normalizedOffset, 0.0f, 1.0f);\\ncolor = vec4(luma, luma, luma, 1.0f);\\n#else\\nvec3 yuvPixel = rgb2yuv * pixel.rgb;\\nvec3 yuvImapPixel = rgb2yuv * imapPixel.rgb;\\nfloat luma = 1.0 / (1.0 + exp(-normalizedGain * magic * (yuvPixel.r - yuvImapPixel.r)));\\nluma += normalizedOffset;\\nvec3 rgbCorrectedPixel = yuv2rgb * vec3(luma, yuvPixel.gb);\\nrgbCorrectedPixel = clamp(rgbCorrectedPixel, 0.0f, 1.0f);\\ncolor = vec4(rgbCorrectedPixel, 1.0f);\\n#endif\\n}\"","module.exports = \"#ifdef GREYSCALE\\nuniform sampler2D minmax2d;\\n#else\\nuniform sampler2D minmax2dRGB[3];\\n#endif\\nuniform float minValue;\\nuniform float maxValue;\\nconst float eps = 1.0f / 255.0f;\\nvoid main()\\n{\\nvec2 minmax = clamp(vec2(minValue, maxValue), 0.0f, 255.0f) / 255.0f;\\nvec4 newMin = vec4(minmax.x);\\nvec4 newRange = vec4(minmax.y - minmax.x);\\nvec4 alpha = vec4(1.0f, newMin.x, newRange.x, 1.0f);\\n#ifdef GREYSCALE\\nvec4 pixel = threadPixel(minmax2d);\\nmat4 channel = mat4(pixel, pixel, pixel, alpha);\\n#else\\nmat4 channel = mat4(\\nthreadPixel(minmax2dRGB[0]),\\nthreadPixel(minmax2dRGB[1]),\\nthreadPixel(minmax2dRGB[2]),\\nalpha\\n);\\n#endif\\nvec4 oldMin = vec4(channel[0].g, channel[1].g, channel[2].g, channel[3].g);\\nvec4 oldRange = max(vec4(channel[0].b, channel[1].b, channel[2].b, channel[3].b), eps);\\nvec4 oldIntensity = vec4(channel[0].a, channel[1].a, channel[2].a, channel[3].a);\\nvec4 newIntensity = (oldIntensity - oldMin) * newRange / oldRange + newMin;\\ncolor = newIntensity;\\n}\"","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * convolution.js\n * Convolution shader generators\n */\n\nimport { createShader } from '../../shader-declaration';\nimport { Utils } from '../../../utils/utils';\nimport { IllegalArgumentError } from '../../../utils/errors';\n\n\n\n/**\n * Generate a 2D convolution with a square kernel\n * @param {Array<number>} kernel convolution kernel\n * @param {number} [normalizationConstant] will be multiplied by all kernel entries\n */\nexport function conv2D(kernel, normalizationConstant = 1.0)\n{\n    const kernel32 = new Float32Array(kernel.map(x => (+x) * (+normalizationConstant)));\n    const kSize = Math.sqrt(kernel32.length) | 0;\n    const N = kSize >> 1; // idiv 2\n\n    // validate input\n    if(kSize < 1 || kSize % 2 == 0)\n        throw new IllegalArgumentError(`Can't perform a 2D convolution with an invalid kSize of ${kSize}`);\n    else if(kSize * kSize != kernel32.length)\n        throw new IllegalArgumentError(`Invalid 2D convolution kernel of ${kernel32.length} elements (expected: square)`);\n\n    // select the appropriate pixel function\n    const pixelAtOffset = (N <= 7) ? 'pixelAtShortOffset' : 'pixelAtLongOffset';\n\n    // code generator\n    const foreachKernelElement = fn => Utils.cartesian(Utils.symmetricRange(N), Utils.symmetricRange(N)).map(\n        cur => fn(\n            kernel32[(cur[0] + N) * kSize + (cur[1] + N)],\n            cur[0], cur[1]\n        )\n    ).join('\\n');\n\n    const generateCode = (k, dy, dx) => `\n        result += ${pixelAtOffset}(image, ivec2(${dx | 0}, ${dy | 0})) * float(${+k});\n    `;\n\n    // shader\n    const source = `\n    uniform sampler2D image;\n\n    void main()\n    {\n        float alpha = threadPixel(image).a;\n        vec4 result = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n\n        ${foreachKernelElement(generateCode)}\n\n        color = vec4(result.rgb, alpha);\n    }\n    `;\n\n    // done!\n    return createShader(source).withArguments('image');\n}\n\n\n\n\n/**\n * Generate a 1D convolution function on the x-axis\n * @param {Array<number>} kernel convolution kernel\n * @param {number} [normalizationConstant] will be multiplied by all kernel entries\n */\nexport function convX(kernel, normalizationConstant = 1.0)\n{\n    return conv1D('x', kernel, normalizationConstant);\n}\n\n\n\n\n/**\n * Generate a 1D convolution function on the y-axis\n * @param {Array<number>} kernel convolution kernel\n * @param {number} [normalizationConstant] will be multiplied by all kernel entries\n */\nexport function convY(kernel, normalizationConstant = 1.0)\n{\n    return conv1D('y', kernel, normalizationConstant);\n}\n\n\n\n\n/**\n * 1D convolution function generator\n * @param {string} axis either \"x\" or \"y\"\n * @param {Array<number>} kernel convolution kernel\n * @param {number} [normalizationConstant] will be multiplied by all kernel entries\n */\nfunction conv1D(axis, kernel, normalizationConstant = 1.0)\n{\n    const kernel32 = new Float32Array(kernel.map(x => (+x) * (+normalizationConstant)));\n    const kSize = kernel32.length;\n    const N = kSize >> 1; // idiv 2\n\n    // validate input\n    if(kSize < 1 || kSize % 2 == 0)\n        throw new IllegalArgumentError(`Can't perform a 1D convolution with an invalid kSize of ${kSize}`);\n    else if(axis != 'x' && axis != 'y')\n        throw new IllegalArgumentError(`Can't perform 1D convolution: invalid axis \"${axis}\"`); // this should never happen\n\n    // select the appropriate pixel function\n    const pixelAtOffset = (N <= 7) ? 'pixelAtShortOffset' : 'pixelAtLongOffset';\n\n    // code generator\n    const foreachKernelElement = fn => Utils.symmetricRange(N).reduce(\n        (acc, cur) => acc + fn(kernel32[cur + N], cur),\n    '');\n    const generateCode = (k, i) => ((axis == 'x') ? `\n        pixel += ${pixelAtOffset}(image, ivec2(${i | 0}, 0)) * float(${+k});\n    ` : `\n        pixel += ${pixelAtOffset}(image, ivec2(0, ${i | 0})) * float(${+k});\n    `);\n\n    // shader\n    const source = `\n    uniform sampler2D image;\n\n    void main()\n    {\n        float alpha = threadPixel(image).a;\n        vec4 pixel = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n\n        ${foreachKernelElement(generateCode)}\n\n        color = vec4(pixel.rgb, alpha);\n    }\n    `;\n\n    // done!\n    return createShader(source).withArguments('image');\n}\n\n\n\n\n\n/*\n * ------------------------------------------------------------------\n * Texture Encoding\n * Encoding a float in [0,1] into RGB[A]\n * ------------------------------------------------------------------\n * Define frac(x) := x - floor(x)\n * Of course, 0 <= frac(x) < 1.\n * \n * Given: x in [0,1]\n * \n * Define e0 := floor(x),\n *        e1 := 256 frac(x)\n *        e2 := 256 frac(e1) = 256 frac(256 frac(x))\n *        e3 := 256 frac(e2) = 256 frac(256 frac(e1)) = 256 frac(256 frac(256 frac(x))),\n *        ...\n *        more generally,\n *        ej := 256 frac(e_{j-1}), j >= 2\n * \n * Since x = frac(x) + floor(x), it follows that\n * x = floor(x) + 256 frac(x) / 256 = e0 + e1 / 256 = e0 + (frac(e1) + floor(e1)) / 256 =\n * e0 + (256 frac(e1) + 256 floor(e1)) / (256^2) = e0 + (e2 + 256 floor(e1)) / (256^2) =\n * e0 + ((256 frac(e2) + 256 floor(e2)) + 256^2 floor(e1)) / (256^3) =\n * e0 + (e3 + 256 floor(e2) + 256^2 floor(e1)) / (256^3) = \n * floor(e0) + floor(e1) / 256 + floor(e2) / (256^2) + e3 / (256^3) = ... =\n * floor(e0) + floor(e1) / 256 + floor(e2) / (256^2) + floor(e3) / (256^3) + e4 / (256^4) = ... ~\n * \\sum_{i >= 0} floor(e_i) / 256^i\n * \n * Observe that e0 in {0, 1} and, for j >= 1, 0 <= e_j < 256, meaning that\n * e0 and (e_j / 256) can be stored in a 8-bit color channel.\n * \n * We now have approximations for x:\n * x ~ x0 <-- first order\n * x ~ x0 + x1 / 256 <-- second order\n * x ~ x0 + x1 / 256 + x2 / (256^2) <-- third order (RGB)\n * x ~ x0 + x1 / 256 + x2 / (256^2) + x3 / (256^3) <-- fourth order (RGBA)\n * where x_i = floor(e_i).\n */\n\n\n\n\n/**\n * Generate a texture-based 2D convolution kernel of size\n * (kernelSize x kernelSize), where all entries belong to\n * the [0, 1] range\n * @param {number} kernelSize odd number, e.g., 3 to create a 3x3 kernel, and so on\n */\nexport function createKernel2D(kernelSize)\n{\n    // validate input\n    kernelSize |= 0;\n    if(kernelSize < 1 || kernelSize % 2 == 0)\n        throw new IllegalArgumentError(`Can't create a 2D texture kernel of size ${kernelSize}`);\n\n    // encode float in the [0,1] range to RGBA\n    const shader = `\n    uniform float kernel[${kernelSize * kernelSize}];\n\n    void main()\n    {\n        ivec2 thread = threadLocation();\n        float val = kernel[(${kernelSize}) * thread.y + thread.x];\n\n        float e0 = floor(val);\n        float e1 = 256.0f * fract(val);\n        float e2 = 256.0f * fract(e1);\n        float e3 = 256.0f * fract(e2);\n\n        color = vec4(e0, floor(e1) / 256.0f, floor(e2) / 256.0f, floor(e3) / 256.0f);\n    }\n    `;\n\n    // IMPORTANT: all entries of the input kernel\n    // are assumed to be in the [0, 1] range AND\n    // kernel.length >= kernelSize * kernelSize\n    return createShader(shader).withArguments('kernel');\n}\n\n\n\n\n/**\n * Generate a texture-based 1D convolution kernel of size\n * (kernelSize x 1), where all entries belong to the [0,1] range\n * @param {number} kernelSize odd number\n */\nexport function createKernel1D(kernelSize)\n{\n    // validate input\n    kernelSize |= 0;\n    if(kernelSize < 1 || kernelSize % 2 == 0)\n        throw new IllegalArgumentError(`Can't create a 1D texture kernel of size ${kernelSize}`);\n\n    // encode float in the [0,1] range to RGBA\n    const shader = `\n    uniform float kernel[${kernelSize}];\n\n    void main()\n    {\n        ivec2 thread = threadLocation();\n        float val = kernel[thread.x];\n\n        float e0 = floor(val);\n        float e1 = 256.0f * fract(val);\n        float e2 = 256.0f * fract(e1);\n        float e3 = 256.0f * fract(e2);\n\n        color = vec4(e0, floor(e1) / 256.0f, floor(e2) / 256.0f, floor(e3) / 256.0f);\n    }\n    `;\n\n    // IMPORTANT: all entries of the input kernel\n    // are assumed to be in the [0, 1] range AND\n    // kernel.length >= kernelSize\n    return createShader(shader).withArguments('kernel');\n}\n\n\n\n\n/**\n * 2D convolution with a texture-based kernel of size\n * kernelSize x kernelSize, with optional scale & offset\n * By default, scale and offset are 1 and 0, respectively\n * @param {number} kernelSize odd number, e.g., 3 to create a 3x3 kernel, and so on\n */\nexport function texConv2D(kernelSize)\n{\n    // validate input\n    const N = kernelSize >> 1; // idiv 2\n    if(kernelSize < 1 || kernelSize % 2 == 0)\n        throw new IllegalArgumentError(`Can't perform a texture-based 2D convolution with an invalid kernel size of ${kernelSize}`);\n\n    // select the appropriate pixel function\n    const pixelAtOffset = (N <= 7) ? 'pixelAtShortOffset' : 'pixelAtLongOffset';\n\n    // utilities\n    const foreachKernelElement = fn => Utils.cartesian(Utils.symmetricRange(N), Utils.symmetricRange(N)).map(\n        ij => fn(ij[0], ij[1])\n    ).join('\\n');\n\n    const generateCode = (i, j) => `\n        kernel = pixelAt(texKernel, ivec2(${i + N}, ${j + N}));\n        value = dot(kernel, magic) * scale + offset;\n        result += ${pixelAtOffset}(image, ivec2(${i}, ${j})) * value;\n    `;\n\n    // image: target image\n    // texKernel: convolution kernel (all entries in [0,1])\n    // scale: multiply the kernel entries by a number (like 1.0)\n    // offset: add a number to all kernel entries (like 0.0)\n    const shader = `\n    const vec4 magic = vec4(1.0f, 1.0f, 1.0f / 256.0f, 1.0f / 65536.0f);\n    uniform sampler2D image, texKernel;\n    uniform float scale, offset;\n\n    void main()\n    {\n        vec4 kernel = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n        vec4 result = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n        float alpha = threadPixel(image).a;\n        float value = 0.0f;\n\n        ${foreachKernelElement(generateCode)}\n\n        result = clamp(result, 0.0f, 1.0f);\n        color = vec4(result.rgb, alpha);\n    }\n    `;\n\n    // done!\n    return createShader(shader).withArguments('image', 'texKernel', 'scale', 'offset');\n}\n\n\n\n\n/**\n * Texture-based 1D convolution on the x-axis\n * @param {number} kernelSize odd number\n */\nexport const texConvX = kernelSize => texConv1D(kernelSize, 'x');\n\n\n\n/**\n * Texture-based 1D convolution on the x-axis\n * @param {number} kernelSize odd number\n */\nexport const texConvY = kernelSize => texConv1D(kernelSize, 'y');\n\n\n\n\n/**\n * Texture-based 1D convolution function generator\n * (the convolution kernel is stored in a texture)\n * @param {number} kernelSize odd number\n * @param {string} axis either \"x\" or \"y\"\n */\nfunction texConv1D(kernelSize, axis)\n{\n    // validate input\n    const N = kernelSize >> 1; // idiv 2\n    if(kernelSize < 1 || kernelSize % 2 == 0)\n        throw new IllegalArgumentError(`Can't perform a texture-based 2D convolution with an invalid kernel size of ${kernelSize}`);\n    else if(axis != 'x' && axis != 'y')\n        throw new IllegalArgumentError(`Can't perform a texture-based 1D convolution: invalid axis \"${axis}\"`); // this should never happen\n\n    // select the appropriate pixel function\n    const pixelAtOffset = (N <= 7) ? 'pixelAtShortOffset' : 'pixelAtLongOffset';\n\n    // utilities\n    const foreachKernelElement = fn => Utils.symmetricRange(N).map(fn).join('\\n');\n    const generateCode = i => ((axis == 'x') ? `\n        kernel = pixelAt(texKernel, ivec2(${i + N}, 0));\n        value = dot(kernel, magic) * scale + offset;\n        result += ${pixelAtOffset}(image, ivec2(${i}, 0)) * value;\n    ` : `\n        kernel = pixelAt(texKernel, ivec2(${i + N}, 0));\n        value = dot(kernel, magic) * scale + offset;\n        result += ${pixelAtOffset}(image, ivec2(0, ${i})) * value;\n    `);\n\n    // image: target image\n    // texKernel: convolution kernel (all entries in [0,1])\n    // scale: multiply the kernel entries by a number (like 1.0)\n    // offset: add a number to all kernel entries (like 0.0)\n    const shader = `\n    const vec4 magic = vec4(1.0f, 1.0f, 1.0f / 256.0f, 1.0f / 65536.0f);\n    uniform sampler2D image, texKernel;\n    uniform float scale, offset;\n\n    void main()\n    {\n        vec4 kernel = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n        vec4 result = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n        float alpha = threadPixel(image).a;\n        float value = 0.0f;\n\n        ${foreachKernelElement(generateCode)}\n\n        result = clamp(result, 0.0f, 1.0f);\n        color = vec4(result.rgb, alpha);\n    }\n    `;\n\n    // done!\n    return createShader(shader).withArguments('image', 'texKernel', 'scale', 'offset');\n}","module.exports = \"uniform sampler2D image;\\n#define SORT(i, j) t = p[i] + p[j]; p[i] = min(p[i], p[j]); p[j] = t - p[i];\\nvoid main()\\n{\\nfloat median, t;\\n#if WINDOW_SIZE == 3\\nfloat p[9];\\np[0] = pixelAtShortOffset(image, ivec2(-1,-1)).g;\\np[1] = pixelAtShortOffset(image, ivec2(0,-1)).g;\\np[2] = pixelAtShortOffset(image, ivec2(1,-1)).g;\\np[3] = pixelAtShortOffset(image, ivec2(-1,0)).g;\\np[4] = pixelAtShortOffset(image, ivec2(0,0)).g;\\np[5] = pixelAtShortOffset(image, ivec2(1,0)).g;\\np[6] = pixelAtShortOffset(image, ivec2(-1,1)).g;\\np[7] = pixelAtShortOffset(image, ivec2(0,1)).g;\\np[8] = pixelAtShortOffset(image, ivec2(1,1)).g;\\nSORT(1,2);\\nSORT(4,5);\\nSORT(7,8);\\nSORT(0,1);\\nSORT(3,4);\\nSORT(6,7);\\nSORT(1,2);\\nSORT(4,5);\\nSORT(7,8);\\nSORT(0,3);\\nSORT(5,8);\\nSORT(4,7);\\nSORT(3,6);\\nSORT(1,4);\\nSORT(2,5);\\nSORT(4,7);\\nSORT(4,2);\\nSORT(6,4);\\nSORT(4,2);\\nmedian = p[4];\\n#elif WINDOW_SIZE == 5\\nfloat p[25];\\np[0] = pixelAtShortOffset(image, ivec2(-2,-2)).g;\\np[1] = pixelAtShortOffset(image, ivec2(-1,-2)).g;\\np[2] = pixelAtShortOffset(image, ivec2(0,-2)).g;\\np[3] = pixelAtShortOffset(image, ivec2(1,-2)).g;\\np[4] = pixelAtShortOffset(image, ivec2(2,-2)).g;\\np[5] = pixelAtShortOffset(image, ivec2(-2,-1)).g;\\np[6] = pixelAtShortOffset(image, ivec2(-1,-1)).g;\\np[7] = pixelAtShortOffset(image, ivec2(0,-1)).g;\\np[8] = pixelAtShortOffset(image, ivec2(1,-1)).g;\\np[9] = pixelAtShortOffset(image, ivec2(2,-1)).g;\\np[10] = pixelAtShortOffset(image, ivec2(-2,0)).g;\\np[11] = pixelAtShortOffset(image, ivec2(-1,0)).g;\\np[12] = pixelAtShortOffset(image, ivec2(0,0)).g;\\np[13] = pixelAtShortOffset(image, ivec2(1,0)).g;\\np[14] = pixelAtShortOffset(image, ivec2(2,0)).g;\\np[15] = pixelAtShortOffset(image, ivec2(-2,1)).g;\\np[16] = pixelAtShortOffset(image, ivec2(-1,1)).g;\\np[17] = pixelAtShortOffset(image, ivec2(0,1)).g;\\np[18] = pixelAtShortOffset(image, ivec2(1,1)).g;\\np[19] = pixelAtShortOffset(image, ivec2(2,1)).g;\\np[20] = pixelAtShortOffset(image, ivec2(-2,2)).g;\\np[21] = pixelAtShortOffset(image, ivec2(-1,2)).g;\\np[22] = pixelAtShortOffset(image, ivec2(0,2)).g;\\np[23] = pixelAtShortOffset(image, ivec2(1,2)).g;\\np[24] = pixelAtShortOffset(image, ivec2(2,2)).g;\\nSORT(0,1);\\nSORT(3,4);\\nSORT(2,4);\\nSORT(2,3);\\nSORT(6,7);\\nSORT(5,7);\\nSORT(5,6);\\nSORT(9,10);\\nSORT(8,10);\\nSORT(8,9);\\nSORT(12,13);\\nSORT(11,13);\\nSORT(11,12);\\nSORT(15,16);\\nSORT(14,16);\\nSORT(14,15);\\nSORT(18,19);\\nSORT(17,19);\\nSORT(17,18);\\nSORT(21,22);\\nSORT(20,22);\\nSORT(20,21);\\nSORT(23,24);\\nSORT(2,5);\\nSORT(3,6);\\nSORT(0,6);\\nSORT(0,3);\\nSORT(4,7);\\nSORT(1,7);\\nSORT(1,4);\\nSORT(11,14);\\nSORT(8,14);\\nSORT(8,11);\\nSORT(12,15);\\nSORT(9,15);\\nSORT(9,12);\\nSORT(13,16);\\nSORT(10,16);\\nSORT(10,13);\\nSORT(20,23);\\nSORT(17,23);\\nSORT(17,20);\\nSORT(21,24);\\nSORT(18,24);\\nSORT(18,21);\\nSORT(19,22);\\nSORT(8,17);\\nSORT(9,18);\\nSORT(0,18);\\nSORT(0,9);\\nSORT(10,19);\\nSORT(1,19);\\nSORT(1,10);\\nSORT(11,20);\\nSORT(2,20);\\nSORT(2,11);\\nSORT(12,21);\\nSORT(3,21);\\nSORT(3,12);\\nSORT(13,22);\\nSORT(4,22);\\nSORT(4,13);\\nSORT(14,23);\\nSORT(5,23);\\nSORT(5,14);\\nSORT(15,24);\\nSORT(6,24);\\nSORT(6,15);\\nSORT(7,16);\\nSORT(7,19);\\nSORT(13,21);\\nSORT(15,23);\\nSORT(7,13);\\nSORT(7,15);\\nSORT(1,9);\\nSORT(3,11);\\nSORT(5,17);\\nSORT(11,17);\\nSORT(9,17);\\nSORT(4,10);\\nSORT(6,12);\\nSORT(7,14);\\nSORT(4,6);\\nSORT(4,7);\\nSORT(12,14);\\nSORT(10,14);\\nSORT(6,7);\\nSORT(10,12);\\nSORT(6,10);\\nSORT(6,17);\\nSORT(12,17);\\nSORT(7,17);\\nSORT(7,10);\\nSORT(12,18);\\nSORT(7,12);\\nSORT(10,18);\\nSORT(12,20);\\nSORT(10,20);\\nSORT(10,12);\\nmedian = p[12];\\n#else\\n#error Unsupported window size\\n#endif\\ncolor = vec4(median, median, median, 1.0f);\\n}\"","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * median.js\n * Median filter generator\n */\n\nimport { createShader } from '../../shader-declaration';\nimport { Utils } from '../../../utils/utils';\nimport { IllegalArgumentError } from '../../../utils/errors';\n\n/**\n * Generate a median filter with a\n * (windowSize x windowSize) window\n * (for greyscale images only)\n * @param {number} windowSize 3, 5, 7, ...\n */\nexport function median(windowSize)\n{\n    // validate argument\n    windowSize |= 0;\n    if(windowSize <= 1 || windowSize % 2 == 0)\n        throw new IllegalArgumentError(`Can't create median filter with a ${windowSize}x${windowSize} window`);\n\n    // prepare data\n    const maxOffset = windowSize >> 1;\n    const pixelAtOffset = maxOffset <= 7 ? 'pixelAtShortOffset' : 'pixelAtLongOffset';\n    const n = windowSize * windowSize;\n    const med = n >> 1;\n\n    // code generator\n    const foreachWindowElement = fn => Utils.cartesian(\n        Utils.symmetricRange(maxOffset), Utils.symmetricRange(maxOffset)\n    ).map(\n        (pair, idx) => fn(idx, pair[0], pair[1])\n    ).join('\\n');\n    const readPixel = (k, j, i) => `\n        v[${k}] = ${pixelAtOffset}(image, ivec2(${i}, ${j})).g;\n    `;\n\n    // selection sort: unrolled & branchless\n    // TODO implement a faster selection algorithm\n    const foreachVectorElement = fn => Utils.range(med + 1).map(fn).join('\\n');\n    const findMinimum = j => Utils.range(n - (j + 1)).map(x => x + j + 1).map(i => `\n        m += int(v[${i}] >= v[m]) * (${i} - m);\n    `).join('\\n');\n    const selectMinimum = j => `\n        m = ${j};\n        ${findMinimum(j)}\n        swpv = v[${j}];\n        v[${j}] = v[m];\n        v[m] = swpv;\n    `;\n\n    // shader\n    const source = `\n    uniform sampler2D image;\n\n    void main()\n    {\n        float v[${n}], swpv;\n        int m;\n\n        // read pixels\n        ${foreachWindowElement(readPixel)}\n\n        // sort v[0..med]\n        ${foreachVectorElement(selectMinimum)}\n\n        // return the median\n        color = vec4(v[${med}], v[${med}], v[${med}], 1.0f);\n    }\n    `;\n\n    // done!\n    return createShader(source).withArguments('image');\n}","module.exports = \"@include \\\"sobel.glsl\\\"\\n@include \\\"pyramids.glsl\\\"\\nuniform sampler2D pyramid;\\nuniform float lod;\\nconst mat3 horizontalKernel = mat3(\\n-1.0f, 0.0f, 1.0f,\\n-2.0f, 0.0f, 2.0f,\\n-1.0f, 0.0f, 1.0f\\n);\\nconst mat3 verticalKernel = mat3(\\n1.0f, 2.0f, 1.0f,\\n0.0f, 0.0f, 0.0f,\\n-1.0f,-2.0f,-1.0f\\n);\\nconst vec3 ones = vec3(1.0f, 1.0f, 1.0f);\\nvoid main()\\n{\\nfloat pot = exp2(lod);\\nmat3 neighbors = mat3(\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-1, -1)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(0, -1)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(1, -1)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-1, 0)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(0, 0)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(1, 0)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-1, 1)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(0, 1)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(1, 1)).g\\n);\\nmat3 sobelX = matrixCompMult(horizontalKernel, neighbors);\\nmat3 sobelY = matrixCompMult(verticalKernel, neighbors);\\nvec2 df = vec2(\\ndot(sobelX[0] + sobelX[1] + sobelX[2], ones),\\ndot(sobelY[0] + sobelY[1] + sobelY[2], ones)\\n);\\ncolor = encodeSobel(df);\\n}\"","var map = {\n\t\"./colors.glsl\": \"./src/gpu/shaders/include/colors.glsl\",\n\t\"./fixed-point.glsl\": \"./src/gpu/shaders/include/fixed-point.glsl\",\n\t\"./global.glsl\": \"./src/gpu/shaders/include/global.glsl\",\n\t\"./keypoints.glsl\": \"./src/gpu/shaders/include/keypoints.glsl\",\n\t\"./math.glsl\": \"./src/gpu/shaders/include/math.glsl\",\n\t\"./orientation.glsl\": \"./src/gpu/shaders/include/orientation.glsl\",\n\t\"./pyramids.glsl\": \"./src/gpu/shaders/include/pyramids.glsl\",\n\t\"./sobel.glsl\": \"./src/gpu/shaders/include/sobel.glsl\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./src/gpu/shaders/include sync recursive ^\\\\.\\\\/.*$\";","module.exports = \"#ifndef _COLORS_GLSL\\n#define _COLORS_GLSL\\n#define PIXELCOMPONENT_RED   @PIXELCOMPONENT_RED@\\n#define PIXELCOMPONENT_GREEN @PIXELCOMPONENT_GREEN@\\n#define PIXELCOMPONENT_BLUE  @PIXELCOMPONENT_BLUE@\\n#define PIXELCOMPONENT_ALPHA @PIXELCOMPONENT_ALPHA@\\n#endif\"","module.exports = \"#ifndef _FIXEDPOINT_GLSL\\n#define _FIXEDPOINT_GLSL\\n#define fixed_t int\\n#define fixed2_t ivec2\\nconst int FIX_BITS = int(@FIX_BITS@);\\nconst float FIX_RESOLUTION = float(@FIX_RESOLUTION@);\\n#define itofix(x) fixed_t((x) << FIX_BITS)\\n#define fixtoi(f) int((x) >> FIX_BITS)\\n#define ftofix(x) fixed_t((x) * FIX_RESOLUTION + 0.5f)\\n#define fixtof(f) (float(f) / FIX_RESOLUTION)\\n#define ivec2tofix(x) fixed2_t((x) << FIX_BITS)\\n#define fixtoivec2(f) ivec2((x) >> FIX_BITS)\\n#define vec2tofix(v) fixed2_t((v) * FIX_RESOLUTION + vec2(0.5f))\\n#define fixtovec2(f) (vec2(f) / FIX_RESOLUTION)\\n#endif\"","module.exports = \"#ifndef _GLOBAL_GLSL\\n#define _GLOBAL_GLSL\\n#define threadLocation() ivec2(texCoord * texSize)\\n#define outputSize() ivec2(texSize)\\n#define DEBUG(scalar) do { color = vec4(float(scalar), 0.0f, 0.0f, 1.0f); return; } while(false)\\n#define threadPixel(img) textureLod((img), texCoord, 0.0f)\\n#define pixelAt(img, pos) texelFetch((img), (pos), 0)\\n#define pixelAtShortOffset(img, offset) textureLodOffset((img), texCoord, 0.0f, (offset))\\n#define pixelAtLongOffset(img, offset) textureLod((img), texCoord + vec2(offset) / texSize, 0.0f)\\n#define subpixelAt(img, pos) textureLod((img), ((pos) + vec2(0.5f)) / texSize, 0.0f)\\n#endif\"","module.exports = \"#ifndef _KEYPOINTS_GLSL\\n#define _KEYPOINTS_GLSL\\n@include \\\"pyramids.glsl\\\"\\n@include \\\"orientation.glsl\\\"\\n@include \\\"fixed-point.glsl\\\"\\nstruct Keypoint\\n{\\nvec2 position;\\nfloat orientation;\\nfloat lod;\\nfloat score;\\n};\\nstruct KeypointAddress\\n{\\nint base;\\nint offset;\\n};\\n#define readKeypointData(encodedKeypoints, encoderLength, keypointAddress) texelFetch((encodedKeypoints), ivec2((keypointAddress) % (encoderLength), (keypointAddress) / (encoderLength)), 0)\\n#define sizeofEncodedKeypoint(descriptorSize, extraSize) (8 + (descriptorSize) + (extraSize))\\n#define findKeypointIndex(address, descriptorSize, extraSize) ((address).base / ((sizeofEncodedKeypoint((descriptorSize), (extraSize))) / 4))\\nKeypointAddress findKeypointAddress(ivec2 thread, int encoderLength, int descriptorSize, int extraSize)\\n{\\nint threadRaster = thread.y * encoderLength + thread.x;\\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\\nKeypointAddress address;\\nint keypointIndex = int(threadRaster / pixelsPerKeypoint);\\naddress.base = keypointIndex * pixelsPerKeypoint;\\naddress.offset = threadRaster % pixelsPerKeypoint;\\nreturn address;\\n}\\nKeypoint decodeKeypoint(sampler2D encodedKeypoints, int encoderLength, KeypointAddress address)\\n{\\nKeypoint keypoint;\\nint positionAddress = address.base;\\nint propertiesAddress = address.base + 1;\\nvec4 rawEncodedPosition = readKeypointData(encodedKeypoints, encoderLength, positionAddress);\\nivec4 encodedPosition = ivec4(rawEncodedPosition * 255.0f);\\nkeypoint.position = fixtovec2(fixed2_t(\\nencodedPosition.r | (encodedPosition.g << 8),\\nencodedPosition.b | (encodedPosition.a << 8)\\n));\\nvec4 encodedProperties = readKeypointData(encodedKeypoints, encoderLength, propertiesAddress);\\nkeypoint.orientation = decodeOrientation(encodedProperties.g);\\nkeypoint.lod = decodeLod(encodedProperties.r);\\nkeypoint.score = encodedProperties.b;\\nreturn keypoint;\\n}\\nvec4 encodeKeypointPosition(vec2 position)\\n{\\nfixed2_t pos = vec2tofix(position);\\nfixed2_t lo = pos & 255;\\nfixed2_t hi = pos >> 8;\\nreturn vec4(float(lo.x), float(hi.x), float(lo.y), float(hi.y)) / 255.0f;\\n}\\n#define encodeNullKeypointPosition() (vec4(1.0f))\\n#define encodeDiscardedKeypointPosition() (vec4(254.0f / 255.0f, vec3(1.0f)))\\nbool isDiscardedOrNullKeypoint(Keypoint keypoint)\\n{\\nconst float F_MAX_TEXTURE_LENGTH = float(@MAX_TEXTURE_LENGTH@);\\nreturn keypoint.position.x > F_MAX_TEXTURE_LENGTH || keypoint.position.y > F_MAX_TEXTURE_LENGTH;\\n}\\n#endif\"","module.exports = \"#ifndef _MATH_GLSL\\n#define _MATH_GLSL\\n#define TWO_PI          6.28318530718f\\n#define PI              3.14159265359f\\n#define PI_OVER_2       1.57079632679f\\n#define PI_OVER_4       0.78539816339f\\n#define INV_PI          0.3183098861837907f\\n#define USE_FAST_ATAN\\n#ifdef USE_FAST_ATAN\\nfloat fastAtan(float x)\\n{\\nfloat w = 1.0f - abs(x);\\nreturn (w >= 0.0f) ?\\n(PI_OVER_4 + 0.273f * w) * x :\\nsign(x) * PI_OVER_2 - (PI_OVER_4 + 0.273f * (1.0f - abs(1.0f / x))) / x;\\n}\\n#else\\n#define fastAtan(x) atan(x)\\n#endif\\n#ifdef USE_FAST_ATAN\\nfloat fastAtan2(float y, float x)\\n{\\nreturn (x == 0.0f) ? PI_OVER_2 * sign(y) : fastAtan(y / x) + float(x < 0.0f) * PI * sign(y);\\n}\\n#else\\n#define fastAtan2(y, x) atan((y), (x))\\n#endif\\n#endif\"","module.exports = \"#ifndef _ORIENTATION_GLSL\\n#define _ORIENTATION_GLSL\\n@include \\\"math.glsl\\\"\\n#define encodeOrientation(angle) ((angle) * INV_PI + 1.0f) * 0.5f\\n#define decodeOrientation(value) ((value) * 2.0f - 1.0f) * PI\\n#endif\"","module.exports = \"#ifndef _PYRAMIDS_GLSL\\n#define _PYRAMIDS_GLSL\\n#define pyrPixel(pyr, lod) textureLod((pyr), texCoord, (lod))\\n#define pyrPixelAtOffset(pyr, lod, pot, offset) textureLod((pyr), texCoord + ((pot) * vec2(offset)) / texSize, (lod))\\n#define pyrPixelAt(pyr, pos, lod) textureLod((pyr), (vec2(pos) + vec2(0.5f)) / texSize, (lod))\\n#define pyrPixelAtEx(pyr, pos, lod, pyrBaseSize) textureLod((pyr), (vec2(pos) + vec2(0.5f)) / vec2(pyrBaseSize), (lod))\\n#define pyrSubpixelAtEx(pyr, pos, lod, pyrBaseSize) textureLod((pyr), ((pos) + vec2(0.5f)) / vec2(pyrBaseSize), (lod))\\n#define pyrSubpixelAtExOffset(pyr, pos, lod, pot, offset, pyrBaseSize) textureLod((pyr), (((pos) + vec2(0.5f)) + ((pot) * vec2(offset))) / vec2(pyrBaseSize), (lod))\\nconst int PYRAMID_MAX_OCTAVES = int(@PYRAMID_MAX_OCTAVES@);\\nconst int PYRAMID_MAX_LEVELS = int(@PYRAMID_MAX_LEVELS@);\\nconst float F_PYRAMID_MAX_LEVELS = float(@PYRAMID_MAX_LEVELS@);\\nconst float LOG2_PYRAMID_MAX_SCALE = float(@LOG2_PYRAMID_MAX_SCALE@);\\nfloat encodeLod(float lod)\\n{\\nreturn (LOG2_PYRAMID_MAX_SCALE + lod) / (LOG2_PYRAMID_MAX_SCALE + F_PYRAMID_MAX_LEVELS);\\n}\\nfloat decodeLod(float encodedLod)\\n{\\nreturn mix(0.0f,\\nencodedLod * (LOG2_PYRAMID_MAX_SCALE + F_PYRAMID_MAX_LEVELS) - LOG2_PYRAMID_MAX_SCALE,\\nencodedLod < 1.0f\\n);\\n}\\n#define isSameEncodedLod(alpha1, alpha2) (abs((alpha1) - (alpha2)) < encodedLodEps)\\nconst float encodedLodEps = 0.2f / (LOG2_PYRAMID_MAX_SCALE + F_PYRAMID_MAX_LEVELS);\\n#endif\"","module.exports = \"#ifndef _SOBEL_GLSL\\n#define _SOBEL_GLSL\\nvec4 encodeSobel(vec2 df)\\n{\\nconst vec2 zeroes = vec2(0.0f, 0.0f);\\nvec2 dmax = -max(df, zeroes);\\nvec2 dmin = min(df, zeroes);\\nreturn exp2(vec4(dmax, dmin));\\n}\\nvec2 decodeSobel(vec4 encodedSobel)\\n{\\nvec4 lg = log2(encodedSobel);\\nreturn vec2(lg.b - lg.r, lg.a - lg.g);\\n}\\n#endif\"","module.exports = \"uniform sampler2D image, layerA, layerB;\\nuniform float scaleA, scaleB, lgM, h;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nfloat score = pixel.r;\\nivec2 zero = ivec2(0, 0);\\nivec2 sizeA = textureSize(layerA, 0);\\nivec2 sizeB = textureSize(layerB, 0);\\nvec2 mid = (texCoord * texSize) + vec2(0.5f, 0.5f);\\nivec2 pa = clamp(ivec2(ceil(mid * scaleA - 1.0f)), zero, sizeA - 2);\\nivec2 pb = clamp(ivec2(ceil(mid * scaleB - 1.0f)), zero, sizeB - 2);\\nvec4 a00 = pixelAt(layerA, pa);\\nvec4 a10 = pixelAt(layerA, pa + ivec2(1, 0));\\nvec4 a01 = pixelAt(layerA, pa + ivec2(0, 1));\\nvec4 a11 = pixelAt(layerA, pa + ivec2(1, 1));\\nvec4 b00 = pixelAt(layerB, pb);\\nvec4 b10 = pixelAt(layerB, pb + ivec2(1, 0));\\nvec4 b01 = pixelAt(layerB, pb + ivec2(0, 1));\\nvec4 b11 = pixelAt(layerB, pb + ivec2(1, 1));\\nfloat maxScore = max(\\nmax(max(a00.r, a10.r), max(a01.r, a11.r)),\\nmax(max(b00.r, b10.r), max(b01.r, b11.r))\\n);\\ncolor = vec4(0.0f, pixel.gba);\\nif(score < maxScore || score == 0.0f)\\nreturn;\\nvec2 ea = fract(mid * scaleA);\\nvec2 eb = fract(mid * scaleB);\\nfloat isa = a00.b * (1.0f - ea.x) * (1.0f - ea.y) +\\na10.b * ea.x * (1.0f - ea.y) +\\na01.b * (1.0f - ea.x) * ea.y +\\na11.b * ea.x * ea.y;\\nfloat isb = b00.b * (1.0f - eb.x) * (1.0f - eb.y) +\\nb10.b * eb.x * (1.0f - eb.y) +\\nb01.b * (1.0f - eb.x) * eb.y +\\nb11.b * eb.x * eb.y;\\ncolor = (isa > score && isa > isb) ? vec4(isa, pixel.gb, a00.a) : pixel;\\ncolor = (isb > score && isb > isa) ? vec4(isb, pixel.gb, b00.a) : pixel;\\nfloat y1 = isa, y2 = isb, y3 = score;\\nfloat x1 = lgM - (lgM + h) * a00.a;\\nfloat x2 = lgM - (lgM + h) * b00.a;\\nfloat x3 = lgM - (lgM + h) * pixel.a;\\nfloat dn = (x1 - x2) * (x1 - x3) * (x2 - x3);\\nif(abs(dn) < 0.00001f)\\nreturn;\\nfloat a = (x3 * (y2 - y1) + x2 * (y1 - y3) + x1 * (y3 - y2)) / dn;\\nif(a >= 0.0f)\\nreturn;\\nfloat b = (x3 * x3 * (y1 - y2) + x2 * x2 * (y3 - y1) + x1 * x1 * (y2 - y3)) / dn;\\nfloat c = (x2 * x3 * (x2 - x3) * y1 + x3 * x1 * (x3 - x1) * y2 + x1 * x2 * (x1 - x2) * y3) / dn;\\nfloat xv = -b / (2.0f * a);\\nfloat yv = c - (b * b) / (4.0f * a);\\nif(xv < min(x1, min(x2, x3)) || xv > max(x1, max(x2, x3)))\\nreturn;\\nfloat interpolatedScale = (lgM - xv) / (lgM + h);\\nfloat interpolatedScore = clamp(yv, 0.0f, 1.0f);\\ncolor = vec4(interpolatedScore, pixel.gb, interpolatedScale);\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform float threshold;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nfloat t = clamp(threshold, 0.0f, 1.0f);\\nfloat ct = pixel.g + t, c_t = pixel.g - t;\\nfloat p0 = pixelAtShortOffset(image, ivec2(0, 2)).g;\\nfloat p1 = pixelAtShortOffset(image, ivec2(1, 2)).g;\\nfloat p2 = pixelAtShortOffset(image, ivec2(2, 1)).g;\\nfloat p3 = pixelAtShortOffset(image, ivec2(2, 0)).g;\\nfloat p4 = pixelAtShortOffset(image, ivec2(2, -1)).g;\\nfloat p5 = pixelAtShortOffset(image, ivec2(1, -2)).g;\\nfloat p6 = pixelAtShortOffset(image, ivec2(0, -2)).g;\\nfloat p7 = pixelAtShortOffset(image, ivec2(-1, -2)).g;\\nfloat p8 = pixelAtShortOffset(image, ivec2(-2, -1)).g;\\nfloat p9 = pixelAtShortOffset(image, ivec2(-2, 0)).g;\\nfloat p10 = pixelAtShortOffset(image, ivec2(-2, 1)).g;\\nfloat p11 = pixelAtShortOffset(image, ivec2(-1, 2)).g;\\nvec2 scores = vec2(0.0f, 0.0f);\\nscores += vec2(max(c_t - p0, 0.0f), max(p0 - ct, 0.0f));\\nscores += vec2(max(c_t - p1, 0.0f), max(p1 - ct, 0.0f));\\nscores += vec2(max(c_t - p2, 0.0f), max(p2 - ct, 0.0f));\\nscores += vec2(max(c_t - p3, 0.0f), max(p3 - ct, 0.0f));\\nscores += vec2(max(c_t - p4, 0.0f), max(p4 - ct, 0.0f));\\nscores += vec2(max(c_t - p5, 0.0f), max(p5 - ct, 0.0f));\\nscores += vec2(max(c_t - p6, 0.0f), max(p6 - ct, 0.0f));\\nscores += vec2(max(c_t - p7, 0.0f), max(p7 - ct, 0.0f));\\nscores += vec2(max(c_t - p8, 0.0f), max(p8 - ct, 0.0f));\\nscores += vec2(max(c_t - p9, 0.0f), max(p9 - ct, 0.0f));\\nscores += vec2(max(c_t - p10, 0.0f), max(p10 - ct, 0.0f));\\nscores += vec2(max(c_t - p11, 0.0f), max(p11 - ct, 0.0f));\\nfloat score = max(scores.x, scores.y) / 12.0f;\\ncolor = vec4(score * step(1.0f, pixel.r), pixel.g, score, pixel.a);\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform float threshold;\\nconst vec4 zeroes = vec4(0.0f, 0.0f, 0.0f, 0.0f);\\nconst vec4 ones = vec4(1.0f, 1.0f, 1.0f, 1.0f);\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nfloat t = clamp(threshold, 0.0f, 1.0f);\\nfloat ct = pixel.g + t, c_t = pixel.g - t;\\nmat4 mp = mat4(\\npixelAtShortOffset(image, ivec2(0, 3)).g,\\npixelAtShortOffset(image, ivec2(1, 3)).g,\\npixelAtShortOffset(image, ivec2(2, 2)).g,\\npixelAtShortOffset(image, ivec2(3, 1)).g,\\npixelAtShortOffset(image, ivec2(3, 0)).g,\\npixelAtShortOffset(image, ivec2(3, -1)).g,\\npixelAtShortOffset(image, ivec2(2, -2)).g,\\npixelAtShortOffset(image, ivec2(1, -3)).g,\\npixelAtShortOffset(image, ivec2(0, -3)).g,\\npixelAtShortOffset(image, ivec2(-1, -3)).g,\\npixelAtShortOffset(image, ivec2(-2, -2)).g,\\npixelAtShortOffset(image, ivec2(-3, -1)).g,\\npixelAtShortOffset(image, ivec2(-3, 0)).g,\\npixelAtShortOffset(image, ivec2(-3, 1)).g,\\npixelAtShortOffset(image, ivec2(-2, 2)).g,\\npixelAtShortOffset(image, ivec2(-1, 3)).g\\n);\\nmat4 mct = mp - mat4(\\nct, ct, ct, ct,\\nct, ct, ct, ct,\\nct, ct, ct, ct,\\nct, ct, ct, ct\\n), mc_t = mat4(\\nc_t, c_t, c_t, c_t,\\nc_t, c_t, c_t, c_t,\\nc_t, c_t, c_t, c_t,\\nc_t, c_t, c_t, c_t\\n) - mp;\\nvec4 bs = max(mc_t[0], zeroes), ds = max(mct[0], zeroes);\\nbs += max(mc_t[1], zeroes); ds += max(mct[1], zeroes);\\nbs += max(mc_t[2], zeroes); ds += max(mct[2], zeroes);\\nbs += max(mc_t[3], zeroes); ds += max(mct[3], zeroes);\\nfloat score = max(dot(bs, ones), dot(ds, ones)) / 16.0f;\\ncolor = vec4(score * step(1.0f, pixel.r), pixel.g, score, pixel.a);\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform float threshold;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nfloat t = clamp(threshold, 0.0f, 1.0f);\\nfloat ct = pixel.g + t, c_t = pixel.g - t;\\nfloat p0 = pixelAtShortOffset(image, ivec2(0, 1)).g;\\nfloat p1 = pixelAtShortOffset(image, ivec2(1, 1)).g;\\nfloat p2 = pixelAtShortOffset(image, ivec2(1, 0)).g;\\nfloat p3 = pixelAtShortOffset(image, ivec2(1, -1)).g;\\nfloat p4 = pixelAtShortOffset(image, ivec2(0, -1)).g;\\nfloat p5 = pixelAtShortOffset(image, ivec2(-1, -1)).g;\\nfloat p6 = pixelAtShortOffset(image, ivec2(-1, 0)).g;\\nfloat p7 = pixelAtShortOffset(image, ivec2(-1, 1)).g;\\nvec2 scores = vec2(0.0f, 0.0f);\\nscores += vec2(max(c_t - p0, 0.0f), max(p0 - ct, 0.0f));\\nscores += vec2(max(c_t - p1, 0.0f), max(p1 - ct, 0.0f));\\nscores += vec2(max(c_t - p2, 0.0f), max(p2 - ct, 0.0f));\\nscores += vec2(max(c_t - p3, 0.0f), max(p3 - ct, 0.0f));\\nscores += vec2(max(c_t - p4, 0.0f), max(p4 - ct, 0.0f));\\nscores += vec2(max(c_t - p5, 0.0f), max(p5 - ct, 0.0f));\\nscores += vec2(max(c_t - p6, 0.0f), max(p6 - ct, 0.0f));\\nscores += vec2(max(c_t - p7, 0.0f), max(p7 - ct, 0.0f));\\nfloat score = max(scores.x, scores.y) / 8.0f;\\ncolor = vec4(score * step(1.0f, pixel.r), pixel.g, score, pixel.a);\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform float threshold;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nivec2 size = outputSize();\\nvec4 pixel = threadPixel(image);\\ncolor = vec4(0.0f, pixel.gba);\\nif(\\nthread.x >= 3 && thread.x < size.x - 3 &&\\nthread.y >= 3 && thread.y < size.y - 3\\n) {\\nfloat t = clamp(threshold, 0.0f, 1.0f);\\nfloat c = pixel.g;\\nfloat ct = c + t, c_t = c - t;\\nfloat p0 = pixelAtShortOffset(image, ivec2(0, 1)).g;\\nfloat p1 = pixelAtShortOffset(image, ivec2(1, 1)).g;\\nfloat p2 = pixelAtShortOffset(image, ivec2(1, 0)).g;\\nfloat p3 = pixelAtShortOffset(image, ivec2(1, -1)).g;\\nfloat p4 = pixelAtShortOffset(image, ivec2(0, -1)).g;\\nfloat p5 = pixelAtShortOffset(image, ivec2(-1, -1)).g;\\nfloat p6 = pixelAtShortOffset(image, ivec2(-1, 0)).g;\\nfloat p7 = pixelAtShortOffset(image, ivec2(-1, 1)).g;\\nbool possibleCorner =\\n((c_t > p1 || c_t > p5) && (c_t > p3 || c_t > p7)) ||\\n((ct < p1  || ct < p5)  && (ct < p3  || ct < p7))  ;\\nif(possibleCorner) {\\nint bright = 0, dark = 0, bc = 0, dc = 0;\\nif(c_t > p0) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p0) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p1) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p1) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p2) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p2) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p3) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p3) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p4) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p4) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p5) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p5) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p6) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p6) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p7) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p7) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(bright < 5 && dark < 5) {\\nif(bc > 0 && bc < 5) do {\\nif(c_t > p0)           bc += 1; else break;\\nif(c_t > p1 && bc < 5) bc += 1; else break;\\nif(c_t > p2 && bc < 5) bc += 1; else break;\\nif(c_t > p3 && bc < 5) bc += 1; else break;\\n} while(false);\\nif(dc > 0 && dc < 5) do {\\nif(ct < p0)           dc += 1; else break;\\nif(ct < p1 && dc < 5) dc += 1; else break;\\nif(ct < p2 && dc < 5) dc += 1; else break;\\nif(ct < p3 && dc < 5) dc += 1; else break;\\n} while(false);\\nif(bc >= 5 || dc >= 5)\\ncolor = vec4(1.0f, pixel.gba);\\n}\\nelse {\\ncolor = vec4(1.0f, pixel.gba);\\n}\\n}\\n}\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform float threshold;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nivec2 size = outputSize();\\nvec4 pixel = threadPixel(image);\\ncolor = vec4(0.0f, pixel.gba);\\nif(\\nthread.x >= 3 && thread.x < size.x - 3 &&\\nthread.y >= 3 && thread.y < size.y - 3\\n) {\\nfloat t = clamp(threshold, 0.0f, 1.0f);\\nfloat c = pixel.g;\\nfloat ct = c + t, c_t = c - t;\\nfloat p0 = pixelAtShortOffset(image, ivec2(0, 2)).g;\\nfloat p1 = pixelAtShortOffset(image, ivec2(1, 2)).g;\\nfloat p2 = pixelAtShortOffset(image, ivec2(2, 1)).g;\\nfloat p3 = pixelAtShortOffset(image, ivec2(2, 0)).g;\\nfloat p4 = pixelAtShortOffset(image, ivec2(2, -1)).g;\\nfloat p5 = pixelAtShortOffset(image, ivec2(1, -2)).g;\\nfloat p6 = pixelAtShortOffset(image, ivec2(0, -2)).g;\\nfloat p7 = pixelAtShortOffset(image, ivec2(-1, -2)).g;\\nfloat p8 = pixelAtShortOffset(image, ivec2(-2, -1)).g;\\nfloat p9 = pixelAtShortOffset(image, ivec2(-2, 0)).g;\\nfloat p10 = pixelAtShortOffset(image, ivec2(-2, 1)).g;\\nfloat p11 = pixelAtShortOffset(image, ivec2(-1, 2)).g;\\nbool possibleCorner =\\n((c_t > p0 || c_t > p6) && (c_t > p3 || c_t > p9)) ||\\n((ct < p0  || ct < p6)  && (ct < p3  || ct < p9))  ;\\nif(possibleCorner) {\\nint bright = 0, dark = 0, bc = 0, dc = 0;\\nif(c_t > p0) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p0) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p1) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p1) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p2) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p2) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p3) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p3) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p4) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p4) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p5) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p5) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p6) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p6) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p7) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p7) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p8) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p8) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p9) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p9) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p10) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p10) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(c_t > p11) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\\nelse { bc = 0; if(ct < p11) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\\nif(bright < 7 && dark < 7) {\\nif(bc > 0 && bc < 7) do {\\nif(c_t > p0)           bc += 1; else break;\\nif(c_t > p1 && bc < 7) bc += 1; else break;\\nif(c_t > p2 && bc < 7) bc += 1; else break;\\nif(c_t > p3 && bc < 7) bc += 1; else break;\\nif(c_t > p4 && bc < 7) bc += 1; else break;\\nif(c_t > p5 && bc < 7) bc += 1; else break;\\n} while(false);\\nif(dc > 0 && dc < 7) do {\\nif(ct < p0)           dc += 1; else break;\\nif(ct < p1 && dc < 7) dc += 1; else break;\\nif(ct < p2 && dc < 7) dc += 1; else break;\\nif(ct < p3 && dc < 7) dc += 1; else break;\\nif(ct < p4 && dc < 7) dc += 1; else break;\\nif(ct < p5 && dc < 7) dc += 1; else break;\\n} while(false);\\nif(bc >= 7 || dc >= 7)\\ncolor = vec4(1.0f, pixel.gba);\\n}\\nelse {\\ncolor = vec4(1.0f, pixel.gba);\\n}\\n}\\n}\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform float threshold;\\nconst ivec4 margin = ivec4(3, 3, 4, 4);\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nivec2 thread = threadLocation();\\nivec2 size = outputSize();\\ncolor = vec4(0.0f, pixel.gba);\\nif(any(lessThan(ivec4(thread, size - thread), margin)))\\nreturn;\\nfloat t = clamp(threshold, 0.0f, 1.0f);\\nfloat ct = pixel.g + t, c_t = pixel.g - t;\\nfloat p0 = pixelAtShortOffset(image, ivec2(0, 3)).g;\\nfloat p4 = pixelAtShortOffset(image, ivec2(3, 0)).g;\\nfloat p8 = pixelAtShortOffset(image, ivec2(0, -3)).g;\\nfloat p12 = pixelAtShortOffset(image, ivec2(-3, 0)).g;\\nif(!(\\n((c_t > p0 || c_t > p8) && (c_t > p4 || c_t > p12)) ||\\n((ct < p0  || ct < p8)  && (ct < p4  || ct < p12))\\n))\\nreturn;\\nfloat p1 = pixelAtShortOffset(image, ivec2(1, 3)).g;\\nfloat p2 = pixelAtShortOffset(image, ivec2(2, 2)).g;\\nfloat p3 = pixelAtShortOffset(image, ivec2(3, 1)).g;\\nfloat p5 = pixelAtShortOffset(image, ivec2(3, -1)).g;\\nfloat p6 = pixelAtShortOffset(image, ivec2(2, -2)).g;\\nfloat p7 = pixelAtShortOffset(image, ivec2(1, -3)).g;\\nfloat p9 = pixelAtShortOffset(image, ivec2(-1, -3)).g;\\nfloat p10 = pixelAtShortOffset(image, ivec2(-2, -2)).g;\\nfloat p11 = pixelAtShortOffset(image, ivec2(-3, -1)).g;\\nfloat p13 = pixelAtShortOffset(image, ivec2(-3, 1)).g;\\nfloat p14 = pixelAtShortOffset(image, ivec2(-2, 2)).g;\\nfloat p15 = pixelAtShortOffset(image, ivec2(-1, 3)).g;\\nbool A=(p0>ct),B=(p1>ct),C=(p2>ct),D=(p3>ct),E=(p4>ct),F=(p5>ct),G=(p6>ct),H=(p7>ct),I=(p8>ct),J=(p9>ct),K=(p10>ct),L=(p11>ct),M=(p12>ct),N=(p13>ct),O=(p14>ct),P=(p15>ct),a=(p0<c_t),b=(p1<c_t),c=(p2<c_t),d=(p3<c_t),e=(p4<c_t),f=(p5<c_t),g=(p6<c_t),h=(p7<c_t),i=(p8<c_t),j=(p9<c_t),k=(p10<c_t),l=(p11<c_t),m=(p12<c_t),n=(p13<c_t),o=(p14<c_t),p=(p15<c_t);\\nbool isCorner=A&&(B&&(K&&L&&J&&(M&&N&&O&&P||G&&H&&I&&(M&&N&&O||F&&(M&&N||E&&(M||D))))||C&&(K&&L&&M&&(N&&O&&P||G&&H&&I&&J&&(N&&O||F&&(N||E)))||D&&(N&&(L&&M&&(K&&G&&H&&I&&J&&(O||F)||O&&P)||k&&l&&m&&e&&f&&g&&h&&i&&j)||E&&(O&&(M&&N&&(K&&L&&G&&H&&I&&J||P)||k&&l&&m&&n&&f&&g&&h&&i&&j)||F&&(P&&(N&&O||k&&l&&m&&n&&o&&g&&h&&i&&j)||G&&(O&&P||H&&(P||I)||k&&l&&m&&n&&o&&p&&h&&i&&j)||k&&l&&m&&n&&o&&h&&i&&j&&(p||g))||k&&l&&m&&n&&h&&i&&j&&(o&&(p||g)||f&&(o&&p||g)))||k&&l&&m&&h&&i&&j&&(n&&(o&&p||g&&(o||f))||e&&(n&&o&&p||g&&(n&&o||f))))||k&&l&&h&&i&&j&&(m&&(n&&o&&p||g&&(n&&o||f&&(n||e)))||d&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e)))))||k&&h&&i&&j&&(l&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d))))))||K&&I&&J&&(L&&M&&N&&O&&P||G&&H&&(L&&M&&N&&O||F&&(L&&M&&N||E&&(L&&M||D&&(L||C)))))||h&&i&&j&&(b&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c)))))||k&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c)))))))||B&&(H&&I&&J&&(K&&L&&M&&N&&O&&P&&a||G&&(K&&L&&M&&N&&O&&a||F&&(K&&L&&M&&N&&a||E&&(K&&L&&M&&a||D&&(K&&L&&a||C)))))||a&&k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||C&&(K&&H&&I&&J&&(L&&M&&N&&O&&P&&a&&b||G&&(L&&M&&N&&O&&a&&b||F&&(L&&M&&N&&a&&b||E&&(L&&M&&a&&b||D))))||a&&b&&k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d)))))||D&&(K&&L&&H&&I&&J&&(M&&N&&O&&P&&a&&b&&c||G&&(M&&N&&O&&a&&b&&c||F&&(M&&N&&a&&b&&c||E)))||a&&b&&k&&l&&m&&c&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e))))||E&&(K&&L&&M&&H&&I&&J&&(N&&O&&P&&a&&b&&c&&d||G&&(N&&O&&a&&b&&c&&d||F))||a&&b&&l&&m&&n&&c&&d&&(k&&g&&h&&i&&j&&(o||f)||o&&p))||F&&(K&&L&&M&&N&&H&&I&&J&&(O&&P&&a&&b&&c&&d&&e||G)||a&&b&&m&&n&&o&&c&&d&&e&&(k&&l&&g&&h&&i&&j||p))||G&&(K&&L&&M&&N&&O&&H&&I&&J||a&&b&&n&&o&&p&&c&&d&&e&&f)||H&&(K&&L&&M&&N&&O&&P&&I&&J||a&&b&&o&&p&&c&&d&&e&&f&&g)||a&&(b&&(k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(k&&l&&m&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e)))||d&&(l&&m&&n&&(k&&g&&h&&i&&j&&(o||f)||o&&p)||e&&(m&&n&&o&&(k&&l&&g&&h&&i&&j||p)||f&&(n&&o&&p||g&&(o&&p||h&&(p||i)))))))||k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||h&&i&&j&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c&&(b||k))))));\\ncolor = vec4(float(isCorner), pixel.gba);\\n}\"","module.exports = \"uniform sampler2D corners;\\nuniform sampler2D maxScore;\\nuniform float quality;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(corners);\\nfloat threshold = threadPixel(maxScore).r * clamp(quality, 0.0f, 1.0f);\\nfloat score = step(threshold, pixel.r) * pixel.r;\\ncolor = vec4(score, pixel.gba);\\n}\"","module.exports = \"@include \\\"pyramids.glsl\\\"\\nuniform sampler2D pyramid;\\nuniform float threshold;\\nuniform int numberOfOctaves;\\nconst ivec4 margin = ivec4(3, 3, 4, 4);\\nconst vec4 zeroes = vec4(0.0f, 0.0f, 0.0f, 0.0f);\\nconst vec4 ones = vec4(1.0f, 1.0f, 1.0f, 1.0f);\\nvoid main()\\n{\\nvec4 pixel = threadPixel(pyramid);\\nivec2 thread = threadLocation();\\nivec2 size = outputSize();\\nfloat t = clamp(threshold, 0.0f, 1.0f);\\nfloat ct = pixel.g + t, c_t = pixel.g - t;\\nvec2 best = vec2(0.0f, pixel.a);\\n#ifdef USE_HARRIS_SCORE\\nvec2 dfmm[PYRAMID_MAX_OCTAVES], dfm0[PYRAMID_MAX_OCTAVES], dfm1[PYRAMID_MAX_OCTAVES],\\ndf0m[PYRAMID_MAX_OCTAVES], df00[PYRAMID_MAX_OCTAVES], df01[PYRAMID_MAX_OCTAVES],\\ndf1m[PYRAMID_MAX_OCTAVES], df10[PYRAMID_MAX_OCTAVES], df11[PYRAMID_MAX_OCTAVES];\\nfloat pyrpix = 0.0f;\\nfor(int l = 0; l < numberOfOctaves; l++) {\\nfloat lod = float(l) * 0.5f;\\nfloat pot = exp2(lod);\\npyrpix = pyrPixelAtOffset(pyramid, lod, pot, ivec2(-1,-1)).g;\\ndfmm[l] = vec2(dFdx(pyrpix), dFdy(pyrpix));\\npyrpix = pyrPixelAtOffset(pyramid, lod, pot, ivec2(-1,0)).g;\\ndfm0[l] = vec2(dFdx(pyrpix), dFdy(pyrpix));\\npyrpix = pyrPixelAtOffset(pyramid, lod, pot, ivec2(-1,1)).g;\\ndfm1[l] = vec2(dFdx(pyrpix), dFdy(pyrpix));\\npyrpix = pyrPixelAtOffset(pyramid, lod, pot, ivec2(0,-1)).g;\\ndf0m[l] = vec2(dFdx(pyrpix), dFdy(pyrpix));\\npyrpix = pyrPixelAtOffset(pyramid, lod, pot, ivec2(0,0)).g;\\ndf00[l] = vec2(dFdx(pyrpix), dFdy(pyrpix));\\npyrpix = pyrPixelAtOffset(pyramid, lod, pot, ivec2(0,1)).g;\\ndf01[l] = vec2(dFdx(pyrpix), dFdy(pyrpix));\\npyrpix = pyrPixelAtOffset(pyramid, lod, pot, ivec2(1,-1)).g;\\ndf1m[l] = vec2(dFdx(pyrpix), dFdy(pyrpix));\\npyrpix = pyrPixelAtOffset(pyramid, lod, pot, ivec2(1,0)).g;\\ndf10[l] = vec2(dFdx(pyrpix), dFdy(pyrpix));\\npyrpix = pyrPixelAtOffset(pyramid, lod, pot, ivec2(1,1)).g;\\ndf11[l] = vec2(dFdx(pyrpix), dFdy(pyrpix));\\n}\\n#endif\\ncolor = vec4(0.0f, pixel.g, 0.0f, pixel.a);\\nfloat lod = 0.0f, pot = 1.0f;\\nfor(int octave = 0; octave < numberOfOctaves; octave++, pot = exp2(lod += 0.5f)) {\\npixel = pyrPixel(pyramid, lod);\\nct = pixel.g + t;\\nc_t = pixel.g - t;\\nvec4 p4k = vec4(\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(0, 3)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(3, 0)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(0, -3)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-3, 0)).g\\n);\\nmat4 mp = mat4(\\np4k.x,\\np4k.y,\\np4k.z,\\np4k.w,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(1, 3)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(3, -1)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-1, -3)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-3, 1)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(2, 2)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(2, -2)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-2, -2)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-2, 2)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(3, 1)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(1, -3)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-3, -1)).g,\\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-1, 3)).g\\n);\\nbool A=(mp[0][0]>ct),B=(mp[1][0]>ct),C=(mp[2][0]>ct),D=(mp[3][0]>ct),E=(mp[0][1]>ct),F=(mp[1][1]>ct),G=(mp[2][1]>ct),H=(mp[3][1]>ct),I=(mp[0][2]>ct),J=(mp[1][2]>ct),K=(mp[2][2]>ct),L=(mp[3][2]>ct),M=(mp[0][3]>ct),N=(mp[1][3]>ct),O=(mp[2][3]>ct),P=(mp[3][3]>ct),a=(mp[0][0]<c_t),b=(mp[1][0]<c_t),c=(mp[2][0]<c_t),d=(mp[3][0]<c_t),e=(mp[0][1]<c_t),f=(mp[1][1]<c_t),g=(mp[2][1]<c_t),h=(mp[3][1]<c_t),i=(mp[0][2]<c_t),j=(mp[1][2]<c_t),k=(mp[2][2]<c_t),l=(mp[3][2]<c_t),m=(mp[0][3]<c_t),n=(mp[1][3]<c_t),o=(mp[2][3]<c_t),p=(mp[3][3]<c_t);\\nbool isCorner=A&&(B&&(K&&L&&J&&(M&&N&&O&&P||G&&H&&I&&(M&&N&&O||F&&(M&&N||E&&(M||D))))||C&&(K&&L&&M&&(N&&O&&P||G&&H&&I&&J&&(N&&O||F&&(N||E)))||D&&(N&&(L&&M&&(K&&G&&H&&I&&J&&(O||F)||O&&P)||k&&l&&m&&e&&f&&g&&h&&i&&j)||E&&(O&&(M&&N&&(K&&L&&G&&H&&I&&J||P)||k&&l&&m&&n&&f&&g&&h&&i&&j)||F&&(P&&(N&&O||k&&l&&m&&n&&o&&g&&h&&i&&j)||G&&(O&&P||H&&(P||I)||k&&l&&m&&n&&o&&p&&h&&i&&j)||k&&l&&m&&n&&o&&h&&i&&j&&(p||g))||k&&l&&m&&n&&h&&i&&j&&(o&&(p||g)||f&&(o&&p||g)))||k&&l&&m&&h&&i&&j&&(n&&(o&&p||g&&(o||f))||e&&(n&&o&&p||g&&(n&&o||f))))||k&&l&&h&&i&&j&&(m&&(n&&o&&p||g&&(n&&o||f&&(n||e)))||d&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e)))))||k&&h&&i&&j&&(l&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d))))))||K&&I&&J&&(L&&M&&N&&O&&P||G&&H&&(L&&M&&N&&O||F&&(L&&M&&N||E&&(L&&M||D&&(L||C)))))||h&&i&&j&&(b&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c)))))||k&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c)))))))||B&&(H&&I&&J&&(K&&L&&M&&N&&O&&P&&a||G&&(K&&L&&M&&N&&O&&a||F&&(K&&L&&M&&N&&a||E&&(K&&L&&M&&a||D&&(K&&L&&a||C)))))||a&&k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||C&&(K&&H&&I&&J&&(L&&M&&N&&O&&P&&a&&b||G&&(L&&M&&N&&O&&a&&b||F&&(L&&M&&N&&a&&b||E&&(L&&M&&a&&b||D))))||a&&b&&k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d)))))||D&&(K&&L&&H&&I&&J&&(M&&N&&O&&P&&a&&b&&c||G&&(M&&N&&O&&a&&b&&c||F&&(M&&N&&a&&b&&c||E)))||a&&b&&k&&l&&m&&c&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e))))||E&&(K&&L&&M&&H&&I&&J&&(N&&O&&P&&a&&b&&c&&d||G&&(N&&O&&a&&b&&c&&d||F))||a&&b&&l&&m&&n&&c&&d&&(k&&g&&h&&i&&j&&(o||f)||o&&p))||F&&(K&&L&&M&&N&&H&&I&&J&&(O&&P&&a&&b&&c&&d&&e||G)||a&&b&&m&&n&&o&&c&&d&&e&&(k&&l&&g&&h&&i&&j||p))||G&&(K&&L&&M&&N&&O&&H&&I&&J||a&&b&&n&&o&&p&&c&&d&&e&&f)||H&&(K&&L&&M&&N&&O&&P&&I&&J||a&&b&&o&&p&&c&&d&&e&&f&&g)||a&&(b&&(k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(k&&l&&m&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e)))||d&&(l&&m&&n&&(k&&g&&h&&i&&j&&(o||f)||o&&p)||e&&(m&&n&&o&&(k&&l&&g&&h&&i&&j||p)||f&&(n&&o&&p||g&&(o&&p||h&&(p||i)))))))||k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||h&&i&&j&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c&&(b||k))))));\\nfloat score = 0.0f;\\n#ifdef USE_HARRIS_SCORE\\nvec2 df0 = dfmm[octave], df1 = dfm0[octave], df2 = dfm1[octave],\\ndf3 = df0m[octave], df4 = df00[octave], df5 = df01[octave],\\ndf6 = df1m[octave], df7 = df10[octave], df8 = df11[octave];\\nvec3 hm = vec3(0.0f);\\nhm += vec3(df0.x * df0.x, df0.x * df0.y, df0.y * df0.y);\\nhm += vec3(df1.x * df1.x, df1.x * df1.y, df1.y * df1.y);\\nhm += vec3(df2.x * df2.x, df2.x * df2.y, df2.y * df2.y);\\nhm += vec3(df3.x * df3.x, df3.x * df3.y, df3.y * df3.y);\\nhm += vec3(df4.x * df4.x, df4.x * df4.y, df4.y * df4.y);\\nhm += vec3(df5.x * df5.x, df5.x * df5.y, df5.y * df5.y);\\nhm += vec3(df6.x * df6.x, df6.x * df6.y, df6.y * df6.y);\\nhm += vec3(df7.x * df7.x, df7.x * df7.y, df7.y * df7.y);\\nhm += vec3(df8.x * df8.x, df8.x * df8.y, df8.y * df8.y);\\nfloat response = 0.5f * (hm.x + hm.z - sqrt((hm.x - hm.z) * (hm.x - hm.z) + 4.0f * hm.y * hm.y));\\nconst float WINDOW_AREA = 9.0f;\\nconst float EIGENVALUE_NORMALIZER = 3.0f / WINDOW_AREA;\\nscore = clamp(response * EIGENVALUE_NORMALIZER, 0.0f, 1.0f);\\n#else\\nmat4 mct = mp - mat4(\\nct, ct, ct, ct,\\nct, ct, ct, ct,\\nct, ct, ct, ct,\\nct, ct, ct, ct\\n), mc_t = mat4(\\nc_t, c_t, c_t, c_t,\\nc_t, c_t, c_t, c_t,\\nc_t, c_t, c_t, c_t,\\nc_t, c_t, c_t, c_t\\n) - mp;\\nvec4 bs = max(mc_t[0], zeroes), ds = max(mct[0], zeroes);\\nbs += max(mc_t[1], zeroes); ds += max(mct[1], zeroes);\\nbs += max(mc_t[2], zeroes); ds += max(mct[2], zeroes);\\nbs += max(mc_t[3], zeroes); ds += max(mct[3], zeroes);\\nscore = max(dot(bs, ones), dot(ds, ones)) / 16.0f;\\n#endif\\nscore *= float(isCorner);\\nivec2 remainder = thread % int(pot);\\nscore *= float(remainder.x + remainder.y == 0);\\nfloat scale = encodeLod(lod);\\nbest = (score > best.x) ? vec2(score, scale) : best;\\n}\\ncolor.rba = best.xxy;\\n}\"","module.exports = \"@include \\\"sobel.glsl\\\"\\n@include \\\"pyramids.glsl\\\"\\nuniform sampler2D pyramid;\\nuniform int windowSize;\\nuniform int numberOfOctaves;\\nuniform sampler2D sobelDerivatives[@PYRAMID_MAX_OCTAVES@];\\nvec4 pickSobelDerivatives(int index, ivec2 offset)\\n{\\nswitch(index) {\\ncase 0:  return textureLod(sobelDerivatives[0], texCoord + vec2(offset) / texSize, 0.0f);\\ncase 1:  return textureLod(sobelDerivatives[1], texCoord + vec2(offset) / texSize, 0.0f);\\ncase 2:  return textureLod(sobelDerivatives[2], texCoord + vec2(offset) / texSize, 0.0f);\\ncase 3:  return textureLod(sobelDerivatives[3], texCoord + vec2(offset) / texSize, 0.0f);\\ncase 4:  return textureLod(sobelDerivatives[4], texCoord + vec2(offset) / texSize, 0.0f);\\ncase 5:  return textureLod(sobelDerivatives[5], texCoord + vec2(offset) / texSize, 0.0f);\\ncase 6:  return textureLod(sobelDerivatives[6], texCoord + vec2(offset) / texSize, 0.0f);\\ndefault: return textureLod(sobelDerivatives[0], texCoord + vec2(offset) / texSize, 0.0f);\\n}\\n}\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nvec4 pixel = threadPixel(pyramid);\\nvec2 best = vec2(0.0f, pixel.a);\\nint r = (windowSize - 1) / 2;\\nfloat windowArea = float(windowSize * windowSize);\\nfor(int octave = 0; octave < numberOfOctaves; octave++) {\\nvec3 m = vec3(0.0f, 0.0f, 0.0f);\\nfor(int j = 0; j < windowSize; j++) {\\nfor(int i = 0; i < windowSize; i++) {\\nvec2 df = decodeSobel(pickSobelDerivatives(octave, ivec2(i-r, j-r)));\\nm += vec3(df.x * df.x, df.x * df.y, df.y * df.y);\\n}\\n}\\nfloat response = 0.5f * (m.x + m.z - sqrt((m.x - m.z) * (m.x - m.z) + 4.0f * m.y * m.y));\\nfloat normalizer = 3.0f / windowArea;\\nfloat score = clamp(response * normalizer, 0.0f, 1.0f);\\nfloat lod = 0.5f * float(octave);\\nfloat scale = encodeLod(lod);\\nbest = (score > best.x) ? vec2(score, scale) : best;\\n}\\ncolor = vec4(best.x, pixel.g, best.xy);\\n}\"","module.exports = \"@include \\\"pyramids.glsl\\\"\\nuniform sampler2D image;\\n#define ENABLE_INNER_RING\\n#define ENABLE_MIDDLE_RING\\n#define ENABLE_OUTER_RING\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nfloat lod = decodeLod(pixel.a);\\nfloat lodJump = 0.5f;\\ncolor = pixel;\\nif(pixel.r == 0.0f)\\nreturn;\\n#ifdef ENABLE_INNER_RING\\nvec4 p0 = pixelAtShortOffset(image, ivec2(0, 1));\\nvec4 p1 = pixelAtShortOffset(image, ivec2(1, 1));\\nvec4 p2 = pixelAtShortOffset(image, ivec2(1, 0));\\nvec4 p3 = pixelAtShortOffset(image, ivec2(1, -1));\\nvec4 p4 = pixelAtShortOffset(image, ivec2(0, -1));\\nvec4 p5 = pixelAtShortOffset(image, ivec2(-1, -1));\\nvec4 p6 = pixelAtShortOffset(image, ivec2(-1, 0));\\nvec4 p7 = pixelAtShortOffset(image, ivec2(-1, 1));\\n#else\\nvec4 p0, p1, p2, p3, p4, p5, p6, p7;\\np0 = p1 = p2 = p3 = p4 = p5 = p6 = p7 = vec4(0.0f, 0.0f, 0.0f, 1.0f);\\n#endif\\n#ifdef ENABLE_MIDDLE_RING\\nvec4 q0 = pixelAtShortOffset(image, ivec2(0, 2));\\nvec4 q1 = pixelAtShortOffset(image, ivec2(1, 2));\\nvec4 q2 = pixelAtShortOffset(image, ivec2(2, 2));\\nvec4 q3 = pixelAtShortOffset(image, ivec2(2, 1));\\nvec4 q4 = pixelAtShortOffset(image, ivec2(2, 0));\\nvec4 q5 = pixelAtShortOffset(image, ivec2(2, -1));\\nvec4 q6 = pixelAtShortOffset(image, ivec2(2, -2));\\nvec4 q7 = pixelAtShortOffset(image, ivec2(1, -2));\\nvec4 q8 = pixelAtShortOffset(image, ivec2(0, -2));\\nvec4 q9 = pixelAtShortOffset(image, ivec2(-1, -2));\\nvec4 q10 = pixelAtShortOffset(image, ivec2(-2, -2));\\nvec4 q11 = pixelAtShortOffset(image, ivec2(-2, -1));\\nvec4 q12 = pixelAtShortOffset(image, ivec2(-2, 0));\\nvec4 q13 = pixelAtShortOffset(image, ivec2(-2, 1));\\nvec4 q14 = pixelAtShortOffset(image, ivec2(-2, 2));\\nvec4 q15 = pixelAtShortOffset(image, ivec2(-1, 2));\\n#else\\nvec4 q0, q1, q2, q3, q4, q5, q6, q7, q8, q9, q10, q11, q12, q13, q14, q15;\\nq0 = q1 = q2 = q3 = q4 = q5 = q6 = q7 = q8 = q9 = q10 =\\nq11 = q12 = q13 = q14 = q15= vec4(0.0f, 0.0f, 0.0f, 1.0f);\\n#endif\\n#ifdef ENABLE_OUTER_RING\\nvec4 r0 = pixelAtShortOffset(image, ivec2(0, 3));\\nvec4 r1 = pixelAtShortOffset(image, ivec2(1, 3));\\nvec4 r2 = pixelAtShortOffset(image, ivec2(3, 1));\\nvec4 r3 = pixelAtShortOffset(image, ivec2(3, 0));\\nvec4 r4 = pixelAtShortOffset(image, ivec2(3, -1));\\nvec4 r5 = pixelAtShortOffset(image, ivec2(1, -3));\\nvec4 r6 = pixelAtShortOffset(image, ivec2(0, -3));\\nvec4 r7 = pixelAtShortOffset(image, ivec2(-1, -3));\\nvec4 r8 = pixelAtShortOffset(image, ivec2(-3, -1));\\nvec4 r9 = pixelAtShortOffset(image, ivec2(-3, 0));\\nvec4 r10 = pixelAtShortOffset(image, ivec2(-3, 1));\\nvec4 r11 = pixelAtShortOffset(image, ivec2(-1, 3));\\nvec4 r12 = pixelAtShortOffset(image, ivec2(0, 4));\\nvec4 r13 = pixelAtShortOffset(image, ivec2(4, 0));\\nvec4 r14 = pixelAtShortOffset(image, ivec2(0, -4));\\nvec4 r15 = pixelAtShortOffset(image, ivec2(-4, 0));\\n#else\\nvec4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15;\\nr0 = r1 = r2 = r3 = r4 = r5 = r6 = r7 = r8 = r9 = r10 =\\nr11 = r12 = r13 = r14 = r15 = vec4(0.0f, 0.0f, 0.0f, 1.0f);\\n#endif\\nfloat lodPlus = min(lod + lodJump, F_PYRAMID_MAX_LEVELS - 1.0f);\\nfloat lodMinus = max(lod - lodJump, 0.0f);\\nfloat alphaPlus = encodeLod(lodPlus);\\nfloat alphaMinus = encodeLod(lodMinus);\\nmat3 innerScore = mat3(\\np0.r * float(isSameEncodedLod(p0.a, alphaPlus) || isSameEncodedLod(p0.a, alphaMinus)),\\np1.r * float(isSameEncodedLod(p1.a, alphaPlus) || isSameEncodedLod(p1.a, alphaMinus)),\\np2.r * float(isSameEncodedLod(p2.a, alphaPlus) || isSameEncodedLod(p2.a, alphaMinus)),\\np3.r * float(isSameEncodedLod(p3.a, alphaPlus) || isSameEncodedLod(p3.a, alphaMinus)),\\np4.r * float(isSameEncodedLod(p4.a, alphaPlus) || isSameEncodedLod(p4.a, alphaMinus)),\\np5.r * float(isSameEncodedLod(p5.a, alphaPlus) || isSameEncodedLod(p5.a, alphaMinus)),\\np6.r * float(isSameEncodedLod(p6.a, alphaPlus) || isSameEncodedLod(p6.a, alphaMinus)),\\np7.r * float(isSameEncodedLod(p7.a, alphaPlus) || isSameEncodedLod(p7.a, alphaMinus)),\\n0.0f\\n);\\nmat4 middleScore = mat4(\\nq0.r * float(isSameEncodedLod(q0.a, alphaPlus) || isSameEncodedLod(q0.a, alphaMinus)),\\nq1.r * float(isSameEncodedLod(q1.a, alphaPlus) || isSameEncodedLod(q1.a, alphaMinus)),\\nq2.r * float(isSameEncodedLod(q2.a, alphaPlus) || isSameEncodedLod(q2.a, alphaMinus)),\\nq3.r * float(isSameEncodedLod(q3.a, alphaPlus) || isSameEncodedLod(q3.a, alphaMinus)),\\nq4.r * float(isSameEncodedLod(q4.a, alphaPlus) || isSameEncodedLod(q4.a, alphaMinus)),\\nq5.r * float(isSameEncodedLod(q5.a, alphaPlus) || isSameEncodedLod(q5.a, alphaMinus)),\\nq6.r * float(isSameEncodedLod(q6.a, alphaPlus) || isSameEncodedLod(q6.a, alphaMinus)),\\nq7.r * float(isSameEncodedLod(q7.a, alphaPlus) || isSameEncodedLod(q7.a, alphaMinus)),\\nq8.r * float(isSameEncodedLod(q8.a, alphaPlus) || isSameEncodedLod(q8.a, alphaMinus)),\\nq9.r * float(isSameEncodedLod(q9.a, alphaPlus) || isSameEncodedLod(q9.a, alphaMinus)),\\nq10.r * float(isSameEncodedLod(q10.a, alphaPlus) || isSameEncodedLod(q10.a, alphaMinus)),\\nq11.r * float(isSameEncodedLod(q11.a, alphaPlus) || isSameEncodedLod(q11.a, alphaMinus)),\\nq12.r * float(isSameEncodedLod(q12.a, alphaPlus) || isSameEncodedLod(q12.a, alphaMinus)),\\nq13.r * float(isSameEncodedLod(q13.a, alphaPlus) || isSameEncodedLod(q13.a, alphaMinus)),\\nq14.r * float(isSameEncodedLod(q14.a, alphaPlus) || isSameEncodedLod(q14.a, alphaMinus)),\\nq15.r * float(isSameEncodedLod(q15.a, alphaPlus) || isSameEncodedLod(q15.a, alphaMinus))\\n);\\nmat4 outerScore = mat4(\\nr0.r * float(isSameEncodedLod(r0.a, alphaPlus) || isSameEncodedLod(r0.a, alphaMinus)),\\nr1.r * float(isSameEncodedLod(r1.a, alphaPlus) || isSameEncodedLod(r1.a, alphaMinus)),\\nr2.r * float(isSameEncodedLod(r2.a, alphaPlus) || isSameEncodedLod(r2.a, alphaMinus)),\\nr3.r * float(isSameEncodedLod(r3.a, alphaPlus) || isSameEncodedLod(r3.a, alphaMinus)),\\nr4.r * float(isSameEncodedLod(r4.a, alphaPlus) || isSameEncodedLod(r4.a, alphaMinus)),\\nr5.r * float(isSameEncodedLod(r5.a, alphaPlus) || isSameEncodedLod(r5.a, alphaMinus)),\\nr6.r * float(isSameEncodedLod(r6.a, alphaPlus) || isSameEncodedLod(r6.a, alphaMinus)),\\nr7.r * float(isSameEncodedLod(r7.a, alphaPlus) || isSameEncodedLod(r7.a, alphaMinus)),\\nr8.r * float(isSameEncodedLod(r8.a, alphaPlus) || isSameEncodedLod(r8.a, alphaMinus)),\\nr9.r * float(isSameEncodedLod(r9.a, alphaPlus) || isSameEncodedLod(r9.a, alphaMinus)),\\nr10.r * float(isSameEncodedLod(r10.a, alphaPlus) || isSameEncodedLod(r10.a, alphaMinus)),\\nr11.r * float(isSameEncodedLod(r11.a, alphaPlus) || isSameEncodedLod(r11.a, alphaMinus)),\\nr12.r * float(isSameEncodedLod(r12.a, alphaPlus) || isSameEncodedLod(r12.a, alphaMinus)),\\nr13.r * float(isSameEncodedLod(r13.a, alphaPlus) || isSameEncodedLod(r13.a, alphaMinus)),\\nr14.r * float(isSameEncodedLod(r14.a, alphaPlus) || isSameEncodedLod(r14.a, alphaMinus)),\\nr15.r * float(isSameEncodedLod(r15.a, alphaPlus) || isSameEncodedLod(r15.a, alphaMinus))\\n);\\nvec3 maxInnerScore3 = max(innerScore[0], max(innerScore[1], innerScore[2]));\\nvec4 maxMiddleScore4 = max(max(middleScore[0], middleScore[1]), max(middleScore[2], middleScore[3]));\\nvec4 maxOuterScore4 = max(max(outerScore[0], outerScore[1]), max(outerScore[2], outerScore[3]));\\nfloat maxInnerScore = max(maxInnerScore3.x, max(maxInnerScore3.y, maxInnerScore3.z));\\nfloat maxMiddleScore = max(max(maxMiddleScore4.x, maxMiddleScore4.y), max(maxMiddleScore4.z, maxMiddleScore4.w));\\nfloat maxOuterScore = max(max(maxOuterScore4.x, maxOuterScore4.y), max(maxOuterScore4.z, maxOuterScore4.w));\\nfloat maxScore = max(maxInnerScore, max(maxMiddleScore, maxOuterScore));\\nfloat myScore = step(maxScore, pixel.r) * pixel.r;\\ncolor = vec4(myScore, pixel.gba);\\n}\"","module.exports = \"uniform sampler2D image;\\nvoid main()\\n{\\nfloat p0 = pixelAtShortOffset(image, ivec2(0, 1)).r;\\nfloat p1 = pixelAtShortOffset(image, ivec2(1, 1)).r;\\nfloat p2 = pixelAtShortOffset(image, ivec2(1, 0)).r;\\nfloat p3 = pixelAtShortOffset(image, ivec2(1, -1)).r;\\nfloat p4 = pixelAtShortOffset(image, ivec2(0, -1)).r;\\nfloat p5 = pixelAtShortOffset(image, ivec2(-1, -1)).r;\\nfloat p6 = pixelAtShortOffset(image, ivec2(-1, 0)).r;\\nfloat p7 = pixelAtShortOffset(image, ivec2(-1, 1)).r;\\nfloat m = max(\\nmax(max(p0, p1), max(p2, p3)),\\nmax(max(p4, p5), max(p6, p7))\\n);\\nvec4 pixel = threadPixel(image);\\nfloat score = step(m, pixel.r) * pixel.r;\\ncolor = vec4(score, pixel.gba);\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform sampler2D encodedCorners;\\nuniform int encoderLength;\\nuniform sampler2D pyramid;\\nuniform int extraSize;\\nconst int descriptorSize = 32;\\nconst ivec4 pat31[256] = ivec4[256](\\nivec4(8,-3,9,5),\\nivec4(4,2,7,-12),\\nivec4(-11,9,-8,2),\\nivec4(7,-12,12,-13),\\nivec4(2,-13,2,12),\\nivec4(1,-7,1,6),\\nivec4(-2,-10,-2,-4),\\nivec4(-13,-13,-11,-8),\\nivec4(-13,-3,-12,-9),\\nivec4(10,4,11,9),\\nivec4(-13,-8,-8,-9),\\nivec4(-11,7,-9,12),\\nivec4(7,7,12,6),\\nivec4(-4,-5,-3,0),\\nivec4(-13,2,-12,-3),\\nivec4(-9,0,-7,5),\\nivec4(12,-6,12,-1),\\nivec4(-3,6,-2,12),\\nivec4(-6,-13,-4,-8),\\nivec4(11,-13,12,-8),\\nivec4(4,7,5,1),\\nivec4(5,-3,10,-3),\\nivec4(3,-7,6,12),\\nivec4(-8,-7,-6,-2),\\nivec4(-2,11,-1,-10),\\nivec4(-13,12,-8,10),\\nivec4(-7,3,-5,-3),\\nivec4(-4,2,-3,7),\\nivec4(-10,-12,-6,11),\\nivec4(5,-12,6,-7),\\nivec4(5,-6,7,-1),\\nivec4(1,0,4,-5),\\nivec4(9,11,11,-13),\\nivec4(4,7,4,12),\\nivec4(2,-1,4,4),\\nivec4(-4,-12,-2,7),\\nivec4(-8,-5,-7,-10),\\nivec4(4,11,9,12),\\nivec4(0,-8,1,-13),\\nivec4(-13,-2,-8,2),\\nivec4(-3,-2,-2,3),\\nivec4(-6,9,-4,-9),\\nivec4(8,12,10,7),\\nivec4(0,9,1,3),\\nivec4(7,-5,11,-10),\\nivec4(-13,-6,-11,0),\\nivec4(10,7,12,1),\\nivec4(-6,-3,-6,12),\\nivec4(10,-9,12,-4),\\nivec4(-13,8,-8,-12),\\nivec4(-13,0,-8,-4),\\nivec4(3,3,7,8),\\nivec4(5,7,10,-7),\\nivec4(-1,7,1,-12),\\nivec4(3,-10,5,6),\\nivec4(2,-4,3,-10),\\nivec4(-13,0,-13,5),\\nivec4(-13,-7,-12,12),\\nivec4(-13,3,-11,8),\\nivec4(-7,12,-4,7),\\nivec4(6,-10,12,8),\\nivec4(-9,-1,-7,-6),\\nivec4(-2,-5,0,12),\\nivec4(-12,5,-7,5),\\nivec4(3,-10,8,-13),\\nivec4(-7,-7,-4,5),\\nivec4(-3,-2,-1,-7),\\nivec4(2,9,5,-11),\\nivec4(-11,-13,-5,-13),\\nivec4(-1,6,0,-1),\\nivec4(5,-3,5,2),\\nivec4(-4,-13,-4,12),\\nivec4(-9,-6,-9,6),\\nivec4(-12,-10,-8,-4),\\nivec4(10,2,12,-3),\\nivec4(7,12,12,12),\\nivec4(-7,-13,-6,5),\\nivec4(-4,9,-3,4),\\nivec4(7,-1,12,2),\\nivec4(-7,6,-5,1),\\nivec4(-13,11,-12,5),\\nivec4(-3,7,-2,-6),\\nivec4(7,-8,12,-7),\\nivec4(-13,-7,-11,-12),\\nivec4(1,-3,12,12),\\nivec4(2,-6,3,0),\\nivec4(-4,3,-2,-13),\\nivec4(-1,-13,1,9),\\nivec4(7,1,8,-6),\\nivec4(1,-1,3,12),\\nivec4(9,1,12,6),\\nivec4(-1,-9,-1,3),\\nivec4(-13,-13,-10,5),\\nivec4(7,7,10,12),\\nivec4(12,-5,12,9),\\nivec4(6,3,7,11),\\nivec4(5,-13,6,10),\\nivec4(2,-12,2,3),\\nivec4(3,8,4,-6),\\nivec4(2,6,12,-13),\\nivec4(9,-12,10,3),\\nivec4(-8,4,-7,9),\\nivec4(-11,12,-4,-6),\\nivec4(1,12,2,-8),\\nivec4(6,-9,7,-4),\\nivec4(2,3,3,-2),\\nivec4(6,3,11,0),\\nivec4(3,-3,8,-8),\\nivec4(7,8,9,3),\\nivec4(-11,-5,-6,-4),\\nivec4(-10,11,-5,10),\\nivec4(-5,-8,-3,12),\\nivec4(-10,5,-9,0),\\nivec4(8,-1,12,-6),\\nivec4(4,-6,6,-11),\\nivec4(-10,12,-8,7),\\nivec4(4,-2,6,7),\\nivec4(-2,0,-2,12),\\nivec4(-5,-8,-5,2),\\nivec4(7,-6,10,12),\\nivec4(-9,-13,-8,-8),\\nivec4(-5,-13,-5,-2),\\nivec4(8,-8,9,-13),\\nivec4(-9,-11,-9,0),\\nivec4(1,-8,1,-2),\\nivec4(7,-4,9,1),\\nivec4(-2,1,-1,-4),\\nivec4(11,-6,12,-11),\\nivec4(-12,-9,-6,4),\\nivec4(3,7,7,12),\\nivec4(5,5,10,8),\\nivec4(0,-4,2,8),\\nivec4(-9,12,-5,-13),\\nivec4(0,7,2,12),\\nivec4(-1,2,1,7),\\nivec4(5,11,7,-9),\\nivec4(3,5,6,-8),\\nivec4(-13,-4,-8,9),\\nivec4(-5,9,-3,-3),\\nivec4(-4,-7,-3,-12),\\nivec4(6,5,8,0),\\nivec4(-7,6,-6,12),\\nivec4(-13,6,-5,-2),\\nivec4(1,-10,3,10),\\nivec4(4,1,8,-4),\\nivec4(-2,-2,2,-13),\\nivec4(2,-12,12,12),\\nivec4(-2,-13,0,-6),\\nivec4(4,1,9,3),\\nivec4(-6,-10,-3,-5),\\nivec4(-3,-13,-1,1),\\nivec4(7,5,12,-11),\\nivec4(4,-2,5,-7),\\nivec4(-13,9,-9,-5),\\nivec4(7,1,8,6),\\nivec4(7,-8,7,6),\\nivec4(-7,-4,-7,1),\\nivec4(-8,11,-7,-8),\\nivec4(-13,6,-12,-8),\\nivec4(2,4,3,9),\\nivec4(10,-5,12,3),\\nivec4(-6,-5,-6,7),\\nivec4(8,-3,9,-8),\\nivec4(2,-12,2,8),\\nivec4(-11,-2,-10,3),\\nivec4(-12,-13,-7,-9),\\nivec4(-11,0,-10,-5),\\nivec4(5,-3,11,8),\\nivec4(-2,-13,-1,12),\\nivec4(-1,-8,0,9),\\nivec4(-13,-11,-12,-5),\\nivec4(-10,-2,-10,11),\\nivec4(-3,9,-2,-13),\\nivec4(2,-3,3,2),\\nivec4(-9,-13,-4,0),\\nivec4(-4,6,-3,-10),\\nivec4(-4,12,-2,-7),\\nivec4(-6,-11,-4,9),\\nivec4(6,-3,6,11),\\nivec4(-13,11,-5,5),\\nivec4(11,11,12,6),\\nivec4(7,-5,12,-2),\\nivec4(-1,12,0,7),\\nivec4(-4,-8,-3,-2),\\nivec4(-7,1,-6,7),\\nivec4(-13,-12,-8,-13),\\nivec4(-7,-2,-6,-8),\\nivec4(-8,5,-6,-9),\\nivec4(-5,-1,-4,5),\\nivec4(-13,7,-8,10),\\nivec4(1,5,5,-13),\\nivec4(1,0,10,-13),\\nivec4(9,12,10,-1),\\nivec4(5,-8,10,-9),\\nivec4(-1,11,1,-13),\\nivec4(-9,-3,-6,2),\\nivec4(-1,-10,1,12),\\nivec4(-13,1,-8,-10),\\nivec4(8,-11,10,-6),\\nivec4(2,-13,3,-6),\\nivec4(7,-13,12,-9),\\nivec4(-10,-10,-5,-7),\\nivec4(-10,-8,-8,-13),\\nivec4(4,-6,8,5),\\nivec4(3,12,8,-13),\\nivec4(-4,2,-3,-3),\\nivec4(5,-13,10,-12),\\nivec4(4,-13,5,-1),\\nivec4(-9,9,-4,3),\\nivec4(0,3,3,-9),\\nivec4(-12,1,-6,1),\\nivec4(3,2,4,-8),\\nivec4(-10,-10,-10,9),\\nivec4(8,-13,12,12),\\nivec4(-8,-12,-6,-5),\\nivec4(2,2,3,7),\\nivec4(10,6,11,-8),\\nivec4(6,8,8,-12),\\nivec4(-7,10,-6,5),\\nivec4(-3,-9,-3,9),\\nivec4(-1,-13,-1,5),\\nivec4(-3,-7,-3,4),\\nivec4(-8,-2,-8,3),\\nivec4(4,2,12,12),\\nivec4(2,-5,3,11),\\nivec4(6,-9,11,-13),\\nivec4(3,-1,7,12),\\nivec4(11,-1,12,4),\\nivec4(-3,0,-3,6),\\nivec4(4,-11,4,12),\\nivec4(2,-4,2,1),\\nivec4(-10,-6,-8,1),\\nivec4(-13,7,-11,1),\\nivec4(-13,12,-11,-13),\\nivec4(6,0,11,-13),\\nivec4(0,-1,1,4),\\nivec4(-13,3,-9,-2),\\nivec4(-9,8,-6,-3),\\nivec4(-13,-6,-8,-2),\\nivec4(5,-9,8,10),\\nivec4(2,7,3,-9),\\nivec4(-1,-6,-1,-1),\\nivec4(9,5,11,-2),\\nivec4(11,-3,12,-8),\\nivec4(3,0,3,5),\\nivec4(-1,4,0,10),\\nivec4(3,-6,4,5),\\nivec4(-13,0,-10,5),\\nivec4(5,8,12,11),\\nivec4(8,9,9,-6),\\nivec4(7,-4,8,-12),\\nivec4(-10,4,-10,9),\\nivec4(7,3,12,4),\\nivec4(9,-7,10,-2),\\nivec4(7,0,12,-2),\\nivec4(-1,-6,0,-11)\\n);\\nvoid getPair(int index, float kcos, float ksin, out ivec2 p, out ivec2 q)\\n{\\nivec4 data = pat31[index];\\nvec2 op = vec2(data.xy);\\nvec2 oq = vec2(data.zw);\\np = ivec2(round(op.x * kcos - op.y * ksin), round(op.x * ksin + op.y * kcos));\\nq = ivec2(round(oq.x * kcos - oq.y * ksin), round(oq.x * ksin + oq.y * kcos));\\n}\\nvoid main()\\n{\\nvec4 pixel = threadPixel(encodedCorners);\\nivec2 thread = threadLocation();\\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\\nint descriptorCell = address.offset - extraSize - 2;\\ncolor = pixel;\\nif(descriptorCell < 0)\\nreturn;\\nKeypoint keypoint = decodeKeypoint(encodedCorners, encoderLength, address);\\nif(isDiscardedOrNullKeypoint(keypoint))\\nreturn;\\nfloat pot = exp2(keypoint.lod);\\nfloat kcos = cos(keypoint.orientation);\\nfloat ksin = sin(keypoint.orientation);\\nvec2 imageSize = vec2(textureSize(pyramid, 0));\\nint patternStart = 32 * descriptorCell;\\nuint test[4] = uint[4](0u, 0u, 0u, 0u);\\nfor(int t = 0; t < 4; t++) {\\nuint bits = 0u;\\nivec2 p, q;\\nvec4 a, b;\\nint i = t * 8;\\nfor(int j = 0; j < 8; j++) {\\ngetPair(patternStart + i + j, kcos, ksin, p, q);\\na = pyrPixelAtEx(pyramid, round(keypoint.position + pot * vec2(p)), keypoint.lod, imageSize);\\nb = pyrPixelAtEx(pyramid, round(keypoint.position + pot * vec2(q)), keypoint.lod, imageSize);\\nbits |= uint(a.g < b.g) << j;\\n}\\ntest[t] = bits;\\n}\\ncolor = vec4(float(test[0]), float(test[1]), float(test[2]), float(test[3])) / 255.0f;\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform sampler2D pyramid;\\nuniform sampler2D encodedKeypoints;\\nuniform int patchRadius;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int encoderLength;\\nconst int patchStart[8] = int[8](0, 0, 8, 28, 64, 132, 228, 356);\\nconst int patchPointCount[8] = int[8](0, 8, 20, 36, 68, 96, 128, 168);\\nconst ivec2 patchData[524] = ivec2[524](\\nivec2(-1,-1),ivec2(0,-1),ivec2(1,-1),ivec2(-1,0),ivec2(1,0),ivec2(-1,1),ivec2(0,1),ivec2(1,1),\\nivec2(-1,-2),ivec2(0,-2),ivec2(1,-2),ivec2(-2,-1),ivec2(-1,-1),ivec2(0,-1),ivec2(1,-1),ivec2(2,-1),ivec2(-2,0),ivec2(-1,0),ivec2(1,0),ivec2(2,0),ivec2(-2,1),ivec2(-1,1),ivec2(0,1),ivec2(1,1),ivec2(2,1),ivec2(-1,2),ivec2(0,2),ivec2(1,2),\\nivec2(-1,-3),ivec2(0,-3),ivec2(1,-3),ivec2(-2,-2),ivec2(-1,-2),ivec2(0,-2),ivec2(1,-2),ivec2(2,-2),ivec2(-3,-1),ivec2(-2,-1),ivec2(-1,-1),ivec2(0,-1),ivec2(1,-1),ivec2(2,-1),ivec2(3,-1),ivec2(-3,0),ivec2(-2,0),ivec2(-1,0),ivec2(1,0),ivec2(2,0),ivec2(3,0),ivec2(-3,1),ivec2(-2,1),ivec2(-1,1),ivec2(0,1),ivec2(1,1),ivec2(2,1),ivec2(3,1),ivec2(-2,2),ivec2(-1,2),ivec2(0,2),ivec2(1,2),ivec2(2,2),ivec2(-1,3),ivec2(0,3),ivec2(1,3),\\nivec2(-2,-4),ivec2(-1,-4),ivec2(0,-4),ivec2(1,-4),ivec2(2,-4),ivec2(-3,-3),ivec2(-2,-3),ivec2(-1,-3),ivec2(0,-3),ivec2(1,-3),ivec2(2,-3),ivec2(3,-3),ivec2(-4,-2),ivec2(-3,-2),ivec2(-2,-2),ivec2(-1,-2),ivec2(0,-2),ivec2(1,-2),ivec2(2,-2),ivec2(3,-2),ivec2(4,-2),ivec2(-4,-1),ivec2(-3,-1),ivec2(-2,-1),ivec2(-1,-1),ivec2(0,-1),ivec2(1,-1),ivec2(2,-1),ivec2(3,-1),ivec2(4,-1),ivec2(-4,0),ivec2(-3,0),ivec2(-2,0),ivec2(-1,0),ivec2(1,0),ivec2(2,0),ivec2(3,0),ivec2(4,0),ivec2(-4,1),ivec2(-3,1),ivec2(-2,1),ivec2(-1,1),ivec2(0,1),ivec2(1,1),ivec2(2,1),ivec2(3,1),ivec2(4,1),ivec2(-4,2),ivec2(-3,2),ivec2(-2,2),ivec2(-1,2),ivec2(0,2),ivec2(1,2),ivec2(2,2),ivec2(3,2),ivec2(4,2),ivec2(-3,3),ivec2(-2,3),ivec2(-1,3),ivec2(0,3),ivec2(1,3),ivec2(2,3),ivec2(3,3),ivec2(-2,4),ivec2(-1,4),ivec2(0,4),ivec2(1,4),ivec2(2,4),\\nivec2(-2,-5),ivec2(-1,-5),ivec2(0,-5),ivec2(1,-5),ivec2(2,-5),ivec2(-3,-4),ivec2(-2,-4),ivec2(-1,-4),ivec2(0,-4),ivec2(1,-4),ivec2(2,-4),ivec2(3,-4),ivec2(-4,-3),ivec2(-3,-3),ivec2(-2,-3),ivec2(-1,-3),ivec2(0,-3),ivec2(1,-3),ivec2(2,-3),ivec2(3,-3),ivec2(4,-3),ivec2(-5,-2),ivec2(-4,-2),ivec2(-3,-2),ivec2(-2,-2),ivec2(-1,-2),ivec2(0,-2),ivec2(1,-2),ivec2(2,-2),ivec2(3,-2),ivec2(4,-2),ivec2(5,-2),ivec2(-5,-1),ivec2(-4,-1),ivec2(-3,-1),ivec2(-2,-1),ivec2(-1,-1),ivec2(0,-1),ivec2(1,-1),ivec2(2,-1),ivec2(3,-1),ivec2(4,-1),ivec2(5,-1),ivec2(-5,0),ivec2(-4,0),ivec2(-3,0),ivec2(-2,0),ivec2(-1,0),ivec2(1,0),ivec2(2,0),ivec2(3,0),ivec2(4,0),ivec2(5,0),ivec2(-5,1),ivec2(-4,1),ivec2(-3,1),ivec2(-2,1),ivec2(-1,1),ivec2(0,1),ivec2(1,1),ivec2(2,1),ivec2(3,1),ivec2(4,1),ivec2(5,1),ivec2(-5,2),ivec2(-4,2),ivec2(-3,2),ivec2(-2,2),ivec2(-1,2),ivec2(0,2),ivec2(1,2),ivec2(2,2),ivec2(3,2),ivec2(4,2),ivec2(5,2),ivec2(-4,3),ivec2(-3,3),ivec2(-2,3),ivec2(-1,3),ivec2(0,3),ivec2(1,3),ivec2(2,3),ivec2(3,3),ivec2(4,3),ivec2(-3,4),ivec2(-2,4),ivec2(-1,4),ivec2(0,4),ivec2(1,4),ivec2(2,4),ivec2(3,4),ivec2(-2,5),ivec2(-1,5),ivec2(0,5),ivec2(1,5),ivec2(2,5),\\nivec2(-2,-6),ivec2(-1,-6),ivec2(0,-6),ivec2(1,-6),ivec2(2,-6),ivec2(-3,-5),ivec2(-2,-5),ivec2(-1,-5),ivec2(0,-5),ivec2(1,-5),ivec2(2,-5),ivec2(3,-5),ivec2(-4,-4),ivec2(-3,-4),ivec2(-2,-4),ivec2(-1,-4),ivec2(0,-4),ivec2(1,-4),ivec2(2,-4),ivec2(3,-4),ivec2(4,-4),ivec2(-5,-3),ivec2(-4,-3),ivec2(-3,-3),ivec2(-2,-3),ivec2(-1,-3),ivec2(0,-3),ivec2(1,-3),ivec2(2,-3),ivec2(3,-3),ivec2(4,-3),ivec2(5,-3),ivec2(-6,-2),ivec2(-5,-2),ivec2(-4,-2),ivec2(-3,-2),ivec2(-2,-2),ivec2(-1,-2),ivec2(0,-2),ivec2(1,-2),ivec2(2,-2),ivec2(3,-2),ivec2(4,-2),ivec2(5,-2),ivec2(6,-2),ivec2(-6,-1),ivec2(-5,-1),ivec2(-4,-1),ivec2(-3,-1),ivec2(-2,-1),ivec2(-1,-1),ivec2(0,-1),ivec2(1,-1),ivec2(2,-1),ivec2(3,-1),ivec2(4,-1),ivec2(5,-1),ivec2(6,-1),ivec2(-6,0),ivec2(-5,0),ivec2(-4,0),ivec2(-3,0),ivec2(-2,0),ivec2(-1,0),ivec2(1,0),ivec2(2,0),ivec2(3,0),ivec2(4,0),ivec2(5,0),ivec2(6,0),ivec2(-6,1),ivec2(-5,1),ivec2(-4,1),ivec2(-3,1),ivec2(-2,1),ivec2(-1,1),ivec2(0,1),ivec2(1,1),ivec2(2,1),ivec2(3,1),ivec2(4,1),ivec2(5,1),ivec2(6,1),ivec2(-6,2),ivec2(-5,2),ivec2(-4,2),ivec2(-3,2),ivec2(-2,2),ivec2(-1,2),ivec2(0,2),ivec2(1,2),ivec2(2,2),ivec2(3,2),ivec2(4,2),ivec2(5,2),ivec2(6,2),ivec2(-5,3),ivec2(-4,3),ivec2(-3,3),ivec2(-2,3),ivec2(-1,3),ivec2(0,3),ivec2(1,3),ivec2(2,3),ivec2(3,3),ivec2(4,3),ivec2(5,3),ivec2(-4,4),ivec2(-3,4),ivec2(-2,4),ivec2(-1,4),ivec2(0,4),ivec2(1,4),ivec2(2,4),ivec2(3,4),ivec2(4,4),ivec2(-3,5),ivec2(-2,5),ivec2(-1,5),ivec2(0,5),ivec2(1,5),ivec2(2,5),ivec2(3,5),ivec2(-2,6),ivec2(-1,6),ivec2(0,6),ivec2(1,6),ivec2(2,6),\\nivec2(-2,-7),ivec2(-1,-7),ivec2(0,-7),ivec2(1,-7),ivec2(2,-7),ivec2(-4,-6),ivec2(-3,-6),ivec2(-2,-6),ivec2(-1,-6),ivec2(0,-6),ivec2(1,-6),ivec2(2,-6),ivec2(3,-6),ivec2(4,-6),ivec2(-5,-5),ivec2(-3,-5),ivec2(-2,-5),ivec2(-1,-5),ivec2(0,-5),ivec2(1,-5),ivec2(2,-5),ivec2(3,-5),ivec2(5,-5),ivec2(-6,-4),ivec2(-4,-4),ivec2(-3,-4),ivec2(-2,-4),ivec2(-1,-4),ivec2(0,-4),ivec2(1,-4),ivec2(2,-4),ivec2(3,-4),ivec2(4,-4),ivec2(6,-4),ivec2(-6,-3),ivec2(-5,-3),ivec2(-4,-3),ivec2(-3,-3),ivec2(-2,-3),ivec2(-1,-3),ivec2(0,-3),ivec2(1,-3),ivec2(2,-3),ivec2(3,-3),ivec2(4,-3),ivec2(5,-3),ivec2(6,-3),ivec2(-7,-2),ivec2(-6,-2),ivec2(-5,-2),ivec2(-4,-2),ivec2(-3,-2),ivec2(-2,-2),ivec2(-1,-2),ivec2(0,-2),ivec2(1,-2),ivec2(2,-2),ivec2(3,-2),ivec2(4,-2),ivec2(5,-2),ivec2(6,-2),ivec2(7,-2),ivec2(-7,-1),ivec2(-6,-1),ivec2(-5,-1),ivec2(-4,-1),ivec2(-3,-1),ivec2(-2,-1),ivec2(-1,-1),ivec2(0,-1),ivec2(1,-1),ivec2(2,-1),ivec2(3,-1),ivec2(4,-1),ivec2(5,-1),ivec2(6,-1),ivec2(7,-1),ivec2(-7,0),ivec2(-6,0),ivec2(-5,0),ivec2(-4,0),ivec2(-3,0),ivec2(-2,0),ivec2(-1,0),ivec2(1,0),ivec2(2,0),ivec2(3,0),ivec2(4,0),ivec2(5,0),ivec2(6,0),ivec2(7,0),ivec2(-7,1),ivec2(-6,1),ivec2(-5,1),ivec2(-4,1),ivec2(-3,1),ivec2(-2,1),ivec2(-1,1),ivec2(0,1),ivec2(1,1),ivec2(2,1),ivec2(3,1),ivec2(4,1),ivec2(5,1),ivec2(6,1),ivec2(7,1),ivec2(-7,2),ivec2(-6,2),ivec2(-5,2),ivec2(-4,2),ivec2(-3,2),ivec2(-2,2),ivec2(-1,2),ivec2(0,2),ivec2(1,2),ivec2(2,2),ivec2(3,2),ivec2(4,2),ivec2(5,2),ivec2(6,2),ivec2(7,2),ivec2(-6,3),ivec2(-5,3),ivec2(-4,3),ivec2(-3,3),ivec2(-2,3),ivec2(-1,3),ivec2(0,3),ivec2(1,3),ivec2(2,3),ivec2(3,3),ivec2(4,3),ivec2(5,3),ivec2(6,3),ivec2(-6,4),ivec2(-4,4),ivec2(-3,4),ivec2(-2,4),ivec2(-1,4),ivec2(0,4),ivec2(1,4),ivec2(2,4),ivec2(3,4),ivec2(4,4),ivec2(6,4),ivec2(-5,5),ivec2(-3,5),ivec2(-2,5),ivec2(-1,5),ivec2(0,5),ivec2(1,5),ivec2(2,5),ivec2(3,5),ivec2(5,5),ivec2(-4,6),ivec2(-3,6),ivec2(-2,6),ivec2(-1,6),ivec2(0,6),ivec2(1,6),ivec2(2,6),ivec2(3,6),ivec2(4,6),ivec2(-2,7),ivec2(-1,7),ivec2(0,7),ivec2(1,7),ivec2(2,7)\\n);\\nconst int MIN_PATCH_RADIUS = 3;\\nconst int MAX_PATCH_RADIUS = 7;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(encodedKeypoints);\\nivec2 thread = threadLocation();\\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\\ncolor = pixel;\\nif(address.offset != 1)\\nreturn;\\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\\nfloat pot = exp2(keypoint.lod);\\nvec2 m = vec2(0.0f);\\nivec2 pyrBaseSize = textureSize(pyramid, 0);\\nint scaledRadius = int(ceil(float(patchRadius) / pot));\\nint radius = clamp(scaledRadius, MIN_PATCH_RADIUS, MAX_PATCH_RADIUS);\\nint start = patchStart[radius];\\nint count = patchPointCount[radius];\\nfor(int j = 0; j < count; j++) {\\nvec2 offset = vec2(patchData[start + j]);\\nvec2 position = keypoint.position + round(pot * offset);\\nvec4 patchPixel = pyrPixelAtEx(pyramid, position, keypoint.lod, pyrBaseSize);\\nm += offset * patchPixel.g;\\n}\\nfloat angle = fastAtan2(m.y, m.x);\\ncolor.g = encodeOrientation(angle);\\n}\"","module.exports = \"@include \\\"pyramids.glsl\\\"\\nuniform sampler2D image;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nivec2 thread = threadLocation();\\nfloat lod = decodeLod(pixel.a);\\nfloat pot = exp2(lod);\\ncolor = pixel;\\nif(pixel.r == 0.0f)\\nreturn;\\nvec4 p0 = pixelAtShortOffset(image, ivec2(0, 1));\\nvec4 p1 = pixelAtShortOffset(image, ivec2(1, 1));\\nvec4 p2 = pixelAtShortOffset(image, ivec2(1, 0));\\nvec4 p3 = pixelAtShortOffset(image, ivec2(1, -1));\\nvec4 p4 = pixelAtShortOffset(image, ivec2(0, -1));\\nvec4 p5 = pixelAtShortOffset(image, ivec2(-1, -1));\\nvec4 p6 = pixelAtShortOffset(image, ivec2(-1, 0));\\nvec4 p7 = pixelAtShortOffset(image, ivec2(-1, 1));\\nmat3 score = mat3(\\np0.r * float(isSameEncodedLod(p0.a, pixel.a)),\\np1.r * float(isSameEncodedLod(p1.a, pixel.a)),\\np2.r * float(isSameEncodedLod(p2.a, pixel.a)),\\np3.r * float(isSameEncodedLod(p3.a, pixel.a)),\\np4.r * float(isSameEncodedLod(p4.a, pixel.a)),\\np5.r * float(isSameEncodedLod(p5.a, pixel.a)),\\np6.r * float(isSameEncodedLod(p6.a, pixel.a)),\\np7.r * float(isSameEncodedLod(p7.a, pixel.a)),\\n0.0f\\n);\\nvec3 maxScore3 = max(score[0], max(score[1], score[2]));\\nfloat maxScore = max(maxScore3.x, max(maxScore3.y, maxScore3.z));\\nfloat myScore = step(maxScore, pixel.r) * pixel.r;\\ncolor = vec4(myScore, pixel.gba);\\n}\"","module.exports = \"uniform sampler2D image;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nivec2 pos = min(thread * 2, textureSize(image, 0) - 1);\\ncolor = pixelAt(image, pos);\\n}\"","module.exports = \"uniform sampler2D image;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nivec2 pos = min(thread * 3, textureSize(image, 0) - 1);\\ncolor = pixelAt(image, pos);\\n}\"","module.exports = \"uniform sampler2D image;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nvec4 pixel = pixelAt(image, thread / 2);\\ncolor = (((thread.x + thread.y) & 1) == 0) ? pixel : vec4(0.0f, 0.0f, 0.0f, pixel.a);\\n}\"","module.exports = \"uniform sampler2D image;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nvec4 pixel = pixelAt(image, thread / 3);\\nbool cond = ((thread.x - (thread.y % 3) + 3) % 3) == 0;\\ncolor = (((thread.x - (thread.y % 3) + 3) % 3) == 0) ? pixel : vec4(0.0f, 0.0f, 0.0f, pixel.a);\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform sampler2D pyramid;\\nuniform sampler2D encodedKeypoints;\\nuniform int windowSize;\\nuniform float discardThreshold;\\nuniform int firstKeypointIndex, lastKeypointIndex;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int encoderLength;\\n#ifndef MAX_WINDOW_SIZE\\n#error Must define MAX_WINDOW_SIZE\\n#endif\\nconst int MAX_WINDOW_SIZE_PLUS = MAX_WINDOW_SIZE + 2;\\nconst int MAX_WINDOW_SIZE_PLUS_SQUARED = MAX_WINDOW_SIZE_PLUS * MAX_WINDOW_SIZE_PLUS;\\nconst int MAX_WINDOW_RADIUS_PLUS = (MAX_WINDOW_SIZE_PLUS - 1) / 2;\\nconst float DISCARD_SCALE = 0.00024318695068359375f;\\nfloat pixelBuffer[MAX_WINDOW_SIZE_PLUS_SQUARED];\\n#define pixelIndex(i, j) (((j) + MAX_WINDOW_RADIUS_PLUS) * MAX_WINDOW_SIZE_PLUS + ((i) + MAX_WINDOW_RADIUS_PLUS))\\n#define windowRadius() ((windowSize - 1) / 2)\\nvoid readWindow(vec2 center, float lod)\\n{\\nivec2 pyrBaseSize = textureSize(pyramid, 0);\\nfloat pot = exp2(lod);\\nint r = windowRadius();\\n#define readPixelAt(ox, oy) pixelBuffer[pixelIndex((ox), (oy))] = pyrSubpixelAtExOffset(pyramid, center, lod, pot, ivec2((ox), (oy)), pyrBaseSize).g\\nfor(int j = 0; j < windowSize; j++) {\\nfor(int i = 0; i < windowSize; i++) {\\nreadPixelAt(i-r, j-r);\\n}\\n}\\nint r1 = r+1;\\nfor(int k = 0; k < windowSize; k++) {\\nreadPixelAt(-r1, k-r);\\nreadPixelAt( r1, k-r);\\nreadPixelAt(k-r,-r1);\\nreadPixelAt(k-r, r1);\\n}\\nreadPixelAt(-r1,-r1);\\nreadPixelAt( r1,-r1);\\nreadPixelAt(-r1, r1);\\nreadPixelAt( r1, r1);\\n}\\nvec2 computeDerivatives(ivec2 offset)\\n{\\nconst mat3 derivX = mat3(\\n3, 0, -3,\\n10, 0, -10,\\n3, 0, -3\\n);\\nconst mat3 derivY = mat3(\\n3, 10, 3,\\n0, 0, 0,\\n-3, -10, -3\\n);\\nmat3 window = mat3(\\npixelBuffer[pixelIndex(offset.x-1, offset.y-1)],\\npixelBuffer[pixelIndex(offset.x+0, offset.y-1)],\\npixelBuffer[pixelIndex(offset.x+1, offset.y-1)],\\npixelBuffer[pixelIndex(offset.x-1, offset.y+0)],\\n0.0f,\\npixelBuffer[pixelIndex(offset.x+1, offset.y+0)],\\npixelBuffer[pixelIndex(offset.x-1, offset.y+1)],\\npixelBuffer[pixelIndex(offset.x+0, offset.y+1)],\\npixelBuffer[pixelIndex(offset.x+1, offset.y+1)]\\n);\\nmat3 fx = matrixCompMult(derivX, window);\\nmat3 fy = matrixCompMult(derivY, window);\\nconst vec3 ones = vec3(1.0f);\\nreturn vec2(\\ndot(fx[0], ones) + dot(fx[1], ones) + dot(fx[2], ones),\\ndot(fy[0], ones) + dot(fy[1], ones) + dot(fy[2], ones)\\n);\\n}\\nvoid main()\\n{\\nvec4 pixel = threadPixel(encodedKeypoints);\\nivec2 thread = threadLocation();\\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\\nint r = windowRadius();\\ncolor = pixel;\\nif(address.offset != 1)\\nreturn;\\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\\nif(isDiscardedOrNullKeypoint(keypoint))\\nreturn;\\nint idx = findKeypointIndex(address, descriptorSize, extraSize);\\nif(idx < firstKeypointIndex || idx > lastKeypointIndex)\\nreturn;\\nreadWindow(keypoint.position, keypoint.lod);\\nvec2 derivatives = vec2(0.0f);\\nmat2 harris = mat2(0.0f, 0.0f, 0.0f, 0.0f);\\nfor(int j = 0; j < windowSize; j++) {\\nfor(int i = 0; i < windowSize; i++) {\\nderivatives = computeDerivatives(ivec2(i-r, j-r));\\nharris += mat2(\\nderivatives.x * derivatives.x, derivatives.x * derivatives.y,\\nderivatives.x * derivatives.y, derivatives.y * derivatives.y\\n) * DISCARD_SCALE;\\n}\\n}\\nfloat delta = harris[0][0] - harris[1][1];\\nfloat eigenvalue = 0.5f * ((harris[0][0] + harris[1][1]) - sqrt(delta * delta - 4.0f * harris[0][1] * harris[0][1]));\\nint windowArea = windowSize * windowSize;\\nfloat cornerness = eigenvalue / float(windowArea);\\nbool unsuitable = (cornerness < discardThreshold);\\ncolor = vec4(pixel.rgb, float(unsuitable));\\n}\"","module.exports = \"@include \\\"keypoints.glsl\\\"\\nuniform sampler2D nextPyramid;\\nuniform sampler2D prevPyramid;\\nuniform sampler2D prevKeypoints;\\nuniform int windowSize;\\nuniform int depth;\\nuniform int firstKeypointIndex, lastKeypointIndex;\\nuniform int descriptorSize;\\nuniform int extraSize;\\nuniform int encoderLength;\\n#ifndef NUM_ITERATIONS\\n#define NUM_ITERATIONS 5\\n#endif\\n#ifndef MAX_WINDOW_SIZE\\n#error Must define MAX_WINDOW_SIZE\\n#endif\\n#ifndef DISCARD_MARGIN\\n#define DISCARD_MARGIN 20\\n#endif\\n#define NEXT_IMAGE 1\\n#define PREV_IMAGE 0\\nconst int MAX_WINDOW_SIZE_PLUS = MAX_WINDOW_SIZE + 2;\\nconst int MAX_WINDOW_SIZE_PLUS_SQUARED = MAX_WINDOW_SIZE_PLUS * MAX_WINDOW_SIZE_PLUS;\\nconst int DBL_MAX_WINDOW_SIZE_PLUS_SQUARED = 2 * MAX_WINDOW_SIZE_PLUS_SQUARED;\\nconst int MAX_WINDOW_RADIUS_PLUS = (MAX_WINDOW_SIZE_PLUS - 1) / 2;\\n#define windowRadius() ((windowSize - 1) / 2)\\nfloat pixelBuffer[DBL_MAX_WINDOW_SIZE_PLUS_SQUARED];\\n#define prevPixel(index) pixelBuffer[(index)]\\n#define nextPixel(index) pixelBuffer[MAX_WINDOW_SIZE_PLUS_SQUARED + (index)]\\n#define pixelIndex(i, j) (((j) + MAX_WINDOW_RADIUS_PLUS) * MAX_WINDOW_SIZE_PLUS + ((i) + MAX_WINDOW_RADIUS_PLUS))\\nvoid readWindow(vec2 center, float lod)\\n{\\nivec2 pyrBaseSize = textureSize(prevPyramid, 0);\\nfloat pot = exp2(lod);\\nint r = windowRadius();\\nivec2 offset; int idx;\\n#define readPixelsAt(ox, oy) offset = ivec2((ox), (oy)); idx = pixelIndex(offset.x, offset.y); nextPixel(idx) = pyrSubpixelAtExOffset(nextPyramid, center, lod, pot, offset, pyrBaseSize).g; prevPixel(idx) = pyrSubpixelAtExOffset(prevPyramid, center, lod, pot, offset, pyrBaseSize).g\\nfor(int j = 0; j < windowSize; j++) {\\nfor(int i = 0; i < windowSize; i++) {\\nreadPixelsAt(i-r, j-r);\\n}\\n}\\nint r1 = r+1;\\nfor(int k = 0; k < windowSize; k++) {\\nreadPixelsAt(-r1, k-r);\\nreadPixelsAt( r1, k-r);\\nreadPixelsAt(k-r,-r1);\\nreadPixelsAt(k-r, r1);\\n}\\nreadPixelsAt(-r1,-r1);\\nreadPixelsAt( r1,-r1);\\nreadPixelsAt(-r1, r1);\\nreadPixelsAt( r1, r1);\\n}\\nvec2 computeDerivatives(int imageCode, ivec2 offset)\\n{\\nconst mat3 derivX = mat3(\\n3, 0, -3,\\n10, 0, -10,\\n3, 0, -3\\n);\\nconst mat3 derivY = mat3(\\n3, 10, 3,\\n0, 0, 0,\\n-3, -10, -3\\n);\\nint indexOffset = imageCode * MAX_WINDOW_SIZE_PLUS_SQUARED;\\nmat3 window = mat3(\\npixelBuffer[indexOffset + pixelIndex(offset.x-1, offset.y-1)],\\npixelBuffer[indexOffset + pixelIndex(offset.x+0, offset.y-1)],\\npixelBuffer[indexOffset + pixelIndex(offset.x+1, offset.y-1)],\\npixelBuffer[indexOffset + pixelIndex(offset.x-1, offset.y+0)],\\n0.0f,\\npixelBuffer[indexOffset + pixelIndex(offset.x+1, offset.y+0)],\\npixelBuffer[indexOffset + pixelIndex(offset.x-1, offset.y+1)],\\npixelBuffer[indexOffset + pixelIndex(offset.x+0, offset.y+1)],\\npixelBuffer[indexOffset + pixelIndex(offset.x+1, offset.y+1)]\\n);\\nmat3 fx = matrixCompMult(derivX, window);\\nmat3 fy = matrixCompMult(derivY, window);\\nconst vec3 ones = vec3(1.0f);\\nreturn vec2(\\ndot(fx[0], ones) + dot(fx[1], ones) + dot(fx[2], ones),\\ndot(fy[0], ones) + dot(fy[1], ones) + dot(fy[2], ones)\\n);\\n}\\nfloat readBufferedPixel(int imageCode, ivec2 offset)\\n{\\nivec2 limit = ivec2(windowRadius());\\noffset = clamp(offset, -limit, limit);\\nint indexOffset = imageCode * MAX_WINDOW_SIZE_PLUS_SQUARED;\\nreturn pixelBuffer[indexOffset + pixelIndex(offset.x, offset.y)];\\n}\\nvoid main()\\n{\\nvec4 pixel = threadPixel(prevKeypoints);\\nivec2 thread = threadLocation();\\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\\nint r = windowRadius();\\ncolor = pixel;\\nif(address.offset > 0)\\nreturn;\\nKeypoint keypoint = decodeKeypoint(prevKeypoints, encoderLength, address);\\nif(isDiscardedOrNullKeypoint(keypoint))\\nreturn;\\nint idx = findKeypointIndex(address, descriptorSize, extraSize);\\nif(idx < firstKeypointIndex || idx > lastKeypointIndex)\\nreturn;\\nvec2 pyrGuess = vec2(0.0f);\\nfor(int d = 0; d < depth; d++) {\\nfloat lod = float(depth - 1 - d);\\nreadWindow(keypoint.position, lod);\\nhighp mat2 invHarris = mat2(0.0f, 0.0f, 0.0f, 0.0f);\\nfor(int j = 0; j < windowSize; j++) {\\nfor(int i = 0; i < windowSize; i++) {\\nvec2 derivatives = computeDerivatives(PREV_IMAGE, ivec2(i-r, j-r));\\ninvHarris += mat2(\\nderivatives.y * derivatives.y, -derivatives.x * derivatives.y,\\n-derivatives.x * derivatives.y, derivatives.x * derivatives.x\\n);\\n}\\n}\\nconst float minDet = 0.00001f;\\nhighp float det = invHarris[0][0] * invHarris[1][1] - invHarris[0][1] * invHarris[1][0];\\nhighp vec2 localGuess = vec2(0.0f);\\nfor(int k = 0; k < NUM_ITERATIONS; k++) {\\nhighp vec2 spaceTime = vec2(0.0f);\\nfor(int _y = 0; _y < windowSize; _y++) {\\nfor(int _x = 0; _x < windowSize; _x++) {\\nint x = _x - r; int y = _y - r;\\nvec2 spatialDerivative = computeDerivatives(PREV_IMAGE, ivec2(x, y));\\nfloat timeDerivative = readBufferedPixel(NEXT_IMAGE,\\nivec2(round(vec2(x, y) + pyrGuess + localGuess))\\n) - readBufferedPixel(PREV_IMAGE, ivec2(x, y));\\nspaceTime += spatialDerivative * timeDerivative;\\n}\\n}\\nhighp vec2 localOpticalFlow = abs(det) < minDet ? vec2(0.0f) : invHarris * spaceTime / det;\\nlocalGuess += localOpticalFlow;\\n}\\npyrGuess = 2.0f * (pyrGuess + localGuess);\\n}\\nvec2 opticalFlow = pyrGuess;\\nvec2 nextPosition = keypoint.position + opticalFlow;\\nvec2 imageSize = vec2(textureSize(nextPyramid, 0));\\nfloat margin = float(DISCARD_MARGIN);\\nbool keypointIsWithinBoundaries = (\\nnextPosition.x >= margin &&\\nnextPosition.y >= margin &&\\nnextPosition.x <= imageSize.x - margin &&\\nnextPosition.y <= imageSize.y - margin\\n);\\ncolor = keypointIsWithinBoundaries ? encodeKeypointPosition(nextPosition) : encodeDiscardedKeypointPosition();\\n}\"","module.exports = \"@include \\\"colors.glsl\\\"\\nuniform sampler2D dest, src;\\nuniform int destComponents;\\nuniform int srcComponentId;\\nvoid main()\\n{\\nvec4 destPixel = threadPixel(dest);\\nvec4 srcPixel = threadPixel(src);\\nbvec4 flags = bvec4(\\n(destComponents & PIXELCOMPONENT_RED) != 0,\\n(destComponents & PIXELCOMPONENT_GREEN) != 0,\\n(destComponents & PIXELCOMPONENT_BLUE) != 0,\\n(destComponents & PIXELCOMPONENT_ALPHA) != 0\\n);\\ncolor = mix(destPixel, vec4(srcPixel[srcComponentId]), flags);\\n}\"","module.exports = \"@include \\\"colors.glsl\\\"\\nuniform sampler2D image;\\nuniform int pixelComponents;\\nuniform float value;\\nvoid main()\\n{\\nvec4 pixel = threadPixel(image);\\nbvec4 flags = bvec4(\\n(pixelComponents & PIXELCOMPONENT_RED) != 0,\\n(pixelComponents & PIXELCOMPONENT_GREEN) != 0,\\n(pixelComponents & PIXELCOMPONENT_BLUE) != 0,\\n(pixelComponents & PIXELCOMPONENT_ALPHA) != 0\\n);\\ncolor = mix(pixel, vec4(value), flags);\\n}\"","module.exports = \"uniform float value;\\nvoid main()\\n{\\ncolor = vec4(value);\\n}\"","module.exports = \"uniform sampler2D image;\\nvoid main() {\\nivec2 pos = threadLocation();\\npos.y = int(texSize.y) - 1 - pos.y;\\ncolor = pixelAt(image, pos);\\n}\"","module.exports = \"uniform sampler2D image;\\nvoid main()\\n{\\ncolor = threadPixel(image);\\n}\"","module.exports = \"uniform sampler2D image;\\nuniform int iterationNumber;\\nvoid main()\\n{\\nivec2 thread = threadLocation();\\nivec2 last = outputSize() - ivec2(1);\\nint jump = (1 << iterationNumber);\\nint clusterLength = jump << 1;\\nint clusterMask = clusterLength - 1;\\nivec2 clusterPos = ivec2(thread >> (1 + iterationNumber)) << (1 + iterationNumber);\\nivec2 next1 = clusterPos + ((thread - clusterPos + ivec2(jump, 0)) & clusterMask);\\nivec2 next2 = clusterPos + ((thread - clusterPos + ivec2(0, jump)) & clusterMask);\\nivec2 next3 = clusterPos + ((thread - clusterPos + ivec2(jump, jump)) & clusterMask);\\nvec4 p0 = texelFetch(image, thread, 0);\\nvec4 p1 = texelFetch(image, min(next1, last), 0);\\nvec4 p2 = texelFetch(image, min(next2, last), 0);\\nvec4 p3 = texelFetch(image, min(next3, last), 0);\\nvec4 pmax = max(max(p0, p1), max(p2, p3));\\nvec4 pmin = min(min(p0, p1), min(p2, p3));\\ncolor = vec4(pmax.r, pmin.g, pmax.r - pmin.g, p0.a);\\n}\"","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-gpu.js\n * GPU routines for accelerated computer vision\n */\n\nimport { GLUtils } from './gl-utils.js';\nimport { SpeedyTexture } from './speedy-texture';\nimport { Utils } from '../utils/utils';\nimport { SpeedyProgramCenter } from './speedy-program-center';\nimport { MAX_TEXTURE_LENGTH } from '../utils/globals';\nimport { NotSupportedError, IllegalArgumentError } from '../utils/errors';\n\n// Constants\nconst UPLOAD_BUFFER_SIZE = 4; // how many textures we allocate for uploading data\n\n/**\n * GPU routines for\n * accelerated computer vision\n */\nexport class SpeedyGPU\n{\n    /**\n     * Class constructor\n     * @param {number} width Texture width\n     * @param {number} height Texture height\n     */\n    constructor(width, height)\n    {\n        // initialize properties\n        this._gl = null;\n        this._canvas = null;\n        this._width = 0;\n        this._height = 0;\n        this._programs = null;\n        this._inputTexture = null;\n        this._inputTextureIndex = 0;\n        this._omitGLContextWarning = false;\n\n        // does the browser support WebGL2?\n        checkWebGL2Availability();\n\n        // read & validate texture size\n        this._width = Math.max(1, width | 0);\n        this._height = Math.max(1, height | 0);\n        if(this._width > MAX_TEXTURE_LENGTH || this._height > MAX_TEXTURE_LENGTH) {\n            Utils.warning(`Maximum texture size exceeded (using ${this._width} x ${this._height}).`);\n            this._width = Math.min(this._width, MAX_TEXTURE_LENGTH);\n            this._height = Math.min(this._height, MAX_TEXTURE_LENGTH);\n        }\n\n        // setup WebGL\n        this._setupWebGL();\n    }\n\n    /**\n     * WebGL context\n     * Be careful when caching this, as the context may be lost!\n     * @returns {WebGL2RenderingContext}\n     */\n    get gl()\n    {\n        return this._gl;\n    }\n\n    /**\n     * Internal canvas\n     * @returns {HTMLCanvasElement|OffscreenCanvas}\n     */\n    get canvas()\n    {\n        return this._canvas;\n    }\n\n    /**\n     * Access point to all GPU programs\n     * @returns {SpeedyProgramCenter}\n     */\n    get programs()\n    {\n        return this._programs;\n    }\n\n    /**\n     * Upload data to the GPU\n     * We reuse textures by means of an internal buffer of size UPLOAD_BUFFER_SIZE\n     * @param {ImageBitmap|ImageData|ArrayBufferView|HTMLImageElement|HTMLVideoElement|HTMLCanvasElement} data \n     * @param {number} [width]\n     * @param {number} [height] \n     * @returns {SpeedyTexture}\n     */\n    upload(data, width = -1, height = -1)\n    {\n        const gl = this._gl;\n\n        // lost GL context?\n        if(gl.isContextLost()) {\n            Utils.warning(`Can't upload texture without a WebGL context`);\n            return (this._inputTexture = null);\n        }\n\n        // default values\n        if(width < 0)\n            width = gl.canvas.width;\n        if(height < 0)\n            height = gl.canvas.height;\n\n        // invalid dimensions?\n        if(width == 0 || height == 0)\n            throw new IllegalArgumentError(`Can't upload an image of area 0`);\n\n        // create (or recreate) internal textures\n        if(this._inputTexture === null) {\n            gl.canvas.width = Math.max(gl.canvas.width, width);\n            gl.canvas.height = Math.max(gl.canvas.height, height);\n            this._inputTexture = Array(UPLOAD_BUFFER_SIZE).fill(null).map(_ =>\n                new SpeedyTexture(gl, gl.canvas.width, gl.canvas.height));\n        }\n        else if(width > gl.canvas.width || height > gl.canvas.height) {\n            Utils.log(`Resizing input texture to ${width} x ${height}`);\n            this._inputTexture.forEach(inputTexture =>\n                inputTexture.release());\n            this._inputTexture = null;\n            return this.upload(data, width, height);\n        }\n\n        // bugfix: if the media is a video, we can't really\n        // upload it to the GPU unless it's ready\n        if(data.constructor.name == 'HTMLVideoElement') {\n            if(data.readyState < 2) {\n                // this may happen when the video loops (Firefox)\n                // return the previously uploaded texture\n                if(this._inputTexture[this._inputTextureIndex] != null)\n                    return this._inputTexture[this._inputTextureIndex];\n                else\n                    Utils.warning(`Trying to process a video that isn't ready yet`);\n            }\n        }\n\n        // use round-robin to mitigate WebGL's implicit synchronization\n        // and maybe minimize texture upload times\n        this._inputTextureIndex = (1 + this._inputTextureIndex) % UPLOAD_BUFFER_SIZE;\n\n        // done! note: the input texture is upside-down, i.e.,\n        // flipped on the y-axis. We need to unflip it on the\n        // output, so that (0,0) becomes the top-left corner\n        const texture = this._inputTexture[this._inputTextureIndex];\n        texture.upload(data);\n        return texture;\n    }\n\n    /**\n     * Clear the internal canvas\n     */\n    /*clearCanvas()\n    {\n        const gl = this._gl;\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n        gl.clearColor(0, 0, 0, 1);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n    }*/\n\n    /**\n     * Lose & restore the WebGL context\n     * @param {number} [timeToRestore] in seconds\n     * @return {Promise} resolves as soon as the context is restored,\n     *                   or as soon as it is lost if timeToRestore is Infinity\n     */\n    loseAndRestoreWebGLContext(timeToRestore = 1.0)\n    {\n        const gl = this._gl;\n\n        if(gl.isContextLost())\n            return Promise.reject('Context already lost');\n\n        const ext = gl.getExtension('WEBGL_lose_context');\n\n        if(ext) {\n            ext.loseContext();\n            return new Promise(resolve => {\n                if(isFinite(timeToRestore)) {\n                    setTimeout(() => {\n                        ext.restoreContext();\n                        setTimeout(() => resolve(), 0); // next frame\n                    }, Math.max(timeToRestore, 0) * 1000.0);\n                }\n                else\n                    resolve(); // won't restore\n            });\n        }\n        else\n            throw new NotSupportedError('WEBGL_lose_context is unavailable');\n    }\n\n    /**\n     * Lose the WebGL context.\n     * This is a way to manually free resources.\n     */\n    loseWebGLContext()\n    {\n        this._omitGLContextWarning = true;\n        return this.loseAndRestoreWebGLContext(Infinity);\n    }\n\n    // setup WebGL\n    _setupWebGL()\n    {\n        const width = this._width;\n        const height = this._height;\n\n        // initializing\n        this._programs = null;\n        this._inputTexture = null;\n        this._inputTextureIndex = 0;\n        this._omitGLContextWarning = false;\n        if(this._canvas !== undefined)\n            delete this._canvas;\n\n        // create canvas\n        this._canvas = createCanvas(width, height);\n        this._canvas.addEventListener('webglcontextlost', ev => {\n            if(!this._omitGLContextWarning)\n                Utils.warning('Lost WebGL context');\n            ev.preventDefault();\n        }, false);\n        this._canvas.addEventListener('webglcontextrestored', ev => {\n            if(!this._omitGLContextWarning)\n                Utils.warning('Restoring WebGL context...');\n            this._setupWebGL();\n        }, false);\n\n        // create WebGL context\n        this._gl = createWebGLContext(this._canvas);\n\n        // spawn program groups\n        this._programs = new SpeedyProgramCenter(this, width, height);\n    }\n}\n\n// Create a canvas\nfunction createCanvas(width, height)\n{\n    const inWorker = (typeof importScripts === 'function') && (typeof WorkerGlobalScope !== 'undefined');\n\n    if(inWorker) {\n        if(typeof OffscreenCanvas !== 'function')\n            throw new NotSupportedError('OffscreenCanvas is not available in your browser. Please upgrade.');\n\n        return new OffscreenCanvas(width, height);\n    }\n\n    return Utils.createCanvas(width, height);\n}\n\n// Checks if the browser supports WebGL2\nfunction checkWebGL2Availability()\n{\n    if(typeof WebGL2RenderingContext === 'undefined')\n        throw new NotSupportedError('WebGL2 is required by this application, but it\\'s not available in your browser. Please use a different browser.');\n}\n\n// Create a WebGL2 context\nfunction createWebGLContext(canvas)\n{\n    const gl = canvas.getContext('webgl2', {\n        premultipliedAlpha: false,\n        preserveDrawingBuffer: false,\n        //preferLowPowerToHighPerformance: false, // TODO user option?\n        alpha: true,\n        antialias: false,\n        depth: false,\n        stencil: false,\n    });\n\n    if(!gl)\n        throw new NotSupportedError('Can\\'t create WebGL2 context. Try in a different browser.');\n\n    return gl;\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-program-center.js\n * An access point to all programs that run on the GPU\n */\n\nimport { GPUUtils } from './programs/utils';\nimport { GPUColors } from './programs/colors';\nimport { GPUFilters } from './programs/filters';\nimport { GPUKeypoints } from './programs/keypoints';\nimport { GPUEncoders } from './programs/encoders';\nimport { GPUPyramids } from './programs/pyramids';\nimport { GPUEnhancements } from './programs/enhancements';\nimport { GPUTrackers } from './programs/trackers';\n\n/**\n * An access point to all programs that run on the CPU\n * All program groups can be accessed via this class\n */\nexport class SpeedyProgramCenter\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu \n     * @param {number} width default width for output textures\n     * @param {number} height default height for output textures\n     */\n    constructor(gpu, width, height)\n    {\n        // properties\n        this._gpu = gpu;\n        this._width = width;\n        this._height = height;\n\n        // program groups\n        // (lazy instantiation)\n        this._utils = null;\n        this._colors = null;\n        this._filters = null;\n        this._keypoints = null;\n        this._encoders = null;\n        this._descriptors = null;\n        this._pyramids = null;\n        this._enhancements = null;\n        this._trackers = null;\n    }\n\n    /**\n     * Default width of the output texture of the programs\n     * @returns {number}\n     */\n    get width()\n    {\n        return this._width;\n    }\n\n    /**\n     * Default height of the output texture of the programs\n     * @returns {number}\n     */\n    get height()\n    {\n        return this._height;\n    }\n\n    /**\n     * Utility programs\n     * @returns {GPUUtils}\n     */\n    get utils()\n    {\n        return this._utils || (this._utils = new GPUUtils(this._gpu, this._width, this._height));\n    }\n\n    /**\n     * Programs related to color conversions\n     * @returns {GPUColors}\n     */\n    get colors()\n    {\n        return this._colors || (this._colors = new GPUColors(this._gpu, this._width, this._height));\n    }\n\n    /**\n     * Image filters & convolutions\n     * @returns {GPUFilters}\n     */\n    get filters()\n    {\n        return this._filters || (this._filters = new GPUFilters(this._gpu, this._width, this._height));\n    }\n\n    /**\n     * Keypoint detection & description\n     * @returns {GPUKeypoints}\n     */\n    get keypoints()\n    {\n        return this._keypoints || (this._keypoints = new GPUKeypoints(this._gpu, this._width, this._height));\n    }\n\n    /**\n     * Keypoint encoders\n     * @returns {GPUEncoders}\n     */\n    get encoders()\n    {\n        return this._encoders || (this._encoders = new GPUEncoders(this._gpu, this._width, this._height));\n    }\n\n    /**\n     * Feature trackers\n     * @returns {GPUTrackers}\n     */\n    get trackers()\n    {\n        return this._trackers || (this._trackers = new GPUTrackers(this._gpu, this._width, this._height));\n    }\n\n    /**\n     * Image pyramids & scale-space\n     * @returns {GPUPyramids}\n     */\n    get pyramids()\n    {\n        return this._pyramids || (this._pyramids = new GPUPyramids(this._gpu, this._width, this._height));\n    }\n\n    /**\n     * Image enhancement algorithms\n     * @returns {GPUEnhancements}\n     */\n    get enhancements()\n    {\n        return this._enhancements || (this._enhancements = new GPUEnhancements(this._gpu, this._width, this._height));\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-program-group.js\n * An abstract group of programs that run on the GPU\n */\n\nimport { SpeedyProgram } from './speedy-program';\n\n/**\n * SpeedyProgramGroup\n * A semantically correlated group\n * of programs that run on the GPU\n */\n\nexport /* abstract */ class SpeedyProgramGroup\n{\n    /**\n     * Class constructor\n     * @param {SpeedyGPU} gpu\n     * @param {number} width Texture width (depends on the pyramid layer)\n     * @param {number} height Texture height (depends on the pyramid layer)\n     */\n    /* protected */ constructor(gpu, width, height)\n    {\n        this._gpu = gpu;\n        this._width = width;\n        this._height = height;\n    }\n\n    /**\n     * Declare a program\n     * @param {string} name Program name\n     * @param {ShaderDeclaration} shaderdecl Shader declaration\n     * @param {object} settings Program settings\n     * @returns {SpeedyProgramGroup} This object\n     */\n    /* protected */ declare(name, shaderdecl, settings = { })\n    {\n        // lazy instantiation of kernels\n        Object.defineProperty(this, name, {\n            get: (() => {\n                const key = '__k_' + name;\n                return (function() {\n                    return this[key] || (this[key] = this._createProgram(shaderdecl, settings));\n                }).bind(this);\n            })()\n        });\n\n        return this;\n    }\n\n    /**\n     * Multi-pass composition\n     * @param {string} name Program name\n     * @param {string} fn Other programs\n     * @returns {SpeedyProgramGroup} This object\n     */\n    /* protected */ compose(name, ...fn)\n    {\n        // function composition: functions are called in the order they are specified\n        // e.g., compose('h', 'f', 'g') means h(x) = g(f(x))\n        Object.defineProperty(this, name, {\n            get: (() => {\n                const key = '__c_' + name;\n                return (function() {\n                    return this[key] || (this[key] = (fn.length == 2) ? (() => {\n                        fn = fn.map(fi => this[fi]);\n                        return function compose(image, ...args) {\n                            return (fn[1])((fn[0])(image, ...args), ...args);\n                        };\n                    })() : ((fn.length == 3) ? (() => {\n                        fn = fn.map(fi => this[fi]);\n                        return function compose(image, ...args) {\n                            return (fn[2])((fn[1])((fn[0])(image, ...args), ...args), ...args);\n                        };\n                    })() : ((fn.length == 4) ? (() => {\n                        fn = fn.map(fi => this[fi]);\n                        return function compose(image, ...args) {\n                            return (fn[3])((fn[2])((fn[1])((fn[0])(image, ...args), ...args), ...args), ...args);\n                        };\n                    })() : (() => {\n                        fn = fn.map(fi => this[fi]);\n                        return function compose(image, ...args) {\n                            return fn.reduce((img, fi) => fi(img, ...args), image);\n                        };\n                    })())));\n                }).bind(this);\n            })()\n        });\n\n        return this;\n    }\n\n    /**\n     * Neat helpers to be used\n     * when defining programs\n     */\n    get program()\n    {\n        return this._helpers || (this.helpers = {\n\n            // Set texture input/output size\n            // Dimensions are converted to integers\n            hasTextureSize(width, height) {\n                return {\n                    output: [ width|0, height|0 ]\n                };\n            },\n\n            // Render to canvas\n            // Use it when we're supposed to see the texture\n            displaysGraphics() {\n                return {\n                    renderToTexture: false\n                };\n            },\n\n            // Calling the program will return a new\n            // instance of the output texture every time\n            // The returned texture must be released manually\n            doesNotRecycleTextures() {\n                return {\n                    recycleTexture: false\n                };\n            },\n\n            // Pingpong Rendering: the output texture of a\n            // program cannot be used as an input to itself.\n            // This is a convenient helper in these situations\n            usesPingpongRendering() {\n                return {\n                    pingpong: true\n                };\n            },\n\n        });\n    }\n\n    /* private */ _createProgram(shaderdecl, settings = { })\n    {\n        return new SpeedyProgram(this._gpu.gl, shaderdecl, {\n            // default settings\n            output: [ this._width, this._height ],\n            ...settings\n        });\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-program.js\n * SpeedyProgram class\n */\n\nimport { GLUtils } from './gl-utils.js';\nimport { SpeedyTexture } from './speedy-texture';\nimport { NotSupportedError, IllegalArgumentError, IllegalOperationError } from '../utils/errors';\n\nconst LOCATION_ATTRIB_POSITION = 0;\nconst LOCATION_ATTRIB_TEXCOORD = 1;\n\nconst UNIFORM_TYPES = {\n    'sampler2D':'uniform1i',\n    'float':    'uniform1f',\n    'int':      'uniform1i',\n    'uint':     'uniform1ui',\n    'bool':     'uniform1i',\n    'vec2':     'uniform2f',\n    'vec3':     'uniform3f',\n    'vec4':     'uniform4f',\n    'ivec2':    'uniform2i',\n    'ivec3':    'uniform3i',\n    'ivec4':    'uniform4i',\n    'uvec2':    'uniform2ui',\n    'uvec3':    'uniform3ui',\n    'uvec4':    'uniform4ui',\n    'bvec2':    'uniform2i',\n    'bvec3':    'uniform3i',\n    'bvec4':    'uniform4i',\n};\n\n// number of pixel buffer objects\n// used to get a performance boost in gl.readPixels()\n// (1 seems to perform better on mobile, 2 on the PC?)\nconst PBO_COUNT = 1;\n\n/**\n * A SpeedyProgram is a Function that\n * runs GPU-accelerated GLSL code\n */\nexport class SpeedyProgram extends Function\n{\n    /**\n     * Creates a new SpeedyProgram\n     * @param {WebGL2RenderingContext} gl WebGL context\n     * @param {ShaderDeclaration} shaderdecl Shader declaration\n     * @param {object} [options] user options\n     */\n    constructor(gl, shaderdecl, options = { })\n    {\n        super('...args', 'return this._self._call(...args)');\n        this._self = this.bind(this);\n        this._self._init(gl, shaderdecl, options);\n        return this._self;\n    }\n\n    /**\n     * Resize the output texture\n     * @param {number} width \n     * @param {number} height \n     */\n    resize(width, height)\n    {\n        // lost context?\n        const gl = this._gl;\n        if(gl.isContextLost())\n            return;\n\n        // get size\n        width = Math.max(1, width | 0);\n        height = Math.max(1, height | 0);\n\n        // no need to resize?\n        if(width === this._stdprog.width && height === this._stdprog.height)\n            return;\n\n        // update options.output\n        const options = this._options;\n        options.output[0] = width;\n        options.output[1] = height;\n\n        // reallocate buffers for reading pixels\n        this._reallocatePixelBuffers(width, height);\n\n        // resize stdprog\n        this._stdprog.resize(width, height);\n    }\n\n    /**\n     * Read pixels from the output texture.\n     * You may optionally specify a (x,y,width,height) sub-rectangle.\n     * @param {number} [x]\n     * @param {number} [y] \n     * @param {number} [width]\n     * @param {number} [height]\n     * @returns {Uint8Array} pixels in the RGBA format\n     */\n    readPixelsSync(x = 0, y = 0, width = -1, height = -1)\n    {\n        const gl = this._gl;\n\n        // lost context?\n        if(gl.isContextLost())\n            return this._pixelBuffer[0];\n\n        // default values\n        if(width < 0)\n            width = this._stdprog.width;\n        if(height < 0)\n            height = this._stdprog.height;\n\n        // clamp values\n        width = Math.min(width, this._stdprog.width);\n        height = Math.min(height, this._stdprog.height);\n        x = Math.max(0, Math.min(x, width - 1));\n        y = Math.max(0, Math.min(y, height - 1));\n\n        // allocate the pixel buffers\n        if(this._pixelBuffer[0] == null)\n            this._reallocatePixelBuffers(this._stdprog.width, this._stdprog.height);\n\n        // read pixels\n        if(this._stdprog.fbo != null) {\n            gl.bindFramebuffer(gl.FRAMEBUFFER, this._stdprog.fbo);\n            gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, this._pixelBuffer[0]);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        }\n        else\n            gl.readPixels(x, y, width, height, gl.RGBA, gl.UNSIGNED_BYTE, this._pixelBuffer[0]);\n\n        // done!\n        return this._pixelBuffer[0];\n    }\n\n    /**\n     * Read pixels from the output texture asynchronously with PBOs.\n     * You may optionally specify a (x,y,width,height) sub-rectangle.\n     * (this won't work very well if options.renderToTexture == false\n     * and you display the canvas)\n     * @param {number} [x]\n     * @param {number} [y] \n     * @param {number} [width]\n     * @param {number} [height]\n     * @param {boolean} [useBufferedDownloads] optimize downloads\n     * @returns {Promise<Uint8Array>} resolves to an array of pixels in the RGBA format\n     */\n    readPixelsAsync(x = 0, y = 0, width = -1, height = -1, useBufferedDownloads = true)\n    {\n        const gl = this._gl;\n\n        // lost context?\n        if(gl.isContextLost())\n            return Promise.resolve(this._pixelBuffer[0]);\n\n        // default values\n        if(width < 0)\n            width = this._stdprog.width;\n        if(height < 0)\n            height = this._stdprog.height;\n\n        // clamp values\n        width = Math.min(width, this._stdprog.width);\n        height = Math.min(height, this._stdprog.height);\n        x = Math.max(0, Math.min(x, width - 1));\n        y = Math.max(0, Math.min(y, height - 1));\n\n        // allocate the pixel buffers\n        if(this._pixelBuffer[0] == null)\n            this._reallocatePixelBuffers(this._stdprog.width, this._stdprog.height);\n\n        // do not optimize?\n        if(!useBufferedDownloads) {\n            return GLUtils.readPixelsViaPBO(gl, this._pixelBuffer[0], x, y, width, height, this._stdprog.fbo).then(downloadTime => {\n                return this._pixelBuffer[0];\n            });\n        }\n\n        // GPU needs to produce data\n        if(this._pboProducerQueue.length > 0) {\n            const nextPBO = this._pboProducerQueue.shift();\n            GLUtils.readPixelsViaPBO(gl, this._pixelBuffer[nextPBO], x, y, width, height, this._stdprog.fbo).then(downloadTime => {\n                this._pboConsumerQueue.push(nextPBO);\n            });\n        }\n        else waitForQueueNotEmpty(this._pboProducerQueue).then(waitTime => {\n            const nextPBO = this._pboProducerQueue.shift();\n            GLUtils.readPixelsViaPBO(gl, this._pixelBuffer[nextPBO], x, y, width, height, this._stdprog.fbo).then(downloadTime => {\n                this._pboConsumerQueue.push(nextPBO);\n            });\n        });\n\n        // CPU needs to consume data\n        if(this._pboConsumerQueue.length > 0) {\n            const readyPBO = this._pboConsumerQueue.shift();\n            return new Promise(resolve => {\n                resolve(this._pixelBuffer[readyPBO]);\n                this._pboProducerQueue.push(readyPBO); // enqueue AFTER resolve()\n            });\n        }\n        else return new Promise(resolve => {\n            waitForQueueNotEmpty(this._pboConsumerQueue).then(waitTime => {\n                const readyPBO = this._pboConsumerQueue.shift();\n                resolve(this._pixelBuffer[readyPBO]);\n                this._pboProducerQueue.push(readyPBO); // enqueue AFTER resolve()\n            });\n        });\n    }\n\n    /**\n     * Set data using a Uniform Buffer Object\n     * @param {string} blockName uniform block name\n     * @param {ArrayBufferView} data\n     */\n    setUBO(blockName, data)\n    {\n        if(this._ubo === null)\n            this._ubo = new UBOHandler(this._gl, this._stdprog.program);\n\n        this._ubo.set(blockName, data);\n    }\n\n    /**\n     * Read uniforms of the program (metadata)\n     * @returns {object}\n     */\n    get uniforms()\n    {\n        return this._stdprog.uniform;\n    }\n\n    /**\n     * Width of the internal texture, in pixels\n     * @returns {number}\n     */\n    get width()\n    {\n        return this._stdprog.width;\n    }\n\n    /**\n     * Height of the internal texture, in pixels\n     * @returns {number}\n     */\n    get height()\n    {\n        return this._stdprog.height;\n    }\n\n    /**\n     * Clear the internal textures to a color\n     * @param {number} r in [0,1]\n     * @param {number} g in [0,1]\n     * @param {number} b in [0,1]\n     * @param {number} [a] in [0,1]\n     * @returns {SpeedyTexture}\n     */\n    clear(r, g, b, a = 1.0)\n    {\n        const gl = this._gl;\n        const stdprog = this._stdprog;\n\n        // skip things\n        if(gl.isContextLost())\n            return stdprog.texture;\n\n        // clear internal textures\n        stdprog.clear(r, g, b, a);\n\n        // done!\n        return stdprog.texture;\n    }\n\n    // Prepare the shader\n    _init(gl, shaderdecl, options)\n    {\n        // default options\n        options = {\n            output: [ gl.drawingBufferWidth, gl.drawingBufferHeight ], // size of the output texture\n            uniforms: { }, // user-defined constants (as uniforms)\n            renderToTexture: true, // render results to a texture?\n            recycleTexture: true, // recycle output texture? If false, you must manually destroy the output texture\n            pingpong: false, // alternate output texture between calls\n            ...options // user-defined options\n        };\n\n        // validate options\n        if(options.pingpong && !options.renderToTexture)\n            throw new IllegalOperationError(`Pingpong rendering can only be used when rendering to textures`);\n\n        // get size\n        let width = Math.max(1, options.output[0] | 0);\n        let height = Math.max(1, options.output[1] | 0);\n        options.output = [ width, height ];\n\n        // need to resize the canvas?\n        const canvas = gl.canvas;\n        if(width > canvas.width)\n            canvas.width = width;\n        if(height > canvas.height)\n            canvas.height = height;\n\n        // if(gl.isContextLost()) ...\n\n        // create shader\n        const stdprog = new StandardProgram(gl, width, height, shaderdecl, options.uniforms);\n        if(options.renderToTexture)\n            stdprog.attachFBO(options.pingpong);\n\n        // validate arguments\n        const params = shaderdecl.arguments;\n        for(let j = 0; j < params.length; j++) {\n            if(!stdprog.uniform.hasOwnProperty(params[j])) {\n                if(!stdprog.uniform.hasOwnProperty(params[j] + '[0]'))\n                    throw new IllegalOperationError(`Can't run shader: expected uniform \"${params[j]}\"`);\n            }\n        }\n\n        // store context\n        this._gl = gl;\n        this._source = shaderdecl.fragmentSource;\n        this._options = Object.freeze(options);\n        this._stdprog = stdprog;\n        this._params = params;\n        this._ubo = null; // lazy spawn\n        this._initPixelBuffers(gl);\n    }\n\n    // Run the SpeedyProgram\n    _call(...args)\n    {\n        const gl = this._gl;\n        const options = this._options;\n        const stdprog = this._stdprog;\n        const params = this._params;\n\n        // skip things\n        if(gl.isContextLost())\n            return stdprog.texture;\n        \n        // matching arguments?\n        if(args.length != params.length)\n            throw new IllegalArgumentError(`Can't run shader: incorrect number of arguments`);\n\n        // use program\n        gl.useProgram(stdprog.program);\n\n        // update texSize uniform\n        if(stdprog.dirtySize) { // if the program was resized\n            gl.uniform2f(stdprog.uniform.texSize.location, stdprog.width, stdprog.height);\n            stdprog.dirtySize = false;\n        }\n\n        // set uniforms[i] to args[i]\n        for(let i = 0, texNo = 0; i < args.length; i++) {\n            const argname = params[i];\n            let uniform = stdprog.uniform[argname];\n\n            if(uniform) {\n                // uniform variable matches parameter name\n                texNo = this._setUniform(uniform, args[i], texNo);\n            }\n            else if(stdprog.uniform.hasOwnProperty(argname + '[0]')) {\n                // uniform array matches parameter name\n                const array = args[i];\n                if(stdprog.uniform.hasOwnProperty(`${argname}[${array.length}]`))\n                    throw new IllegalArgumentError(`Can't run shader: too few elements in array \"${argname}\"`);\n                for(let j = 0; (uniform = stdprog.uniform[`${argname}[${j}]`]); j++)\n                    texNo = this._setUniform(uniform, array[j], texNo);\n            }\n            else\n                throw new IllegalArgumentError(`Can't run shader: unknown parameter \"${argname}\": ${args[i]}`);\n        }\n\n        // set Uniform Buffer Objects (if any)\n        if(this._ubo !== null)\n            this._ubo.update();\n\n        // bind fbo\n        if(options.renderToTexture)\n            gl.bindFramebuffer(gl.FRAMEBUFFER, stdprog.fbo);\n        else\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n        // render\n        gl.viewport(0, 0, stdprog.width, stdprog.height);\n        gl.drawArrays(gl.TRIANGLE_STRIP,\n                      0,        // offset\n                      4);       // count\n\n        // output texture\n        let outputTexture = null;\n        if(options.renderToTexture) {\n            outputTexture = stdprog.texture;\n\n            // clone outputTexture using the current framebuffer\n            if(!options.recycleTexture) {\n                const cloneTexture = new SpeedyTexture(gl, stdprog.width, stdprog.height);\n                gl.activeTexture(gl.TEXTURE0);\n                gl.bindTexture(gl.TEXTURE_2D, cloneTexture.glTexture);\n                gl.copyTexSubImage2D(gl.TEXTURE_2D,     // target\n                                     0,                 // mipmap level\n                                     0,                 // xoffset\n                                     0,                 // yoffset\n                                     0,                 // x\n                                     0,                 // y\n                                     stdprog.width,     // width\n                                     stdprog.height);   // height\n                gl.bindTexture(gl.TEXTURE_2D, null);\n                outputTexture = cloneTexture;\n            }\n\n            // ping-pong rendering\n            if(options.pingpong)\n                stdprog.pingpong();\n\n            // invalidate mipmaps\n            outputTexture.discardMipmap();\n        }\n\n        // unbind fbo\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n        // return texture (if available)\n        return outputTexture;\n    }\n\n    // set uniform to value\n    // arrays of arbitrary size are not supported, only fixed-size vectors (vecX, ivecX, etc.)\n    _setUniform(uniform, value, texNo)\n    {\n        const gl = this._gl;\n\n        if(uniform.type == 'sampler2D') {\n            // set texture\n            if(texNo > gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS)\n                throw new NotSupportedError(`Can't bind ${texNo} textures to a program: max is ${gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS}`);\n            else if(value === this._stdprog.texture)\n                throw new NotSupportedError(`Can't run shader: cannot use its output texture as an input to itself`);\n            else if(value == null)\n                throw new IllegalArgumentError(`Can't run shader: cannot use null as an input texture`);\n\n            gl.activeTexture(gl.TEXTURE0 + texNo);\n            gl.bindTexture(gl.TEXTURE_2D, value.glTexture);\n            gl.uniform1i(uniform.location, texNo);\n            texNo++;\n        }\n        else {\n            // set value\n            if(typeof value == 'number' || typeof value == 'boolean')\n                (gl[UNIFORM_TYPES[uniform.type]])(uniform.location, value);\n            else if(Array.isArray(value))\n                (gl[UNIFORM_TYPES[uniform.type]])(uniform.location, ...value);\n            else\n                throw new IllegalArgumentError(`Can't run shader: unrecognized argument \"${value}\"`);\n        }\n\n        return texNo;\n    }\n\n    // initialize pixel buffers\n    _initPixelBuffers(gl)\n    {\n        this._pixelBuffer = Array(PBO_COUNT).fill(null);\n        this._pixelBufferSize = [0, 0]; // width, height\n        this._pboConsumerQueue = Array(PBO_COUNT).fill(0).map((_, i) => i);\n        this._pboProducerQueue = [];\n    }\n\n    // resize pixel buffers\n    _reallocatePixelBuffers(width, height)\n    {\n        // skip realloc\n        if(width * height <= this._pixelBufferSize[0] * this._pixelBufferSize[1])\n            return;\n\n        // update size\n        this._pixelBufferSize[0] = width;\n        this._pixelBufferSize[1] = height;\n\n        // reallocate pixels array\n        for(let i = 0; i < PBO_COUNT; i++) {\n            const oldBuffer = this._pixelBuffer[i];\n            this._pixelBuffer[i] = this._createPixelBuffer(width, height);\n\n            if(oldBuffer) {\n                if(oldBuffer.length > this._pixelBuffer[i].length)\n                    this._pixelBuffer[i].set(oldBuffer.slice(0, this._pixelBuffer[i].length));\n                else\n                    this._pixelBuffer[i].set(oldBuffer);\n            }\n        }\n    }\n\n    // create a width x height buffer for RGBA data\n    _createPixelBuffer(width, height)\n    {\n        const pixels = new Uint8Array(width * height * 4);\n        pixels.fill(255, 0, 4); // will be recognized as empty\n        return pixels;\n    }\n}\n\n\n\n//\n// Standard Program\n//\n\n// a standard program runs a shader on an \"image\"\n// uniforms: { 'name': <default_value>, ... }\nfunction StandardProgram(gl, width, height, shaderdecl, uniforms = { })\n{\n    // compile shaders\n    const program = GLUtils.createProgram(gl, shaderdecl.vertexSource, shaderdecl.fragmentSource);\n\n    // setup geometry\n    gl.bindAttribLocation(program, LOCATION_ATTRIB_POSITION, shaderdecl.attributes.position);\n    gl.bindAttribLocation(program, LOCATION_ATTRIB_TEXCOORD, shaderdecl.attributes.texCoord);\n    const vertexObjects = GLUtils.createStandardGeometry(gl, LOCATION_ATTRIB_POSITION, LOCATION_ATTRIB_TEXCOORD);\n\n    // define texSize\n    width = Math.max(width | 0, 1);\n    height = Math.max(height | 0, 1);\n    uniforms.texSize = [ width, height ];\n\n    // autodetect uniforms\n    const uniform = { };\n    for(const u of shaderdecl.uniforms)\n        uniform[u] = { type: shaderdecl.uniformType(u) };\n\n    // given the declared uniforms, get their\n    // locations and set their default values\n    gl.useProgram(program);\n    for(const u in uniform) {\n        // get location\n        uniform[u].location = gl.getUniformLocation(program, u);\n\n        // validate type\n        if(!UNIFORM_TYPES.hasOwnProperty(uniform[u].type))\n            throw new NotSupportedError(`Unknown uniform type: ${uniform[u].type}`);\n\n        // must set a default value?\n        if(uniforms.hasOwnProperty(u)) {\n            const value = uniforms[u];\n            if(typeof value == 'number' || typeof value == 'boolean')\n                (gl[UNIFORM_TYPES[uniform[u].type]])(uniform[u].location, value);\n            else if(typeof value == 'object')\n                (gl[UNIFORM_TYPES[uniform[u].type]])(uniform[u].location, ...Array.from(value));\n            else\n                throw new IllegalArgumentError(`Unrecognized uniform value: \"${value}\"`);\n        }\n\n        // note: to set the default value of array arr, pass\n        // { 'arr[0]': val0, 'arr[1]': val1, ... } to uniforms\n    }\n\n    // done!\n    this.gl = gl;\n    this.program = program;\n    this.uniform = uniform;\n    this.width = width;\n    this.height = height;\n    this.dirtySize = false;\n    this.vertexObjects = vertexObjects;\n    this._fbo = this._texture = null;\n    this._texIndex = 0;\n    Object.defineProperty(this, 'fbo', {\n        get: () => this._fbo ? this._fbo[this._texIndex] : null\n    });\n    Object.defineProperty(this, 'texture', {\n        get: () => this._texture ? this._texture[this._texIndex] : null\n    });\n    Object.defineProperty(this, 'pingpongTexture', {\n        get: () => this._texture && this._texture.length > 1 ? this._texture[1 - this._texIndex] : null\n    });\n}\n\n// Attach a framebuffer object to a standard program\nStandardProgram.prototype.attachFBO = function(pingpong = false)\n{\n    const gl = this.gl;\n    const width = this.width;\n    const height = this.height;\n    const numTextures = pingpong ? 2 : 1;\n\n    this._texIndex = 0;\n    this._texture = Array(numTextures);\n    this._fbo = Array(numTextures);\n\n    for(let i = 0; i < numTextures; i++) {\n        this._texture[i] = new SpeedyTexture(gl, width, height);\n        this._fbo[i] = GLUtils.createFramebuffer(gl, this._texture[i].glTexture);\n    }\n}\n\n// Detach a framebuffer object from a standard program\nStandardProgram.prototype.detachFBO = function()\n{\n    const gl = this.gl;\n\n    if(this._fbo != null) {\n        for(let fbo of this._fbo)\n            GLUtils.destroyFramebuffer(gl, fbo);\n        this._fbo = null;\n    }\n\n    if(this._texture != null) {\n        for(let texture of this._texture)\n            texture.release();\n        this._texture = null;\n    }\n\n    this._texIndex = 0;\n}\n\n// Ping-pong rendering\nStandardProgram.prototype.pingpong = function()\n{\n    if(this._fbo != null && this._fbo.length > 1)\n        this._texIndex = 1 - this._texIndex;\n}\n\n// Resize\nStandardProgram.prototype.resize = function(width, height)\n{\n    const gl = this.gl;\n    const oldWidth = this.width;\n    const oldHeight = this.height;\n\n    // validate size\n    width = Math.max(1, width | 0);\n    height = Math.max(1, height | 0);\n\n    // update size\n    this.width = width;\n    this.height = height;\n\n    // set dirty flag to update texSize uniform later\n    this.dirtySize = true;\n\n    // resize textures\n    if(this._fbo != null) {\n        const numTextures = this._fbo.length;\n        const newTexture = Array(numTextures);\n        const newFBO = Array(numTextures);\n\n        // create textures with new size & old content\n        for(let i = 0; i < numTextures; i++) {\n            newTexture[i] = new SpeedyTexture(gl, width, height);\n\n            /*\n            gl.bindFramebuffer(gl.FRAMEBUFFER, this._fbo[i]);\n            gl.activeTexture(gl.TEXTURE0);\n            gl.bindTexture(gl.TEXTURE_2D, newTexture[i].glTexture);\n\n            //\n            // BUG: calling copyTexSubImage2D() below generates a warning\n            //      on Firefox - investigate further\n            //\n            // \"Texture has not been initialized prior to a partial upload,\n            //  forcing the browser to clear it. This may be slow.\"\n            //\n            // FIXME: Currently, texture contents are being lost on resize\n            //\n\n            // copy old content\n            gl.copyTexSubImage2D(gl.TEXTURE_2D,     // target\n                                 0,                 // mipmap level\n                                 0,                 // xoffset\n                                 0,                 // yoffset\n                                 0,                 // x\n                                 0,                 // y\n                                 Math.min(width, oldWidth),    // width\n                                 Math.min(height, oldHeight)); // height\n\n            gl.bindTexture(gl.TEXTURE_2D, null);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n            */\n\n            newFBO[i] = GLUtils.createFramebuffer(gl, newTexture[i].glTexture);\n        }\n\n        // release old textures\n        for(let fbo of this._fbo)\n            GLUtils.destroyFramebuffer(gl, fbo);\n\n        for(let texture of this._texture)\n            texture.release();\n\n        // update references\n        this._texture = newTexture;\n        this._fbo = newFBO;\n    }\n\n    //console.log(`Resized program to ${width} x ${height}`);\n}\n\n// Clear inner textures to a color: 0 <= r,g,b,a <= 1\nStandardProgram.prototype.clear = function(r, g, b, a)\n{\n    const gl = this.gl;\n\n    // nothing to do\n    if(this._fbo == null)\n        return;\n\n    // clear all textures\n    for(let i = 0; i < this._fbo.length; i++) {\n        gl.bindFramebuffer(gl.FRAMEBUFFER, this._fbo[i]);\n        gl.viewport(0, 0, this.width, this.height);\n        gl.clearColor(r, g, b, a);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n    }\n\n    // unbind\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n}\n\n// invalidate FBOs\nStandardProgram.prototype.invalidateFramebuffer = function()\n{\n    const gl = this.gl;\n\n    // nothing to do\n    if(this._fbo == null)\n        return;\n\n    // invalidate framebuffers\n    for(let i = 0; i < this._fbo.length; i++) {\n        gl.bindFramebuffer(gl.FRAMEBUFFER, this._fbo[i]);\n        gl.invalidateFramebuffer(gl.FRAMEBUFFER, [gl.COLOR_ATTACHMENT0]);\n    }\n\n    // unbind\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n}\n\n\n\n//\n// Consumer-producer\n//\n\n// wait for a queue to be not empty\nfunction waitForQueueNotEmpty(queue)\n{\n    return new Promise(resolve => {\n        const start = performance.now();\n        function wait() {\n            if(queue.length > 0)\n                resolve(performance.now() - start);\n            else\n                setTimeout(wait, 0); // Utils.setZeroTimeout may hinder performance (GLUtils already calls it)\n                //Utils.setZeroTimeout(wait);\n        }\n        wait();\n    });\n}\n\n\n\n\n//\n// Uniform Buffer Objects\n//\n\n/**\n * UBO Handler\n * @param {WebGL2RenderingContext} gl\n * @param {WebGLProgram} program\n */\nfunction UBOHandler(gl, program)\n{\n    this._gl = gl;\n    this._program = program;\n    this._nextIndex = 0;\n    this._ubo = {};\n}\n\n/**\n * Set Uniform Buffer Object data\n * (the buffer will only be uploaded when the program runs)\n * @param {string} name uniform block name\n * @param {ArrayBufferView} data\n */\nUBOHandler.prototype.set = function(name, data)\n{\n    const gl = this._gl;\n    const program = this._program;\n\n    // create UBO entry\n    if(!this._ubo.hasOwnProperty(name)) {\n        this._ubo[name] = {\n            buffer: gl.createBuffer(),\n            blockBindingIndex: this._nextIndex++, // \"global\" binding index\n        };\n    }\n\n    // get UBO entry for the given block name\n    const ubo = this._ubo[name];\n\n    // read block index & assign binding point\n    if(!ubo.hasOwnProperty('blockIndex')) {\n        const blockIndex = gl.getUniformBlockIndex(program, name); // UBO \"location\" in the program\n        gl.uniformBlockBinding(program, blockIndex, ubo.blockBindingIndex);\n    }\n\n    // store data - will upload it later\n    ubo.data = data;\n}\n\n/**\n * Update UBO data\n * Called when we're using the appropriate WebGLProgram\n */\nUBOHandler.prototype.update = function()\n{\n    const gl = this._gl;\n\n    for(const name in this._ubo) {\n        const ubo = this._ubo[name];\n\n        gl.bindBuffer(gl.UNIFORM_BUFFER, ubo.buffer);\n        gl.bufferData(gl.UNIFORM_BUFFER, ubo.data.byteLength, gl.DYNAMIC_DRAW); // buffer orphaning - needed?\n        gl.bufferData(gl.UNIFORM_BUFFER, ubo.data, gl.DYNAMIC_DRAW);\n        gl.bindBufferBase(gl.UNIFORM_BUFFER, ubo.blockBindingIndex, ubo.buffer);\n        gl.bindBuffer(gl.UNIFORM_BUFFER, null);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-texture.js\n * A wrapper around WebGLTexture\n */\n\nimport { GLUtils } from './gl-utils';\nimport { IllegalOperationError } from '../utils/errors';\n\n/**\n * A wrapper around WebGLTexture\n */\nexport class SpeedyTexture\n{\n    /**\n     * Creates a new texture with the specified dimensions\n     * @param {WebGL2RenderingContext} gl \n     * @param {number} width \n     * @param {number} height \n     */\n    constructor(gl, width, height)\n    {\n        this._gl = gl;\n        this._width = width;\n        this._height = height;\n        this._glTexture = GLUtils.createTexture(this._gl, this._width, this._height);\n        this._hasMipmaps = false;\n    }\n\n    /**\n     * Releases the texture\n     * @returns {null}\n     */\n    release()\n    {\n        if(this._glTexture !== null) {\n            GLUtils.destroyTexture(this._gl, this._glTexture);\n            this._glTexture = null;\n            this._width = this._height = 0;\n        }\n        else\n            throw new IllegalOperationError(`The SpeedyTexture has already been released`);\n\n        return null;\n    }\n\n    /**\n     * Upload pixel data to the texture\n     * @param {ImageBitmap|ImageData|ArrayBufferView|HTMLImageElement|HTMLVideoElement|HTMLCanvasElement} pixels \n     * @param {number} [lod] mipmap level-of-detail\n     */\n    upload(pixels, lod = 0)\n    {\n        this._hasMipmaps = false;\n        GLUtils.uploadToTexture(this._gl, this._glTexture, this._width, this._height, pixels, lod | 0);\n    }\n\n    /**\n     * Generates mipmaps for this texture\n     * This computes the image pyramid via hardware\n     * @returns {SpeedyTexture} this\n     */\n    generateMipmap()\n    {\n        if(!this._hasMipmaps) {\n            // TODO: generate octaves via gaussians\n            GLUtils.generateMipmap(this._gl, this._glTexture);\n            this._hasMipmaps = true;\n        }\n\n        return this;\n    }\n\n    /**\n     * Invalidates previously generated mipmaps\n     */\n    discardMipmap()\n    {\n        this._hasMipmaps = false;\n    }\n\n    /**\n     * The internal WebGLTexture\n     * @returns {WebGLTexture}\n     */\n    get glTexture()\n    {\n        return this._glTexture;\n    }\n\n    /**\n     * The width of the texture, in pixels\n     * @returns {number}\n     */\n    get width()\n    {\n        return this._width;\n    }\n\n    /**\n     * The height of the texture, in pixels\n     * @returns {number}\n     */\n    get height()\n    {\n        return this._height;\n    }\n\n    /**\n     * The WebGL Context\n     * @returns {WebGL2RenderingContext}\n     */\n    get gl()\n    {\n        return this._gl;\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * index.js\n * The entry point of the library\n */\n\nmodule.exports = require('./core/speedy').Speedy;","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * errors.js\n * Error classes\n */\n\n/**\n * Generic error class for Speedy\n */\nexport class SpeedyError extends Error\n{\n    /**\n     * Class constructor\n     * @param {string} message message text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message, cause = null)\n    {\n        super([\n            message,\n            cause ? cause.toString() : '[speedy-vision.js]'\n        ].join('\\n-> '));\n        this._cause = cause;\n    }\n\n    /**\n     * Error name\n     * @returns {string}\n     */\n    get name()\n    {\n        return this.constructor.name;\n    }\n\n    /**\n     * Set error name (ignored)\n     * @param {string} _ ignored\n     */\n    set name(_)\n    {\n        ;\n    }\n\n    /**\n     * Get the cause of the error. Available if\n     * it has been specified in the constructor\n     * @returns {SpeedyError|null}\n     */\n    get cause()\n    {\n        return this._cause;\n    }\n}\n\n/**\n * Unsupported operation error\n * The requested operation is not supported\n */\nexport class NotSupportedError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Unsupported operation. ${message}`, cause);\n    }\n}\n\n/**\n * Not implemented error\n * The called method is not implemented\n */\nexport class NotImplementedError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Method not implemented. ${message}`, cause);\n    }\n}\n\n/**\n * WebGL error\n */\nexport class GLError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`WebGL error. ${message}`, cause);\n    }\n}\n\n/**\n * AbstractMethodError\n * Thrown when one tries to call an abstract method\n */\nexport class AbstractMethodError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Can't call abstract method. ${message}`, cause);\n    }\n}\n\n/**\n * Illegal argument error\n * A method has received one or more illegal arguments\n */\nexport class IllegalArgumentError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Illegal argument. ${message}`, cause);\n    }\n}\n\n/**\n * Illegal operation error\n * The method arguments are valid, but the method can't\n * be called due to the current the state of the object\n */\nexport class IllegalOperationError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Illegal operation. ${message}`, cause);\n    }\n}\n\n/**\n * File not found error\n */\nexport class FileNotFoundError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`File not found. ${message}`, cause);\n    }\n}\n\n/**\n * Timeout error\n */\nexport class TimeoutError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Timeout error. ${message}`, cause);\n    }\n}\n\n/**\n * Parse error\n */\nexport class ParseError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Parse error. ${message}`, cause);\n    }\n}\n\n/**\n * Assertion error\n */\nexport class AssertionError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Assertion failed. ${message}`, cause);\n    }\n}\n\n/**\n * Access denied\n */\nexport class AccessDeniedError extends SpeedyError\n{\n    /**\n     * Class constructor\n     * @param {string} [message] additional text\n     * @param {SpeedyError} [cause] cause of the error\n     */\n    constructor(message = '', cause = null)\n    {\n        super(`Access denied. ${message}`, cause);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * fps-counter.js\n * A FPS counter\n */\n\nimport { IllegalOperationError } from './errors';\n\nlet instance = null;\nconst UPDATE_INTERVAL = 500; // in ms\n\nexport class FPSCounter\n{\n    /**\n     * Creates a new FPSCounter\n     */\n    /* private */ constructor()\n    {\n        this._fps = 60;\n        this._frames = 0;\n        this._updateInterval = UPDATE_INTERVAL;\n        this._lastUpdate = performance.now();\n        this._boundUpdate = this._update.bind(this);\n\n        // this should never happen...\n        if(instance !== null)\n            throw new IllegalOperationError(`Can't have multiple instances of FPSCounter`);\n\n        // start FPS counter\n        this._boundUpdate();\n    }\n\n    /**\n     * Gets an instance of the FPS counter.\n     * We use lazy loading, i.e., we will not\n     * create a FPS counter unless we need to!\n     * @returns {FPSCounter}\n     */\n    static get instance()\n    {\n        if(instance === null)\n            instance = new FPSCounter();\n\n        return instance;\n    }\n\n    /**\n     * Get the FPS rate\n     * @returns {number} frames per second\n     */\n    get fps()\n    {\n        return this._fps;\n    }\n\n    /**\n     * Updates the FPS counter\n     */\n    _update()\n    {\n        const now = performance.now();\n        const deltaTime = now - this._lastUpdate;\n\n        if(deltaTime >= this._updateInterval) {\n            this._fps = Math.round(this._frames / (deltaTime * 0.001));\n            this._frames = 0;\n            this._lastUpdate = now;\n        }\n\n        this._frames++;\n        requestAnimationFrame(this._boundUpdate);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * globals.js\n * Global constants\n */\n\n// -----------------------------------------------------------------\n// IMAGE PYRAMIDS & SCALE-SPACE\n// -----------------------------------------------------------------\n\n// The maximum number of layers of the pyramid (not counting intra-layers)\nexport const PYRAMID_MAX_LEVELS = 4; // scaling factor = 1\n\n// The maximum number of layers of the pyramid (counting intra-layers)\nexport const PYRAMID_MAX_OCTAVES = 2 * PYRAMID_MAX_LEVELS - 1; // scaling factor = sqrt(2)\n\n// The maximum supported scale for a pyramid layer\nexport const PYRAMID_MAX_SCALE = 2; // preferably a power of 2 (image scale can go up to this value)\n\n// The base-2 logarithm of PYRAMID_MAX_SCALE\nexport const LOG2_PYRAMID_MAX_SCALE = Math.log2(PYRAMID_MAX_SCALE);\n\n\n\n// -----------------------------------------------------------------\n// FIXED-POINT MATH\n// -----------------------------------------------------------------\n\n// How many bits do we use for storing the fractional data\nexport const FIX_BITS = 3; // MAX_TEXTURE_LENGTH depends on this\n\n// Fixed-point resolution\nexport const FIX_RESOLUTION = 1.0 * (1 << FIX_BITS); // float(2^(FIX_BITS))\n\n\n\n// -----------------------------------------------------------------\n// TEXTURE LIMITS\n// -----------------------------------------------------------------\n\n// Maximum texture length\nexport const MAX_TEXTURE_LENGTH = (1 << (16 - FIX_BITS)) - 2; // 2^n - 2 due to keypoint encoding","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * observable.js\n * Observer design pattern\n */\n\n/**\n * Implementation of the Observer design pattern\n */\nexport /* abstract */ class Observable\n{\n    /**\n     * Class constructor\n     */\n    constructor()\n    {\n        this._subscribers = [];\n    }\n\n    /**\n     * Add subscriber\n     * @param {Function} fn callback\n     */\n    subscribe(fn)\n    {\n        if(this._subscribers.indexOf(fn) < 0)\n            this._subscribers.push(fn);\n    }\n\n    /**\n     * Remove subscriber\n     * @param {Function} fn previously added callback\n     */\n    unsubscribe(fn)\n    {\n        this._subscribers = this._subscribers.filter(subscriber => subscriber !== fn);\n    }\n\n    /**\n     * Notify all subscribers about a state change\n     * @param {any} data generic data\n     */\n    /* protected */ _notify(data)\n    {\n        for(const fn of this._subscribers)\n            fn(data);\n    }\n}","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * speedy-promise.js\n * Speedy Promises: a fast implementation of Promises\n */\n\nconst PENDING = 0;\nconst FULFILLED = 1;\nconst REJECTED = 2;\n\nconst SUSPEND_ASYNC = 1;\nconst DISABLE_ASYNC = 2;\nconst asap = (typeof queueMicrotask !== 'undefined' && queueMicrotask) || // browsers\n             (typeof process !== 'undefined' && process.nextTick) || // node.js\n             (f => Promise.resolve().then(f)); // most compatible\n\n/**\n * SpeedyPromise: Super Fast Promises. SpeedyPromises can\n * interoperate with ES6 Promises. This implementation is\n * based on the Promises/A+ specification.\n */\n class SpeedyPromise\n{\n    /**\n     * Constructor\n     * @param {Function} callback\n     * @param {boolean} [sync] a hint that you'll be calling turbocharge() after a chain of then()/catch()/finally()\n     */\n    constructor(callback, sync = false)\n    {\n        this._state = PENDING;\n        this._value = undefined;\n\n        this._onFulfillment = null;\n        this._onRejection = null;\n        this._children = 0;\n        this[0] = this;\n        this._parent = undefined;\n        this._flags = sync ? DISABLE_ASYNC : 0;\n\n        this._fulfill = this._fulfill.bind(this);\n        this._reject = this._reject.bind(this);\n        this._resolve = this._resolve.bind(this);\n        this._broadcastIfAsync = this._broadcastIfAsync.bind(this);\n\n        callback(this._fulfill, this._reject);\n    }\n\n    /**\n     * Setup handlers\n     * @param {Function} onFulfillment called when the SpeedyPromise is fulfilled\n     * @param {Function} [onRejection] called when the SpeedyPromise is rejected\n     * @returns {SpeedyPromise}\n     */\n    then(onFulfillment, onRejection = null)\n    {\n        const child = new SpeedyPromise(this._nop);\n        child._onFulfillment = typeof onFulfillment === 'function' && onFulfillment;\n        child._onRejection = typeof onRejection === 'function' && onRejection;\n        child._parent = this;\n\n        this[this._children++] = child; // attach child\n        this._flags &= ~SUSPEND_ASYNC; // restore the async behavior\n        this._notify();\n\n        return child;\n    }\n\n    /**\n     * Setup rejection handler\n     * @param {Function} onRejection called when the SpeedyPromise is rejected\n     * @returns {SpeedyPromise}\n     */\n    catch(onRejection)\n    {\n        return this.then(null, onRejection);\n    }\n\n    /**\n     * Execute a callback when the promise is settled\n     * (i.e., fulfilled or rejected)\n     * @param {Function} onFinally\n     * @returns {SpeedyPromise}\n     */\n    finally(onFinally)\n    {\n        const fn = val => { onFinally(); return val; };\n        return this.then(fn, fn);\n    }\n\n    /**\n     * Start the computation immediately, synchronously.\n     * Can't afford to spend any time at all waiting for micro-tasks, etc.\n     * @returns {SpeedyPromise} this\n     */\n    turbocharge()\n    {\n        let my = this;\n\n        // suspend the async behavior\n        this._flags |= SUSPEND_ASYNC;\n        while(my._parent !== undefined) {\n            my = my._parent;\n            my._flags |= SUSPEND_ASYNC;\n        }\n\n        // notify the children of the root\n        my._notify(); // will be synchronous\n\n        // return this SpeedyPromise\n        return this;\n    }\n\n    /**\n     * Convert to string\n     * @returns {string}\n     */\n    toString()\n    {\n        switch(this._state) {\n            case PENDING:\n                return `SpeedyPromise { <pending> }`;\n            case FULFILLED:\n                return `SpeedyPromise { <fulfilled> ${this._value} }`;\n            case REJECTED:\n                return `SpeedyPromise { <rejected> ${this._value} }`;\n            default:\n                return '';\n        }\n    }\n\n    /**\n     * Creates a resolved SpeedyPromise\n     * @param {any} value\n     * @returns {SpeedyPromise}\n     */\n    static resolve(value)\n    {\n        const promise = new SpeedyPromise(this._snop);\n\n        if((typeof value === 'object' && value !== null && 'then' in value) || (typeof value === 'function' && 'then' in value)) {\n            // resolve asynchronously\n            promise._resolve(value);\n        }\n        else {\n            // fulfill synchronously\n            promise._value = value;\n            promise._state = FULFILLED;\n        }\n\n        return promise;\n    }\n\n    /**\n     * Creates a rejected SpeedyPromise\n     * @param {any} reason usually an instance of Error\n     * @returns {SpeedyPromise}\n     */\n    static reject(reason)\n    {\n        const promise = new SpeedyPromise(this._snop);\n        promise._value = reason;\n        promise._state = REJECTED;\n        return promise;\n    }\n\n    /**\n     * Returns a SpeedyPromise that resolves to an array\n     * containing the results of the input promises/values,\n     * in their given order. The returned SpeedyPromise will\n     * resolve if all input promises resolve, or reject if\n     * any input promise rejects.\n     * @param {iterable} iterable e.g., a SpeedyPromise[]\n     * @returns {SpeedyPromise}\n     */\n    static all(iterable)\n    {\n        return new SpeedyPromise((resolve, reject) => {\n            const input = [];\n\n            // get elements\n            for(const element of iterable)\n                input.push(element);\n\n            // resolve synchronously if there are no elements\n            const length = input.length;\n            if(length == 0) {\n                resolve([]);\n                return;\n            }\n\n            // resolve asynchronously\n            let counter = length;\n            const output = new Array(length);\n            const partialResolve = i => (val => { output[i] = val; if(0 == --counter) resolve(output); });\n            for(let i = 0; i < length; i++) {\n                const element = input[i];\n                if(element.__proto__ === SpeedyPromise.prototype || element.__proto__ === Promise.prototype)\n                    element.then(partialResolve(i), reject);\n                else\n                    SpeedyPromise.resolve(element).then(partialResolve(i), reject);\n            }\n        });\n    }\n\n    /**\n     * Returns a promise that gets fulfilled or rejected as soon\n     * as the first promise in the iterable gets fulfilled or\n     * rejected (with its value/reason).\n     * @param {iterable} iterable e.g., a SpeedyPromise[]\n     * @returns {SpeedyPromise}\n     */\n    static race(iterable)\n    {\n        return new SpeedyPromise((resolve, reject) => {\n            const input = [];\n\n            // get elements\n            for(const element of iterable)\n                input.push(element);\n\n            // if the iterable is empty, the promise\n            // will be pending forever...\n\n            // resolve asynchronously\n            const length = input.length;\n            for(let i = 0; i < length; i++) {\n                const element = input[i];\n                if(element.__proto__ === SpeedyPromise.prototype || element.__proto__ === Promise.prototype)\n                    element.then(resolve, reject);\n                else\n                    SpeedyPromise.resolve(element).then(resolve, reject);\n            }\n        });\n    }\n\n    /**\n     * Fulfill this promise with a value\n     * @param {any} value\n     */\n    _fulfill(value)\n    {\n        this._setState(FULFILLED, value);\n    }\n\n    /**\n     * Reject this promise with a reason\n     * @param {any} reason\n     */\n    _reject(reason)\n    {\n        this._setState(REJECTED, reason);\n    }\n\n    /**\n     * Set the state and the value of this promise\n     * @param {number} state\n     * @param {any} value\n     */\n    _setState(state, value)\n    {\n        // the promise is already fulfilled or rejected\n        if(this._state != PENDING)\n            return;\n\n        // set the new state\n        this._state = state;\n        this._value = value;\n        this._notify();\n    }\n\n    /**\n     * Notify my children that this promise is no\n     * longer pending. This is an async operation:\n     * my childen will be notified \"as soon\n     * as possible\" (it will be scheduled).\n     * We may force this to be synchronous, though\n     */\n    _notify()\n    {\n        // nothing to do\n        if(this._state == PENDING)\n            return;\n\n        // have we turbocharged this promise?\n        if(this._flags & SUSPEND_ASYNC) {\n            this._broadcast(); // execute synchronously\n            return;\n        }\n\n        // install a timer (default behavior)\n        if(!(this._flags & DISABLE_ASYNC))\n            asap(this._broadcastIfAsync);\n    }\n\n    /**\n     * Helper method\n     */\n    _broadcastIfAsync()\n    {\n        // we may have installed a timer at some\n        // point, but turbocharged the promise later\n        if(!(this._flags & SUSPEND_ASYNC))\n            this._broadcast();\n    }\n\n    /**\n     * Tell my children that this promise\n     * is either fulfilled or rejected.\n     * This is a synchronous operation\n     */\n    _broadcast()\n    {\n        const children = this._children;\n        const state = this._state;\n\n        if(state === FULFILLED) {\n            for(let i = 0; i < children; i++) {\n                const child = this[i];\n                const callback = child._onFulfillment;\n\n                try {\n                    if(callback) {\n                        if(callback !== child._nop) {\n                            child._resolve(callback(this._value)); // promise resolution procedure\n                            child._onFulfillment = child._nop; // will not be called again\n                        }\n                    }\n                    else\n                        child._fulfill(this._value);\n                }\n                catch(e) {\n                    child._reject(e);\n                }\n            }\n        }\n        else if(state === REJECTED) {\n            for(let i = 0; i < children; i++) {\n                const child = this[i];\n                const callback = child._onRejection;\n\n                try {\n                    if(callback) {\n                        if(callback !== child._nop) {\n                            child._resolve(callback(this._value)); // promise resolution procedure\n                            child._onRejection = child._nop; // will not be called again\n                        }\n                    }\n                    else\n                        child._reject(this._value);\n                }\n                catch(e) {\n                    child._reject(e);\n                }\n            }\n        }\n    }\n\n    /**\n     * Promise Resolution Procedure\n     * based on the Promises/A+ spec\n     * @param {any} x\n     */\n    _resolve(x)\n    {\n        if((typeof x !== 'object' && typeof x !== 'function') || (x === null)) { // if(x !== Object(x))\n            this._fulfill(x);\n            return;\n        }\n\n        if(x === this)\n            throw new TypeError(); // Circular reference\n\n        if(x.__proto__ === SpeedyPromise.prototype || x.__proto__ === Promise.prototype) {\n            x.then(this._resolve, this._reject);\n            return;\n        }\n\n        try {\n            const then = x.then;\n            if(typeof then === 'function') {\n                let resolve = this._resolve, reject = this._reject;\n                try {\n                    then.call(x,\n                        y => { resolve(y); resolve = reject = this._nop; },\n                        r => { reject(r); resolve = reject = this._nop; }\n                    );\n                }\n                catch(e) {\n                    if(resolve !== this._nop && reject !== this._nop)\n                        this._reject(e);\n                }\n            }\n            else {\n                this._fulfill(x);\n            }\n        }\n        catch(e) {\n            this._reject(e);\n        }\n    }\n\n    /**\n     * No-operation\n     */\n    _nop()\n    {\n    }\n\n    /**\n     * Static no-operation\n     */\n    static _snop()\n    {\n    }\n}\n\nmodule.exports = { SpeedyPromise };\n\n/*\n// Uncomment to test performance with regular Promises\nmodule.exports = { SpeedyPromise: Promise };\nPromise.prototype.turbocharge = function() { return this };\n*/","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * types.js\n * Types & formats\n */\n\nimport { Utils } from './utils';\n\nexport const MediaType = Utils.enum(\n    'Image',\n    'Video',\n    'Canvas',\n    'Bitmap'\n);\n\nexport const ColorFormat = Utils.enum(\n    'RGB',\n    'Greyscale',\n    'Binary'\n);\n\nexport const PixelComponent = Object.freeze({\n    RED:   1,\n    GREEN: 2,\n    BLUE:  4,\n    ALPHA: 8,\n    ALL:   15 // = RED | GREEN | BLUE | ALPHA\n});\n\nexport const ColorComponentId = Object.freeze({\n    [PixelComponent.RED]:   0,\n    [PixelComponent.GREEN]: 1,\n    [PixelComponent.BLUE]:  2,\n    [PixelComponent.ALPHA]: 3\n});","/*\n * speedy-vision.js\n * GPU-accelerated Computer Vision for JavaScript\n * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * utils.js\n * Generic utilities\n */\n\nimport { IllegalArgumentError, ParseError, AssertionError } from './errors'\n\n/**\n * Generic utilities\n */\nexport class Utils\n{\n    /**\n     * Generates a warning\n     * @param {string} text message text\n     * @param  {...string} [args] optional text\n     * @returns {string} the message text\n     */\n    static warning(text, ...args)\n    {\n        const message = [ text, ...args ].join(' ');\n        console.warn('[speedy-vision.js]', message);\n        return message;\n    }\n\n    /**\n     * Logs a message\n     * @param {string} text message text\n     * @param  {...string} [args] optional text\n     * @returns {string} the message text\n     */\n    static log(text, ...args)\n    {\n        const message = [ text, ...args ].join(' ');\n        if(__SPEEDY_DEVELOPMENT_MODE__)\n            console.log('[speedy-vision.js]', message);\n        return message;\n    }\n\n    /**\n     * Assertion\n     * @param {boolean} expr expression\n     * @param {string} [text] error message\n     * @throws {AssertionError}\n     */\n    static assert(expr, text = '')\n    {\n        if(!expr)\n            throw new AssertionError(text);\n    }\n\n    /**\n     * Generates an enumeration\n     * @param {...string} values enumeration options\n     * @returns {object} enum object\n     */\n    static enum(...values)\n    {\n        return Object.freeze(\n            values.reduce((acc, cur) => ((acc[cur] = Symbol(cur)), acc), { })\n        );\n    }\n\n    /**\n     * Similar to setTimeout(fn, 0), but without the ~4ms delay.\n     * Although much faster than setTimeout, this may be resource-hungry\n     * (heavy on battery) if used in a loop. Use with caution.\n     * Implementation based on David Baron's, but adapted for ES6 classes\n     * @param {Function} fn\n     */\n    //static setZeroTimeout(fn) { setTimeout(fn, 0); } // easier on the CPU\n    static setZeroTimeout(fn)\n    {\n        const ctx = (Utils._setZeroTimeoutContext = Utils._setZeroTimeoutContext || (Utils._setZeroTimeoutContext = {\n            callbacks: new Map(),\n            _setup: window.addEventListener('message', ev => {\n                if(ev.source === window) {\n                    const ctx = Utils._setZeroTimeoutContext;\n                    const msgId = ev.data;\n                    const fn = ctx.callbacks.get(msgId);\n                    if(fn !== undefined) {\n                        ev.stopPropagation();\n                        fn.call(window);\n                        ctx.callbacks.delete(msgId);\n                    }\n                }\n            }, true)\n        }));\n\n        const msgId = '0%' + Math.random();\n        ctx.callbacks.set(msgId, fn);\n        window.postMessage(msgId, '*');\n    }\n\n    /**\n     * Gets the names of the arguments of the specified function\n     * @param {Function} fun \n     * @returns {Array<string>}\n     */\n    static functionArguments(fun)\n    {\n        const code = fun.toString();\n        const regex = code.startsWith('function') ? 'function\\\\s.*\\\\(([^)]*)\\\\)' :\n                     (code.startsWith('(') ? '\\\\(([^)]*)\\\\).*=>' : '([^=]+).*=>');\n        const match = new RegExp(regex).exec(code);\n\n        if(match !== null) {\n            const args = match[1].replace(/\\/\\*.*?\\*\\//g, ''); // remove comments\n            return args.split(',').map(argname =>\n                argname.replace(/=.*$/, '').trim() // remove default params & trim\n            ).filter(argname =>\n                argname // handle trailing commas\n            );\n        }\n        else\n            throw new ParseError(`Can't detect function arguments of ${code}`);\n\n        return [];\n    }\n\n    /**\n     * Get all property descriptors from an object,\n     * traversing its entire prototype chain\n     * @param {object} obj \n     * @returns {object}\n     */\n    static getAllPropertyDescriptors(obj)\n    {\n        if(obj) {\n            const proto = Object.getPrototypeOf(obj);\n\n            return {\n                ...(Utils.getAllPropertyDescriptors(proto)),\n                ...Object.getOwnPropertyDescriptors(obj)\n            };\n        }\n        else\n            return Object.create(null);\n    }\n\n    /**\n     * Are we in a little-endian platform?\n     * @returns {boolean}\n     */\n    static isLittleEndian()\n    {\n        if(Utils._isLittleEndian !== undefined)\n            return Utils._isLittleEndian;\n\n        const buf = new ArrayBuffer(2);\n        const u8 = new Uint8Array(buf);\n        const u16 = new Uint16Array(buf);\n\n        u8[1] = 0xCA; u8[0] = 0xFE;\n\n        return Utils._isLittleEndian = (u16[0] == 0xCAFE);\n    }\n\n    /**\n     * Creates a <canvas> element with the given dimensions\n     * @param {number} width in pixels\n     * @param {number} height in pixels\n     * @returns {HTMLCanvasElement}\n     */\n    static createCanvas(width, height)\n    {\n        const canvas = document.createElement('canvas');\n        canvas.width = width;\n        canvas.height = height;\n        return canvas;\n    }\n\n    /**\n     * Generates a random number with\n     * Gaussian distribution (mu, sigma)\n     * @param {number} mu mean\n     * @param {number} sigma standard deviation\n     * @returns {number} random number\n     */\n    static gaussianNoise(mu = 0, sigma = 1)\n    {\n        // Box-Muller transformation\n        const TWO_PI = 2.0 * Math.PI;\n        \n        let a, b = Math.random();\n        do { a = Math.random(); } while(a <= Number.EPSILON);\n        let z = Math.sqrt(-2 * Math.log(a)) * Math.sin(TWO_PI * b);\n\n        return z * sigma + mu;\n    }\n\n    /**\n     * Generate a 1D gaussian kernel with custom sigma\n     * Tip: use kernelSize >= (5 * sigma), kernelSize odd\n     * @param {number} sigma gaussian sigma\n     * @param {number} [kernelSize] kernel size, odd number\n     * @param {bool} [normalized] normalize entries so that their sum is 1\n     */\n    static gaussianKernel(sigma, kernelSize = -1, normalized = true)\n    {\n        /*\n         * Let G(x) be a Gaussian function centered at 0 with fixed sigma:\n         *\n         * G(x) = (1 / (sigma * sqrt(2 * pi))) * exp(-(x / (sqrt(2) * sigma))^2)\n         * \n         * In addition, let f(p) be a kernel value at pixel p, -k/2 <= p <= k/2:\n         * \n         * f(p) = \\int_{p - 0.5}^{p + 0.5} G(x) dx (integrate around p)\n         *      = \\int_{0}^{p + 0.5} G(x) dx - \\int_{0}^{p - 0.5} G(x) dx\n         * \n         * Setting a constant c := sqrt(2) * sigma, it follows that:\n         * \n         * f(p) = (1 / 2c) * (erf((p + 0.5) / c) - erf((p - 0.5) / c))\n         */\n\n        // default kernel size\n        if(kernelSize < 0) {\n            kernelSize = Math.ceil(5.0 * sigma) | 0;\n            kernelSize += 1 - (kernelSize % 2);\n        }\n\n        // validate input\n        kernelSize |= 0;\n        if(kernelSize < 1 || kernelSize % 2 == 0)\n            throw new IllegalArgumentError(`Invalid kernel size given to gaussianKernel: ${kernelSize} x 1`);\n        else if(sigma <= 0.0)\n            throw new IllegalArgumentError(`Invalid sigma given to gaussianKernel: ${sigma}`);\n\n        // function erf(x) = -erf(-x) can be approximated numerically. See:\n        // https://en.wikipedia.org/wiki/Error_function#Numerical_approximations\n        const kernel = new Array(kernelSize);\n\n        // set constants\n        const N  =  kernelSize >> 1; // integer (floor, div 2)\n        const c  =  (+sigma) * 1.4142135623730951; // sigma * sqrt(2)\n        const m  =  0.3275911;\n        const a1 =  0.254829592;\n        const a2 = -0.284496736;\n        const a3 =  1.421413741;\n        const a4 = -1.453152027;\n        const a5 =  1.061405429;\n\n        // compute the kernel\n        let sum = 0.0;\n        for(let j = 0; j < kernelSize; j++) {\n            let xa = (j - N + 0.5) / c;\n            let xb = (j - N - 0.5) / c;\n            let sa = 1.0, sb = 1.0;\n\n            if(xa < 0.0) { sa = -1.0; xa = -xa; }\n            if(xb < 0.0) { sb = -1.0; xb = -xb; }\n\n            const ta = 1.0 / (1.0 + m * xa);\n            const tb = 1.0 / (1.0 + m * xb);\n            const pa = ((((a5 * ta + a4) * ta + a3) * ta + a2) * ta + a1) * ta;\n            const pb = ((((a5 * tb + a4) * tb + a3) * tb + a2) * tb + a1) * tb;\n            const ya = 1.0 - pa * Math.exp(-xa * xa);\n            const yb = 1.0 - pb * Math.exp(-xb * xb);\n\n            const erfa = sa * ya;\n            const erfb = sb * yb;\n            const fp = (erfa - erfb) / (2.0 * c);\n\n            kernel[j] = fp;\n            sum += fp;\n        }\n\n        // done!\n        return normalized ? kernel.map(k => k / sum) : kernel;\n    }\n\n    /**\n     * Cartesian product a x b: [ [ai, bj] for all i, j ]\n     * @param {Array<number>} a\n     * @param {Array<number>} b\n     * @returns {Array<number[2]>}\n     */\n    static cartesian(a, b)\n    {\n        return [].concat(...a.map(a => b.map(b => [a, b])));\n    }\n\n    /**\n     * Symmetric range\n     * @param {number} n non-negative integer\n     * @returns {Array<number>} [ -n, ..., n ]\n     */\n    static symmetricRange(n)\n    {\n        if((n |= 0) < 0)\n            throw new IllegalArgumentError(`Expected a non-negative integer as input`);\n\n        return [...(Array(2*n + 1).keys())].map(x => x - n);\n    }\n\n    /**\n     * Compute the [0, n) range of integers\n     * @param {number} n positive integer\n     * @returns {Array<number>} [ 0, 1, ..., n-1 ]\n     */\n    static range(n)\n    {\n        if((n |= 0) <= 0)\n            throw new IllegalArgumentError(`Expected a positive integer as input`);\n\n        return [...(Array(n).keys())];\n    }\n}"],"sourceRoot":""}