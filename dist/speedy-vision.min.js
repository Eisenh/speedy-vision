/*!
 * speedy-vision.js v0.8.2-wip
 * GPU-accelerated Computer Vision for JavaScript
 * https://github.com/alemart/speedy-vision-js
 * 
 * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com> (https://github.com/alemart)
 * @license Apache-2.0
 * 
 * Date: 2021-10-12T16:57:08.744Z
 */
var Speedy=function(e){var t={};function n(i){if(t[i])return t[i].exports;var o=t[i]={i:i,l:!1,exports:{}};return e[i].call(o.exports,o,o.exports,n),o.l=!0,o.exports}return n.m=e,n.c=t,n.d=function(e,t,i){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:i})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var i=Object.create(null);if(n.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)n.d(i,o,function(t){return e[t]}.bind(null,o));return i},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=19)}([function(e,t,n){"use strict";n.d(t,"h",(function(){return o})),n.d(t,"e",(function(){return s})),n.d(t,"a",(function(){return r})),n.d(t,"f",(function(){return A})),n.d(t,"g",(function(){return a})),n.d(t,"i",(function(){return l})),n.d(t,"d",(function(){return c})),n.d(t,"k",(function(){return d})),n.d(t,"j",(function(){return g})),n.d(t,"c",(function(){return h})),n.d(t,"b",(function(){return u})),n.d(t,"l",(function(){return p}));class i extends Error{constructor(e,t=null){super([e,t?t.toString():"[speedy-vision.js]"].join("\n-> ")),this._cause=t}get name(){return this.constructor.name}set name(e){}get cause(){return this._cause}}class o extends i{constructor(e="",t=null){super("Unsupported operation. "+e,t)}}class s extends i{constructor(e="",t=null){super("WebGL error. "+e,t)}}class r extends i{constructor(e="",t=null){super("Can't call abstract method. "+e,t)}}class A extends i{constructor(e="",t=null){super("Illegal argument. "+e,t)}}class a extends i{constructor(e="",t=null){super("Illegal operation. "+e,t)}}class l extends i{constructor(e="",t=null){super("Out of memory. "+e,t)}}class c extends i{constructor(e="",t=null){super("File not found. "+e,t)}}class d extends i{constructor(e="",t=null){super("Timeout error. "+e,t)}}class g extends i{constructor(e="",t=null){super("Parse error. "+e,t)}}class h extends i{constructor(e="",t=null){super("Assertion failed. "+e,t)}}class u extends i{constructor(e="",t=null){super("Access denied. "+e,t)}}class p extends i{constructor(e="",t=null){super("WebAssembly error. "+e,t)}}},function(e,t,n){"use strict";n.d(t,"a",(function(){return s}));var i=n(0),o=n(3);class s{static warning(e,...t){const n=[e,...t].join(" ");return console.warn("[speedy-vision.js]",n),n}static log(e,...t){return[e,...t].join(" ")}static assert(e,t=""){if(!e)throw new i.c(t)}static enum(...e){return Object.freeze(e.reduce((e,t)=>(e[t]=Symbol(t),e),{}))}static setZeroTimeout(e,...t){const n=s._setZeroTimeoutContext=s._setZeroTimeoutContext||(s._setZeroTimeoutContext={callbacks:new Map,_setup:window.addEventListener("message",e=>{if(e.source===window){const t=s._setZeroTimeoutContext,n=e.data,{fn:i,args:o}=t.callbacks.get(n);void 0!==i&&(e.stopPropagation(),i.apply(window,o),t.callbacks.delete(n))}},!0)}),i="0%"+Math.random();n.callbacks.set(i,{fn:e,args:t}),window.postMessage(i,"*")}static functionArguments(e){const t=e.toString(),n=t.startsWith("function")?"function\\s.*\\(([^)]*)\\)":t.startsWith("(")?"\\(([^)]*)\\).*=>":"([^=]+).*=>",o=new RegExp(n).exec(t);if(null!==o){return o[1].replace(/\/\*.*?\*\//g,"").split(",").map(e=>e.replace(/=.*$/,"").trim()).filter(e=>e)}throw new i.j("Can't detect function arguments of "+t)}static getAllPropertyDescriptors(e){if(e){const t=Object.getPrototypeOf(e);return{...s.getAllPropertyDescriptors(t),...Object.getOwnPropertyDescriptors(e)}}return Object.create(null)}static createCanvas(e,t){const n=document.createElement("canvas");return n.width=e,n.height=t,n}static gaussianNoise(e=0,t=1){const n=2*Math.PI;let i,o=Math.random();do{i=Math.random()}while(i<=Number.EPSILON);return Math.sqrt(-2*Math.log(i))*Math.sin(n*o)*t+e}static gaussianKernel(e,t=0,n=!0){if(0==t&&(t=0|Math.ceil(5*e),t+=1-t%2),(t|=0)<1||t%2==0)throw new i.f(`Invalid kernel size given to gaussianKernel: ${t} x 1`);if(e<=0)throw new i.f("Invalid sigma given to gaussianKernel: "+e);const o=new Array(t),s=t>>1,r=1.4142135623730951*+e,A=.3275911,a=.254829592,l=-.284496736,c=1.421413741,d=-1.453152027,g=1.061405429;let h=0;for(let e=0;e<t;e++){let t=(e-s+.5)/r,n=(e-s-.5)/r,i=1,u=1;t<0&&(i=-1,t=-t),n<0&&(u=-1,n=-n);const p=1/(1+A*t),I=1/(1+A*n),f=((((g*I+d)*I+c)*I+l)*I+a)*I,m=(i*(1-((((g*p+d)*p+c)*p+l)*p+a)*p*Math.exp(-t*t))-u*(1-f*Math.exp(-n*n)))/(2*r);o[e]=m,h+=m}if(n)for(let e=0;e<t;e++)o[e]/=h;return o}static kernel2d(e,t=e){const n=e.length;s.assert(e.length==e.length),s.assert(n>=1&&n%2==1);let i=new Array(n*n),o=0;for(let s=0;s<n;s++)for(let r=0;r<n;r++)i[o++]=e[r]*t[s];return i}static cartesian(e,t){return[].concat(...e.map(e=>t.map(t=>[e,t])))}static symmetricRange(e){if((e|=0)<0)throw new i.f("Expected a non-negative integer as input");return[...Array(2*e+1).keys()].map(t=>t-e)}static range(e){if((e|=0)<=0)throw new i.f("Expected a positive integer as input");return[...Array(e).keys()]}static decodeFloat16(e){const t=(32767&e)>>10,n=1023&e,i=1-2*((65535&e)>>15);return 0==t?0==n?0*i:i*n*5.960464477539063e-8:31==t?0==n?i*Number.POSITIVE_INFINITY:Number.NaN:i*(t>=15?1<<t-15:1/(1<<15-t))*(1+.0009765625*n)}static requestCameraStream(e,t,n={}){if(s.log("Accessing the webcam..."),!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia)throw new i.h("Unsupported browser: no mediaDevices.getUserMedia()");return new o.a((o,r)=>{navigator.mediaDevices.getUserMedia({audio:!1,video:{width:{ideal:e},height:{ideal:t},aspectRatio:e/t,facingMode:"environment",frameRate:30},...n}).then(e=>{const t=document.createElement("video");t.onloadedmetadata=()=>{t.play(),s.log("The camera device is turned on!"),o(t)},t.srcObject=e}).catch(e=>{r(new i.b("Please give access to the camera and reload the page",e))})})}}},function(e,t,n){"use strict";n.d(t,"a",(function(){return g}));var i=n(6),o=n(3),s=n(0),r=n(1);const A=n(69);let a=null,l=null;const c={as:{object:d=new WebAssembly.Memory({initial:16,maximum:256}),uint8:new Uint8Array(d.buffer),int32:new Int32Array(d.buffer),uint32:new Uint32Array(d.buffer),float32:new Float32Array(d.buffer),float64:new Float64Array(d.buffer)}};var d;class g{static ready(){return new o.a((e,t)=>{g._ready(e,t)}).turbocharge()}static imports(e){const t=new h(e);return Object.getOwnPropertyNames(h.prototype).filter(e=>"function"==typeof t[e]&&"constructor"!==e).reduce((e,n)=>(e[n]=t[n],e),Object.create(null))}static allocateMat32(e,t,n){const i=e.exports.malloc(n.data.byteLength);return e.exports.Mat32_create(n.rows,n.columns,n.step0,n.step1,n._data.length,i)}static deallocateMat32(e,t,n){const i=e.exports.Mat32_data(n);return e.exports.free(n),e.exports.free(i),0}static copyToMat32(e,t,n,i){r.a.assert(i.data.byteLength===e.exports.Mat32_dataSize(n));const o=e.exports.Mat32_data(n);return t.as.float32.set(i.data,o/Float32Array.BYTES_PER_ELEMENT),n}static copyFromMat32(e,t,n,i){r.a.assert(i.data.byteLength===e.exports.Mat32_dataSize(n));const o=e.exports.Mat32_data(n)/Float32Array.BYTES_PER_ELEMENT;for(let e=i.data.length-1;e>=0;e--)i.data[e]=t.as.float32[o+e];return n}static _ready(e,t,n=1e3){null!==a&&null!==l?e([a,c,l]):n<=0?t(new s.k("Can't load WASM instance")):setTimeout(g._ready,0,e,t,n-1)}}class h{constructor(e){return Object.getOwnPropertyNames(this.constructor.prototype).filter(e=>"function"==typeof this[e]).filter(e=>"constructor"!==e).forEach(e=>{this[e]=this[e].bind(this)}),this.memory=e,this.cstring=new u(e),Object.freeze(this)}print(e){r.a.log(this.cstring.get(e))}fatal(e){throw new s.l(this.cstring.get(e))}bytefill(e,t,n){this.memory.as.uint8.fill(e,t,n)}copyWithin(e,t,n){this.memory.as.uint8.copyWithin(e,t,n)}}class u{constructor(e){this._decoder=new TextDecoder("utf-8"),this._memory=e}get(e){const t=this._memory.as.uint8,n=this._memory.as.uint8.byteLength;let i=e;for(;i<n&&0!==t[i];)++i;return this._decoder.decode(t.subarray(e,i))}}!function(e){if(!i.LITTLE_ENDIAN)throw new s.h("Can't run WebAssembly code: not in a little-endian machine!");o.a.resolve(A).then(e=>(e=>Uint8Array.from(atob(e),e=>e.charCodeAt(0)))(e)).then(t=>WebAssembly.instantiate(t,{env:{memory:e.as.object,...g.imports(e)}})).then(e=>{a=e.instance,l=e.module,e.instance.exports.srand(.001*Date.now()&4294967295),r.a.log("The WebAssembly code has been loaded!")}).catch(e=>{throw new s.l("Can't load WebAssembly code: "+e,e)})}(c)},function(e,t,n){"use strict";(function(e){n.d(t,"a",(function(){return o}));const i="undefined"!=typeof queueMicrotask&&queueMicrotask||void 0!==e&&e.nextTick||(e=>Promise.resolve().then(e));class o{constructor(e){this._state=0,this._value=void 0,this._onFulfillment=null,this._onRejection=null,this._children=0,this[0]=this,this._parent=void 0,this._flags=0,this._fulfill=this._fulfill.bind(this),this._reject=this._reject.bind(this),this._resolve=this._resolve.bind(this),this._broadcastIfAsync=this._broadcastIfAsync.bind(this),e(this._fulfill,this._reject)}then(e,t=null){const n=new o(this._nop);return n._onFulfillment="function"==typeof e&&e,n._onRejection="function"==typeof t&&t,n._parent=this,this[this._children++]=n,this._flags&=-2,this._notify(),n}catch(e){return this.then(null,e)}finally(e){const t=t=>(e(),t);return this.then(t,t)}turbocharge(){let e=this;for(this._flags|=1;void 0!==e._parent;)e=e._parent,e._flags|=1;return e._notify(),this}toString(){switch(this._state){case 0:return"SpeedyPromise { <pending> }";case 1:return`SpeedyPromise { <fulfilled> ${this._value} }`;case 2:return`SpeedyPromise { <rejected> ${this._value} }`;default:return""}}static resolve(e){const t=new o(this._snop);return"object"==typeof e&&null!==e&&"then"in e||"function"==typeof e&&"then"in e?t._resolve(e):(t._value=e,t._state=1),t}static reject(e){const t=new o(this._snop);return t._value=e,t._state=2,t}static all(e){return new o((t,n)=>{const i=[];for(const t of e)i.push(t);const s=i.length;if(0==s)return void t([]);let r=s;const A=new Array(s),a=e=>n=>{A[e]=n,0==--r&&t(A)};for(let e=0;e<s;e++){const t=i[e];t.__proto__===o.prototype||t.__proto__===Promise.prototype?t.then(a(e),n):o.resolve(t).then(a(e),n)}})}static race(e){return new o((t,n)=>{const i=[];for(const t of e)i.push(t);const s=i.length;for(let e=0;e<s;e++){const s=i[e];s.__proto__===o.prototype||s.__proto__===Promise.prototype?s.then(t,n):o.resolve(s).then(t,n)}})}_fulfill(e){this._setState(1,e)}_reject(e){this._setState(2,e)}_setState(e,t){0==this._state&&(this._state=e,this._value=t,this._notify())}_notify(){0!=this._state&&(1&this._flags?this._broadcast():i(this._broadcastIfAsync))}_broadcastIfAsync(){1&this._flags||this._broadcast()}_broadcast(){const e=this._children,t=this._state;if(1===t)for(let t=0;t<e;t++){const e=this[t],n=e._onFulfillment;try{n?n!==e._nop&&(e._resolve(n(this._value)),e._onFulfillment=e._nop):e._fulfill(this._value)}catch(t){e._reject(t)}}else if(2===t)for(let t=0;t<e;t++){const e=this[t],n=e._onRejection;try{n?n!==e._nop&&(e._resolve(n(this._value)),e._onRejection=e._nop):e._reject(this._value)}catch(t){e._reject(t)}}}_resolve(e){if("object"!=typeof e&&"function"!=typeof e||null===e)this._fulfill(e);else{if(e===this)throw new TypeError;if(e.__proto__!==o.prototype&&e.__proto__!==Promise.prototype)try{const t=e.then;if("function"==typeof t){let n=this._resolve,i=this._reject;try{t.call(e,e=>{n(e),n=i=this._nop},e=>{i(e),n=i=this._nop})}catch(e){n!==this._nop&&i!==this._nop&&this._reject(e)}}else this._fulfill(e)}catch(e){this._reject(e)}else e.then(this._resolve,this._reject)}}_nop(){}static _snop(){}}}).call(this,n(20))},function(e,t,n){"use strict";n.d(t,"b",(function(){return x})),n.d(t,"a",(function(){return _}));var i=n(1),o=n(5),s=n(0);const r=n(6),A=Object.keys(r).filter(e=>"number"==typeof r[e]).reduce((e,t)=>(e[t]=r[t],e),{}),a=Object.freeze({...A,PIXELCOMPONENT_RED:o.e.RED,PIXELCOMPONENT_GREEN:o.e.GREEN,PIXELCOMPONENT_BLUE:o.e.BLUE,PIXELCOMPONENT_ALPHA:o.e.ALPHA}),l=[/\/\*(.|\s)*?\*\//g,/\/\/.*$/gm],c=/^\s*@\s*include\s+"(.*?)"/gm,d=/@(\w+)@/g,g=[/@\s*unroll\s+?for\s*\(\s*(int|)\s*(?<counter>\w+)\s*\=\s*(-?\d+|\w+)\s*;\s*\k<counter>\s*(<=?)\s*(-?\d+|\w+)\s*;\s*\k<counter>\s*\+\+()\s*\)\s*\{\s*([\s\S]+?)\s*\}/g,/@\s*unroll\s+?for\s*\(\s*(int|)\s*(?<counter>\w+)\s*\=\s*(-?\d+|\w+)\s*;\s*\k<counter>\s*(<=?)\s*(-?\d+|\w+)\s*;\s*\k<counter>\s*\+=\s*(-?\d+)\s*\)\s*\{\s*([\s\S]+?)\s*\}/g];class h{static run(e,t=new Map){const n=[];return function(e,t){const n=p.bind(t),i=g.length;for(let t=0;t<i;t++)e=e.replace(g[t],n);return e}(String(e).replace(l[0],"").replace(l[1],"").replace(c,(e,n)=>h.run(u(n),t)).replace(d,(e,i)=>String(void 0!==a[i]?Number(a[i]):t.has(i)?Number(t.get(i)):(n.push("Undefined constant: "+i),0))),t)+(n.length>0?n.map(e=>`\n#error ${e}\n`).join(""):"")}}function u(e){if(String(e).match(/^[a-zA-Z0-9_\-]+\.glsl$/))return n(21)("./"+e);throw new s.d(`Shader preprocessor: can't read file "${e}"`)}function p(e,t,n,o,r,A,a,l){const c=this;if(o=Number.isFinite(+o)?o:c.get(o),A=Number.isFinite(+A)?A:c.get(A),void 0===o||void 0===A){if(c.size>0)throw new s.j(`Can't unroll loop: unknown limits (start=${o}, end=${A}). Code:\n\n${e}`);return e}o=parseInt(o),A=parseInt(A),a=0==a.length?1:parseInt(a),i.a.assert(o<=A&&a>0);let d=null!==l.match(/\bbreak\s*;/)?"switch(1) { default:\n":"{\n";d+=`${t} ${n};\n`,A+="<="==r?1:0;for(let e=o;e<A;e+=a)d+=`{\n${n} = ${e};\n${l}\n}\n`;return d+="}\n",d}const I=Object.freeze({position:"a_position",texCoord:"a_texCoord"}),f=Object.freeze({position:0,texCoord:1}),m=`#version 300 es\nlayout (location=${f.position}) in vec2 ${I.position};\nlayout (location=${f.texCoord}) in vec2 ${I.texCoord};\nout vec2 texCoord;\n\nvoid main() {\n    gl_Position = vec4(${I.position}, 0.0f, 1.0f);\n    texCoord = ${I.texCoord};\n}\n`,C='#version 300 es\nprecision highp int; // int32\nprecision mediump float; // ~float16\nprecision mediump sampler2D;\n\nout vec4 color;\nin vec2 texCoord;\nuniform vec2 texSize;\n\n@include "global.glsl"\n\n';class E{constructor(e){const t=e.filepath||null,i=t?n(22)("./"+t):e.source||"";if(0==i.length)throw new s.f("Can't import shader: empty code");this._userSource=i,this._vertexSource=h.run(m),this._fragmentSource=h.run(C+this._userSource),this._filepath=t||"<in-memory>",this._arguments=[],this._uniforms=this._autodetectUniforms(this._fragmentSource),this._defines=new Map}static create(e){return new E({source:e})}static import(e){if(!String(e).match(/^[a-zA-Z0-9_\-\/]+\.glsl$/))throw new s.d(`Can't import shader: "${e}"`);return new E({filepath:e})}withArguments(...e){if(this._arguments.length>0)throw new s.g("Redefinition of shader arguments");this._arguments=e.map(e=>String(e));for(const e of this._arguments)if(!this._uniforms.has(e)&&!this._uniforms.has(e+"[0]"))throw new s.f(`Argument "${e}" has not been declared in the shader`);return this}withDefines(e){if(this._defines.size>0)throw new s.g("Redefinition of externally defined constants of a shader");const t=[];for(const n of Object.keys(e)){const i=Number(e[n]);this._defines.set(n,i),t.push(`#define ${n} ${i}\n`)}const n=C+t.join("")+this._userSource;return this._fragmentSource=h.run(n,this._defines),this._uniforms=this._autodetectUniforms(this._fragmentSource),this}get fragmentSource(){return this._fragmentSource}get vertexSource(){return this._vertexSource}get attributes(){return I}get locationOfAttributes(){return f}get arguments(){return this._arguments}get uniforms(){return Array.from(this._uniforms.keys())}uniformType(e){if(!this._uniforms.has(e))throw new s.f(`Unrecognized uniform variable: "${e}"`);return this._uniforms.get(e)}definedConstant(e){if(!this._defines.has(e))throw new s.f(`Unrecognized externally defined constant: "${e}"`);return this._defines.get(e)}_autodetectUniforms(e){const t=e,n=/^\s*uniform\s+(highp\s+|mediump\s+|lowp\s+)?(\w+)\s+([^;]+)/gm,i=new Map;let o;for(;null!==(o=n.exec(t));){const e=o[2],t=o[3].split(",").map(e=>e.trim()).filter(e=>e);for(const n of t)if(n.endsWith("]")){if(!(o=n.match(/(\w+)\s*\[\s*(\d+)\s*\]$/)))throw new s.j(`Unspecified array length for uniform "${n}" in the shader`);const[t,r]=[o[1],Number(o[2])];for(let n=0;n<r;n++)i.set(`${t}[${n}]`,e)}else i.set(n,e)}return i}}function x(e){return E.import(e)}function _(e){return E.create(e)}},function(e,t,n){"use strict";n.d(t,"d",(function(){return o})),n.d(t,"c",(function(){return s})),n.d(t,"b",(function(){return r})),n.d(t,"e",(function(){return A})),n.d(t,"a",(function(){return a}));var i=n(1);const o=i.a.enum("Image","Video","Canvas","Bitmap"),s=Object.freeze({RGBA:0,GREY:1}),r=i.a.enum("RGB","Greyscale","Binary"),A=Object.freeze({RED:1,GREEN:2,BLUE:4,ALPHA:8,ALL:15}),a=Object.freeze({[A.RED]:0,[A.GREEN]:1,[A.BLUE]:2,[A.ALPHA]:3})},function(e,t,n){"use strict";n.r(t),n.d(t,"PYRAMID_MAX_LEVELS",(function(){return i})),n.d(t,"PYRAMID_MAX_SCALE",(function(){return o})),n.d(t,"LOG2_PYRAMID_MAX_SCALE",(function(){return s})),n.d(t,"FIX_BITS",(function(){return r})),n.d(t,"FIX_RESOLUTION",(function(){return A})),n.d(t,"MAX_TEXTURE_LENGTH",(function(){return a})),n.d(t,"MIN_KEYPOINT_SIZE",(function(){return l})),n.d(t,"MIN_ENCODER_LENGTH",(function(){return c})),n.d(t,"MAX_ENCODER_CAPACITY",(function(){return d})),n.d(t,"LITTLE_ENDIAN",(function(){return g}));const i=8,o=1,s=Math.log2(o),r=3,A=1<<r,a=(1<<16-r)-2,l=8,c=Math.ceil(Math.sqrt(l/4)),d=8192,g=51966===new Uint16Array(new Uint8Array([254,202]).buffer)[0]},function(e,t,n){"use strict";n.r(t),n.d(t,"conv2D",(function(){return r})),n.d(t,"convX",(function(){return A})),n.d(t,"convY",(function(){return a}));var i=n(4),o=n(1),s=n(0);function r(e,t=1){const n=new Float32Array(e.map(e=>+e*+t)),r=0|Math.sqrt(n.length),A=r>>1;if(r<1||r%2==0)throw new s.f("Can't perform a 2D convolution with an invalid kSize of "+r);if(r*r!=n.length)throw new s.f(`Invalid 2D convolution kernel of ${n.length} elements (expected: square)`);const a=A<=7?"pixelAtShortOffset":"pixelAtLongOffset",l=`\n    uniform sampler2D image;\n\n    void main()\n    {\n        float alpha = threadPixel(image).a;\n        vec4 result = vec4(0.0f);\n\n        ${c=(e,t,n)=>`\n        result += ${a}(image, ivec2(${0|-n}, ${0|-t})) * float(${+e});\n    `,o.a.cartesian(o.a.symmetricRange(A),o.a.symmetricRange(A)).map(e=>c(n[(e[0]+A)*r+(e[1]+A)],e[0],e[1])).join("\n")}\n\n        color = vec4(result.rgb, alpha);\n    }\n    `;var c;return Object(i.a)(l).withArguments("image")}function A(e,t=1){return l("x",e,t)}function a(e,t=1){return l("y",e,t)}function l(e,t,n=1){const r=new Float32Array(t.map(e=>+e*+n)),A=r.length,a=A>>1;if(A<1||A%2==0)throw new s.f("Can't perform a 1D convolution with an invalid kSize of "+A);if("x"!=e&&"y"!=e)throw new s.f(`Can't perform 1D convolution: invalid axis "${e}"`);const l=a<=7?"pixelAtShortOffset":"pixelAtLongOffset",c=`\n    uniform sampler2D image;\n\n    void main()\n    {\n        float alpha = threadPixel(image).a;\n        vec4 pixel = vec4(0.0f);\n\n        ${d=(t,n)=>"x"==e?`\n        pixel += ${l}(image, ivec2(${0|-n}, 0)) * float(${+t});\n    `:`\n        pixel += ${l}(image, ivec2(0, ${0|-n})) * float(${+t});\n    `,o.a.symmetricRange(a).reduce((e,t)=>e+d(r[t+a],t),"")}\n\n        color = vec4(pixel.rgb, alpha);\n    }\n    `;var d;return Object(i.a)(c).withArguments("image")}},function(e,t,n){"use strict";n.d(t,"a",(function(){return A}));n(3);var i=n(2),o=n(1),s=n(0);const r=Object.freeze({float32:Float32Array});class A{constructor(e,t,n){o.a.assert(e>0&&t>0),o.a.assert(n===A.DEFAULT_DTYPE),this._rows=0|e,this._columns=0|t,this._dtype=n}get rows(){return this._rows}get columns(){return this._columns}get dtype(){return this._dtype}static get DEFAULT_DTYPE(){return"float32"}static get BUFFER_TYPE(){return r}plus(e){return new p(this,e)}minus(e){return new I(this,e)}times(e){return"number"==typeof e?new u(this,e):new f(this,e)}transpose(){return new g(this)}inverse(){return new h(this)}compMult(e){return new m(this,e)}toString(){return`SpeedyMatrixExpr(rows=${this.rows}, columns=${this.columns})`}_evaluate(e,t){throw new s.a}}const{SpeedyMatrix:a}=n(9);class l extends A{constructor(e,t,n){super(e,t,n),this._tempMatrix=a.Zeros(this.rows,this.columns,this.dtype)}}class c extends l{constructor(e,t,n){super(e,t,n.dtype),this._operand=n}_evaluate(e,t){const n=this._operand._evaluate(e,t),o=this._tempMatrix,s=i.a.allocateMat32(e,t,o),r=i.a.allocateMat32(e,t,n);return i.a.copyToMat32(e,t,r,n),this._compute(e,t,s,r),i.a.copyFromMat32(e,t,s,o),i.a.deallocateMat32(e,t,r),i.a.deallocateMat32(e,t,s),o}_compute(e,t,n,i){throw new s.a}}class d extends l{constructor(e,t,n,i){o.a.assert(n.dtype===i.dtype),super(e,t,n.dtype),this._left=n,this._right=i}_evaluate(e,t){const n=this._left._evaluate(e,t),o=this._right._evaluate(e,t),s=this._tempMatrix,r=i.a.allocateMat32(e,t,s),A=i.a.allocateMat32(e,t,n),a=i.a.allocateMat32(e,t,o);return i.a.copyToMat32(e,t,A,n),i.a.copyToMat32(e,t,a,o),this._compute(e,t,r,A,a),i.a.copyFromMat32(e,t,r,s),i.a.deallocateMat32(e,t,a),i.a.deallocateMat32(e,t,A),i.a.deallocateMat32(e,t,r),s}_compute(e,t,n,i,o){throw new s.a}}class g extends c{constructor(e){super(e.columns,e.rows,e)}_compute(e,t,n,i){e.exports.Mat32_transpose(n,i)}}class h extends c{constructor(e){o.a.assert(e.rows===e.columns),super(e.rows,e.columns,e),this._size=e.rows}_compute(e,t,n,i){switch(this._size){case 0:break;case 1:e.exports.Mat32_inverse1(n,i);break;case 2:e.exports.Mat32_inverse2(n,i);break;case 3:e.exports.Mat32_inverse3(n,i);break;default:e.exports.Mat32_qr_inverse(n,i)}}}class u extends c{constructor(e,t){super(e.rows,e.columns,e),this._scalar=+t}_compute(e,t,n,i){e.exports.Mat32_scale(n,i,this._scalar)}}class p extends d{constructor(e,t){o.a.assert(e.rows===t.rows&&e.columns===t.columns),super(e.rows,e.columns,e,t)}_compute(e,t,n,i,o){e.exports.Mat32_add(n,i,o)}}class I extends d{constructor(e,t){o.a.assert(e.rows===t.rows&&e.columns===t.columns),super(e.rows,e.columns,e,t)}_compute(e,t,n,i,o){e.exports.Mat32_subtract(n,i,o)}}class f extends d{constructor(e,t){o.a.assert(e.columns===t.rows),super(e.rows,t.columns,e,t)}_compute(e,t,n,i,o){e.exports.Mat32_multiply(n,i,o)}}class m extends d{constructor(e,t){o.a.assert(e.rows===t.rows&&e.columns===t.columns),super(t.rows,t.columns,e,t)}_compute(e,t,n,i,o){e.exports.Mat32_compmult(n,i,o)}}},function(e,t,n){"use strict";n.r(t),n.d(t,"SpeedyMatrix",(function(){return A}));var i=n(8),o=n(2),s=n(3),r=n(1);n(0);class A extends i.a{constructor(e,t,n,o,s){super(e,t,i.a.DEFAULT_DTYPE),r.a.assert(s.constructor===i.a.BUFFER_TYPE[this.dtype]),r.a.assert(n>0&&o>=n),r.a.assert(s.length+e*t===0||s.length===1+n*(e-1)+o*(t-1)),this._step0=0|n,this._step1=0|o,this._data=s}static Create(e,t,n,o=i.a.DEFAULT_DTYPE){return r.a.assert(e*t>0,"Can't create a matrix without a shape"),r.a.assert(e*t===n.length,`Can't create matrix: expected ${e*t} entries, but found ${n.length}`),r.a.assert(Object.prototype.hasOwnProperty.call(i.a.BUFFER_TYPE,o),`Invalid dtype: "${o}"`),new A(e,t,1,e,Reflect.construct(i.a.BUFFER_TYPE[o],[n]))}static Zeros(e,t=e,n=i.a.DEFAULT_DTYPE){return r.a.assert(e*t>0,"Can't create a matrix without a shape"),r.a.assert(Object.prototype.hasOwnProperty.call(i.a.BUFFER_TYPE,n),`Invalid dtype: "${n}"`),new A(e,t,1,e,Reflect.construct(i.a.BUFFER_TYPE[n],[e*t]))}static Ones(e,t=e,n=i.a.DEFAULT_DTYPE){return r.a.assert(e*t>0,"Can't create a matrix without a shape"),r.a.assert(Object.prototype.hasOwnProperty.call(i.a.BUFFER_TYPE,n),`Invalid dtype: "${n}"`),new A(e,t,1,e,Reflect.construct(i.a.BUFFER_TYPE[n],[e*t]).fill(1))}static Eye(e,t=e,n=i.a.DEFAULT_DTYPE){r.a.assert(e*t>0,"Can't create a matrix without a shape"),r.a.assert(Object.prototype.hasOwnProperty.call(i.a.BUFFER_TYPE,n),`Invalid dtype: "${n}"`);const o=Reflect.construct(i.a.BUFFER_TYPE[n],[e*t]);for(let n=Math.min(e,t)-1;n>=0;n--)o[n*e+n]=1;return new A(e,t,1,e,o)}get data(){return this._data}get step0(){return this._step0}get step1(){return this._step1}block(e,t,n,i){r.a.assert(e<=t&&n<=i,`Invalid indices: [${e}:${t},${n}:${i}]`),e=Math.max(e,0),t=Math.min(t,this._rows-1),n=Math.max(n,0);const o=t-e+1,s=(i=Math.min(i,this._columns-1))-n+1,a=this._step0,l=this._step1,c=e*a+n*l,d=1+t*a+i*l;return new A(o,s,a,l,this._data.subarray(c,d))}row(e){return this.block(e,e,0,this._columns-1)}column(e){return this.block(0,this._rows-1,e,e)}diagonal(){const e=Math.min(this._rows,this._columns),t=e,n=this._step0+this._step1,i=1+(e-1)*n;return new A(t,1,n,n,this._data.subarray(0,i))}at(e,t){return e>=0&&e<this._rows&&t>=0&&t<this._columns?this._data[this._step0*e+this._step1*t]:Number.NaN}read(){const e=new Array(this._rows*this._columns),t=this._step0,n=this._step1;let i=0;for(let o=0;o<this._columns;o++)for(let s=0;s<this._rows;s++)e[i++]=this._data[s*t+o*n];return e}toString(){const e=this.rows,t=this.columns,n=this.read(),i=new Array(e);for(let o=0;o<e;o++){i[o]=new Array(t);for(let s=0;s<t;s++)i[o][s]=n[s*e+o]}const o=e=>e.toFixed(5);return`SpeedyMatrix(rows=${e}, columns=${t}, data=[\n${i.map(e=>"    "+e.map(o).join(", ")).join(",\n")}\n])`}setTo(e){return o.a.ready().then(([t,n])=>{const i=e._evaluate(t,n);r.a.assert(this._rows===i._rows&&this._columns===i._columns&&this.dtype===i.dtype,`Can't set the values of a ${this.rows} x ${this.columns} ${this.dtype} matrix to those of a ${i.rows} x ${i.columns} ${i.dtype} matrix`);const o=this._step0,s=this._step1,A=i._step0,a=i._step1;for(let e=this._columns-1;e>=0;e--)for(let t=this._rows-1;t>=0;t--)this._data[t*o+e*s]=i._data[t*A+e*a];return this}).turbocharge()}fill(e){if(e=+e,this._rows*this._columns===this._data.length)return this._data.fill(e),s.a.resolve(this);for(let t=0;t<this._columns;t++)for(let n=0;n<this._rows;n++)this._data[n*this._step0+t*this._step1]=e;return s.a.resolve(this)}_evaluate(e,t){return this}}},function(e,t){e.exports="#ifndef _COLORS_GLSL\n#define _COLORS_GLSL\n#define PIXELCOMPONENT_RED   @PIXELCOMPONENT_RED@\n#define PIXELCOMPONENT_GREEN @PIXELCOMPONENT_GREEN@\n#define PIXELCOMPONENT_BLUE  @PIXELCOMPONENT_BLUE@\n#define PIXELCOMPONENT_ALPHA @PIXELCOMPONENT_ALPHA@\n#endif"},function(e,t){e.exports="#ifndef _FILTERS_GLSL\n#define _FILTERS_GLSL\nfloat laplacian(sampler2D pyramid, vec2 position, float lod)\n{\nfloat pot = exp2(lod);\nivec2 pyrBaseSize = textureSize(pyramid, 0);\nconst vec3 ones = vec3(1.0f);\nconst mat3 kernel = mat3(\n0,-1, 0,\n-1, 4,-1,\n0,-1, 0\n);\n#define LPC(x,y) pyrSubpixelAtExOffset(pyramid, position, lod, pot, ivec2((x),(y)), pyrBaseSize).g\nmat3 neighborhood = mat3(\n0.0f, LPC(0,-1), 0.0f,\nLPC(-1,0), LPC(0,0), LPC(1,0),\n0.0f, LPC(0,1), 0.0f\n);\nmat3 m = matrixCompMult(neighborhood, kernel);\nreturn dot(ones, vec3(\ndot(m[0], ones),\ndot(m[1], ones),\ndot(m[2], ones)\n)) * (1.0f + lod);\n}\n#endif"},function(e,t){e.exports="#ifndef _FIXEDPOINT_GLSL\n#define _FIXEDPOINT_GLSL\n#define fixed_t int\n#define fixed2_t ivec2\nconst int FIX_BITS = int(@FIX_BITS@);\nconst float FIX_RESOLUTION = float(@FIX_RESOLUTION@);\n#define itofix(x) fixed_t((x) << FIX_BITS)\n#define fixtoi(f) int((x) >> FIX_BITS)\n#define ftofix(x) fixed_t((x) * FIX_RESOLUTION + 0.5f)\n#define fixtof(f) (float(f) / FIX_RESOLUTION)\n#define ivec2tofix(x) fixed2_t((x) << FIX_BITS)\n#define fixtoivec2(f) ivec2((f) >> FIX_BITS)\n#define vec2tofix(v) fixed2_t((v) * FIX_RESOLUTION + vec2(0.5f))\n#define fixtovec2(f) (vec2(f) / FIX_RESOLUTION)\n#endif"},function(e,t){e.exports="#ifndef _FLOAT16_GLSL\n#define _FLOAT16_GLSL\n#define encodeFloat16(f) (vec2(packf16(f)) / 255.0f)\n#define decodeFloat16(v) unpackf16(uvec2((v) * 255.0f))\n#define encodePairOfFloat16(f) vec4(encodeFloat16((f).x), encodeFloat16((f).y))\n#define decodePairOfFloat16(v) vec2(decodeFloat16((v).rg), decodeFloat16((v).ba))\n#define encodeNullPairOfFloat16() vec4(1.0f)\n#define encodeDiscardedPairOfFloat16() vec4(0.0f, 1.0f, 0.0f, 1.0f)\n#define isDiscardedPairOfFloat16(v) all(equal((v), encodeDiscardedPairOfFloat16()))\n#define encodeFloat16NaN() vec2(0.5f, 1.0f)\n#define isEncodedFloat16NaN(v) all(equal((v), encodeFloat16NaN()))\nuvec2 packf16( float f)\n{\nuint y = packHalf2x16(vec2(f, 0.0f));\nreturn uvec2(y, y >> 8u) & 0xFFu;\n}\nfloat unpackf16(uvec2 v)\n{\nv &= 0xFFu;\nreturn unpackHalf2x16(v.x | (v.y << 8u)).x;\n}\nbool isEncodedFloat16Zero(vec2 v)\n{\nuvec2 w = uvec2(v * 255.0f);\nreturn 0u == w.x + w.y * (0x80u - w.y);\n}\n#endif"},function(e,t){e.exports="#ifndef _GLOBAL_GLSL\n#define _GLOBAL_GLSL\n#define threadLocation() ivec2(texCoord * texSize)\n#define outputSize() ivec2(texSize)\n#define threadPixel(img) textureLod((img), texCoord, 0.0f)\n#define pixelAt(img, pos) texelFetch((img), (pos), 0)\n#define pixelAtShortOffset(img, offset) textureLodOffset((img), texCoord, 0.0f, (offset))\n#define pixelAtLongOffset(img, offset) textureLod((img), texCoord + vec2(offset) / texSize, 0.0f)\n#endif"},function(e,t){e.exports='#ifndef _KEYPOINTS_GLSL\n#define _KEYPOINTS_GLSL\n@include "math.glsl"\n@include "fixed-point.glsl"\n@include "float16.glsl"\n@include "pyramids.glsl"\nstruct Keypoint\n{\nvec2 position;\nfloat lod;\nfloat orientation;\nfloat score;\nuint flags;\n};\nstruct KeypointAddress\n{\nint base;\nint offset;\n};\nconst int MIN_KEYPOINT_SIZE = int(@MIN_KEYPOINT_SIZE@);\nconst uint KPF_NONE = 0u;\nconst uint KPF_NULL = 1u;\nconst uint KPF_INFINITY = 2u;\n#define encodeKeypointScore(score) encodeFloat16(score)\n#define decodeKeypointScore(encodedScore) decodeFloat16(encodedScore)\n#define encodeKeypointOrientation(angle) ((angle) * INV_PI_OVER_2 + 0.5f)\n#define decodeKeypointOrientation(value) ((value) * TWO_PI - PI)\n#define encodeNullKeypoint() (vec4(1.0f))\n#define encodeDiscardedKeypoint() (vec4(0.0f))\n#define encodeKeypointPositionAtInfinity() (vec4(254, 255, 255, 255) / 255.0f)\n#define isKeypointAtInfinity(keypoint) ((((keypoint).flags) & KPF_INFINITY) != 0u)\n#define isNullKeypoint(keypoint) ((((keypoint).flags) & KPF_NULL) != 0u)\n#define isBadKeypoint(keypoint) ((keypoint).score < 0.0f)\n#define sizeofEncodedKeypoint(descriptorSize, extraSize) (MIN_KEYPOINT_SIZE + (descriptorSize) + (extraSize))\n#define findKeypointIndex(address, descriptorSize, extraSize) ((address).base / ((sizeofEncodedKeypoint((descriptorSize), (extraSize))) / 4))\nvec4 readKeypointData(sampler2D encodedKeypoints, int encoderLength, KeypointAddress address)\n{\nint rasterIndex = address.base + address.offset;\nvec4 data = pixelAt(encodedKeypoints, ivec2(rasterIndex % encoderLength, rasterIndex / encoderLength));\nreturn rasterIndex < encoderLength * encoderLength ? data : encodeNullKeypoint();\n}\nKeypointAddress findKeypointAddress(ivec2 thread, int encoderLength, int descriptorSize, int extraSize)\n{\nint threadRaster = thread.y * encoderLength + thread.x;\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nint keypointIndex = int(threadRaster / pixelsPerKeypoint);\nKeypointAddress address = KeypointAddress(\nkeypointIndex * pixelsPerKeypoint,\nthreadRaster % pixelsPerKeypoint\n);\nreturn address;\n}\nKeypoint decodeKeypoint(sampler2D encodedKeypoints, int encoderLength, KeypointAddress address)\n{\nKeypoint keypoint;\nKeypointAddress positionAddress = KeypointAddress(address.base, 0);\nKeypointAddress propertiesAddress = KeypointAddress(address.base, 1);\nvec4 rawEncodedPosition = readKeypointData(encodedKeypoints, encoderLength, positionAddress);\nivec4 encodedPosition = ivec4(rawEncodedPosition * 255.0f);\nkeypoint.position = fixtovec2(fixed2_t(\nencodedPosition.r | (encodedPosition.g << 8),\nencodedPosition.b | (encodedPosition.a << 8)\n));\nvec4 encodedProperties = readKeypointData(encodedKeypoints, encoderLength, propertiesAddress);\nkeypoint.lod = decodeLod(encodedProperties.r);\nkeypoint.orientation = decodeKeypointOrientation(encodedProperties.g);\nkeypoint.score = decodeKeypointScore(encodedProperties.ba);\nbool isNull = all(equal(rawEncodedPosition, vec4(1)));\nbool isDiscarded = all(equal(rawEncodedPosition + encodedProperties, vec4(0)));\nkeypoint.score = (isNull || isDiscarded) ? -1.0f : keypoint.score;\nkeypoint.flags = KPF_NONE;\nkeypoint.flags |= KPF_NULL * uint(isNull);\nkeypoint.flags |= KPF_INFINITY * uint(all(equal(encodedPosition, ivec4(254, 255, 255, 255))));\nreturn keypoint;\n}\nvec4 encodeKeypointPosition(vec2 position)\n{\nconst vec2 zeros = vec2(0.0f);\nfixed2_t pos = vec2tofix(max(position, zeros));\nfixed2_t lo = pos & 255;\nfixed2_t hi = pos >> 8;\nreturn vec4(lo.x, hi.x, lo.y, hi.y) / 255.0f;\n}\n#endif'},function(e,t){e.exports="#ifndef _MATH_GLSL\n#define _MATH_GLSL\n#define TWO_PI          6.28318530718f\n#define PI              3.14159265359f\n#define PI_OVER_2       1.57079632679f\n#define PI_OVER_4       0.78539816339f\n#define INV_PI          0.3183098861837907f\n#define INV_PI_OVER_2   0.15915494309189535f\nconst highp float INFINITY = 1.0f / 0.0f;\nfloat fastAtan(float x)\n{\nfloat w = 1.0f - abs(x);\nreturn (w >= 0.0f) ? ((PI_OVER_4 + 0.273f * w) * x) :\n(sign(x) * PI_OVER_2 - (PI_OVER_4 + 0.273f * (1.0f - abs(1.0f / x))) / x);\n}\nfloat fastAtan2(float y, float x)\n{\nreturn (x == 0.0f) ? PI_OVER_2 * sign(y) : fastAtan(y / x) + float(x < 0.0f) * PI * sign(y);\n}\n#endif"},function(e,t){e.exports="#ifndef _PYRAMIDS_GLSL\n#define _PYRAMIDS_GLSL\n#define pyrPixel(pyr, lod) textureLod((pyr), texCoord, (lod))\n#define pyrPixelAtOffset(pyr, lod, pot, offset) textureLod((pyr), texCoord + ((pot) * vec2(offset)) / texSize, (lod))\n#define pyrPixelAt(pyr, pos, lod) textureLod((pyr), (vec2(pos) + vec2(0.5f)) / texSize, (lod))\n#define pyrPixelAtEx(pyr, pos, lod, pyrBaseSize) textureLod((pyr), (vec2(pos) + vec2(0.5f)) / vec2(pyrBaseSize), (lod))\n#define pyrSubpixelAtEx(pyr, pos, lod, pyrBaseSize) textureLod((pyr), ((pos) + vec2(0.5f)) / vec2(pyrBaseSize), (lod))\n#define pyrSubpixelAtExOffset(pyr, pos, lod, pot, offset, pyrBaseSize) textureLod((pyr), (((pos) + vec2(0.5f)) + ((pot) * vec2(offset))) / vec2(pyrBaseSize), (lod))\nconst int PYRAMID_MAX_LEVELS = int(@PYRAMID_MAX_LEVELS@);\nconst float F_PYRAMID_MAX_LEVELS = float(@PYRAMID_MAX_LEVELS@);\nconst float LOG2_PYRAMID_MAX_SCALE = float(@LOG2_PYRAMID_MAX_SCALE@);\n#define encodeLod(lod) ((LOG2_PYRAMID_MAX_SCALE + (lod)) / (LOG2_PYRAMID_MAX_SCALE + F_PYRAMID_MAX_LEVELS))\nfloat decodeLod(float encodedLod)\n{\nfloat lod = encodedLod * (LOG2_PYRAMID_MAX_SCALE + F_PYRAMID_MAX_LEVELS) - LOG2_PYRAMID_MAX_SCALE;\nreturn lod - lod * step(1.0f, encodedLod);\n}\n#define LOD_EPS 0.0625f\nconst float ENCODED_LOD_EPS = (LOD_EPS / (LOG2_PYRAMID_MAX_SCALE + F_PYRAMID_MAX_LEVELS));\n#define isSameLod(lod1, lod2) (abs((lod1) - (lod2)) < LOD_EPS)\n#define isSameEncodedLod(alpha1, alpha2) (abs((alpha1) - (alpha2)) < ENCODED_LOD_EPS)\n#endif"},function(e,t){e.exports="#ifndef _SUBPIXEL_GLSL\n#define _SUBPIXEL_GLSL\n#define subpixelAt(image, pos) textureLod((image), ((pos) + vec2(0.5f)) / texSize, 0.0f)\nvec4 subpixelAtBI(sampler2D image, vec2 pos)\n{\nvec2 frc = fract(pos);\nvec2 ifrc = vec2(1.0f) - frc;\nvec2 p = (floor(pos) + vec2(0.5f)) / vec2(textureSize(image, 0));\nvec4 pix00 = textureLod(image, p, 0.0f);\nvec4 pix10 = textureLodOffset(image, p, 0.0f, ivec2(1,0));\nvec4 pix01 = textureLodOffset(image, p, 0.0f, ivec2(0,1));\nvec4 pix11 = textureLodOffset(image, p, 0.0f, ivec2(1,1));\nmat4 pix = mat4(pix00, pix10, pix01, pix11);\nvec4 mul = vec4(ifrc.x * ifrc.y, frc.x * ifrc.y, ifrc.x * frc.y, frc.x * frc.y);\nreturn pix * mul;\n}\n#endif"},function(e,t,n){e.exports=n(70).Speedy},function(e,t){var n,i,o=e.exports={};function s(){throw new Error("setTimeout has not been defined")}function r(){throw new Error("clearTimeout has not been defined")}function A(e){if(n===setTimeout)return setTimeout(e,0);if((n===s||!n)&&setTimeout)return n=setTimeout,setTimeout(e,0);try{return n(e,0)}catch(t){try{return n.call(null,e,0)}catch(t){return n.call(this,e,0)}}}!function(){try{n="function"==typeof setTimeout?setTimeout:s}catch(e){n=s}try{i="function"==typeof clearTimeout?clearTimeout:r}catch(e){i=r}}();var a,l=[],c=!1,d=-1;function g(){c&&a&&(c=!1,a.length?l=a.concat(l):d=-1,l.length&&h())}function h(){if(!c){var e=A(g);c=!0;for(var t=l.length;t;){for(a=l,l=[];++d<t;)a&&a[d].run();d=-1,t=l.length}a=null,c=!1,function(e){if(i===clearTimeout)return clearTimeout(e);if((i===r||!i)&&clearTimeout)return i=clearTimeout,clearTimeout(e);try{i(e)}catch(t){try{return i.call(null,e)}catch(t){return i.call(this,e)}}}(e)}}function u(e,t){this.fun=e,this.array=t}function p(){}o.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)t[n-1]=arguments[n];l.push(new u(e,t)),1!==l.length||c||A(h)},u.prototype.run=function(){this.fun.apply(null,this.array)},o.title="browser",o.browser=!0,o.env={},o.argv=[],o.version="",o.versions={},o.on=p,o.addListener=p,o.once=p,o.off=p,o.removeListener=p,o.removeAllListeners=p,o.emit=p,o.prependListener=p,o.prependOnceListener=p,o.listeners=function(e){return[]},o.binding=function(e){throw new Error("process.binding is not supported")},o.cwd=function(){return"/"},o.chdir=function(e){throw new Error("process.chdir is not supported")},o.umask=function(){return 0}},function(e,t,n){var i={"./colors.glsl":10,"./filters.glsl":11,"./fixed-point.glsl":12,"./float16.glsl":13,"./global.glsl":14,"./keypoints.glsl":15,"./math.glsl":16,"./pyramids.glsl":17,"./subpixel.glsl":18};function o(e){var t=s(e);return n(t)}function s(e){if(!n.o(i,e)){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}return i[e]}o.keys=function(){return Object.keys(i)},o.resolve=s,e.exports=o,o.id=21},function(e,t,n){var i={"./filters/convolution":7,"./filters/convolution.js":7,"./filters/convolution1d.glsl":23,"./filters/convolution2d.glsl":24,"./filters/fast-median.glsl":25,"./filters/nightvision.glsl":26,"./filters/normalize-image.glsl":27,"./filters/rgb2grey.glsl":28,"./include/colors.glsl":10,"./include/filters.glsl":11,"./include/fixed-point.glsl":12,"./include/float16.glsl":13,"./include/global.glsl":14,"./include/keypoints.glsl":15,"./include/math.glsl":16,"./include/pyramids.glsl":17,"./include/subpixel.glsl":18,"./keypoints/allocate-descriptors.glsl":29,"./keypoints/apply-homography.glsl":30,"./keypoints/discard-descriptors.glsl":31,"./keypoints/encode-keypoint-long-offsets.glsl":32,"./keypoints/encode-keypoint-offsets.glsl":33,"./keypoints/encode-keypoint-positions.glsl":34,"./keypoints/encode-keypoint-properties.glsl":35,"./keypoints/encode-null-keypoints.glsl":36,"./keypoints/fast.glsl":37,"./keypoints/harris-cutoff.glsl":38,"./keypoints/harris.glsl":39,"./keypoints/laplacian.glsl":40,"./keypoints/lk.glsl":41,"./keypoints/mix-keypoints.glsl":42,"./keypoints/nonmax-scale.glsl":43,"./keypoints/nonmax-space.glsl":44,"./keypoints/nonmax-suppression.glsl":45,"./keypoints/orb-descriptor.glsl":46,"./keypoints/orb-orientation.glsl":47,"./keypoints/refine-scale.glsl":48,"./keypoints/score-findmax.glsl":49,"./keypoints/sort-applyperm.glsl":50,"./keypoints/sort-createperm.glsl":51,"./keypoints/sort-mergeperm.glsl":52,"./keypoints/subpixel-refinement.glsl":53,"./keypoints/transfer-flow.glsl":54,"./keypoints/transfer-orientation.glsl":55,"./keypoints/upload-keypoints.glsl":56,"./pyramids/downsample2.glsl":57,"./pyramids/upsample2.glsl":58,"./transforms/additive-mix.glsl":59,"./transforms/resize.glsl":60,"./transforms/warp-perspective.glsl":61,"./utils/copy-components.glsl":62,"./utils/fill-components.glsl":63,"./utils/fill.glsl":64,"./utils/flip-y.glsl":65,"./utils/identity.glsl":66,"./utils/scan-minmax2d.glsl":67,"./utils/sobel-derivatives.glsl":68};function o(e){var t=s(e);return n(t)}function s(e){if(!n.o(i,e)){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}return i[e]}o.keys=function(){return Object.keys(i)},o.resolve=s,e.exports=o,o.id=22},function(e,t){e.exports="#if !defined(KERNEL_SIZE) || !defined(AXIS)\n#define Must define KERNEL_SIZE and AXIS\n#endif\nuniform sampler2D image;\nuniform float kernel[@KERNEL_SIZE@];\n#define S(x,y,k) result += pixelAtShortOffset(image, ivec2((x),(y))) * kernel[k]\nvoid main()\n{\nvec4 result = vec4(0.0f);\n#if AXIS == 0 && KERNEL_SIZE == 3\nS(-1, 0, 2);\nS( 0, 0, 1);\nS( 1, 0, 0);\n#elif AXIS == 1 && KERNEL_SIZE == 3\nS( 0,-1, 2);\nS( 0, 0, 1);\nS( 0, 1, 0);\n#elif AXIS == 0 && KERNEL_SIZE == 5\nS(-2, 0, 4);\nS(-1, 0, 3);\nS( 0, 0, 2);\nS( 1, 0, 1);\nS( 2, 0, 0);\n#elif AXIS == 1 && KERNEL_SIZE == 5\nS(0,-2, 4);\nS(0,-1, 3);\nS(0, 0, 2);\nS(0, 1, 1);\nS(0, 2, 0);\n#elif AXIS == 0 && KERNEL_SIZE == 7\nS(-3, 0, 6);\nS(-2, 0, 5);\nS(-1, 0, 4);\nS( 0, 0, 3);\nS( 1, 0, 2);\nS( 2, 0, 1);\nS( 3, 0, 0);\n#elif AXIS == 1 && KERNEL_SIZE == 7\nS(0,-3, 6);\nS(0,-2, 5);\nS(0,-1, 4);\nS(0, 0, 3);\nS(0, 1, 2);\nS(0, 2, 1);\nS(0, 3, 0);\n#elif AXIS == 0 && KERNEL_SIZE == 9\nS(-4, 0, 8);\nS(-3, 0, 7);\nS(-2, 0, 6);\nS(-1, 0, 5);\nS( 0, 0, 4);\nS( 1, 0, 3);\nS( 2, 0, 2);\nS( 3, 0, 1);\nS( 4, 0, 0);\n#elif AXIS == 1 && KERNEL_SIZE == 9\nS(0,-4, 8);\nS(0,-3, 7);\nS(0,-2, 6);\nS(0,-1, 5);\nS(0, 0, 4);\nS(0, 1, 3);\nS(0, 2, 2);\nS(0, 3, 1);\nS(0, 4, 0);\n#elif AXIS == 0 && KERNEL_SIZE == 11\nS(-5, 0, 10);\nS(-4, 0, 9);\nS(-3, 0, 8);\nS(-2, 0, 7);\nS(-1, 0, 6);\nS( 0, 0, 5);\nS( 1, 0, 4);\nS( 2, 0, 3);\nS( 3, 0, 2);\nS( 4, 0, 1);\nS( 5, 0, 0);\n#elif AXIS == 1 && KERNEL_SIZE == 11\nS(0,-5, 10);\nS(0,-4, 9);\nS(0,-3, 8);\nS(0,-2, 7);\nS(0,-1, 6);\nS(0, 0, 5);\nS(0, 1, 4);\nS(0, 2, 3);\nS(0, 3, 2);\nS(0, 4, 1);\nS(0, 5, 0);\n#elif AXIS == 0 && KERNEL_SIZE == 13\nS(-6, 0, 12);\nS(-5, 0, 11);\nS(-4, 0, 10);\nS(-3, 0, 9);\nS(-2, 0, 8);\nS(-1, 0, 7);\nS( 0, 0, 6);\nS( 1, 0, 5);\nS( 2, 0, 4);\nS( 3, 0, 3);\nS( 4, 0, 2);\nS( 5, 0, 1);\nS( 6, 0, 0);\n#elif AXIS == 1 && KERNEL_SIZE == 13\nS(0,-6, 12);\nS(0,-5, 11);\nS(0,-4, 10);\nS(0,-3, 9);\nS(0,-2, 8);\nS(0,-1, 7);\nS(0, 0, 6);\nS(0, 1, 5);\nS(0, 2, 4);\nS(0, 3, 3);\nS(0, 4, 2);\nS(0, 5, 1);\nS(0, 6, 0);\n#elif AXIS == 0 && KERNEL_SIZE == 15\nS(-7, 0, 14);\nS(-6, 0, 13);\nS(-5, 0, 12);\nS(-4, 0, 11);\nS(-3, 0, 10);\nS(-2, 0, 9);\nS(-1, 0, 8);\nS( 0, 0, 7);\nS( 1, 0, 6);\nS( 2, 0, 5);\nS( 3, 0, 4);\nS( 4, 0, 3);\nS( 5, 0, 2);\nS( 6, 0, 1);\nS( 7, 0, 0);\n#elif AXIS == 1 && KERNEL_SIZE == 15\nS(0,-7, 14);\nS(0,-6, 13);\nS(0,-5, 12);\nS(0,-4, 11);\nS(0,-3, 10);\nS(0,-2, 9);\nS(0,-1, 8);\nS(0, 0, 7);\nS(0, 1, 6);\nS(0, 2, 5);\nS(0, 3, 4);\nS(0, 4, 3);\nS(0, 5, 2);\nS(0, 6, 1);\nS(0, 7, 0);\n#else\n#error Invalid parameters\n#endif\ncolor = vec4(result.rgb, 1.0f);\n}"},function(e,t){e.exports="#ifndef KERNEL_SIZE_SQUARED\n#define Must define KERNEL_SIZE_SQUARED\n#endif\nuniform sampler2D image;\nuniform float kernel[@KERNEL_SIZE_SQUARED@];\n#define S(x,y,k) result += pixelAtShortOffset(image, ivec2((x),(y))) * kernel[k]\nvoid main()\n{\nvec4 result = vec4(0.0f);\n#if KERNEL_SIZE_SQUARED == 9\nS(-1,-1, 8);\nS(-1, 0, 7);\nS(-1, 1, 6);\nS( 0,-1, 5);\nS( 0, 0, 4);\nS( 0, 1, 3);\nS( 1,-1, 2);\nS( 1, 0, 1);\nS( 1, 1, 0);\n#elif KERNEL_SIZE_SQUARED == 25\nS(-2,-2, 24);\nS(-2,-1, 23);\nS(-2, 0, 22);\nS(-2, 1, 21);\nS(-2, 2, 20);\nS(-1,-2, 19);\nS(-1,-1, 18);\nS(-1, 0, 17);\nS(-1, 1, 16);\nS(-1, 2, 15);\nS( 0,-2, 14);\nS( 0,-1, 13);\nS( 0, 0, 12);\nS( 0, 1, 11);\nS( 0, 2, 10);\nS( 1,-2, 9);\nS( 1,-1, 8);\nS( 1, 0, 7);\nS( 1, 1, 6);\nS( 1, 2, 5);\nS( 2,-2, 4);\nS( 2,-1, 3);\nS( 2, 0, 2);\nS( 2, 1, 1);\nS( 2, 2, 0);\n#elif KERNEL_SIZE_SQUARED == 49\nS(-3,-3, 48);\nS(-3,-2, 47);\nS(-3,-1, 46);\nS(-3, 0, 45);\nS(-3, 1, 44);\nS(-3, 2, 43);\nS(-3, 3, 42);\nS(-2,-3, 41);\nS(-2,-2, 40);\nS(-2,-1, 39);\nS(-2, 0, 38);\nS(-2, 1, 37);\nS(-2, 2, 36);\nS(-2, 3, 35);\nS(-1,-3, 34);\nS(-1,-2, 33);\nS(-1,-1, 32);\nS(-1, 0, 31);\nS(-1, 1, 30);\nS(-1, 2, 29);\nS(-1, 3, 28);\nS( 0,-3, 27);\nS( 0,-2, 26);\nS( 0,-1, 25);\nS( 0, 0, 24);\nS( 0, 1, 23);\nS( 0, 2, 22);\nS( 0, 3, 21);\nS( 1,-3, 20);\nS( 1,-2, 19);\nS( 1,-1, 18);\nS( 1, 0, 17);\nS( 1, 1, 16);\nS( 1, 2, 15);\nS( 1, 3, 14);\nS( 2,-3, 13);\nS( 2,-2, 12);\nS( 2,-1, 11);\nS( 2, 0, 10);\nS( 2, 1, 9);\nS( 2, 2, 8);\nS( 2, 3, 7);\nS( 3,-3, 6);\nS( 3,-2, 5);\nS( 3,-1, 4);\nS( 3, 0, 3);\nS( 3, 1, 2);\nS( 3, 2, 1);\nS( 3, 3, 0);\n#else\n#error Invalid KERNEL_SIZE_SQUARED\n#endif\ncolor = vec4(result.rgb, 1.0f);\n}"},function(e,t){e.exports="uniform sampler2D image;\n#define X(i,j) t = vec2(min(p[i], p[j]), max(p[i], p[j])); p[i] = t.x; p[j] = t.y;\n#define S(i,x,y) p[i] = pixelAtShortOffset(image, ivec2((x),(y))).g\nvoid main()\n{\nfloat median;\nvec2 t;\n#if !defined(KERNEL_SIZE)\n#error Must define KERNEL_SIZE\n#elif KERNEL_SIZE == 3\nfloat p[9];\nS(0,-1,-1);\nS(1, 0,-1);\nS(2, 1,-1);\nS(3,-1, 0);\nS(4, 0, 0);\nS(5, 1, 0);\nS(6,-1, 1);\nS(7, 0, 1);\nS(8, 1, 1);\nX(1,2);X(4,5);X(7,8);X(0,1);X(3,4);X(6,7);X(1,2);X(4,5);X(7,8);X(0,3);X(5,8);X(4,7);X(3,6);X(1,4);X(2,5);X(4,7);X(4,2);X(6,4);X(4,2);\nmedian = p[4];\n#elif KERNEL_SIZE == 5\nfloat p[25];\nS( 0,-2,-2);\nS( 1,-1,-2);\nS( 2, 0,-2);\nS( 3, 1,-2);\nS( 4, 2,-2);\nS( 5,-2,-1);\nS( 6,-1,-1);\nS( 7, 0,-1);\nS( 8, 1,-1);\nS( 9, 2,-1);\nS(10,-2, 0);\nS(11,-1, 0);\nS(12, 0, 0);\nS(13, 1, 0);\nS(14, 2, 0);\nS(15,-2, 1);\nS(16,-1, 1);\nS(17, 0, 1);\nS(18, 1, 1);\nS(19, 2, 1);\nS(20,-2, 2);\nS(21,-1, 2);\nS(22, 0, 2);\nS(23, 1, 2);\nS(24, 2, 2);\nX(0,1);X(3,4);X(2,4);X(2,3);X(6,7);X(5,7);X(5,6);X(9,10);X(8,10);X(8,9);X(12,13);X(11,13);X(11,12);X(15,16);X(14,16);X(14,15);X(18,19);X(17,19);X(17,18);X(21,22);X(20,22);X(20,21);X(23,24);X(2,5);X(3,6);X(0,6);X(0,3);X(4,7);X(1,7);X(1,4);X(11,14);X(8,14);X(8,11);X(12,15);X(9,15);X(9,12);X(13,16);X(10,16);X(10,13);X(20,23);X(17,23);X(17,20);X(21,24);X(18,24);X(18,21);X(19,22);X(8,17);X(9,18);X(0,18);X(0,9);X(10,19);X(1,19);X(1,10);X(11,20);X(2,20);X(2,11);X(12,21);X(3,21);X(3,12);X(13,22);X(4,22);X(4,13);X(14,23);X(5,23);X(5,14);X(15,24);X(6,24);X(6,15);X(7,16);X(7,19);X(13,21);X(15,23);X(7,13);X(7,15);X(1,9);X(3,11);X(5,17);X(11,17);X(9,17);X(4,10);X(6,12);X(7,14);X(4,6);X(4,7);X(12,14);X(10,14);X(6,7);X(10,12);X(6,10);X(6,17);X(12,17);X(7,17);X(7,10);X(12,18);X(7,12);X(10,18);X(12,20);X(10,20);X(10,12);\nmedian = p[12];\n#elif KERNEL_SIZE == 7\nfloat p[49];\nS( 0,-3,-3);\nS( 1,-2,-3);\nS( 2,-1,-3);\nS( 3, 0,-3);\nS( 4, 1,-3);\nS( 5, 2,-3);\nS( 6, 3,-3);\nS( 7,-3,-2);\nS( 8,-2,-2);\nS( 9,-1,-2);\nS(10, 0,-2);\nS(11, 1,-2);\nS(12, 2,-2);\nS(13, 3,-2);\nS(14,-3,-1);\nS(15,-2,-1);\nS(16,-1,-1);\nS(17, 0,-1);\nS(18, 1,-1);\nS(19, 2,-1);\nS(20, 3,-1);\nS(21,-3, 0);\nS(22,-2, 0);\nS(23,-1, 0);\nS(24, 0, 0);\nS(25, 1, 0);\nS(26, 2, 0);\nS(27, 3, 0);\nS(28,-3, 1);\nS(29,-2, 1);\nS(30,-1, 1);\nS(31, 0, 1);\nS(32, 1, 1);\nS(33, 2, 1);\nS(34, 3, 1);\nS(35,-3, 2);\nS(36,-2, 2);\nS(37,-1, 2);\nS(38, 0, 2);\nS(39, 1, 2);\nS(40, 2, 2);\nS(41, 3, 2);\nS(42,-3, 3);\nS(43,-2, 3);\nS(44,-1, 3);\nS(45, 0, 3);\nS(46, 1, 3);\nS(47, 2, 3);\nS(48, 3, 3);\nX(0,1);X(2,3);X(0,2);X(1,3);X(1,2);X(4,5);X(6,7);X(4,6);X(5,7);X(5,6);X(0,4);X(2,6);X(2,4);X(1,5);X(3,7);X(3,5);X(1,2);X(3,4);X(5,6);X(8,9);X(10,11);X(8,10);X(9,11);X(9,10);X(12,13);X(14,15);X(12,14);X(13,15);X(13,14);X(8,12);X(10,14);X(10,12);X(9,13);X(11,15);X(11,13);X(9,10);X(11,12);X(13,14);X(0,8);X(4,12);X(4,8);X(2,10);X(6,14);X(6,10);X(2,4);X(6,8);X(10,12);X(1,9);X(5,13);X(5,9);X(3,11);X(7,15);X(7,11);X(3,5);X(7,9);X(11,13);X(1,2);X(3,4);X(5,6);X(7,8);X(9,10);X(11,12);X(13,14);X(16,17);X(18,19);X(16,18);X(17,19);X(17,18);X(20,21);X(22,23);X(20,22);X(21,23);X(21,22);X(16,20);X(18,22);X(18,20);X(17,21);X(19,23);X(19,21);X(17,18);X(19,20);X(21,22);X(24,25);X(26,27);X(24,26);X(25,27);X(25,26);X(28,29);X(30,31);X(28,30);X(29,31);X(29,30);X(24,28);X(26,30);X(26,28);X(25,29);X(27,31);X(27,29);X(25,26);X(27,28);X(29,30);X(16,24);X(20,28);X(20,24);X(18,26);X(22,30);X(22,26);X(18,20);X(22,24);X(26,28);X(17,25);X(21,29);X(21,25);X(19,27);X(23,31);X(23,27);X(19,21);X(23,25);X(27,29);X(17,18);X(19,20);X(21,22);X(23,24);X(25,26);X(27,28);X(29,30);X(0,16);X(8,24);X(8,16);X(4,20);X(12,28);X(12,20);X(4,8);X(12,16);X(20,24);X(2,18);X(10,26);X(10,18);X(6,22);X(14,30);X(14,22);X(6,10);X(14,18);X(22,26);X(2,4);X(6,8);X(10,12);X(14,16);X(18,20);X(22,24);X(26,28);X(1,17);X(9,25);X(9,17);X(5,21);X(13,29);X(13,21);X(5,9);X(13,17);X(21,25);X(3,19);X(11,27);X(11,19);X(7,23);X(15,31);X(15,23);X(7,11);X(15,19);X(23,27);X(3,5);X(7,9);X(11,13);X(15,17);X(19,21);X(23,25);X(27,29);X(1,2);X(3,4);X(5,6);X(7,8);X(9,10);X(11,12);X(13,14);X(15,16);X(17,18);X(19,20);X(21,22);X(23,24);X(25,26);X(27,28);X(29,30);X(32,33);X(34,35);X(32,34);X(33,35);X(33,34);X(36,37);X(38,39);X(36,38);X(37,39);X(37,38);X(32,36);X(34,38);X(34,36);X(33,37);X(35,39);X(35,37);X(33,34);X(35,36);X(37,38);X(40,41);X(42,43);X(40,42);X(41,43);X(41,42);X(44,45);X(46,47);X(44,46);X(45,47);X(45,46);X(40,44);X(42,46);X(42,44);X(41,45);X(43,47);X(43,45);X(41,42);X(43,44);X(45,46);X(32,40);X(36,44);X(36,40);X(34,42);X(38,46);X(38,42);X(34,36);X(38,40);X(42,44);X(33,41);X(37,45);X(37,41);X(35,43);X(39,47);X(39,43);X(35,37);X(39,41);X(43,45);X(33,34);X(35,36);X(37,38);X(39,40);X(41,42);X(43,44);X(45,46);X(32,48);X(40,48);X(36,40);X(44,48);X(38,42);X(34,36);X(38,40);X(42,44);X(46,48);X(37,41);X(39,43);X(35,37);X(39,41);X(43,45);X(33,34);X(35,36);X(37,38);X(39,40);X(41,42);X(43,44);X(45,46);X(47,48);X(0,32);X(16,48);X(16,32);X(8,40);X(24,40);X(8,16);X(24,32);X(40,48);X(4,36);X(20,36);X(12,44);X(28,44);X(12,20);X(28,36);X(4,8);X(12,16);X(20,24);X(28,32);X(36,40);X(44,48);X(2,34);X(18,34);X(10,42);X(26,42);X(10,18);X(26,34);X(6,38);X(22,38);X(14,46);X(30,46);X(14,22);X(30,38);X(6,10);X(14,18);X(22,26);X(30,34);X(38,42);X(2,4);X(6,8);X(10,12);X(14,16);X(18,20);X(22,24);X(26,28);X(30,32);X(34,36);X(38,40);X(42,44);X(46,48);X(1,33);X(17,33);X(9,41);X(25,41);X(9,17);X(25,33);X(5,37);X(21,37);X(13,45);X(29,45);X(13,21);X(29,37);X(5,9);X(13,17);X(21,25);X(29,33);X(37,41);X(3,35);X(19,35);X(11,43);X(27,43);X(11,19);X(27,35);X(7,39);X(23,39);X(15,47);X(31,47);X(15,23);X(31,39);X(7,11);X(15,19);X(23,27);X(31,35);X(39,43);X(3,5);X(7,9);X(11,13);X(15,17);X(19,21);X(23,25);X(27,29);X(31,33);X(35,37);X(39,41);X(43,45);X(1,2);X(3,4);X(5,6);X(7,8);X(9,10);X(11,12);X(13,14);X(15,16);X(17,18);X(19,20);X(21,22);X(23,24);\nmedian = p[24];\n#else\n#error Unsupported kernel size\n#endif\ncolor = vec4(median, median, median, 1.0f);\n}"},function(e,t){e.exports="uniform sampler2D image;\nuniform sampler2D illuminationMap;\nuniform float gain;\nuniform float offset;\nuniform float decay;\n#ifndef GREYSCALE\n#error Must define GREYSCALE\n#endif\n#if GREYSCALE == 0\nconst mat3 rgb2yuv = mat3(\n0.299f, -0.14713f, 0.615f,\n0.587f, -0.28886f, -0.51499f,\n0.114f, 0.436f, -0.10001f\n);\nconst mat3 yuv2rgb = mat3(\n1.0f, 1.0f, 1.0f,\n0.0f, -0.39465f, 2.03211f,\n1.13983f, -0.58060f, 0.0f\n);\n#endif\nconst float eps = 0.0001f;\nconst float sqrt2 = 1.4142135623730951f;\nconst float magic = 20.0f;\nconst vec2 center = vec2(0.5f);\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nvec4 imapPixel = threadPixel(illuminationMap);\nfloat lambda = -sqrt2 * log(max(1.0f - decay, eps));\nfloat dist = length(texCoord - center);\nfloat vgain = gain * exp(-lambda * dist);\nfloat normalizedGain = 2.0f * vgain;\nfloat normalizedOffset = 2.0f * offset - 1.0f;\n#if GREYSCALE != 0\nfloat luma = 1.0 / (1.0 + exp(-normalizedGain * magic * (pixel.g - imapPixel.g)));\nluma = clamp(luma + normalizedOffset, 0.0f, 1.0f);\ncolor = vec4(luma, luma, luma, 1.0f);\n#else\nvec3 yuvPixel = rgb2yuv * pixel.rgb;\nvec3 yuvImapPixel = rgb2yuv * imapPixel.rgb;\nfloat luma = 1.0 / (1.0 + exp(-normalizedGain * magic * (yuvPixel.r - yuvImapPixel.r)));\nluma += normalizedOffset;\nvec3 rgbCorrectedPixel = yuv2rgb * vec3(luma, yuvPixel.gb);\nrgbCorrectedPixel = clamp(rgbCorrectedPixel, 0.0f, 1.0f);\ncolor = vec4(rgbCorrectedPixel, 1.0f);\n#endif\n}"},function(e,t){e.exports="#ifndef GREYSCALE\n#error Must define GREYSCALE\n#endif\n#if GREYSCALE != 0\nuniform sampler2D minmax2d;\n#else\nuniform sampler2D minmax2dRGB[3];\n#endif\nuniform float minValue;\nuniform float maxValue;\nconst float eps = 1.0f / 255.0f;\nvoid main()\n{\nvec2 minmax = clamp(vec2(minValue, maxValue), 0.0f, 255.0f) / 255.0f;\nvec4 newMin = vec4(minmax.x);\nvec4 newRange = vec4(minmax.y - minmax.x);\nvec4 alpha = vec4(1.0f, newMin.x, newRange.x, 1.0f);\n#if GREYSCALE != 0\nvec4 pixel = threadPixel(minmax2d);\nmat4 channel = mat4(pixel, pixel, pixel, alpha);\n#else\nmat4 channel = mat4(\nthreadPixel(minmax2dRGB[0]),\nthreadPixel(minmax2dRGB[1]),\nthreadPixel(minmax2dRGB[2]),\nalpha\n);\n#endif\nvec4 oldMin = vec4(channel[0].g, channel[1].g, channel[2].g, channel[3].g);\nvec4 oldRange = max(vec4(channel[0].b, channel[1].b, channel[2].b, channel[3].b), eps);\nvec4 oldIntensity = vec4(channel[0].a, channel[1].a, channel[2].a, channel[3].a);\nvec4 newIntensity = (oldIntensity - oldMin) * newRange / oldRange + newMin;\ncolor = newIntensity;\n}"},function(e,t){e.exports="const vec4 grey = vec4(0.299f, 0.587f, 0.114f, 0.0f);\nuniform sampler2D image;\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nfloat g = dot(pixel, grey);\ncolor = vec4(g, g, g, 1.0f);\n}"},function(e,t){e.exports='@include "keypoints.glsl"\nuniform sampler2D inputEncodedKeypoints;\nuniform int inputDescriptorSize;\nuniform int inputExtraSize;\nuniform int inputEncoderLength;\nuniform int outputDescriptorSize;\nuniform int outputExtraSize;\nuniform int outputEncoderLength;\nconst vec4 EMPTY_DESCRIPTOR = vec4(0.0f);\nvoid main()\n{\nivec2 thread = threadLocation();\nKeypointAddress myAddress = findKeypointAddress(thread, outputEncoderLength, outputDescriptorSize, outputExtraSize);\nint myIndex = findKeypointIndex(myAddress, outputDescriptorSize, outputExtraSize);\nint headerSize = sizeofEncodedKeypoint(0, 0);\nbool isDescriptor = (myAddress.offset >= (headerSize + outputExtraSize) / 4);\nint addressOffset = myAddress.offset;\nint pixelsPerKeypoint = sizeofEncodedKeypoint(inputDescriptorSize, inputExtraSize) / 4;\nKeypointAddress otherAddress = KeypointAddress(myIndex * pixelsPerKeypoint, addressOffset);\ncolor = isDescriptor ? EMPTY_DESCRIPTOR : readKeypointData(inputEncodedKeypoints, inputEncoderLength, otherAddress);\n}'},function(e,t){e.exports='@include "keypoints.glsl"\nuniform mat3 homography;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nvoid main()\n{\nvec4 pixel = threadPixel(encodedKeypoints);\nivec2 thread = threadLocation();\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\ncolor = pixel;\nif(address.offset != 0)\nreturn;\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\nif(isBadKeypoint(keypoint))\nreturn;\nvec3 pos3 = homography * vec3(keypoint.position, 1.0f);\ncolor = encodeKeypointPosition(pos3.xy / pos3.z);\n}'},function(e,t){e.exports='@include "keypoints.glsl"\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nuniform int newEncoderLength;\nvoid main()\n{\nivec2 thread = threadLocation();\nKeypointAddress myAddress = findKeypointAddress(thread, newEncoderLength, 0, extraSize);\nint myIndex = findKeypointIndex(myAddress, 0, extraSize);\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress otherAddress = KeypointAddress(myIndex * pixelsPerKeypoint, myAddress.offset);\ncolor = readKeypointData(encodedKeypoints, encoderLength, otherAddress);\n}'},function(e,t){e.exports='@include "float16.glsl"\nuniform sampler2D offsetsImage;\nuniform ivec2 imageSize;\n#ifndef MAX_ITERATIONS\n#error Must define MAX_ITERATIONS\n#endif\n#define decodeSkipOffset(pixel) (int((pixel).g * 255.0f) | (int((pixel).a * 255.0f) << 8))\n#define encodeSkipOffset(offset) (vec2((offset) & 255, (offset) >> 8) / 255.0f)\nvoid main()\n{\nvec4 pixel = threadPixel(offsetsImage);\nivec2 thread = threadLocation();\nint rasterIndex = thread.y * imageSize.x + thread.x;\nint offset = decodeSkipOffset(pixel);\nint totalOffset = offset;\nvec2 encodedScore = pixel.rb;\nivec2 pos = thread; int allow = 1;\nfor(int i = 0; i < MAX_ITERATIONS; i++) {\nallow *= int(pos.y < imageSize.y) * int(isEncodedFloat16Zero(pixel.rb));\nrasterIndex += allow * offset;\npos = ivec2(rasterIndex % imageSize.x, rasterIndex / imageSize.x);\npixel = pixelAt(offsetsImage, pos);\noffset = decodeSkipOffset(pixel);\ntotalOffset += allow * offset;\n}\ntotalOffset = min(totalOffset, 65535);\ncolor.rb = encodedScore;\ncolor.ga = encodeSkipOffset(totalOffset);\n}'},function(e,t){e.exports='@include "float16.glsl"\nuniform sampler2D corners;\nuniform ivec2 imageSize;\n#if !defined(MAX_ITERATIONS)\n#error Must define MAX_ITERATIONS\n#elif MAX_ITERATIONS > 255\n#error MAX_ITERATIONS must be less than 256\n#endif\nvoid main()\n{\nvec4 pixel = threadPixel(corners);\nivec2 pos = threadLocation();\nvec2 encodedScore = pixel.rb;\nint offset = 0, allow = 1;\nfor(int i = 0; i < MAX_ITERATIONS; i++) {\nallow *= int(pos.y < imageSize.y) * int(isEncodedFloat16Zero(pixel.rb));\noffset += allow;\npos.x = (pos.x + 1) % imageSize.x;\npos.y += int(pos.x == 0);\npixel = pixelAt(corners, pos);\n}\ncolor.rb = encodedScore;\ncolor.ga = vec2(offset, 0) / 255.0f;\n}'},function(e,t){e.exports='@include "keypoints.glsl"\nuniform sampler2D offsetsImage;\nuniform ivec2 imageSize;\nuniform int passId;\nuniform int numPasses;\nuniform int keypointLimit;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\n#define decodeSkipOffset(pixel) (int((pixel).g * 255.0f) | (int((pixel).a * 255.0f) << 8))\nbool findQthKeypoint(int q, int p, inout ivec2 position, out vec4 pixel)\n{\nint notFirstPass = int(passId > 0);\nposition *= notFirstPass;\np |= -(1 - notFirstPass);\np -= notFirstPass;\nint rasterIndex = position.y * imageSize.x + position.x;\nwhile(position.y < imageSize.y && p != q) {\nposition = ivec2(rasterIndex % imageSize.x, rasterIndex / imageSize.x);\npixel = texelFetch(offsetsImage, position, 0);\np += int(!isEncodedFloat16Zero(pixel.rb));\nrasterIndex += max(1, decodeSkipOffset(pixel));\n}\nreturn (p == q);\n}\nvoid main()\n{\nivec2 thread = threadLocation();\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nint q = findKeypointIndex(address, descriptorSize, extraSize);\ncolor = vec4(0.0f);\nif(address.offset != 0)\nreturn;\ncolor = threadPixel(encodedKeypoints);\nint numPixels = encoderLength * encoderLength;\nint maxKeypoints = numPixels / pixelsPerKeypoint;\nint maxKeypointsPerPass = maxKeypoints / numPasses + int(maxKeypoints % numPasses != 0);\nint targetPassId = q / maxKeypointsPerPass;\nif(passId != targetPassId)\nreturn;\nint lastIndexFromPrevPass = passId * maxKeypointsPerPass - 1;\nKeypointAddress lastAddressFromPrevPass = KeypointAddress(max(0, lastIndexFromPrevPass) * pixelsPerKeypoint, 0);\nKeypoint lastKeypointFromPrevPass = decodeKeypoint(encodedKeypoints, encoderLength, lastAddressFromPrevPass);\nivec2 position = ivec2(lastKeypointFromPrevPass.position);\nvec4 pixel;\ncolor = encodeNullKeypoint();\nif(q >= min(maxKeypoints, keypointLimit) || !findQthKeypoint(q, lastIndexFromPrevPass, position, pixel))\nreturn;\ncolor = encodeKeypointPosition(vec2(position));\n}'},function(e,t){e.exports='@include "keypoints.glsl"\nuniform sampler2D corners;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nvoid main()\n{\nivec2 thread = threadLocation();\nvec4 pixel = threadPixel(encodedKeypoints);\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nint q = findKeypointIndex(address, descriptorSize, extraSize);\ncolor = pixel;\nif(address.offset != 1)\nreturn;\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\nvec4 kpix = pixelAt(corners, ivec2(keypoint.position));\nkeypoint.score = decodeFloat16(kpix.rb);\ncolor.r = kpix.a;\ncolor.g = encodeKeypointOrientation(0.0f);\ncolor.ba = encodeKeypointScore(keypoint.score);\n}'},function(e,t){e.exports='@include "keypoints.glsl"\nvoid main()\n{\ncolor = encodeNullKeypoint();\n}'},function(e,t){e.exports='@include "pyramids.glsl"\n@include "float16.glsl"\nuniform sampler2D corners;\nuniform sampler2D pyramid;\nuniform float lod;\nuniform int threshold;\n#define PIX(x,y) pyrPixelAtOffset(pyramid, lod, pot, ivec2((x),(y))).g\nvoid main()\n{\nfloat pixel = threadPixel(pyramid).g;\nvec4 prev = threadPixel(corners);\nivec2 thread = threadLocation();\nivec2 size = outputSize();\nfloat pot = exp2(lod);\nfloat t = float(clamp(threshold, 0, 255)) / 255.0f;\nfloat ct = pixel + t, c_t = pixel - t;\ncolor = vec4(prev.r, pixel, prev.ba);\n#if !defined(FAST_TYPE)\n#error Must define FAST_TYPE\n#elif FAST_TYPE == 916\nconst ivec4 margin = ivec4(3, 3, 4, 4);\nif(any(lessThan(ivec4(thread, size - thread), margin)))\nreturn;\nfloat p0 = PIX(0,3), p4 = PIX(3,0), p8 = PIX(0,-3), p12 = PIX(-3,0);\nbvec4 brighter = bvec4(p0 > ct, p4 > ct, p8 > ct, p12 > ct);\nbvec4 darker = bvec4(p0 < c_t, p4 < c_t, p8 < c_t, p12 < c_t);\nbvec4 bpairs = bvec4(all(brighter.xy), all(brighter.yz), all(brighter.zw), all(brighter.wx));\nbvec4 dpairs = bvec4(all(darker.xy), all(darker.yz), all(darker.zw), all(darker.wx));\nif(!(any(bpairs) || any(dpairs)))\nreturn;\nfloat p1 = PIX(1,3), p2 = PIX(2,2), p3 = PIX(3,1);\nfloat p5 = PIX(3,-1), p6 = PIX(2,-2), p7 = PIX(1,-3);\nfloat p9 = PIX(-1,-3), p10 = PIX(-2,-2), p11 = PIX(-3,-1);\nfloat p13 = PIX(-3,1), p14 = PIX(-2,2), p15 = PIX(-1,3);\nbool A=(p0>ct),B=(p1>ct),C=(p2>ct),D=(p3>ct),E=(p4>ct),F=(p5>ct),G=(p6>ct),H=(p7>ct),I=(p8>ct),J=(p9>ct),K=(p10>ct),L=(p11>ct),M=(p12>ct),N=(p13>ct),O=(p14>ct),P=(p15>ct),a=(p0<c_t),b=(p1<c_t),c=(p2<c_t),d=(p3<c_t),e=(p4<c_t),f=(p5<c_t),g=(p6<c_t),h=(p7<c_t),i=(p8<c_t),j=(p9<c_t),k=(p10<c_t),l=(p11<c_t),m=(p12<c_t),n=(p13<c_t),o=(p14<c_t),p=(p15<c_t);\nbool isCorner=A&&(B&&(K&&L&&J&&(M&&N&&O&&P||G&&H&&I&&(M&&N&&O||F&&(M&&N||E&&(M||D))))||C&&(K&&L&&M&&(N&&O&&P||G&&H&&I&&J&&(N&&O||F&&(N||E)))||D&&(N&&(L&&M&&(K&&G&&H&&I&&J&&(O||F)||O&&P)||k&&l&&m&&e&&f&&g&&h&&i&&j)||E&&(O&&(M&&N&&(K&&L&&G&&H&&I&&J||P)||k&&l&&m&&n&&f&&g&&h&&i&&j)||F&&(P&&(N&&O||k&&l&&m&&n&&o&&g&&h&&i&&j)||G&&(O&&P||H&&(P||I)||k&&l&&m&&n&&o&&p&&h&&i&&j)||k&&l&&m&&n&&o&&h&&i&&j&&(p||g))||k&&l&&m&&n&&h&&i&&j&&(o&&(p||g)||f&&(o&&p||g)))||k&&l&&m&&h&&i&&j&&(n&&(o&&p||g&&(o||f))||e&&(n&&o&&p||g&&(n&&o||f))))||k&&l&&h&&i&&j&&(m&&(n&&o&&p||g&&(n&&o||f&&(n||e)))||d&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e)))))||k&&h&&i&&j&&(l&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d))))))||K&&I&&J&&(L&&M&&N&&O&&P||G&&H&&(L&&M&&N&&O||F&&(L&&M&&N||E&&(L&&M||D&&(L||C)))))||h&&i&&j&&(b&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c)))))||k&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c)))))))||B&&(H&&I&&J&&(K&&L&&M&&N&&O&&P&&a||G&&(K&&L&&M&&N&&O&&a||F&&(K&&L&&M&&N&&a||E&&(K&&L&&M&&a||D&&(K&&L&&a||C)))))||a&&k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||C&&(K&&H&&I&&J&&(L&&M&&N&&O&&P&&a&&b||G&&(L&&M&&N&&O&&a&&b||F&&(L&&M&&N&&a&&b||E&&(L&&M&&a&&b||D))))||a&&b&&k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d)))))||D&&(K&&L&&H&&I&&J&&(M&&N&&O&&P&&a&&b&&c||G&&(M&&N&&O&&a&&b&&c||F&&(M&&N&&a&&b&&c||E)))||a&&b&&k&&l&&m&&c&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e))))||E&&(K&&L&&M&&H&&I&&J&&(N&&O&&P&&a&&b&&c&&d||G&&(N&&O&&a&&b&&c&&d||F))||a&&b&&l&&m&&n&&c&&d&&(k&&g&&h&&i&&j&&(o||f)||o&&p))||F&&(K&&L&&M&&N&&H&&I&&J&&(O&&P&&a&&b&&c&&d&&e||G)||a&&b&&m&&n&&o&&c&&d&&e&&(k&&l&&g&&h&&i&&j||p))||G&&(K&&L&&M&&N&&O&&H&&I&&J||a&&b&&n&&o&&p&&c&&d&&e&&f)||H&&(K&&L&&M&&N&&O&&P&&I&&J||a&&b&&o&&p&&c&&d&&e&&f&&g)||a&&(b&&(k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(k&&l&&m&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e)))||d&&(l&&m&&n&&(k&&g&&h&&i&&j&&(o||f)||o&&p)||e&&(m&&n&&o&&(k&&l&&g&&h&&i&&j||p)||f&&(n&&o&&p||g&&(o&&p||h&&(p||i)))))))||k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||h&&i&&j&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c&&(b||k))))));\nif(!isCorner)\nreturn;\nmat4 mp = mat4(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15);\nmat4 mct = mp - mat4(ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct);\nmat4 mc_t = mat4(c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t) - mp;\nconst vec4 zeros = vec4(0.0f), ones = vec4(1.0f);\nvec4 bs = max(mct[0], zeros), ds = max(mc_t[0], zeros);\nbs += max(mct[1], zeros);     ds += max(mc_t[1], zeros);\nbs += max(mct[2], zeros);     ds += max(mc_t[2], zeros);\nbs += max(mct[3], zeros);     ds += max(mc_t[3], zeros);\nfloat thisScore = max(dot(bs, ones), dot(ds, ones)) / 16.0f;\nfloat prevScore = decodeFloat16(prev.rb);\nvec3 thisResult = vec3(encodeFloat16(thisScore), encodeLod(lod));\ncolor.rba = thisScore > prevScore ? thisResult : color.rba;\n#else\n#error Unrecognized FAST_TYPE\n#endif\n}'},function(e,t){e.exports='@include "float16.glsl"\nuniform sampler2D corners;\nuniform sampler2D maxScore;\nuniform float quality;\nvoid main()\n{\nvec4 pixel = threadPixel(corners);\nfloat score = decodeFloat16(pixel.rb);\nfloat maxval = decodeFloat16(threadPixel(maxScore).rb);\nfloat threshold = maxval * clamp(quality, 0.0f, 1.0f);\ncolor = pixel;\ncolor.rb = score >= threshold ? color.rb : encodeFloat16(0.0f);\n}'},function(e,t){e.exports='@include "pyramids.glsl"\n@include "float16.glsl"\n@include "filters.glsl"\n#if !defined(WINDOW_SIZE)\n#error Undefined WINDOW_SIZE\n#endif\n#define WINDOW_RADIUS ((WINDOW_SIZE - 1) / 2)\nuniform sampler2D corners;\nuniform sampler2D pyramid;\nuniform sampler2D derivatives;\nuniform float lod;\nuniform float lodStep;\nuniform float gaussian[@WINDOW_SIZE@];\n#define G(x) gaussian[(x) + WINDOW_RADIUS]\n#define W(x,y) (G(x) * G(y))\n#define H(ox,oy) dpix = pixelAtShortOffset(derivatives, ivec2((ox),(oy))); \\\ndf = (1.0f + lod) * decodePairOfFloat16(dpix); \\\nh += vec3(df.x * df.x, df.x * df.y, df.y * df.y) * W((ox),(oy))\nvoid main()\n{\nfloat intensity = 0.0f;\nivec2 thread = threadLocation();\nvec4 pixel = threadPixel(corners);\nvec4 dpix = vec4(0.0f);\nvec2 df = vec2(0.0f);\nvec3 h = vec3(0.0f);\ncolor = pixel;\n#if WINDOW_SIZE == 1\nH(0,0);\n#elif WINDOW_SIZE == 3\nH(-1,-1); H(0,-1); H(1,-1);\nH(-1,0); H(0,0); H(1,0);\nH(-1,1); H(0,1); H(1,1);\n#elif WINDOW_SIZE == 5\nH(-2,-2); H(-1,-2); H(0,-2); H(1,-2); H(2,-2);\nH(-2,-1); H(-1,-1); H(0,-1); H(1,-1); H(2,-1);\nH(-2,0); H(-1,0); H(0,0); H(1,0); H(2,0);\nH(-2,1); H(-1,1); H(0,1); H(1,1); H(2,1);\nH(-2,2); H(-1,2); H(0,2); H(1,2); H(2,2);\n#elif WINDOW_SIZE == 7\nH(-3,-3); H(-2,-3); H(-1,-3); H(0,-3); H(1,-3); H(2,-3); H(3,-3);\nH(-3,-2); H(-2,-2); H(-1,-2); H(0,-2); H(1,-2); H(2,-2); H(3,-2);\nH(-3,-1); H(-2,-1); H(-1,-1); H(0,-1); H(1,-1); H(2,-1); H(3,-1);\nH(-3,0); H(-2,0); H(-1,0); H(0,0); H(1,0); H(2,0); H(3,0);\nH(-3,1); H(-2,1); H(-1,1); H(0,1); H(1,1); H(2,1); H(3,1);\nH(-3,2); H(-2,2); H(-1,2); H(0,2); H(1,2); H(2,2); H(3,2);\nH(-3,3); H(-2,3); H(-1,3); H(0,3); H(1,3); H(2,3); H(3,3);\n#else\n#error Invalid WINDOW_SIZE\n#endif\nfloat response = 0.5f * (h.x + h.z - sqrt((h.x - h.z) * (h.x - h.z) + 4.0f * h.y * h.y));\nresponse /= float(WINDOW_SIZE * WINDOW_SIZE);\nfloat lodPlus = min(float(PYRAMID_MAX_LEVELS - 1), lod + lodStep);\nfloat currentScaleStrength = abs(laplacian(pyramid, vec2(thread), lod));\nfloat previousScaleStrength = abs(laplacian(pyramid, vec2(thread), lodPlus));\nfloat previousResponse = decodeFloat16(pixel.rb);\nvec4 result = vec4(encodeFloat16(response), encodeLod(lod), intensity);\ncolor.rbag = (currentScaleStrength >= previousScaleStrength || previousResponse == 0.0f) ? result : pixel.rbag;\n}'},function(e,t){e.exports='@include "pyramids.glsl"\n@include "float16.glsl"\n@include "filters.glsl"\nuniform sampler2D corners;\nuniform sampler2D pyramid;\nuniform float lodStep;\nuniform float lodOffset;\nvoid main()\n{\nivec2 thread = threadLocation();\nvec4 pixel = threadPixel(corners);\nfloat lod = decodeLod(pixel.a);\nfloat lodMinus = max(0.0f, lod - lodStep + lodOffset);\nfloat lodPlus = min(float(PYRAMID_MAX_LEVELS - 1), lod + lodStep + lodOffset);\nfloat lapMinus = laplacian(pyramid, vec2(thread), lodMinus);\nfloat lapPlus = abs(lodPlus - lodMinus) < 1e-5 ? lapMinus : laplacian(pyramid, vec2(thread), lodPlus);\ncolor = encodePairOfFloat16(vec2(lapMinus, lapPlus));\n}'},function(e,t){e.exports='@include "keypoints.glsl"\n@include "float16.glsl"\nuniform sampler2D nextPyramid;\nuniform sampler2D prevPyramid;\nuniform sampler2D encodedFlow;\nuniform sampler2D prevKeypoints;\nuniform int windowSize;\nuniform int level;\nuniform int depth;\nuniform int numberOfIterations;\nuniform float discardThreshold;\nuniform float epsilon;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\n#ifndef MAX_WINDOW_SIZE\n#error Must define MAX_WINDOW_SIZE\n#endif\n#define NEXT_IMAGE 1\n#define PREV_IMAGE 0\nconst int MAX_WINDOW_SIZE_SQUARED = (MAX_WINDOW_SIZE) * (MAX_WINDOW_SIZE);\nconst int MAX_WINDOW_SIZE_PLUS = (MAX_WINDOW_SIZE) + 2;\nconst int MAX_WINDOW_SIZE_PLUS_SQUARED = MAX_WINDOW_SIZE_PLUS * MAX_WINDOW_SIZE_PLUS;\nconst int DBL_MAX_WINDOW_SIZE_PLUS_SQUARED = 2 * MAX_WINDOW_SIZE_PLUS_SQUARED;\nconst int MAX_WINDOW_RADIUS_PLUS = (MAX_WINDOW_SIZE_PLUS - 1) / 2;\nconst int MAX_WINDOW_RADIUS = ((MAX_WINDOW_SIZE) - 1) / 2;\nconst highp float FLT_SCALE = 9.5367431640625e-7;\nconst highp float FLT_EPSILON = 0.00000011920929f;\n#define windowRadius() ((windowSize - 1) / 2)\nint pixelBuffer[DBL_MAX_WINDOW_SIZE_PLUS_SQUARED];\n#define prevPixel(index) pixelBuffer[(index)]\n#define nextPixel(index) pixelBuffer[MAX_WINDOW_SIZE_PLUS_SQUARED + (index)]\n#define pixelIndex(i, j) (((j) + MAX_WINDOW_RADIUS_PLUS) * MAX_WINDOW_SIZE_PLUS + ((i) + MAX_WINDOW_RADIUS_PLUS))\nivec2 derivBuffer[MAX_WINDOW_SIZE_SQUARED];\n#define derivativesAt(x, y) derivBuffer[((y) + MAX_WINDOW_RADIUS) * MAX_WINDOW_SIZE + ((x) + MAX_WINDOW_RADIUS)]\nvoid readWindow(vec2 center, float lod)\n{\nivec2 pyrBaseSize = textureSize(prevPyramid, 0);\nfloat pot = exp2(lod);\nint r = windowRadius();\nivec2 offset; int idx;\n#define readPixelsAt(ox, oy) offset = ivec2((ox), (oy)); \\\nidx = pixelIndex(offset.x, offset.y); \\\nnextPixel(idx) = int(255.0f * pyrSubpixelAtExOffset(nextPyramid, center, lod, pot, offset, pyrBaseSize).g); \\\nprevPixel(idx) = int(255.0f * pyrSubpixelAtExOffset(prevPyramid, center, lod, pot, offset, pyrBaseSize).g)\nfor(int j = 0; j < windowSize; j++) {\nfor(int i = 0; i < windowSize; i++) {\nreadPixelsAt(i-r, j-r);\n}\n}\nint r1 = r+1;\nfor(int k = 0; k < windowSize; k++) {\nreadPixelsAt(-r1, k-r);\nreadPixelsAt( r1, k-r);\nreadPixelsAt(k-r,-r1);\nreadPixelsAt(k-r, r1);\n}\nreadPixelsAt(-r1,-r1);\nreadPixelsAt( r1,-r1);\nreadPixelsAt(-r1, r1);\nreadPixelsAt( r1, r1);\n}\nivec2 computeDerivatives(int imageCode, ivec2 offset)\n{\nconst mat3 dx = mat3(\n3, 0, -3,\n10, 0, -10,\n3, 0, -3\n);\nconst mat3 dy = mat3(\n3, 10, 3,\n0, 0, 0,\n-3, -10, -3\n);\nint indexOffset = imageCode * MAX_WINDOW_SIZE_PLUS_SQUARED;\nmat3 window = mat3(\npixelBuffer[indexOffset + pixelIndex(offset.x-1, offset.y-1)],\npixelBuffer[indexOffset + pixelIndex(offset.x+0, offset.y-1)],\npixelBuffer[indexOffset + pixelIndex(offset.x+1, offset.y-1)],\npixelBuffer[indexOffset + pixelIndex(offset.x-1, offset.y+0)],\n0.0f,\npixelBuffer[indexOffset + pixelIndex(offset.x+1, offset.y+0)],\npixelBuffer[indexOffset + pixelIndex(offset.x-1, offset.y+1)],\npixelBuffer[indexOffset + pixelIndex(offset.x+0, offset.y+1)],\npixelBuffer[indexOffset + pixelIndex(offset.x+1, offset.y+1)]\n);\nmat3 fx = matrixCompMult(dx, window);\nmat3 fy = matrixCompMult(dy, window);\nconst vec3 ones = vec3(1.0f);\nreturn ivec2(\ndot(fx[0], ones) + dot(fx[1], ones) + dot(fx[2], ones),\ndot(fy[0], ones) + dot(fy[1], ones) + dot(fy[2], ones)\n);\n}\nint readBufferedPixel(int imageCode, ivec2 offset)\n{\nint r = windowRadius();\noffset = clamp(offset, -r, r);\nint indexOffset = imageCode * MAX_WINDOW_SIZE_PLUS_SQUARED;\nreturn pixelBuffer[indexOffset + pixelIndex(offset.x, offset.y)];\n}\nint readBufferedSubpixel(int imageCode, vec2 offset)\n{\nivec2 p = ivec2(floor(offset));\nvec2 frc = fract(offset);\nvec2 ifrc = vec2(1.0f) - frc;\nvec4 pix = vec4(\nreadBufferedPixel(imageCode, p),\nreadBufferedPixel(imageCode, p + ivec2(1,0)),\nreadBufferedPixel(imageCode, p + ivec2(0,1)),\nreadBufferedPixel(imageCode, p + ivec2(1,1))\n);\nvec4 sub = vec4(\nifrc.x * ifrc.y,\nfrc.x * ifrc.y,\nifrc.x * frc.y,\nfrc.x * frc.y\n);\nreturn int(0.5f + dot(sub*pix, vec4(1.0f)));\n}\nvec2 computeMismatch(vec2 pyrGuess, vec2 localGuess)\n{\nint timeDerivative;\nivec2 mismatch = ivec2(0);\nint x, y, r = windowRadius();\nvec2 d = pyrGuess + localGuess;\nfor(int _y = 0; _y < windowSize; _y++) {\nfor(int _x = 0; _x < windowSize; _x++) {\nx = _x - r; y = _y - r;\ntimeDerivative = (\nreadBufferedSubpixel(NEXT_IMAGE, vec2(x, y) + d) -\nreadBufferedPixel(PREV_IMAGE, ivec2(x, y))\n);\nmismatch += derivativesAt(x, y) * timeDerivative;\n}\n}\nreturn vec2(mismatch) * FLT_SCALE;\n}\nbool isInsideImage(vec2 position)\n{\nvec2 imageSize = vec2(textureSize(nextPyramid, 0));\nvec2 border = vec2(windowSize);\nreturn all(bvec4(\ngreaterThanEqual(position, border),\nlessThan(position, imageSize - border)\n));\n}\nvoid main()\n{\nvec4 pixel = threadPixel(encodedFlow);\nivec2 thread = threadLocation();\nfloat windowArea = float(windowSize * windowSize);\nint r = windowRadius();\nint keypointIndex = thread.x + thread.y * outputSize().x;\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress address = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);\nKeypoint keypoint = decodeKeypoint(prevKeypoints, encoderLength, address);\ncolor = encodeNullPairOfFloat16();\nif(isNullKeypoint(keypoint))\nreturn;\ncolor = encodeDiscardedPairOfFloat16();\nif(isBadKeypoint(keypoint))\nreturn;\nvec2 pyrGuess = (level < depth - 1) ? decodePairOfFloat16(pixel) : vec2(0.0f);\npyrGuess *= 2.0f;\nreadWindow(keypoint.position, float(level));\nivec2 derivatives;\nivec3 harris3i = ivec3(0);\nfor(int j = 0; j < windowSize; j++) {\nfor(int i = 0; i < windowSize; i++) {\nderivatives = computeDerivatives(PREV_IMAGE, ivec2(i-r, j-r));\nharris3i += ivec3(\nderivatives.x * derivatives.x,\nderivatives.x * derivatives.y,\nderivatives.y * derivatives.y\n);\nderivativesAt(i-r, j-r) = derivatives;\n}\n}\nhighp vec3 harris = vec3(harris3i) * FLT_SCALE;\nhighp mat2 invHarris = mat2(harris.z, -harris.y, -harris.y, harris.x);\nhighp float det = harris.x * harris.z - harris.y * harris.y;\nhighp float invDet = abs(det) >= FLT_EPSILON ? 1.0f / det : 0.0f;\nhighp float minEigenvalue = 0.5f * ((harris.x + harris.z) - sqrt(\n(harris.x - harris.z) * (harris.x - harris.z) + 4.0f * (harris.y * harris.y)\n));\nint niceNumbers = int(abs(det) >= FLT_EPSILON && minEigenvalue >= discardThreshold * windowArea);\nbool goodKeypoint = (level > 0) || (niceNumbers != 0);\nhighp float eps2 = epsilon * epsilon;\nhighp vec2 mismatch, delta, localGuess = vec2(0.0f);\nfor(int k = 0; k < numberOfIterations; k++) {\nmismatch = niceNumbers != 0 ? computeMismatch(pyrGuess, localGuess) : vec2(0.0f);\ndelta = mismatch * invHarris * invDet;\nniceNumbers *= int(eps2 <= dot(delta, delta));\nlocalGuess += float(niceNumbers) * delta;\n}\nvec2 opticalFlow = pyrGuess + localGuess;\nbool mustDiscard = (level == 0) && any(bvec2(\n!goodKeypoint,\n!isInsideImage(keypoint.position + opticalFlow)\n));\ncolor = !mustDiscard ? encodePairOfFloat16(opticalFlow) : encodeDiscardedPairOfFloat16();\n}'},function(e,t){e.exports='@include "keypoints.glsl"\nuniform sampler2D encodedKeypoints[2];\nuniform int encoderLength[2];\nuniform int encoderCapacity[2];\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int outEncoderLength;\nvoid main()\n{\nivec2 thread = threadLocation();\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress outAddr = findKeypointAddress(thread, outEncoderLength, descriptorSize, extraSize);\nint outIndex = findKeypointIndex(outAddr, descriptorSize, extraSize);\nint encoderIndex = int(outIndex >= encoderCapacity[0]);\nint inIndex = (outIndex - encoderCapacity[0] * encoderIndex);\nKeypointAddress inAddr = KeypointAddress(\ninIndex * pixelsPerKeypoint,\noutAddr.offset\n);\nvec4 data[2] = vec4[2](\nreadKeypointData(encodedKeypoints[0], encoderLength[0], inAddr),\nreadKeypointData(encodedKeypoints[1], encoderLength[1], inAddr)\n);\nbool valid = (inIndex < max(encoderCapacity[0], encoderCapacity[1]));\ncolor = valid ? data[encoderIndex] : encodeNullKeypoint();\n}'},function(e,t){e.exports='@include "pyramids.glsl"\n@include "float16.glsl"\n@include "filters.glsl"\n#if !defined(USE_LAPLACIAN)\n#error Undefined USE_LAPLACIAN\n#endif\nuniform sampler2D corners;\nuniform sampler2D pyramid;\nuniform float lodStep;\n#if USE_LAPLACIAN\nuniform sampler2D pyrLaplacian;\n#endif\nvoid main()\n{\nivec2 thread = threadLocation();\nvec4 pixel = threadPixel(corners);\nfloat score = decodeFloat16(pixel.rb);\nfloat myEncodedLod = pixel.a;\nfloat lod = decodeLod(myEncodedLod);\nfloat lodPlus = lod + lodStep;\nfloat lodMinus = lod - lodStep;\nfloat pot = exp2(lod);\nfloat potPlus = exp2(lodPlus);\nfloat potMinus = exp2(lodMinus);\ncolor = pixel;\nif(score == 0.0f)\nreturn;\n#define P(p,u,v) textureLod(corners, texCoord + (p) * vec2((u),(v)) / texSize, 0.0f)\nvec4 pix[18] = vec4[18](\n#define D(u,v) P(potMinus,(u),(v))\nD(-1,-1), D(0,-1), D(1,-1),\nD(-1,0), D(0,0), D(1,0),\nD(-1,1), D(0,1), D(1,1)\n,\n#define U(u,v) P(potPlus,(u),(v))\nU(-1,-1), U(0,-1), U(1,-1),\nU(-1,0), U(0,0), U(1,0),\nU(-1,1), U(0,1), U(1,1)\n);\nfloat scores[18] = float[18](\n#define C(j) decodeFloat16(pix[j].rb)\nC(0), C(1), C(2),\nC(3), C(4), C(5),\nC(6), C(7), C(8)\n,\nC(9), C(10), C(11),\nC(12), C(13), C(14),\nC(15), C(16), C(17)\n);\nfloat lods[18] = float[18](\n#define E(j) decodeLod(pix[j].a)\nE(0), E(1), E(2),\nE(3), E(4), E(5),\nE(6), E(7), E(8)\n,\nE(9), E(10), E(11),\nE(12), E(13), E(14),\nE(15), E(16), E(17)\n);\n#if USE_LAPLACIAN\n#define L(p,u,v) textureLod(pyrLaplacian, texCoord + (p) * vec2((u),(v)) / texSize, 0.0f)\nmat3 strengths[2] = mat3[2](mat3(\n#define Lm(u,v) abs(decodeFloat16(L(potMinus,(u),(v)).xy))\nLm(-1,-1), Lm(0,-1), Lm(1,-1),\nLm(-1,0), Lm(0,0), Lm(1,0),\nLm(-1,1), Lm(0,1), Lm(1,1)\n), mat3(\n#define Lp(u,v) abs(decodeFloat16(L(potPlus,(u),(v)).zw))\nLp(-1,-1), Lp(0,-1), Lp(1,-1),\nLp(-1,0), Lp(0,0), Lp(1,0),\nLp(-1,1), Lp(0,1), Lp(1,1)\n));\nfloat myStrength = abs(laplacian(pyramid, vec2(thread), lod));\n#else\n#define L(u,v) (((v)+1)*3 + ((u)+1))\nmat3 strengths[2] = mat3[2](mat3(\n#define Lm(u,v) scores[L((u),(v))]\nLm(-1,-1), Lm(0,-1), Lm(1,-1),\nLm(-1,0), Lm(0,0), Lm(1,0),\nLm(-1,1), Lm(0,1), Lm(1,1)\n), mat3(\n#define Lp(u,v) scores[9 + L((u),(v))]\nLp(-1,-1), Lp(0,-1), Lp(1,-1),\nLp(-1,0), Lp(0,0), Lp(1,0),\nLp(-1,1), Lp(0,1), Lp(1,1)\n));\nfloat myStrength = score;\n#endif\n#define B(j,lod) float(isSameLod(lods[j], (lod))) * float(scores[j] > 0.0f)\nmat3 nearLod[2] = mat3[2](mat3(\n#define Bm(j) B((j), lodMinus)\nBm(0), Bm(1), Bm(2),\nBm(3), Bm(4), Bm(5),\nBm(6), Bm(7), Bm(8)\n), mat3(\n#define Bp(j) B((j), lodPlus)\nBp(9), Bp(10), Bp(11),\nBp(12), Bp(13), Bp(14),\nBp(15), Bp(16), Bp(17)\n));\nmat3 upStrengths = matrixCompMult(strengths[1], nearLod[1]);\nmat3 downStrengths = matrixCompMult(strengths[0], nearLod[0]);\nvec3 maxUpStrength3 = max(upStrengths[0], max(upStrengths[1], upStrengths[2]));\nvec3 maxDownStrength3 = max(downStrengths[0], max(downStrengths[1], downStrengths[2]));\nvec3 maxStrength3 = max(maxUpStrength3, maxDownStrength3);\nfloat maxStrength = max(maxStrength3.x, max(maxStrength3.y, maxStrength3.z));\ncolor.rb = encodeFloat16(score * step(maxStrength, myStrength));\n}'},function(e,t){e.exports='@include "pyramids.glsl"\n@include "float16.glsl"\nuniform sampler2D corners;\nvoid main()\n{\nivec2 thread = threadLocation();\nvec4 pixel = threadPixel(corners);\nfloat encodedLod = pixel.a;\nfloat score = decodeFloat16(pixel.rb);\nfloat lod = decodeLod(encodedLod);\nfloat pot = exp2(lod);\ncolor = pixel;\nif(score == 0.0f)\nreturn;\n#if 1\nvec2 gridSize = vec2(pot);\nvec2 gridLocation = floor(mod(texCoord * texSize, gridSize));\nvec2 gridDelta = gridLocation / gridSize - vec2(0.5f);\nfloat gridStep = 1.0f / pot;\nconst float adjustment = 1.25f;\ncolor.rb = encodeFloat16(0.0f);\nif(max(abs(gridDelta.x), abs(gridDelta.y)) > adjustment * gridStep)\nreturn;\n#endif\n#define P(x,y) textureLod(corners, texCoord + pot * vec2((x), (y)) / texSize, 0.0f)\nvec4 pix[9] = vec4[9](\nP(-1,-1), P(0,-1), P(1,-1),\nP(-1,0), pixel, P(1,0),\nP(-1,1), P(0,1), P(1,1)\n);\n#define S(j) decodeFloat16(pix[j].rb)\nmat3 scores = mat3(\nS(0), S(1), S(2),\nS(3), S(4), S(5),\nS(6), S(7), S(8)\n);\n#define B(j) float(isSameLod(decodeLod(pix[j].a), lod))\nmat3 sameLod = mat3(\nB(0), B(1), B(2),\nB(3), B(4), B(5),\nB(6), B(7), B(8)\n);\nmat3 sameLodScores = matrixCompMult(scores, sameLod);\nvec3 maxScore3 = max(sameLodScores[0], max(sameLodScores[1], sameLodScores[2]));\nfloat maxScore = max(maxScore3.x, max(maxScore3.y, maxScore3.z));\ncolor.rb = encodeFloat16(score * step(maxScore, score));\n}'},function(e,t){e.exports='@include "pyramids.glsl"\n@include "float16.glsl"\nuniform sampler2D image;\nuniform float lodStep;\n#if !defined(MULTISCALE)\n#error Must define MULTISCALE\n#elif MULTISCALE != 0\n#define LOD_STEP (lodStep)\n#define USE_MIDDLE_RING\n#else\n#define LOD_STEP (0.0f)\n#endif\n#define PIX(x,y) pixelAtShortOffset(image, ivec2((x),(y)))\n#define L2(v,i) bvec2(isSameEncodedLod(v[i].a, alphaMinus), isSameEncodedLod(v[i].a, alphaPlus))\n#define L3(v,i) bvec3(isSameEncodedLod(v[i].a, alpha), isSameEncodedLod(v[i].a, alphaMinus), isSameEncodedLod(v[i].a, alphaPlus))\n#define S3(v,i) decodeFloat16(v[i].rb) * float(any(L3(v,i)))\n#define S2(v,i) decodeFloat16(v[i].rb) * float(any(L2(v,i)))\n#define P(i) S3(p,i)\n#define Q(i) S2(q,i)\n#define R(i) S2(r,i)\nconst vec4 O = vec4(0.0f);\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nfloat lod = decodeLod(pixel.a);\nfloat score = decodeFloat16(pixel.rb);\ncolor = pixel;\nif(score == 0.0f)\nreturn;\nvec4 p[8] = vec4[8](\nPIX(0,1), PIX(1,1), PIX(1,0), PIX(1,-1),\nPIX(0,-1), PIX(-1,-1), PIX(-1,0), PIX(-1,1)\n);\n#ifdef USE_MIDDLE_RING\nvec4 q[16] = vec4[16](\nPIX(0,2), PIX(1,2), PIX(2,2), PIX(2,1),\nPIX(2,0), PIX(2,-1), PIX(2,-2), PIX(1,-2),\nPIX(0,-2), PIX(-1,-2), PIX(-2,-2), PIX(-2,-1),\nPIX(-2,0), PIX(-2,1), PIX(-2,2), PIX(-1,2)\n);\n#else\nvec4 q[16] = vec4[16](O,O,O,O,O,O,O,O,O,O,O,O,O,O,O,O);\n#endif\n#ifdef USE_OUTER_RING\nvec4 r[16] = vec4[16](\nPIX(0,3), PIX(1,3), PIX(3,1), PIX(3,0),\nPIX(3,-1), PIX(1,-3), PIX(0,-3), PIX(-1,-3),\nPIX(-3,-1), PIX(-3,0), PIX(-3,1), PIX(-1,3),\nPIX(0,4), PIX(4,0), PIX(0,-4), PIX(-4,0)\n);\n#else\nvec4 r[16] = vec4[16](O,O,O,O,O,O,O,O,O,O,O,O,O,O,O,O);\n#endif\nfloat alphaPlus = encodeLod(lod + LOD_STEP);\nfloat alphaMinus = encodeLod(lod - LOD_STEP);\nfloat alpha = encodeLod(lod);\nmat3 innerScore = mat3(\nP(0), P(1), P(2), P(3),\nP(4), P(5), P(6), P(7),\n0.0f);\nmat4 middleScore = mat4(\nQ(0), Q(1), Q(2), Q(3),\nQ(4), Q(5), Q(6), Q(7),\nQ(8), Q(9), Q(10), Q(11),\nQ(12), Q(13), Q(14), Q(15)\n);\nmat4 outerScore = mat4(\nR(0), R(1), R(2), R(3),\nR(4), R(5), R(6), R(7),\nR(8), R(9), R(10), R(11),\nR(12), R(13), R(14), R(15)\n);\nvec3 maxInnerScore3 = max(innerScore[0], max(innerScore[1], innerScore[2]));\nvec4 maxMiddleScore4 = max(max(middleScore[0], middleScore[1]), max(middleScore[2], middleScore[3]));\nvec4 maxOuterScore4 = max(max(outerScore[0], outerScore[1]), max(outerScore[2], outerScore[3]));\nfloat maxInnerScore = max(maxInnerScore3.x, max(maxInnerScore3.y, maxInnerScore3.z));\nfloat maxMiddleScore = max(max(maxMiddleScore4.x, maxMiddleScore4.y), max(maxMiddleScore4.z, maxMiddleScore4.w));\nfloat maxOuterScore = max(max(maxOuterScore4.x, maxOuterScore4.y), max(maxOuterScore4.z, maxOuterScore4.w));\nfloat maxScore = max(maxInnerScore, max(maxMiddleScore, maxOuterScore));\nfloat finalScore = step(maxScore, score) * score;\ncolor.rb = encodeFloat16(finalScore);\n}'},function(e,t){e.exports='@include "keypoints.glsl"\nuniform sampler2D encodedCorners;\nuniform int encoderLength;\nuniform sampler2D pyramid;\nuniform int extraSize;\nconst int descriptorSize = 32;\n#define P(a,b,c,d) ivec4((a),(b),(c),(d))\nconst ivec4 pat31[256] = ivec4[256](\nP(8,-3,9,5),\nP(4,2,7,-12),\nP(-11,9,-8,2),\nP(7,-12,12,-13),\nP(2,-13,2,12),\nP(1,-7,1,6),\nP(-2,-10,-2,-4),\nP(-13,-13,-11,-8),\nP(-13,-3,-12,-9),\nP(10,4,11,9),\nP(-13,-8,-8,-9),\nP(-11,7,-9,12),\nP(7,7,12,6),\nP(-4,-5,-3,0),\nP(-13,2,-12,-3),\nP(-9,0,-7,5),\nP(12,-6,12,-1),\nP(-3,6,-2,12),\nP(-6,-13,-4,-8),\nP(11,-13,12,-8),\nP(4,7,5,1),\nP(5,-3,10,-3),\nP(3,-7,6,12),\nP(-8,-7,-6,-2),\nP(-2,11,-1,-10),\nP(-13,12,-8,10),\nP(-7,3,-5,-3),\nP(-4,2,-3,7),\nP(-10,-12,-6,11),\nP(5,-12,6,-7),\nP(5,-6,7,-1),\nP(1,0,4,-5),\nP(9,11,11,-13),\nP(4,7,4,12),\nP(2,-1,4,4),\nP(-4,-12,-2,7),\nP(-8,-5,-7,-10),\nP(4,11,9,12),\nP(0,-8,1,-13),\nP(-13,-2,-8,2),\nP(-3,-2,-2,3),\nP(-6,9,-4,-9),\nP(8,12,10,7),\nP(0,9,1,3),\nP(7,-5,11,-10),\nP(-13,-6,-11,0),\nP(10,7,12,1),\nP(-6,-3,-6,12),\nP(10,-9,12,-4),\nP(-13,8,-8,-12),\nP(-13,0,-8,-4),\nP(3,3,7,8),\nP(5,7,10,-7),\nP(-1,7,1,-12),\nP(3,-10,5,6),\nP(2,-4,3,-10),\nP(-13,0,-13,5),\nP(-13,-7,-12,12),\nP(-13,3,-11,8),\nP(-7,12,-4,7),\nP(6,-10,12,8),\nP(-9,-1,-7,-6),\nP(-2,-5,0,12),\nP(-12,5,-7,5),\nP(3,-10,8,-13),\nP(-7,-7,-4,5),\nP(-3,-2,-1,-7),\nP(2,9,5,-11),\nP(-11,-13,-5,-13),\nP(-1,6,0,-1),\nP(5,-3,5,2),\nP(-4,-13,-4,12),\nP(-9,-6,-9,6),\nP(-12,-10,-8,-4),\nP(10,2,12,-3),\nP(7,12,12,12),\nP(-7,-13,-6,5),\nP(-4,9,-3,4),\nP(7,-1,12,2),\nP(-7,6,-5,1),\nP(-13,11,-12,5),\nP(-3,7,-2,-6),\nP(7,-8,12,-7),\nP(-13,-7,-11,-12),\nP(1,-3,12,12),\nP(2,-6,3,0),\nP(-4,3,-2,-13),\nP(-1,-13,1,9),\nP(7,1,8,-6),\nP(1,-1,3,12),\nP(9,1,12,6),\nP(-1,-9,-1,3),\nP(-13,-13,-10,5),\nP(7,7,10,12),\nP(12,-5,12,9),\nP(6,3,7,11),\nP(5,-13,6,10),\nP(2,-12,2,3),\nP(3,8,4,-6),\nP(2,6,12,-13),\nP(9,-12,10,3),\nP(-8,4,-7,9),\nP(-11,12,-4,-6),\nP(1,12,2,-8),\nP(6,-9,7,-4),\nP(2,3,3,-2),\nP(6,3,11,0),\nP(3,-3,8,-8),\nP(7,8,9,3),\nP(-11,-5,-6,-4),\nP(-10,11,-5,10),\nP(-5,-8,-3,12),\nP(-10,5,-9,0),\nP(8,-1,12,-6),\nP(4,-6,6,-11),\nP(-10,12,-8,7),\nP(4,-2,6,7),\nP(-2,0,-2,12),\nP(-5,-8,-5,2),\nP(7,-6,10,12),\nP(-9,-13,-8,-8),\nP(-5,-13,-5,-2),\nP(8,-8,9,-13),\nP(-9,-11,-9,0),\nP(1,-8,1,-2),\nP(7,-4,9,1),\nP(-2,1,-1,-4),\nP(11,-6,12,-11),\nP(-12,-9,-6,4),\nP(3,7,7,12),\nP(5,5,10,8),\nP(0,-4,2,8),\nP(-9,12,-5,-13),\nP(0,7,2,12),\nP(-1,2,1,7),\nP(5,11,7,-9),\nP(3,5,6,-8),\nP(-13,-4,-8,9),\nP(-5,9,-3,-3),\nP(-4,-7,-3,-12),\nP(6,5,8,0),\nP(-7,6,-6,12),\nP(-13,6,-5,-2),\nP(1,-10,3,10),\nP(4,1,8,-4),\nP(-2,-2,2,-13),\nP(2,-12,12,12),\nP(-2,-13,0,-6),\nP(4,1,9,3),\nP(-6,-10,-3,-5),\nP(-3,-13,-1,1),\nP(7,5,12,-11),\nP(4,-2,5,-7),\nP(-13,9,-9,-5),\nP(7,1,8,6),\nP(7,-8,7,6),\nP(-7,-4,-7,1),\nP(-8,11,-7,-8),\nP(-13,6,-12,-8),\nP(2,4,3,9),\nP(10,-5,12,3),\nP(-6,-5,-6,7),\nP(8,-3,9,-8),\nP(2,-12,2,8),\nP(-11,-2,-10,3),\nP(-12,-13,-7,-9),\nP(-11,0,-10,-5),\nP(5,-3,11,8),\nP(-2,-13,-1,12),\nP(-1,-8,0,9),\nP(-13,-11,-12,-5),\nP(-10,-2,-10,11),\nP(-3,9,-2,-13),\nP(2,-3,3,2),\nP(-9,-13,-4,0),\nP(-4,6,-3,-10),\nP(-4,12,-2,-7),\nP(-6,-11,-4,9),\nP(6,-3,6,11),\nP(-13,11,-5,5),\nP(11,11,12,6),\nP(7,-5,12,-2),\nP(-1,12,0,7),\nP(-4,-8,-3,-2),\nP(-7,1,-6,7),\nP(-13,-12,-8,-13),\nP(-7,-2,-6,-8),\nP(-8,5,-6,-9),\nP(-5,-1,-4,5),\nP(-13,7,-8,10),\nP(1,5,5,-13),\nP(1,0,10,-13),\nP(9,12,10,-1),\nP(5,-8,10,-9),\nP(-1,11,1,-13),\nP(-9,-3,-6,2),\nP(-1,-10,1,12),\nP(-13,1,-8,-10),\nP(8,-11,10,-6),\nP(2,-13,3,-6),\nP(7,-13,12,-9),\nP(-10,-10,-5,-7),\nP(-10,-8,-8,-13),\nP(4,-6,8,5),\nP(3,12,8,-13),\nP(-4,2,-3,-3),\nP(5,-13,10,-12),\nP(4,-13,5,-1),\nP(-9,9,-4,3),\nP(0,3,3,-9),\nP(-12,1,-6,1),\nP(3,2,4,-8),\nP(-10,-10,-10,9),\nP(8,-13,12,12),\nP(-8,-12,-6,-5),\nP(2,2,3,7),\nP(10,6,11,-8),\nP(6,8,8,-12),\nP(-7,10,-6,5),\nP(-3,-9,-3,9),\nP(-1,-13,-1,5),\nP(-3,-7,-3,4),\nP(-8,-2,-8,3),\nP(4,2,12,12),\nP(2,-5,3,11),\nP(6,-9,11,-13),\nP(3,-1,7,12),\nP(11,-1,12,4),\nP(-3,0,-3,6),\nP(4,-11,4,12),\nP(2,-4,2,1),\nP(-10,-6,-8,1),\nP(-13,7,-11,1),\nP(-13,12,-11,-13),\nP(6,0,11,-13),\nP(0,-1,1,4),\nP(-13,3,-9,-2),\nP(-9,8,-6,-3),\nP(-13,-6,-8,-2),\nP(5,-9,8,10),\nP(2,7,3,-9),\nP(-1,-6,-1,-1),\nP(9,5,11,-2),\nP(11,-3,12,-8),\nP(3,0,3,5),\nP(-1,4,0,10),\nP(3,-6,4,5),\nP(-13,0,-10,5),\nP(5,8,12,11),\nP(8,9,9,-6),\nP(7,-4,8,-12),\nP(-10,4,-10,9),\nP(7,3,12,4),\nP(9,-7,10,-2),\nP(7,0,12,-2),\nP(-1,-6,0,-11)\n);\nvoid getPair(int index, mat2 rot, out vec2 p, out vec2 q)\n{\nivec4 data = pat31[index];\nvec2 op = vec2(data.xy);\nvec2 oq = vec2(data.zw);\np = rot * op;\nq = rot * oq;\n}\nvoid main()\n{\nvec4 pixel = threadPixel(encodedCorners);\nivec2 thread = threadLocation();\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nint descriptorCell = address.offset - sizeofEncodedKeypoint(0, extraSize) / 4;\ncolor = pixel;\nif(descriptorCell < 0)\nreturn;\nKeypoint keypoint = decodeKeypoint(encodedCorners, encoderLength, address);\nif(isBadKeypoint(keypoint))\nreturn;\nfloat degreesOrientation = round(360.0f + degrees(keypoint.orientation));\nfloat orientation = radians(degreesOrientation - mod(degreesOrientation, 12.0f));\nfloat kcos = cos(orientation);\nfloat ksin = sin(orientation);\nmat2 rot = mat2(kcos, ksin, -ksin, kcos);\nfloat pot = exp2(keypoint.lod);\nvec2 imageSize = vec2(textureSize(pyramid, 0));\nint patternStart = 32 * descriptorCell;\nuint test[4] = uint[4](0u, 0u, 0u, 0u);\nfor(int t = 0; t < 4; t++) {\nuint bits = 0u;\nvec2 p, q;\nvec4 a, b;\nint i = t * 8;\n@unroll\nfor(int j = 0; j < 8; j++) {\ngetPair(patternStart + i + j, rot, p, q);\na = pyrPixelAtEx(pyramid, round(keypoint.position + pot * p), keypoint.lod, imageSize);\nb = pyrPixelAtEx(pyramid, round(keypoint.position + pot * q), keypoint.lod, imageSize);\nbits |= uint(a.g < b.g) << j;\n}\ntest[t] = bits;\n}\ncolor = vec4(test[0], test[1], test[2], test[3]) / 255.0f;\n}'},function(e,t){e.exports='@include "keypoints.glsl"\nuniform sampler2D pyramid;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\n#define P(x,y) ivec2((x),(y))\nconst int diskPointCount[16] = int[16](0, 4, 12, 28, 48, 80, 112, 148, 196, 252, 316, 376, 440, 528, 612, 708);\nconst ivec2 diskPoint[708] = ivec2[708](\nP(0,-1),P(-1,0),P(1,0),P(0,1),\nP(-1,-1),P(1,-1),P(-1,1),P(1,1),P(0,-2),P(-2,0),P(2,0),P(0,2),\nP(-1,-2),P(1,-2),P(-2,-1),P(2,-1),P(-2,1),P(2,1),P(-1,2),P(1,2),P(-2,-2),P(2,-2),P(-2,2),P(2,2),P(0,-3),P(-3,0),P(3,0),P(0,3),\nP(-1,-3),P(1,-3),P(-3,-1),P(3,-1),P(-3,1),P(3,1),P(-1,3),P(1,3),P(-2,-3),P(2,-3),P(-3,-2),P(3,-2),P(-3,2),P(3,2),P(-2,3),P(2,3),P(0,-4),P(-4,0),P(4,0),P(0,4),\nP(-1,-4),P(1,-4),P(-4,-1),P(4,-1),P(-4,1),P(4,1),P(-1,4),P(1,4),P(-3,-3),P(3,-3),P(-3,3),P(3,3),P(-2,-4),P(2,-4),P(-4,-2),P(4,-2),P(-4,2),P(4,2),P(-2,4),P(2,4),P(0,-5),P(-3,-4),P(3,-4),P(-4,-3),P(4,-3),P(-5,0),P(5,0),P(-4,3),P(4,3),P(-3,4),P(3,4),P(0,5),\nP(-1,-5),P(1,-5),P(-5,-1),P(5,-1),P(-5,1),P(5,1),P(-1,5),P(1,5),P(-2,-5),P(2,-5),P(-5,-2),P(5,-2),P(-5,2),P(5,2),P(-2,5),P(2,5),P(-4,-4),P(4,-4),P(-4,4),P(4,4),P(-3,-5),P(3,-5),P(-5,-3),P(5,-3),P(-5,3),P(5,3),P(-3,5),P(3,5),P(0,-6),P(-6,0),P(6,0),P(0,6),\nP(-1,-6),P(1,-6),P(-6,-1),P(6,-1),P(-6,1),P(6,1),P(-1,6),P(1,6),P(-2,-6),P(2,-6),P(-6,-2),P(6,-2),P(-6,2),P(6,2),P(-2,6),P(2,6),P(-4,-5),P(4,-5),P(-5,-4),P(5,-4),P(-5,4),P(5,4),P(-4,5),P(4,5),P(-3,-6),P(3,-6),P(-6,-3),P(6,-3),P(-6,3),P(6,3),P(-3,6),P(3,6),P(0,-7),P(-7,0),P(7,0),P(0,7),\nP(-1,-7),P(1,-7),P(-5,-5),P(5,-5),P(-7,-1),P(7,-1),P(-7,1),P(7,1),P(-5,5),P(5,5),P(-1,7),P(1,7),P(-4,-6),P(4,-6),P(-6,-4),P(6,-4),P(-6,4),P(6,4),P(-4,6),P(4,6),P(-2,-7),P(2,-7),P(-7,-2),P(7,-2),P(-7,2),P(7,2),P(-2,7),P(2,7),P(-3,-7),P(3,-7),P(-7,-3),P(7,-3),P(-7,3),P(7,3),P(-3,7),P(3,7),P(-5,-6),P(5,-6),P(-6,-5),P(6,-5),P(-6,5),P(6,5),P(-5,6),P(5,6),P(0,-8),P(-8,0),P(8,0),P(0,8),\nP(-1,-8),P(1,-8),P(-4,-7),P(4,-7),P(-7,-4),P(7,-4),P(-8,-1),P(8,-1),P(-8,1),P(8,1),P(-7,4),P(7,4),P(-4,7),P(4,7),P(-1,8),P(1,8),P(-2,-8),P(2,-8),P(-8,-2),P(8,-2),P(-8,2),P(8,2),P(-2,8),P(2,8),P(-6,-6),P(6,-6),P(-6,6),P(6,6),P(-3,-8),P(3,-8),P(-8,-3),P(8,-3),P(-8,3),P(8,3),P(-3,8),P(3,8),P(-5,-7),P(5,-7),P(-7,-5),P(7,-5),P(-7,5),P(7,5),P(-5,7),P(5,7),P(-4,-8),P(4,-8),P(-8,-4),P(8,-4),P(-8,4),P(8,4),P(-4,8),P(4,8),P(0,-9),P(-9,0),P(9,0),P(0,9),\nP(-1,-9),P(1,-9),P(-9,-1),P(9,-1),P(-9,1),P(9,1),P(-1,9),P(1,9),P(-2,-9),P(2,-9),P(-6,-7),P(6,-7),P(-7,-6),P(7,-6),P(-9,-2),P(9,-2),P(-9,2),P(9,2),P(-7,6),P(7,6),P(-6,7),P(6,7),P(-2,9),P(2,9),P(-5,-8),P(5,-8),P(-8,-5),P(8,-5),P(-8,5),P(8,5),P(-5,8),P(5,8),P(-3,-9),P(3,-9),P(-9,-3),P(9,-3),P(-9,3),P(9,3),P(-3,9),P(3,9),P(-4,-9),P(4,-9),P(-9,-4),P(9,-4),P(-9,4),P(9,4),P(-4,9),P(4,9),P(-7,-7),P(7,-7),P(-7,7),P(7,7),P(0,-10),P(-6,-8),P(6,-8),P(-8,-6),P(8,-6),P(-10,0),P(10,0),P(-8,6),P(8,6),P(-6,8),P(6,8),P(0,10),\nP(-1,-10),P(1,-10),P(-10,-1),P(10,-1),P(-10,1),P(10,1),P(-1,10),P(1,10),P(-2,-10),P(2,-10),P(-10,-2),P(10,-2),P(-10,2),P(10,2),P(-2,10),P(2,10),P(-5,-9),P(5,-9),P(-9,-5),P(9,-5),P(-9,5),P(9,5),P(-5,9),P(5,9),P(-3,-10),P(3,-10),P(-10,-3),P(10,-3),P(-10,3),P(10,3),P(-3,10),P(3,10),P(-7,-8),P(7,-8),P(-8,-7),P(8,-7),P(-8,7),P(8,7),P(-7,8),P(7,8),P(-4,-10),P(4,-10),P(-10,-4),P(10,-4),P(-10,4),P(10,4),P(-4,10),P(4,10),P(-6,-9),P(6,-9),P(-9,-6),P(9,-6),P(-9,6),P(9,6),P(-6,9),P(6,9),P(0,-11),P(-11,0),P(11,0),P(0,11),\nP(-1,-11),P(1,-11),P(-11,-1),P(11,-1),P(-11,1),P(11,1),P(-1,11),P(1,11),P(-2,-11),P(2,-11),P(-5,-10),P(5,-10),P(-10,-5),P(10,-5),P(-11,-2),P(11,-2),P(-11,2),P(11,2),P(-10,5),P(10,5),P(-5,10),P(5,10),P(-2,11),P(2,11),P(-8,-8),P(8,-8),P(-8,8),P(8,8),P(-3,-11),P(3,-11),P(-7,-9),P(7,-9),P(-9,-7),P(9,-7),P(-11,-3),P(11,-3),P(-11,3),P(11,3),P(-9,7),P(9,7),P(-7,9),P(7,9),P(-3,11),P(3,11),P(-6,-10),P(6,-10),P(-10,-6),P(10,-6),P(-10,6),P(10,6),P(-6,10),P(6,10),P(-4,-11),P(4,-11),P(-11,-4),P(11,-4),P(-11,4),P(11,4),P(-4,11),P(4,11),P(0,-12),P(-12,0),P(12,0),P(0,12),\nP(-1,-12),P(1,-12),P(-8,-9),P(8,-9),P(-9,-8),P(9,-8),P(-12,-1),P(12,-1),P(-12,1),P(12,1),P(-9,8),P(9,8),P(-8,9),P(8,9),P(-1,12),P(1,12),P(-5,-11),P(5,-11),P(-11,-5),P(11,-5),P(-11,5),P(11,5),P(-5,11),P(5,11),P(-2,-12),P(2,-12),P(-12,-2),P(12,-2),P(-12,2),P(12,2),P(-2,12),P(2,12),P(-7,-10),P(7,-10),P(-10,-7),P(10,-7),P(-10,7),P(10,7),P(-7,10),P(7,10),P(-3,-12),P(3,-12),P(-12,-3),P(12,-3),P(-12,3),P(12,3),P(-3,12),P(3,12),P(-6,-11),P(6,-11),P(-11,-6),P(11,-6),P(-11,6),P(11,6),P(-6,11),P(6,11),P(-4,-12),P(4,-12),P(-12,-4),P(12,-4),P(-12,4),P(12,4),P(-4,12),P(4,12),P(-9,-9),P(9,-9),P(-9,9),P(9,9),P(-8,-10),P(8,-10),P(-10,-8),P(10,-8),P(-10,8),P(10,8),P(-8,10),P(8,10),P(0,-13),P(-5,-12),P(5,-12),P(-12,-5),P(12,-5),P(-13,0),P(13,0),P(-12,5),P(12,5),P(-5,12),P(5,12),P(0,13),\nP(-1,-13),P(1,-13),P(-7,-11),P(7,-11),P(-11,-7),P(11,-7),P(-13,-1),P(13,-1),P(-13,1),P(13,1),P(-11,7),P(11,7),P(-7,11),P(7,11),P(-1,13),P(1,13),P(-2,-13),P(2,-13),P(-13,-2),P(13,-2),P(-13,2),P(13,2),P(-2,13),P(2,13),P(-3,-13),P(3,-13),P(-13,-3),P(13,-3),P(-13,3),P(13,3),P(-3,13),P(3,13),P(-6,-12),P(6,-12),P(-12,-6),P(12,-6),P(-12,6),P(12,6),P(-6,12),P(6,12),P(-9,-10),P(9,-10),P(-10,-9),P(10,-9),P(-10,9),P(10,9),P(-9,10),P(9,10),P(-4,-13),P(4,-13),P(-8,-11),P(8,-11),P(-11,-8),P(11,-8),P(-13,-4),P(13,-4),P(-13,4),P(13,4),P(-11,8),P(11,8),P(-8,11),P(8,11),P(-4,13),P(4,13),P(-7,-12),P(7,-12),P(-12,-7),P(12,-7),P(-12,7),P(12,7),P(-7,12),P(7,12),P(-5,-13),P(5,-13),P(-13,-5),P(13,-5),P(-13,5),P(13,5),P(-5,13),P(5,13),P(0,-14),P(-14,0),P(14,0),P(0,14),\nP(-1,-14),P(1,-14),P(-14,-1),P(14,-1),P(-14,1),P(14,1),P(-1,14),P(1,14),P(-2,-14),P(2,-14),P(-10,-10),P(10,-10),P(-14,-2),P(14,-2),P(-14,2),P(14,2),P(-10,10),P(10,10),P(-2,14),P(2,14),P(-9,-11),P(9,-11),P(-11,-9),P(11,-9),P(-11,9),P(11,9),P(-9,11),P(9,11),P(-3,-14),P(3,-14),P(-6,-13),P(6,-13),P(-13,-6),P(13,-6),P(-14,-3),P(14,-3),P(-14,3),P(14,3),P(-13,6),P(13,6),P(-6,13),P(6,13),P(-3,14),P(3,14),P(-8,-12),P(8,-12),P(-12,-8),P(12,-8),P(-12,8),P(12,8),P(-8,12),P(8,12),P(-4,-14),P(4,-14),P(-14,-4),P(14,-4),P(-14,4),P(14,4),P(-4,14),P(4,14),P(-7,-13),P(7,-13),P(-13,-7),P(13,-7),P(-13,7),P(13,7),P(-7,13),P(7,13),P(-5,-14),P(5,-14),P(-10,-11),P(10,-11),P(-11,-10),P(11,-10),P(-14,-5),P(14,-5),P(-14,5),P(14,5),P(-11,10),P(11,10),P(-10,11),P(10,11),P(-5,14),P(5,14),P(0,-15),P(-9,-12),P(9,-12),P(-12,-9),P(12,-9),P(-15,0),P(15,0),P(-12,9),P(12,9),P(-9,12),P(9,12),P(0,15)\n);\nconst int DEFAULT_PATCH_RADIUS = 15;\nconst int MIN_PATCH_RADIUS = 2;\nvoid main()\n{\nvec4 pixel = threadPixel(encodedKeypoints);\nivec2 thread = threadLocation();\nint keypointIndex = thread.x + thread.y * outputSize().x;\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress address = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\nvec2 m = vec2(0.0f);\nfloat pot = exp2(keypoint.lod);\nivec2 pyrBaseSize = textureSize(pyramid, 0);\nint scaledRadius = int(ceil(float(DEFAULT_PATCH_RADIUS) / pot));\nint radius = max(scaledRadius, MIN_PATCH_RADIUS);\nint count = diskPointCount[radius];\nfor(int j = 0; j < count; j++) {\nvec2 offset = vec2(diskPoint[j]);\nvec2 position = keypoint.position + round(pot * offset);\nvec4 patchPixel = pyrPixelAtEx(pyramid, position, keypoint.lod, pyrBaseSize);\nm += offset * patchPixel.g;\n}\nfloat angle = fastAtan2(m.y, m.x);\nfloat encodedOrientation = encodeKeypointOrientation(angle);\ncolor = vec4(0.0f, encodedOrientation, 0.0f, 0.0f);\n}'},function(e,t){e.exports='@include "keypoints.glsl"\n@include "filters.glsl"\n#if !defined(METHOD)\n#error Undefined METHOD\n#endif\nuniform sampler2D pyramid;\nuniform float lodStep;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\n#if METHOD == 1\nuniform int threshold;\n#endif\nconst float eps = 1e-6;\nfloat cornerStrength(vec2 position, float lod)\n{\n#if METHOD == 0\nreturn laplacian(pyramid, position, lod);\n#elif METHOD == 1\nfloat pot = exp2(lod);\nfloat t = float(clamp(threshold, 0, 255)) / 255.0f;\n#define P(x,y) pyrPixelAtOffset(pyramid, lod, pot, ivec2((x),(y))).g\nmat4 mp = mat4(\nP(0,3),P(3,0),P(0,-3),P(-3,0),\nP(1,3),P(2,2),P(3,1),P(3,-1),\nP(2,-2),P(1,-3),P(-1,-3),P(-2,-2),\nP(-3,-1),P(-3,1),P(-2,2),P(-1,3)\n);\nfloat c = P(0,0);\nfloat ct = c + t, c_t = c - t;\nmat4 mct = mp - mat4(ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct);\nmat4 mc_t = mat4(c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t) - mp;\nconst vec4 zeros = vec4(0.0f), ones = vec4(1.0f);\nvec4 bs = max(mct[0], zeros), ds = max(mc_t[0], zeros);\nbs += max(mct[1], zeros);     ds += max(mc_t[1], zeros);\nbs += max(mct[2], zeros);     ds += max(mc_t[2], zeros);\nbs += max(mct[3], zeros);     ds += max(mc_t[3], zeros);\nreturn max(dot(bs, ones), dot(ds, ones)) / 16.0f;\n#else\n#error Invalid method\n#endif\n}\nvoid main()\n{\nvec4 pixel = threadPixel(encodedKeypoints);\nivec2 thread = threadLocation();\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\ncolor = pixel;\nif(address.offset != 1)\nreturn;\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\nif(isBadKeypoint(keypoint))\nreturn;\nvec3 strength = vec3(\ncornerStrength(keypoint.position, max(0.0f, keypoint.lod - lodStep)),\ncornerStrength(keypoint.position, keypoint.lod),\ncornerStrength(keypoint.position, keypoint.lod + lodStep)\n);\nvec3 p = mat3(\n2, -3, 1,\n-4, 4, 0,\n2, -1, 0\n) * strength;\nfloat maxStrength = max(strength.x, max(strength.y, strength.z));\nvec3 diffStrength = abs(strength - vec3(maxStrength));\nvec3 strengthIndicators = vec3(lessThan(diffStrength, vec3(eps)));\nfloat maxPoint = min(1.0f, dot(vec3(0.0f, 0.5f, 1.0f), strengthIndicators));\nbool hasMax = p.x < -eps;\nfloat pmax = hasMax ? -0.5f * p.y / p.x : maxPoint;\nfloat alpha = abs(pmax - 0.5f) <= 0.5f ? pmax : maxPoint;\nfloat lodOffset = mix(-lodStep, lodStep, alpha);\nfloat lod = keypoint.lod + lodOffset;\ncolor.r = encodeLod(lod);\n}'},function(e,t){e.exports='@include "float16.glsl"\nuniform sampler2D corners;\nuniform int iterationNumber;\nvoid main()\n{\nivec2 thread = threadLocation();\nivec2 bounds = outputSize();\nint jump = (1 << iterationNumber);\nint clusterLength = jump << 1;\nint clusterMask = clusterLength - 1;\nivec2 clusterPos = ivec2(thread >> (1 + iterationNumber)) << (1 + iterationNumber);\nivec2 next1 = clusterPos + ((thread - clusterPos + ivec2(jump, 0)) & clusterMask);\nivec2 next2 = clusterPos + ((thread - clusterPos + ivec2(0, jump)) & clusterMask);\nivec2 next3 = clusterPos + ((thread - clusterPos + ivec2(jump, jump)) & clusterMask);\nvec4 p0 = texelFetch(corners, thread, 0);\nvec4 p1 = texelFetch(corners, next1 % bounds, 0);\nvec4 p2 = texelFetch(corners, next2 % bounds, 0);\nvec4 p3 = texelFetch(corners, next3 % bounds, 0);\nfloat s0 = decodeFloat16(p0.rb);\nfloat s1 = decodeFloat16(p1.rb);\nfloat s2 = decodeFloat16(p2.rb);\nfloat s3 = decodeFloat16(p3.rb);\nbool b0 = s0 >= s1 && s0 >= s2 && s0 >= s3;\nbool b1 = s1 >= s0 && s1 >= s2 && s1 >= s3;\nbool b2 = s2 >= s0 && s2 >= s1 && s2 >= s3;\ncolor = vec4(0.0f);\ncolor.rb = b0 ? p0.rb : (\nb1 ? p1.rb : (\nb2 ? p2.rb : p3.rb\n)\n);\n}'},function(e,t){e.exports='@include "keypoints.glsl"\nuniform sampler2D permutation;\nuniform int maxKeypoints;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nstruct PermutationElement\n{\nint keypointIndex;\nfloat score;\nbool valid;\n};\nPermutationElement decodePermutationElement(vec4 pixel)\n{\nconst vec2 ones = vec2(1.0f);\nPermutationElement element;\nelement.keypointIndex = int(pixel.r * 255.0f) | (int(pixel.g * 255.0f) << 8);\nelement.valid = !all(equal(pixel.ba, ones));\nelement.score = element.valid ? decodeFloat16(pixel.ba) : -1.0f;\nreturn element;\n}\nPermutationElement readPermutationElement(sampler2D permutation, int elementIndex, int stride, int height)\n{\nconst vec4 INVALID_PIXEL = vec4(0.0f);\nivec2 pos = ivec2(elementIndex % stride, elementIndex / stride);\nvec4 pixel = pos.y < height ? pixelAt(permutation, pos) : INVALID_PIXEL;\nreturn decodePermutationElement(pixel);\n}\nvoid main()\n{\nivec2 thread = threadLocation();\nint newEncoderLength = outputSize().x;\nKeypointAddress myAddress = findKeypointAddress(thread, newEncoderLength, descriptorSize, extraSize);\nint myKeypointIndex = findKeypointIndex(myAddress, descriptorSize, extraSize);\nivec2 psize = textureSize(permutation, 0);\nPermutationElement element = readPermutationElement(permutation, myKeypointIndex, psize.x, psize.y);\nint oldEncoderLength = textureSize(encodedKeypoints, 0).x;\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress address = KeypointAddress(element.keypointIndex * pixelsPerKeypoint, myAddress.offset);\nvec4 keypointData = readKeypointData(encodedKeypoints, oldEncoderLength, address);\ncolor = myKeypointIndex < maxKeypoints && element.valid ? keypointData : encodeNullKeypoint();\n}'},function(e,t){e.exports='@include "keypoints.glsl"\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nstruct PermutationElement\n{\nint keypointIndex;\nfloat score;\nbool valid;\n};\nvec4 encodePermutationElement(PermutationElement element)\n{\nconst vec2 ones = vec2(1.0f);\nvec2 encodedScore = element.valid ? encodeFloat16(element.score) : ones;\nvec2 encodedIndex = vec2(element.keypointIndex & 255, (element.keypointIndex >> 8) & 255) / 255.0f;\nreturn vec4(encodedIndex, encodedScore);\n}\nvoid main()\n{\nivec2 thread = threadLocation();\nint stride = outputSize().x;\nint keypointIndex = thread.y * stride + thread.x;\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress address = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\nPermutationElement element;\nelement.keypointIndex = keypointIndex;\nelement.score = keypoint.score;\nelement.valid = !isBadKeypoint(keypoint);\ncolor = encodePermutationElement(element);\n}'},function(e,t){e.exports='@include "keypoints.glsl"\nuniform sampler2D permutation;\nuniform int blockSize;\nuniform int dblLog2BlockSize;\nstruct PermutationElement\n{\nint keypointIndex;\nfloat score;\nbool valid;\n};\nPermutationElement decodePermutationElement(vec4 pixel)\n{\nconst vec2 ones = vec2(1.0f);\nPermutationElement element;\nelement.keypointIndex = int(pixel.r * 255.0f) | (int(pixel.g * 255.0f) << 8);\nelement.valid = !all(equal(pixel.ba, ones));\nelement.score = element.valid ? decodeFloat16(pixel.ba) : -1.0f;\nreturn element;\n}\nvec4 encodePermutationElement(PermutationElement element)\n{\nconst vec2 ones = vec2(1.0f);\nvec2 encodedScore = element.valid ? encodeFloat16(element.score) : ones;\nvec2 encodedIndex = vec2(element.keypointIndex & 255, (element.keypointIndex >> 8) & 255) / 255.0f;\nreturn vec4(encodedIndex, encodedScore);\n}\nPermutationElement readPermutationElement(sampler2D permutation, int elementIndex, int stride, int height)\n{\nconst vec4 INVALID_PIXEL = vec4(0.0f);\nivec2 pos = ivec2(elementIndex % stride, elementIndex / stride);\nvec4 pixel = pos.y < height ? pixelAt(permutation, pos) : INVALID_PIXEL;\nreturn decodePermutationElement(pixel);\n}\nPermutationElement selectKth(int k, int la, int ra, int lb, int rb)\n{\nPermutationElement a, b;\nint ha, hb, ma, mb;\nbool discard1stHalf, altb;\nbool locked = false;\nint tmp, result = 0;\nint stride = outputSize().x;\nint height = outputSize().y;\nfor(int i = 0; i < dblLog2BlockSize; i++) {\ntmp = (lb > rb && !locked) ? (la+k) : result;\nresult = (la > ra && !locked) ? (lb+k) : tmp;\nlocked = locked || (la > ra) || (lb > rb);\nha = (ra - la + 1) / 2;\nhb = (rb - lb + 1) / 2;\nma = la + ha;\nmb = lb + hb;\na = readPermutationElement(permutation, ma, stride, height);\nb = readPermutationElement(permutation, mb, stride, height);\ndiscard1stHalf = (k > ha + hb);\naltb = (-a.score < -b.score);\nk -= int(discard1stHalf && altb) * (ha + 1);\nk -= int(discard1stHalf && !altb) * (hb + 1);\nla += int(discard1stHalf && altb) * (ma + 1 - la);\nlb += int(discard1stHalf && !altb) * (mb + 1 - lb);\nra += int(!discard1stHalf && !altb) * (ma - 1 - ra);\nrb += int(!discard1stHalf && altb) * (mb - 1 - rb);\n}\nreturn readPermutationElement(permutation, result, stride, height);\n}\nvoid main()\n{\nivec2 thread = threadLocation();\nint stride = outputSize().x;\nint elementIndex = thread.y * stride + thread.x;\nint blockIndex = elementIndex / blockSize;\nint blockOffset = elementIndex % blockSize;\nint la = blockIndex * blockSize;\nint lb = la + blockSize / 2;\nint ra = lb - 1;\nint rb = (blockIndex + 1) * blockSize - 1;\nint k = blockOffset;\nPermutationElement element = selectKth(k, la, ra, lb, rb);\ncolor = encodePermutationElement(element);\n}'},function(e,t){e.exports='@include "keypoints.glsl"\n@include "float16.glsl"\n#if !defined(METHOD)\n#error Must define METHOD\n#endif\nuniform sampler2D pyramid;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nuniform int maxIterations;\nuniform float epsilon;\nconst int PATCH_RADIUS = 1;\nconst int PATCH_SIZE = 2 * PATCH_RADIUS + 1;\nconst int PATCH_SIZE_SQUARED = PATCH_SIZE * PATCH_SIZE;\nconst int LARGE_PATCH_RADIUS = PATCH_RADIUS + 1;\nconst int LARGE_PATCH_SIZE = 2 * LARGE_PATCH_RADIUS + 1;\nconst int LARGE_PATCH_SIZE_SQUARED = LARGE_PATCH_SIZE * LARGE_PATCH_SIZE;\nconst int LARGER_PATCH_RADIUS = LARGE_PATCH_RADIUS + 1;\nconst int LARGER_PATCH_SIZE = 2 * LARGER_PATCH_RADIUS + 1;\nconst int LARGER_PATCH_SIZE_SQUARED = LARGER_PATCH_SIZE * LARGER_PATCH_SIZE;\nconst float EPS = 1e-5;\nfloat smoothPixelBuffer[LARGER_PATCH_SIZE_SQUARED];\nvec2 derivativesBuffer[LARGE_PATCH_SIZE_SQUARED];\nfloat responseBuffer[PATCH_SIZE_SQUARED];\n#define patchPixelAt(u,v) smoothPixelBuffer[((v) + LARGER_PATCH_RADIUS) * LARGER_PATCH_SIZE + ((u) + LARGER_PATCH_RADIUS)]\n#define derivativesAt(u,v) derivativesBuffer[((v) + LARGE_PATCH_RADIUS) * LARGE_PATCH_SIZE + ((u) + LARGE_PATCH_RADIUS)]\n#define responseAt(u,v) responseBuffer[((v) + PATCH_RADIUS) * PATCH_SIZE + ((u) + PATCH_RADIUS)]\nvoid readPixels(vec2 center, float lod)\n{\nivec2 pyrBaseSize = textureSize(pyramid, 0);\nfloat pot = exp2(lod);\nint u, v;\nfor(int j = 0; j < LARGER_PATCH_SIZE; j++) {\nfor(int i = 0; i < LARGER_PATCH_SIZE; i++) {\nu = i - LARGER_PATCH_RADIUS;\nv = j - LARGER_PATCH_RADIUS;\npatchPixelAt(u,v) = pyrSubpixelAtExOffset(pyramid, center, lod, pot, ivec2(u,v), pyrBaseSize).g;\n}\n}\n}\nvoid computeDerivatives()\n{\nconst mat3 dx = mat3(\n-1, 0, 1,\n-2, 0, 2,\n-1, 0, 1\n);\nconst mat3 dy = mat3(\n1, 2, 1,\n0, 0, 0,\n-1,-2,-1\n);\nint u, v;\nmat3 pix, convX, convY;\nconst vec3 ones = vec3(1.0f);\nfor(int j = 0; j < LARGE_PATCH_SIZE; j++) {\nfor(int i = 0; i < LARGE_PATCH_SIZE; i++) {\nu = i - LARGE_PATCH_RADIUS;\nv = j - LARGE_PATCH_RADIUS;\npix = mat3(\npatchPixelAt(u+1,v+1), patchPixelAt(u+0,v+1), patchPixelAt(u-1,v+1),\npatchPixelAt(u+1,v+0), patchPixelAt(u+0,v+0), patchPixelAt(u-1,v+0),\npatchPixelAt(u+1,v-1), patchPixelAt(u+0,v-1), patchPixelAt(u-1,v-1)\n);\nconvX = matrixCompMult(dx, pix);\nconvY = matrixCompMult(dy, pix);\nderivativesAt(u,v) = vec2(\ndot(ones, vec3(\ndot(convX[0], ones),\ndot(convX[1], ones),\ndot(convX[2], ones)\n)),\ndot(ones, vec3(\ndot(convY[0], ones),\ndot(convY[1], ones),\ndot(convY[2], ones)\n))\n);\n}\n}\n}\nvec2 computeResponseMap()\n{\nfloat patchArea = float(PATCH_SIZE * PATCH_SIZE);\nvec3 h; vec2 d, c = vec2(0.0f);\nconst vec3 ones = vec3(1.0f);\nfloat response, sum = 0.0f;\nint u, v;\n#define H(r,s) d = derivativesAt((r),(s)); h += vec3(d.x * d.x, d.x * d.y, d.y * d.y)\nfor(int j = 0; j < PATCH_SIZE; j++) {\nfor(int i = 0; i < PATCH_SIZE; i++) {\nu = i - PATCH_RADIUS;\nv = j - PATCH_RADIUS;\nh = vec3(0.0f);\nH(u-1,v-1); H(u+0,v-1); H(u+1,v-1);\nH(u-1,v+0); H(u+0,v+0); H(u+1,v+0);\nH(u-1,v+1); H(u+0,v+1); H(u+1,v+1);\nresponse = 0.5f * (h.x + h.z - sqrt((h.x - h.z) * (h.x - h.z) + 4.0f * h.y * h.y));\nresponse /= patchArea;\nresponseAt(u,v) = response;\nc += vec2(u,v) * response;\nsum += response;\n}\n}\nreturn abs(sum) > EPS ? c / sum : vec2(0.0f);\n}\n#if METHOD == 0\nvec2 quadratic1d()\n{\nfloat a = 0.5f * (responseAt(-1,0) - 2.0f * responseAt(0,0) + responseAt(1,0));\nfloat b = 0.5f * (responseAt(1,0) - responseAt(-1,0));\nfloat c = responseAt(0,0);\nfloat d = 0.5f * (responseAt(0,-1) - 2.0f * responseAt(0,0) + responseAt(0,1));\nfloat e = 0.5f * (responseAt(0,1) - responseAt(0,-1));\nfloat f = responseAt(0,0);\nbool hasMax = a < -EPS && d < -EPS;\nreturn hasMax ? -0.5f * vec2(b / a, e / d) : vec2(0.0f);\n}\n#endif\n#if METHOD == 1\nvec2 taylor2d()\n{\nfloat dx = (-responseAt(-1,0) + responseAt(1,0)) * 0.5f;\nfloat dy = (-responseAt(0,-1) + responseAt(0,1)) * 0.5f;\nfloat dxx = responseAt(-1,0) - 2.0f * responseAt(0,0) + responseAt(1,0);\nfloat dyy = responseAt(0,-1) - 2.0f * responseAt(0,0) + responseAt(0,1);\nfloat dxy = (responseAt(-1,-1) + responseAt(1,1) - responseAt(1,-1) - responseAt(-1,1)) * 0.25f;\nfloat det = dxx * dyy - dxy * dxy;\nmat2 inv = mat2(dyy, -dxy, -dxy, dxx);\nbool hasMax = det > EPS && dxx < 0.0f;\nreturn hasMax ? inv * vec2(dx, dy) / (-det) : vec2(0.0f);\n}\n#endif\n#if METHOD == 2\nvoid bilinearUpsample(ivec2 patchOffset, vec4 pixelsOfPatch)\n{\nint u, v, i, j;\nvec2 frc, ifrc; vec4 sub;\nconst vec4 ones = vec4(1.0f);\nfloat s = 1.0f / float(PATCH_SIZE - 1);\nint xoff = 2 * patchOffset.x;\nint yoff = 2 * patchOffset.y;\nfor(j = 0; j < PATCH_SIZE; j++) {\nfor(i = 0; i < PATCH_SIZE; i++) {\nu = i - PATCH_RADIUS;\nv = j - PATCH_RADIUS;\nfrc = vec2(i, j) * s;\nifrc = vec2(1.0f) - frc;\nsub = vec4(\nifrc.x * ifrc.y,\nfrc.x * ifrc.y,\nifrc.x * frc.y,\nfrc.x * frc.y\n);\npatchPixelAt(u+xoff,v+yoff) = dot(sub*pixelsOfPatch, ones);\n}\n}\n}\n#endif\n#if METHOD == 3\nvoid bicubicUpsample(ivec2 patchOffset, vec4 pixelsOfPatch, vec4 dx, vec4 dy, vec4 dxy)\n{\nfloat x, y, s = 1.0f / float(PATCH_SIZE - 1);\nint u, v, i, j;\nfloat f00 = pixelsOfPatch.x;\nfloat f10 = pixelsOfPatch.y;\nfloat f01 = pixelsOfPatch.z;\nfloat f11 = pixelsOfPatch.w;\nfloat fx00 = dx.x;\nfloat fx10 = dx.y;\nfloat fx01 = dx.z;\nfloat fx11 = dx.w;\nfloat fy00 = dy.x;\nfloat fy10 = dy.y;\nfloat fy01 = dy.z;\nfloat fy11 = dy.w;\nfloat fxy00 = dxy.x;\nfloat fxy10 = dxy.y;\nfloat fxy01 = dxy.z;\nfloat fxy11 = dxy.w;\nmat4 bicubic = mat4(\n1, 0, -3, 2,\n0, 0, 3, -2,\n0, 1, -2, 1,\n0, 0, -1, 1\n) * mat4(\nf00, f10, fx00, fx10,\nf01, f11, fx01, fx11,\nfy00, fy10, fxy00, fxy10,\nfy01, fy11, fxy01, fxy11\n) * mat4(\n1, 0, 0, 0,\n0, 0, 1, 0,\n-3, 3, -2, -1,\n2, -2, 1, 1\n);\nint xoff = 2 * patchOffset.x;\nint yoff = 2 * patchOffset.y;\nfor(j = 0; j < PATCH_SIZE; j++) {\nfor(i = 0; i < PATCH_SIZE; i++) {\nu = i - PATCH_RADIUS;\nv = j - PATCH_RADIUS;\nx = float(i) * s;\ny = float(j) * s;\npatchPixelAt(u+xoff,v+yoff) = dot(\nvec4(1, x, x*x, x*x*x),\nbicubic * vec4(1, y, y*y, y*y*y)\n);\n}\n}\n}\n#endif\n#if METHOD == 2 || METHOD == 3\nvoid upsamplePatch(int left, int top, int right, int bottom)\n{\nint x, y, k;\nvec4 ptch[9];\nvec2 d00, d10, d01, d11;\nfor(k = 0; k < 9; k++) {\nx = -1 + (k % 3);\ny = -1 + (k / 3);\nptch[k] = vec4(\npatchPixelAt(left+x, top+y),\npatchPixelAt(right+x, top+y),\npatchPixelAt(left+x, bottom+y),\npatchPixelAt(right+x, bottom+y)\n);\n}\nfor(k = 0; k < 9; k++) {\nx = -1 + (k % 3);\ny = -1 + (k / 3);\n#if METHOD == 2\nbilinearUpsample(ivec2(x, y), ptch[k]);\n#elif METHOD == 3\nd00 = derivativesAt(left+x, top+y);\nd10 = derivativesAt(right+x, top+y);\nd01 = derivativesAt(left+x, bottom+y);\nd11 = derivativesAt(right+x, bottom+y);\nbicubicUpsample(ivec2(x, y), ptch[k],\nvec4(d00.x, d10.x, d01.x, d11.x),\nvec4(d00.y, d10.y, d01.y, d11.y),\n0.25f * vec4(\n(patchPixelAt(left+x + 1,top+y + 1) + patchPixelAt(left+x - 1, top+y - 1)) - (patchPixelAt(left+x + 1, top+y - 1) + patchPixelAt(left+x - 1, top+y + 1)),\n(patchPixelAt(right+x + 1,top+y + 1) + patchPixelAt(right+x - 1, top+y - 1)) - (patchPixelAt(right+x + 1, top+y - 1) + patchPixelAt(right+x - 1, top+y + 1)),\n(patchPixelAt(left+x + 1,bottom+y + 1) + patchPixelAt(left+x - 1, bottom+y - 1)) - (patchPixelAt(left+x + 1, bottom+y - 1) + patchPixelAt(left+x - 1, bottom+y + 1)),\n(patchPixelAt(right+x + 1,bottom+y + 1) + patchPixelAt(right+x - 1, bottom+y - 1)) - (patchPixelAt(right+x + 1, bottom+y - 1) + patchPixelAt(right+x - 1, bottom+y + 1))\n)\n);\n#endif\n}\n}\nvec2 upsampleResponseMap(int left, int top, int right, int bottom)\n{\nupsamplePatch(left, top, right, bottom);\ncomputeDerivatives();\nreturn computeResponseMap();\n}\nvec2 iterativeUpsample(vec2 initialGuess)\n{\nint refine = 1;\nfloat scale = 0.5f;\nfloat eps2 = epsilon * epsilon;\nvec2 guess = initialGuess, localGuess = initialGuess;\nfor(int k = 0; k < maxIterations; k++) {\nivec4 quad = ivec4(floor(localGuess.x), floor(localGuess.y), ceil(localGuess.x), ceil(localGuess.y));\nvec2 response = (refine != 0) ? upsampleResponseMap(quad.x, quad.y, quad.z, quad.w) : vec2(0.0f);\nlocalGuess = response * scale;\nguess += localGuess;\nscale *= 0.5f;\nrefine *= int(dot(localGuess, localGuess) >= eps2);\n}\nreturn guess;\n}\n#endif\nvoid main()\n{\nivec2 thread = threadLocation();\nint keypointIndex = thread.x + thread.y * outputSize().x;\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress address = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\ncolor = encodeNullPairOfFloat16();\nif(isNullKeypoint(keypoint));\nreturn;\ncolor = encodeDiscardedPairOfFloat16();\nif(isBadKeypoint(keypoint))\nreturn;\nreadPixels(keypoint.position, keypoint.lod);\ncomputeDerivatives();\nvec2 offset = computeResponseMap();\n#if METHOD == 0\noffset = quadratic1d();\n#elif METHOD == 1\noffset = taylor2d();\n#elif METHOD == 2 || METHOD == 3\noffset = iterativeUpsample(offset);\n#else\n#error Unknown METHOD\n#endif\nfloat pot = exp2(keypoint.lod);\ncolor = encodePairOfFloat16(offset * pot);\n}'},function(e,t){e.exports='@include "keypoints.glsl"\n@include "float16.glsl"\nuniform sampler2D encodedFlow;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nvoid main()\n{\nvec4 pixel = threadPixel(encodedKeypoints);\nivec2 thread = threadLocation();\nKeypointAddress myAddress = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, myAddress);\nint myIndex = findKeypointIndex(myAddress, descriptorSize, extraSize);\ncolor = pixel;\nif(isBadKeypoint(keypoint))\nreturn;\nint len = textureSize(encodedFlow, 0).x;\nivec2 location = ivec2(myIndex % len, myIndex / len);\nvec4 encodedFlow = pixelAt(encodedFlow, location);\nbool discardFlow = isDiscardedPairOfFloat16(encodedFlow);\nvec2 flow = !discardFlow ? decodePairOfFloat16(encodedFlow) : vec2(0.0f);\nvec4 newPosition = encodeKeypointPosition(keypoint.position + flow);\nvec4 newPixel = myAddress.offset == 0 ? newPosition : pixel;\ncolor = !discardFlow ? newPixel : encodeDiscardedKeypoint();\n}'},function(e,t){e.exports='@include "keypoints.glsl"\nuniform sampler2D encodedOrientations;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nvoid main()\n{\nvec4 pixel = threadPixel(encodedKeypoints);\nivec2 thread = threadLocation();\nKeypointAddress myAddress = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nint myIndex = findKeypointIndex(myAddress, descriptorSize, extraSize);\nint orientationEncoderLength = textureSize(encodedOrientations, 0).x;\nivec2 location = ivec2(myIndex % orientationEncoderLength, myIndex / orientationEncoderLength);\nvec4 targetPixel = pixelAt(encodedOrientations, location);\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, myAddress);\nbool isValid = !isBadKeypoint(keypoint);\nfloat encodedOrientation = targetPixel.g;\ncolor = isValid && myAddress.offset == 1 ? vec4(pixel.r, encodedOrientation, pixel.ba) : pixel;\n}'},function(e,t){e.exports='@include "keypoints.glsl"\nuniform sampler2D encodedKeypoints;\nuniform int startIndex;\nuniform int endIndex;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\n#ifndef BUFFER_SIZE\n#error Undefined BUFFER_SIZE\n#endif\nlayout(std140) uniform KeypointBuffer\n{\nvec4 keypointBuffer[BUFFER_SIZE];\n};\nvoid main()\n{\nvec4 pixel = threadPixel(encodedKeypoints);\nivec2 thread = threadLocation();\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nint index = findKeypointIndex(address, descriptorSize, extraSize);\ncolor = pixel;\nif(index < startIndex)\nreturn;\ncolor = encodeNullKeypoint();\nif(index >= endIndex)\nreturn;\nvec4 data = keypointBuffer[index - startIndex];\nswitch(address.offset) {\ncase 0: {\nfixed2_t pos = vec2tofix(data.xy);\nfixed2_t lo = pos & 255;\nfixed2_t hi = (pos >> 8) & 255;\ncolor = vec4(float(lo.x), float(hi.x), float(lo.y), float(hi.y)) / 255.0f;\nbreak;\n}\ncase 1: {\nvec2 score = encodeKeypointScore(max(data.w, 0.0f));\nfloat scale = encodeLod(data.z);\nfloat rotation = encodeKeypointOrientation(0.0f);\ncolor = vec4(scale, rotation, score);\nbreak;\n}\ndefault: {\ncolor = vec4(0.0f);\nbreak;\n}\n}\n}'},function(e,t){e.exports="uniform sampler2D image;\nvoid main()\n{\nivec2 thread = threadLocation();\nivec2 pos = min(thread * 2, textureSize(image, 0) - ivec2(1));\ncolor = pixelAt(image, pos);\n}"},function(e,t){e.exports="uniform sampler2D image;\nvoid main()\n{\nivec2 thread = threadLocation();\nvec4 pixel = pixelAt(image, thread / 2);\ncolor = (((thread.x + thread.y) & 1) == 0) ? pixel : vec4(0.0f, 0.0f, 0.0f, pixel.a);\n}"},function(e,t){e.exports='@include "subpixel.glsl"\nuniform sampler2D image0;\nuniform sampler2D image1;\nuniform float alpha;\nuniform float beta;\nuniform float gamma;\nconst vec4 BACKGROUND = vec4(0.0f);\nvoid main()\n{\nivec2 location = threadLocation();\nivec2 size0 = textureSize(image0, 0);\nivec2 size1 = textureSize(image1, 0);\nvec4 pix0 = all(lessThan(location, size0)) ? pixelAt(image0, location) : BACKGROUND;\nvec4 pix1 = all(lessThan(location, size1)) ? pixelAt(image1, location) : BACKGROUND;\nvec4 pix = clamp(alpha * pix0 + beta * pix1 + vec4(gamma), 0.0f, 1.0f);\ncolor = vec4(pix.rgb, 1.0f);\n}'},function(e,t){e.exports='@include "subpixel.glsl"\nuniform sampler2D image;\nvoid main()\n{\nvec2 imageSize = vec2(textureSize(image, 0));\n#if !defined(INTERPOLATION_METHOD)\n#error Must define INTERPOLATION_METHOD\n#elif INTERPOLATION_METHOD == 0\nvec2 pos = texCoord * imageSize;\ncolor = textureLod(image, (round(pos) + vec2(0.5f)) / imageSize, 0.0f);\n#elif INTERPOLATION_METHOD == 1\ncolor = subpixelAtBI(image, texCoord * imageSize);\n#else\n#error Invalid INTERPOLATION_METHOD\n#endif\n}'},function(e,t){e.exports='@include "subpixel.glsl"\nuniform sampler2D image;\nuniform mat3 inverseHomography;\nconst vec4 emptyColor = vec4(0.0f, 0.0f, 0.0f, 1.0f);\nvec2 perspectiveWarp(mat3 homography, vec2 p)\n{\nvec3 q = homography * vec3(p, 1.0f);\nreturn q.xy / q.z;\n}\nvoid main()\n{\nivec2 location = threadLocation();\nivec2 size = outputSize();\nconst vec2 zero = vec2(0.0f);\nvec2 target = perspectiveWarp(inverseHomography, vec2(location));\nbool withinBounds = all(bvec4(greaterThanEqual(target, zero), lessThan(target, vec2(size))));\ncolor = withinBounds ? subpixelAtBI(image, target) : emptyColor;\n}'},function(e,t){e.exports='@include "colors.glsl"\nuniform sampler2D dest, src;\nuniform int destComponents;\nuniform int srcComponentId;\nvoid main()\n{\nvec4 destPixel = threadPixel(dest);\nvec4 srcPixel = threadPixel(src);\nbvec4 flags = bvec4(\n(destComponents & PIXELCOMPONENT_RED) != 0,\n(destComponents & PIXELCOMPONENT_GREEN) != 0,\n(destComponents & PIXELCOMPONENT_BLUE) != 0,\n(destComponents & PIXELCOMPONENT_ALPHA) != 0\n);\ncolor = mix(destPixel, vec4(srcPixel[srcComponentId]), flags);\n}'},function(e,t){e.exports='@include "colors.glsl"\nuniform sampler2D image;\nuniform int pixelComponents;\nuniform float value;\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nbvec4 flags = bvec4(\n(pixelComponents & PIXELCOMPONENT_RED) != 0,\n(pixelComponents & PIXELCOMPONENT_GREEN) != 0,\n(pixelComponents & PIXELCOMPONENT_BLUE) != 0,\n(pixelComponents & PIXELCOMPONENT_ALPHA) != 0\n);\ncolor = mix(pixel, vec4(value), flags);\n}'},function(e,t){e.exports="uniform float value;\nvoid main()\n{\ncolor = vec4(value);\n}"},function(e,t){e.exports="uniform sampler2D image;\nvoid main() {\nivec2 pos = threadLocation();\npos.y = int(texSize.y) - 1 - pos.y;\ncolor = pixelAt(image, pos);\n}"},function(e,t){e.exports="uniform sampler2D image;\nvoid main()\n{\ncolor = threadPixel(image);\n}"},function(e,t){e.exports="uniform sampler2D image;\nuniform int iterationNumber;\nvoid main()\n{\nivec2 thread = threadLocation();\nivec2 last = outputSize() - ivec2(1);\nint jump = (1 << iterationNumber);\nint clusterLength = jump << 1;\nint clusterMask = clusterLength - 1;\nivec2 clusterPos = ivec2(thread >> (1 + iterationNumber)) << (1 + iterationNumber);\nivec2 next1 = clusterPos + ((thread - clusterPos + ivec2(jump, 0)) & clusterMask);\nivec2 next2 = clusterPos + ((thread - clusterPos + ivec2(0, jump)) & clusterMask);\nivec2 next3 = clusterPos + ((thread - clusterPos + ivec2(jump, jump)) & clusterMask);\nvec4 p0 = texelFetch(image, thread, 0);\nvec4 p1 = texelFetch(image, min(next1, last), 0);\nvec4 p2 = texelFetch(image, min(next2, last), 0);\nvec4 p3 = texelFetch(image, min(next3, last), 0);\nvec4 pmax = max(max(p0, p1), max(p2, p3));\nvec4 pmin = min(min(p0, p1), min(p2, p3));\ncolor = vec4(pmax.r, pmin.g, pmax.r - pmin.g, p0.a);\n}"},function(e,t){e.exports='@include "pyramids.glsl"\n@include "float16.glsl"\nuniform sampler2D pyramid;\nuniform float lod;\nconst mat3 hkern = mat3(\n1.0f, 0.0f,-1.0f,\n2.0f, 0.0f,-2.0f,\n1.0f, 0.0f,-1.0f\n), vkern = mat3(\n1.0f, 2.0f, 1.0f,\n0.0f, 0.0f, 0.0f,\n-1.0f,-2.0f,-1.0f\n);\n#define PIX(x,y) pyrPixelAtOffset(pyramid, lod, pot, ivec2((x),(y))).g\nconst vec3 ones = vec3(1.0f);\nvoid main()\n{\nfloat pot = exp2(lod);\nmat3 win = mat3(\nPIX(-1,-1), PIX(0,-1), PIX(1,-1),\nPIX(-1,0), PIX(0,0), PIX(1,0),\nPIX(-1,1), PIX(0,1), PIX(1,1)\n);\nmat3 dx = matrixCompMult(hkern, win);\nmat3 dy = matrixCompMult(vkern, win);\nvec2 df = vec2(\ndot(dx[0] + dx[1] + dx[2], ones),\ndot(dy[0] + dy[1] + dy[2], ones)\n);\ncolor = encodePairOfFloat16(df);\n}'},function(e,t){e.exports="AGFzbQEAAAABiwETYAABfmADf39/AX9gAX8AYAN/f38AYAF9AX9gAX8Bf2ACf38Bf2AFf39/f38B\nf2AFf39/f38AYAZ/f39/f38Bf2AAAX9gAn99AX9gA39/fQF/YAJ/fwF9YAF/AX1gBH9/f38AYAR/\nf39/AX9gEX98fHx8fHx8fHx8fHx8fHx8AGAHf39/f39/fQF/AjsEA2VudgZtZW1vcnkCAAIDZW52\nBWZhdGFsAAIDZW52CGJ5dGVmaWxsAAMDZW52CmNvcHlXaXRoaW4AAwM7OgQFBgIGAQECBwgGAwAJ\nAgYCBgYKBQUFCQsFBgEBDAEBBgYGAQEMAQ0OAwgPAxAIAwYBEQEBAQ8SAQEEBQFwAQUFBggBfwFB\n0JcECwfGAxoGbWFsbG9jAAQEZnJlZQAGBXNyYW5kAAoMTWF0MzJfY3JlYXRlABANTWF0MzJfZGVz\ndHJveQAXCk1hdDMyX2RhdGEAGA5NYXQzMl9kYXRhU2l6ZQAZD01hdDMyX3RyYW5zcG9zZQAdCU1h\ndDMyX2FkZAAeDk1hdDMyX3N1YnRyYWN0AB8LTWF0MzJfc2NhbGUAIA5NYXQzMl9jb21wbXVsdAAh\nDk1hdDMyX211bHRpcGx5ACIOTWF0MzJfaW52ZXJzZTEAIw5NYXQzMl9pbnZlcnNlMgAkDk1hdDMy\nX2ludmVyc2UzACUNTWF0MzJfcXJfZnVsbAAsEE1hdDMyX3FyX3JlZHVjZWQALwxNYXQzMl9xcl9v\nbHMAMBBNYXQzMl9xcl9pbnZlcnNlADMVTWF0MzJfaG9tb2dyYXBoeV9kbHQ0ADQWTWF0MzJfaG9t\nb2dyYXBoeV9uZGx0NAA2FE1hdDMyX2hvbW9ncmFwaHlfZGx0ADcVTWF0MzJfaG9tb2dyYXBoeV9u\nZGx0ADgYTWF0MzJfcHJhbnNhY19ob21vZ3JhcGh5ADobTWF0MzJfdHJhbnNmb3JtX3BlcnNwZWN0\naXZlADwJCgEAQQELBA8REzsKqJcBOiMBAX8gALwiAUGAgID8B3FBgICA/AdGIAFB////A3FBAEdx\nC2kBAX9BAEEAKAKgl4CAAEEBajYCoJeAgABBAEEAKAKMl4CAACIBQQdxIAFqIgEgAGo2AoyXgIAA\nAkBB0JeEgABBB3EgAWpB0JeEgABqIgA/AEEQdEkNAEGEiICAABCAgICAAEEADwsgAAt1AQJ/QQAh\n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\noqEiHiAUIAeiIBigIhiioSIkmUSN7bWg98awPmMNACAcmiIlIBShIiYgIqIgHyAcoSIiIBiioUQA\nAAAAAADwPyAkoyIkoiEYICIgI6IgJiAeoqEgJKIhHgJAAkAgHSAgZEEBcw0AIBMgGCAEoiAeIAOi\nRAAAAAAAAPA/oKAiBKIgJaMhHSAcIR8MAQsgEyAYIAaiIB4gBaJEAAAAAAAA8D+goCIEoiAfmqMh\nHQsgFyAEoiAfoyETAkACQCAhICWZZEEBcw0AIBogGCAGoiAeIAWiRAAAAAAAAPA/oKAiBKIgFJqj\nIQcMAQsgGiAYIAiiIB4gB6JEAAAAAAAA8D+goCIEoiAcoyEHICUhFAsgGCAdmiABoiATIAKioSIX\nIAeioiAdIBsgBKIgFKMiFKIgHiATIAeaIAGiIBQgAqKhIhyioqCgIBMgB6KhIBggHSAcoqKhIB4g\nFyAUoqKhmUSN7bWg98awPmMNACALIA2hIhsgECAOoSIaoiAWIA8gDaEiH6KhIiCZRI3ttaD3xrA+\nYw0AIBEhBCARIQIgESEGIBEhDiARIQEgESEDIBEhBSARIQggGyAVIBmgIhWiIBYgCSALoSANIA+h\noCIZoqFEAAAAAAAA8D8gIKMiFqIiDSAMIAqhIBogGaIgHyAVoqEgFqIiFiAMoqAiDCAJoqIgCyAJ\noSAWIAuioCILIBIgDSAQoqAiEKIgFiAPIAmhIA0gD6KgIg8gCqKioKAgDyAMoqEgDSALIAqioqEg\nFiAQIAmioqGZRI3ttaD3xrA+Yw0BIBYgF6IgDSAcoqBEAAAAAAAA8D+gIQUgGCAWIBOiIA0gFKKg\noCEDIB4gFiAdoiANIAeioKAhASAMIBeiIBAgHKKgIAqgIQ4gGCAKoiAMIBOiIBAgFKKgoCEGIB4g\nCqIgDCAdoiAQIAeioKAhAiALIBeiIA8gHKKgIAmgIQQgGCAJoiALIBOiIA8gFKKgoCERIB4gCaIg\nCyAdoiAPIAeioKAhCAwBCyARIQQgESECIBEhBiARIQ4gESEBIBEhAyARIQUgESEICyAAKAIAIicg\nCLY4AgAgJyAAQRRqKAIAIihBAnRqIBG2OAIAICcgKEEDdGogBLY4AgAgJyAAKAIQIgBBAnRqIAK2\nOAIAICcgACAoaiIpQQJ0aiAGtjgCACAnIAAgKEEBdGpBAnRqIA62OAIAICcgAEEDdGogAbY4AgAg\nJyAoIABBAXRqQQJ0aiADtjgCACAnIClBA3RqIAW2OAIAC58ICgF/AX0BfwJ9AX8KfQF/AX0DfwF9\nAkACQCAAKAIIQQNHDQAgACgCDEEDRw0AIAEoAghBAkcNACABKAIMQQRHDQAgAigCCEECRw0AIAIo\nAgxBBEYNAQtBspOAgAAQgICAgAALIAAgASgCACIDKgIAIgQgBCADIAFBFGooAgAiBUECdGoqAgAi\nBpIgAyAFQQN0aioCACIHkiADIAVBA2wiCEECdGoqAgAiCZJDAACAPpQiCpMiBEMAAABBIAMgCCAB\nKAIQIgFqQQJ0aioCACILIAsgAyABQQJ0aioCACIMIAMgBSABakECdGoqAgAiDZIgAyAFQQF0IAFq\nQQJ0aioCACIOkpJDAACAPpQiD5MiCyALlCAJIAqTIgkgCZQgDiAPkyIOIA6UIAcgCpMiByAHlCAN\nIA+TIg0gDZQgBiAKkyIGIAaUIAQgBJQgDCAPkyIMIAyUkpKSkpKSkpWRIgSUuyAMIASUuyAGIASU\nuyANIASUuyAHIASUuyAOIASUuyAJIASUuyALIASUuyACKAIAIgMqAgAiCyALIAMgAkEUaigCACIF\nQQJ0aioCACIQkiADIAVBA3RqKgIAIgySIAMgBUEDbCIIQQJ0aioCACINkkMAAIA+lCIJkyILQwAA\nAEEgAyAIIAIoAhAiAWpBAnRqKgIAIg4gDiADIAFBAnRqKgIAIhEgAyAFIAFqQQJ0aioCACISkiAD\nIAVBAXQgAWpBAnRqKgIAIgaSkkMAAIA+lCIOkyIHIAeUIA0gCZMiDSANlCAGIA6TIgYgBpQgDCAJ\nkyIMIAyUIBIgDpMiEiASlCAQIAmTIhAgEJQgCyALlCARIA6TIhEgEZSSkpKSkpKSlZEiC5S7IBEg\nC5S7IBAgC5S7IBIgC5S7IAwgC5S7IAYgC5S7IA0gC5S7IAcgC5S7ELWAgIAAIAAoAgAiAyAAQRRq\nKAIAIgVBAXQiAiAAKAIQIgFBAXQiCGpBAnRqKgIAIRAgAyAIIAVqQQJ0aiIIKgIAIQcgAyACIAFq\nQQJ0aiICKgIAIREgAyAFQQN0aiITKgIAIRQgAyAFIAFqIhVBAnRqIhYqAgAhBiADIAVBAnRqIgUq\nAgAhDCADIAFBAnRqIhcqAgAhEiADIAQgCSADIAFBA3RqIgEqAgAiDZQgAyoCACIYQwAAgD8gC5Ui\n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\nCSAOIBKUIAsgE5SSkiAUlTgCACAEIAxqIQQgBSARaiEFIANBf2oiAw0ACwsgAA8LIABBACoCgIiA\ngAAQm4CAgAALC84PAwBBgAgLig8AAPh/T3V0IG9mIG1lbW9yeSEARG91YmxlIGZyZWUAQXNzZXJ0\naW9uIGZhaWxlZCBhdCBtYXQzMi5jOjYxAE91dCBvZiBtZW1vcnkgYXQgbWF0MzIuYzo2MwBBc3Nl\ncnRpb24gZmFpbGVkIGF0IG1hdDMyLmM6ODQAT3V0IG9mIG1lbW9yeSBhdCBtYXQzMi5jOjg2AE91\ndCBvZiBtZW1vcnkgYXQgbWF0MzIuYzo4OQBPdXQgb2YgbWVtb3J5IGF0IG1hdDMyLmM6MTM2AAAA\nwAsAAAEAAAAAAAAAAAAAAAEAAAABAAAAAgAAAERvdWJsZSBmcmVlIGF0IG1hdDMyLmM6MTQ5AEFz\nc2VydGlvbiBmYWlsZWQgYXQgbWF0MzIuYzoxODQAQXNzZXJ0aW9uIGZhaWxlZCBhdCBtYXQzMi5j\nOjE4OABBc3NlcnRpb24gZmFpbGVkIGF0IG1hdDMyLmM6Mjc1AERvdWJsZSBmcmVlIGF0IG1hdDMy\nLmM6MjkAQXNzZXJ0aW9uIGZhaWxlZCBhdCBhcml0aG1ldGljMzIuYzozNgBBc3NlcnRpb24gZmFp\nbGVkIGF0IGFyaXRobWV0aWMzMi5jOjU4AEFzc2VydGlvbiBmYWlsZWQgYXQgYXJpdGhtZXRpYzMy\nLmM6ODAAQXNzZXJ0aW9uIGZhaWxlZCBhdCBhcml0aG1ldGljMzIuYzo5OQBBc3NlcnRpb24gZmFp\nbGVkIGF0IGFyaXRobWV0aWMzMi5jOjEyMQBBc3NlcnRpb24gZmFpbGVkIGF0IGFyaXRobWV0aWMz\nMi5jOjE0MwBBc3NlcnRpb24gZmFpbGVkIGF0IGFyaXRobWV0aWMzMi5jOjE2OABBc3NlcnRpb24g\nZmFpbGVkIGF0IGFyaXRobWV0aWMzMi5jOjE4OQBBc3NlcnRpb24gZmFpbGVkIGF0IGFyaXRobWV0\naWMzMi5jOjIxOABBc3NlcnRpb24gZmFpbGVkIGF0IGFyaXRobWV0aWMzMi5jOjI3MQBBc3NlcnRp\nb24gZmFpbGVkIGF0IGFyaXRobWV0aWMzMi5jOjMyMgBBc3NlcnRpb24gZmFpbGVkIGF0IGFyaXRo\nbWV0aWMzMi5jOjM1NgBBc3NlcnRpb24gZmFpbGVkIGF0IGFyaXRobWV0aWMzMi5jOjM3OABBc3Nl\ncnRpb24gZmFpbGVkIGF0IGFyaXRobWV0aWMzMi5jOjQyMABBc3NlcnRpb24gZmFpbGVkIGF0IGFy\naXRobWV0aWMzMi5jOjQzNgBBc3NlcnRpb24gZmFpbGVkIGF0IHFyMzIuYzoyNjEAQXNzZXJ0aW9u\nIGZhaWxlZCBhdCBxcjMyLmM6MjY1AEFzc2VydGlvbiBmYWlsZWQgYXQgcXIzMi5jOjI4NgBBc3Nl\ncnRpb24gZmFpbGVkIGF0IHFyMzIuYzoyOTAAQXNzZXJ0aW9uIGZhaWxlZCBhdCBxcjMyLmM6MzIx\nAEFzc2VydGlvbiBmYWlsZWQgYXQgcXIzMi5jOjMyNQBBc3NlcnRpb24gZmFpbGVkIGF0IHFyMzIu\nYzozNzkAT3V0IG9mIG1lbW9yeSBhdCBxcjMyLmM6MzYAQXNzZXJ0aW9uIGZhaWxlZCBhdCBxcjMy\nLmM6NjkAQXNzZXJ0aW9uIGZhaWxlZCBhdCBxcjMyLmM6NzMAQXNzZXJ0aW9uIGZhaWxlZCBhdCBx\ncjMyLmM6MTg0AERvdWJsZSBmcmVlIGF0IHFyMzIuYzo1NQBBc3NlcnRpb24gZmFpbGVkIGF0IHFy\nMzIuYzoxNDgAQXNzZXJ0aW9uIGZhaWxlZCBhdCBxcjMyLmM6MjI0AEFzc2VydGlvbiBmYWlsZWQg\nYXQgcXIzMi5jOjIyOABBc3NlcnRpb24gZmFpbGVkIGF0IGhvbW9ncmFwaHkzMi5jOjMyNABBc3Nl\ncnRpb24gZmFpbGVkIGF0IGhvbW9ncmFwaHkzMi5jOjM1OQBBc3NlcnRpb24gZmFpbGVkIGF0IGhv\nbW9ncmFwaHkzMi5jOjQ0NABBc3NlcnRpb24gZmFpbGVkIGF0IGhvbW9ncmFwaHkzMi5jOjUyNABB\nc3NlcnRpb24gZmFpbGVkIGF0IGhvbW9ncmFwaHkzMi5jOjI0MgBBc3NlcnRpb24gZmFpbGVkIGF0\nIHJhbnNhYzMyLmM6NzAAT3V0IG9mIG1lbW9yeSBhdCByYW5zYWMzMi5jOjgzAE91dCBvZiBtZW1v\ncnkgYXQgcmFuc2FjMzIuYzo4NwBPdXQgb2YgbWVtb3J5IGF0IHJhbnNhYzMyLmM6OTIAT3V0IG9m\nIG1lbW9yeSBhdCByYW5zYWMzMi5jOjEwNgBEb3VibGUgZnJlZSBhdCByYW5zYWMzMi5jOjIzNwBE\nb3VibGUgZnJlZSBhdCByYW5zYWMzMi5jOjI0NABEb3VibGUgZnJlZSBhdCByYW5zYWMzMi5jOjI0\nNwBEb3VibGUgZnJlZSBhdCByYW5zYWMzMi5jOjI1MABBc3NlcnRpb24gZmFpbGVkIGF0IHRyYW5z\nZm9ybTMyLmM6MzkAAEGMFwsMCAAAALALAAABAAAAAEGgFwskAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAA\n"},function(e,t,n){"use strict";n.r(t),n.d(t,"Speedy",(function(){return kn}));var i=n(1);var o=n(3),s=n(0);const r=Symbol();let A=null;class a extends class{constructor(){this._subscribers=[]}subscribe(e){this._subscribers.indexOf(e)<0&&this._subscribers.push(e)}unsubscribe(e){this._subscribers=this._subscribers.filter(t=>t!==e)}_notify(e){for(const t of this._subscribers)t(e)}}{constructor(e){if(i.a.assert(e===r),super(),"undefined"==typeof WebGL2RenderingContext)throw new s.h("This application requires WebGL2. Please use a different browser.");this._canvas=this._createCanvas(this._reinitialize.bind(this)),this._gl=this._createContext(this._canvas),this._reinitializeOnContextLoss=!0}static get instance(){return A||(A=new a(r))}get gl(){return this._gl}get canvas(){return this._canvas}_createCanvas(e){const t=i.a.createCanvas(16,16);return t.addEventListener("webglcontextlost",t=>{i.a.warning("Lost WebGL2 context"),setTimeout(e,0),t.preventDefault()},!1),t}_createContext(e){const t=e.getContext("webgl2",{premultipliedAlpha:!1,preserveDrawingBuffer:!1,alpha:!0,antialias:!1,depth:!1,stencil:!1});if(!t)throw new s.h("Can't create a WebGL2 Rendering Context. Try a different browser!");return t}_reinitialize(){this._reinitializeOnContextLoss&&(i.a.warning("Reinitializing WebGL2..."),this._canvas.remove(),this._canvas=this._createCanvas(this._reinitialize.bind(this)),this._gl=this._createContext(this._canvas),this._notify(this._gl))}loseContext(){const e=this._gl;if(e.isContextLost())return;const t=e.getExtension("WEBGL_lose_context");if(!t)throw new s.h("WEBGL_lose_context extension is unavailable");return this._reinitializeOnContextLoss=!1,t.loseContext(),t}loseAndRestoreContext(e=1){const t=1e3*Math.max(e,0),n=this.loseContext();return new o.a(e=>{setTimeout(()=>{this._reinitializeOnContextLoss=!0,this._reinitialize(),setTimeout(()=>e(n),0)},t)})}}var l=n(6);class c{constructor(e,t,n){this._gl=e,this._width=Math.max(1,0|t),this._height=Math.max(1,0|n),this._glTexture=c._createTexture(this._gl,this._width,this._height),this._hasMipmaps=!1}release(){const e=this._gl;if(null==this._glTexture)throw new s.g("The SpeedyTexture has already been released");return this.discardMipmaps(),e.deleteTexture(this._glTexture),this._glTexture=null,this._width=this._height=0,null}upload(e,t=this._width,n=this._height){return i.a.assert(t>0&&n>0),this.discardMipmaps(),this._width=t,this._height=n,c._upload(this._gl,this._glTexture,t,n,e,0),this}clear(){const e=this._gl;return e.isContextLost()||(e.bindTexture(e.TEXTURE_2D,this._glTexture),e.texImage2D(e.TEXTURE_2D,0,e.RGBA8,this._width,this._height,0,e.RGBA,e.UNSIGNED_BYTE,null),e.bindTexture(e.TEXTURE_2D,null),this.discardMipmaps()),this}resize(e,t){const n=this._gl;if(this._width===e&&this._height===t)return this;if(t|=0,(e|=0)>l.MAX_TEXTURE_LENGTH||t>l.MAX_TEXTURE_LENGTH)throw new s.h(`Maximum texture size exceeded. Using ${e} x ${t}, expected up to ${l.MAX_TEXTURE_LENGTH} x ${l.MAX_TEXTURE_LENGTH}.`);if(e<1||t<1)throw new s.f(`Invalid texture size: ${e} x ${t}`);return n.isContextLost()||(this._width=e,this._height=t,n.bindTexture(n.TEXTURE_2D,this._glTexture),n.texImage2D(n.TEXTURE_2D,0,n.RGBA8,e,t,0,n.RGBA,n.UNSIGNED_BYTE,null),n.bindTexture(n.TEXTURE_2D,null),this.discardMipmaps()),this}generateMipmaps(e=[]){const t=this._gl;if(this._hasMipmaps)return this;if(t.bindTexture(t.TEXTURE_2D,this._glTexture),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.NEAREST_MIPMAP_LINEAR),t.generateMipmap(t.TEXTURE_2D),t.bindTexture(t.TEXTURE_2D,null),e.length>0){const t=this.width,n=this.height,o=1+Math.floor(Math.log2(Math.max(t,n)));i.a.assert(e.length<=o);for(let o=1;o<e.length;o++){const s=Math.max(1,t>>>o),r=Math.max(1,n>>>o);i.a.assert(e[o].width===s&&e[o].height===r),e[o].copyTo(this,o)}}return this._hasMipmaps=!0,this}discardMipmaps(){const e=this._gl;this._hasMipmaps&&(e.bindTexture(e.TEXTURE_2D,this._glTexture),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),e.bindTexture(e.TEXTURE_2D,null),this._hasMipmaps=!1)}hasMipmaps(){return this._hasMipmaps}isReleased(){return null==this._glTexture}size(){return 4*this._width*this._height}get glTexture(){return this._glTexture}get width(){return this._width}get height(){return this._height}get gl(){return this._gl}static _createTexture(e,t,n){i.a.assert(t>0&&n>0);const o=e.createTexture();return e.bindTexture(e.TEXTURE_2D,o),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.MIRRORED_REPEAT),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.MIRRORED_REPEAT),e.texImage2D(e.TEXTURE_2D,0,e.RGBA8,t,n,0,e.RGBA,e.UNSIGNED_BYTE,null),e.bindTexture(e.TEXTURE_2D,null),o}static _upload(e,t,n,i,o,s=0){return e.bindTexture(e.TEXTURE_2D,t),e.texImage2D(e.TEXTURE_2D,s,e.RGBA8,n,i,0,e.RGBA,e.UNSIGNED_BYTE,o),e.bindTexture(e.TEXTURE_2D,null),t}}class d extends c{constructor(e,t,n){super(e,t,n),this._glFbo=d._createFramebuffer(e,this._glTexture)}release(){const e=this._gl;if(null==this._glFbo)throw new s.g("The SpeedyDrawableTexture has already been released");return e.deleteFramebuffer(this._glFbo),this._glFbo=null,super.release()}get glFbo(){return this._glFbo}copyTo(e,t=0){const n=this._gl;if(n.isContextLost())return;const o=1<<(t|=0),s=Math.max(1,Math.floor(e.width/o)),r=Math.max(1,Math.floor(e.height/o));i.a.assert(this._width===s&&this._height===r),d._copyToTexture(n,this._glFbo,e.glTexture,0,0,this._width,this._height,t)}clone(){const e=new c(this._gl,this._width,this._height);return this.copyTo(e),e}clear(){return this.clearToColor(0,0,0,0)}clearToColor(e,t,n,i){const o=this._gl;return o.isContextLost()||(e=Math.max(0,Math.min(+e,1)),t=Math.max(0,Math.min(+t,1)),n=Math.max(0,Math.min(+n,1)),i=Math.max(0,Math.min(+i,1)),this.discardMipmaps(),o.bindFramebuffer(o.FRAMEBUFFER,this._glFbo),o.viewport(0,0,this._width,this._height),o.clearColor(e,t,n,i),o.clear(o.COLOR_BUFFER_BIT),o.bindFramebuffer(o.FRAMEBUFFER,null)),this}static _createFramebuffer(e,t){const n=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,n),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0);const i=e.checkFramebufferStatus(e.FRAMEBUFFER);if(i!=e.FRAMEBUFFER_COMPLETE){const t=["FRAMEBUFFER_UNSUPPORTED","FRAMEBUFFER_INCOMPLETE_ATTACHMENT","FRAMEBUFFER_INCOMPLETE_DIMENSIONS","FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT","FRAMEBUFFER_INCOMPLETE_MULTISAMPLE"].filter(t=>e[t]===i)[0]||"unknown error";throw new s.e(`Can't create framebuffer: ${t} (${i})`)}return e.bindFramebuffer(e.FRAMEBUFFER,null),n}static _copyToTexture(e,t,n,i,o,s,r,A=0){return e.bindTexture(e.TEXTURE_2D,n),e.bindFramebuffer(e.FRAMEBUFFER,t),e.copyTexSubImage2D(e.TEXTURE_2D,A,0,0,i,o,s,r),e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindTexture(e.TEXTURE_2D,null),n}}var g=n(4);const h=Object.freeze({sampler2D:"uniform1i",float:"uniform1f",int:"uniform1i",uint:"uniform1ui",bool:"uniform1i",vec2:"uniform2f",vec3:"uniform3f",vec4:"uniform4f",ivec2:"uniform2i",ivec3:"uniform3i",ivec4:"uniform4i",uvec2:"uniform2ui",uvec3:"uniform3ui",uvec4:"uniform4ui",bvec2:"uniform2i",bvec3:"uniform3i",bvec4:"uniform4i",mat2:"uniformMatrix2fv",mat3:"uniformMatrix3fv",mat4:"uniformMatrix4fv"});class u extends Function{constructor(e,t,n={}){return super("...args","return this._self._call(...args)"),this._self=this.bind(this),this._self._init(e,t,n),this._self}_init(e,t,n){if(e.isContextLost())throw new s.g("Can't initialize SpeedyProgram: lost context");n=Object.assign({renderToTexture:!0,pingpong:!1},n),this._gl=e,this._program=u._compile(e,t.vertexSource,t.fragmentSource),this._geometry=new p(e,{position:t.locationOfAttributes.position,texCoord:t.locationOfAttributes.texCoord}),this._argnames=t.arguments,this._argIsArray=new Array(this._argnames.length).fill(!1),this._ubo=null,this._renderToTexture=Boolean(n.renderToTexture),this._width=1,this._height=1,this._texture=new Array(n.pingpong?2:1).fill(null),this._textureIndex=0,this._uniform=new Map,e.useProgram(this._program);for(const n of t.uniforms){const i=t.uniformType(n),o=e.getUniformLocation(this._program,n);this._uniform.set(n,new I(i,o))}for(let e=0;e<this._argnames.length;e++){const t=this._argnames[e];if(!this._uniform.has(t)&&(this._argIsArray[e]=this._uniform.has(t+"[0]"),!this._argIsArray[e]))throw new s.g(`Expected uniform "${t}", as declared in the argument list`)}}_call(...e){const t=this._gl,n=this._argnames;if(e.length!=n.length)throw new s.f(`Can't run shader: incorrect number of arguments (expected ${n.length}, got ${e.length})`);const i=e.flat();for(let e=i.length-1;e>=0;e--)if(i[e]===this._texture[this._textureIndex])throw new s.h("Can't run shader: don't use its output texture as an input to itself. Consider using pingpong rendering!");if(t.isContextLost())return this._texture[this._textureIndex];t.useProgram(this._program),t.bindVertexArray(this._geometry.vao);const o=this._texture[this._textureIndex],r=this._renderToTexture?o.glFbo:null,A=this._width,a=this._height,l=this._uniform.get("texSize");t.uniform2f(l.location,A,a);for(let i=0,o=0;i<e.length;i++){const r=n[i];if(this._argIsArray[i]){const n=e[i];if(this._uniform.has(`${r}[${n.length}]`))throw new s.f(`Can't run shader: too few elements in the "${r}" array`);for(let e=0,i=void 0;void 0!==(i=this._uniform.get(`${r}[${e}]`));e++)o=i.setValue(t,n[e],o)}else{o=this._uniform.get(r).setValue(t,e[i],o)}}return null!==this._ubo&&this._ubo.update(),t.bindFramebuffer(t.FRAMEBUFFER,r),t.viewport(0,0,A,a),t.drawArrays(t.TRIANGLES,0,6),t.bindFramebuffer(t.FRAMEBUFFER,null),t.bindVertexArray(null),null!=o&&o.discardMipmaps(),this._pingpong(),o}outputs(e,t,...n){return this._setOutputTexture(...n),this._setOutputSize(e,t),this}_setOutputSize(e,t){i.a.assert(e>0&&t>0),this._width=0|e,this._height=0|t;for(let e=0;e<this._texture.length;e++)null!=this._texture[e]&&this._texture[e].resize(this._width,this._height);return this}_setOutputTexture(...e){i.a.assert(e.length===this._texture.length,`Incorrect number of textures (expected ${this._texture.length})`);for(let t=0;t<this._texture.length;t++)this._texture[t]=e[t];return this._textureIndex=0,this}clear(){const e=this._texture[this._textureIndex];for(let e=0;e<this._texture.length;e++)this._texture[e].clear();return this._pingpong(),e}setUBO(e,t){null===this._ubo&&(this._ubo=new f(this._gl,this._program)),this._ubo.set(e,t)}release(){const e=this._gl;return null!=this._ubo&&(this._ubo=this._ubo.release()),this._texture.fill(null),this._geometry=this._geometry.release(),e.deleteProgram(this._program),this._program=null,null}_pingpong(){this._texture.length>1&&(this._textureIndex=1-this._textureIndex)}static _compile(e,t,n){const i=e.createProgram(),o=e.createShader(e.VERTEX_SHADER),r=e.createShader(e.FRAGMENT_SHADER);if(e.shaderSource(o,t),e.compileShader(o),e.attachShader(i,o),e.shaderSource(r,n),e.compileShader(r),e.attachShader(i,r),e.linkProgram(i),e.validateProgram(i),!e.getProgramParameter(i,e.LINK_STATUS)&&!e.isContextLost()){const t=[e.getShaderInfoLog(r),e.getShaderInfoLog(o),e.getProgramInfoLog(i)];e.deleteProgram(i),e.deleteShader(r),e.deleteShader(o);const A=e=>Math.max(0,2-Math.floor(Math.log10(e))),a=e=>Array(A(e)).fill(" ").join("")+e+". ",l=n.split("\n").map((e,t)=>a(1+t)+e).join("\n");throw new s.e("Can't create shader.\n\n---------- ERROR ----------\n"+t.join("\n")+"\n\n---------- SOURCE CODE ----------\n"+l)}return i}}function p(e,t){return this.vao=e.createVertexArray(),this.vbo=Object.freeze({position:e.createBuffer(),texCoord:e.createBuffer()}),this._gl=e,e.bindVertexArray(this.vao),e.bindBuffer(e.ARRAY_BUFFER,this.vbo.position),e.bufferData(e.ARRAY_BUFFER,new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]),e.STATIC_DRAW),e.enableVertexAttribArray(t.position),e.vertexAttribPointer(t.position,2,e.FLOAT,!1,0,0),e.bindBuffer(e.ARRAY_BUFFER,this.vbo.texCoord),e.bufferData(e.ARRAY_BUFFER,new Float32Array([0,0,1,0,0,1,0,1,1,0,1,1]),e.STATIC_DRAW),e.enableVertexAttribArray(t.texCoord),e.vertexAttribPointer(t.texCoord,2,e.FLOAT,!1,0,0),e.bindBuffer(e.ARRAY_BUFFER,null),e.bindVertexArray(null),Object.freeze(this)}function I(e,t){if(this.type=String(e),!Object.prototype.hasOwnProperty.call(h,this.type))throw new s.h("Unsupported uniform type: "+this.type);this.location=t,this.setter=h[this.type];const n=0|Number(this.setter.match(/^uniform(Matrix)?(\d)/)[2]);return this.dim=this.type.startsWith("mat")?2:this.type.indexOf("vec")>=0|0,this.length=2==this.dim?n*n:n,Object.freeze(this)}function f(e,t){this._gl=e,this._program=t,this._nextIndex=0,this._ubo=Object.create(null)}p.prototype.release=function(){const e=this._gl;return e.deleteVertexArray(this.vao),e.deleteBuffer(this.vbo.position),e.deleteBuffer(this.vbo.texCoord),null},I.prototype.setValue=function(e,t,n){const i=e[this.setter];if("sampler2D"==this.type){if(n>e.MAX_COMBINED_TEXTURE_IMAGE_UNITS)throw new s.h(`Can't bind ${n} textures to a program: max is ${e.MAX_COMBINED_TEXTURE_IMAGE_UNITS}`);if(null==t)throw new s.f("Can't run shader: cannot use null as an input texture");e.activeTexture(e.TEXTURE0+n),e.bindTexture(e.TEXTURE_2D,t.glTexture),e.uniform1i(this.location,n),n++}else if("number"==typeof t||"boolean"==typeof t)i.call(e,this.location,t);else{if(!Array.isArray(t))throw new s.f(`Can't run shader: unrecognized argument "${t}"`);if(t.length!==this.length)throw new s.f(`Can't run shader: incorrect number of values for ${this.type}: "${t}"`);2==this.dim?i.call(e,this.location,!1,t):i.call(e,this.location,...t)}return n},f.prototype.set=function(e,t){const n=this._gl;void 0===this._ubo[e]&&(this._ubo[e]={buffer:n.createBuffer(),blockBindingIndex:this._nextIndex++,blockIndex:null,data:null});const i=this._ubo[e];if(null===i.blockIndex){const t=n.getUniformBlockIndex(this._program,e);n.uniformBlockBinding(this._program,t,i.blockBindingIndex),i.blockIndex=t}i.data=t},f.prototype.update=function(){const e=this._gl;for(const t in this._ubo){const n=this._ubo[t];e.bindBuffer(e.UNIFORM_BUFFER,n.buffer),e.bufferData(e.UNIFORM_BUFFER,n.data.byteLength,e.DYNAMIC_DRAW),e.bufferData(e.UNIFORM_BUFFER,n.data,e.DYNAMIC_DRAW),e.bindBufferBase(e.UNIFORM_BUFFER,n.blockBindingIndex,n.buffer),e.bindBuffer(e.UNIFORM_BUFFER,null)}},f.prototype.release=function(){const e=this._gl;for(const t in this._ubo){const n=this._ubo[t];e.deleteBuffer(n.buffer),n.data=null}return null};const m={usesPingpongRendering:()=>({pingpong:!0}),rendersToCanvas:()=>({renderToTexture:!1})};class C{constructor(e){this._gpu=e,this._programs=[]}declare(e,t,n={}){return Object.defineProperty(this,e,{get:(()=>{const i=Symbol(e);return function(){return this[i]||(this[i]=this._createProgram(t,n))}.bind(this)})()}),this}get program(){return m}release(){for(let e=0;e<this._programs.length;e++)this._programs[e].release();return null}_createProgram(e,t={}){const n=new u(this._gpu.gl,e,t);return this._programs.push(n),n}}const E=Object(g.b)("utils/identity.glsl").withArguments("image"),x=Object(g.b)("utils/flip-y.glsl").withArguments("image"),_=Object(g.b)("utils/fill.glsl").withArguments("value"),y=Object(g.b)("utils/fill-components.glsl").withArguments("image","pixelComponents","value"),P=Object(g.b)("utils/copy-components.glsl").withArguments("dest","src","destComponents","srcComponentId"),S=Object(g.b)("utils/scan-minmax2d.glsl").withArguments("image","iterationNumber"),B=Object(g.b)("utils/sobel-derivatives.glsl").withArguments("pyramid","lod");class Q extends C{constructor(e){super(e),this.declare("identity",E).declare("renderToCanvas",x,{...this.program.rendersToCanvas()}).declare("fill",_).declare("fillComponents",y).declare("copyComponents",P).declare("scanMinMax2D",S,{...this.program.usesPingpongRendering()}).declare("sobelDerivatives",B)}}var w=n(7);const v=Object(g.b)("filters/rgb2grey.glsl").withArguments("image"),M=[3,5,7].reduce((e,t)=>(e[t]=Object(g.b)("filters/convolution2d.glsl").withDefines({KERNEL_SIZE_SQUARED:t*t}).withArguments("image","kernel"),e),{}),b=[3,5,7,9,11,13,15].reduce((e,t)=>(e[t]=Object(g.b)("filters/convolution1d.glsl").withDefines({KERNEL_SIZE:t,AXIS:0}).withArguments("image","kernel"),e),{}),D=[3,5,7,9,11,13,15].reduce((e,t)=>(e[t]=Object(g.b)("filters/convolution1d.glsl").withDefines({KERNEL_SIZE:t,AXIS:1}).withArguments("image","kernel"),e),{}),X=[3,5,7].reduce((e,t)=>(e[t]=Object(g.b)("filters/fast-median.glsl").withDefines({KERNEL_SIZE:t}).withArguments("image"),e),{}),L=Object(g.b)("filters/normalize-image.glsl").withDefines({GREYSCALE:1}).withArguments("minmax2d","minValue","maxValue"),R=Object(g.b)("filters/normalize-image.glsl").withDefines({GREYSCALE:0}).withArguments("minmax2dRGB","minValue","maxValue"),k=Object(g.b)("filters/nightvision.glsl").withDefines({GREYSCALE:0}).withArguments("image","illuminationMap","gain","offset","decay"),K=Object(g.b)("filters/nightvision.glsl").withDefines({GREYSCALE:1}).withArguments("image","illuminationMap","gain","offset","decay"),N=e=>i.a.gaussianKernel((e=>Math.max(1,e/6))(e),e),F=e=>new Array(e).fill(1/e);class O extends C{constructor(e){super(e),this.declare("rgb2grey",v).declare("median3",X[3]).declare("median5",X[5]).declare("median7",X[7]).declare("convolution3",M[3]).declare("convolution5",M[5]).declare("convolution7",M[7]).declare("convolution3x",b[3]).declare("convolution3y",D[3]).declare("convolution5x",b[5]).declare("convolution5y",D[5]).declare("convolution7x",b[7]).declare("convolution7y",D[7]).declare("convolution9x",b[9]).declare("convolution9y",D[9]).declare("convolution11x",b[11]).declare("convolution11y",D[11]).declare("convolution13x",b[13]).declare("convolution13y",D[13]).declare("convolution15x",b[15]).declare("convolution15y",D[15]).declare("normalizeGreyscale",L).declare("normalizeColored",R).declare("nightvision",k).declare("nightvisionGreyscale",K).declare("illuminationMapLoX",Object(w.convX)(i.a.gaussianKernel(80,31))).declare("illuminationMapLoY",Object(w.convY)(i.a.gaussianKernel(80,31))).declare("illuminationMapX",Object(w.convX)(i.a.gaussianKernel(80,63))).declare("illuminationMapY",Object(w.convY)(i.a.gaussianKernel(80,63))).declare("illuminationMapHiX",Object(w.convX)(i.a.gaussianKernel(80,255))).declare("illuminationMapHiY",Object(w.convY)(i.a.gaussianKernel(80,255))).declare("gaussian3x",Object(w.convX)([.25,.5,.25])).declare("gaussian3y",Object(w.convY)([.25,.5,.25])).declare("gaussian5x",Object(w.convX)([.05,.25,.4,.25,.05])).declare("gaussian5y",Object(w.convY)([.05,.25,.4,.25,.05])).declare("gaussian7x",Object(w.convX)(N(7))).declare("gaussian7y",Object(w.convY)(N(7))).declare("gaussian9x",Object(w.convX)(N(9))).declare("gaussian9y",Object(w.convY)(N(9))).declare("gaussian11x",Object(w.convX)(N(11))).declare("gaussian11y",Object(w.convY)(N(11))).declare("box3x",Object(w.convX)(F(3))).declare("box3y",Object(w.convY)(F(3))).declare("box5x",Object(w.convX)(F(5))).declare("box5y",Object(w.convY)(F(5))).declare("box7x",Object(w.convX)(F(7))).declare("box7y",Object(w.convY)(F(7))).declare("box9x",Object(w.convX)(F(9))).declare("box9y",Object(w.convY)(F(9))).declare("box11x",Object(w.convX)(F(11))).declare("box11y",Object(w.convY)(F(11)))}}const z=Object(g.b)("keypoints/fast.glsl").withDefines({FAST_TYPE:916}).withArguments("corners","pyramid","lod","threshold"),G=[1,3,5,7].reduce((e,t)=>(e[t]=Object(g.b)("keypoints/harris.glsl").withDefines({WINDOW_SIZE:t}).withArguments("corners","pyramid","derivatives","lod","lodStep","gaussian"),e),{}),T=Object(g.b)("keypoints/score-findmax.glsl").withArguments("corners","iterationNumber"),U=Object(g.b)("keypoints/harris-cutoff.glsl").withArguments("corners","maxScore","quality"),H=Object(g.b)("keypoints/subpixel-refinement.glsl").withDefines({METHOD:0}).withArguments("pyramid","encodedKeypoints","descriptorSize","extraSize","encoderLength","maxIterations","epsilon"),q=Object(g.b)("keypoints/subpixel-refinement.glsl").withDefines({METHOD:1}).withArguments("pyramid","encodedKeypoints","descriptorSize","extraSize","encoderLength","maxIterations","epsilon"),J=Object(g.b)("keypoints/subpixel-refinement.glsl").withDefines({METHOD:2}).withArguments("pyramid","encodedKeypoints","descriptorSize","extraSize","encoderLength","maxIterations","epsilon"),j=Object(g.b)("keypoints/subpixel-refinement.glsl").withDefines({METHOD:3}).withArguments("pyramid","encodedKeypoints","descriptorSize","extraSize","encoderLength","maxIterations","epsilon"),Y=Object(g.b)("keypoints/refine-scale.glsl").withDefines({METHOD:0}).withArguments("pyramid","lodStep","encodedKeypoints","descriptorSize","extraSize","encoderLength"),W=Object(g.b)("keypoints/refine-scale.glsl").withDefines({METHOD:1}).withArguments("pyramid","lodStep","encodedKeypoints","descriptorSize","extraSize","encoderLength","threshold"),Z=Object(g.b)("keypoints/allocate-descriptors.glsl").withArguments("inputEncodedKeypoints","inputDescriptorSize","inputExtraSize","inputEncoderLength","outputDescriptorSize","outputExtraSize","outputEncoderLength"),V=Object(g.b)("keypoints/orb-descriptor.glsl").withArguments("pyramid","encodedCorners","extraSize","encoderLength"),$=Object(g.b)("keypoints/orb-orientation.glsl").withArguments("pyramid","encodedKeypoints","descriptorSize","extraSize","encoderLength"),ee=Object(g.b)("keypoints/nonmax-suppression.glsl").withDefines({MULTISCALE:0}).withArguments("image","lodStep"),te=Object(g.b)("keypoints/nonmax-suppression.glsl").withDefines({MULTISCALE:1}).withArguments("image","lodStep"),ne=Object(g.b)("keypoints/nonmax-space.glsl").withArguments("corners"),ie=Object(g.b)("keypoints/nonmax-scale.glsl").withDefines({USE_LAPLACIAN:1}).withArguments("corners","pyramid","pyrLaplacian","lodStep"),oe=Object(g.b)("keypoints/nonmax-scale.glsl").withDefines({USE_LAPLACIAN:0}).withArguments("corners","pyramid","lodStep"),se=Object(g.b)("keypoints/laplacian.glsl").withArguments("corners","pyramid","lodStep","lodOffset"),re=[7,9,11,13,15,21].reduce((e,t)=>(e[t]=Object(g.b)("keypoints/lk.glsl").withDefines({MAX_WINDOW_SIZE:t}).withArguments("encodedFlow","prevKeypoints","nextPyramid","prevPyramid","windowSize","level","depth","numberOfIterations","discardThreshold","epsilon","descriptorSize","extraSize","encoderLength"),e),{}),Ae=Object(g.b)("keypoints/transfer-flow.glsl").withArguments("encodedFlow","encodedKeypoints","descriptorSize","extraSize","encoderLength"),ae=Object(g.b)("keypoints/sort-createperm.glsl").withArguments("encodedKeypoints","descriptorSize","extraSize","encoderLength"),le=Object(g.b)("keypoints/sort-mergeperm.glsl").withArguments("permutation","blockSize","dblLog2BlockSize"),ce=Object(g.b)("keypoints/sort-applyperm.glsl").withArguments("permutation","maxKeypoints","encodedKeypoints","descriptorSize","extraSize"),de=Object(g.b)("keypoints/encode-keypoint-offsets.glsl").withDefines({MAX_ITERATIONS:32}).withArguments("corners","imageSize"),ge=Object(g.b)("keypoints/encode-keypoint-long-offsets.glsl").withDefines({MAX_ITERATIONS:32}).withArguments("offsetsImage","imageSize"),he=Object(g.b)("keypoints/encode-keypoint-positions.glsl").withArguments("offsetsImage","imageSize","passId","numPasses","keypointLimit","encodedKeypoints","descriptorSize","extraSize","encoderLength"),ue=Object(g.b)("keypoints/encode-keypoint-properties.glsl").withArguments("corners","encodedKeypoints","descriptorSize","extraSize","encoderLength"),pe=Object(g.b)("keypoints/encode-null-keypoints.glsl").withArguments(),Ie=Object(g.b)("keypoints/transfer-orientation.glsl").withArguments("encodedOrientations","encodedKeypoints","descriptorSize","extraSize","encoderLength"),fe=Object(g.b)("keypoints/discard-descriptors.glsl").withArguments("encodedKeypoints","descriptorSize","extraSize","encoderLength","newEncoderLength"),me=Object(g.b)("keypoints/upload-keypoints.glsl").withDefines({BUFFER_SIZE:1024}).withArguments("encodedKeypoints","startIndex","endIndex","descriptorSize","extraSize","encoderLength"),Ce=Object(g.b)("keypoints/mix-keypoints.glsl").withArguments("encodedKeypoints","encoderLength","encoderCapacity","descriptorSize","extraSize","outEncoderLength"),Ee=Object(g.b)("keypoints/apply-homography.glsl").withArguments("homography","encodedKeypoints","descriptorSize","extraSize","encoderLength");class xe extends C{constructor(e){super(e),this.declare("fast9_16",z,{...this.program.usesPingpongRendering()}).declare("harris1",G[1],{...this.program.usesPingpongRendering()}).declare("harris3",G[3],{...this.program.usesPingpongRendering()}).declare("harris5",G[5],{...this.program.usesPingpongRendering()}).declare("harris7",G[7],{...this.program.usesPingpongRendering()}).declare("harrisScoreFindMax",T,{...this.program.usesPingpongRendering()}).declare("harrisScoreCutoff",U).declare("subpixelQuadratic1d",H).declare("subpixelTaylor2d",q).declare("subpixelBicubic",j).declare("subpixelBilinear",J).declare("refineScaleLoG",Y).declare("refineScaleFAST916",W).declare("allocateDescriptors",Z).declare("orbDescriptor",V).declare("orbOrientation",$).declare("nonmax",ee).declare("pyrnonmax",te).declare("nonmaxSpace",ne).declare("nonmaxScale",ie).declare("nonmaxScaleSimple",oe).declare("laplacian",se).declare("lk21",re[21],{...this.program.usesPingpongRendering()}).declare("lk15",re[15],{...this.program.usesPingpongRendering()}).declare("lk13",re[13],{...this.program.usesPingpongRendering()}).declare("lk11",re[11],{...this.program.usesPingpongRendering()}).declare("lk9",re[9],{...this.program.usesPingpongRendering()}).declare("lk7",re[7],{...this.program.usesPingpongRendering()}).declare("transferFlow",Ae).declare("sortCreatePermutation",ae).declare("sortMergePermutation",le,{...this.program.usesPingpongRendering()}).declare("sortApplyPermutation",ce).declare("encodeKeypointSkipOffsets",de).declare("encodeKeypointLongSkipOffsets",ge,{...this.program.usesPingpongRendering()}).declare("encodeKeypointPositions",he,{...this.program.usesPingpongRendering()}).declare("encodeKeypointProperties",ue).declare("encodeNullKeypoints",pe).declare("transferOrientation",Ie).declare("discardDescriptors",fe).declare("uploadKeypoints",me,{...this.program.usesPingpongRendering()}).declare("mixKeypoints",Ce).declare("applyHomography",Ee)}}const _e=Object(g.b)("pyramids/upsample2.glsl").withArguments("image"),ye=Object(g.b)("pyramids/downsample2.glsl").withArguments("image");class Pe extends C{constructor(e){super(e),this.declare("upsample2",_e).declare("downsample2",ye).declare("smoothX",Object(w.convX)([.05,.25,.4,.25,.05])).declare("smoothY",Object(w.convY)([.05,.25,.4,.25,.05])).declare("smoothX2",Object(w.convX)([.1,.5,.8,.5,.1])).declare("smoothY2",Object(w.convY)([.1,.5,.8,.5,.1],.5))}}const Se=Object(g.b)("transforms/warp-perspective.glsl").withArguments("image","inverseHomography"),Be=Object(g.b)("transforms/resize.glsl").withDefines({INTERPOLATION_METHOD:0}).withArguments("image"),Qe=Object(g.b)("transforms/resize.glsl").withDefines({INTERPOLATION_METHOD:1}).withArguments("image"),we=Object(g.b)("transforms/additive-mix.glsl").withArguments("image0","image1","alpha","beta","gamma");class ve extends C{constructor(e){super(e),this.declare("warpPerspective",Se).declare("resizeNearest",Be).declare("resizeBilinear",Qe).declare("additiveMix",we)}}class Me{constructor(e){this._gpu=e,this._filters=null,this._transforms=null,this._pyramids=null,this._keypoints=null,this._utils=null}get filters(){return this._filters||(this._filters=new O(this._gpu))}get transforms(){return this._transforms||(this._transforms=new ve(this._gpu))}get pyramids(){return this._pyramids||(this._pyramids=new Pe(this._gpu))}get keypoints(){return this._keypoints||(this._keypoints=new xe(this._gpu))}get utils(){return this._utils||(this._utils=new Q(this._gpu))}release(){for(const e in this)Object.prototype.hasOwnProperty.call(this,e)&&null!=this[e]&&this[e]instanceof C&&this[e].release();return null}}const be=Symbol("Bucket");class De{constructor(e,t,n){this.texture=e,this.index=t,this.next=n,this.free=!0}}class Xe{constructor(e,t=256){i.a.assert(t>0),this._bucket=Array.from({length:t},(e,t)=>new De(null,t,t-1)),this._head=t-1,this._gpu=e}allocate(){if(this._head<0)throw new s.i(`Exhausted pool (capacity: ${this._bucket.length})`);const e=this._bucket[this._head];return e.free=!1,this._head=e.next,null==e.texture&&(e.texture=Xe._createManagedTexture(this._gpu.gl,e)),e.texture}free(e){const t=e[be];return i.a.assert(void 0!==t&&!t.free,"Unmanaged texture or double free"),t.next=this._head,t.free=!0,this._head=t.index,null}release(){for(let e=0;e<this._bucket.length;e++)null!=this._bucket[e].texture&&(this._bucket[e].texture=this._bucket[e].texture.release());return null}static _createManagedTexture(e,t){const n=new d(e,1,1);return Object.defineProperty(n,be,{configurable:!1,enumerable:!1,writable:!1,value:t})}}var Le=n(5);class Re{constructor(){this._data=null,this._width=0,this._height=0}static load(e){const t=e.constructor.name;if("HTMLImageElement"==t)return(new ke)._load(e);if("HTMLVideoElement"==t)return(new Ke)._load(e);if("HTMLCanvasElement"==t)return(new Ne)._load(e);if("ImageBitmap"==t)return(new Fe)._load(e);throw new s.f("Unsupported media type: "+e)}get data(){return this._data}get width(){return this._width}get height(){return this._height}isLoaded(){return null!==this._data}get type(){throw new s.a}clone(){throw new s.a}_load(){throw new s.a}_waitUntil(e,t,n=3e4){return new o.a((o,r)=>{i.a.log(`Waiting for ${t} to be triggered in ${e}...`);const A=setTimeout(()=>{r(new s.k(`${t} has not been triggered in ${e}: timeout (${n}ms)`))},n);e.addEventListener(t,()=>{clearTimeout(A),o(e)},!1)})}}class ke extends Re{get type(){return Le.d.Image}clone(){if(null==this._data)throw new s.g("Media not loaded");const e=this._data.cloneNode(!0);return(new ke)._load(e)}_load(e){return e.complete&&0!==e.naturalWidth?o.a.resolve().then(()=>(this._data=e,this._width=e.naturalWidth,this._height=e.naturalHeight,this)):this._waitUntil(e,"load").then(()=>(this._data=e,this._width=e.naturalWidth,this._height=e.naturalHeight,this))}}class Ke extends Re{get type(){return Le.d.Video}clone(){if(null==this._data)throw new s.g("Media not loaded");const e=this._data.cloneNode(!0);return(new Ke)._load(e)}_load(e){return e.readyState>=4?o.a.resolve().then(()=>(this._data=e,this._width=e.videoWidth,this._height=e.videoHeight,this)):this._waitUntil(e,"canplaythrough").then(()=>(this._data=e,this._width=e.videoWidth,this._height=e.videoHeight,this))}}class Ne extends Re{get type(){return Le.d.Canvas}clone(){if(null==this._data)throw new s.g("Media not loaded");const e=i.a.createCanvas(this._width,this._height);return e.getContext("2d").draw(this._data,0,0),(new Ne)._load(e)}_load(e){return o.a.resolve().then(()=>(this._data=e,this._width=e.width,this._height=e.height,this))}}class Fe extends Re{get type(){return Le.d.Bitmap}clone(){if(null==this._data)throw new s.g("Media not loaded");const e=new Fe;return createImageBitmap(this._data).then(t=>e._load(t))}_load(e){return o.a.resolve().then(()=>(this._data=e,this._width=e.width,this._height=e.height,this))}}class Oe{constructor(e){this._gpu=e,this._texture=new Array(2).fill(null),this._textureIndex=0}upload(e,t=null){const n=this._gpu.gl,i=e.data;if(null==t&&null==this._texture[0])for(let t=0;t<this._texture.length;t++)this._texture[t]=new c(n,e.width,e.height);return"HTMLVideoElement"==i.constructor.name&&i.readyState<2?t||this._texture[this._textureIndex]:null!=t?t.upload(i,e.width,e.height):(this._textureIndex=(this._textureIndex+1)%2,this._texture[this._textureIndex].upload(i,e.width,e.height))}release(){for(let e=0;e<this._texture.length;e++)null!=this._texture[e]&&(this._texture[e]=this._texture[e].release());return null}}class ze{constructor(){this._speedyGL=a.instance,this._programs=new Me(this),this._texturePool=new Xe(this),this._textureUploader=new Oe(this),this._speedyGL.subscribe(this._reset=this._reset.bind(this))}get programs(){return this._programs}get gl(){return this._speedyGL.gl}get canvas(){return this._speedyGL.canvas}get texturePool(){return this._texturePool}renderToCanvas(e){const t=e.width,n=e.height,o=this.canvas;return(t>o.width||n>o.height)&&(i.a.warning(`Resizing the canvas to ${t} x ${n}`),o.width=t,o.height=n),this.programs.utils.renderToCanvas.outputs(t,n,null),this.programs.utils.renderToCanvas(e),o}upload(e,t=null){return this._textureUploader.upload(e,t)}release(){return i.a.assert(!this.isReleased()),this._programs=this._programs.release(),this._texturePool=this._texturePool.release(),this._textureUploader=this._textureUploader.release(),this._speedyGL.unsubscribe(this._reset),null}isReleased(){return null==this._programs}loseAndRestoreWebGLContext(){return this._speedyGL.loseAndRestoreContext().then(()=>{})}_reset(){this.isReleased()||(this._programs=new Me(this),this._texturePool=new Xe(this),this._textureUploader=new Oe(this))}}class Ge{constructor(e,t={},n=Le.b.RGB){i.a.assert(e.isLoaded()),this._source=e,this._options=Object.freeze(t),this._colorFormat=n,this._gpu=t.lightweight?Object.create(null):new ze}static load(e,t={}){return Re.load(e).then(n=>{i.a.assert(0!==n.width&&0!==n.height);const o=new Ge(n,t);return i.a.log(`Loaded SpeedyMedia with a ${e}.`),o})}static loadCameraStream(e,t,n={},o={}){return i.a.requestCameraStream(e,t,n).then(e=>Ge.load(e,o))}get source(){return this._source.data}get width(){return this._source.width}get height(){return this._source.height}get type(){switch(this._source.type){case Le.d.Image:return"image";case Le.d.Video:return"video";case Le.d.Canvas:return"canvas";case Le.d.Bitmap:return"bitmap";default:return"unknown"}}get options(){return this._options}release(){return this.isReleased()||(i.a.log("Releasing SpeedyMedia object..."),this._gpu=this._gpu.release()),null}isReleased(){return null==this._gpu}clone(){if(this.isReleased())throw new s.g("Can't clone a SpeedyMedia that has been released");const e=new Ge(this._source,this._options,this._colorFormat);return o.a.resolve(e)}draw(e,t=0,n=0,i=this.width,o=this.height){if(this.isReleased())return;i=Math.max(+i,0),o=Math.max(+o,0),e.getContext("2d").drawImage(this._source.data,+t,+n,i,o)}toBitmap(){if(this.isReleased())throw new s.g("Can't convert SpeedyMedia to ImageBitmap: the media has been released");if(!this._source.isLoaded())throw new s.g("Can't convert SpeedyMedia to bitmap: the media hasn't been loaded");return new o.a((e,t)=>createImageBitmap(this._source.data).then(e,t))}_upload(){return this._gpu.upload(this._source)}}let Te=null;class Ue{constructor(){if(this._fps=60,this._frames=0,this._updateInterval=500,this._lastUpdate=performance.now(),this._boundUpdate=this._update.bind(this),null!==Te)throw new s.g("Can't have multiple instances of FPSCounter");this._boundUpdate()}static get instance(){return null===Te&&(Te=new Ue),Te}get fps(){return this._fps}_update(){const e=performance.now(),t=e-this._lastUpdate;t>=this._updateInterval&&(this._fps=Math.round(this._frames/(.001*t)),this._frames=0,this._lastUpdate=e),this._frames++,requestAnimationFrame(this._boundUpdate)}}class He{constructor(e,t){this._x=+e,this._y=+t}get x(){return this._x}set x(e){this._x=+e}get y(){return this._y}set y(e){this._y=+e}toString(){return`SpeedyVector2(${this.x.toFixed(5)}, ${this.y.toFixed(5)})`}equals(e){return this.x===e.x&&this.y===e.y}dot(e){return this.x*e.x+this.y*e.y}distanceTo(e){const t=this.x-e.x,n=this.y-e.y;return Math.sqrt(t*t+n*n)}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}normalized(){const e=this.length();return e>0?new He(this.x/e,this.y/e):new He(0,0)}plus(e){return new He(this.x+e.x,this.y+e.y)}minus(e){return new He(this.x-e.x,this.y-e.y)}times(e){return new He(this.x*e,this.y*e)}}class qe{constructor(e,t){this._x=+e,this._y=+t}get x(){return this._x}set x(e){this._x=+e}get y(){return this._y}set y(e){this._y=+e}toString(){return`SpeedyPoint2(${this.x.toFixed(5)}, ${this.y.toFixed(5)})`}plus(e){return new qe(this.x+e.x,this.y+e.y)}minus(e){return new He(this.x-e.x,this.y-e.y)}equals(e){return this.x===e.x&&this.y===e.y}}class Je{constructor(e,t){this._width=Math.max(0,+e),this._height=Math.max(0,+t)}get width(){return this._width}set width(e){this._width=Math.max(0,+e)}get height(){return this._height}set height(e){this._height=Math.max(0,+e)}toString(){return`SpeedySize(${this.width}, ${this.height})`}equals(e){return this.width===e.width&&this.height===e.height}area(){return this.width*this.height}}n(8);var je=n(2),Ye=n(9);const We=Object.freeze({Nothing:Symbol("Nothing"),Image:Symbol("Image"),Keypoints:Symbol("Keypoints"),Vector2:Symbol("Vector2")});class Ze{constructor(e){this._type=e}get type(){return this._type}hasType(e){return this._type===e}isEmpty(){return this.hasType(We.Nothing)}toString(){return"message of type "+Object.keys(We).find(e=>We[e]===this.type)}set(...e){throw new s.a}static create(e){return function(e){return new $e[e]}(e)}}class Ve extends Ze{constructor(){super(We.Nothing)}set(){return this}}const $e=Object.freeze({[We.Nothing]:Ve,[We.Image]:class extends Ze{constructor(){super(We.Image),this._image=null,this._format=Le.c.RGBA}set(e,t=Le.c.RGBA){return this._image=e,this._format=t,this}get image(){return this._image}get format(){return this._format}},[We.Keypoints]:class extends Ze{constructor(){super(We.Keypoints),this._encodedKeypoints=null,this._descriptorSize=0,this._extraSize=0,this._encoderLength=1}set(e,t,n,o){return this._encodedKeypoints=e,this._descriptorSize=0|t,this._extraSize=0|n,this._encoderLength=0|o,i.a.assert(this._descriptorSize>=0&&this._extraSize>=0),i.a.assert(this._encoderLength===this._encodedKeypoints.width,"Invalid encoderLength"),i.a.assert(this._encodedKeypoints.width===this._encodedKeypoints.height,"Invalid encodedKeypoints texture"),this}get encodedKeypoints(){return this._encodedKeypoints}get descriptorSize(){return this._descriptorSize}get extraSize(){return this._extraSize}get encoderLength(){return this._encoderLength}hasDescriptors(){return this._descriptorSize>0}hasMatches(){return this._extraSize>0}},[We.Vector2]:class extends Ze{constructor(){super(We.Vector2),this._vectors=null}set(e){return this._vectors=e,this}get vectors(){return this._vectors}}});const et=e=>!0;class tt{constructor(e,t=et){this._expectedMessageType=e,this._isValidMessage="function"==typeof t?t:et,i.a.assert(this._expectedMessageType!=We.Nothing)}isCompatibleWith(e){return this._expectedMessageType==e._expectedMessageType}accepts(e){return e.hasType(this._expectedMessageType)&&this._isValidMessage(e)}toString(){return`Port expects ${Object.keys(We).find(e=>We[e]===this._expectedMessageType)} satisfying ${this._isValidMessage}`}get expectedMessageType(){return this._expectedMessageType}}const nt=/^[a-z][a-zA-Z0-9]*$/,it=new Ve;class ot{constructor(e,t,n){this._name=String(e),this._spec=t,this._node=n,this._message=it,i.a.assert(nt.test(this._name),`Port name "${this._name}" is not acceptable`)}get name(){return this._name}get node(){return this._node}connectTo(e){throw new s.a}isInputPort(){throw new s.a}isOutputPort(){return!this.isInputPort()}clearMessage(){this._message=it}hasMessage(){return!this._message.isEmpty()}read(){if(this._message.isEmpty())throw new s.g(`Can't read from port ${this.name}: nothing to read`);return this._message}write(e){throw new s.h(`Can't write ${e} to port ${this.name}: unsupported operation`)}static get DEFAULT_NAME(){throw new s.a}}class st extends ot{constructor(e,t,n){super(e,t,n),this._cachedMessage=null}connectTo(e){if(!e.isInputPort())throw new s.f(`Can't connect output port ${this.name} to port ${e.name}: expected an input port`);e.connectTo(this)}isInputPort(){return!1}write(e){if(!this._spec.accepts(e))throw new s.f(`Can't write ${e} to port ${this.name}. ${this._spec}`);this._message=e}swrite(...e){null==this._cachedMessage&&(this._cachedMessage=Ze.create(this._spec.expectedMessageType)),this.write(this._cachedMessage.set(...e))}static get DEFAULT_NAME(){return"out"}}class rt extends ot{constructor(e,t,n){super(e,t,n),this._incomingLink=null}get incomingLink(){return this._incomingLink}connectTo(e){if(!e.isOutputPort())throw new s.f(`Can't connect input port ${this.name} to port ${e.name}: expected an output port`);if(!this._spec.isCompatibleWith(e._spec))throw new s.f(`Can't connect ports ${this.name} and ${e.name}: incompatible types`);this._incomingLink=e}disconnect(){this._incomingLink=null}isInputPort(){return!0}pullMessage(e=""){const t=e.length>0?`${this.name} of ${e}`:this.name;if(null==this._incomingLink)throw new s.g("No incoming link for input port "+t);const n=this._incomingLink.read();if(!this._spec.accepts(n))throw new s.f(`Can't receive ${n} at port ${t}: ${this._spec}`);return this._message=n}static get DEFAULT_NAME(){return"in"}}class At{constructor(e,t){this._class=e,this._name=String(t),this._type=We.Nothing,this._messageConstraint=void 0}expects(e){return i.a.assert(this._type==We.Nothing),i.a.assert(e!=We.Nothing),this._type=e,this}satisfying(e){return i.a.assert(this._type!=We.Nothing,"You must first declare what type of message this port expects"),i.a.assert(void 0===this._messageConstraint),i.a.assert("function"==typeof e),this._messageConstraint=e,this}build(e){const t=new tt(this._type,this._messageConstraint);return Reflect.construct(this._class,[this._name,t,e])}}function at(e=rt.DEFAULT_NAME){return new At(rt,e)}function lt(e=st.DEFAULT_NAME){return new At(st,e)}const ct=navigator.userAgent.includes("Firefox");class dt{static getError(e){const t=e.getError(),n=["NO_ERROR","INVALID_ENUM","INVALID_VALUE","INVALID_OPERATION","INVALID_FRAMEBUFFER_OPERATION","OUT_OF_MEMORY","CONTEXT_LOST_WEBGL"].find(n=>e[n]==t)||"Unknown";return new s.e(n)}static getBufferSubDataAsync(e,t,n,i,o,r=0,A=0){const a=e.fenceSync(e.SYNC_GPU_COMMANDS_COMPLETE,0);return e.flush(),this.clientWaitAsync(e,a).then(()=>(e.bindBuffer(n,t),e.getBufferSubData(n,i,o,r,A),e.bindBuffer(n,null),0)).catch(e=>{throw new s.g("Can't getBufferSubDataAsync(): error in clientWaitAsync()",e)}).finally(()=>{e.deleteSync(a)})}static clientWaitAsync(e,t,n=0){return new o.a((i,o)=>{this._checkStatus(e,t,n,i,o)})}static _checkStatus(e,t,n,i,o){const s=e.clientWaitSync(t,n,0);s==e.TIMEOUT_EXPIRED?setTimeout(dt._checkStatus,0,e,t,n,i,o):s==e.WAIT_FAILED?ct&&e.getError()==e.NO_ERROR?setTimeout(dt._checkStatus,0,e,t,n,i,o):o(dt.getError(e)):i()}}class gt{constructor(e=1){i.a.assert(e>0),this._pixelBuffer=new Array(e).fill(null).map(()=>new Uint8Array(0)),this._consumerQueue=new Array(e).fill(0).map((e,t)=>t),this._producerQueue=[]}readPixelsSync(e,t=0,n=0,i=e.width,o=e.height){const s=e.gl,r=e.glFbo;i=Math.max(0,Math.min(i,e.width)),o=Math.max(0,Math.min(o,e.height)),t=Math.max(0,Math.min(t,e.width-i)),n=Math.max(0,Math.min(n,e.height-o));const A=i*o*4;return this._reallocate(A),s.isContextLost()||(s.bindFramebuffer(s.FRAMEBUFFER,r),s.readPixels(t,n,i,o,s.RGBA,s.UNSIGNED_BYTE,this._pixelBuffer[0]),s.bindFramebuffer(s.FRAMEBUFFER,null)),this._pixelBuffer[0].subarray(0,A)}readPixelsAsync(e,t=0,n=0,i=e.width,s=e.height,r=!1){const A=e.gl,a=e.glFbo;i=Math.max(0,Math.min(i,e.width)),s=Math.max(0,Math.min(s,e.height)),t=Math.max(0,Math.min(t,e.width-i)),n=Math.max(0,Math.min(n,e.height-s));const l=i*s*4;if(this._reallocate(l),A.isContextLost())return o.a.resolve(this._pixelBuffer[0].subarray(0,l));if(!r)return gt._readPixelsViaPBO(A,this._pixelBuffer[0],a,t,n,i,s).then(()=>this._pixelBuffer[0].subarray(0,l));if(this._producerQueue.length>0){const e=this._producerQueue.shift();gt._readPixelsViaPBO(A,this._pixelBuffer[e],a,t,n,i,s).then(()=>{this._consumerQueue.push(e)})}else this._waitForQueueNotEmpty(this._producerQueue).then(()=>{const e=this._producerQueue.shift();gt._readPixelsViaPBO(A,this._pixelBuffer[e],a,t,n,i,s).then(()=>{this._consumerQueue.push(e)})}).turbocharge();if(this._consumerQueue.length>0){const e=this._consumerQueue.shift();return new o.a(t=>{t(this._pixelBuffer[e].subarray(0,l)),this._producerQueue.push(e)})}return new o.a(e=>{this._waitForQueueNotEmpty(this._consumerQueue).then(()=>{const t=this._consumerQueue.shift();e(this._pixelBuffer[t].subarray(0,l)),this._producerQueue.push(t)}).turbocharge()})}_reallocate(e){if(!(e<=this._pixelBuffer[0].byteLength))for(let t=0;t<this._pixelBuffer.length;t++){const n=new Uint8Array(e);n.set(this._pixelBuffer[t]),this._pixelBuffer[t]=n}}_waitForQueueNotEmpty(e){return new o.a(t=>{!function n(){e.length>0?t():setTimeout(n,0)}()})}static _readPixelsViaPBO(e,t,n,i,o,r,A){const a=e.createBuffer();if(!(t.byteLength>=r*A*4))throw new s.f("Can't read pixels: invalid buffer size");return e.bindBuffer(e.PIXEL_PACK_BUFFER,a),e.bufferData(e.PIXEL_PACK_BUFFER,t.byteLength,e.STREAM_READ),e.bindFramebuffer(e.FRAMEBUFFER,n),e.readPixels(i,o,r,A,e.RGBA,e.UNSIGNED_BYTE,0),e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindBuffer(e.PIXEL_PACK_BUFFER,null),dt.getBufferSubDataAsync(e,a,e.PIXEL_PACK_BUFFER,0,t,0,0).catch(e=>{throw new s.g("Can't read pixels",e)}).finally(()=>{e.deleteBuffer(a)})}}const ht=e=>e.reduce((e,t)=>(e[t.name]=t,e),Object.create(null));class ut{constructor(e=(()=>Math.random().toString(16).substr(2))(),t=0,n=[]){this._name=String(e);const i=n.map(e=>e.build(this));if(this._inputPorts=ht(i.filter(e=>e.isInputPort())),this._outputPorts=ht(i.filter(e=>e.isOutputPort())),this._tex=new Array(t).fill(null),0==this._name.length)throw new s.f(`Invalid name "${this._name}" for node ${this.fullName}`);if(0==n.length)throw new s.f("No ports have been found in node "+this.fullName)}get name(){return this._name}get fullName(){return`${this.constructor.name}[${this.name}]`}input(e=rt.DEFAULT_NAME){if(e in this._inputPorts)return this._inputPorts[e];throw new s.f(`Can't find input port ${e} in node ${this.fullName}`)}output(e=st.DEFAULT_NAME){if(e in this._outputPorts)return this._outputPorts[e];throw new s.f(`Can't find output port ${e} in node ${this.fullName}`)}execute(e){let t;for(t in this._outputPorts)this._outputPorts[t].clearMessage();for(t in this._inputPorts)this._inputPorts[t].pullMessage(this.fullName);const n=this._run(e);if(null!=n)return n.then(()=>{for(t in this._outputPorts)i.a.assert(this._outputPorts[t].hasMessage(),`Did you forget to write data to the output port ${t} of ${this.fullName}?`)});for(t in this._outputPorts)i.a.assert(this._outputPorts[t].hasMessage(),`Did you forget to write data to the output port ${t} of ${this.fullName}?`)}_run(e){throw new s.a}init(e){for(let t=0;t<this._tex.length;t++)this._tex[t]=e.texturePool.allocate()}release(e){for(let t=this._tex.length-1;t>=0;t--)this._tex[t]=e.texturePool.free(this._tex[t])}clearPorts(){let e;for(e in this._inputPorts)this._inputPorts[e].clearMessage();for(e in this._outputPorts)this._outputPorts[e].clearMessage()}inputNodes(){const e=[];for(const t in this._inputPorts){const n=this._inputPorts[t];null!=n.incomingLink&&e.push(n.incomingLink.node)}return e}isSource(){return!1}isSink(){return!1}_inspect(e){this._textureReader=this._textureReader||new gt;const t=this._textureReader.readPixelsSync(e);return new Uint8Array(t)}_inspect32(e){return i.a.assert(l.LITTLE_ENDIAN),new Uint32Array(this._inspect(e).buffer)}}class pt extends ut{constructor(e,t,n){super(e,t,n),i.a.assert(0==Object.keys(this._inputPorts).length)}isSource(){return!0}}class It extends ut{constructor(e,t,n){super(e,t,n),i.a.assert(0==Object.keys(this._outputPorts).length)}export(){throw new s.a}isSink(){return!0}}class ft{constructor(e){return this._data=e,Object.freeze(this)}get data(){return this._data}get size(){return this._data.byteLength}toString(){return`SpeedyKeypointDescriptor(${this._data.join(",")})`}}class mt{constructor(e,t,n=0,i=0,o=0,s=null){return this._position=new qe(+e,+t),this._lod=+n,this._rotation=+i,this._score=+o,this._descriptor=s,Object.freeze(this)}toString(){return`SpeedyKeypoint(${this.x},${this.y})`}get position(){return this._position}get x(){return this._position.x}get y(){return this._position.y}get lod(){return this._lod}get scale(){return Math.pow(2,this._lod)}get rotation(){return this._rotation}get score(){return this._score}get descriptor(){return this._descriptor}}class Ct{constructor(){this._nodes=[],this._sequence=[],this._template=Ct._createOutputTemplate(),this._gpu=null,this._busy=!1}node(e){for(let t=0,n=this._nodes.length;t<n;t++)if(this._nodes[t].name===e)return this._nodes[t];return null}init(...e){if(this._nodes.length>0)throw new s.g("The pipeline has already been initialized");if(0==e.length)throw new s.f("Can't initialize the pipeline. Please specify its nodes");this._gpu=new ze;for(let t=0;t<e.length;t++){const n=e[t];this._nodes.includes(n)||this._nodes.push(n)}this._template=Ct._createOutputTemplate(this._nodes),this._sequence=Ct._tsort(this._nodes),Ct._validateSequence(this._sequence);for(let e=0;e<this._sequence.length;e++)this._sequence[e].init(this._gpu);return this}release(){if(0==this._nodes.length)throw new s.g("The pipeline has already been released or has never been initialized");for(let e=this._sequence.length-1;e>=0;e--)this._sequence[e].release(this._gpu);return this._sequence.length=0,this._nodes.length=0,this._gpu=this._gpu.release(),this._template=Ct._createOutputTemplate(),null}run(){if(i.a.assert(null!=this._gpu,"Pipeline has not been initialized or has been released"),this._busy)return new o.a((e,t)=>{setTimeout(()=>this.run().then(e,t),0)});this._busy=!0;const e=this._sequence.filter(e=>e.isSink());return Ct._runSequence(this._sequence,this._gpu).then(()=>o.a.all(e.map(e=>e.export())).then(t=>t.reduce((t,n,i)=>(t[e[i].name]=n,t),this._template))).then(e=>{for(let e=this._sequence.length-1;e>=0;e--)this._sequence[e].clearPorts();return this._busy=!1,e}).turbocharge()}static _runSequence(e,t,n=0,i=e.length){if(n>=i)return o.a.resolve();const s=e[n].execute(t);return t.gl.flush(),null==s?Ct._runSequence(e,t,n+1,i):s.then(()=>Ct._runSequence(e,t,n+1,i))}static _tsort(e){const t=Ct._outlinks(e),n=e.map(e=>[e,!1]),i=new Set,o=new Array(e.length);let r=o.length;for(;n.length>0;){const[e,A]=n.pop();if(A)o[--r]=e;else if(!i.has(e)){const r=t.get(e);if(i.add(e),n.push([e,!0]),n.push(...r.map(e=>[e,!1])),r.some(e=>i.has(e)&&!o.includes(e)))throw new s.g("Pipeline networks cannot have cycles!")}}return o}static _outlinks(e){const t=new Map;for(let n=0;n<e.length;n++)t.set(e[n],[]);for(let n=0;n<e.length;n++){const i=e[n],o=i.inputNodes();for(let e=0;e<o.length;e++){const n=o[e],r=t.get(n);if(!r)throw new s.g(`Can't initialize the pipeline. Missing node: ${n.fullName}. Did you forget to add it to the initialization list?`);r.includes(i)||r.push(i)}}return t}static _createOutputTemplate(e=[]){const t=Object.create(null);return e.filter(e=>e.isSink()).reduce((e,t)=>(e[t.name]=null,e),t)}static _validateSequence(e){if(0==e.length)throw new s.g("Pipeline doesn't have nodes");if(!e[0].isSource())throw new s.g("Pipeline doesn't have a source");if(!e.find(e=>e.isSink()))throw new s.g("Pipeline doesn't have a sink")}}class Et{constructor(){throw new s.a("Namespaces can't be instantiated")}}class xt extends pt{constructor(e){super(e,1,[lt().expects(We.Image)]),this._media=null}get media(){return this._media}set media(e){if(!(e instanceof Ge))throw new s.f("Not a SpeedyMedia: "+e);this._media=e}_run(e){const t=this._tex[0];if(null==this._media)throw new s.g(`Did you forget to set the media of ${this.fullName}?`);e.upload(this._media._source,t),this.output().swrite(t,Le.c.RGBA)}}class _t extends It{constructor(e="image"){super(e,0,[at().expects(We.Image)]),this._bitmap=null,this._format=Le.c.RGBA}export(){return i.a.assert(null!=this._bitmap),Re.load(this._bitmap).then(e=>new Ge(e,{lightweight:1}))}_run(e){const{image:t,format:n}=this.input().read();return new o.a(i=>{const o=e.renderToCanvas(t);createImageBitmap(o,0,o.height-t.height,t.width,t.height).then(e=>{this._bitmap=e,this._format=n,i()})})}}const yt=["in0","in1"];class Pt extends ut{constructor(e){super(e,0,[...yt.map(e=>at(e).expects(We.Image)),lt().expects(We.Image)]),this._port=0}get port(){return this._port}set port(e){if(e<0||e>=yt.length)throw new s.f("Invalid port: "+e);this._port=0|e}_run(e){const t=this.input(yt[this._port]).read();this.output().write(t)}}class St extends ut{constructor(e){super(e,2,[at().expects(We.Image),lt().expects(We.Image)]),this._pageIndex=0,this._initialized=!1,this._previousFormat=Le.c.RGBA,this._frozen=!1}get frozen(){return this._frozen}set frozen(e){this._frozen=Boolean(e)}release(e){this._initialized=!1,super.release(e)}_run(e){const{image:t,format:n}=this.input().read(),i=this._previousFormat,o=this._tex,r=o[1-this._pageIndex],A=o[this._pageIndex];if(t.hasMipmaps())throw new s.h(this.fullName+" can't bufferize a pyramid");if(this._frozen&&this._initialized||(this._previousFormat=n,r.resize(t.width,t.height),t.copyTo(r),this._pageIndex=1-this._pageIndex),!this._initialized)return this._initialized=!0,void this.output().swrite(r,n);this.output().swrite(A,i)}}const Bt=l.PYRAMID_MAX_LEVELS,Qt=2*Bt;class wt extends ut{constructor(e){super(e,Qt+1,[at().expects(We.Image),lt().expects(We.Image)])}_run(e){const{image:t,format:n}=this.input().read(),i=this._tex[0],o=e.programs.pyramids;let s=t.width,r=t.height;const A=1+Math.floor(Math.log2(Math.max(s,r))),a=new Array(Qt+1);for(let e=Qt;e>=1;e--)a[e-1]=this._tex[e];a[0].resize(s,r),t.copyTo(a[0]);const l=Math.min(A,Bt);for(let e=1;e<l;e++){const t=Math.max(1,s>>>1),n=Math.max(1,r>>>1),i=e-1+Bt;o.smoothX.outputs(s,r,a[i])(a[e-1]),o.smoothY.outputs(s,r,a[e-1])(a[i]),o.downsample2.outputs(t,n,a[e])(a[e-1]),s=t,r=n}i.resize(t.width,t.height),i.clear(),t.copyTo(i),i.generateMipmaps(a.slice(0,l)),this.output().swrite(i,n)}}class vt extends ut{constructor(e){super(e,1,[at("in0").expects(We.Image),at("in1").expects(We.Image),lt().expects(We.Image)]),this._alpha=.5,this._beta=.5,this._gamma=0}get alpha(){return this._alpha}set alpha(e){this._alpha=+e}get beta(){return this._beta}set beta(e){this._beta=+e}get gamma(){return this._gamma}set gamma(e){this._gamma=+e}_run(e){const t=this.input("in0").read(),n=this.input("in1").read(),i=t.image,o=n.image,r=t.format,A=n.format,a=Math.max(i.width,o.width),l=Math.max(i.height,o.height),c=this._alpha,d=this._beta,g=this._gamma,h=this._tex[0];if(r!=A)throw new s.h("Can't mix images of different formats");e.programs.transforms.additiveMix.outputs(a,l,h),e.programs.transforms.additiveMix(i,o,c,d,g),this.output().swrite(h,r)}}class Mt extends ut{constructor(e){super(e,1,[at().expects(We.Image)]),this._format=Le.c.RGBA,this._initialized=!1}get image(){if(!this._initialized)throw new s.g(`Portal error: ${this.fullName} holds no data`);return this._tex[0]}get format(){if(!this._initialized)throw new s.g(`Portal error: ${this.fullName} holds no data`);return this._format}init(e){super.init(e),this._tex[0].resize(1,1).clear(),this._format=Le.c.RGBA,this._initialized=!0}release(e){this._initialized=!1,super.release(e)}_run(e){const{image:t,format:n}=this.input().read(),i=this._tex[0];if(t.hasMipmaps())throw new s.h(this.fullName+" can't store a pyramid");this._format=n,i.resize(t.width,t.height),t.copyTo(i)}}class bt extends pt{constructor(e){super(e,0,[lt().expects(We.Image)]),this._source=null}get source(){return this._source}set source(e){if(null!==e&&!(e instanceof Mt))throw new s.f("Incompatible source for "+this.fullName);this._source=e}_run(e){if(null==this._source)throw new s.g(this.fullName+" has no source");this.output().swrite(this._source.image,this._source.format)}}class Dt extends Et{static Source(e){return new bt(e)}static Sink(e){return new Mt(e)}}class Xt extends Et{static Source(e){return new xt(e)}static Sink(e){return new _t(e)}static Multiplexer(e){return new Pt(e)}static Buffer(e){return new St(e)}static Pyramid(e){return new wt(e)}static Mixer(e){return new vt(e)}static get Portal(){return Dt}}class Lt extends ut{constructor(e){super(e,1,[at().expects(We.Image),lt().expects(We.Image)])}_run(e){const{image:t}=this.input().read(),n=t.width,i=t.height,o=this._tex[0],s=e.programs.filters;s.rgb2grey.outputs(n,i,o),s.rgb2grey(t),this.output().swrite(o,Le.c.GREY)}}const Rt={3:[.27901008925473514,.44197982149052983,.27901008925473514],5:[.06135959781344021,.2447701955296099,.3877404133138998,.2447701955296099,.06135959781344021],7:[.03873542500847274,.11308485700794121,.2150068609928349,.26634571398150225,.2150068609928349,.11308485700794121,.03873542500847274],9:[.028532262603370988,.067234535494912,.12400932997922749,.17904386461741617,.20236001461014655,.17904386461741617,.12400932997922749,.067234535494912,.028532262603370988],11:[.022656882730580346,.04610857898527292,.08012661469398517,.11890414969751599,.15067709325491124,.16305336127546846,.15067709325491124,.11890414969751599,.08012661469398517,.04610857898527292,.022656882730580346],13:[.018815730430644363,.03447396964662016,.05657737457255748,.08317258170844948,.10952340502389682,.12918787500405662,.13649812722755,.12918787500405662,.10952340502389682,.08317258170844948,.05657737457255748,.03447396964662016,.018815730430644363],15:[.016100340991695383,.027272329212157102,.042598338587449644,.06135478775568558,.08148767614129326,.09979838342934616,.11270444144735056,.11736740487004466,.11270444144735056,.09979838342934616,.08148767614129326,.06135478775568558,.042598338587449644,.027272329212157102,.016100340991695383]},kt=new He(0,0),Kt={3:"convolution3x",5:"convolution5x",7:"convolution7x",9:"convolution9x",11:"convolution11x",13:"convolution13x",15:"convolution15x"},Nt={3:"convolution3y",5:"convolution5y",7:"convolution7y",9:"convolution9y",11:"convolution11y",13:"convolution13y",15:"convolution15y"};class Ft extends ut{constructor(e){super(e,2,[at().expects(We.Image),lt().expects(We.Image)]),this._kernelSize=new Je(5,5),this._sigma=kt,this._kernel={x:Rt[this._kernelSize.width],y:Rt[this._kernelSize.height]}}get kernelSize(){return this._kernelSize}set kernelSize(e){i.a.assert(e instanceof Je);const t=e.width,n=e.height;if(t<3||n<3||t>15||n>15||t%2==0||n%2==0)throw new s.h(`Unsupported kernel size: ${t}x${n}`);this._kernelSize=e,this._updateKernel()}get sigma(){return this._sigma}set sigma(e){i.a.assert(e instanceof He,"Sigma must be a SpeedyVector2"),i.a.assert(e.x>=0&&e.y>=0),this._sigma=e,this._updateKernel()}_run(e){const{image:t,format:n}=this.input().read(),i=t.width,o=t.height,s=this._kernel.x,r=this._kernel.y,A=Kt[this._kernelSize.width],a=Nt[this._kernelSize.height],l=this._tex[0],c=this._tex[1];e.programs.filters[A].outputs(i,o,l)(t,s),e.programs.filters[a].outputs(i,o,c)(l,r),this.output().swrite(c,n)}_updateKernel(){this._sigma.x==kt.x?this._kernel.x=Rt[this._kernelSize.width]:this._kernel.x=i.a.gaussianKernel(this._sigma.x,this._kernelSize.width,!0),this._sigma.y==kt.y?this._kernel.y=Rt[this._kernelSize.height]:this._kernel.y=i.a.gaussianKernel(this._sigma.y,this._kernelSize.height,!0)}}const Ot={3:new Array(3).fill(1/3),5:new Array(5).fill(.2),7:new Array(7).fill(1/7),9:new Array(9).fill(1/9),11:new Array(11).fill(1/11),13:new Array(13).fill(1/13),15:new Array(15).fill(1/15)},zt={3:"convolution3x",5:"convolution5x",7:"convolution7x",9:"convolution9x",11:"convolution11x",13:"convolution13x",15:"convolution15x"},Gt={3:"convolution3y",5:"convolution5y",7:"convolution7y",9:"convolution9y",11:"convolution11y",13:"convolution13y",15:"convolution15y"};class Tt extends ut{constructor(e){super(e,2,[at().expects(We.Image),lt().expects(We.Image)]),this._kernelSize=new Je(5,5),this._kernel={x:Ot[this._kernelSize.width],y:Ot[this._kernelSize.height]}}get kernelSize(){return this._kernelSize}set kernelSize(e){i.a.assert(e instanceof Je);const t=e.width,n=e.height;if(t<3||n<3||t>15||n>15||t%2==0||n%2==0)throw new s.h(`Unsupported kernel size: ${t}x${n}`);this._kernelSize=e,this._kernel.x=Ot[this._kernelSize.width],this._kernel.y=Ot[this._kernelSize.height]}_run(e){const{image:t,format:n}=this.input().read(),i=t.width,o=t.height,s=this._kernel.x,r=this._kernel.y,A=zt[this._kernelSize.width],a=Gt[this._kernelSize.height],l=this._tex[0],c=this._tex[1];e.programs.filters[A].outputs(i,o,l)(t,s),e.programs.filters[a].outputs(i,o,c)(l,r),this.output().swrite(c,n)}}const Ut={3:"median3",5:"median5",7:"median7"};class Ht extends ut{constructor(e){super(e,1,[at().expects(We.Image).satisfying(e=>e.format===Le.c.GREY),lt().expects(We.Image)]),this._kernelSize=new Je(5,5)}get kernelSize(){return this._kernelSize}set kernelSize(e){i.a.assert(e instanceof Je);const t=e.width;if(3!=t&&5!=t&&7!=t)throw new s.h("Supported kernel sizes: 3x3, 5x5, 7x7");if(e.width!=e.height)throw new s.h("Use a square kernel");this._kernelSize=e}_run(e){const{image:t,format:n}=this.input().read(),i=t.width,o=t.height,s=this._kernelSize.width,r=Ut[s],A=this._tex[0];e.programs.filters[r].outputs(i,o,A)(t),this.output().swrite(A,n)}}const qt={3:"convolution3",5:"convolution5",7:"convolution7"};class Jt extends ut{constructor(e){super(e,1,[at().expects(We.Image),lt().expects(We.Image)]),this._kernel=Ye.SpeedyMatrix.Create(3,3,[0,0,0,0,1,0,0,0,0])}get kernel(){return this._kernel}set kernel(e){if(e.rows!=e.columns)throw new s.h("Use a square kernel");if(3!=e.rows&&5!=e.rows&&7!=e.rows)throw new s.h("Invalid kernel size. Supported sizes: 3x3, 5x5, 7x7");this._kernel=e}_run(e){const{image:t,format:n}=this.input().read(),i=t.width,o=t.height,s=this._tex[0],r=this._kernel.rows,A=qt[r],a=this._kernel.read();e.programs.filters[A].outputs(i,o,s)(t,a),this.output().swrite(s,n)}}class jt extends ut{constructor(e){super(e,3,[at().expects(We.Image).satisfying(e=>e.format===Le.c.RGBA||e.format===Le.c.GREY),lt().expects(We.Image)]),this._gain=.5,this._offset=.5,this._decay=0,this._quality="medium"}get gain(){return this._gain}set gain(e){this._gain=+e}get offset(){return this._offset}set offset(e){this._offset=+e}get decay(){return this._decay}set decay(e){this._decay=Math.max(0,Math.min(+e,1))}get quality(){return this._quality}set quality(e){if("high"!=e&&"medium"!=e&&"low"!=e)throw new s.f(`Invalid quality level for the Nightvision filter: "${e}"`);this._quality=String(e)}_run(e){const{image:t,format:n}=this.input().read(),i=t.width,o=t.height,s=this._gain,r=this._offset,A=this._decay,a=this._quality,l=e.programs.filters,c=this._tex[0],d=this._tex[1],g=this._tex[2];"medium"==a?(l.illuminationMapX.outputs(i,o,c),l.illuminationMapY.outputs(i,o,d),l.illuminationMapX(t),l.illuminationMapY(c)):"high"==a?(l.illuminationMapHiX.outputs(i,o,c),l.illuminationMapHiY.outputs(i,o,d),l.illuminationMapHiX(t),l.illuminationMapHiY(c)):"low"==a&&(l.illuminationMapLoX.outputs(i,o,c),l.illuminationMapLoY.outputs(i,o,d),l.illuminationMapLoX(t),l.illuminationMapLoY(c)),n===Le.c.GREY?(l.nightvisionGreyscale.outputs(i,o,g),l.nightvisionGreyscale(t,d,s,r,A)):n===Le.c.RGBA&&(l.nightvision.outputs(i,o,g),l.nightvision(t,d,s,r,A)),this.output().swrite(g,n)}}class Yt extends ut{constructor(e){super(e,4,[at().expects(We.Image).satisfying(e=>e.format===Le.c.GREY),lt().expects(We.Image)]),this._minValue=0,this._maxValue=255}get minValue(){return this._minValue}set minValue(e){this._minValue=Math.max(0,Math.min(+e,255))}get maxValue(){return this._maxValue}set maxValue(e){this._maxValue=Math.max(0,Math.min(+e,255))}_run(e){const{image:t,format:n}=this.input().read(),i=t.width,o=t.height,s=this._tex[3];let r=this._minValue,A=this._maxValue;r>A&&(r=A=(r+A)/2);const a=this._scanMinMax(e,t,Le.e.GREEN);e.programs.filters.normalizeGreyscale.outputs(i,o,s),e.programs.filters.normalizeGreyscale(a,r,A),this.output().swrite(s,n)}_scanMinMax(e,t,n){const o=this._tex,s=e.programs.utils,r=t.width,A=t.height,a=0|Math.ceil(Math.log2(Math.max(r,A)));i.a.assert(void 0!==Le.a[n]),s.copyComponents.outputs(r,A,o[2]),s.scanMinMax2D.outputs(r,A,o[0],o[1]);let l=s.copyComponents(t,t,Le.e.ALL,Le.a[n]);for(let e=0;e<a;e++)l=s.scanMinMax2D(l,e);return l}}class Wt extends Et{static Greyscale(e){return new Lt(e)}static GaussianBlur(e){return new Ft(e)}static SimpleBlur(e){return new Tt(e)}static MedianBlur(e){return new Ht(e)}static Convolution(e){return new Jt(e)}static Nightvision(e){return new jt(e)}static Normalize(e){return new Yt(e)}}const Zt=[0,0,0,0,0,0,0,0,1];class Vt extends ut{constructor(e){super(e,1,[at().expects(We.Image),lt().expects(We.Image)]),this._transform=Ye.SpeedyMatrix.Create(3,3,[1,0,0,0,1,0,0,0,1])}get transform(){return this._transform}set transform(e){if(3!=e.rows||3!=e.columns)throw new s.f("Not a 3x3 transformation matrix: "+e);this._transform=e}_run(e){const{image:t,format:n}=this.input().read(),i=t.width,o=t.height,s=this._tex[0],r=this._transform.read(),A=this._inverse3(r),a=!Number.isNaN(A[0]);e.programs.transforms.warpPerspective.outputs(i,o,s),e.programs.transforms.warpPerspective(t,a?A:Zt),this.output().swrite(s,n)}_inverse3(e,t=1e-6){const n=e[0],i=e[1],o=e[2],s=e[3],r=e[4],A=e[5],a=e[6],l=e[7],c=e[8],d=c*r-A*l,g=c*s-A*a,h=l*s-r*a,u=n*d-i*g+o*h;if(Math.abs(u)<t)e.fill(Number.NaN,0,9);else{const t=1/u;e[0]=d*t,e[1]=-(c*i-o*l)*t,e[2]=(A*i-o*r)*t,e[3]=-g*t,e[4]=(c*n-o*a)*t,e[5]=-(A*n-o*s)*t,e[6]=h*t,e[7]=-(l*n-i*a)*t,e[8]=(r*n-i*s)*t}return e}}class $t extends ut{constructor(e){super(e,1,[at().expects(We.Image),lt().expects(We.Image)]),this._size=new Je(0,0),this._scale=new He(1,1),this._method="bilinear"}get size(){return this._size}set size(e){this._size=e}get scale(){return this._scale}set scale(e){this._scale=e}get method(){return this._method}set method(e){if("nearest"!==e&&"bilinear"!==e)throw new s.f(`Invalid method method: "${e}"`);this._method=e}_run(e){const{image:t,format:n}=this.input().read(),i=t.width,o=t.height,s=this._tex[0],r=this._method,A=this._size.width||Math.max(1,this._scale.x*i),a=this._size.height||Math.max(1,this._scale.y*o);"bilinear"==r?e.programs.transforms.resizeBilinear.outputs(A,a,s)(t):"nearest"==r&&e.programs.transforms.resizeNearest.outputs(A,a,s)(t),this.output().swrite(s,n)}}class en extends Et{static Resize(e){return new $t(e)}static PerspectiveWarp(e){return new Vt(e)}}const tn=l.MAX_ENCODER_CAPACITY;class nn extends ut{constructor(e,t=0,n){super(e,t+4,n),this._capacity=2048}get capacity(){return this._capacity}set capacity(e){this._capacity=Math.min(Math.max(0,0|e),tn)}_encodeKeypoints(e,t,n,i=0,o=0){const s=this._capacity,r=nn.encoderLength(s,i,o),A=t.width,a=t.height,l=[A,a],c=this._tex.slice(this._tex.length-4),d=e.programs.keypoints;d.encodeKeypointSkipOffsets.outputs(A,a,c[0]),d.encodeKeypointLongSkipOffsets.outputs(A,a,c[1],c[0]),d.encodeKeypointPositions.outputs(r,r,c[2],c[3]),d.encodeKeypointProperties.outputs(r,r,n);let g=d.encodeKeypointSkipOffsets(t,l);for(let e=0;e<2;e++)g=d.encodeKeypointLongSkipOffsets(g,l);let h=c[3].clear();for(let e=0;e<8;e++)h=d.encodeKeypointPositions(g,l,e,8,s,h,i,o,r);return d.encodeKeypointProperties(t,h,i,o,r)}_encodeZeroKeypoints(e,t,n=0,i=0){const o=nn.encoderLength(0,n,i),s=e.programs.keypoints;return s.encodeNullKeypoints.outputs(o,o,t),s.encodeNullKeypoints(),t}static encoderLength(e,t,n){const i=e*Math.ceil((l.MIN_KEYPOINT_SIZE+t+n)/4);return Math.max(l.MIN_ENCODER_LENGTH,Math.ceil(Math.sqrt(i)))}static encoderCapacity(e,t,n){const i=Math.ceil((l.MIN_KEYPOINT_SIZE+e+t)/4),o=n*n;return Math.floor(o/i)}}class on extends nn{constructor(e,t,n){super(e,t,n),this._levels=1,this._scaleFactor=1.4142135623730951}get levels(){return this._levels}set levels(e){this._levels=Math.max(1,0|e)}get scaleFactor(){return this._scaleFactor}set scaleFactor(e){this._scaleFactor=Math.max(1,Math.min(+e,2))}}const sn=4*Float32Array.BYTES_PER_ELEMENT;class rn extends pt{constructor(e){super(e,2,[lt().expects(We.Keypoints)]),this._keypoints=[],this._buffer=rn._createUploadBuffer(1024)}get keypoints(){return this._keypoints}set keypoints(e){i.a.assert(Array.isArray(e)),this._keypoints=e}_run(e){const t=this._keypoints,n=t.length,i=Math.max(1,Math.ceil(n/1024)),o=this._buffer,s=e.programs.keypoints.uploadKeypoints,r=nn.encoderLength(n,0,0);s.outputs(r,r,this._tex[0],this._tex[1]);let A=0,a=s.clear();for(let e=0;e<i;e++){const e=A+Math.min(1024,n-A);s.setUBO("KeypointBuffer",rn._fillUploadBuffer(o,t,A,e)),a=s(a,A,e,0,0,r),A=e}this.output().swrite(a,0,0,r)}static _createUploadBuffer(e){const t=new ArrayBuffer(sn*e);return i.a.assert(t.byteLength<=16384),new Float32Array(t)}static _fillUploadBuffer(e,t,n,i){const o=i-n;for(let i=0;i<o;i++){const o=t[n+i],s=4*i;e[s]=+o.position.x||0,e[s+1]=+o.position.y||0,e[s+2]=+o.lod||0,e[s+3]=+o.score||0}return e}}class An extends It{constructor(e="keypoints"){super(e,0,[at().expects(We.Keypoints)]),this._keypoints=[],this._textureReader=new gt}export(){return o.a.resolve(this._keypoints)}_run(e){const{encodedKeypoints:t,descriptorSize:n,extraSize:i,encoderLength:o}=this.input().read();return this._textureReader.readPixelsAsync(t).then(e=>{this._keypoints=An._decode(e,n,i,o)})}static _decode(e,t,n,o){const s=l.MIN_KEYPOINT_SIZE+t+n,r=l.LOG2_PYRAMID_MAX_SCALE,A=l.PYRAMID_MAX_LEVELS,a=Math.PI/255,c=[];let d,g,h,u,p,I,f,m,C,E;const x=o*o*s,_=Math.min(e.length,x);t+n>0&&(e=new Uint8Array(e));for(let o=0;o<_&&(d=e[o+1]<<8|e[o],g=e[o+3]<<8|e[o+2],h=e[o+5]<<8|e[o+4],u=e[o+7]<<8|e[o+6],65535!=d||65535!=g);o+=s)d+g+h+u!=0&&(n>0&&(C=e.subarray(8+o,8+o+n),C.byteLength<n)||t>0&&(m=e.subarray(8+o+n,8+o+n+t),m.byteLength<t)||(d/=l.FIX_RESOLUTION,g/=l.FIX_RESOLUTION,p=e[o+4]<255?-r+(r+A)*e[o+4]/255:0,I=(2*e[o+5]-255)*a,f=i.a.decodeFloat16(u),E=t>0?new ft(m):null,c.push(new mt(d,g,p,I,f,E))));return c}}const an=l.MAX_ENCODER_CAPACITY;class ln extends ut{constructor(e){super(e,4,[at().expects(We.Keypoints).satisfying(e=>0==e.descriptorSize&&0==e.extraSize),lt().expects(We.Keypoints)]),this._size=an}get size(){return this._size}set size(e){this._size=Math.max(0,Math.min(0|e,an))}_run(e){const{encodedKeypoints:t,descriptorSize:n,extraSize:i,encoderLength:o}=this.input().read(),s=e.programs.keypoints,r=this._size,A=this._tex,a=this._tex[3],l=nn.encoderCapacity(n,i,o),c=Math.ceil(l/32),d=32*c,g=Math.min(l,r),h=nn.encoderLength(g,n,i);s.sortCreatePermutation.outputs(32,c,A[0]);let u=s.sortCreatePermutation(t,n,i,o);const p=Math.ceil(Math.log2(d));s.sortMergePermutation.outputs(32,c,A[1],A[2]);for(let e=1;e<=p;e++){const t=1<<e,n=e<<1;u=s.sortMergePermutation(u,t,n)}s.sortApplyPermutation.outputs(h,h,a),s.sortApplyPermutation(u,g,t,n,i),this.output().swrite(a,n,i,h)}}class cn extends ut{constructor(e){super(e,2,[at().expects(We.Keypoints),lt().expects(We.Keypoints)]),this._pageIndex=0,this._initialized=!1,this._previousDescriptorSize=0,this._previousExtraSize=0,this._previousEncoderLength=0,this._frozen=!1}get frozen(){return this._frozen}set frozen(e){this._frozen=Boolean(e)}release(e){this._initialized=!1,super.release(e)}_run(e){const{encodedKeypoints:t,descriptorSize:n,extraSize:i,encoderLength:o}=this.input().read(),s=this._previousDescriptorSize,r=this._previousExtraSize,A=this._previousEncoderLength,a=this._tex,l=a[1-this._pageIndex],c=a[this._pageIndex];if(this._frozen&&this._initialized||(this._previousDescriptorSize=n,this._previousExtraSize=i,this._previousEncoderLength=o,l.resize(o,o),t.copyTo(l),this._pageIndex=1-this._pageIndex),!this._initialized)return this._initialized=!0,void this.output().swrite(l,n,i,o);this.output().swrite(c,s,r,A)}}class dn extends ut{constructor(e){super(e,5,[at("in0").expects(We.Keypoints),at("in1").expects(We.Keypoints),lt().expects(We.Keypoints)])}_run(e){const t=this.input("in0").read(),n=this.input("in1").read(),i=t.descriptorSize,o=t.extraSize,r=e.programs.keypoints,A=this._tex,a=this._tex[4];if(t.descriptorSize!==n.descriptorSize||t.extraSize!=t.extraSize)throw new s.g("Can't merge two sets of keypoints that have different formats");const l=nn.encoderCapacity(t.descriptorSize,t.extraSize,t.encoderLength),c=nn.encoderCapacity(n.descriptorSize,n.extraSize,n.encoderLength),d=l+c,g=nn.encoderLength(d,i,o);r.mixKeypoints.outputs(g,g,A[3]);const h=r.mixKeypoints([t.encodedKeypoints,n.encodedKeypoints],[t.encoderLength,n.encoderLength],[l,c],i,o,g),u=Math.ceil(d/32),p=32*u;r.sortCreatePermutation.outputs(32,u,A[0]);let I=r.sortCreatePermutation(h,i,o,g);const f=Math.ceil(Math.log2(p));r.sortMergePermutation.outputs(32,u,A[1],A[2]);for(let e=1;e<=f;e++){const t=1<<e,n=e<<1;I=r.sortMergePermutation(I,t,n)}r.sortApplyPermutation.outputs(g,g,a),r.sortApplyPermutation(I,d,h,i,o),this.output().swrite(a,i,o,g)}}const gn=["in0","in1"];class hn extends ut{constructor(e){super(e,0,[...gn.map(e=>at(e).expects(We.Keypoints)),lt().expects(We.Keypoints)]),this._port=0}get port(){return this._port}set port(e){if(e<0||e>=gn.length)throw new s.f("Invalid port: "+e);this._port=0|e}_run(e){const t=this.input(gn[this._port]).read();this.output().write(t)}}class un extends ut{constructor(e){super(e,1,[at().expects(We.Keypoints),lt().expects(We.Keypoints)]),this._transform=Ye.SpeedyMatrix.Create(3,3,[1,0,0,0,1,0,0,0,1])}get transform(){return this._transform}set transform(e){if(3!=e.rows||3!=e.columns)throw new s.f("Not a 3x3 transformation matrix: "+e);this._transform=e}_run(e){const{encodedKeypoints:t,descriptorSize:n,extraSize:i,encoderLength:o}=this.input().read(),s=this._tex[0],r=this._transform.read();e.programs.keypoints.applyHomography.outputs(t.width,t.height,s)(r,t,n,i,o),this.output().swrite(s,n,i,o)}}const pn=Object.freeze({quadratic1d:"subpixelQuadratic1d",taylor2d:"subpixelTaylor2d","bicubic-upsample":"subpixelBicubic","bilinear-upsample":"subpixelBilinear"});class In extends ut{constructor(e){super(e,2,[at("image").expects(We.Image).satisfying(e=>e.format===Le.c.GREY),at("keypoints").expects(We.Keypoints),lt().expects(We.Keypoints),lt("displacements").expects(We.Vector2)]),this._method="quadratic1d",this._maxIterations=6,this._epsilon=.1}get method(){return this._method}set method(e){if(!Object.prototype.hasOwnProperty.call(pn,e))throw new s.f(`Invalid method: "${e}"`);this._method=e}get maxIterations(){return this._maxIterations}set maxIterations(e){this._maxIterations=Math.max(0,+e)}get epsilon(){return this._epsilon}set epsilon(e){this._epsilon=Math.max(0,+e)}_run(e){const{encodedKeypoints:t,descriptorSize:n,extraSize:i,encoderLength:o}=this.input("keypoints").read(),s=this.input("image").read().image,r=this._tex,A=pn[this._method],a=this._maxIterations,l=this._epsilon,c=nn.encoderCapacity(n,i,o),d=Math.max(1,Math.ceil(Math.sqrt(c))),g=e.programs.keypoints[A].outputs(d,d,r[0])(s,t,n,i,o,a,l),h=e.programs.keypoints.transferFlow.outputs(o,o,r[1])(g,t,n,i,o);this.output().swrite(h,n,i,o),this.output("displacements").swrite(g)}}class fn extends on{constructor(e){super(e,5,[at().expects(We.Image).satisfying(e=>e.format===Le.c.GREY),lt().expects(We.Keypoints)]),this._threshold=20}get threshold(){return this._threshold}set threshold(e){this._threshold=Math.max(0,Math.min(0|e,255))}_run(e){const t=this.input().read().image,n=t.width,i=t.height,o=this._tex,r=this._capacity,A=this._threshold,a=Math.log2(this.scaleFactor),c=this.levels;if(1!=c&&!t.hasMipmaps())throw new s.g("Expected a pyramid in "+this.fullName);if(0==r){const t=this._encodeZeroKeypoints(e,o[4]),n=t.width;return void this.output().swrite(t,0,0,n)}e.programs.keypoints.fast9_16.outputs(n,i,o[0],o[1]),e.programs.keypoints.nonmaxSpace.outputs(n,i,o[2]);let d=o[1].clear(),g=Math.max(1,Math.min(c,l.PYRAMID_MAX_LEVELS/a|0));for(let n=a*(g-1);g-- >0;n-=a)d=e.programs.keypoints.fast9_16(d,t,n,A),d=e.programs.keypoints.nonmaxSpace(d);if(c>1){const s=e.programs.keypoints.laplacian.outputs(n,i,o[0])(d,t,a,0);d=e.programs.keypoints.nonmaxScale.outputs(n,i,o[1])(d,t,s,a)}d=e.programs.keypoints[c>1?"pyrnonmax":"nonmax"].outputs(n,i,o[0])(d,a);let h=this._encodeKeypoints(e,d,o[3]);const u=h.width;c>1&&(h=e.programs.keypoints.refineScaleFAST916.outputs(u,u,o[4])(t,a,h,0,0,u,A)),this.output().swrite(h,0,0,u)}}const mn={1:"harris1",3:"harris3",5:"harris5",7:"harris7"};class Cn extends on{constructor(e){super(e,6,[at().expects(We.Image).satisfying(e=>e.format===Le.c.GREY),lt().expects(We.Keypoints)]),this._windowSize=new Je(3,3),this._quality=.1}get quality(){return this._quality}set quality(e){this._quality=Math.max(0,Math.min(+e,1))}get windowSize(){return this._windowSize}set windowSize(e){const t=e.width;if(t!=e.height||1!=t&&3!=t&&5!=t&&7!=t)throw new s.f(`Invalid window: ${e}. Acceptable sizes: 1x1, 3x3, 5x5, 7x7`);this._windowSize=e}_run(e){const t=this.input().read().image,n=t.width,o=t.height,r=this._capacity,A=this._quality,a=this._windowSize.width,c=this.levels,d=Math.log2(this.scaleFactor),g=c>1?this.scaleFactor:1,h=e.programs.keypoints[mn[a]],u=this._tex;if(1!=c&&!t.hasMipmaps())throw new s.g("Expected a pyramid in "+this.fullName);if(0==r){const t=this._encodeZeroKeypoints(e,u[5]),n=t.width;return void this.output().swrite(t,0,0,n)}h.outputs(n,o,u[0],u[1]),e.programs.utils.sobelDerivatives.outputs(n,o,u[2]),e.programs.keypoints.nonmaxSpace.outputs(n,o,u[3]);let p=u[1].clear(),I=Math.max(1,Math.min(c,l.PYRAMID_MAX_LEVELS/d|0));for(let n=d*(I-1);I-- >0;n-=d){const o=i.a.gaussianKernel(g*(1+n),a);p=h(p,t,e.programs.utils.sobelDerivatives(t,n),n,d,o),p=e.programs.keypoints.nonmaxSpace(p)}if(c>1){const i=e.programs.keypoints.laplacian.outputs(n,o,u[0])(p,t,d,0);p=e.programs.keypoints.nonmaxScale.outputs(n,o,u[2])(p,t,i,d)}e.programs.keypoints.harrisScoreFindMax.outputs(n,o,u[0],u[1]),I=Math.ceil(Math.log2(Math.max(n,o)));let f=p;for(let t=0;t<I;t++)f=e.programs.keypoints.harrisScoreFindMax(f,t);p=e.programs.keypoints.harrisScoreCutoff.outputs(n,o,f==u[0]?u[1]:u[0])(p,f,A);let m=this._encodeKeypoints(e,p,u[4]);const C=m.width;c>1&&(m=e.programs.keypoints.refineScaleLoG.outputs(C,C,u[5])(t,d,m,0,0,C)),this.output().swrite(m,0,0,C)}}class En extends ut{constructor(e,t=0,n){super(e,t+1,n)}_allocateDescriptors(e,t,n,o,s,r){i.a.assert(t>=0&&n>=0),i.a.assert(o>=0&&o%4==0&&s===n);const A=r.width,a=nn.encoderCapacity(t,n,A),l=nn.encoderLength(a,o,s),c=this._tex[this._tex.length-1];return e.programs.keypoints.allocateDescriptors.outputs(l,l,c)(r,t,n,A,o,s,l)}}class xn extends En{constructor(e){super(e,3,[at("image").expects(We.Image).satisfying(e=>e.format===Le.c.GREY&&e.image.hasMipmaps()),at("keypoints").expects(We.Keypoints).satisfying(e=>0==e.descriptorSize&&0==e.extraSize),lt().expects(We.Keypoints)])}_run(e){const{encodedKeypoints:t,descriptorSize:n,extraSize:i,encoderLength:o}=this.input("keypoints").read(),s=this.input("image").read().image,r=this._tex,A=this._tex[2],a=nn.encoderCapacity(n,i,o),l=Math.max(1,Math.ceil(Math.sqrt(a))),c=e.programs.keypoints.orbOrientation.outputs(l,l,r[0])(s,t,n,i,o),d=e.programs.keypoints.transferOrientation.outputs(o,o,r[1])(c,t,n,i,o),g=this._allocateDescriptors(e,n,i,32,i,d),h=g.width,u=e.programs.keypoints.orbDescriptor.outputs(h,h,A)(s,g,i,h);this.output().swrite(u,32,i,h)}}class _n extends En{constructor(e){super(e,0,[at().expects(We.Keypoints).satisfying(e=>e.descriptorSize>0),lt().expects(We.Keypoints)])}_run(e){const{encodedKeypoints:t,descriptorSize:n,extraSize:i,encoderLength:o}=this.input().read(),s=this._allocateDescriptors(e,n,i,0,i,t),r=s.width;e.programs.keypoints.discardDescriptors.outputs(r,r,s)(t,n,i,o,r),this.output().swrite(s,0,i,r)}}const yn=new Je(11,11),Pn=Math.min(3,l.PYRAMID_MAX_LEVELS);class Sn extends ut{constructor(e){super(e,3,[at("previousImage").expects(We.Image).satisfying(e=>e.format===Le.c.GREY),at("nextImage").expects(We.Image).satisfying(e=>e.format===Le.c.GREY),at("previousKeypoints").expects(We.Keypoints),lt().expects(We.Keypoints),lt("flow").expects(We.Vector2)]),this._windowSize=yn,this._levels=Pn,this._discardThreshold=1e-4,this._numberOfIterations=30,this._epsilon=.01}get windowSize(){return this._windowSize}set windowSize(e){i.a.assert(e.width==e.height&&e.area()>0),i.a.assert(e.width%2==1),this._windowSize=e;const t=this._windowSize.width;if(t>21)throw new s.h(`LK: window of size ${this._windowSize} is too large!`);if(t<5)throw new s.h(`LK: window of size ${this._windowSize} is too small!`)}get levels(){return this._levels}set levels(e){i.a.assert(e>=1&&e<=l.PYRAMID_MAX_LEVELS),this._levels=0|e}get discardThreshold(){return this._discardThreshold}set discardThreshold(e){i.a.assert(e>=0),this._discardThreshold=+e}get numberOfIterations(){return this._numberOfIterations}set numberOfIterations(e){i.a.assert(e>=1),this._numberOfIterations=0|e}get epsilon(){return this._epsilon}set epsilon(e){i.a.assert(e>=0),this._epsilon=+e}_run(e){const{encodedKeypoints:t,descriptorSize:n,extraSize:i,encoderLength:o}=this.input("previousKeypoints").read(),r=this.input("previousImage").read().image,A=this.input("nextImage").read().image,a=t,l=this._levels,c=this._windowSize.width,d=this._numberOfIterations,g=this._discardThreshold,h=this._epsilon,u=e.programs.keypoints,p=this._tex,I=this._tex[2];if(!(1==l||r.hasMipmaps()&&A.hasMipmaps()))throw new s.g("LK: a pyramid is required if levels > 1");if(r.width!==A.width||r.height!==A.height)throw new s.g("LK: can't use input images of different size");const f=c<=7?u.lk7:c<=9?u.lk9:c<=11?u.lk11:c<=13?u.lk13:c<=15?u.lk15:c<=21?u.lk21:null,m=nn.encoderCapacity(n,i,o),C=Math.max(1,Math.ceil(Math.sqrt(m)));f.outputs(C,C,p[0],p[1]);let E=p[1].clear();for(let e=l-1;e>=0;e--)E=f(E,a,A,r,c,e,l,d,g,h,n,i,o);u.transferFlow.outputs(o,o,I),u.transferFlow(E,a,n,i,o),this.output().swrite(I,n,i,o),this.output("flow").swrite(E)}}class Bn extends ut{constructor(e){super(e,1,[at().expects(We.Keypoints)]),this._descriptorSize=0,this._extraSize=0,this._encoderLength=0,this._initialized=!1}get encodedKeypoints(){if(!this._initialized)throw new s.g(`Portal error: ${this.fullName} holds no data`);return this._tex[0]}get descriptorSize(){if(!this._initialized)throw new s.g(`Portal error: ${this.fullName} holds no data`);return this._descriptorSize}get extraSize(){if(!this._initialized)throw new s.g(`Portal error: ${this.fullName} holds no data`);return this._extraSize}get encoderLength(){if(!this._initialized)throw new s.g(`Portal error: ${this.fullName} holds no data`);return this._encoderLength}init(e){super.init(e);const t=nn.encoderLength(0,0,0);this._tex[0].resize(t,t).clearToColor(1,1,1,1),this._descriptorSize=this._extraSize=0,this._encoderLength=t,this._initialized=!0}release(e){this._initialized=!1,super.release(e)}_run(e){const{encodedKeypoints:t,descriptorSize:n,extraSize:i,encoderLength:o}=this.input().read(),s=this._tex[0];s.resize(t.width,t.height),t.copyTo(s),this._descriptorSize=n,this._extraSize=i,this._encoderLength=o}}class Qn extends pt{constructor(e){super(e,0,[lt().expects(We.Keypoints)]),this._source=null}get source(){return this._source}set source(e){if(null!==e&&!(e instanceof Bn))throw new s.f("Incompatible source for "+this.fullName);this._source=e}_run(e){if(null==this._source)throw new s.g(this.fullName+" has no source");this.output().swrite(this._source.encodedKeypoints,this._source.descriptorSize,this._source.extraSize,this._source.encoderLength)}}class wn extends Et{static FAST(e){return new fn(e)}static Harris(e){return new Cn(e)}}class vn extends Et{static ORB(e){return new xn(e)}static Discard(e){return new _n(e)}}class Mn extends Et{static LK(e){return new Sn(e)}}class bn extends Et{static Source(e){return new Qn(e)}static Sink(e){return new Bn(e)}}class Dn extends Et{static get Detector(){return wn}static get Descriptor(){return vn}static get Tracker(){return Mn}static get Portal(){return bn}static Source(e){return new rn(e)}static Sink(e){return new An(e)}static Clipper(e){return new ln(e)}static Buffer(e){return new cn(e)}static Mixer(e){return new dn(e)}static Multiplexer(e){return new hn(e)}static Transformer(e){return new un(e)}static SubpixelRefiner(e){return new In(e)}}class Xn extends It{constructor(e="vec2"){super(e,0,[at().expects(We.Vector2)]),this._vectors=[],this._textureReader=new gt}export(){return o.a.resolve(this._vectors)}_run(e){const t=this.input().read().vectors;return this._textureReader.readPixelsAsync(t).then(e=>{this._vectors=Xn._decode(e,t.width)})}static _decode(e,t){const n=[];let o=0,s=0,r=0,A=0;const a=t*t*4,l=Math.min(e.length,a);for(let t=0;t<l&&(s=e[t+1]<<8|e[t],o=e[t+3]<<8|e[t+2],65535!=s||65535!=o);t+=4)65280==s&&65280==o||(r=i.a.decodeFloat16(s),A=i.a.decodeFloat16(o),n.push(new He(r,A)));return n}}const Ln=new class extends Function{constructor(){return super("...args","return this._create(...args)"),this.bind(this)}_create(e,t=e,n=[]){return Ye.SpeedyMatrix.Create(e,t,n)}Zeros(e,t=e){return Ye.SpeedyMatrix.Zeros(e,t)}Ones(e,t=e){return Ye.SpeedyMatrix.Ones(e,t)}Eye(e,t=e){return Ye.SpeedyMatrix.Eye(e,t)}qr(e,t,n,{mode:i="reduced"}={}){const o=n,r=n.rows,A=n.columns;if("reduced"==i){if(e.rows!=r||e.columns!=A||t.rows!=A||t.columns!=A)throw new s.f("Invalid shape for reduced QR")}else{if("full"!=i)throw new s.f(`Invalid mode for QR: "${i}"`);if(e.rows!=r||e.columns!=r||t.rows!=r||t.columns!=A)throw new s.f("Invalid shape for full QR")}return je.a.ready().then(([n,s])=>{const r=je.a.allocateMat32(n,s,e),A=je.a.allocateMat32(n,s,t),a=je.a.allocateMat32(n,s,o);je.a.copyToMat32(n,s,a,o),"reduced"==i?n.exports.Mat32_qr_reduced(r,A,a):n.exports.Mat32_qr_full(r,A,a),je.a.copyFromMat32(n,s,r,e),je.a.copyFromMat32(n,s,A,t),je.a.deallocateMat32(n,s,a),je.a.deallocateMat32(n,s,A),je.a.deallocateMat32(n,s,r)})}ols(e,t,n,{method:i="qr"}={}){const o=t.rows,r=t.columns,A=e;if(o<r||0==r)throw new s.f("Can't solve an underdetermined system of equations");if(n.rows!=o||1!=n.columns||A.rows!=r||1!=A.columns)throw new s.f("Invalid shapes");return je.a.ready().then(([o,r])=>{const a=je.a.allocateMat32(o,r,t),l=je.a.allocateMat32(o,r,n),c=je.a.allocateMat32(o,r,A);switch(je.a.copyToMat32(o,r,a,t),je.a.copyToMat32(o,r,l,n),i){case"qr":o.exports.Mat32_qr_ols(c,a,l,2);break;default:throw new s.f(`Invalid method: "${i}"`)}return je.a.copyFromMat32(o,r,c,A),je.a.deallocateMat32(o,r,c),je.a.deallocateMat32(o,r,l),je.a.deallocateMat32(o,r,a),e})}solve(e,t,n,{method:i="qr"}={}){const o=t.rows,r=t.columns,A=e;if(o!=r)throw new s.f("Can't solve an over or underdetermined system of equations");if(n.rows!=o||1!=n.columns||A.rows!=o||1!=A.columns)throw new s.f("Invalid shapes");return je.a.ready().then(([e,o])=>{switch(i){case"qr":return this.ols(A,t,n,{method:i});default:throw new s.f(`Invalid method: "${i}"`)}})}perspective(e,t,n){if(2!=t.rows||4!=t.columns||2!=n.rows||4!=n.columns)throw new s.f("You need two 2x4 input matrices to compute a perspective transformation");if(3!=e.rows||3!=e.columns)throw new s.f("The output of perspective() is a 3x3 homography");return je.a.ready().then(([i,o])=>{const s=je.a.allocateMat32(i,o,e),r=je.a.allocateMat32(i,o,t),A=je.a.allocateMat32(i,o,n);return je.a.copyToMat32(i,o,r,t),je.a.copyToMat32(i,o,A,n),i.exports.Mat32_homography_ndlt4(s,r,A),je.a.copyFromMat32(i,o,s,e),je.a.deallocateMat32(i,o,A),je.a.deallocateMat32(i,o,r),je.a.deallocateMat32(i,o,s),e})}findHomography(e,t,n,{method:o="dlt",mask:r=null,reprojectionError:A=3,numberOfHypotheses:a=500,bundleSize:l=100}={}){if(2!=t.rows||t.columns<4||2!=n.rows||n.columns!=t.columns)throw new s.f("You need two 2 x n (n >= 4) input matrices to compute a homography");if(3!=e.rows||3!=e.columns)throw new s.f("The output of findHomography() is a 3x3 homography");if(null!=r&&(1!=r.rows||r.columns!=t.columns))throw new s.f("Invalid shape of the inliers mask");return je.a.ready().then(([c,d])=>{const g=je.a.allocateMat32(c,d,e),h=je.a.allocateMat32(c,d,t),u=je.a.allocateMat32(c,d,n),p=null!=r?je.a.allocateMat32(c,d,r):0;switch(je.a.copyToMat32(c,d,h,t),je.a.copyToMat32(c,d,u,n),o){case"pransac":i.a.assert(A>=0&&a>0&&l>0),c.exports.Mat32_pransac_homography(g,p,h,u,a,l,A);break;case"dlt":c.exports.Mat32_homography_ndlt(g,h,u);break;default:throw new s.f(`Illegal method for findHomography(): "${o}"`)}return je.a.copyFromMat32(c,d,g,e),null!=r&&je.a.copyFromMat32(c,d,p,r),null!=r&&je.a.deallocateMat32(c,d,p),je.a.deallocateMat32(c,d,u),je.a.deallocateMat32(c,d,h),je.a.deallocateMat32(c,d,g),e})}perspectiveTransform(e,t,n){if(2!=t.rows||2!=e.rows||t.columns!=e.columns)throw new s.f("Invalid shapes");if(3!=n.rows||3!=n.columns)throw new s.f("The perspective transformation must be a 3x3 matrix");return je.a.ready().then(([i,o])=>{const s=je.a.allocateMat32(i,o,n),r=je.a.allocateMat32(i,o,t),A=je.a.allocateMat32(i,o,e);return je.a.copyToMat32(i,o,r,t),je.a.copyToMat32(i,o,s,n),i.exports.Mat32_transform_perspective(A,r,s),je.a.copyFromMat32(i,o,A,e),je.a.deallocateMat32(i,o,A),je.a.deallocateMat32(i,o,r),je.a.deallocateMat32(i,o,s),e})}},Rn=new class extends Function{constructor(){return super("...args","return this._create(...args)"),this.bind(this)}_create(e,t){return new He(e,t)}Sink(e){return new Xn(e)}};class kn{static load(e,t={}){return Ge.load(e,t)}static camera(e=640,t=360,n={},i={}){return Ge.loadCameraStream(e,t,n,i)}static get version(){return"0.8.2-wip"}static get fps(){return Ue.instance.fps}static get Vector2(){return Rn}static Point2(e,t){return new qe(e,t)}static Size(e,t){return new Je(e,t)}static get Matrix(){return Ln}static get Promise(){return o.a}static Pipeline(){return new Ct}static get Image(){return Xt}static get Filter(){return Wt}static get Transform(){return en}static get Keypoint(){return Dn}}l.LITTLE_ENDIAN||i.a.warn("Running on a big-endian machine")}]);