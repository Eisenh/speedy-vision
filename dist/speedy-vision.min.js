/*!
 * speedy-vision.js v0.3.2
 * GPU-accelerated Computer Vision for the web
 * https://github.com/alemart/speedy-vision-js
 * 
 * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com> (https://github.com/alemart)
 * @license Apache-2.0
 * 
 * Date: 2020-08-05T22:05:30.732Z
 */
var Speedy=function(e){var t={};function i(n){if(t[n])return t[n].exports;var a=t[n]={i:n,l:!1,exports:{}};return e[n].call(a.exports,a,a.exports,i),a.l=!0,a.exports}return i.m=e,i.c=t,i.d=function(e,t,n){i.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},i.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},i.t=function(e,t){if(1&t&&(e=i(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(i.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var a in e)i.d(n,a,function(t){return e[t]}.bind(null,a));return n},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,"a",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p="",i(i.s=46)}([function(e,t,i){"use strict";i.d(t,"a",(function(){return a}));var n=i(5);class a{static fatal(e,...t){throw new n.a(e,...t)}static warning(e,...t){const i=[e,...t].join(" ");return console.warn("[speedy-vision.js]",i),i}static log(e,...t){const i=[e,...t].join(" ");return console.log("[speedy-vision.js]",i),i}static assert(e,t=""){if(!e)throw new n.a("Assertion failed.",t)}static enum(...e){return Object.freeze(e.reduce((e,t)=>(e[t]=Symbol(t),e),{}))}static get setZeroTimeout(){return this._setZeroTimeout||(this._setZeroTimeout=(()=>{const e="0%"+Math.random().toString(36).slice(2),t=[];return window.addEventListener("message",i=>{i.source===window&&i.data===e&&(event.stopPropagation(),t.shift().call(window))},!0),function(i){t.push(i),window.postMessage(e,"*")}})())}static functionArguments(e){const t=e.toString(),i=t.startsWith("function")?"function\\s.*\\(([^)]*)\\)":t.startsWith("(")?"\\(([^)]*)\\).*=>":"([^=]+).*=>",n=new RegExp(i).exec(t);if(null!==n){return n[1].replace(/\/\*.*?\*\//g,"").split(",").map(e=>e.replace(/=.*$/,"").trim()).filter(e=>e)}return a.fatal("Can't detect function arguments of "+t),[]}static gaussianNoise(e=0,t=1){const i=2*Math.PI;let n,a=Math.random();do{n=Math.random()}while(n<=Number.EPSILON);return Math.sqrt(-2*Math.log(n))*Math.sin(i*a)*t+e}static gaussianKernel(e,t=-1,i=!0){t<0&&(t=0|Math.ceil(5*e),t+=1-t%2),(t|=0)<1||t%2==0?a.fatal(`Invalid kernel size given to gaussianKernel: ${t} x 1`):e<=0&&a.fatal("Invalid sigma given to gaussianKernel: "+e);const n=new Array(t),r=t>>1,s=+e*Math.sqrt(2),o=.3275911,c=.254829592,l=-.284496736,p=1.421413741,f=-1.453152027,h=1.061405429;let m=0;for(let e=0;e<t;e++){let t=(e-r+.5)/s,i=(e-r-.5)/s,a=1,u=1;t<0&&(a=-1,t=-t),i<0&&(u=-1,i=-i);const d=1/(1+o*t),g=1/(1+o*i),x=((((h*g+f)*g+p)*g+l)*g+c)*g,_=(a*(1-((((h*d+f)*d+p)*d+l)*d+c)*d*Math.exp(-t*t))-u*(1-x*Math.exp(-i*i)))/(2*s);n[e]=_,m+=_}return i?n.map(e=>e/m):n}}},function(e,t,i){"use strict";i.d(t,"b",(function(){return h})),i.d(t,"a",(function(){return m}));var n=i(4),a=i(3),r=i(0);const s=[/\/\*(.|\s)*?\*\//g,/\/\/.*$/gm],o=/^\s*@\s*include\s+"(.*?)"/gm,c=/@(\w+)@/g,l={PYRAMID_MAX_LEVELS:n.b,LOG2_PYRAMID_MAX_SCALE:Math.log2(n.c),PIXELCOMPONENT_RED:a.c.RED,PIXELCOMPONENT_GREEN:a.c.GREEN,PIXELCOMPONENT_BLUE:a.c.BLUE,PIXELCOMPONENT_ALPHA:a.c.ALPHA};class p{static run(e){return String(e).replace(s[0],"").replace(s[1],"").replace(o,(e,t)=>p.run(function(e){return String(e).match(/^[a-zA-Z0-9_\-]+\.glsl$/)?i(11)("./"+e):(r.a.fatal(`Shader preprocessor: can't read file "${e}"`),"")}(t))).replace(c,(e,t)=>String(l[t]||"UNDEFINED_CONSTANT"))}}class f{constructor(e){const t=e.filepath||null,n=t?i(12)("./"+t):e.source||"";this._fragmentSource=p.run('#version 300 es\nprecision highp float;\nprecision highp int;\nprecision mediump sampler2D;\n \nout vec4 color;\nin vec2 texCoord;\nuniform vec2 texSize;\n\n@include "global.glsl"\n'+n),this._vertexSource=p.run("#version 300 es\nin vec2 a_position;\nin vec2 a_texCoord;\nout vec2 texCoord;\n \nvoid main() {\n    gl_Position = vec4(a_position, 0.0, 1.0);\n    texCoord = a_texCoord;\n}"),this._filepath=t||"<in-memory>",this._uniform=this._autodetectUniforms(this._fragmentSource),this._arguments=[]}static create(e){return new f({source:e})}static import(e){return String(e).match(/^[a-zA-Z0-9_\-\/]+\.glsl$/)||r.a.fatal(`Can't import shader: "${e}"`),new f({filepath:e})}withArguments(...e){this._arguments=e.map(e=>String(e));for(const e of this._arguments)this._uniform.hasOwnProperty(e)||this._uniform.hasOwnProperty(e+"[0]")||r.a.fatal(`Argument "${e}" has not been declared in the shader`);return this}get fragmentSource(){return this._fragmentSource}get vertexSource(){return this._vertexSource}get attributes(){return f._attr||(f._attr=Object.freeze({position:"a_position",texCoord:"a_texCoord"}))}get arguments(){return this._arguments}get uniforms(){return Object.keys(this._uniform)}uniformType(e){return this._uniform.hasOwnProperty(e)||r.a.fatal(`Unrecognized uniform variable: "${e}"`),this._uniform[e]}_autodetectUniforms(e){const t=e,i=/uniform\s+(\w+)\s+([^;]+)/g,n={};let a;for(;null!==(a=i.exec(t));){const e=a[1],t=a[2].split(",").map(e=>e.trim()).filter(e=>e);for(const i of t)if(i.endsWith("]")){(a=i.match(/(\w+)\s*\[\s*(\d+)\s*\]$/))||r.a.fatal(`Unspecified array length for uniform "${i}" in the shader`);const[t,s]=[a[1],Number(a[2])];for(let i=0;i<s;i++)n[`${t}[${i}]`]=e}else n[i]=e}return Object.freeze(n)}}function h(e){return f.import(e)}function m(e){return f.create(e)}},function(e,t,i){"use strict";i.r(t),i.d(t,"conv2D",(function(){return o})),i.d(t,"convX",(function(){return c})),i.d(t,"convY",(function(){return l})),i.d(t,"createKernel2D",(function(){return f})),i.d(t,"createKernel1D",(function(){return h})),i.d(t,"texConv2D",(function(){return m})),i.d(t,"texConvX",(function(){return u})),i.d(t,"texConvY",(function(){return d}));var n=i(0),a=i(1);const r=(e,t)=>[].concat(...e.map(e=>t.map(t=>[e,t]))),s=e=>[...Array(2*e+1).keys()].map(t=>t-e);function o(e,t=1){const i=new Float32Array(e.map(e=>+e*+t)),o=0|Math.sqrt(i.length),c=o/2|0;o<1||o%2==0?n.a.fatal("Can't perform a 2D convolution with an invalid kSize of "+o):o*o!=i.length&&n.a.fatal(`Invalid 2D convolution kernel of ${i.length} elements (expected: square)`);const l=`\n    uniform sampler2D image;\n\n    void main()\n    {\n        float alpha = threadPixel(image).a;\n        vec4 result = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n\n        ${p=(e,t,i)=>`\n        result += pixelAtOffset(image, ivec2(${0|i}, ${0|t})) * float(${+e});\n    `,r(s(c),s(c)).map(e=>p(i[(e[0]+c)*o+(e[1]+c)],e[0],e[1])).join("\n")}\n\n        color = vec4(result.rgb, alpha);\n    }\n    `;var p;return Object(a.a)(l).withArguments("image")}function c(e,t=1){return p("x",e,t)}function l(e,t=1){return p("y",e,t)}function p(e,t,i=1){const r=new Float32Array(t.map(e=>+e*+i)),o=r.length,c=o/2|0;o<1||o%2==0?n.a.fatal("Can't perform a 1D convolution with an invalid kSize of "+o):"x"!=e&&"y"!=e&&n.a.fatal(`Can't perform 1D convolution: invalid axis "${e}"`);const l=`\n    uniform sampler2D image;\n\n    void main()\n    {\n        float alpha = threadPixel(image).a;\n        vec4 pixel = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n\n        ${p=(t,i)=>"x"==e?`\n        pixel += pixelAtOffset(image, ivec2(${0|i}, 0)) * float(${+t});\n    `:`\n        pixel += pixelAtOffset(image, ivec2(0, ${0|i})) * float(${+t});\n    `,s(c).reduce((e,t)=>e+p(r[t+c],t),"")}\n\n        color = vec4(pixel.rgb, alpha);\n    }\n    `;var p;return Object(a.a)(l).withArguments("image")}function f(e){((e|=0)<1||e%2==0)&&n.a.fatal("Can't create a 2D texture kernel of size "+e);const t=`\n    uniform float kernel[${e*e}];\n\n    void main()\n    {\n        ivec2 thread = threadLocation();\n        float val = kernel[(${e}) * thread.y + thread.x];\n\n        float e0 = floor(val);\n        float e1 = 256.0f * fract(val);\n        float e2 = 256.0f * fract(e1);\n        float e3 = 256.0f * fract(e2);\n\n        color = vec4(e0, floor(e1) / 256.0f, floor(e2) / 256.0f, floor(e3) / 256.0f);\n    }\n    `;return Object(a.a)(t).withArguments("kernel")}function h(e){((e|=0)<1||e%2==0)&&n.a.fatal("Can't create a 1D texture kernel of size "+e);const t=`\n    uniform float kernel[${e}];\n\n    void main()\n    {\n        ivec2 thread = threadLocation();\n        float val = kernel[thread.x];\n\n        float e0 = floor(val);\n        float e1 = 256.0f * fract(val);\n        float e2 = 256.0f * fract(e1);\n        float e3 = 256.0f * fract(e2);\n\n        color = vec4(e0, floor(e1) / 256.0f, floor(e2) / 256.0f, floor(e3) / 256.0f);\n    }\n    `;return Object(a.a)(t).withArguments("kernel")}function m(e){const t=e>>1;(e<1||e%2==0)&&n.a.fatal("Can't perform a texture-based 2D convolution with an invalid kernel size of "+e);const i=`\n    const vec4 magic = vec4(1.0f, 1.0f, 1.0f / 256.0f, 1.0f / 65536.0f);\n    uniform sampler2D image, texKernel;\n    uniform float scale, offset;\n\n    void main()\n    {\n        vec4 kernel = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n        vec4 result = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n        float alpha = threadPixel(image).a;\n        float value = 0.0f;\n\n        ${o=(e,i)=>`\n        kernel = pixelAt(texKernel, ivec2(${e+t}, ${i+t}));\n        value = dot(kernel, magic) * scale + offset;\n        result += pixelAtOffset(image, ivec2(${e}, ${i})) * value;\n    `,r(s(t),s(t)).map(e=>o(e[0],e[1])).join("\n")}\n\n        result = clamp(result, 0.0f, 1.0f);\n        color = vec4(result.rgb, alpha);\n    }\n    `;var o;return Object(a.a)(i).withArguments("image","texKernel","scale","offset")}const u=e=>g(e,"x"),d=e=>g(e,"y");function g(e,t){const i=e>>1;e<1||e%2==0?n.a.fatal("Can't perform a texture-based 2D convolution with an invalid kernel size of "+e):"x"!=t&&"y"!=t&&n.a.fatal(`Can't perform a texture-based 1D convolution: invalid axis "${t}"`);const r=`\n    const vec4 magic = vec4(1.0f, 1.0f, 1.0f / 256.0f, 1.0f / 65536.0f);\n    uniform sampler2D image, texKernel;\n    uniform float scale, offset;\n\n    void main()\n    {\n        vec4 kernel = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n        vec4 result = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n        float alpha = threadPixel(image).a;\n        float value = 0.0f;\n\n        ${o=e=>"x"==t?`\n        kernel = pixelAt(texKernel, ivec2(${e+i}, 0));\n        value = dot(kernel, magic) * scale + offset;\n        result += pixelAtOffset(image, ivec2(${e}, 0)) * value;\n    `:`\n        kernel = pixelAt(texKernel, ivec2(${e+i}, 0));\n        value = dot(kernel, magic) * scale + offset;\n        result += pixelAtOffset(image, ivec2(0, ${e})) * value;\n    `,s(i).map(o).join("\n")}\n\n        result = clamp(result, 0.0f, 1.0f);\n        color = vec4(result.rgb, alpha);\n    }\n    `;var o;return Object(a.a)(r).withArguments("image","texKernel","scale","offset")}},function(e,t,i){"use strict";i.d(t,"b",(function(){return a})),i.d(t,"a",(function(){return r})),i.d(t,"c",(function(){return s}));var n=i(0);const a=n.a.enum("Image","Video","Canvas","Texture"),r=n.a.enum("RGB","Greyscale","Binary"),s=Object.freeze({RED:1,GREEN:2,BLUE:4,ALPHA:8,ALL:15})},function(e,t,i){"use strict";i.d(t,"a",(function(){return n})),i.d(t,"b",(function(){return a})),i.d(t,"c",(function(){return r}));const n=65534,a=4,r=2},function(e,t,i){"use strict";i.d(t,"a",(function(){return n}));class n extends Error{constructor(e,...t){const i=[e,...t].join(" ");console.error("[speedy-vision.js]",i),super(i)}get name(){return this.constructor.name}}},function(e,t){e.exports="#define PIXELCOMPONENT_RED   @PIXELCOMPONENT_RED@\n#define PIXELCOMPONENT_GREEN @PIXELCOMPONENT_GREEN@\n#define PIXELCOMPONENT_BLUE  @PIXELCOMPONENT_BLUE@\n#define PIXELCOMPONENT_ALPHA @PIXELCOMPONENT_ALPHA@"},function(e,t){e.exports="#define threadLocation() ivec2(texCoord * texSize)\n#define outputSize() ivec2(texSize)\n#define DEBUG(scalar) do { color = vec4(float(scalar), 0.0f, 0.0f, 1.0f); return; } while(false)\n#define threadPixel(img) textureLod((img), texCoord, 0.0f)\n#define pixelAt(img, pos) texelFetch((img), (pos), 0)\n#define pixelAtOffset(img, offset) textureLodOffset((img), texCoord, 0.0f, (offset))"},function(e,t){e.exports="#ifndef _MATH_GLSL\n#define _MATH_GLSL\n#define TWO_PI          6.28318530718f\n#define PI              3.14159265359f\n#define PI_OVER_2       1.57079632679f\n#define PI_OVER_4       0.78539816339f\n#define USE_FAST_ATAN\n#ifdef USE_FAST_ATAN\nfloat fastAtan(float x)\n{\nfloat w = 1.0f - abs(x);\nreturn (w >= 0.0f) ?\n(PI_OVER_4 + 0.273f * w) * x :\nsign(x) * PI_OVER_2 - (PI_OVER_4 + 0.273f * (1.0f - abs(1.0f / x))) / x;\n}\n#else\n#define fastAtan(x) atan(x)\n#endif\n#ifdef USE_FAST_ATAN\nfloat fastAtan2(float y, float x)\n{\nreturn (x == 0.0f) ? PI_OVER_2 * sign(y) : fastAtan(y / x) + float(x < 0.0f) * PI * sign(y);\n}\n#else\n#define fastAtan2(y, x) atan((y), (x))\n#endif\n#endif"},function(e,t){e.exports="#define pyrPixel(pyr, lod) textureLod((pyr), texCoord, (lod))\n#define pyrPixelAtOffset(pyr, lod, pot, offset) textureLod((pyr), texCoord + ((pot) * vec2(offset)) / texSize, (lod))\n#define PYRAMID_MAX_LEVELS      float(@PYRAMID_MAX_LEVELS@)\n#define LOG2_PYRAMID_MAX_SCALE  float(@LOG2_PYRAMID_MAX_SCALE@)\nfloat encodeLod(float lod)\n{\nreturn (LOG2_PYRAMID_MAX_SCALE + lod) / (LOG2_PYRAMID_MAX_SCALE + PYRAMID_MAX_LEVELS);\n}\nfloat decodeLod(float encodedLod)\n{\nreturn encodedLod * (LOG2_PYRAMID_MAX_SCALE + PYRAMID_MAX_LEVELS) - LOG2_PYRAMID_MAX_SCALE;\n}"},function(e,t){e.exports="vec4 encodeSobel(vec2 df)\n{\nvec2 zeroes = vec2(0.0f, 0.0f);\nvec2 dmax = -max(df, zeroes);\nvec2 dmin = min(df, zeroes);\nreturn exp2(vec4(dmax, dmin));\n}\nvec2 decodeSobel(vec4 encodedSobel)\n{\nvec4 lg = log2(encodedSobel);\nreturn vec2(lg.b - lg.r, lg.a - lg.g);\n}"},function(e,t,i){var n={"./colors.glsl":6,"./global.glsl":7,"./math.glsl":8,"./pyramids.glsl":9,"./sobel.glsl":10};function a(e){var t=r(e);return i(t)}function r(e){if(!i.o(n,e)){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}return n[e]}a.keys=function(){return Object.keys(n)},a.resolve=r,e.exports=a,a.id=11},function(e,t,i){var n={"./colors/rgb2grey.glsl":13,"./encoders/encode-keypoint-offsets.glsl":14,"./encoders/encode-keypoints.glsl":15,"./filters/convolution":2,"./filters/convolution.js":2,"./include/colors.glsl":6,"./include/global.glsl":7,"./include/math.glsl":8,"./include/pyramids.glsl":9,"./include/sobel.glsl":10,"./keypoints/brisk.glsl":16,"./keypoints/fast-score12.glsl":17,"./keypoints/fast-score16.glsl":18,"./keypoints/fast-score8.glsl":19,"./keypoints/fast5.glsl":20,"./keypoints/fast7.glsl":21,"./keypoints/fast9lg.glsl":22,"./keypoints/fast9pyr.glsl":23,"./keypoints/harris-cutoff.glsl":24,"./keypoints/multiscale-harris.glsl":25,"./keypoints/multiscale-orientation-via-centroid.glsl":26,"./keypoints/multiscale-sobel.glsl":27,"./keypoints/multiscale-suppression.glsl":28,"./keypoints/nonmax-suppression.glsl":29,"./keypoints/orientation-via-centroid.glsl":30,"./keypoints/samescale-suppression.glsl":31,"./pyramids/crop.glsl":32,"./pyramids/downsample2.glsl":33,"./pyramids/downsample3.glsl":34,"./pyramids/merge-keypoints-at-consecutive-levels.glsl":35,"./pyramids/merge-keypoints.glsl":36,"./pyramids/normalize-keypoints.glsl":37,"./pyramids/upsample2.glsl":38,"./pyramids/upsample3.glsl":39,"./utils/copy-components.glsl":40,"./utils/fill-components.glsl":41,"./utils/fill.glsl":42,"./utils/flip-y.glsl":43,"./utils/identity.glsl":44,"./utils/scan-minmax2d.glsl":45};function a(e){var t=r(e);return i(t)}function r(e){if(!i.o(n,e)){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}return n[e]}a.keys=function(){return Object.keys(n)},a.resolve=r,e.exports=a,a.id=12},function(e,t){e.exports="const vec4 grey = vec4(0.299f, 0.587f, 0.114f, 0.0f);\nuniform sampler2D image;\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nfloat g = dot(pixel, grey);\ncolor = vec4(g, g, g, 1.0f);\n}"},function(e,t){e.exports="uniform sampler2D image;\nuniform ivec2 imageSize;\nuniform int maxIterations;\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nivec2 pos = threadLocation();\nint offset = -1;\nwhile(offset < maxIterations && pos.y < imageSize.y && pixelAt(image, pos).r == 0.0f) {\n++offset;\npos.x = (pos.x + 1) % imageSize.x;\npos.y += int(pos.x == 0);\n}\ncolor = vec4(pixel.r, float(max(0, offset)) / 255.0f, pixel.ba);\n}"},function(e,t){e.exports="uniform sampler2D image;\nuniform ivec2 imageSize;\nuniform int encoderLength;\nuniform int descriptorSize;\nbool findQthKeypoint(int q, out ivec2 position, out vec4 pixel)\n{\nint i = 0, p = 0;\nfor(position = ivec2(0, 0); position.y < imageSize.y; ) {\npixel = pixelAt(image, position);\nif(pixel.r > 0.0f) {\nif(p++ == q)\nreturn true;\n}\ni += 1 + int(pixel.g * 255.0f);\nposition = ivec2(i % imageSize.x, i / imageSize.x);\n}\nreturn false;\n}\nvoid main()\n{\nvec4 pixel;\nivec2 position;\nivec2 thread = threadLocation();\nint p = encoderLength * thread.y + thread.x;\nint d = 2 + descriptorSize / 4;\nint q = p / d;\ncolor = vec4(1.0f, 1.0f, 1.0f, 1.0f);\nif(findQthKeypoint(q, position, pixel)) {\nint r = p % d;\nswitch(r) {\ncase 0: {\nivec2 lo = position & 255;\nivec2 hi = position >> 8;\ncolor = vec4(float(lo.x), float(hi.x), float(lo.y), float(hi.y)) / 255.0f;\nbreak;\n}\ncase 1: {\nfloat score = pixel.r;\nfloat scale = pixel.a;\nfloat rotation = pixel.b;\ncolor = vec4(scale, rotation, score, 0.0f);\nbreak;\n}\ndefault: {\nint i = r - 2;\nbreak;\n}\n}\n}\n}"},function(e,t){e.exports="uniform sampler2D image, layerA, layerB;\nuniform float scaleA, scaleB, lgM, h;\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nfloat score = pixel.r;\nivec2 zero = ivec2(0, 0);\nivec2 sizeA = textureSize(layerA, 0);\nivec2 sizeB = textureSize(layerB, 0);\nvec2 mid = (texCoord * texSize) + vec2(0.5f, 0.5f);\nivec2 pa = clamp(ivec2(ceil(mid * scaleA - 1.0f)), zero, sizeA - 2);\nivec2 pb = clamp(ivec2(ceil(mid * scaleB - 1.0f)), zero, sizeB - 2);\nvec4 a00 = pixelAt(layerA, pa);\nvec4 a10 = pixelAt(layerA, pa + ivec2(1, 0));\nvec4 a01 = pixelAt(layerA, pa + ivec2(0, 1));\nvec4 a11 = pixelAt(layerA, pa + ivec2(1, 1));\nvec4 b00 = pixelAt(layerB, pb);\nvec4 b10 = pixelAt(layerB, pb + ivec2(1, 0));\nvec4 b01 = pixelAt(layerB, pb + ivec2(0, 1));\nvec4 b11 = pixelAt(layerB, pb + ivec2(1, 1));\nfloat maxScore = max(\nmax(max(a00.r, a10.r), max(a01.r, a11.r)),\nmax(max(b00.r, b10.r), max(b01.r, b11.r))\n);\ncolor = vec4(0.0f, pixel.gba);\nif(score < maxScore || score == 0.0f)\nreturn;\nvec2 ea = fract(mid * scaleA);\nvec2 eb = fract(mid * scaleB);\nfloat isa = a00.b * (1.0f - ea.x) * (1.0f - ea.y) +\na10.b * ea.x * (1.0f - ea.y) +\na01.b * (1.0f - ea.x) * ea.y +\na11.b * ea.x * ea.y;\nfloat isb = b00.b * (1.0f - eb.x) * (1.0f - eb.y) +\nb10.b * eb.x * (1.0f - eb.y) +\nb01.b * (1.0f - eb.x) * eb.y +\nb11.b * eb.x * eb.y;\ncolor = (isa > score && isa > isb) ? vec4(isa, pixel.gb, a00.a) : pixel;\ncolor = (isb > score && isb > isa) ? vec4(isb, pixel.gb, b00.a) : pixel;\nfloat y1 = isa, y2 = isb, y3 = score;\nfloat x1 = lgM - (lgM + h) * a00.a;\nfloat x2 = lgM - (lgM + h) * b00.a;\nfloat x3 = lgM - (lgM + h) * pixel.a;\nfloat dn = (x1 - x2) * (x1 - x3) * (x2 - x3);\nif(abs(dn) < 0.00001f)\nreturn;\nfloat a = (x3 * (y2 - y1) + x2 * (y1 - y3) + x1 * (y3 - y2)) / dn;\nif(a >= 0.0f)\nreturn;\nfloat b = (x3 * x3 * (y1 - y2) + x2 * x2 * (y3 - y1) + x1 * x1 * (y2 - y3)) / dn;\nfloat c = (x2 * x3 * (x2 - x3) * y1 + x3 * x1 * (x3 - x1) * y2 + x1 * x2 * (x1 - x2) * y3) / dn;\nfloat xv = -b / (2.0f * a);\nfloat yv = c - (b * b) / (4.0f * a);\nif(xv < min(x1, min(x2, x3)) || xv > max(x1, max(x2, x3)))\nreturn;\nfloat interpolatedScale = (lgM - xv) / (lgM + h);\nfloat interpolatedScore = clamp(yv, 0.0f, 1.0f);\ncolor = vec4(interpolatedScore, pixel.gb, interpolatedScale);\n}"},function(e,t){e.exports="uniform sampler2D image;\nuniform float threshold;\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nfloat t = clamp(threshold, 0.0f, 1.0f);\nfloat ct = pixel.g + t, c_t = pixel.g - t;\nfloat p0 = pixelAtOffset(image, ivec2(0, 2)).g;\nfloat p1 = pixelAtOffset(image, ivec2(1, 2)).g;\nfloat p2 = pixelAtOffset(image, ivec2(2, 1)).g;\nfloat p3 = pixelAtOffset(image, ivec2(2, 0)).g;\nfloat p4 = pixelAtOffset(image, ivec2(2, -1)).g;\nfloat p5 = pixelAtOffset(image, ivec2(1, -2)).g;\nfloat p6 = pixelAtOffset(image, ivec2(0, -2)).g;\nfloat p7 = pixelAtOffset(image, ivec2(-1, -2)).g;\nfloat p8 = pixelAtOffset(image, ivec2(-2, -1)).g;\nfloat p9 = pixelAtOffset(image, ivec2(-2, 0)).g;\nfloat p10 = pixelAtOffset(image, ivec2(-2, 1)).g;\nfloat p11 = pixelAtOffset(image, ivec2(-1, 2)).g;\nvec2 scores = vec2(0.0f, 0.0f);\nscores += vec2(max(c_t - p0, 0.0f), max(p0 - ct, 0.0f));\nscores += vec2(max(c_t - p1, 0.0f), max(p1 - ct, 0.0f));\nscores += vec2(max(c_t - p2, 0.0f), max(p2 - ct, 0.0f));\nscores += vec2(max(c_t - p3, 0.0f), max(p3 - ct, 0.0f));\nscores += vec2(max(c_t - p4, 0.0f), max(p4 - ct, 0.0f));\nscores += vec2(max(c_t - p5, 0.0f), max(p5 - ct, 0.0f));\nscores += vec2(max(c_t - p6, 0.0f), max(p6 - ct, 0.0f));\nscores += vec2(max(c_t - p7, 0.0f), max(p7 - ct, 0.0f));\nscores += vec2(max(c_t - p8, 0.0f), max(p8 - ct, 0.0f));\nscores += vec2(max(c_t - p9, 0.0f), max(p9 - ct, 0.0f));\nscores += vec2(max(c_t - p10, 0.0f), max(p10 - ct, 0.0f));\nscores += vec2(max(c_t - p11, 0.0f), max(p11 - ct, 0.0f));\nfloat score = max(scores.x, scores.y) / 12.0f;\ncolor = vec4(score * step(1.0f, pixel.r), pixel.g, score, pixel.a);\n}"},function(e,t){e.exports="uniform sampler2D image;\nuniform float threshold;\nconst vec4 zeroes = vec4(0.0f, 0.0f, 0.0f, 0.0f);\nconst vec4 ones = vec4(1.0f, 1.0f, 1.0f, 1.0f);\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nfloat t = clamp(threshold, 0.0f, 1.0f);\nfloat ct = pixel.g + t, c_t = pixel.g - t;\nmat4 mp = mat4(\npixelAtOffset(image, ivec2(0, 3)).g,\npixelAtOffset(image, ivec2(1, 3)).g,\npixelAtOffset(image, ivec2(2, 2)).g,\npixelAtOffset(image, ivec2(3, 1)).g,\npixelAtOffset(image, ivec2(3, 0)).g,\npixelAtOffset(image, ivec2(3, -1)).g,\npixelAtOffset(image, ivec2(2, -2)).g,\npixelAtOffset(image, ivec2(1, -3)).g,\npixelAtOffset(image, ivec2(0, -3)).g,\npixelAtOffset(image, ivec2(-1, -3)).g,\npixelAtOffset(image, ivec2(-2, -2)).g,\npixelAtOffset(image, ivec2(-3, -1)).g,\npixelAtOffset(image, ivec2(-3, 0)).g,\npixelAtOffset(image, ivec2(-3, 1)).g,\npixelAtOffset(image, ivec2(-2, 2)).g,\npixelAtOffset(image, ivec2(-1, 3)).g\n);\nmat4 mct = mp - mat4(\nct, ct, ct, ct,\nct, ct, ct, ct,\nct, ct, ct, ct,\nct, ct, ct, ct\n), mc_t = mat4(\nc_t, c_t, c_t, c_t,\nc_t, c_t, c_t, c_t,\nc_t, c_t, c_t, c_t,\nc_t, c_t, c_t, c_t\n) - mp;\nvec4 bs = max(mc_t[0], zeroes), ds = max(mct[0], zeroes);\nbs += max(mc_t[1], zeroes); ds += max(mct[1], zeroes);\nbs += max(mc_t[2], zeroes); ds += max(mct[2], zeroes);\nbs += max(mc_t[3], zeroes); ds += max(mct[3], zeroes);\nfloat score = max(dot(bs, ones), dot(ds, ones)) / 16.0f;\ncolor = vec4(score * step(1.0f, pixel.r), pixel.g, score, pixel.a);\n}"},function(e,t){e.exports="uniform sampler2D image;\nuniform float threshold;\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nfloat t = clamp(threshold, 0.0f, 1.0f);\nfloat ct = pixel.g + t, c_t = pixel.g - t;\nfloat p0 = pixelAtOffset(image, ivec2(0, 1)).g;\nfloat p1 = pixelAtOffset(image, ivec2(1, 1)).g;\nfloat p2 = pixelAtOffset(image, ivec2(1, 0)).g;\nfloat p3 = pixelAtOffset(image, ivec2(1, -1)).g;\nfloat p4 = pixelAtOffset(image, ivec2(0, -1)).g;\nfloat p5 = pixelAtOffset(image, ivec2(-1, -1)).g;\nfloat p6 = pixelAtOffset(image, ivec2(-1, 0)).g;\nfloat p7 = pixelAtOffset(image, ivec2(-1, 1)).g;\nvec2 scores = vec2(0.0f, 0.0f);\nscores += vec2(max(c_t - p0, 0.0f), max(p0 - ct, 0.0f));\nscores += vec2(max(c_t - p1, 0.0f), max(p1 - ct, 0.0f));\nscores += vec2(max(c_t - p2, 0.0f), max(p2 - ct, 0.0f));\nscores += vec2(max(c_t - p3, 0.0f), max(p3 - ct, 0.0f));\nscores += vec2(max(c_t - p4, 0.0f), max(p4 - ct, 0.0f));\nscores += vec2(max(c_t - p5, 0.0f), max(p5 - ct, 0.0f));\nscores += vec2(max(c_t - p6, 0.0f), max(p6 - ct, 0.0f));\nscores += vec2(max(c_t - p7, 0.0f), max(p7 - ct, 0.0f));\nfloat score = max(scores.x, scores.y) / 8.0f;\ncolor = vec4(score * step(1.0f, pixel.r), pixel.g, score, pixel.a);\n}"},function(e,t){e.exports="uniform sampler2D image;\nuniform float threshold;\nvoid main()\n{\nivec2 thread = threadLocation();\nivec2 size = outputSize();\nvec4 pixel = threadPixel(image);\ncolor = vec4(0.0f, pixel.gba);\nif(\nthread.x >= 3 && thread.x < size.x - 3 &&\nthread.y >= 3 && thread.y < size.y - 3\n) {\nfloat t = clamp(threshold, 0.0f, 1.0f);\nfloat c = pixel.g;\nfloat ct = c + t, c_t = c - t;\nfloat p0 = pixelAtOffset(image, ivec2(0, 1)).g;\nfloat p1 = pixelAtOffset(image, ivec2(1, 1)).g;\nfloat p2 = pixelAtOffset(image, ivec2(1, 0)).g;\nfloat p3 = pixelAtOffset(image, ivec2(1, -1)).g;\nfloat p4 = pixelAtOffset(image, ivec2(0, -1)).g;\nfloat p5 = pixelAtOffset(image, ivec2(-1, -1)).g;\nfloat p6 = pixelAtOffset(image, ivec2(-1, 0)).g;\nfloat p7 = pixelAtOffset(image, ivec2(-1, 1)).g;\nbool possibleCorner =\n((c_t > p1 || c_t > p5) && (c_t > p3 || c_t > p7)) ||\n((ct < p1  || ct < p5)  && (ct < p3  || ct < p7))  ;\nif(possibleCorner) {\nint bright = 0, dark = 0, bc = 0, dc = 0;\nif(c_t > p0) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p0) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p1) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p1) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p2) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p2) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p3) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p3) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p4) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p4) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p5) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p5) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p6) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p6) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p7) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p7) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(bright < 5 && dark < 5) {\nif(bc > 0 && bc < 5) do {\nif(c_t > p0)           bc += 1; else break;\nif(c_t > p1 && bc < 5) bc += 1; else break;\nif(c_t > p2 && bc < 5) bc += 1; else break;\nif(c_t > p3 && bc < 5) bc += 1; else break;\n} while(false);\nif(dc > 0 && dc < 5) do {\nif(ct < p0)           dc += 1; else break;\nif(ct < p1 && dc < 5) dc += 1; else break;\nif(ct < p2 && dc < 5) dc += 1; else break;\nif(ct < p3 && dc < 5) dc += 1; else break;\n} while(false);\nif(bc >= 5 || dc >= 5)\ncolor = vec4(1.0f, pixel.gba);\n}\nelse {\ncolor = vec4(1.0f, pixel.gba);\n}\n}\n}\n}"},function(e,t){e.exports="uniform sampler2D image;\nuniform float threshold;\nvoid main()\n{\nivec2 thread = threadLocation();\nivec2 size = outputSize();\nvec4 pixel = threadPixel(image);\ncolor = vec4(0.0f, pixel.gba);\nif(\nthread.x >= 3 && thread.x < size.x - 3 &&\nthread.y >= 3 && thread.y < size.y - 3\n) {\nfloat t = clamp(threshold, 0.0f, 1.0f);\nfloat c = pixel.g;\nfloat ct = c + t, c_t = c - t;\nfloat p0 = pixelAtOffset(image, ivec2(0, 2)).g;\nfloat p1 = pixelAtOffset(image, ivec2(1, 2)).g;\nfloat p2 = pixelAtOffset(image, ivec2(2, 1)).g;\nfloat p3 = pixelAtOffset(image, ivec2(2, 0)).g;\nfloat p4 = pixelAtOffset(image, ivec2(2, -1)).g;\nfloat p5 = pixelAtOffset(image, ivec2(1, -2)).g;\nfloat p6 = pixelAtOffset(image, ivec2(0, -2)).g;\nfloat p7 = pixelAtOffset(image, ivec2(-1, -2)).g;\nfloat p8 = pixelAtOffset(image, ivec2(-2, -1)).g;\nfloat p9 = pixelAtOffset(image, ivec2(-2, 0)).g;\nfloat p10 = pixelAtOffset(image, ivec2(-2, 1)).g;\nfloat p11 = pixelAtOffset(image, ivec2(-1, 2)).g;\nbool possibleCorner =\n((c_t > p0 || c_t > p6) && (c_t > p3 || c_t > p9)) ||\n((ct < p0  || ct < p6)  && (ct < p3  || ct < p9))  ;\nif(possibleCorner) {\nint bright = 0, dark = 0, bc = 0, dc = 0;\nif(c_t > p0) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p0) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p1) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p1) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p2) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p2) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p3) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p3) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p4) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p4) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p5) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p5) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p6) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p6) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p7) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p7) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p8) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p8) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p9) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p9) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p10) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p10) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p11) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p11) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(bright < 7 && dark < 7) {\nif(bc > 0 && bc < 7) do {\nif(c_t > p0)           bc += 1; else break;\nif(c_t > p1 && bc < 7) bc += 1; else break;\nif(c_t > p2 && bc < 7) bc += 1; else break;\nif(c_t > p3 && bc < 7) bc += 1; else break;\nif(c_t > p4 && bc < 7) bc += 1; else break;\nif(c_t > p5 && bc < 7) bc += 1; else break;\n} while(false);\nif(dc > 0 && dc < 7) do {\nif(ct < p0)           dc += 1; else break;\nif(ct < p1 && dc < 7) dc += 1; else break;\nif(ct < p2 && dc < 7) dc += 1; else break;\nif(ct < p3 && dc < 7) dc += 1; else break;\nif(ct < p4 && dc < 7) dc += 1; else break;\nif(ct < p5 && dc < 7) dc += 1; else break;\n} while(false);\nif(bc >= 7 || dc >= 7)\ncolor = vec4(1.0f, pixel.gba);\n}\nelse {\ncolor = vec4(1.0f, pixel.gba);\n}\n}\n}\n}"},function(e,t){e.exports="uniform sampler2D image;\nuniform float threshold;\nconst ivec4 margin = ivec4(3, 3, 4, 4);\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nivec2 thread = threadLocation();\nivec2 size = outputSize();\ncolor = vec4(0.0f, pixel.gba);\nif(any(lessThan(ivec4(thread, size - thread), margin)))\nreturn;\nfloat t = clamp(threshold, 0.0f, 1.0f);\nfloat ct = pixel.g + t, c_t = pixel.g - t;\nfloat p0 = pixelAtOffset(image, ivec2(0, 3)).g;\nfloat p4 = pixelAtOffset(image, ivec2(3, 0)).g;\nfloat p8 = pixelAtOffset(image, ivec2(0, -3)).g;\nfloat p12 = pixelAtOffset(image, ivec2(-3, 0)).g;\nif(!(\n((c_t > p0 || c_t > p8) && (c_t > p4 || c_t > p12)) ||\n((ct < p0  || ct < p8)  && (ct < p4  || ct < p12))\n))\nreturn;\nfloat p1 = pixelAtOffset(image, ivec2(1, 3)).g;\nfloat p2 = pixelAtOffset(image, ivec2(2, 2)).g;\nfloat p3 = pixelAtOffset(image, ivec2(3, 1)).g;\nfloat p5 = pixelAtOffset(image, ivec2(3, -1)).g;\nfloat p6 = pixelAtOffset(image, ivec2(2, -2)).g;\nfloat p7 = pixelAtOffset(image, ivec2(1, -3)).g;\nfloat p9 = pixelAtOffset(image, ivec2(-1, -3)).g;\nfloat p10 = pixelAtOffset(image, ivec2(-2, -2)).g;\nfloat p11 = pixelAtOffset(image, ivec2(-3, -1)).g;\nfloat p13 = pixelAtOffset(image, ivec2(-3, 1)).g;\nfloat p14 = pixelAtOffset(image, ivec2(-2, 2)).g;\nfloat p15 = pixelAtOffset(image, ivec2(-1, 3)).g;\nbool A=(p0>ct),B=(p1>ct),C=(p2>ct),D=(p3>ct),E=(p4>ct),F=(p5>ct),G=(p6>ct),H=(p7>ct),I=(p8>ct),J=(p9>ct),K=(p10>ct),L=(p11>ct),M=(p12>ct),N=(p13>ct),O=(p14>ct),P=(p15>ct),a=(p0<c_t),b=(p1<c_t),c=(p2<c_t),d=(p3<c_t),e=(p4<c_t),f=(p5<c_t),g=(p6<c_t),h=(p7<c_t),i=(p8<c_t),j=(p9<c_t),k=(p10<c_t),l=(p11<c_t),m=(p12<c_t),n=(p13<c_t),o=(p14<c_t),p=(p15<c_t);\nbool isCorner=A&&(B&&(K&&L&&J&&(M&&N&&O&&P||G&&H&&I&&(M&&N&&O||F&&(M&&N||E&&(M||D))))||C&&(K&&L&&M&&(N&&O&&P||G&&H&&I&&J&&(N&&O||F&&(N||E)))||D&&(N&&(L&&M&&(K&&G&&H&&I&&J&&(O||F)||O&&P)||k&&l&&m&&e&&f&&g&&h&&i&&j)||E&&(O&&(M&&N&&(K&&L&&G&&H&&I&&J||P)||k&&l&&m&&n&&f&&g&&h&&i&&j)||F&&(P&&(N&&O||k&&l&&m&&n&&o&&g&&h&&i&&j)||G&&(O&&P||H&&(P||I)||k&&l&&m&&n&&o&&p&&h&&i&&j)||k&&l&&m&&n&&o&&h&&i&&j&&(p||g))||k&&l&&m&&n&&h&&i&&j&&(o&&(p||g)||f&&(o&&p||g)))||k&&l&&m&&h&&i&&j&&(n&&(o&&p||g&&(o||f))||e&&(n&&o&&p||g&&(n&&o||f))))||k&&l&&h&&i&&j&&(m&&(n&&o&&p||g&&(n&&o||f&&(n||e)))||d&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e)))))||k&&h&&i&&j&&(l&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d))))))||K&&I&&J&&(L&&M&&N&&O&&P||G&&H&&(L&&M&&N&&O||F&&(L&&M&&N||E&&(L&&M||D&&(L||C)))))||h&&i&&j&&(b&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c)))))||k&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c)))))))||B&&(H&&I&&J&&(K&&L&&M&&N&&O&&P&&a||G&&(K&&L&&M&&N&&O&&a||F&&(K&&L&&M&&N&&a||E&&(K&&L&&M&&a||D&&(K&&L&&a||C)))))||a&&k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||C&&(K&&H&&I&&J&&(L&&M&&N&&O&&P&&a&&b||G&&(L&&M&&N&&O&&a&&b||F&&(L&&M&&N&&a&&b||E&&(L&&M&&a&&b||D))))||a&&b&&k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d)))))||D&&(K&&L&&H&&I&&J&&(M&&N&&O&&P&&a&&b&&c||G&&(M&&N&&O&&a&&b&&c||F&&(M&&N&&a&&b&&c||E)))||a&&b&&k&&l&&m&&c&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e))))||E&&(K&&L&&M&&H&&I&&J&&(N&&O&&P&&a&&b&&c&&d||G&&(N&&O&&a&&b&&c&&d||F))||a&&b&&l&&m&&n&&c&&d&&(k&&g&&h&&i&&j&&(o||f)||o&&p))||F&&(K&&L&&M&&N&&H&&I&&J&&(O&&P&&a&&b&&c&&d&&e||G)||a&&b&&m&&n&&o&&c&&d&&e&&(k&&l&&g&&h&&i&&j||p))||G&&(K&&L&&M&&N&&O&&H&&I&&J||a&&b&&n&&o&&p&&c&&d&&e&&f)||H&&(K&&L&&M&&N&&O&&P&&I&&J||a&&b&&o&&p&&c&&d&&e&&f&&g)||a&&(b&&(k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(k&&l&&m&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e)))||d&&(l&&m&&n&&(k&&g&&h&&i&&j&&(o||f)||o&&p)||e&&(m&&n&&o&&(k&&l&&g&&h&&i&&j||p)||f&&(n&&o&&p||g&&(o&&p||h&&(p||i)))))))||k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||h&&i&&j&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c&&(b||k))))));\ncolor = vec4(float(isCorner), pixel.gba);\n}"},function(e,t){e.exports='@include "pyramids.glsl"\nuniform sampler2D pyramid;\nuniform float threshold;\nuniform float minLod, maxLod;\nuniform bool usePyrSubLevels;\nconst ivec4 margin = ivec4(3, 3, 4, 4);\nconst vec4 zeroes = vec4(0.0f, 0.0f, 0.0f, 0.0f);\nconst vec4 ones = vec4(1.0f, 1.0f, 1.0f, 1.0f);\nvoid main()\n{\nvec4 pixel = threadPixel(pyramid);\nivec2 thread = threadLocation();\nivec2 size = outputSize();\nfloat t = clamp(threshold, 0.0f, 1.0f);\nfloat ct = pixel.g + t, c_t = pixel.g - t;\nfloat pot = exp2(minLod);\nfloat lodJump = 1.0f - float(usePyrSubLevels) * 0.5f;\nvec2 best = vec2(0.0f, pixel.a);\ncolor = vec4(0.0f, pixel.g, 0.0f, pixel.a);\nfor(float lod = minLod; lod <= maxLod; pot = exp2(lod += lodJump)) {\npixel = pyrPixel(pyramid, lod);\nct = pixel.g + t;\nc_t = pixel.g - t;\nvec4 p4k = vec4(\npyrPixelAtOffset(pyramid, lod, pot, ivec2(0, 3)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(3, 0)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(0, -3)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-3, 0)).g\n);\nmat4 mp = mat4(\np4k.x,\np4k.y,\np4k.z,\np4k.w,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(1, 3)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(3, -1)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-1, -3)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-3, 1)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(2, 2)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(2, -2)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-2, -2)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-2, 2)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(3, 1)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(1, -3)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-3, -1)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-1, 3)).g\n);\nbool A=(mp[0][0]>ct),B=(mp[1][0]>ct),C=(mp[2][0]>ct),D=(mp[3][0]>ct),E=(mp[0][1]>ct),F=(mp[1][1]>ct),G=(mp[2][1]>ct),H=(mp[3][1]>ct),I=(mp[0][2]>ct),J=(mp[1][2]>ct),K=(mp[2][2]>ct),L=(mp[3][2]>ct),M=(mp[0][3]>ct),N=(mp[1][3]>ct),O=(mp[2][3]>ct),P=(mp[3][3]>ct),a=(mp[0][0]<c_t),b=(mp[1][0]<c_t),c=(mp[2][0]<c_t),d=(mp[3][0]<c_t),e=(mp[0][1]<c_t),f=(mp[1][1]<c_t),g=(mp[2][1]<c_t),h=(mp[3][1]<c_t),i=(mp[0][2]<c_t),j=(mp[1][2]<c_t),k=(mp[2][2]<c_t),l=(mp[3][2]<c_t),m=(mp[0][3]<c_t),n=(mp[1][3]<c_t),o=(mp[2][3]<c_t),p=(mp[3][3]<c_t);\nbool isCorner=A&&(B&&(K&&L&&J&&(M&&N&&O&&P||G&&H&&I&&(M&&N&&O||F&&(M&&N||E&&(M||D))))||C&&(K&&L&&M&&(N&&O&&P||G&&H&&I&&J&&(N&&O||F&&(N||E)))||D&&(N&&(L&&M&&(K&&G&&H&&I&&J&&(O||F)||O&&P)||k&&l&&m&&e&&f&&g&&h&&i&&j)||E&&(O&&(M&&N&&(K&&L&&G&&H&&I&&J||P)||k&&l&&m&&n&&f&&g&&h&&i&&j)||F&&(P&&(N&&O||k&&l&&m&&n&&o&&g&&h&&i&&j)||G&&(O&&P||H&&(P||I)||k&&l&&m&&n&&o&&p&&h&&i&&j)||k&&l&&m&&n&&o&&h&&i&&j&&(p||g))||k&&l&&m&&n&&h&&i&&j&&(o&&(p||g)||f&&(o&&p||g)))||k&&l&&m&&h&&i&&j&&(n&&(o&&p||g&&(o||f))||e&&(n&&o&&p||g&&(n&&o||f))))||k&&l&&h&&i&&j&&(m&&(n&&o&&p||g&&(n&&o||f&&(n||e)))||d&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e)))))||k&&h&&i&&j&&(l&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d))))))||K&&I&&J&&(L&&M&&N&&O&&P||G&&H&&(L&&M&&N&&O||F&&(L&&M&&N||E&&(L&&M||D&&(L||C)))))||h&&i&&j&&(b&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c)))))||k&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c)))))))||B&&(H&&I&&J&&(K&&L&&M&&N&&O&&P&&a||G&&(K&&L&&M&&N&&O&&a||F&&(K&&L&&M&&N&&a||E&&(K&&L&&M&&a||D&&(K&&L&&a||C)))))||a&&k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||C&&(K&&H&&I&&J&&(L&&M&&N&&O&&P&&a&&b||G&&(L&&M&&N&&O&&a&&b||F&&(L&&M&&N&&a&&b||E&&(L&&M&&a&&b||D))))||a&&b&&k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d)))))||D&&(K&&L&&H&&I&&J&&(M&&N&&O&&P&&a&&b&&c||G&&(M&&N&&O&&a&&b&&c||F&&(M&&N&&a&&b&&c||E)))||a&&b&&k&&l&&m&&c&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e))))||E&&(K&&L&&M&&H&&I&&J&&(N&&O&&P&&a&&b&&c&&d||G&&(N&&O&&a&&b&&c&&d||F))||a&&b&&l&&m&&n&&c&&d&&(k&&g&&h&&i&&j&&(o||f)||o&&p))||F&&(K&&L&&M&&N&&H&&I&&J&&(O&&P&&a&&b&&c&&d&&e||G)||a&&b&&m&&n&&o&&c&&d&&e&&(k&&l&&g&&h&&i&&j||p))||G&&(K&&L&&M&&N&&O&&H&&I&&J||a&&b&&n&&o&&p&&c&&d&&e&&f)||H&&(K&&L&&M&&N&&O&&P&&I&&J||a&&b&&o&&p&&c&&d&&e&&f&&g)||a&&(b&&(k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(k&&l&&m&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e)))||d&&(l&&m&&n&&(k&&g&&h&&i&&j&&(o||f)||o&&p)||e&&(m&&n&&o&&(k&&l&&g&&h&&i&&j||p)||f&&(n&&o&&p||g&&(o&&p||h&&(p||i)))))))||k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||h&&i&&j&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c&&(b||k))))));\nmat4 mct = mp - mat4(\nct, ct, ct, ct,\nct, ct, ct, ct,\nct, ct, ct, ct,\nct, ct, ct, ct\n), mc_t = mat4(\nc_t, c_t, c_t, c_t,\nc_t, c_t, c_t, c_t,\nc_t, c_t, c_t, c_t,\nc_t, c_t, c_t, c_t\n) - mp;\nvec4 bs = max(mc_t[0], zeroes), ds = max(mct[0], zeroes);\nbs += max(mc_t[1], zeroes); ds += max(mct[1], zeroes);\nbs += max(mc_t[2], zeroes); ds += max(mct[2], zeroes);\nbs += max(mc_t[3], zeroes); ds += max(mct[3], zeroes);\nfloat score = max(dot(bs, ones), dot(ds, ones)) / 16.0f;\nscore *= float(isCorner);\nivec2 remainder = thread % int(pot);\nscore *= float(remainder.x + remainder.y == 0);\nfloat scale = encodeLod(lod);\nbest = (score > best.x) ? vec2(score, scale) : best;\n}\ncolor.rba = best.xxy;\n}'},function(e,t){e.exports="uniform sampler2D corners;\nuniform sampler2D maxScore;\nuniform float quality;\nvoid main()\n{\nvec4 pixel = threadPixel(corners);\nfloat threshold = threadPixel(maxScore).r * clamp(quality, 0.0f, 1.0f);\nfloat score = step(threshold, pixel.r) * pixel.r;\ncolor = vec4(score, pixel.gba);\n}"},function(e,t){e.exports='@include "sobel.glsl"\n@include "pyramids.glsl"\nuniform sampler2D pyramid;\nuniform int windowRadius;\nuniform float minLod, maxLod;\nuniform bool usePyrSubLevels;\nuniform sampler2D sobelDerivatives[7];\nvec4 pickSobelDerivatives(int index, ivec2 offset)\n{\nswitch(index) {\ncase 0:  return textureLod(sobelDerivatives[0], texCoord + vec2(offset) / texSize, 0.0f);\ncase 1:  return textureLod(sobelDerivatives[1], texCoord + vec2(offset) / texSize, 0.0f);\ncase 2:  return textureLod(sobelDerivatives[2], texCoord + vec2(offset) / texSize, 0.0f);\ncase 3:  return textureLod(sobelDerivatives[3], texCoord + vec2(offset) / texSize, 0.0f);\ncase 4:  return textureLod(sobelDerivatives[4], texCoord + vec2(offset) / texSize, 0.0f);\ncase 5:  return textureLod(sobelDerivatives[5], texCoord + vec2(offset) / texSize, 0.0f);\ncase 6:  return textureLod(sobelDerivatives[6], texCoord + vec2(offset) / texSize, 0.0f);\ndefault: return textureLod(sobelDerivatives[0], texCoord + vec2(offset) / texSize, 0.0f);\n}\n}\nvoid main()\n{\nivec2 thread = threadLocation();\nvec4 pixel = threadPixel(pyramid);\nvec2 best = vec2(0.0f, pixel.a);\nhighp float lodJump = 1.0f - float(usePyrSubLevels) * 0.5f;\nfor(highp float lod = maxLod; lod >= minLod; lod -= lodJump) {\nint sobelIndex = int(lod / lodJump);\nvec3 m = vec3(0.0f, 0.0f, 0.0f);\nfor(int j = -windowRadius; j <= windowRadius; j++) {\nfor(int i = -windowRadius; i <= windowRadius; i++) {\nvec2 df = decodeSobel(pickSobelDerivatives(sobelIndex, ivec2(i, j)));\nm += vec3(df.x * df.x, df.x * df.y, df.y * df.y);\n}\n}\nfloat response = 0.5f * (m.x + m.z - sqrt((m.x - m.z) * (m.x - m.z) + 4.0f * m.y * m.y));\nfloat score = max(0.0f, response / 4.0f);\nfloat scale = encodeLod(lod);\nbest = (score > best.x) ? vec2(score, scale) : best;\n}\ncolor = vec4(best.x, pixel.g, best.xy);\n}'},function(e,t){e.exports='@include "math.glsl"\n@include "pyramids.glsl"\nuniform sampler2D corners;\nuniform int patchRadius;\nuniform sampler2D pyramid;\nvoid main()\n{\nvec4 pixel = threadPixel(corners);\nfloat angle = 0.5f;\ncolor = vec4(pixel.rg, angle, pixel.a);\nif(pixel.r == 0.0f)\nreturn;\nfloat lod = decodeLod(pixel.a);\nfloat pot = exp2(lod);\nvec2 m = vec2(0.0f, 0.0f);\nif(patchRadius >= 1) {\nmat4 p;\np[0] = vec4(\npyrPixelAtOffset(pyramid, lod, pot, ivec2(0, -1)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(1, -1)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(1, 0)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(1, 1)).g\n);\np[1] = vec4(\npyrPixelAtOffset(pyramid, lod, pot, ivec2(0, 1)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-1, 1)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-1, 0)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-1, -1)).g\n);\nm += vec2(0.0f, -p[0][0]);\nm += vec2(p[0][1], -p[0][1]);\nm += vec2(p[0][2], 0.0f);\nm += vec2(p[0][3], p[0][3]);\nm += vec2(0.0f, p[1][0]);\nm += vec2(-p[1][1], p[1][1]);\nm += vec2(-p[1][2], 0.0f);\nm += vec2(-p[1][3], -p[1][3]);\nif(patchRadius >= 2) {\np[0] = vec4(\npyrPixelAtOffset(pyramid, lod, pot, ivec2(0, -2)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(1, -2)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(2, -1)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(2, 0)).g\n);\np[1] = vec4(\npyrPixelAtOffset(pyramid, lod, pot, ivec2(2, 1)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(1, 2)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(0, 2)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-1, 2)).g\n);\np[2] = vec4(\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-2, 1)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-2, 0)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-2, -1)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-1, -2)).g\n);\nm += vec2(0.0f, -2.0f * p[0][0]);\nm += vec2(p[0][1], -2.0f * p[0][1]);\nm += vec2(2.0f * p[0][2], -p[0][2]);\nm += vec2(2.0f * p[0][3], 0.0f);\nm += vec2(2.0f * p[1][0], p[1][0]);\nm += vec2(p[1][1], 2.0f * p[1][1]);\nm += vec2(0.0f, 2.0f * p[1][2]);\nm += vec2(-p[1][3], 2.0f * p[1][3]);\nm += vec2(-2.0f * p[2][0], p[2][0]);\nm += vec2(-2.0f * p[2][1], 0.0f);\nm += vec2(-2.0f * p[2][2], -p[2][2]);\nm += vec2(-p[2][3], -2.0f * p[2][3]);\nif(patchRadius >= 3) {\np[0] = vec4(\npyrPixelAtOffset(pyramid, lod, pot, ivec2(0, -3)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(1, -3)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(2, -2)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(3, -1)).g\n);\np[1] = vec4(\npyrPixelAtOffset(pyramid, lod, pot, ivec2(3, 0)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(3, 1)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(2, 2)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(1, 3)).g\n);\np[2] = vec4(\npyrPixelAtOffset(pyramid, lod, pot, ivec2(0, 3)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-1, 3)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-2, 2)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-3, 1)).g\n);\np[3] = vec4(\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-3, 0)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-3, -1)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-2, -2)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-1, -3)).g\n);\nm += vec2(0.0f, -3.0f * p[0][0]);\nm += vec2(p[0][1], -3.0f * p[0][1]);\nm += vec2(2.0f * p[0][2], -2.0f * p[0][2]);\nm += vec2(3.0f * p[0][3], -p[0][3]);\nm += vec2(3.0f * p[1][0], 0.0f);\nm += vec2(3.0f * p[1][1], p[1][1]);\nm += vec2(2.0f * p[1][2], 2.0f * p[1][2]);\nm += vec2(p[1][3], 3.0f * p[1][3]);\nm += vec2(0.0f, 3.0f * p[2][0]);\nm += vec2(-p[2][1], 3.0f * p[2][1]);\nm += vec2(-2.0f * p[2][2], 2.0f * p[2][2]);\nm += vec2(-3.0f * p[2][3], p[2][3]);\nm += vec2(-3.0f * p[3][0], 0.0f);\nm += vec2(-3.0f * p[3][1], -p[3][1]);\nm += vec2(-2.0f * p[3][2], -2.0f * p[3][2]);\nm += vec2(-p[3][3], -3.0f * p[3][3]);\n}\n}\nangle = (fastAtan2(m.y, m.x) + PI) / TWO_PI;\n}\ncolor.b = angle;\n}'},function(e,t){e.exports='@include "sobel.glsl"\n@include "pyramids.glsl"\nuniform sampler2D pyramid;\nuniform float lod;\nconst mat3 horizontalKernel = mat3(\n-1.0f, 0.0f, 1.0f,\n-2.0f, 0.0f, 2.0f,\n-1.0f, 0.0f, 1.0f\n);\nconst mat3 verticalKernel = mat3(\n1.0f, 2.0f, 1.0f,\n0.0f, 0.0f, 0.0f,\n-1.0f,-2.0f,-1.0f\n);\nconst vec3 ones = vec3(1.0f, 1.0f, 1.0f);\nvoid main()\n{\nfloat pot = exp2(lod);\nmat3 neighbors = mat3(\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-1, -1)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(0, -1)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(1, -1)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-1, 0)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(0, 0)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(1, 0)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-1, 1)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(0, 1)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(1, 1)).g\n);\nmat3 sobelX = matrixCompMult(horizontalKernel, neighbors);\nmat3 sobelY = matrixCompMult(verticalKernel, neighbors);\nvec2 df = vec2(\ndot(sobelX[0] + sobelX[1] + sobelX[2], ones),\ndot(sobelY[0] + sobelY[1] + sobelY[2], ones)\n);\ncolor = encodeSobel(df);\n}'},function(e,t){e.exports='@include "pyramids.glsl"\nuniform sampler2D image;\nuniform bool usePyrSubLevels;\nconst float scaleEps = 1e-5;\n#define ENABLE_INNER_RING\n#define ENABLE_MIDDLE_RING\n#define ENABLE_OUTER_RING\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nfloat lod = decodeLod(pixel.a);\nfloat lodJump = 1.0f;\ncolor = pixel;\nif(pixel.r == 0.0f)\nreturn;\n#ifdef ENABLE_INNER_RING\nvec4 p0 = pixelAtOffset(image, ivec2(0, 1));\nvec4 p1 = pixelAtOffset(image, ivec2(1, 1));\nvec4 p2 = pixelAtOffset(image, ivec2(1, 0));\nvec4 p3 = pixelAtOffset(image, ivec2(1, -1));\nvec4 p4 = pixelAtOffset(image, ivec2(0, -1));\nvec4 p5 = pixelAtOffset(image, ivec2(-1, -1));\nvec4 p6 = pixelAtOffset(image, ivec2(-1, 0));\nvec4 p7 = pixelAtOffset(image, ivec2(-1, 1));\n#else\nvec4 p0, p1, p2, p3, p4, p5, p6, p7;\np0 = p1 = p2 = p3 = p4 = p5 = p6 = p7 = vec4(0.0f, 0.0f, 0.0f, 1.0f);\n#endif\n#ifdef ENABLE_MIDDLE_RING\nvec4 q0 = pixelAtOffset(image, ivec2(0, 2));\nvec4 q1 = pixelAtOffset(image, ivec2(1, 2));\nvec4 q2 = pixelAtOffset(image, ivec2(2, 2));\nvec4 q3 = pixelAtOffset(image, ivec2(2, 1));\nvec4 q4 = pixelAtOffset(image, ivec2(2, 0));\nvec4 q5 = pixelAtOffset(image, ivec2(2, -1));\nvec4 q6 = pixelAtOffset(image, ivec2(2, -2));\nvec4 q7 = pixelAtOffset(image, ivec2(1, -2));\nvec4 q8 = pixelAtOffset(image, ivec2(0, -2));\nvec4 q9 = pixelAtOffset(image, ivec2(-1, -2));\nvec4 q10 = pixelAtOffset(image, ivec2(-2, -2));\nvec4 q11 = pixelAtOffset(image, ivec2(-2, -1));\nvec4 q12 = pixelAtOffset(image, ivec2(-2, 0));\nvec4 q13 = pixelAtOffset(image, ivec2(-2, 1));\nvec4 q14 = pixelAtOffset(image, ivec2(-2, 2));\nvec4 q15 = pixelAtOffset(image, ivec2(-1, 2));\n#else\nvec4 q0, q1, q2, q3, q4, q5, q6, q7, q8, q9, q10, q11, q12, q13, q14, q15;\nq0 = q1 = q2 = q3 = q4 = q5 = q6 = q7 = q8 = q9 = q10 =\nq11 = q12 = q13 = q14 = q15= vec4(0.0f, 0.0f, 0.0f, 1.0f);\n#endif\n#ifdef ENABLE_OUTER_RING\nvec4 r0 = pixelAtOffset(image, ivec2(0, 3));\nvec4 r1 = pixelAtOffset(image, ivec2(1, 3));\nvec4 r2 = pixelAtOffset(image, ivec2(3, 1));\nvec4 r3 = pixelAtOffset(image, ivec2(3, 0));\nvec4 r4 = pixelAtOffset(image, ivec2(3, -1));\nvec4 r5 = pixelAtOffset(image, ivec2(1, -3));\nvec4 r6 = pixelAtOffset(image, ivec2(0, -3));\nvec4 r7 = pixelAtOffset(image, ivec2(-1, -3));\nvec4 r8 = pixelAtOffset(image, ivec2(-3, -1));\nvec4 r9 = pixelAtOffset(image, ivec2(-3, 0));\nvec4 r10 = pixelAtOffset(image, ivec2(-3, 1));\nvec4 r11 = pixelAtOffset(image, ivec2(-1, 3));\nvec4 r12 = pixelAtOffset(image, ivec2(0, 4));\nvec4 r13 = pixelAtOffset(image, ivec2(4, 0));\nvec4 r14 = pixelAtOffset(image, ivec2(0, -4));\nvec4 r15 = pixelAtOffset(image, ivec2(-4, 0));\n#else\nvec4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15;\nr0 = r1 = r2 = r3 = r4 = r5 = r6 = r7 = r8 = r9 = r10 =\nr11 = r12 = r13 = r14 = r15 = vec4(0.0f, 0.0f, 0.0f, 1.0f);\n#endif\nfloat lodPlus = min(lod + lodJump, PYRAMID_MAX_LEVELS - 1.0f);\nfloat lodMinus = max(lod - lodJump, 0.0f);\nfloat alphaPlus = encodeLod(lodPlus);\nfloat alphaMinus = encodeLod(lodMinus);\nmat3 innerScore = mat3(\np0.r * float(abs(p0.a - alphaPlus) < scaleEps || abs(p0.a - alphaMinus) < scaleEps),\np1.r * float(abs(p1.a - alphaPlus) < scaleEps || abs(p1.a - alphaMinus) < scaleEps),\np2.r * float(abs(p2.a - alphaPlus) < scaleEps || abs(p2.a - alphaMinus) < scaleEps),\np3.r * float(abs(p3.a - alphaPlus) < scaleEps || abs(p3.a - alphaMinus) < scaleEps),\np4.r * float(abs(p4.a - alphaPlus) < scaleEps || abs(p4.a - alphaMinus) < scaleEps),\np5.r * float(abs(p5.a - alphaPlus) < scaleEps || abs(p5.a - alphaMinus) < scaleEps),\np6.r * float(abs(p6.a - alphaPlus) < scaleEps || abs(p6.a - alphaMinus) < scaleEps),\np7.r * float(abs(p7.a - alphaPlus) < scaleEps || abs(p7.a - alphaMinus) < scaleEps),\n0.0f\n);\nmat4 middleScore = mat4(\nq0.r * float(abs(q0.a - alphaPlus) < scaleEps || abs(q0.a - alphaMinus) < scaleEps),\nq1.r * float(abs(q1.a - alphaPlus) < scaleEps || abs(q1.a - alphaMinus) < scaleEps),\nq2.r * float(abs(q2.a - alphaPlus) < scaleEps || abs(q2.a - alphaMinus) < scaleEps),\nq3.r * float(abs(q3.a - alphaPlus) < scaleEps || abs(q3.a - alphaMinus) < scaleEps),\nq4.r * float(abs(q4.a - alphaPlus) < scaleEps || abs(q4.a - alphaMinus) < scaleEps),\nq5.r * float(abs(q5.a - alphaPlus) < scaleEps || abs(q5.a - alphaMinus) < scaleEps),\nq6.r * float(abs(q6.a - alphaPlus) < scaleEps || abs(q6.a - alphaMinus) < scaleEps),\nq7.r * float(abs(q7.a - alphaPlus) < scaleEps || abs(q7.a - alphaMinus) < scaleEps),\nq8.r * float(abs(q8.a - alphaPlus) < scaleEps || abs(q8.a - alphaMinus) < scaleEps),\nq9.r * float(abs(q9.a - alphaPlus) < scaleEps || abs(q9.a - alphaMinus) < scaleEps),\nq10.r * float(abs(q10.a - alphaPlus) < scaleEps || abs(q10.a - alphaMinus) < scaleEps),\nq11.r * float(abs(q11.a - alphaPlus) < scaleEps || abs(q11.a - alphaMinus) < scaleEps),\nq12.r * float(abs(q12.a - alphaPlus) < scaleEps || abs(q12.a - alphaMinus) < scaleEps),\nq13.r * float(abs(q13.a - alphaPlus) < scaleEps || abs(q13.a - alphaMinus) < scaleEps),\nq14.r * float(abs(q14.a - alphaPlus) < scaleEps || abs(q14.a - alphaMinus) < scaleEps),\nq15.r * float(abs(q15.a - alphaPlus) < scaleEps || abs(q15.a - alphaMinus) < scaleEps)\n);\nmat4 outerScore = mat4(\nr0.r * float(abs(r0.a - alphaPlus) < scaleEps || abs(r0.a - alphaMinus) < scaleEps),\nr1.r * float(abs(r1.a - alphaPlus) < scaleEps || abs(r1.a - alphaMinus) < scaleEps),\nr2.r * float(abs(r2.a - alphaPlus) < scaleEps || abs(r2.a - alphaMinus) < scaleEps),\nr3.r * float(abs(r3.a - alphaPlus) < scaleEps || abs(r3.a - alphaMinus) < scaleEps),\nr4.r * float(abs(r4.a - alphaPlus) < scaleEps || abs(r4.a - alphaMinus) < scaleEps),\nr5.r * float(abs(r5.a - alphaPlus) < scaleEps || abs(r5.a - alphaMinus) < scaleEps),\nr6.r * float(abs(r6.a - alphaPlus) < scaleEps || abs(r6.a - alphaMinus) < scaleEps),\nr7.r * float(abs(r7.a - alphaPlus) < scaleEps || abs(r7.a - alphaMinus) < scaleEps),\nr8.r * float(abs(r8.a - alphaPlus) < scaleEps || abs(r8.a - alphaMinus) < scaleEps),\nr9.r * float(abs(r9.a - alphaPlus) < scaleEps || abs(r9.a - alphaMinus) < scaleEps),\nr10.r * float(abs(r10.a - alphaPlus) < scaleEps || abs(r10.a - alphaMinus) < scaleEps),\nr11.r * float(abs(r11.a - alphaPlus) < scaleEps || abs(r11.a - alphaMinus) < scaleEps),\nr12.r * float(abs(r12.a - alphaPlus) < scaleEps || abs(r12.a - alphaMinus) < scaleEps),\nr13.r * float(abs(r13.a - alphaPlus) < scaleEps || abs(r13.a - alphaMinus) < scaleEps),\nr14.r * float(abs(r14.a - alphaPlus) < scaleEps || abs(r14.a - alphaMinus) < scaleEps),\nr15.r * float(abs(r15.a - alphaPlus) < scaleEps || abs(r15.a - alphaMinus) < scaleEps)\n);\nvec3 maxInnerScore3 = max(innerScore[0], max(innerScore[1], innerScore[2]));\nvec4 maxMiddleScore4 = max(max(middleScore[0], middleScore[1]), max(middleScore[2], middleScore[3]));\nvec4 maxOuterScore4 = max(max(outerScore[0], outerScore[1]), max(outerScore[2], outerScore[3]));\nfloat maxInnerScore = max(maxInnerScore3.x, max(maxInnerScore3.y, maxInnerScore3.z));\nfloat maxMiddleScore = max(max(maxMiddleScore4.x, maxMiddleScore4.y), max(maxMiddleScore4.z, maxMiddleScore4.w));\nfloat maxOuterScore = max(max(maxOuterScore4.x, maxOuterScore4.y), max(maxOuterScore4.z, maxOuterScore4.w));\nfloat maxScore = max(maxInnerScore, max(maxMiddleScore, maxOuterScore));\nfloat myScore = step(maxScore, pixel.r) * pixel.r;\ncolor = vec4(myScore, pixel.gba);\n}'},function(e,t){e.exports="uniform sampler2D image;\nvoid main()\n{\nfloat p0 = pixelAtOffset(image, ivec2(0, 1)).r;\nfloat p1 = pixelAtOffset(image, ivec2(1, 1)).r;\nfloat p2 = pixelAtOffset(image, ivec2(1, 0)).r;\nfloat p3 = pixelAtOffset(image, ivec2(1, -1)).r;\nfloat p4 = pixelAtOffset(image, ivec2(0, -1)).r;\nfloat p5 = pixelAtOffset(image, ivec2(-1, -1)).r;\nfloat p6 = pixelAtOffset(image, ivec2(-1, 0)).r;\nfloat p7 = pixelAtOffset(image, ivec2(-1, 1)).r;\nfloat m = max(\nmax(max(p0, p1), max(p2, p3)),\nmax(max(p4, p5), max(p6, p7))\n);\nvec4 pixel = threadPixel(image);\nfloat score = step(m, pixel.r) * pixel.r;\ncolor = vec4(score, pixel.gba);\n}"},function(e,t){e.exports='@include "math.glsl"\nuniform sampler2D corners;\nuniform int patchRadius;\nvoid main()\n{\nvec4 pixel = threadPixel(corners);\nvec2 m = vec2(0.0f, 0.0f);\nfloat angle = 0.5f;\ncolor = vec4(pixel.rg, angle, pixel.a);\nif(pixel.r == 0.0f)\nreturn;\nif(patchRadius >= 1) {\nmat4 p;\np[0] = vec4(\npixelAtOffset(corners, ivec2(0, -1)).g,\npixelAtOffset(corners, ivec2(1, -1)).g,\npixelAtOffset(corners, ivec2(1, 0)).g,\npixelAtOffset(corners, ivec2(1, 1)).g\n);\np[1] = vec4(\npixelAtOffset(corners, ivec2(0, 1)).g,\npixelAtOffset(corners, ivec2(-1, 1)).g,\npixelAtOffset(corners, ivec2(-1, 0)).g,\npixelAtOffset(corners, ivec2(-1, -1)).g\n);\nm += vec2(0.0f, -p[0][0]);\nm += vec2(p[0][1], -p[0][1]);\nm += vec2(p[0][2], 0.0f);\nm += vec2(p[0][3], p[0][3]);\nm += vec2(0.0f, p[1][0]);\nm += vec2(-p[1][1], p[1][1]);\nm += vec2(-p[1][2], 0.0f);\nm += vec2(-p[1][3], -p[1][3]);\nif(patchRadius >= 2) {\np[0] = vec4(\npixelAtOffset(corners, ivec2(0, -2)).g,\npixelAtOffset(corners, ivec2(1, -2)).g,\npixelAtOffset(corners, ivec2(2, -1)).g,\npixelAtOffset(corners, ivec2(2, 0)).g\n);\np[1] = vec4(\npixelAtOffset(corners, ivec2(2, 1)).g,\npixelAtOffset(corners, ivec2(1, 2)).g,\npixelAtOffset(corners, ivec2(0, 2)).g,\npixelAtOffset(corners, ivec2(-1, 2)).g\n);\np[2] = vec4(\npixelAtOffset(corners, ivec2(-2, 1)).g,\npixelAtOffset(corners, ivec2(-2, 0)).g,\npixelAtOffset(corners, ivec2(-2, -1)).g,\npixelAtOffset(corners, ivec2(-1, -2)).g\n);\nm += vec2(0.0f, -2.0f * p[0][0]);\nm += vec2(p[0][1], -2.0f * p[0][1]);\nm += vec2(2.0f * p[0][2], -p[0][2]);\nm += vec2(2.0f * p[0][3], 0.0f);\nm += vec2(2.0f * p[1][0], p[1][0]);\nm += vec2(p[1][1], 2.0f * p[1][1]);\nm += vec2(0.0f, 2.0f * p[1][2]);\nm += vec2(-p[1][3], 2.0f * p[1][3]);\nm += vec2(-2.0f * p[2][0], p[2][0]);\nm += vec2(-2.0f * p[2][1], 0.0f);\nm += vec2(-2.0f * p[2][2], -p[2][2]);\nm += vec2(-p[2][3], -2.0f * p[2][3]);\nif(patchRadius >= 3) {\np[0] = vec4(\npixelAtOffset(corners, ivec2(0, -3)).g,\npixelAtOffset(corners, ivec2(1, -3)).g,\npixelAtOffset(corners, ivec2(2, -2)).g,\npixelAtOffset(corners, ivec2(3, -1)).g\n);\np[1] = vec4(\npixelAtOffset(corners, ivec2(3, 0)).g,\npixelAtOffset(corners, ivec2(3, 1)).g,\npixelAtOffset(corners, ivec2(2, 2)).g,\npixelAtOffset(corners, ivec2(1, 3)).g\n);\np[2] = vec4(\npixelAtOffset(corners, ivec2(0, 3)).g,\npixelAtOffset(corners, ivec2(-1, 3)).g,\npixelAtOffset(corners, ivec2(-2, 2)).g,\npixelAtOffset(corners, ivec2(-3, 1)).g\n);\np[3] = vec4(\npixelAtOffset(corners, ivec2(-3, 0)).g,\npixelAtOffset(corners, ivec2(-3, -1)).g,\npixelAtOffset(corners, ivec2(-2, -2)).g,\npixelAtOffset(corners, ivec2(-1, -3)).g\n);\nm += vec2(0.0f, -3.0f * p[0][0]);\nm += vec2(p[0][1], -3.0f * p[0][1]);\nm += vec2(2.0f * p[0][2], -2.0f * p[0][2]);\nm += vec2(3.0f * p[0][3], -p[0][3]);\nm += vec2(3.0f * p[1][0], 0.0f);\nm += vec2(3.0f * p[1][1], p[1][1]);\nm += vec2(2.0f * p[1][2], 2.0f * p[1][2]);\nm += vec2(p[1][3], 3.0f * p[1][3]);\nm += vec2(0.0f, 3.0f * p[2][0]);\nm += vec2(-p[2][1], 3.0f * p[2][1]);\nm += vec2(-2.0f * p[2][2], 2.0f * p[2][2]);\nm += vec2(-3.0f * p[2][3], p[2][3]);\nm += vec2(-3.0f * p[3][0], 0.0f);\nm += vec2(-3.0f * p[3][1], -p[3][1]);\nm += vec2(-2.0f * p[3][2], -2.0f * p[3][2]);\nm += vec2(-p[3][3], -3.0f * p[3][3]);\n}\n}\nangle = (fastAtan2(m.y, m.x) + PI) / TWO_PI;\n}\ncolor.b = angle;\n}'},function(e,t){e.exports='@include "pyramids.glsl"\nuniform sampler2D image;\nconst float scaleEps = 1e-5;\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nivec2 thread = threadLocation();\nfloat lod = decodeLod(pixel.a);\nfloat pot = exp2(lod);\ncolor = pixel;\nif(pixel.r == 0.0f)\nreturn;\nvec4 p0 = pixelAtOffset(image, ivec2(0, 1));\nvec4 p1 = pixelAtOffset(image, ivec2(1, 1));\nvec4 p2 = pixelAtOffset(image, ivec2(1, 0));\nvec4 p3 = pixelAtOffset(image, ivec2(1, -1));\nvec4 p4 = pixelAtOffset(image, ivec2(0, -1));\nvec4 p5 = pixelAtOffset(image, ivec2(-1, -1));\nvec4 p6 = pixelAtOffset(image, ivec2(-1, 0));\nvec4 p7 = pixelAtOffset(image, ivec2(-1, 1));\nmat3 score = mat3(\np0.r * float(abs(p0.a - pixel.a) < scaleEps),\np1.r * float(abs(p1.a - pixel.a) < scaleEps),\np2.r * float(abs(p2.a - pixel.a) < scaleEps),\np3.r * float(abs(p3.a - pixel.a) < scaleEps),\np4.r * float(abs(p4.a - pixel.a) < scaleEps),\np5.r * float(abs(p5.a - pixel.a) < scaleEps),\np6.r * float(abs(p6.a - pixel.a) < scaleEps),\np7.r * float(abs(p7.a - pixel.a) < scaleEps),\n0.0f\n);\nvec3 maxScore3 = max(score[0], max(score[1], score[2]));\nfloat maxScore = max(maxScore3.x, max(maxScore3.y, maxScore3.z));\nfloat myScore = step(maxScore, pixel.r) * pixel.r;\ncolor = vec4(myScore, pixel.gba);\n}'},function(e,t){e.exports="uniform sampler2D image;\nvoid main()\n{\nivec2 thread = threadLocation();\nivec2 size = outputSize();\nivec2 zero = ivec2(0, 0);\ncolor = pixelAt(image, clamp(thread, zero, size - 1));\n}"},function(e,t){e.exports="uniform sampler2D image;\nvoid main()\n{\nivec2 thread = threadLocation();\nivec2 pos = min(thread * 2, textureSize(image, 0) - 1);\ncolor = pixelAt(image, pos);\n}"},function(e,t){e.exports="uniform sampler2D image;\nvoid main()\n{\nivec2 thread = threadLocation();\nivec2 pos = min(thread * 3, textureSize(image, 0) - 1);\ncolor = pixelAt(image, pos);\n}"},function(e,t){e.exports="uniform sampler2D largerImage;\nuniform sampler2D smallerImage;\nvoid main()\n{\nivec2 thread = threadLocation();\nvec4 lg = pixelAt(largerImage, min(thread, textureSize(largerImage, 0) - 1));\nvec4 sm = pixelAt(smallerImage, min(thread / 2, textureSize(smallerImage, 0) - 1));\ncolor = ((((thread.x & 1) + (thread.y & 1)) == 0) && (sm.r > lg.r)) ? vec4(sm.r, lg.gb, sm.a) : lg;\n}"},function(e,t){e.exports="uniform sampler2D target;\nuniform sampler2D source;\nvoid main()\n{\nvec4 a = threadPixel(target);\nvec4 b = threadPixel(source);\ncolor = (b.r > a.r) ? b : a;\n}"},function(e,t){e.exports="uniform sampler2D image;\nuniform float imageScale;\nconst ivec2 one = ivec2(1, 1);\n#define B2(expr) bvec2((expr),(expr))\nvoid main()\n{\nivec2 thread = threadLocation();\nivec2 size = outputSize();\nivec2 scaled = ivec2((texCoord * texSize) * imageScale);\nivec2 imageSize = textureSize(image, 0);\nvec4 pixel = threadPixel(image);\nvec4 p0 = pixelAt(image, min(scaled, imageSize-1));\nvec4 p1 = pixelAt(image, min(scaled + ivec2(0, 1), imageSize-1));\nvec4 p2 = pixelAt(image, min(scaled + ivec2(1, 0), imageSize-1));\nvec4 p3 = pixelAt(image, min(scaled + ivec2(1, 1), imageSize-1));\nbool gotCorner = ((thread.x & 1) + (thread.y & 1) == 0) &&\n(all(lessThan(scaled + one, size))) &&\n(p0.r + p1.r + p2.r + p3.r > 0.0f);\nvec2 best = mix(\nvec2(0.0f, pixel.a),\nmix(\nmix(\np1.r > p3.r ? p1.ra : p3.ra,\np1.r > p2.r ? p1.ra : p2.ra,\nB2(p2.r > p3.r)\n),\nmix(\np0.r > p3.r ? p0.ra : p3.ra,\np0.r > p2.r ? p0.ra : p2.ra,\nB2(p2.r > p3.r)\n),\nB2(p0.r > p1.r)\n),\nB2(gotCorner)\n);\ncolor = vec4(best.x, pixel.gb, best.y);\n}"},function(e,t){e.exports="uniform sampler2D image;\nvoid main()\n{\nivec2 thread = threadLocation();\nvec4 pixel = pixelAt(image, thread / 2);\ncolor = (((thread.x + thread.y) & 1) == 0) ? pixel : vec4(0.0f, 0.0f, 0.0f, pixel.a);\n}"},function(e,t){e.exports="uniform sampler2D image;\nvoid main()\n{\nivec2 thread = threadLocation();\nvec4 pixel = pixelAt(image, thread / 3);\nbool cond = ((thread.x - (thread.y % 3) + 3) % 3) == 0;\ncolor = (((thread.x - (thread.y % 3) + 3) % 3) == 0) ? pixel : vec4(0.0f, 0.0f, 0.0f, pixel.a);\n}"},function(e,t){e.exports='@include "colors.glsl"\nuniform sampler2D dest, src;\nuniform int destComponents;\nuniform int srcComponentId;\nvoid main()\n{\nvec4 destPixel = threadPixel(dest);\nvec4 srcPixel = threadPixel(src);\nbvec4 flags = bvec4(\n(destComponents & PIXELCOMPONENT_RED) != 0,\n(destComponents & PIXELCOMPONENT_GREEN) != 0,\n(destComponents & PIXELCOMPONENT_BLUE) != 0,\n(destComponents & PIXELCOMPONENT_ALPHA) != 0\n);\ncolor = mix(destPixel, vec4(srcPixel[srcComponentId]), flags);\n}'},function(e,t){e.exports='@include "colors.glsl"\nuniform sampler2D image;\nuniform int pixelComponents;\nuniform float value;\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nbvec4 flags = bvec4(\n(pixelComponents & PIXELCOMPONENT_RED) != 0,\n(pixelComponents & PIXELCOMPONENT_GREEN) != 0,\n(pixelComponents & PIXELCOMPONENT_BLUE) != 0,\n(pixelComponents & PIXELCOMPONENT_ALPHA) != 0\n);\ncolor = mix(pixel, vec4(value), flags);\n}'},function(e,t){e.exports="uniform float value;\nvoid main()\n{\ncolor = vec4(value);\n}"},function(e,t){e.exports="uniform sampler2D image;\nvoid main() {\nivec2 pos = threadLocation();\npos.y = int(texSize.y) - 1 - pos.y;\ncolor = pixelAt(image, pos);\n}"},function(e,t){e.exports="uniform sampler2D image;\nvoid main()\n{\ncolor = threadPixel(image);\n}"},function(e,t){e.exports="uniform sampler2D image;\nuniform int iterationNumber;\nvoid main()\n{\nivec2 thread = threadLocation();\nivec2 last = outputSize() - ivec2(1);\nint jump = (1 << iterationNumber);\nint clusterLength = jump << 1;\nint clusterMask = clusterLength - 1;\nivec2 clusterPos = ivec2(thread >> (1 + iterationNumber)) << (1 + iterationNumber);\nivec2 next1 = clusterPos + ((thread - clusterPos + ivec2(jump, 0)) & clusterMask);\nivec2 next2 = clusterPos + ((thread - clusterPos + ivec2(0, jump)) & clusterMask);\nivec2 next3 = clusterPos + ((thread - clusterPos + ivec2(jump, jump)) & clusterMask);\nvec4 p0 = texelFetch(image, thread, 0);\nvec4 p1 = texelFetch(image, min(next1, last), 0);\nvec4 p2 = texelFetch(image, min(next2, last), 0);\nvec4 p3 = texelFetch(image, min(next3, last), 0);\nvec4 pmax = max(max(p0, p1), max(p2, p3));\nvec4 pmin = min(min(p0, p1), min(p2, p3));\ncolor = vec4(pmax.r, pmin.g, pmax.r - pmin.g, p0.a);\n}"},function(e,t,i){"use strict";i.r(t),i.d(t,"load",(function(){return Te})),i.d(t,"camera",(function(){return Le})),i.d(t,"pipeline",(function(){return Ce})),i.d(t,"version",(function(){return De})),i.d(t,"fps",(function(){return Re}));var n=i(0);class a extends Error{constructor(e){super("[GLError] "+e),this.name=this.constructor.name}}class r{static Error(e){return new a(e)}static getError(e){const t=e.getError(),i=["NO_ERROR","INVALID_ENUM","INVALID_VALUE","INVALID_OPERATION","INVALID_FRAMEBUFFER_OPERATION","OUT_OF_MEMORY","CONTEXT_LOST_WEBGL"].find(i=>e[i]==t)||"Unknown";return new a(i)}static createShader(e,t,i){const n=e.createShader(t);return e.shaderSource(n,i),e.compileShader(n),n}static createProgram(e,t,i){const n=e.createProgram(),a=r.createShader(e,e.VERTEX_SHADER,t),s=r.createShader(e,e.FRAGMENT_SHADER,i);if(e.attachShader(n,a),e.attachShader(n,s),e.linkProgram(n),!e.getProgramParameter(n,e.LINK_STATUS)&&!e.isContextLost()){const t=[e.getShaderInfoLog(s),e.getShaderInfoLog(a),e.getProgramInfoLog(n)];e.deleteProgram(n),e.deleteShader(s),e.deleteShader(a);const o=e=>Math.max(0,2-Math.floor(Math.log10(e))),c=e=>Array(o(e)).fill(" ").join("")+e+". ",l=i.split("\n").map((e,t)=>c(1+t)+e).join("\n");throw r.Error("Can't create shader.\n\n---------- ERROR ----------\n"+t.join("\n")+"\n\n---------- SOURCE CODE ----------\n"+l)}return n}static createStandardGeometry(e,t,i){const n=r.createStandardGeometry,a=n._cache||(n._cache=new WeakMap);if(a.has(e))return a.get(e);const s=e.createVertexArray(),o=[e.createBuffer(),e.createBuffer()];e.bindVertexArray(s),e.bindBuffer(e.ARRAY_BUFFER,o[0]),e.bufferData(e.ARRAY_BUFFER,new Float32Array([-1,-1,1,-1,-1,1,1,1]),e.STATIC_DRAW),e.vertexAttribPointer(t,2,e.FLOAT,!1,0,0),e.enableVertexAttribArray(t),e.bindBuffer(e.ARRAY_BUFFER,o[1]),e.bufferData(e.ARRAY_BUFFER,new Float32Array([0,0,1,0,0,1,1,1]),e.STATIC_DRAW),e.vertexAttribPointer(i,2,e.FLOAT,!1,0,0),e.enableVertexAttribArray(i),e.bindBuffer(e.ARRAY_BUFFER,null);const c={vao:s,vbo:o};return a.set(e,c),c}static createTexture(e,t,i){if(t<=0||i<=0)throw r.Error("Invalid dimensions given to createTexture()");const n=e.createTexture();return e.bindTexture(e.TEXTURE_2D,n),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.MIRRORED_REPEAT),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.MIRRORED_REPEAT),e.texImage2D(e.TEXTURE_2D,0,e.RGBA8,t,i,0,e.RGBA,e.UNSIGNED_BYTE,null),e.bindTexture(e.TEXTURE_2D,null),n}static destroyTexture(e,t){return e.deleteTexture(t),null}static uploadToTexture(e,t,i,n,a){return e.bindTexture(e.TEXTURE_2D,t),e.texImage2D(e.TEXTURE_2D,0,e.RGBA8,e.RGBA,e.UNSIGNED_BYTE,a),e.bindTexture(e.TEXTURE_2D,null),t}static generateMipmap(e,t){e.bindTexture(e.TEXTURE_2D,t),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR_MIPMAP_NEAREST),e.generateMipmap(e.TEXTURE_2D),e.bindTexture(e.TEXTURE_2D,null)}static bindTextures(e,t,i){const n=Object.keys(t);if(!e.isContextLost()){if(n.length>e.MAX_COMBINED_TEXTURE_IMAGE_UNITS)throw r.Error(`Can't bind ${n.length} textures to a program: max is ${e.MAX_COMBINED_TEXTURE_IMAGE_UNITS}`);for(let a=0;a<n.length;a++)e.activeTexture(e.TEXTURE0+a),e.bindTexture(e.TEXTURE_2D,t[n[a]]),e.uniform1i(i[n[a]],a)}}static createFramebuffer(e,t){const i=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0);const n=e.checkFramebufferStatus(e.FRAMEBUFFER);if(n!=e.FRAMEBUFFER_COMPLETE){const t=["FRAMEBUFFER_UNSUPPORTED","FRAMEBUFFER_INCOMPLETE_ATTACHMENT","FRAMEBUFFER_INCOMPLETE_DIMENSIONS","FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT","FRAMEBUFFER_INCOMPLETE_MULTISAMPLE"].filter(t=>e[t]===n)[0]||"unknown error";throw r.Error(`Can't create framebuffer: ${t} (${n})`)}return e.bindFramebuffer(e.FRAMEBUFFER,null),i}static destroyFramebuffer(e,t){return e.deleteFramebuffer(t),null}static clientWaitAsync(e,t,i=0){return new Promise((a,s)=>{const o=navigator.userAgent.includes("Firefox");!function c(){const l=e.clientWaitSync(t,i,0);l==e.TIMEOUT_EXPIRED?n.a.setZeroTimeout(c):l==e.WAIT_FAILED?o&&e.getError()==e.NO_ERROR?n.a.setZeroTimeout(c):s(r.getError(e)):a()}()})}static getBufferSubDataAsync(e,t,i,n,a,s=0,o=0){const c=e.fenceSync(e.SYNC_GPU_COMMANDS_COMPLETE,0),l=performance.now();return e.flush(),r.clientWaitAsync(e,c).then(()=>(e.bindBuffer(i,t),e.getBufferSubData(i,n,a,s,o),e.bindBuffer(i,null),performance.now()-l)).catch(e=>{throw r.Error(`Can't getBufferSubDataAsync(): got ${e.message} in clientWaitAsync()`)}).finally(()=>{e.deleteSync(c)})}static readPixelsViaPBO(e,t,i,n,a,s,o,c=null){if(!(i.byteLength>=s*o*4))throw r.Error("Can't read pixels: invalid buffer size");return e.bindBuffer(e.PIXEL_PACK_BUFFER,t),e.bufferData(e.PIXEL_PACK_BUFFER,i.byteLength,e.STREAM_READ),c?(e.bindFramebuffer(e.FRAMEBUFFER,c),e.readPixels(n,a,s,o,e.RGBA,e.UNSIGNED_BYTE,0),e.bindFramebuffer(e.FRAMEBUFFER,null)):e.readPixels(n,a,s,o,e.RGBA,e.UNSIGNED_BYTE,0),e.bindBuffer(e.PIXEL_PACK_BUFFER,null),r.getBufferSubDataAsync(e,t,e.PIXEL_PACK_BUFFER,0,i,0,0).then(e=>e).catch(e=>{throw e})}}const s={sampler2D:"uniform1i",float:"uniform1f",int:"uniform1i",uint:"uniform1ui",bool:"uniform1i",vec2:"uniform2f",vec3:"uniform3f",vec4:"uniform4f",ivec2:"uniform2i",ivec3:"uniform3i",ivec4:"uniform4i",uvec2:"uniform2ui",uvec3:"uniform3ui",uvec4:"uniform4ui",bvec2:"uniform2i",bvec3:"uniform3i",bvec4:"uniform4i"};class o extends Function{constructor(e,t,i={}){return super("...args","return this._self._call(...args)"),this._self=this.bind(this),this._self._init(e,t,i),this._self}resize(e,t){const i=this._gl,n=this._options;if(i.isContextLost())return;if(e===this._stdprog.width&&t===this._stdprog.height)return;e=Math.max(1,0|e),t=Math.max(1,0|t),n.output[0]=e,n.output[1]=t,this._stdprog.width=e,this._stdprog.height=t;const a=this._stdprog.uniform.texSize;i[s[a.type]](a.location,e,t),this._reallocatePixelBuffers(e,t)}readPixelsSync(e=0,t=0,i=-1,n=-1){const a=this._gl;return a.isContextLost()||(i<0&&(i=this._stdprog.width),n<0&&(n=this._stdprog.height),i=Math.min(i,this._stdprog.width),n=Math.min(n,this._stdprog.height),e=Math.max(0,Math.min(e,i-1)),t=Math.max(0,Math.min(t,n-1)),null==this._pixelBuffer[0]&&this._reallocatePixelBuffers(this._stdprog.width,this._stdprog.height),null!=this._stdprog.fbo?(a.bindFramebuffer(a.FRAMEBUFFER,this._stdprog.fbo),a.readPixels(e,t,i,n,a.RGBA,a.UNSIGNED_BYTE,this._pixelBuffer[0]),a.bindFramebuffer(a.FRAMEBUFFER,null)):a.readPixels(e,t,i,n,a.RGBA,a.UNSIGNED_BYTE,this._pixelBuffer[0])),this._pixelBuffer[0]}readPixelsAsync(e=0,t=0,i=-1,n=-1){const a=this._gl;if(a.isContextLost())return Promise.resolve(this._pixelBuffer[0]);if(i<0&&(i=this._stdprog.width),n<0&&(n=this._stdprog.height),i=Math.min(i,this._stdprog.width),n=Math.min(n,this._stdprog.height),e=Math.max(0,Math.min(e,i-1)),t=Math.max(0,Math.min(t,n-1)),null==this._pixelBuffer[0]&&this._reallocatePixelBuffers(this._stdprog.width,this._stdprog.height),this._pboProducerQueue.length>0){const s=this._pboProducerQueue.shift();r.readPixelsViaPBO(a,this._pbo[s],this._pixelBuffer[s],e,t,i,n,this._stdprog.fbo).then(e=>{this._pboConsumerQueue.push(s)})}else l(this._pboProducerQueue).then(s=>{const o=this._pboProducerQueue.shift();r.readPixelsViaPBO(a,this._pbo[o],this._pixelBuffer[o],e,t,i,n,this._stdprog.fbo).then(e=>{this._pboConsumerQueue.push(o)})});if(this._pboConsumerQueue.length>0){const e=this._pboConsumerQueue.shift();return new Promise(t=>{t(this._pixelBuffer[e]),this._pboProducerQueue.push(e)})}return new Promise(e=>{l(this._pboConsumerQueue).then(t=>{const i=this._pboConsumerQueue.shift();e(this._pixelBuffer[i]),this._pboProducerQueue.push(i)})})}get uniforms(){return this._stdprog.uniform}_init(e,t,i){(i={output:[e.drawingBufferWidth,e.drawingBufferHeight],uniforms:{},renderToTexture:!0,recycleTexture:!0,pingpong:!1,...i}).pingpong&&!i.renderToTexture&&n.a.fatal("Pingpong rendering can only be used when rendering to textures");let a=Math.max(1,0|i.output[0]),r=Math.max(1,0|i.output[1]);i.output=[a,r];const s=e.canvas;a>s.width&&(s.width=a),r>s.height&&(s.height=r);const o=new c(e,a,r,t,i.uniforms);i.renderToTexture&&o.attachFBO(i.pingpong);const l=t.arguments;for(let e=0;e<l.length;e++)o.uniform.hasOwnProperty(l[e])||o.uniform.hasOwnProperty(l[e]+"[0]")||n.a.fatal(`Can't run shader: expected uniform "${l[e]}"`);this._gl=e,this._source=t.fragmentSource,this._options=Object.freeze(i),this._stdprog=o,this._params=l,this._initPixelBuffers(e)}_call(...e){const t=this._gl,i=this._options,a=this._stdprog,s=this._params;if(t.isContextLost())return a.texture;e.length!=s.length&&n.a.fatal("Can't run shader: incorrect number of arguments"),t.useProgram(a.program);for(let t=0,i=0;t<e.length;t++){const r=s[t];let o=a.uniform[r];if(o)i=this._setUniform(o,e[t],i);else if(a.uniform.hasOwnProperty(r+"[0]")){const s=e[t];a.uniform.hasOwnProperty(`${r}[${s.length}]`)&&n.a.fatal(`Can't run shader: too few elements in array "${r}"`);for(let e=0;o=a.uniform[`${r}[${e}]`];e++)i=this._setUniform(o,s[e],i)}else n.a.fatal(`Can't run shader: unknown parameter "${r}": ${e[t]}`)}i.renderToTexture?t.bindFramebuffer(t.FRAMEBUFFER,a.fbo):t.bindFramebuffer(t.FRAMEBUFFER,null),t.viewport(0,0,a.width,a.height),t.drawArrays(t.TRIANGLE_STRIP,0,4);let o=null;if(i.renderToTexture){if(o=a.texture,!i.recycleTexture){const e=r.createTexture(t,a.width,a.height);t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,e),t.copyTexSubImage2D(t.TEXTURE_2D,0,0,0,0,0,a.width,a.height),t.bindTexture(t.TEXTURE_2D,null),o=e}i.pingpong&&a.pingpong()}return t.bindFramebuffer(t.FRAMEBUFFER,null),o}_setUniform(e,t,i){const a=this._gl;return"sampler2D"==e.type?(i>a.MAX_COMBINED_TEXTURE_IMAGE_UNITS?n.a.fatal(`Can't bind ${i} textures to a program: max is ${a.MAX_COMBINED_TEXTURE_IMAGE_UNITS}`):t===this._stdprog.texture&&n.a.fatal("Can't run shader: cannot use its output texture as an input to itself"),a.activeTexture(a.TEXTURE0+i),a.bindTexture(a.TEXTURE_2D,t),a.uniform1i(e.location,i),i++):"number"==typeof t||"boolean"==typeof t?a[s[e.type]](e.location,t):Array.isArray(t)?a[s[e.type]](e.location,...t):n.a.fatal(`Can't run shader: unrecognized argument "${t}"`),i}_initPixelBuffers(e){this._pixelBuffer=Array(1).fill(null),this._pixelBufferSize=[0,0],this._pboConsumerQueue=Array(1).fill(0).map((e,t)=>t),this._pboProducerQueue=[],this._pbo=Array(1).fill(null).map(()=>e.createBuffer())}_reallocatePixelBuffers(e,t){if(!(e*t<=this._pixelBufferSize[0]*this._pixelBufferSize[1])){this._pixelBufferSize[0]=e,this._pixelBufferSize[1]=t;for(let i=0;i<1;i++){const n=this._pixelBuffer[i];this._pixelBuffer[i]=this._createPixelBuffer(e,t),n&&(n.length>this._pixelBuffer[i].length?this._pixelBuffer[i].set(n.slice(0,this._pixelBuffer[i].length)):this._pixelBuffer[i].set(n))}}}_createPixelBuffer(e,t){const i=new Uint8Array(e*t*4);return i.fill(255,0,4),i}}function c(e,t,i,a,o={}){const c=r.createProgram(e,a.vertexSource,a.fragmentSource);e.bindAttribLocation(c,0,a.attributes.position),e.bindAttribLocation(c,1,a.attributes.texCoord);const l=r.createStandardGeometry(e,0,1);t=Math.max(0|t,1),i=Math.max(0|i,1),o.texSize=[t,i];const p={};for(const e of a.uniforms)p[e]={type:a.uniformType(e)};e.useProgram(c);for(const t in p)if(p[t].location=e.getUniformLocation(c,t),s.hasOwnProperty(p[t].type)||n.a.fatal("Unknown uniform type: "+p[t].type),o.hasOwnProperty(t)){const i=o[t];"number"==typeof i||"boolean"==typeof i?e[s[p[t].type]](p[t].location,i):"object"==typeof i?e[s[p[t].type]](p[t].location,...Array.from(i)):n.a.fatal(`Unrecognized uniform value: "${i}"`)}this.gl=e,this.program=c,this.uniform=p,this.width=t,this.height=i,this.vertexObjects=l,this._fbo=this._texture=null,this._texIndex=0,Object.defineProperty(this,"fbo",{get:()=>this._fbo?this._fbo[this._texIndex]:null}),Object.defineProperty(this,"texture",{get:()=>this._texture?this._texture[this._texIndex]:null})}function l(e){return new Promise(t=>{const i=performance.now();!function n(){e.length>0?t(performance.now()-i):setTimeout(n,0)}()})}c.prototype.attachFBO=function(e=!1){const t=this.gl,i=this.width,n=this.height,a=e?2:1;this._texIndex=0,this._texture=Array(a).fill(null).map(()=>r.createTexture(t,i,n)),this._fbo=Array(a).fill(null).map((e,i)=>r.createFramebuffer(t,this._texture[i]))},c.prototype.detachFBO=function(){const e=this.gl;if(null!=this._fbo){for(let t of this._fbo)r.destroyFramebuffer(e,t);this._fbo=null}if(null!=this._texture){for(let t of this._texture)r.destroyTexture(e,t);this._texture=null}this._texIndex=0},c.prototype.pingpong=function(){null!=this._fbo&&this._fbo.length>1&&(this._texIndex=1-this._texIndex)};class p{constructor(e,t,i){this._gpu=e,this._width=t,this._height=i}declare(e,t,i={}){return Object.defineProperty(this,e,{get:(()=>{const n="__k_"+e;return function(){return this[n]||(this[n]=this._createProgram(t,i))}.bind(this)})()}),this}compose(e,...t){return Object.defineProperty(this,e,{get:(()=>{const i="__c_"+e;return function(){return this[i]||(this[i]=2==t.length?(()=>(t=t.map(e=>this[e]),function(e,...i){return t[1](t[0](e,...i),...i)}))():3==t.length?(()=>(t=t.map(e=>this[e]),function(e,...i){return t[2](t[1](t[0](e,...i),...i),...i)}))():4==t.length?(()=>(t=t.map(e=>this[e]),function(e,...i){return t[3](t[2](t[1](t[0](e,...i),...i),...i),...i)}))():(()=>(t=t.map(e=>this[e]),function(e,...i){return t.reduce((e,t)=>t(e,...i),e)}))())}.bind(this)})()}),this}get program(){return this._helpers||(this.helpers={hasTextureSize:(e,t)=>({output:[0|e,0|t]}),displaysGraphics:()=>({renderToTexture:!1}),doesNotRecycleTextures:()=>({recycleTexture:!1}),usesPingpongRendering:()=>({pingpong:!0})})}_createProgram(e,t={}){return new o(this._gpu.gl,e,{output:[this._width,this._height],...t})}}var f=i(1),h=i(3);const m=Object(f.b)("utils/identity.glsl").withArguments("image"),u=Object(f.b)("utils/flip-y.glsl").withArguments("image"),d=Object(f.b)("utils/fill.glsl").withArguments("value"),g=Object(f.b)("utils/fill-components.glsl").withArguments("image","pixelComponents","value"),x=Object(f.b)("utils/copy-components.glsl").withArguments("dest","src","destComponents","srcComponentId"),_=Object(f.b)("utils/scan-minmax2d.glsl").withArguments("image","iterationNumber");class v extends p{constructor(e,t,i){super(e,t,i),this.declare("identity",m).declare("flipY",u).declare("output",u,{...this.program.displaysGraphics()}).declare("clone",m,{...this.program.doesNotRecycleTextures()}).declare("fill",d).declare("fillComponents",g).declare("copyComponents",x).declare("_scanMinMax2D",_,{...this.program.usesPingpongRendering()})}release(e){return r.destroyTexture(this._gpu.gl,e)}scanMax(e,t){return this._scanMinMax(e,t,!0)}scanMin(e,t){return this._scanMinMax(e,t,!1)}_scanMinMax(e,t,i=!0){const n=0|Math.max(0,Math.min(Math.log2(t),3)),a=0|Math.ceil(Math.log2(Math.max(this._width,this._height)));let r=this.copyComponents(e,e,h.c.ALL,n);for(let e=0;e<a;e++)r=this._scanMinMax2D(r,e);return this.copyComponents(e,r,1<<n,i?0:1)}}const b=Object(f.b)("colors/rgb2grey.glsl").withArguments("image");class y extends p{constructor(e,t,i){super(e,t,i),this.declare("rgb2grey",b)}}var O=i(2);class A extends p{constructor(e,t,i){super(e,t,i),this.compose("gauss5","_gauss5x","_gauss5y").compose("gauss3","_gauss3x","_gauss3y").compose("gauss7","_gauss7x","_gauss7y").compose("box5","_box5x","_box5y").compose("box3","_box3x","_box3y").compose("box7","_box7x","_box7y").compose("box9","_box9x","_box9y").compose("box11","_box11x","_box11y").declare("texConv2D3",Object(O.texConv2D)(3),{...this.program.usesPingpongRendering()}).declare("texConv2D5",Object(O.texConv2D)(5),{...this.program.usesPingpongRendering()}).declare("texConv2D7",Object(O.texConv2D)(7),{...this.program.usesPingpongRendering()}).compose("texConvXY3","texConvX3","texConvY3").declare("texConvX3",Object(O.texConvX)(3)).declare("texConvY3",Object(O.texConvY)(3)).compose("texConvXY5","texConvX5","texConvY5").declare("texConvX5",Object(O.texConvX)(5)).declare("texConvY5",Object(O.texConvY)(5)).compose("texConvXY7","texConvX7","texConvY7").declare("texConvX7",Object(O.texConvX)(7)).declare("texConvY7",Object(O.texConvY)(7)).compose("texConvXY9","texConvX9","texConvY9").declare("texConvX9",Object(O.texConvX)(9)).declare("texConvY9",Object(O.texConvY)(9)).compose("texConvXY11","texConvX11","texConvY11").declare("texConvX11",Object(O.texConvX)(11)).declare("texConvY11",Object(O.texConvY)(11)).declare("createKernel3x3",Object(O.createKernel2D)(3),{...this.program.hasTextureSize(3,3),...this.program.doesNotRecycleTextures()}).declare("createKernel5x5",Object(O.createKernel2D)(5),{...this.program.hasTextureSize(5,5),...this.program.doesNotRecycleTextures()}).declare("createKernel7x7",Object(O.createKernel2D)(7),{...this.program.hasTextureSize(7,7),...this.program.doesNotRecycleTextures()}).declare("createKernel3x1",Object(O.createKernel1D)(3),{...this.program.hasTextureSize(3,1),...this.program.doesNotRecycleTextures()}).declare("createKernel5x1",Object(O.createKernel1D)(5),{...this.program.hasTextureSize(5,1),...this.program.doesNotRecycleTextures()}).declare("createKernel7x1",Object(O.createKernel1D)(7),{...this.program.hasTextureSize(7,1),...this.program.doesNotRecycleTextures()}).declare("createKernel9x1",Object(O.createKernel1D)(9),{...this.program.hasTextureSize(9,1),...this.program.doesNotRecycleTextures()}).declare("createKernel11x1",Object(O.createKernel1D)(11),{...this.program.hasTextureSize(11,1),...this.program.doesNotRecycleTextures()}).declare("_gauss5x",Object(O.convX)([.05,.25,.4,.25,.05])).declare("_gauss5y",Object(O.convY)([.05,.25,.4,.25,.05])).declare("_gauss3x",Object(O.convX)([.25,.5,.25])).declare("_gauss3y",Object(O.convY)([.25,.5,.25])).declare("_gauss7x",Object(O.convX)([.00598,.060626,.241843,.383103,.241843,.060626,.00598])).declare("_gauss7y",Object(O.convY)([.00598,.060626,.241843,.383103,.241843,.060626,.00598])).declare("_box3x",Object(O.convX)([1,1,1],1/3)).declare("_box3y",Object(O.convY)([1,1,1],1/3)).declare("_box5x",Object(O.convX)([1,1,1,1,1],.2)).declare("_box5y",Object(O.convY)([1,1,1,1,1],.2)).declare("_box7x",Object(O.convX)([1,1,1,1,1,1,1],1/7)).declare("_box7y",Object(O.convY)([1,1,1,1,1,1,1],1/7)).declare("_box9x",Object(O.convX)([1,1,1,1,1,1,1,1,1],1/9)).declare("_box9y",Object(O.convY)([1,1,1,1,1,1,1,1,1],1/9)).declare("_box11x",Object(O.convX)([1,1,1,1,1,1,1,1,1,1,1],1/11)).declare("_box11y",Object(O.convY)([1,1,1,1,1,1,1,1,1,1,1],1/11))}}const E=Object(f.b)("keypoints/fast9lg.glsl").withArguments("image","threshold"),P=Object(f.b)("keypoints/fast9pyr.glsl").withArguments("pyramid","threshold","minLod","maxLod","usePyrSubLevels"),M=Object(f.b)("keypoints/fast7.glsl").withArguments("image","threshold"),w=Object(f.b)("keypoints/fast5.glsl").withArguments("image","threshold"),S=Object(f.b)("keypoints/fast-score16.glsl").withArguments("image","threshold"),k=Object(f.b)("keypoints/fast-score12.glsl").withArguments("image","threshold"),T=Object(f.b)("keypoints/fast-score8.glsl").withArguments("image","threshold"),L=Object(f.b)("keypoints/multiscale-harris.glsl").withArguments("pyramid","windowRadius","minLod","maxLod","usePyrSubLevels","sobelDerivatives"),C=Object(f.b)("keypoints/harris-cutoff.glsl").withArguments("corners","maxScore","quality"),D=Object(f.b)("keypoints/brisk.glsl").withArguments("image","layerA","layerB","scaleA","scaleB","lgM","h"),R=Object(f.b)("keypoints/nonmax-suppression.glsl").withArguments("image"),I=Object(f.b)("keypoints/multiscale-suppression.glsl").withArguments("image","usePyrSubLevels"),N=Object(f.b)("keypoints/samescale-suppression.glsl").withArguments("image"),z=Object(f.b)("keypoints/orientation-via-centroid.glsl").withArguments("corners","patchRadius"),j=Object(f.b)("keypoints/multiscale-orientation-via-centroid.glsl").withArguments("corners","patchRadius","pyramid"),F=Object(f.b)("keypoints/multiscale-sobel.glsl").withArguments("pyramid","lod");class B extends p{constructor(e,t,i){super(e,t,i),this.compose("fast9","_fast9","_fastScore16").declare("_fast9",E).declare("_fastScore16",S).compose("fast7","_fast7","_fastScore12").declare("_fast7",M).declare("_fastScore12",k).compose("fast5","_fast5","_fastScore8").declare("_fast5",w).declare("_fastScore8",T).declare("fast9pyr",P).declare("brisk",D).declare("multiscaleHarris",L).declare("harrisCutoff",C).declare("nonmaxSuppression",R).declare("multiscaleSuppression",I).declare("samescaleSuppression",N).declare("orientationViaCentroid",z).declare("multiscaleOrientationViaCentroid",j).declare("multiscaleSobel",F,{...this.program.doesNotRecycleTextures()})}}class q{constructor(e,t,i=1,n=0,a=0,r=null){this._x=+e,this._y=+t,this._scale=+i,this._rotation=+n,this._score=+a,this._descriptor=r}toString(){return`(${this._x},${this._y})`}get x(){return this._x}get y(){return this._y}get scale(){return this._scale}get rotation(){return this._rotation}get score(){return this._score}get descriptor(){return this._descriptor}}class U{constructor(e=32,t=5){this._bucketSize=1<<Math.ceil(Math.log2(e)),this._windowSize=t+(1-t%2),e<this._windowSize&&n.a.fatal("Invalid bucketSize of "+e),this._head=this._bucketSize-1,this._rawData=new Float32Array(this._bucketSize).fill(0),this._smoothedData=new Float32Array(this._bucketSize).fill(0),this._average=0,this._isSmooth=!0}put(e){this._head=this._head+1&this._bucketSize-1,this._rawData[this._head]=e,this._isSmooth=!1}get size(){return this._bucketSize}get average(){return this._isSmooth||this._smooth(),this._average}fill(e){return this._rawData.fill(e),this._smoothedData.fill(e),this._average=e,this._isSmooth=!0,this._head=this._bucketSize-1,this}_smooth(){this._average=0;for(let e=0;e<this._bucketSize;e++)this._smoothedData[e]=this._median(this._window(e)),this._average+=this._smoothedData[e];this._average/=this._bucketSize,this._isSmooth=!0}_window(e){const t=this._rawData,i=this._win||(this._win=new Float32Array(this._windowSize)),n=t.length,a=i.length>>1,r=this._head,s=r+1&n-1;for(let o=0,c=-a;c<=a;c++){let a=e+c;e<=r?a>r&&(a=r+(r-a)):a<s&&(a=s+(s-a)),a<0?a+=n:a>=n&&(a-=n),i[o++]=t[a]}return i}_median(e){switch(e.length){case 1:return e[0];case 3:return e[0]>e[1]&&([e[0],e[1]]=[e[1],e[0]]),e[1]>e[2]&&([e[1],e[2]]=[e[2],e[1]]),e[0]>e[1]&&([e[0],e[1]]=[e[1],e[0]]),e[1];case 5:return e[0]>e[1]&&([e[0],e[1]]=[e[1],e[0]]),e[3]>e[4]&&([e[3],e[4]]=[e[4],e[3]]),e[0]>e[3]&&([e[0],e[3]]=[e[3],e[0]]),e[1]>e[4]&&([e[1],e[4]]=[e[4],e[1]]),e[1]>e[2]&&([e[1],e[2]]=[e[2],e[1]]),e[2]>e[3]&&([e[2],e[3]]=[e[3],e[2]]),e[1]>e[2]&&([e[1],e[2]]=[e[2],e[1]]),e[2];case 7:return e[0]>e[5]&&([e[0],e[5]]=[e[5],e[0]]),e[0]>e[3]&&([e[0],e[3]]=[e[3],e[0]]),e[1]>e[6]&&([e[1],e[6]]=[e[6],e[1]]),e[2]>e[4]&&([e[2],e[4]]=[e[4],e[2]]),e[0]>e[1]&&([e[0],e[1]]=[e[1],e[0]]),e[3]>e[5]&&([e[3],e[5]]=[e[5],e[3]]),e[2]>e[6]&&([e[2],e[6]]=[e[6],e[2]]),e[2]>e[3]&&([e[2],e[3]]=[e[3],e[2]]),e[3]>e[6]&&([e[3],e[6]]=[e[6],e[3]]),e[4]>e[5]&&([e[4],e[5]]=[e[5],e[4]]),e[1]>e[4]&&([e[1],e[4]]=[e[4],e[1]]),e[1]>e[3]&&([e[1],e[3]]=[e[3],e[1]]),e[3]>e[4]&&([e[3],e[4]]=[e[4],e[3]]),e[3];default:return e.sort((e,t)=>e-t),(e[e.length-1>>1]+e[e.length>>1])/2}}}class X{constructor(e,t,i){t>=i&&n.a.fatal(`Invalid boundaries [${t},${i}] given to the Tuner`),e=Math.max(t,Math.min(e,i)),this._state=e,this._prevState=e,this._prevPrevState=e,this._initialState=e,this._minState=t,this._maxState=i,this._bucket=new Array(i-t+1).fill(null).map(e=>new U(this._bucketSetup().size,this._bucketSetup().window)),this._iterations=0,this._epoch=0}currentValue(){return this._state}feedObservation(e){const t=this._bucketOf(this._state);if(t.put(+e),++this._iterations>=t.size){0==this._epoch&&(this._bucket.forEach(e=>e.fill(t.average)),isFinite(this._costOfBestState)||(this._costOfBestState=t.average));const e=e=>Math.max(this._minState,Math.min(0|e,this._maxState)),i=this._prevState,n=this._state;this._state=e(this._nextState()),this._prevState=n,this._prevPrevState=i,this._iterations=0,this._epoch++}}reset(){this._state=this._initialState,this._prevState=this._initialState,this._prevPrevState=this._initialState,this._iterations=0,this._epoch=0}finished(){return!1}_bucketOf(e){return e=Math.max(this._minState,Math.min(0|e,this._maxState)),this._bucket[e-this._minState]}_bucketSetup(){return{size:32,window:5}}_nextState(){return this._state}info(){const e=this._bucketOf(this._state),t=this._bucketOf(this._prevState);return{now:this._state,avg:e.average,itr:[this._iterations,this._epoch],bkt:e._smoothedData,cur:new Array(e.size).fill(0).map((t,i)=>i==e._head?1:0),prv:[this._prevState,t.average],fim:this.finished()}}}class K extends X{constructor(e,t,i,n=.5,a=8,r=100,s=null){super(e,t,i),this._bestState=this._initialState,this._costOfBestState=1/0,this._initialTemperature=Math.max(0,r),this._temperature=this._initialTemperature,this._numIterations=0,this._maxIterationsPerTemperature=Math.max(1,a),this._alpha=Math.max(0,Math.min(n,1)),s||(s=e=>this._minState+Math.floor(Math.random()*(this._maxState-this._minState+1))),this._pickNeighbor=s}reset(){this._temperature=this._initialTemperature,this._numIterations=0}finished(){return this._temperature<=1e-5}_nextState(){if(this.finished())return this._bestState;const e=e=>this._bucketOf(e).average;let t=this._state,i=0|this._pickNeighbor(this._state,e(this._state));return i=Math.max(this._minState,Math.min(i,this._maxState)),(e(i)<e(this._state)||Math.random()<Math.exp((e(this._state)-e(i))/this._temperature))&&(t=i),e(t)<this._costOfBestState&&(this._bestState=t,this._costOfBestState=e(t)),++this._numIterations>=this._maxIterationsPerTemperature&&(this._temperature*=this._alpha,this._numIterations=0),t}_bucketSetup(){return{size:4,window:3}}info(){return{best:[this._bestState,this._costOfBestState],state:[this._state,this._bucketOf(this._state).average],iterations:[this._numIterations,this._maxIterationsPerTemperature],temperature:this._temperature,alpha:this._alpha,cool:this.finished()}}}class G extends X{constructor(e,t,i=.1,a=.05){super(Math.round(n.a.gaussianNoise((e+t)/2,5)),e,t),this._tolerance=Math.max(0,i),this._bestState=this._initialState,this._expected=null,this._learningRate=Math.max(0,a),this._lastObservation=0}reset(){super.reset(),this._expected=null}feedObservation(e,t){const i=+e,n=+t;n!==this._expected&&this.reset(),this._expected=n;const a=Math.abs(i)>2*Math.abs(this._lastObservation);if(this._lastObservation=i,a)return;const r=(i-n)*(i-n)/(n*n);super.feedObservation(r)}finished(){return(e=>Math.sqrt(this._bucketOf(e).average)*Math.abs(this._expected))(this._bestState)<=this._tolerance*this._expected}get tolerance(){return this._tolerance}set tolerance(e){this._tolerance=Math.max(0,e)}_nextState(){if(this.finished())return this._bestState;const e=e=>Math.sqrt(this._bucketOf(e).average)*Math.abs(this._expected);e(this._state)<e(this._bestState)&&(this._bestState=this._state);const t=Math.abs(this._maxState),i=this._learningRate*(e=>Math.sqrt(this._bucketOf(e).average)*t)(this._state),a=e=>Number(e>=0)-Number(e<0),r=e(this._state)-e(this._prevState),s=a(r)*a(0!=r?-(this._state-this._prevState):1)*a(Math.random()-.15),o=n.a.gaussianNoise(1,.1);let c=Math.round(this._state+s*o*i);return(c>this._maxState||c<this._minState)&&(c=this._bestState),c}_bucketSetup(){return{size:4,window:3}}info(){return{now:[this._state,this._prevState],bkt:this._bucketOf(this._state)._rawData,cur:this._bucketOf(this._state)._head,err:[this._bucketOf(this._state).average,this._bucketOf(this._prevState).average],sqt:Math.sqrt(this._bucketOf(this._state).average),done:this.finished()}}}const $=2*Math.PI,Y=Math.PI,H=Object(f.b)("encoders/encode-keypoint-offsets.glsl").withArguments("image","imageSize","maxIterations"),W=Object(f.b)("encoders/encode-keypoints.glsl").withArguments("image","imageSize","encoderLength","descriptorSize");class V extends p{constructor(e,t,i){super(e,t,i),this.declare("_encodeKeypointOffsets",H).declare("_encodeKeypoints",W,{output:[128,128],renderToTexture:!1});this._tuner=new K(48,32,48,.2,8,60,e=>Math.round(n.a.gaussianNoise(e,64))%256),this._keypointEncoderLength=128,this._descriptorSize=0,this._spawnedAt=performance.now()}optimizeKeypointEncoder(e){const t=Math.max(0,Math.min(Math.ceil(e),5e3)),i=Math.ceil(2+this._descriptorSize/4),n=Math.ceil(Math.sqrt((4+1.05*t)*i)),a=Math.max(1,Math.min(n,300)),r=this._keypointEncoderLength;return a!=r&&(this._keypointEncoderLength=a,this._encodeKeypoints.resize(a,a)),a-r}async encodeKeypoints(e,t=!0){const i=this._keypointEncoderLength,a=this._descriptorSize,r=[this._width,this._height],s=this._tuner.currentValue();try{let n=performance.now();const o=this._encodeKeypointOffsets(e,r,s);let c,l;if(this._encodeKeypoints(o,r,i,a),n=performance.now()-n,t?(l=performance.now(),c=await this._encodeKeypoints.readPixelsAsync(0,0,-1,-1),l=performance.now()-l):(l=performance.now(),c=this._encodeKeypoints.readPixelsSync(),l=performance.now()-l),performance.now()>=this._spawnedAt+2e3){const e=n+l;this._tuner.feedObservation(e)}return c}catch(e){n.a.fatal(e)}}decodeKeypoints(e,t=!0){const[i,n]=[this._width,this._height],a=2+this._descriptorSize/4,r=Math.log2(this._gpu.pyramidMaxScale),s=this._gpu.pyramidHeight,o=[];let c,l,p,f,h;for(let m=0;m<e.length&&(c=e[m+1]<<8|e[m],l=e[m+3]<<8|e[m+2],!(c>=i||l>=n));m+=4*a)p=255==e[m+4]?1:Math.pow(2,-r+(r+s)*e[m+4]/255),f=t?(e[m+5]*$-Y)/255:0,h=e[m+6]/255,o.push(new q(c,l,p,f,h));return 0==o.length&&this._tuner.finished()&&this._tuner.reset(),o}}var J=i(4);const Q=Object(f.b)("pyramids/upsample2.glsl").withArguments("image"),Z=Object(f.b)("pyramids/downsample2.glsl").withArguments("image"),ee=Object(f.b)("pyramids/upsample3.glsl").withArguments("image"),te=Object(f.b)("pyramids/downsample3.glsl").withArguments("image"),ie=Object(f.b)("pyramids/merge-keypoints.glsl").withArguments("target","source"),ne=Object(f.b)("pyramids/merge-keypoints-at-consecutive-levels.glsl").withArguments("largerImage","smallerImage"),ae=Object(f.b)("pyramids/normalize-keypoints.glsl").withArguments("image","imageScale"),re=Object(f.b)("pyramids/crop.glsl").withArguments("image"),se=Object(f.b)("utils/flip-y.glsl").withArguments("image");class oe extends p{constructor(e,t,i){super(e,t,i),this.declare("setBase",function(e){const t=Math.log2(J.c),i=Math.pow(2,-J.b)+1e-5,n=Math.max(i,Math.min(e,J.c)),a=`\n    uniform sampler2D image;\n\n    void main()\n    {\n        color = vec4(threadPixel(image).rgb, float(${(t-Math.log2(n))/(t+J.b)}));\n    }\n    `;return Object(f.a)(a).withArguments("image")}(1)).compose("reduce","_smoothX","_smoothY","_downsample2","_scale1/2").compose("expand","_upsample2","_smoothX2","_smoothY2","_scale2").compose("intraReduce","_upsample2","_smoothX2","_smoothY2","_downsample3/2","_scale2/3").compose("intraExpand","_upsample3","_smoothX3","_smoothY3","_downsample2/3","_scale3/2").declare("mergeKeypoints",ie).declare("mergeKeypointsAtConsecutiveLevels",ne).declare("normalizeKeypoints",ae).declare("crop",re).declare("output",se,{...this.program.hasTextureSize(this._width,this._height),...this.program.displaysGraphics()}).declare("output2",se,{...this.program.hasTextureSize(2*this._width,2*this._height),...this.program.displaysGraphics()}).declare("output3",se,{...this.program.hasTextureSize(3*this._width,3*this._height),...this.program.displaysGraphics()}).declare("_smoothX",Object(O.convX)([.05,.25,.4,.25,.05])).declare("_smoothY",Object(O.convY)([.05,.25,.4,.25,.05])).declare("_smoothX2",Object(O.convX)([.1,.5,.8,.5,.1]),this.program.hasTextureSize(2*this._width,2*this._height)).declare("_smoothY2",Object(O.convY)([.1,.5,.8,.5,.1],.5),this.program.hasTextureSize(2*this._width,2*this._height)).declare("_smoothX3",Object(O.convX)([.2,.8,1,.8,.2]),this.program.hasTextureSize(3*this._width,3*this._height)).declare("_smoothY3",Object(O.convY)([.2,.8,1,.8,.2],1/3),this.program.hasTextureSize(3*this._width,3*this._height)).declare("_upsample2",Q,this.program.hasTextureSize(2*this._width,2*this._height)).declare("_downsample2",Z,this.program.hasTextureSize((1+this._width)/2,(1+this._height)/2)).declare("_upsample3",ee,this.program.hasTextureSize(3*this._width,3*this._height)).declare("_downsample3",te,this.program.hasTextureSize((2+this._width)/3,(2+this._height)/3)).declare("_downsample2/3",Z,this.program.hasTextureSize(3*this._width/2,3*this._height/2)).declare("_downsample3/2",te,this.program.hasTextureSize(2*this._width/3,2*this._height/3)).declare("_scale2",ce(2),this.program.hasTextureSize(2*this._width,2*this._height)).declare("_scale1/2",ce(.5),this.program.hasTextureSize((1+this._width)/2,(1+this._height)/2)).declare("_scale3/2",ce(1.5),this.program.hasTextureSize(3*this._width/2,3*this._height/2)).declare("_scale2/3",ce(2/3),this.program.hasTextureSize(2*this._width/3,2*this._height/3))}}function ce(e){const t=Math.log2(J.c),i=Math.max(1e-5,e),n=`\n    uniform sampler2D image;\n\n    void main()\n    {\n        vec4 pixel = threadPixel(image);\n        float alpha = clamp(pixel.a + float(${-Math.log2(i)/(t+J.b)}), 0.0f, 1.0f);\n\n        color = vec4(pixel.rgb, alpha);\n    }\n    `;return Object(f.a)(n).withArguments("image")}class le{constructor(e,t,i){this._gpu=e,this._width=t,this._height=i,this._utils=null,this._colors=null,this._filters=null,this._keypoints=null,this._encoders=null,this._pyramids=null}get width(){return this._width}get height(){return this._height}get utils(){return this._utils||(this._utils=new v(this._gpu,this._width,this._height))}get colors(){return this._colors||(this._colors=new y(this._gpu,this._width,this._height))}get filters(){return this._filters||(this._filters=new A(this._gpu,this._width,this._height))}get keypoints(){return this._keypoints||(this._keypoints=new B(this._gpu,this._width,this._height))}get encoders(){return this._encoders||(this._encoders=new V(this._gpu,this._width,this._height))}get pyramids(){return this._pyramids||(this._pyramids=new oe(this._gpu,this._width,this._height))}}class pe{constructor(e,t){this._gl=null,this._canvas=null,this._width=0,this._height=0,this._programs=null,this._pyramid=null,this._intraPyramid=null,this._inputTexture=null,this._inputTextureIndex=0,this._omitGLContextWarning=!1,"undefined"==typeof WebGL2RenderingContext&&n.a.fatal("WebGL2 is required by this application, but it's not available in your browser. Please use a different browser."),this._width=Math.max(1,0|e),this._height=Math.max(1,0|t),(this._width>J.a||this._height>J.a)&&(n.a.warning(`Maximum texture size exceeded (using ${this._width} x ${this._height}).`),this._width=Math.min(this._width,J.a),this._height=Math.min(this._height,J.a)),this._setupWebGL()}get gl(){return this._gl}get canvas(){return this._canvas}get programs(){return this._programs}pyramid(e){const t=0|e;return(t<0||t>=J.b)&&n.a.fatal("Invalid pyramid level: "+t),this._pyramid[t]}intraPyramid(e){const t=0|e;return(t<0||t>=J.b+1)&&n.a.fatal("Invalid intra-pyramid level: "+t),this._intraPyramid[t]}get pyramidHeight(){return J.b}get pyramidMaxScale(){return J.c}upload(e,t=-1,i=-1){const a=this._gl;if(a.isContextLost())return n.a.warning("Can't upload texture without a WebGL context"),this._inputTexture=null;if(t<0&&(t=a.canvas.width),i<0&&(i=a.canvas.height),0!=t&&0!=i||n.a.fatal("Can't upload an image of area 0"),null===this._inputTexture)a.canvas.width=Math.max(a.canvas.width,t),a.canvas.height=Math.max(a.canvas.height,i),this._inputTexture=Array(2).fill(null).map(e=>r.createTexture(a,a.canvas.width,a.canvas.height));else if(t>a.canvas.width||i>a.canvas.height)return n.a.warning(`Resizing input texture to ${t} x ${i}`),this._inputTexture.forEach(e=>r.destroyTexture(a,e)),this.upload(e,t,i);return this._inputTextureIndex=1-this._inputTextureIndex,r.uploadToTexture(a,this._inputTexture[this._inputTextureIndex],t,i,e),this._inputTexture[this._inputTextureIndex]}loseAndRestoreWebGLContext(e=1){const t=this._gl;if(t.isContextLost())return Promise.reject("Context already lost");const i=t.getExtension("WEBGL_lose_context");if(i)return i.loseContext(),new Promise(t=>{isFinite(e)?setTimeout(()=>{i.restoreContext(),setTimeout(()=>t(),0)},1e3*Math.max(e,0)):t()});n.a.fatal("WEBGL_lose_context is unavailable")}loseWebGLContext(){return this._omitGLContextWarning=!0,this.loseAndRestoreWebGLContext(1/0)}_setupWebGL(){const e=this._width,t=this._height;this._programs=null,this._pyramid=null,this._intraPyramid=null,this._inputTexture=null,this._inputTextureIndex=0,this._omitGLContextWarning=!1,void 0!==this._canvas&&delete this._canvas,this._canvas=function(e,t){if("function"==typeof importScripts&&"undefined"!=typeof WorkerGlobalScope)return"function"!=typeof OffscreenCanvas&&n.a.fatal("OffscreenCanvas is not available in your browser. Please upgrade."),new OffscreenCanvas(e,t);{const i=document.createElement("canvas");return i.width=e,i.height=t,i}}(e,t),this._canvas.addEventListener("webglcontextlost",e=>{this._omitGLContextWarning||n.a.warning("Lost WebGL context"),e.preventDefault()},!1),this._canvas.addEventListener("webglcontextrestored",e=>{this._omitGLContextWarning||n.a.warning("Restoring WebGL context..."),this._setupWebGL()},!1),this._gl=function(e){const t=e.getContext("webgl2",{premultipliedAlpha:!1,preserveDrawingBuffer:!1,alpha:!0,antialias:!1,depth:!1,stencil:!1});t||n.a.fatal("Can't create WebGL2 context. Try in a different browser.");return t}(this._canvas),this._programs=new le(this,e,t),this._pyramid=this._buildPyramid(e,t,1,J.b),this._intraPyramid=this._buildPyramid(e,t,1.5,J.b+1)}_buildPyramid(e,t,i,n){let a=+i,r=e*a|0,s=t*a|0,o=new Array(n);for(let e=0;e<o.length;e++)o[e]=new le(this,r,s),r=(1+r)/2|0,s=(1+s)/2|0,a/=2;return o}}class fe{static run(e,t,i,a){n.a.assert(9==i||7==i||5==i,"Not implemented: FAST-"+i),a.hasOwnProperty("threshold")||(a.threshold=10),a.hasOwnProperty("sensitivity")?a.threshold=this._sensitivity2threshold(a.sensitivity):a.threshold=this._normalizedThreshold(a.threshold);const r=(this.run._vtable||(this.run._vtable={5:e=>e.programs.keypoints.fast5,7:e=>e.programs.keypoints.fast7,9:e=>e.programs.keypoints.fast9}))[i](e)(t,a.threshold);return e.programs.keypoints.nonmaxSuppression(r)}static _sensitivity2threshold(e){return e=Math.max(0,Math.min(e,1)),1-Math.tanh(2.77*e)}static _normalizedThreshold(e){return(e=Math.max(0,Math.min(e,255)))/255}}class he extends fe{static run(e,t,i,a){n.a.assert(9==i,`Not implemented: FAST-${i}-plus`),a.hasOwnProperty("threshold")||(a.threshold=10),a.hasOwnProperty("depth")||(a.depth=3),a.hasOwnProperty("sensitivity")?a.threshold=this._sensitivity2threshold(a.sensitivity):a.threshold=this._normalizedThreshold(a.threshold);const s=e.pyramidHeight,o=Math.max(1,Math.min(+a.depth,s))-1,c=e.programs.keypoints.fast9pyr,l=t;r.generateMipmap(e.gl,l);const p=c(l,a.threshold,0,o,!0),f=e.programs.keypoints.samescaleSuppression(p),h=e.programs.keypoints.multiscaleSuppression(f,!0);return e.programs.keypoints.multiscaleOrientationViaCentroid(h,3,l)}}let me=null,ue=null;function de(e){const{n:t,r:i,l:n}=e,a=2*Math.PI;return[...Array(t).keys()].map(e=>({x:n*Math.cos(a*e/t),y:n*Math.sin(a*e/t),r:i,l:n,j:e,n:t}))}function ge(e,t=1){const i=function(e=1){const t=Math.PI/2,i=Math.sin(t/10),n=Math.sin(t/14),a=Math.sin(t/15),r=Math.sin(t/20),s=4.21*e,o=2*s*i,c=2*(s+o)*n/(1-2*n),l=s+o+c,p=2*(l+c)*a/(1-2*a),f=l+c+p,h=2*(f+p)*r/(1-2*r);return[{n:1,r:.8*o,l:0},{n:10,r:o,l:s},{n:14,r:c,l:l},{n:15,r:p,l:f},{n:20,r:h,l:f+p+h}]}(t).map(de).reduce((e,t)=>e.concat(t),[]);const n=i.length,a=+e*t,r=(e,t)=>(e.x-t.x)*(e.x-t.x)+(e.y-t.y)*(e.y-t.y),s=a<0?(e,t)=>r(e,t)<a*a:(e,t)=>r(e,t)>a*a,o=[];for(let e=1;e<n;e++)for(let t=0;t<e;t++)s(i[e],i[t])&&(o.push(i[e].x),o.push(i[e].y),o.push(i[t].x),o.push(i[t].y));return new Float32Array(o)}const xe=J.b;const _e=(e,t)=>+t.score-+e.score;class ve{constructor(e,t){this._gpu=e,this._lastKeypointCount=0,this._lastKeypointEncoderOutput=0,this._sensitivityTuner=null,this._optimizeForDynamicUsage=t}fast(e,t=9,i={}){const n=this._gpu;(i={denoise:!0,max:-1,...i}).hasOwnProperty("expected")&&(i.sensitivity=this._findSensitivity(i.expected));const a=e._gpu.upload(e.source),r=i.denoise?n.programs.filters.gauss5(a):a,s=n.programs.colors.rgb2grey(r),o=fe.run(n,s,t,i);return this._extractKeypoints(o,this._optimizeForDynamicUsage,i.max)}fastPlus(e,t=9,i={}){const n=this._gpu;(i={denoise:!0,max:-1,...i}).hasOwnProperty("expected")&&(i.sensitivity=this._findSensitivity(i.expected));const a=e._gpu.upload(e.source),r=i.denoise?n.programs.filters.gauss5(a):a,s=n.programs.colors.rgb2grey(r),o=he.run(n,s,t,i);return this._extractKeypoints(o,this._optimizeForDynamicUsage,i.max)}harris(e,t={}){const i=this._gpu;(t={denoise:!0,max:-1,...t}).hasOwnProperty("expected")&&(t.sensitivity=this._findSensitivity(t.expected));const n=e._gpu.upload(e.source),a=t.denoise?i.programs.filters.gauss5(n):n,r=i.programs.colors.rgb2grey(a),s=class{static run(e,t,i){i.hasOwnProperty("windowSize")||(i.windowSize=3),i.hasOwnProperty("sensitivity")&&(i.quality=this._sensitivity2quality(i.sensitivity)),i.hasOwnProperty("quality")?i.quality=Math.max(0,Math.min(i.quality,1)):i.quality=.1;const n=Math.max(0,Math.min((0|i.windowSize)>>1,3)),a=e.programs.keypoints.multiscaleSobel(t,0),r=Array(7).fill(a),s=t,o=e.programs.keypoints.multiscaleHarris(s,n,0,0,!0,r),c=e.programs.utils.scanMax(o,h.c.RED),l=e.programs.keypoints.harrisCutoff(o,c,i.quality);return e.programs.utils.release(a),e.programs.keypoints.nonmaxSuppression(l)}static _sensitivity2quality(e){return e=Math.max(0,Math.min(e,1)),1-Math.tanh(2.3*e)}}.run(i,r,t);return this._extractKeypoints(s,this._optimizeForDynamicUsage,t.max)}multiscaleHarris(e,t={}){const i=this._gpu;(t={denoise:!0,max:-1,...t}).hasOwnProperty("expected")&&(t.sensitivity=this._findSensitivity(t.expected));const a=e._gpu.upload(e.source),s=t.denoise?i.programs.filters.gauss5(a):a,o=i.programs.colors.rgb2grey(s),c=class{static run(e,t,i){i.hasOwnProperty("windowSize")||(i.windowSize=3),i.hasOwnProperty("depth")||(i.depth=3),i.hasOwnProperty("sensitivity")&&(i.quality=this._sensitivity2quality(i.sensitivity)),i.hasOwnProperty("quality")||(i.quality=.1);const a=Math.max(1,Math.min(+i.depth,xe))-1,s=Math.max(0,Math.min((0|i.windowSize)>>1,3)),o=t;r.generateMipmap(e.gl,o);const c=e.programs.keypoints.multiscaleSobel(o,0),l=Array(7).fill(c);for(let t=.5;t<=a;t+=.5)l[2*t|0]=e.programs.keypoints.multiscaleSobel(o,t);n.a.assert(l.length==2*e.pyramidHeight-1,"Incorrect sobelDerivatives.length");const p=e.programs.keypoints.multiscaleHarris(o,s,0,a,!0,l);for(let t=0;t<l.length;t++)l[t]=e.programs.utils.release(l[t]);const f=e.programs.utils.scanMax(p,h.c.RED),m=e.programs.keypoints.harrisCutoff(p,f,i.quality),u=e.programs.keypoints.samescaleSuppression(m),d=e.programs.keypoints.multiscaleSuppression(u,!0);return e.programs.keypoints.multiscaleOrientationViaCentroid(d,3,o)}static _sensitivity2quality(e){return e=Math.max(0,Math.min(e,1)),1-Math.tanh(2.3*e)}}.run(i,o,t);return this._extractKeypoints(c,this._optimizeForDynamicUsage,t.max)}brisk(e,t={}){const i=this._gpu;(t={threshold:10,denoise:!0,max:-1,depth:4,...t}).hasOwnProperty("expected")&&(t.sensitivity=this._findSensitivity(t.expected)),t.hasOwnProperty("sensitivity")?t.threshold=fe._sensitivity2threshold(t.sensitivity):t.threshold=fe._normalizedThreshold(t.threshold);const n=e._gpu.upload(e.source),a=t.denoise?i.programs.filters.gauss5(n):n,r=i.programs.colors.rgb2grey(a),s=class{static run(e,t,i){const n=e.pyramidHeight;i.depth=0|Math.max(1,Math.min(i.depth,n));const a=new Array(i.depth),r=new Array(a.length+1);a[0]=e.pyramid(0).pyramids.setBase(t);for(let t=1;t<a.length;t++)a[t]=e.pyramid(t-1).pyramids.reduce(a[t-1]);r[0]=e.pyramid(0).pyramids.intraExpand(a[0]);for(let t=1;t<r.length;t++)r[t]=e.intraPyramid(t-1).pyramids.reduce(r[t-1]);const s=new Array(a.length),o=new Array(r.length);for(let t=0;t<s.length;t++)s[t]=e.pyramid(t).keypoints.fast9(a[t],i.threshold);for(let t=0;t<o.length;t++)o[t]=e.intraPyramid(t).keypoints.fast9(r[t],i.threshold);const c=Math.log2(e.pyramidMaxScale),l=e.pyramidHeight,p=new Array(s.length),f=new Array(o.length);f[0]=e.intraPyramid(0).keypoints.brisk(o[0],o[0],s[0],1,2/3,c,l);for(let t=0;t<p.length;t++)p[t]=e.pyramid(t).keypoints.brisk(s[t],o[t],o[t+1],1.5,.75,c,l),t+1<p.length?f[t+1]=e.intraPyramid(t+1).keypoints.brisk(o[t+1],s[t],s[t+1],4/3,2/3,c,l):f[t+1]=e.intraPyramid(t+1).keypoints.brisk(o[t+1],s[t],o[t+1],4/3,1,c,l);for(let t=p.length-2;t>=0;t--)p[t]=e.pyramid(t).pyramids.mergeKeypointsAtConsecutiveLevels(p[t],p[t+1]);for(let t=f.length-2;t>=0;t--)f[t]=e.intraPyramid(t).pyramids.mergeKeypointsAtConsecutiveLevels(f[t],f[t+1]);return f[0]=e.intraPyramid(0).pyramids.normalizeKeypoints(f[0],1.5),f[0]=e.pyramid(0).pyramids.crop(f[0]),e.pyramid(0).pyramids.mergeKeypoints(p[0],f[0])}static get shortDistancePairs(){return me||(me=function(e=9.75,t=1){return ge(-e,t)}())}static get longDistancePairs(){return ue||(ue=function(e=13.67,t=1){return ge(e,t)}())}}.run(i,r,t);return this._extractKeypoints(s,this._optimizeForDynamicUsage,t.max)}_extractKeypoints(e,t=!0,i=-1,n=this._gpu){return n.programs.encoders.encodeKeypoints(e,t).then(e=>{const a=n.programs.encoders.decodeKeypoints(e),r=Math.max(a.length,64),s=Math.max(this._lastKeypointCount,64),o=Math.ceil(.02*r+.98*s);return this._lastKeypointCount=o,this._lastKeypointEncoderOutput=a.length,t&&n.programs.encoders.optimizeKeypointEncoder(o),a.sort(_e),Number.isFinite(i)&&i>=0&&a.splice(i,a.length-i),t&&o<a.length&&a.splice(o,a.length-o),a}).catch(e=>{throw e})}_findSensitivity(e){const t={number:0,tolerance:.1,..."object"==typeof e?e:{number:0|e}};this._optimizeForDynamicUsage||this._findSensitivity._warning||(n.a.warning("Finding an expected number of features in a media configured for static usage"),this._findSensitivity._warning=!0),this._sensitivityTuner=this._sensitivityTuner||new G(0,1200);this._sensitivityTuner.tolerance=Math.max(t.tolerance,0),this._sensitivityTuner.feedObservation(this._lastKeypointEncoderOutput,Math.max(t.number,0));const i=.001*this._sensitivityTuner.currentValue();return Math.max(0,Math.min(i,1))}}var be=i(5);class ye{constructor(e,t,i,a={}){if(arguments.length>1)this._source=e,this._width=0|t,this._height=0|i,this._type=function(e){if(e&&e.constructor)switch(e.constructor.name){case"HTMLImageElement":return h.b.Image;case"HTMLVideoElement":return h.b.Video;case"HTMLCanvasElement":return h.b.Canvas;default:return h.b.Texture}return n.a.fatal("Can't get media type: invalid media source. "+e),null}(this._source),this._colorFormat=h.a.RGB,this._options=Ae(a,{usage:this._type!=h.b.Image?"dynamic":"static"}),this._gpu=new pe(this._width,this._height),this._featureDetector=null;else if(1==arguments.length){const e=arguments[0];this._source=e._source,this._width=e._width,this._height=e._height,this._type=e._type,this._colorFormat=e._colorFormat,this._gpu=e._gpu,this._featureDetector=e._featureDetector}else n.a.fatal("Invalid instantiation of SpeedyMedia")}static load(e,t={}){return new Promise((i,a)=>{const r=Oe(e);null!=r?function r(s,o=500){if(s.width>0&&s.height>0){const a=new ye(e,s.width,s.height,t);n.a.log(`Loaded SpeedyMedia with a ${e}.`),i(a)}else o>0?setTimeout(()=>r(Oe(e),o-1),10):a(new be.a(`Can't load SpeedyMedia with a ${e}: timeout.`))}(r):a(new be.a(`Can't load SpeedyMedia with a ${e}: invalid media source.`))})}static loadCameraStream(e=426,t=240,i={},a={}){return function(e,t,i={}){return new Promise((a,r)=>{if(n.a.log("Accessing the webcam..."),!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia)return r(new be.a("Unsupported browser: no mediaDevices.getUserMedia()"));navigator.mediaDevices.getUserMedia({audio:!1,video:{width:{ideal:e},height:{ideal:t},aspectRatio:{ideal:e/t},facingMode:"environment"},...i}).then(e=>{const t=document.createElement("video");t.srcObject=e,t.onloadedmetadata=i=>{t.play(),n.a.log("The camera device is turned on!"),a(t,e)}}).catch(e=>{r(new be.a(`Please give access to the camera and reload the page.\n${e.name}. ${e.message}.`))})})}(e,t,i).then(e=>ye.load(function(e){const t=document.createElement("canvas"),i=t.getContext("2d");function n(){i.drawImage(e,0,0),requestAnimationFrame(n)}return t.width=e.videoWidth,t.height=e.videoHeight,n(),t}(e),a))}get source(){return this._source}get width(){return this._width}get height(){return this._height}get type(){switch(this._type){case h.b.Image:return"image";case h.b.Video:return"video";case h.b.Canvas:return"canvas";case h.b.Texture:return"internal";default:return"unknown"}}get options(){return this._options}release(){return this.isReleased()||(this._featureDetector=null,this._gpu.loseWebGLContext(),this._gpu=null,this._source=null),Promise.resolve()}isReleased(){return null==this._gpu}clone(e={}){if(e={lightweight:!1,...e},this.isReleased()&&n.a.fatal("Can't clone a SpeedyMedia that has been released"),e.lightweight)return new ye(this);{let e=this._source;return this._type!=h.b.Texture&&this._type!=h.b.Canvas||(e=function(e){const t=document.createElement("canvas");return t.width=e.width,t.height=e.height,e.draw(t),t}(this)),new ye(e,this._width,this._height)}}run(e){this.isReleased()&&n.a.fatal("Can't run pipeline: SpeedyMedia has been released");const t=this.clone({lightweight:!0});return t._type=h.b.Texture,e._run(t)}draw(e,t=0,i=0,n=this.width,a=this.height){if(this.isReleased())return;const r=e.getContext("2d");switch(t=+t,i=+i,n=Math.max(n,0),a=Math.max(a,0),this._type){case h.b.Image:case h.b.Video:case h.b.Canvas:r.drawImage(this._source,t,i,n,a);break;case h.b.Texture:r.drawImage(this._gpu.canvas,t,i,n,a)}}findFeatures(e={}){e=Object.assign({method:"fast"},e),this.isReleased()&&n.a.fatal("Can't find features: SpeedyMedia has been released"),this._featureDetector=this._featureDetector||new ve(this._gpu,"dynamic"==this.options.usage);const t=this._featureDetector._table||(this._featureDetector._table={fast:(e,t)=>this._featureDetector.fast(e,9,t),fast9:(e,t)=>this._featureDetector.fast(e,9,t),fast7:(e,t)=>this._featureDetector.fast(e,7,t),fast5:(e,t)=>this._featureDetector.fast(e,5,t),"multiscale-fast":(e,t)=>this._featureDetector.fastPlus(e,9,t),brisk:(e,t)=>this._featureDetector.brisk(e,t),harris:(e,t)=>this._featureDetector.harris(e,t),"multiscale-harris":(e,t)=>this._featureDetector.multiscaleHarris(e,t)}),i=String(e.method).toLowerCase();return t.hasOwnProperty(i)||n.a.fatal(`Invalid method "${i}" for keypoint detection.`),t[i](this,e)}}function Oe(e){if(e&&e.constructor&&e.constructor.name){const t=e.constructor.name,i={HTMLImageElement:{width:"naturalWidth",height:"naturalHeight"},HTMLVideoElement:{width:"videoWidth",height:"videoHeight"},HTMLCanvasElement:{width:"width",height:"height"}};if(i.hasOwnProperty(t))return{width:e[i[t].width],height:e[i[t].height]}}return null}function Ae(e,t){const i=Ae._err||(Ae._err=(...e)=>n.a.warning("Invalid option when loading media.",...e));return"dynamic"!=(e=Object.assign(t,e)).usage&&"static"!=e.usage&&(i(`Unrecognized usage: "${e.usage}"`),e.usage=t.usage),Object.freeze(e)}const Ee={};class Pe{run(e,t,i){return e}release(){}}Ee.ConvertToGreyscale=class extends Pe{run(e,t,i){return i._colorFormat==h.a.RGB?e=t.programs.colors.rgb2grey(e):i._colorFormat!=h.a.Greyscale&&n.a.fatal("Can't convert image to greyscale: unknown color format"),i._colorFormat=h.a.Greyscale,e}},Ee.Blur=class extends Pe{constructor(e={}){const{filter:t,size:i}=e={filter:"gaussian",size:5,...e};super(),3!=i&&5!=i&&7!=i&&n.a.fatal("Invalid kernel size: "+i),"gaussian"==t?this._filter="gauss"+i:"box"==t?this._filter="box"+i:n.a.fatal(`Invalid filter: "${t}"`)}run(e,t,i){return t.programs.filters[this._filter](e)}},Ee.Convolve=class extends Pe{constructor(e,t=1){let i=new Float32Array(e).map(e=>e/t);const a=i.length,r=0|Math.sqrt(a),s={3:["createKernel3x3","texConv2D3"],5:["createKernel5x5","texConv2D5"],7:["createKernel7x7","texConv2D7"]}[r]||null;super(),1==a?n.a.fatal("Cannot convolve with a kernel containing a single element"):r*r==a&&s||n.a.fatal(`Cannot convolve with a non-square kernel of ${a} elements`);const o=Math.min(...i),c=Math.max(...i),l=o,p=Math.abs(c-o)>1e-5?c-o:1;i=i.map(e=>(e-l)/p),this._method=s,this._scale=p,this._offset=l,this._kernel=i,this._kernelSize=r,this._texKernel=null,this._gl=null}run(e,t,i){if(t.gl.isContextLost())this._texKernel=null,this._gl=null;else if(null==this._texKernel||this._gl!==t.gl&&null!==this._gl){if(this._gl!==t.gl&&null!==this._gl&&!this._gl.isContextLost()){const e="Performance warning: need to recreate the texture kernel. Consider duplicating the pipeline when using convolutions for different media objects.";n.a.warning(e),r.destroyTexture(this._gl,this._texKernel)}this._texKernel=t.programs.filters[this._method[0]](this._kernel),this._gl=t.gl}return t.programs.filters[this._method[1]](e,this._texKernel,this._scale,this._offset)}release(){null!=this._texKernel&&(r.destroyTexture(this._gl,this._texKernel),this._texKernel=this._gl=null),super.release()}};class Me{constructor(){this._operations=[]}get length(){return this._operations.length}release(){return new Promise((e,t)=>{for(let e=this._operations.length-1;e>=0;e--)this._operations[e].release();this._operations.length=0,e(this)})}_spawn(e){return this._operations.push(e),this}_run(e){return new Promise((t,i)=>{if(e._type==h.b.Texture){let i=e._gpu.upload(e._source);for(let t=0;t<this._operations.length;t++)i=this._operations[t].run(i,e._gpu,e);e._gpu.programs.utils.output(i),e._source=e._gpu.canvas,t(e)}else i(new be.a("Can't run a pipeline on a media that is not a texture"))})}concat(e){return e instanceof Me?(this._operations=this._operations.concat(e._operations),this):(n.a.fatal(`Invalid argument "${e}" given to SpeedyPipeline.concatenate()`),this)}convertTo(e=null){return"greyscale"==e||"grayscale"==e?this._spawn(new Ee.ConvertToGreyscale):(n.a.fatal(`Can't convert to unknown color space: "${e}"`),this)}blur(e={}){return this._spawn(new Ee.Blur(e))}convolve(e,t=1){return this._spawn(new Ee.Convolve(e,t))}}let we=null;class Se{constructor(){this._fps=60,this._frames=0,this._updateInterval=500,this._lastUpdate=performance.now(),null!==we&&n.a.fatal("Can't have multiple instances of FPSCounter"),requestAnimationFrame(this._update.bind(this))}static get instance(){return null===we&&(we=new Se),we}get fps(){return this._fps}_update(){const e=performance.now(),t=e-this._lastUpdate;t>=this._updateInterval&&(this._fps=Math.round(this._frames/(.001*t)),this._frames=0,this._lastUpdate=e),this._frames++,requestAnimationFrame(this._update.bind(this))}}class ke{static load(e,t={}){return ye.load(e,t)}static camera(e=426,t=240,i={},n={}){return ye.loadCameraStream(e,t,i,n)}static pipeline(){return new Me}static get version(){return"0.3.2"}static get fps(){return{get value(){return Se.instance.fps}}}}const Te=ke.load,Le=ke.camera,Ce=ke.pipeline,De=ke.version,Re=ke.fps}]);