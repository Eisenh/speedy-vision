/*!
 * speedy-vision.js v0.5.1-wip
 * GPU-accelerated Computer Vision for JavaScript
 * https://github.com/alemart/speedy-vision-js
 * 
 * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com> (https://github.com/alemart)
 * @license Apache-2.0
 * 
 * Date: 2021-02-23T21:32:58.715Z
 */
var Speedy=function(e){var t={};function n(i){if(t[i])return t[i].exports;var r=t[i]={i:i,l:!1,exports:{}};return e[i].call(r.exports,r,r.exports,n),r.l=!0,r.exports}return n.m=e,n.c=t,n.d=function(e,t,i){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:i})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var i=Object.create(null);if(n.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var r in e)n.d(i,r,function(t){return e[t]}.bind(null,r));return i},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=20)}([function(e,t,n){"use strict";n.d(t,"i",(function(){return r})),n.d(t,"h",(function(){return s})),n.d(t,"e",(function(){return o})),n.d(t,"a",(function(){return a})),n.d(t,"f",(function(){return c})),n.d(t,"g",(function(){return l})),n.d(t,"d",(function(){return d})),n.d(t,"k",(function(){return f})),n.d(t,"j",(function(){return h})),n.d(t,"c",(function(){return p})),n.d(t,"b",(function(){return u}));class i extends Error{constructor(e,t=null){super([e,t?t.toString():"[speedy-vision.js]"].join("\n-> ")),this._cause=t}get name(){return this.constructor.name}set name(e){}get cause(){return this._cause}}class r extends i{constructor(e="",t=null){super("Unsupported operation. "+e,t)}}class s extends i{constructor(e="",t=null){super("Method not implemented. "+e,t)}}class o extends i{constructor(e="",t=null){super("WebGL error. "+e,t)}}class a extends i{constructor(e="",t=null){super("Can't call abstract method. "+e,t)}}class c extends i{constructor(e="",t=null){super("Illegal argument. "+e,t)}}class l extends i{constructor(e="",t=null){super("Illegal operation. "+e,t)}}class d extends i{constructor(e="",t=null){super("File not found. "+e,t)}}class f extends i{constructor(e="",t=null){super("Timeout error. "+e,t)}}class h extends i{constructor(e="",t=null){super("Parse error. "+e,t)}}class p extends i{constructor(e="",t=null){super("Assertion failed. "+e,t)}}class u extends i{constructor(e="",t=null){super("Access denied. "+e,t)}}},function(e,t,n){"use strict";n.d(t,"a",(function(){return s}));var i=n(0),r=n(5);class s{static warning(e,...t){const n=[e,...t].join(" ");return console.warn("[speedy-vision.js]",n),n}static log(e,...t){return[e,...t].join(" ")}static assert(e,t=""){if(!e)throw new i.c(t)}static enum(...e){return Object.freeze(e.reduce((e,t)=>(e[t]=Symbol(t),e),{}))}static setZeroTimeout(e){const t=s._setZeroTimeoutContext=s._setZeroTimeoutContext||(s._setZeroTimeoutContext={callbacks:new Map,_setup:window.addEventListener("message",e=>{if(e.source===window){const t=s._setZeroTimeoutContext,n=e.data,i=t.callbacks.get(n);void 0!==i&&(e.stopPropagation(),i.call(window),t.callbacks.delete(n))}},!0)}),n="0%"+Math.random();t.callbacks.set(n,e),window.postMessage(n,"*")}static functionArguments(e){const t=e.toString(),n=t.startsWith("function")?"function\\s.*\\(([^)]*)\\)":t.startsWith("(")?"\\(([^)]*)\\).*=>":"([^=]+).*=>",r=new RegExp(n).exec(t);if(null!==r){return r[1].replace(/\/\*.*?\*\//g,"").split(",").map(e=>e.replace(/=.*$/,"").trim()).filter(e=>e)}throw new i.j("Can't detect function arguments of "+t)}static getAllPropertyDescriptors(e){if(e){const t=Object.getPrototypeOf(e);return{...s.getAllPropertyDescriptors(t),...Object.getOwnPropertyDescriptors(e)}}return Object.create(null)}static createCanvas(e,t){const n=document.createElement("canvas");return n.width=e,n.height=t,n}static gaussianNoise(e=0,t=1){const n=2*Math.PI;let i,r=Math.random();do{i=Math.random()}while(i<=Number.EPSILON);return Math.sqrt(-2*Math.log(i))*Math.sin(n*r)*t+e}static gaussianKernel(e,t=-1,n=!0){if(t<0&&(t=0|Math.ceil(5*e),t+=1-t%2),(t|=0)<1||t%2==0)throw new i.f(`Invalid kernel size given to gaussianKernel: ${t} x 1`);if(e<=0)throw new i.f("Invalid sigma given to gaussianKernel: "+e);const r=new Array(t),s=t>>1,o=1.4142135623730951*+e,a=.3275911,c=.254829592,l=-.284496736,d=1.421413741,f=-1.453152027,h=1.061405429;let p=0;for(let e=0;e<t;e++){let t=(e-s+.5)/o,n=(e-s-.5)/o,i=1,u=1;t<0&&(i=-1,t=-t),n<0&&(u=-1,n=-n);const m=1/(1+a*t),v=1/(1+a*n),_=((((h*v+f)*v+d)*v+l)*v+c)*v,g=(i*(1-((((h*m+f)*m+d)*m+l)*m+c)*m*Math.exp(-t*t))-u*(1-_*Math.exp(-n*n)))/(2*o);r[e]=g,p+=g}return n?r.map(e=>e/p):r}static cartesian(e,t){return[].concat(...e.map(e=>t.map(t=>[e,t])))}static symmetricRange(e){if((e|=0)<0)throw new i.f("Expected a non-negative integer as input");return[...Array(2*e+1).keys()].map(t=>t-e)}static range(e){if((e|=0)<=0)throw new i.f("Expected a positive integer as input");return[...Array(e).keys()]}static requestCameraStream(e,t,n={}){if(s.log("Accessing the webcam..."),!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia)throw new i.i("Unsupported browser: no mediaDevices.getUserMedia()");return new r.a((r,o)=>{navigator.mediaDevices.getUserMedia({audio:!1,video:{width:{ideal:e},height:{ideal:t},aspectRatio:e/t,facingMode:"environment",frameRate:30},...n}).then(e=>{const t=document.createElement("video");t.onloadedmetadata=()=>{t.play(),s.log("The camera device is turned on!"),r(t)},t.srcObject=e}).catch(e=>{o(new i.b("Please give access to the camera and reload the page",e))})})}}},function(e,t,n){"use strict";n.d(t,"b",(function(){return g})),n.d(t,"a",(function(){return x}));var i=n(4),r=n(1),s=n(6),o=n(0);const a=[/\/\*(.|\s)*?\*\//g,/\/\/.*$/gm],c=/^\s*@\s*include\s+"(.*?)"/gm,l=/@(\w+)@/g,d=[/@\s*unroll\s+?for\s*\(\s*(int|)\s*(?<counter>\w+)\s*\=\s*(-?\d+|\w+)\s*;\s*\k<counter>\s*(<=?)\s*(-?\d+|\w+)\s*;\s*\k<counter>\s*\+\+()\s*\)\s*\{\s*([\s\S]+?)\s*\}/g,/@\s*unroll\s+?for\s*\(\s*(int|)\s*(?<counter>\w+)\s*\=\s*(-?\d+|\w+)\s*;\s*\k<counter>\s*(<=?)\s*(-?\d+|\w+)\s*;\s*\k<counter>\s*\+=\s*(-?\d+)\s*\)\s*\{\s*([\s\S]+?)\s*\}/g],f=Object.freeze({MAX_TEXTURE_LENGTH:i.i,LITTLE_ENDIAN:i.f?1:0,PYRAMID_MAX_LEVELS:i.k,LOG2_PYRAMID_MAX_SCALE:i.g,PYRAMID_MAX_OCTAVES:i.l,PIXELCOMPONENT_RED:s.d.RED,PIXELCOMPONENT_GREEN:s.d.GREEN,PIXELCOMPONENT_BLUE:s.d.BLUE,PIXELCOMPONENT_ALPHA:s.d.ALPHA,FIX_BITS:i.a,FIX_RESOLUTION:i.b,MAX_DESCRIPTOR_SIZE:i.h,MIN_KEYPOINT_SIZE:i.j,KPF_NONE:i.d,KPF_ORIENTED:i.e,KPF_DISCARD:i.c});class h{static run(e,t=new Map){return function(e,t){const n=p.bind(t),i=d.length;for(let t=0;t<i;t++)e=e.replace(d[t],n);return e}(String(e).replace(a[0],"").replace(a[1],"").replace(c,(e,i)=>h.run(function(e){if(String(e).match(/^[a-zA-Z0-9_\-]+\.glsl$/))return n(22)("./"+e);throw new o.d(`Shader preprocessor: can't read file "${e}"`)}(i),t)).replace(l,(e,t)=>String(void 0!==f[t]?f[t]:"UNDEFINED_CONSTANT")),t)}}function p(e,t,n,i,s,a,c,l){const d=this;if(i=Number.isFinite(+i)?i:d.get(i),a=Number.isFinite(+a)?a:d.get(a),void 0===i||void 0===a){if(d.size>0)throw new o.j(`Can't unroll loop: unknown limits (start=${i}, end=${a}). Code:\n\n${e}`);return e}i=parseInt(i),a=parseInt(a),c=0==c.length?1:parseInt(c),r.a.assert(i<=a&&c>0);let f=null!==l.match(/\bbreak\s*;/)?"switch(1) { default:\n":"{\n";f+=`${t} ${n};\n`,a+="<="==s?1:0;for(let e=i;e<a;e+=c)f+=`{\n${n} = ${e};\n${l}\n}\n`;return f+="}\n",f}const u=Object.freeze({position:"a_position",texCoord:"a_texCoord"}),m=`#version 300 es\nin vec2 ${u.position};\nin vec2 ${u.texCoord};\nout vec2 texCoord;\n\nvoid main() {\n    gl_Position = vec4(${u.position}, 0.0, 1.0);\n    texCoord = ${u.texCoord};\n}`,v='#version 300 es\nprecision highp int;\nprecision mediump float;\nprecision mediump sampler2D;\n\nout vec4 color;\nin vec2 texCoord;\nuniform vec2 texSize;\n\n@include "global.glsl"\n';class _{constructor(e){const t=e.filepath||null,i=t?n(23)("./"+t):e.source||"";if(0==i.length)throw new o.f("Can't import shader: empty code");this._userSource=i,this._vertexSource=h.run(m),this._fragmentSource=h.run(v+this._userSource),this._filepath=t||"<in-memory>",this._arguments=[],this._uniforms=this._autodetectUniforms(this._fragmentSource),this._defines=new Map}static create(e){return new _({source:e})}static import(e){if(!String(e).match(/^[a-zA-Z0-9_\-\/]+\.glsl$/))throw new o.d(`Can't import shader: "${e}"`);return new _({filepath:e})}withArguments(...e){if(this._arguments.length>0)throw new o.g("Redefinition of shader arguments");this._arguments=e.map(e=>String(e));for(const e of this._arguments)if(!this._uniforms.has(e)&&!this._uniforms.has(e+"[0]"))throw new o.f(`Argument "${e}" has not been declared in the shader`);return this}withDefines(e){if(this._defines.size>0)throw new o.g("Redefinition of externally defined constants of a shader");const t=[];for(const n of Object.keys(e)){const i=Number(e[n]);this._defines.set(n,i),t.push(`#define ${n} ${i}\n`)}const n=v+t.join("")+this._userSource;return this._fragmentSource=h.run(n,this._defines),this}get fragmentSource(){return this._fragmentSource}get vertexSource(){return this._vertexSource}get attributes(){return u}get arguments(){return this._arguments}get uniforms(){return Array.from(this._uniforms.keys())}uniformType(e){if(!this._uniforms.has(e))throw new o.f(`Unrecognized uniform variable: "${e}"`);return this._uniforms.get(e)}definedConstant(e){if(!this._defines.has(e))throw new o.f(`Unrecognized externally defined constant: "${e}"`);return this._defines.get(e)}_autodetectUniforms(e){const t=e,n=/^\s*uniform\s+(highp\s+|mediump\s+|lowp\s+)?(\w+)\s+([^;]+)/gm,i=new Map;let r;for(;null!==(r=n.exec(t));){const e=r[2],t=r[3].split(",").map(e=>e.trim()).filter(e=>e);for(const n of t)if(n.endsWith("]")){if(!(r=n.match(/(\w+)\s*\[\s*(\d+)\s*\]$/)))throw new o.j(`Unspecified array length for uniform "${n}" in the shader`);const[t,s]=[r[1],Number(r[2])];if(0==s)throw new o.j(`Array ${t} has size zero`);for(let n=0;n<s;n++)i.set(`${t}[${n}]`,e)}else i.set(n,e)}return i}}function g(e){return _.import(e)}function x(e){return _.create(e)}},function(e,t,n){"use strict";n.r(t),n.d(t,"conv2D",(function(){return o})),n.d(t,"convX",(function(){return a})),n.d(t,"convY",(function(){return c})),n.d(t,"createKernel2D",(function(){return d})),n.d(t,"createKernel1D",(function(){return f})),n.d(t,"texConv2D",(function(){return h})),n.d(t,"texConvX",(function(){return p})),n.d(t,"texConvY",(function(){return u}));var i=n(2),r=n(1),s=n(0);function o(e,t=1){const n=new Float32Array(e.map(e=>+e*+t)),o=0|Math.sqrt(n.length),a=o>>1;if(o<1||o%2==0)throw new s.f("Can't perform a 2D convolution with an invalid kSize of "+o);if(o*o!=n.length)throw new s.f(`Invalid 2D convolution kernel of ${n.length} elements (expected: square)`);const c=a<=7?"pixelAtShortOffset":"pixelAtLongOffset",l=`\n    uniform sampler2D image;\n\n    void main()\n    {\n        float alpha = threadPixel(image).a;\n        vec4 result = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n\n        ${d=(e,t,n)=>`\n        result += ${c}(image, ivec2(${0|n}, ${0|t})) * float(${+e});\n    `,r.a.cartesian(r.a.symmetricRange(a),r.a.symmetricRange(a)).map(e=>d(n[(e[0]+a)*o+(e[1]+a)],e[0],e[1])).join("\n")}\n\n        color = vec4(result.rgb, alpha);\n    }\n    `;var d;return Object(i.a)(l).withArguments("image")}function a(e,t=1){return l("x",e,t)}function c(e,t=1){return l("y",e,t)}function l(e,t,n=1){const o=new Float32Array(t.map(e=>+e*+n)),a=o.length,c=a>>1;if(a<1||a%2==0)throw new s.f("Can't perform a 1D convolution with an invalid kSize of "+a);if("x"!=e&&"y"!=e)throw new s.f(`Can't perform 1D convolution: invalid axis "${e}"`);const l=c<=7?"pixelAtShortOffset":"pixelAtLongOffset",d=`\n    uniform sampler2D image;\n\n    void main()\n    {\n        float alpha = threadPixel(image).a;\n        vec4 pixel = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n\n        ${f=(t,n)=>"x"==e?`\n        pixel += ${l}(image, ivec2(${0|n}, 0)) * float(${+t});\n    `:`\n        pixel += ${l}(image, ivec2(0, ${0|n})) * float(${+t});\n    `,r.a.symmetricRange(c).reduce((e,t)=>e+f(o[t+c],t),"")}\n\n        color = vec4(pixel.rgb, alpha);\n    }\n    `;var f;return Object(i.a)(d).withArguments("image")}function d(e){if((e|=0)<1||e%2==0)throw new s.f("Can't create a 2D texture kernel of size "+e);const t=`\n    uniform float kernel[${e*e}];\n\n    void main()\n    {\n        ivec2 thread = threadLocation();\n        float val = kernel[(${e}) * thread.y + thread.x];\n\n        float e0 = floor(val);\n        float e1 = 256.0f * fract(val);\n        float e2 = 256.0f * fract(e1);\n        float e3 = 256.0f * fract(e2);\n\n        color = vec4(e0, floor(e1) / 256.0f, floor(e2) / 256.0f, floor(e3) / 256.0f);\n    }\n    `;return Object(i.a)(t).withArguments("kernel")}function f(e){if((e|=0)<1||e%2==0)throw new s.f("Can't create a 1D texture kernel of size "+e);const t=`\n    uniform float kernel[${e}];\n\n    void main()\n    {\n        ivec2 thread = threadLocation();\n        float val = kernel[thread.x];\n\n        float e0 = floor(val);\n        float e1 = 256.0f * fract(val);\n        float e2 = 256.0f * fract(e1);\n        float e3 = 256.0f * fract(e2);\n\n        color = vec4(e0, floor(e1) / 256.0f, floor(e2) / 256.0f, floor(e3) / 256.0f);\n    }\n    `;return Object(i.a)(t).withArguments("kernel")}function h(e){const t=e>>1;if(e<1||e%2==0)throw new s.f("Can't perform a texture-based 2D convolution with an invalid kernel size of "+e);const n=t<=7?"pixelAtShortOffset":"pixelAtLongOffset",o=`\n    const vec4 magic = vec4(1.0f, 1.0f, 1.0f / 256.0f, 1.0f / 65536.0f);\n    uniform sampler2D image, texKernel;\n    uniform float scale, offset;\n\n    void main()\n    {\n        vec4 kernel = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n        vec4 result = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n        float alpha = threadPixel(image).a;\n        float value = 0.0f;\n\n        ${a=(e,i)=>`\n        kernel = pixelAt(texKernel, ivec2(${e+t}, ${i+t}));\n        value = dot(kernel, magic) * scale + offset;\n        result += ${n}(image, ivec2(${e}, ${i})) * value;\n    `,r.a.cartesian(r.a.symmetricRange(t),r.a.symmetricRange(t)).map(e=>a(e[0],e[1])).join("\n")}\n\n        result = clamp(result, 0.0f, 1.0f);\n        color = vec4(result.rgb, alpha);\n    }\n    `;var a;return Object(i.a)(o).withArguments("image","texKernel","scale","offset")}const p=e=>m(e,"x"),u=e=>m(e,"y");function m(e,t){const n=e>>1;if(e<1||e%2==0)throw new s.f("Can't perform a texture-based 2D convolution with an invalid kernel size of "+e);if("x"!=t&&"y"!=t)throw new s.f(`Can't perform a texture-based 1D convolution: invalid axis "${t}"`);const o=n<=7?"pixelAtShortOffset":"pixelAtLongOffset",a=`\n    const vec4 magic = vec4(1.0f, 1.0f, 1.0f / 256.0f, 1.0f / 65536.0f);\n    uniform sampler2D image, texKernel;\n    uniform float scale, offset;\n\n    void main()\n    {\n        vec4 kernel = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n        vec4 result = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n        float alpha = threadPixel(image).a;\n        float value = 0.0f;\n\n        ${c=e=>"x"==t?`\n        kernel = pixelAt(texKernel, ivec2(${e+n}, 0));\n        value = dot(kernel, magic) * scale + offset;\n        result += ${o}(image, ivec2(${e}, 0)) * value;\n    `:`\n        kernel = pixelAt(texKernel, ivec2(${e+n}, 0));\n        value = dot(kernel, magic) * scale + offset;\n        result += ${o}(image, ivec2(0, ${e})) * value;\n    `,r.a.symmetricRange(n).map(c).join("\n")}\n\n        result = clamp(result, 0.0f, 1.0f);\n        color = vec4(result.rgb, alpha);\n    }\n    `;var c;return Object(i.a)(a).withArguments("image","texKernel","scale","offset")}},function(e,t,n){"use strict";n.d(t,"k",(function(){return i})),n.d(t,"l",(function(){return r})),n.d(t,"g",(function(){return s})),n.d(t,"a",(function(){return o})),n.d(t,"b",(function(){return a})),n.d(t,"i",(function(){return c})),n.d(t,"h",(function(){return l})),n.d(t,"j",(function(){return d})),n.d(t,"d",(function(){return f})),n.d(t,"e",(function(){return h})),n.d(t,"c",(function(){return p})),n.d(t,"f",(function(){return u}));const i=7,r=2*i-1,s=Math.log2(2),o=3,a=1*(1<<o),c=(1<<16-o)-2,l=64,d=8,f=0,h=1,p=128,u=51966===new Uint16Array(new Uint8Array([254,202]).buffer)[0]},function(e,t,n){"use strict";(function(e){n.d(t,"a",(function(){return r}));const i="undefined"!=typeof queueMicrotask&&queueMicrotask||void 0!==e&&e.nextTick||(e=>Promise.resolve().then(e));class r{constructor(e,t=!1){this._state=0,this._value=void 0,this._onFulfillment=null,this._onRejection=null,this._children=0,this[0]=this,this._parent=void 0,this._flags=t?2:0,this._fulfill=this._fulfill.bind(this),this._reject=this._reject.bind(this),this._resolve=this._resolve.bind(this),this._broadcastIfAsync=this._broadcastIfAsync.bind(this),e(this._fulfill,this._reject)}then(e,t=null){const n=new r(this._nop);return n._onFulfillment="function"==typeof e&&e,n._onRejection="function"==typeof t&&t,n._parent=this,this[this._children++]=n,this._flags&=-2,this._notify(),n}catch(e){return this.then(null,e)}finally(e){const t=t=>(e(),t);return this.then(t,t)}turbocharge(){let e=this;for(this._flags|=1;void 0!==e._parent;)e=e._parent,e._flags|=1;return e._notify(),this}toString(){switch(this._state){case 0:return"SpeedyPromise { <pending> }";case 1:return`SpeedyPromise { <fulfilled> ${this._value} }`;case 2:return`SpeedyPromise { <rejected> ${this._value} }`;default:return""}}static resolve(e){const t=new r(this._snop);return"object"==typeof e&&null!==e&&"then"in e||"function"==typeof e&&"then"in e?t._resolve(e):(t._value=e,t._state=1),t}static reject(e){const t=new r(this._snop);return t._value=e,t._state=2,t}static all(e){return new r((t,n)=>{const i=[];for(const t of e)i.push(t);const s=i.length;if(0==s)return void t([]);let o=s;const a=new Array(s),c=e=>n=>{a[e]=n,0==--o&&t(a)};for(let e=0;e<s;e++){const t=i[e];t.__proto__===r.prototype||t.__proto__===Promise.prototype?t.then(c(e),n):r.resolve(t).then(c(e),n)}})}static race(e){return new r((t,n)=>{const i=[];for(const t of e)i.push(t);const s=i.length;for(let e=0;e<s;e++){const s=i[e];s.__proto__===r.prototype||s.__proto__===Promise.prototype?s.then(t,n):r.resolve(s).then(t,n)}})}_fulfill(e){this._setState(1,e)}_reject(e){this._setState(2,e)}_setState(e,t){0==this._state&&(this._state=e,this._value=t,this._notify())}_notify(){0!=this._state&&(1&this._flags?this._broadcast():2&this._flags||i(this._broadcastIfAsync))}_broadcastIfAsync(){1&this._flags||this._broadcast()}_broadcast(){const e=this._children,t=this._state;if(1===t)for(let t=0;t<e;t++){const e=this[t],n=e._onFulfillment;try{n?n!==e._nop&&(e._resolve(n(this._value)),e._onFulfillment=e._nop):e._fulfill(this._value)}catch(t){e._reject(t)}}else if(2===t)for(let t=0;t<e;t++){const e=this[t],n=e._onRejection;try{n?n!==e._nop&&(e._resolve(n(this._value)),e._onRejection=e._nop):e._reject(this._value)}catch(t){e._reject(t)}}}_resolve(e){if("object"!=typeof e&&"function"!=typeof e||null===e)this._fulfill(e);else{if(e===this)throw new TypeError;if(e.__proto__!==r.prototype&&e.__proto__!==Promise.prototype)try{const t=e.then;if("function"==typeof t){let n=this._resolve,i=this._reject;try{t.call(e,e=>{n(e),n=i=this._nop},e=>{i(e),n=i=this._nop})}catch(e){n!==this._nop&&i!==this._nop&&this._reject(e)}}else this._fulfill(e)}catch(e){this._reject(e)}else e.then(this._resolve,this._reject)}}_nop(){}static _snop(){}}}).call(this,n(21))},function(e,t,n){"use strict";n.d(t,"c",(function(){return r})),n.d(t,"b",(function(){return s})),n.d(t,"d",(function(){return o})),n.d(t,"a",(function(){return a}));var i=n(1);const r=i.a.enum("Image","Video","Canvas","Bitmap"),s=i.a.enum("RGB","Greyscale","Binary"),o=Object.freeze({RED:1,GREEN:2,BLUE:4,ALPHA:8,ALL:15}),a=Object.freeze({[o.RED]:0,[o.GREEN]:1,[o.BLUE]:2,[o.ALPHA]:3})},function(e,t){e.exports={MatrixType:
//! No imports here
//! MatrixType is exported to a WebWorker
class{static isValid(e){return Object.prototype.hasOwnProperty.call(this._classOf,e)}static createTypedArray(e,...t){if(!this.isValid(e))throw new Error(`Invalid matrix type: "${e}"`);return Reflect.construct(this._classOf[e],t)}static get default(){return"float32"}static get _classOf(){return this._dataType||(this._dataType=Object.freeze({float32:Float32Array,float64:Float64Array,int32:Int32Array,uint8:Uint8Array}))}static freeze(){const e=(this._classOf,this);return Object.freeze(e)}}.freeze()}},function(e,t,n){const{MatrixType:i}=n(7),r={...n(63),...n(64),...n(65),...n(66)},s=function(){"use strict";function e(){}return e.lib=Object.create(null),e.lib._src=Object.create(null),e.register=function(t,n){if("function"!=typeof n)throw new Error("Not a function: "+t);if("string"!=typeof t||!t.match(/^[a-z_][0-9a-z_]*$/i))throw new Error("Undesirable identifier: "+t);if(e.hasMethod(t))throw new Error("Can't redefine method "+t);const i={enumerable:!0,writable:!1,configurable:!1};Object.defineProperty(e.lib,t,{value:n.bind(e.lib),...i}),Object.defineProperty(e.lib._src,t,{value:n.toString(),...i})},e.hasMethod=function(t){return Object.prototype.hasOwnProperty.call(e.lib,t)},e.toString=function(){const t=Object.keys(e.lib._src).map(t=>`LinAlg.lib.${t} = (${e.lib._src[t]}).bind(LinAlg.lib);`).join("\n");return`(function() {\n'use strict';\nfunction LinAlg() { }\nLinAlg.lib = Object.create(null);\nLinAlg.lib.MatrixType = (${i.toString()}).freeze();\n\n${t}\n\nObject.freeze(LinAlg.lib);\nreturn Object.freeze(LinAlg);\n})()`},Object.defineProperty(e.lib,"MatrixType",{value:i.freeze(),writable:!1,configurable:!1,enumerable:!1}),Object.keys(r).forEach(t=>{e.register(t,r[t])}),Object.freeze(e)}();e.exports={LinAlg:s}},function(e,t,n){"use strict";n.r(t),n.d(t,"median",(function(){return o}));var i=n(2),r=n(1),s=n(0);function o(e){if((e|=0)<=1||e%2==0)throw new s.f(`Can't create median filter with a ${e}x${e} window`);const t=e>>1,n=t<=7?"pixelAtShortOffset":"pixelAtLongOffset",o=e*e,a=o>>1,c=`\n    uniform sampler2D image;\n\n    void main()\n    {\n        float v[${o}], swpv;\n        int m;\n\n        // read pixels\n        ${l=(e,t,i)=>`\n        v[${e}] = ${n}(image, ivec2(${i}, ${t})).g;\n    `,r.a.cartesian(r.a.symmetricRange(t),r.a.symmetricRange(t)).map((e,t)=>l(t,e[0],e[1])).join("\n")}\n\n        // sort v[0..med]\n        ${(e=>r.a.range(a+1).map(e).join("\n"))(e=>`\n        m = ${e};\n        ${(e=>r.a.range(o-(e+1)).map(t=>t+e+1).map(e=>`\n        m += int(v[${e}] >= v[m]) * (${e} - m);\n    `).join("\n"))(e)}\n        swpv = v[${e}];\n        v[${e}] = v[m];\n        v[m] = swpv;\n    `)}\n\n        // return the median\n        color = vec4(v[${a}], v[${a}], v[${a}], 1.0f);\n    }\n    `;var l;return Object(i.a)(c).withArguments("image")}},function(e,t){e.exports="#ifndef _COLORS_GLSL\n#define _COLORS_GLSL\n#define PIXELCOMPONENT_RED   @PIXELCOMPONENT_RED@\n#define PIXELCOMPONENT_GREEN @PIXELCOMPONENT_GREEN@\n#define PIXELCOMPONENT_BLUE  @PIXELCOMPONENT_BLUE@\n#define PIXELCOMPONENT_ALPHA @PIXELCOMPONENT_ALPHA@\n#endif"},function(e,t){e.exports="#ifndef _FIXEDPOINT_GLSL\n#define _FIXEDPOINT_GLSL\n#define fixed_t int\n#define fixed2_t ivec2\nconst int FIX_BITS = int(@FIX_BITS@);\nconst float FIX_RESOLUTION = float(@FIX_RESOLUTION@);\n#define itofix(x) fixed_t((x) << FIX_BITS)\n#define fixtoi(f) int((x) >> FIX_BITS)\n#define ftofix(x) fixed_t((x) * FIX_RESOLUTION + 0.5f)\n#define fixtof(f) (float(f) / FIX_RESOLUTION)\n#define ivec2tofix(x) fixed2_t((x) << FIX_BITS)\n#define fixtoivec2(f) ivec2((f) >> FIX_BITS)\n#define vec2tofix(v) fixed2_t((v) * FIX_RESOLUTION + vec2(0.5f))\n#define fixtovec2(f) (vec2(f) / FIX_RESOLUTION)\n#endif"},function(e,t){e.exports="#ifndef _FLOAT16_GLSL\n#define _FLOAT16_GLSL\n#define encodeFloat16(f) (vec2(packf16(f)) / 255.0f)\n#define decodeFloat16(v) unpackf16(uvec2((v) * 255.0f))\nuvec2 packf16( float f)\n{\nuint y = packHalf2x16(vec2(f, 0.0f));\nreturn uvec2(y, y >> 8) & 0xFFu;\n}\nfloat unpackf16(uvec2 v)\n{\nv &= 0xFFu;\nreturn unpackHalf2x16(v.x | (v.y << 8)).x;\n}\n#endif"},function(e,t){e.exports="#ifndef _GLOBAL_GLSL\n#define _GLOBAL_GLSL\n#define threadLocation() ivec2(texCoord * texSize)\n#define outputSize() ivec2(texSize)\n#define DEBUG(scalar) do { color = vec4(float(scalar), 0.0f, 0.0f, 1.0f); return; } while(false)\n#define threadPixel(img) textureLod((img), texCoord, 0.0f)\n#define pixelAt(img, pos) texelFetch((img), (pos), 0)\n#define pixelAtShortOffset(img, offset) textureLodOffset((img), texCoord, 0.0f, (offset))\n#define pixelAtLongOffset(img, offset) textureLod((img), texCoord + vec2(offset) / texSize, 0.0f)\n#define subpixelAt(img, pos) textureLod((img), ((pos) + vec2(0.5f)) / texSize, 0.0f)\n#endif"},function(e,t){e.exports='#ifndef _KEYPOINTS_GLSL\n#define _KEYPOINTS_GLSL\n@include "pyramids.glsl"\n@include "orientation.glsl"\n@include "fixed-point.glsl"\nstruct Keypoint\n{\nvec2 position;\nfloat orientation;\nfloat lod;\nfloat score;\nint flags;\n};\nstruct KeypointAddress\n{\nint base;\nint offset;\n};\nconst int MAX_DESCRIPTOR_SIZE = int(@MAX_DESCRIPTOR_SIZE@);\nconst int MIN_KEYPOINT_SIZE = int(@MIN_KEYPOINT_SIZE@);\nconst int KPF_NONE = int(@KPF_NONE@);\nconst int KPF_ORIENTED = int(@KPF_ORIENTED@);\nconst int KPF_DISCARD = int(@KPF_DISCARD@);\nvec4 readKeypointData(sampler2D encodedKeypoints, int encoderLength, KeypointAddress address)\n{\nint rasterIndex = address.base + address.offset;\nreturn pixelAt(encodedKeypoints, ivec2(rasterIndex % encoderLength, rasterIndex / encoderLength));\n}\n#define sizeofEncodedKeypoint(descriptorSize, extraSize) (MIN_KEYPOINT_SIZE + (descriptorSize) + (extraSize))\n#define findKeypointIndex(address, descriptorSize, extraSize) ((address).base / ((sizeofEncodedKeypoint((descriptorSize), (extraSize))) / 4))\nKeypointAddress findKeypointAddress(ivec2 thread, int encoderLength, int descriptorSize, int extraSize)\n{\nint threadRaster = thread.y * encoderLength + thread.x;\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nint keypointIndex = int(threadRaster / pixelsPerKeypoint);\nKeypointAddress address = KeypointAddress(\nkeypointIndex * pixelsPerKeypoint,\nthreadRaster % pixelsPerKeypoint\n);\nreturn address;\n}\nKeypoint decodeKeypoint(sampler2D encodedKeypoints, int encoderLength, KeypointAddress address)\n{\nconst vec4 ones = vec4(1.0f);\nKeypoint keypoint;\nKeypointAddress positionAddress = KeypointAddress(address.base, 0);\nKeypointAddress propertiesAddress = KeypointAddress(address.base, 1);\nvec4 rawEncodedPosition = readKeypointData(encodedKeypoints, encoderLength, positionAddress);\nivec4 encodedPosition = ivec4(rawEncodedPosition * 255.0f);\nkeypoint.position = fixtovec2(fixed2_t(\nencodedPosition.r | (encodedPosition.g << 8),\nencodedPosition.b | (encodedPosition.a << 8)\n));\nvec4 encodedProperties = readKeypointData(encodedKeypoints, encoderLength, propertiesAddress);\nkeypoint.orientation = decodeOrientation(encodedProperties.g);\nkeypoint.lod = decodeLod(encodedProperties.r);\nkeypoint.score = encodedProperties.b;\nkeypoint.flags = int(encodedProperties.a * 255.0f);\nbool isNull = all(greaterThanEqual(rawEncodedPosition, ones));\nkeypoint.score = keypoint.score * float(!isNull) - float(isNull);\nkeypoint.score -= float(keypoint.score == 0.0f) * float(all(equal(keypoint.position, vec2(0.0f))));\nreturn keypoint;\n}\nvec4 encodeKeypointPosition(vec2 position)\n{\nconst vec2 zeros = vec2(0.0f);\nfixed2_t pos = vec2tofix(max(position, zeros));\nfixed2_t lo = pos & 255;\nfixed2_t hi = pos >> 8;\nreturn vec4(lo.x, hi.x, lo.y, hi.y) / 255.0f;\n}\n#define encodeNullKeypoint() (vec4(1.0f))\n#define isBadKeypoint(keypoint) ((keypoint).score < 0.0f)\n#define encodeKeypointPositionAtInfinity() (vec4(254.0f / 255.0f, vec3(1.0f)))\nbool isKeypointAtInfinity(Keypoint keypoint)\n{\nconst vec2 V2_MAX_TEXTURE_LENGTH = vec2(@MAX_TEXTURE_LENGTH@);\nreturn any(greaterThan(keypoint.position, V2_MAX_TEXTURE_LENGTH));\n}\n#define encodeKeypointFlags(flags) (float(flags) / 255.0f)\n#endif'},function(e,t){e.exports="#ifndef _MATH_GLSL\n#define _MATH_GLSL\n#define TWO_PI          6.28318530718f\n#define PI              3.14159265359f\n#define PI_OVER_2       1.57079632679f\n#define PI_OVER_4       0.78539816339f\n#define INV_PI          0.3183098861837907f\n#define USE_FAST_ATAN\n#ifdef USE_FAST_ATAN\nfloat fastAtan(float x)\n{\nfloat w = 1.0f - abs(x);\nreturn (w >= 0.0f) ? ((PI_OVER_4 + 0.273 * w) * x) :\n(sign(x) * PI_OVER_2 - (PI_OVER_4 + 0.273 * (1.0f - abs(1.0f / x))) / x);\n}\n#else\n#define fastAtan(x) atan(x)\n#endif\n#ifdef USE_FAST_ATAN\nfloat fastAtan2(float y, float x)\n{\nreturn (x == 0.0f) ? PI_OVER_2 * sign(y) : fastAtan(y / x) + float(x < 0.0f) * PI * sign(y);\n}\n#else\n#define fastAtan2(y, x) atan((y), (x))\n#endif\n#endif"},function(e,t){e.exports='#ifndef _ORIENTATION_GLSL\n#define _ORIENTATION_GLSL\n@include "math.glsl"\n#define encodeOrientation(angle) ((angle) * INV_PI + 1.0f) * 0.5f\n#define decodeOrientation(value) ((value) * 2.0f - 1.0f) * PI\n#endif'},function(e,t){e.exports="#ifndef _PYRAMIDS_GLSL\n#define _PYRAMIDS_GLSL\n#define pyrPixel(pyr, lod) textureLod((pyr), texCoord, (lod))\n#define pyrPixelAtOffset(pyr, lod, pot, offset) textureLod((pyr), texCoord + ((pot) * vec2(offset)) / texSize, (lod))\n#define pyrPixelAt(pyr, pos, lod) textureLod((pyr), (vec2(pos) + vec2(0.5f)) / texSize, (lod))\n#define pyrPixelAtEx(pyr, pos, lod, pyrBaseSize) textureLod((pyr), (vec2(pos) + vec2(0.5f)) / vec2(pyrBaseSize), (lod))\n#define pyrSubpixelAtEx(pyr, pos, lod, pyrBaseSize) textureLod((pyr), ((pos) + vec2(0.5f)) / vec2(pyrBaseSize), (lod))\n#define pyrSubpixelAtExOffset(pyr, pos, lod, pot, offset, pyrBaseSize) textureLod((pyr), (((pos) + vec2(0.5f)) + ((pot) * vec2(offset))) / vec2(pyrBaseSize), (lod))\nconst int PYRAMID_MAX_OCTAVES = int(@PYRAMID_MAX_OCTAVES@);\nconst int PYRAMID_MAX_LEVELS = int(@PYRAMID_MAX_LEVELS@);\nconst float F_PYRAMID_MAX_LEVELS = float(@PYRAMID_MAX_LEVELS@);\nconst float LOG2_PYRAMID_MAX_SCALE = float(@LOG2_PYRAMID_MAX_SCALE@);\nfloat encodeLod(float lod)\n{\nreturn (LOG2_PYRAMID_MAX_SCALE + lod) / (LOG2_PYRAMID_MAX_SCALE + F_PYRAMID_MAX_LEVELS);\n}\nfloat decodeLod(float encodedLod)\n{\nfloat lod = encodedLod * (LOG2_PYRAMID_MAX_SCALE + F_PYRAMID_MAX_LEVELS) - LOG2_PYRAMID_MAX_SCALE;\nreturn lod * float(encodedLod < 1.0f);\n}\n#define isSameEncodedLod(alpha1, alpha2) (abs((alpha1) - (alpha2)) < encodedLodEps)\nconst float encodedLodEps = 0.2f / (LOG2_PYRAMID_MAX_SCALE + F_PYRAMID_MAX_LEVELS);\n#endif"},function(e,t){e.exports="#ifndef _QUICKSELECT_GLSL\n#define _QUICKSELECT_GLSL\n#if defined(QUICKSELECT_UNSIGNED) && !defined(QUICKSELECT_SIGNED)\n#define QS_TYPE uint\n#define QS_TYPE4 uvec4\n#elif !defined(QUICKSELECT_UNSIGNED) && defined(QUICKSELECT_SIGNED)\n#define QS_TYPE int\n#define QS_TYPE4 ivec4\n#else\n#error Must define either QUICKSELECT_SIGNED or QUICKSELECT_UNSIGNED before including quickselect\n#endif\n#if defined(QUICKSELECT_ASCENDING) && !defined(QUICKSELECT_DESCENDING)\n#define QS_ORD(element,pivot) ((element) < (pivot))\n#elif defined(QUICKSELECT_DESCENDING) && !defined(QUICKSELECT_ASCENDING)\n#define QS_ORD(element,pivot) ((element) > (pivot))\n#else\n#error Must define either QUICKSELECT_ASCENDING or QUICKSELECT_DESCENDING before including quickselect\n#endif\n#ifdef QUICKSELECT_ARRAY\n#define QS_ARRAY QUICKSELECT_ARRAY\n#else\n#error Must define QUICKSELECT_ARRAY before including quickselect\n#endif\nint qspart(int l, int r, int p)\n{\n#define QS_SWAP(a,b) t = QS_ARRAY[(a)]; QS_ARRAY[(a)] = QS_ARRAY[(b)]; QS_ARRAY[(b)] = t\nhighp QS_TYPE e, t, mask, pivot = QS_ARRAY[p];\nhighp QS_TYPE4 tmp;\nint q, cond;\nQS_SWAP(p, r);\nq = l;\nfor(int i = l; i < r; i++) {\ne = QS_ARRAY[i];\nt = QS_ARRAY[q];\ncond = int(QS_ORD(e, pivot));\nmask = QS_TYPE(-cond);\ntmp = QS_TYPE4(mask & t, (~mask) & e, mask & e, (~mask) & t);\nQS_ARRAY[i] = tmp.x | tmp.y;\nQS_ARRAY[q] = tmp.z | tmp.w;\nq += cond;\n}\nQS_SWAP(q, r);\nreturn q;\n}\nhighp QS_TYPE quickselect(int l, int r, int k)\n{\nint p = -1337;\nivec2 idx = ivec2(l, r);\nwhile(idx.s < idx.t && p != k) {\np = qspart(idx.s, idx.t, (idx.s + idx.t) / 2);\nidx = int(k < p) * ivec2(idx.s, p-1) + int(k >= p) * ivec2(p+1, idx.t);\n}\nreturn (p == k) ? QS_ARRAY[k] : QS_ARRAY[idx.s];\n}\n#endif"},function(e,t){e.exports="#ifndef _SOBEL_GLSL\n#define _SOBEL_GLSL\nvec4 encodeSobel(vec2 df)\n{\n#ifdef SOBEL_USE_LOG\nconst vec2 zero = vec2(0.0f);\nvec2 dmax = -max(df, zero);\nvec2 dmin = min(df, zero);\nreturn exp2(vec4(dmax, dmin));\n#else\nuint data = packHalf2x16(df);\nuvec4 bytes = uvec4(data, data >> 8, data >> 16, data >> 24) & 255u;\nreturn vec4(bytes) / 255.0f;\n#endif\n}\nvec2 decodeSobel(vec4 encodedSobel)\n{\n#ifdef SOBEL_USE_LOG\nvec4 lg = log2(encodedSobel);\nreturn vec2(lg.b - lg.r, lg.a - lg.g);\n#else\nuvec4 bytes = uvec4(encodedSobel * 255.0f);\nuint data = bytes.r | (bytes.g << 8) | (bytes.b << 16) | (bytes.a << 24);\nreturn unpackHalf2x16(data);\n#endif\n}\n#endif"},function(e,t,n){e.exports=n(67).Speedy},function(e,t){var n,i,r=e.exports={};function s(){throw new Error("setTimeout has not been defined")}function o(){throw new Error("clearTimeout has not been defined")}function a(e){if(n===setTimeout)return setTimeout(e,0);if((n===s||!n)&&setTimeout)return n=setTimeout,setTimeout(e,0);try{return n(e,0)}catch(t){try{return n.call(null,e,0)}catch(t){return n.call(this,e,0)}}}!function(){try{n="function"==typeof setTimeout?setTimeout:s}catch(e){n=s}try{i="function"==typeof clearTimeout?clearTimeout:o}catch(e){i=o}}();var c,l=[],d=!1,f=-1;function h(){d&&c&&(d=!1,c.length?l=c.concat(l):f=-1,l.length&&p())}function p(){if(!d){var e=a(h);d=!0;for(var t=l.length;t;){for(c=l,l=[];++f<t;)c&&c[f].run();f=-1,t=l.length}c=null,d=!1,function(e){if(i===clearTimeout)return clearTimeout(e);if((i===o||!i)&&clearTimeout)return i=clearTimeout,clearTimeout(e);try{i(e)}catch(t){try{return i.call(null,e)}catch(t){return i.call(this,e)}}}(e)}}function u(e,t){this.fun=e,this.array=t}function m(){}r.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)t[n-1]=arguments[n];l.push(new u(e,t)),1!==l.length||d||a(p)},u.prototype.run=function(){this.fun.apply(null,this.array)},r.title="browser",r.browser=!0,r.env={},r.argv=[],r.version="",r.versions={},r.on=m,r.addListener=m,r.once=m,r.off=m,r.removeListener=m,r.removeAllListeners=m,r.emit=m,r.prependListener=m,r.prependOnceListener=m,r.listeners=function(e){return[]},r.binding=function(e){throw new Error("process.binding is not supported")},r.cwd=function(){return"/"},r.chdir=function(e){throw new Error("process.chdir is not supported")},r.umask=function(){return 0}},function(e,t,n){var i={"./colors.glsl":10,"./fixed-point.glsl":11,"./float16.glsl":12,"./global.glsl":13,"./keypoints.glsl":14,"./math.glsl":15,"./orientation.glsl":16,"./pyramids.glsl":17,"./quickselect.glsl":18,"./sobel.glsl":19};function r(e){var t=s(e);return n(t)}function s(e){if(!n.o(i,e)){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}return i[e]}r.keys=function(){return Object.keys(i)},r.resolve=s,e.exports=r,r.id=22},function(e,t,n){var i={"./colors/rgb2grey.glsl":24,"./encoders/encode-keypoint-long-offsets.glsl":25,"./encoders/encode-keypoint-offsets.glsl":26,"./encoders/encode-keypoints.glsl":27,"./encoders/resize-encoded-keypoints.glsl":28,"./encoders/upload-keypoints.glsl":29,"./enhancements/nightvision.glsl":30,"./enhancements/normalize-image.glsl":31,"./filters/convolution":3,"./filters/convolution.js":3,"./filters/fast-median.glsl":32,"./filters/median":9,"./filters/median.js":9,"./include/colors.glsl":10,"./include/fixed-point.glsl":11,"./include/float16.glsl":12,"./include/global.glsl":13,"./include/keypoints.glsl":14,"./include/math.glsl":15,"./include/orientation.glsl":16,"./include/pyramids.glsl":17,"./include/quickselect.glsl":18,"./include/sobel.glsl":19,"./keypoints/brisk.glsl":33,"./keypoints/fast/encode-fast-score.glsl":34,"./keypoints/fast/fast-score12.glsl":35,"./keypoints/fast/fast-score16.glsl":36,"./keypoints/fast/fast-score8.glsl":37,"./keypoints/fast/fast5.glsl":38,"./keypoints/fast/fast7.glsl":39,"./keypoints/fast/fast9.glsl":40,"./keypoints/fast/multiscale-fast.glsl":41,"./keypoints/harris/encode-harris-score.glsl":42,"./keypoints/harris/harris-cutoff.glsl":43,"./keypoints/harris/max-harris-score.glsl":44,"./keypoints/harris/multiscale-harris.glsl":45,"./keypoints/harris/multiscale-sobel.glsl":46,"./keypoints/nonmax-suppression.glsl":47,"./keypoints/orb-descriptor.glsl":48,"./keypoints/orb-orientation.glsl":49,"./keypoints/sort-by-score.glsl":50,"./keypoints/suppress-descriptors.glsl":51,"./keypoints/transfer-orientation.glsl":52,"./pyramids/downsample2.glsl":53,"./pyramids/upsample2.glsl":54,"./trackers/lk-discard.glsl":55,"./trackers/lk.glsl":56,"./utils/copy-components.glsl":57,"./utils/fill-components.glsl":58,"./utils/fill.glsl":59,"./utils/flip-y.glsl":60,"./utils/identity.glsl":61,"./utils/scan-minmax2d.glsl":62};function r(e){var t=s(e);return n(t)}function s(e){if(!n.o(i,e)){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}return i[e]}r.keys=function(){return Object.keys(i)},r.resolve=s,e.exports=r,r.id=23},function(e,t){e.exports="const vec4 grey = vec4(0.299f, 0.587f, 0.114f, 0.0f);\nuniform sampler2D image;\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nfloat g = dot(pixel, grey);\ncolor = vec4(g, g, g, 1.0f);\n}"},function(e,t){e.exports="uniform sampler2D offsetsImage;\nuniform ivec2 imageSize;\n#ifndef MAX_ITERATIONS\n#error Must define MAX_ITERATIONS\n#endif\n#define decodeSkipOffset(pixel) int((pixel).b * 255.0f) | (int((pixel).a * 255.0f) << 8)\n#define encodeSkipOffset(offset) vec2((offset) & 255, (offset) >> 8) / 255.0f\nvoid main()\n{\nvec4 pixel = threadPixel(offsetsImage);\nivec2 thread = threadLocation();\nvec2 prefix = pixel.rg;\nint rasterIndex = thread.y * imageSize.x + thread.x;\nint offset = decodeSkipOffset(pixel);\nint totalOffset = offset;\nivec2 pos = thread;\n#if 0\nwhile(offset < MAX_ITERATIONS && pos.y < imageSize.y && pixel.r == 0.0f) {\nrasterIndex += offset;\npos = ivec2(rasterIndex % imageSize.x, rasterIndex / imageSize.x);\npixel = pixelAt(offsetsImage, pos);\noffset = decodeSkipOffset(pixel);\ntotalOffset += offset;\n}\n#else\nint allow = 1;\nfor(int i = 0; i < MAX_ITERATIONS; i++) {\nallow *= int(pos.y < imageSize.y) * int(pixel.r == 0.0f);\nrasterIndex += allow * offset;\npos = ivec2(rasterIndex % imageSize.x, rasterIndex / imageSize.x);\npixel = pixelAt(offsetsImage, pos);\noffset = decodeSkipOffset(pixel);\ntotalOffset += allow * offset;\n}\n#endif\ntotalOffset = min(totalOffset, 65535);\ncolor = vec4(prefix, encodeSkipOffset(totalOffset));\n}"},function(e,t){e.exports="uniform sampler2D image;\nuniform ivec2 imageSize;\n#if !defined(MAX_ITERATIONS)\n#error Must define MAX_ITERATIONS\n#elif MAX_ITERATIONS > 255\n#error MAX_ITERATIONS must be less than 256\n#endif\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nivec2 pos = threadLocation();\nvec2 prefix = pixel.ra;\nint offset = 0;\n#if 0\nwhile(offset < MAX_ITERATIONS && pos.y < imageSize.y && pixelAt(image, pos).r == 0.0f) {\n++offset;\npos.x = (pos.x + 1) % imageSize.x;\npos.y += int(pos.x == 0);\n}\n#else\nint allow = 1;\nfor(int i = 0; i < MAX_ITERATIONS; i++) {\nallow *= int(pos.y < imageSize.y) * int(pixel.r == 0.0f);\noffset += allow;\npos.x = (pos.x + 1) % imageSize.x;\npos.y += int(pos.x == 0);\npixel = pixelAt(image, pos);\n}\n#endif\ncolor = vec4(prefix, float(offset) / 255.0f, 0.0f);\n}"},function(e,t){e.exports='@include "keypoints.glsl"\nuniform sampler2D offsetsImage;\nuniform sampler2D encodedKeypoints;\nuniform ivec2 imageSize;\nuniform int passId;\nuniform int numPasses;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\n#define decodeSkipOffset(pixel) int((pixel).b * 255.0f) | (int((pixel).a * 255.0f) << 8)\nbool findQthKeypoint(int q, int p, inout ivec2 position, out vec4 pixel)\n{\nint notFirstPass = int(passId > 0);\nposition *= notFirstPass;\np |= -(1 - notFirstPass);\np -= notFirstPass;\nint rasterIndex = position.y * imageSize.x + position.x;\nwhile(position.y < imageSize.y && p != q) {\nposition = ivec2(rasterIndex % imageSize.x, rasterIndex / imageSize.x);\npixel = texelFetch(offsetsImage, position, 0);\np += int(pixel.r > 0.0f);\nrasterIndex += max(1, decodeSkipOffset(pixel));\n}\nreturn (p == q);\n}\nvoid main()\n{\nivec2 thread = threadLocation();\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nint q = findKeypointIndex(address, descriptorSize, extraSize);\ncolor = vec4(0.0f);\nif(address.offset > 1)\nreturn;\ncolor = threadPixel(encodedKeypoints);\nint numPixels = encoderLength * encoderLength;\nint maxKeypoints = numPixels / pixelsPerKeypoint;\nint maxKeypointsPerPass = maxKeypoints / numPasses + int(maxKeypoints % numPasses != 0);\nint targetPassId = q / maxKeypointsPerPass;\nif(passId != targetPassId)\nreturn;\n#if 1\nint lastIndexFromPrevPass = passId * maxKeypointsPerPass - 1;\nKeypointAddress lastAddressFromPrevPass = KeypointAddress(max(0, lastIndexFromPrevPass) * pixelsPerKeypoint, 0);\nKeypoint lastKeypointFromPrevPass = decodeKeypoint(encodedKeypoints, encoderLength, lastAddressFromPrevPass);\nivec2 position = ivec2(lastKeypointFromPrevPass.position);\n#else\nint lastIndexFromPrevPass = -1; ivec2 position = ivec2(0);\n#endif\nvec4 pixel;\ncolor = encodeNullKeypoint();\nif(q >= maxKeypoints || !findQthKeypoint(q, lastIndexFromPrevPass, position, pixel))\nreturn;\ncolor = (address.offset == 1) ? vec4(\npixel.g,\n0.0f,\npixel.r,\nencodeKeypointFlags(KPF_NONE)\n) : encodeKeypointPosition(\nvec2(position)\n);\n}'},function(e,t){e.exports='@include "keypoints.glsl"\nuniform sampler2D inputTexture;\nuniform int inputDescriptorSize;\nuniform int inputExtraSize;\nuniform int inputEncoderLength;\nuniform int outputDescriptorSize;\nuniform int outputExtraSize;\nuniform int outputEncoderLength;\nvoid main()\n{\nvec4 pixel = threadPixel(inputTexture);\nivec2 thread = threadLocation();\nKeypointAddress myAddress = findKeypointAddress(\nthread,\noutputEncoderLength,\noutputDescriptorSize,\noutputExtraSize\n);\nint myIndex = findKeypointIndex(\nmyAddress,\noutputDescriptorSize,\noutputExtraSize\n);\nint pixelsPerKeypoint = sizeofEncodedKeypoint(inputDescriptorSize, inputExtraSize) / 4;\nKeypointAddress otherAddress = KeypointAddress(\nmyIndex * pixelsPerKeypoint,\nmyAddress.offset\n);\nint head = MIN_KEYPOINT_SIZE / 4;\ncolor = (myAddress.offset >= head) ? vec4(0.0f) :\nreadKeypointData(inputTexture, inputEncoderLength, otherAddress);\n}'},function(e,t){e.exports='@include "keypoints.glsl"\nuniform int keypointCount;\nuniform int encoderLength;\nuniform int descriptorSize;\nuniform int extraSize;\n#ifndef KEYPOINT_BUFFER_LENGTH\n#error Must specify KEYPOINT_BUFFER_LENGTH\n#endif\nlayout(std140) uniform KeypointBuffer\n{\nvec4 keypointBuffer[KEYPOINT_BUFFER_LENGTH];\n};\nvoid main()\n{\nivec2 thread = threadLocation();\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nint q = findKeypointIndex(address, descriptorSize, extraSize);\ncolor = vec4(1.0f);\nif(q >= keypointCount)\nreturn;\nvec4 data = keypointBuffer[q];\nswitch(address.offset) {\ncase 0: {\nfixed2_t pos = vec2tofix(data.xy);\nfixed2_t lo = pos & 255;\nfixed2_t hi = pos >> 8;\ncolor = vec4(float(lo.x), float(hi.x), float(lo.y), float(hi.y)) / 255.0f;\nbreak;\n}\ncase 1: {\nfloat score = data.w;\nfloat scale = encodeLod(data.z);\nfloat rotation = encodeOrientation(0.0f);\ncolor = vec4(scale, rotation, score, 0.0f);\nbreak;\n}\ndefault: {\ncolor = vec4(0.0f);\nbreak;\n}\n}\n}'},function(e,t){e.exports="uniform sampler2D image;\nuniform sampler2D illuminationMap;\nuniform float gain;\nuniform float offset;\nuniform float decay;\nconst mat3 rgb2yuv = mat3(\n0.299f, -0.14713f, 0.615f,\n0.587f, -0.28886f, -0.51499f,\n0.114f, 0.436f, -0.10001f\n);\nconst mat3 yuv2rgb = mat3(\n1.0f, 1.0f, 1.0f,\n0.0f, -0.39465f, 2.03211f,\n1.13983f, -0.58060f, 0.0f\n);\nconst float eps = 0.0001f;\nconst float sqrt2 = 1.4142135623730951f;\nconst float magic = 20.0f;\nconst vec2 center = vec2(0.5f);\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nvec4 imapPixel = threadPixel(illuminationMap);\nfloat lambda = -sqrt2 * log(max(1.0f - decay, eps));\nfloat dist = length(texCoord - center);\nfloat vgain = gain * exp(-lambda * dist);\nfloat normalizedGain = 2.0f * vgain;\nfloat normalizedOffset = 2.0f * offset - 1.0f;\n#ifdef GREYSCALE\nfloat luma = 1.0 / (1.0 + exp(-normalizedGain * magic * (pixel.g - imapPixel.g)));\nluma = clamp(luma + normalizedOffset, 0.0f, 1.0f);\ncolor = vec4(luma, luma, luma, 1.0f);\n#else\nvec3 yuvPixel = rgb2yuv * pixel.rgb;\nvec3 yuvImapPixel = rgb2yuv * imapPixel.rgb;\nfloat luma = 1.0 / (1.0 + exp(-normalizedGain * magic * (yuvPixel.r - yuvImapPixel.r)));\nluma += normalizedOffset;\nvec3 rgbCorrectedPixel = yuv2rgb * vec3(luma, yuvPixel.gb);\nrgbCorrectedPixel = clamp(rgbCorrectedPixel, 0.0f, 1.0f);\ncolor = vec4(rgbCorrectedPixel, 1.0f);\n#endif\n}"},function(e,t){e.exports="#ifdef GREYSCALE\nuniform sampler2D minmax2d;\n#else\nuniform sampler2D minmax2dRGB[3];\n#endif\nuniform float minValue;\nuniform float maxValue;\nconst float eps = 1.0f / 255.0f;\nvoid main()\n{\nvec2 minmax = clamp(vec2(minValue, maxValue), 0.0f, 255.0f) / 255.0f;\nvec4 newMin = vec4(minmax.x);\nvec4 newRange = vec4(minmax.y - minmax.x);\nvec4 alpha = vec4(1.0f, newMin.x, newRange.x, 1.0f);\n#ifdef GREYSCALE\nvec4 pixel = threadPixel(minmax2d);\nmat4 channel = mat4(pixel, pixel, pixel, alpha);\n#else\nmat4 channel = mat4(\nthreadPixel(minmax2dRGB[0]),\nthreadPixel(minmax2dRGB[1]),\nthreadPixel(minmax2dRGB[2]),\nalpha\n);\n#endif\nvec4 oldMin = vec4(channel[0].g, channel[1].g, channel[2].g, channel[3].g);\nvec4 oldRange = max(vec4(channel[0].b, channel[1].b, channel[2].b, channel[3].b), eps);\nvec4 oldIntensity = vec4(channel[0].a, channel[1].a, channel[2].a, channel[3].a);\nvec4 newIntensity = (oldIntensity - oldMin) * newRange / oldRange + newMin;\ncolor = newIntensity;\n}"},function(e,t){e.exports="uniform sampler2D image;\n#define SORT(i, j) t = p[i] + p[j]; p[i] = min(p[i], p[j]); p[j] = t - p[i];\nvoid main()\n{\nfloat median, t;\n#if WINDOW_SIZE == 3\nfloat p[9];\np[0] = pixelAtShortOffset(image, ivec2(-1,-1)).g;\np[1] = pixelAtShortOffset(image, ivec2(0,-1)).g;\np[2] = pixelAtShortOffset(image, ivec2(1,-1)).g;\np[3] = pixelAtShortOffset(image, ivec2(-1,0)).g;\np[4] = pixelAtShortOffset(image, ivec2(0,0)).g;\np[5] = pixelAtShortOffset(image, ivec2(1,0)).g;\np[6] = pixelAtShortOffset(image, ivec2(-1,1)).g;\np[7] = pixelAtShortOffset(image, ivec2(0,1)).g;\np[8] = pixelAtShortOffset(image, ivec2(1,1)).g;\nSORT(1,2);\nSORT(4,5);\nSORT(7,8);\nSORT(0,1);\nSORT(3,4);\nSORT(6,7);\nSORT(1,2);\nSORT(4,5);\nSORT(7,8);\nSORT(0,3);\nSORT(5,8);\nSORT(4,7);\nSORT(3,6);\nSORT(1,4);\nSORT(2,5);\nSORT(4,7);\nSORT(4,2);\nSORT(6,4);\nSORT(4,2);\nmedian = p[4];\n#elif WINDOW_SIZE == 5\nfloat p[25];\np[0] = pixelAtShortOffset(image, ivec2(-2,-2)).g;\np[1] = pixelAtShortOffset(image, ivec2(-1,-2)).g;\np[2] = pixelAtShortOffset(image, ivec2(0,-2)).g;\np[3] = pixelAtShortOffset(image, ivec2(1,-2)).g;\np[4] = pixelAtShortOffset(image, ivec2(2,-2)).g;\np[5] = pixelAtShortOffset(image, ivec2(-2,-1)).g;\np[6] = pixelAtShortOffset(image, ivec2(-1,-1)).g;\np[7] = pixelAtShortOffset(image, ivec2(0,-1)).g;\np[8] = pixelAtShortOffset(image, ivec2(1,-1)).g;\np[9] = pixelAtShortOffset(image, ivec2(2,-1)).g;\np[10] = pixelAtShortOffset(image, ivec2(-2,0)).g;\np[11] = pixelAtShortOffset(image, ivec2(-1,0)).g;\np[12] = pixelAtShortOffset(image, ivec2(0,0)).g;\np[13] = pixelAtShortOffset(image, ivec2(1,0)).g;\np[14] = pixelAtShortOffset(image, ivec2(2,0)).g;\np[15] = pixelAtShortOffset(image, ivec2(-2,1)).g;\np[16] = pixelAtShortOffset(image, ivec2(-1,1)).g;\np[17] = pixelAtShortOffset(image, ivec2(0,1)).g;\np[18] = pixelAtShortOffset(image, ivec2(1,1)).g;\np[19] = pixelAtShortOffset(image, ivec2(2,1)).g;\np[20] = pixelAtShortOffset(image, ivec2(-2,2)).g;\np[21] = pixelAtShortOffset(image, ivec2(-1,2)).g;\np[22] = pixelAtShortOffset(image, ivec2(0,2)).g;\np[23] = pixelAtShortOffset(image, ivec2(1,2)).g;\np[24] = pixelAtShortOffset(image, ivec2(2,2)).g;\nSORT(0,1);\nSORT(3,4);\nSORT(2,4);\nSORT(2,3);\nSORT(6,7);\nSORT(5,7);\nSORT(5,6);\nSORT(9,10);\nSORT(8,10);\nSORT(8,9);\nSORT(12,13);\nSORT(11,13);\nSORT(11,12);\nSORT(15,16);\nSORT(14,16);\nSORT(14,15);\nSORT(18,19);\nSORT(17,19);\nSORT(17,18);\nSORT(21,22);\nSORT(20,22);\nSORT(20,21);\nSORT(23,24);\nSORT(2,5);\nSORT(3,6);\nSORT(0,6);\nSORT(0,3);\nSORT(4,7);\nSORT(1,7);\nSORT(1,4);\nSORT(11,14);\nSORT(8,14);\nSORT(8,11);\nSORT(12,15);\nSORT(9,15);\nSORT(9,12);\nSORT(13,16);\nSORT(10,16);\nSORT(10,13);\nSORT(20,23);\nSORT(17,23);\nSORT(17,20);\nSORT(21,24);\nSORT(18,24);\nSORT(18,21);\nSORT(19,22);\nSORT(8,17);\nSORT(9,18);\nSORT(0,18);\nSORT(0,9);\nSORT(10,19);\nSORT(1,19);\nSORT(1,10);\nSORT(11,20);\nSORT(2,20);\nSORT(2,11);\nSORT(12,21);\nSORT(3,21);\nSORT(3,12);\nSORT(13,22);\nSORT(4,22);\nSORT(4,13);\nSORT(14,23);\nSORT(5,23);\nSORT(5,14);\nSORT(15,24);\nSORT(6,24);\nSORT(6,15);\nSORT(7,16);\nSORT(7,19);\nSORT(13,21);\nSORT(15,23);\nSORT(7,13);\nSORT(7,15);\nSORT(1,9);\nSORT(3,11);\nSORT(5,17);\nSORT(11,17);\nSORT(9,17);\nSORT(4,10);\nSORT(6,12);\nSORT(7,14);\nSORT(4,6);\nSORT(4,7);\nSORT(12,14);\nSORT(10,14);\nSORT(6,7);\nSORT(10,12);\nSORT(6,10);\nSORT(6,17);\nSORT(12,17);\nSORT(7,17);\nSORT(7,10);\nSORT(12,18);\nSORT(7,12);\nSORT(10,18);\nSORT(12,20);\nSORT(10,20);\nSORT(10,12);\nmedian = p[12];\n#else\n#error Unsupported window size\n#endif\ncolor = vec4(median, median, median, 1.0f);\n}"},function(e,t){e.exports="uniform sampler2D image, layerA, layerB;\nuniform float scaleA, scaleB, lgM, h;\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nfloat score = pixel.r;\nivec2 zero = ivec2(0, 0);\nivec2 sizeA = textureSize(layerA, 0);\nivec2 sizeB = textureSize(layerB, 0);\nvec2 mid = (texCoord * texSize) + vec2(0.5f, 0.5f);\nivec2 pa = clamp(ivec2(ceil(mid * scaleA - 1.0f)), zero, sizeA - 2);\nivec2 pb = clamp(ivec2(ceil(mid * scaleB - 1.0f)), zero, sizeB - 2);\nvec4 a00 = pixelAt(layerA, pa);\nvec4 a10 = pixelAt(layerA, pa + ivec2(1, 0));\nvec4 a01 = pixelAt(layerA, pa + ivec2(0, 1));\nvec4 a11 = pixelAt(layerA, pa + ivec2(1, 1));\nvec4 b00 = pixelAt(layerB, pb);\nvec4 b10 = pixelAt(layerB, pb + ivec2(1, 0));\nvec4 b01 = pixelAt(layerB, pb + ivec2(0, 1));\nvec4 b11 = pixelAt(layerB, pb + ivec2(1, 1));\nfloat maxScore = max(\nmax(max(a00.r, a10.r), max(a01.r, a11.r)),\nmax(max(b00.r, b10.r), max(b01.r, b11.r))\n);\ncolor = vec4(0.0f, pixel.gba);\nif(score < maxScore || score == 0.0f)\nreturn;\nvec2 ea = fract(mid * scaleA);\nvec2 eb = fract(mid * scaleB);\nfloat isa = a00.b * (1.0f - ea.x) * (1.0f - ea.y) +\na10.b * ea.x * (1.0f - ea.y) +\na01.b * (1.0f - ea.x) * ea.y +\na11.b * ea.x * ea.y;\nfloat isb = b00.b * (1.0f - eb.x) * (1.0f - eb.y) +\nb10.b * eb.x * (1.0f - eb.y) +\nb01.b * (1.0f - eb.x) * eb.y +\nb11.b * eb.x * eb.y;\ncolor = (isa > score && isa > isb) ? vec4(isa, pixel.gb, a00.a) : pixel;\ncolor = (isb > score && isb > isa) ? vec4(isb, pixel.gb, b00.a) : pixel;\nfloat y1 = isa, y2 = isb, y3 = score;\nfloat x1 = lgM - (lgM + h) * a00.a;\nfloat x2 = lgM - (lgM + h) * b00.a;\nfloat x3 = lgM - (lgM + h) * pixel.a;\nfloat dn = (x1 - x2) * (x1 - x3) * (x2 - x3);\nif(abs(dn) < 0.00001f)\nreturn;\nfloat a = (x3 * (y2 - y1) + x2 * (y1 - y3) + x1 * (y3 - y2)) / dn;\nif(a >= 0.0f)\nreturn;\nfloat b = (x3 * x3 * (y1 - y2) + x2 * x2 * (y3 - y1) + x1 * x1 * (y2 - y3)) / dn;\nfloat c = (x2 * x3 * (x2 - x3) * y1 + x3 * x1 * (x3 - x1) * y2 + x1 * x2 * (x1 - x2) * y3) / dn;\nfloat xv = -b / (2.0f * a);\nfloat yv = c - (b * b) / (4.0f * a);\nif(xv < min(x1, min(x2, x3)) || xv > max(x1, max(x2, x3)))\nreturn;\nfloat interpolatedScale = (lgM - xv) / (lgM + h);\nfloat interpolatedScore = clamp(yv, 0.0f, 1.0f);\ncolor = vec4(interpolatedScore, pixel.gb, interpolatedScale);\n}"},function(e,t){e.exports='@include "float16.glsl"\nuniform sampler2D image;\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nfloat score = decodeFloat16(pixel.rb);\nconst float mul = 6.0f;\nfloat score8 = clamp(score * mul, 0.0f, 1.0f);\ncolor = vec4(score8, pixel.g, 0.0f, pixel.a);\n}'},function(e,t){e.exports='@include "float16.glsl"\nuniform sampler2D image;\nuniform float threshold;\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nfloat t = clamp(threshold, 0.0f, 1.0f);\nfloat ct = pixel.g + t, c_t = pixel.g - t;\nfloat p0 = pixelAtShortOffset(image, ivec2(0, 2)).g;\nfloat p1 = pixelAtShortOffset(image, ivec2(1, 2)).g;\nfloat p2 = pixelAtShortOffset(image, ivec2(2, 1)).g;\nfloat p3 = pixelAtShortOffset(image, ivec2(2, 0)).g;\nfloat p4 = pixelAtShortOffset(image, ivec2(2, -1)).g;\nfloat p5 = pixelAtShortOffset(image, ivec2(1, -2)).g;\nfloat p6 = pixelAtShortOffset(image, ivec2(0, -2)).g;\nfloat p7 = pixelAtShortOffset(image, ivec2(-1, -2)).g;\nfloat p8 = pixelAtShortOffset(image, ivec2(-2, -1)).g;\nfloat p9 = pixelAtShortOffset(image, ivec2(-2, 0)).g;\nfloat p10 = pixelAtShortOffset(image, ivec2(-2, 1)).g;\nfloat p11 = pixelAtShortOffset(image, ivec2(-1, 2)).g;\nvec2 scores = vec2(0.0f, 0.0f);\nscores += vec2(max(c_t - p0, 0.0f), max(p0 - ct, 0.0f));\nscores += vec2(max(c_t - p1, 0.0f), max(p1 - ct, 0.0f));\nscores += vec2(max(c_t - p2, 0.0f), max(p2 - ct, 0.0f));\nscores += vec2(max(c_t - p3, 0.0f), max(p3 - ct, 0.0f));\nscores += vec2(max(c_t - p4, 0.0f), max(p4 - ct, 0.0f));\nscores += vec2(max(c_t - p5, 0.0f), max(p5 - ct, 0.0f));\nscores += vec2(max(c_t - p6, 0.0f), max(p6 - ct, 0.0f));\nscores += vec2(max(c_t - p7, 0.0f), max(p7 - ct, 0.0f));\nscores += vec2(max(c_t - p8, 0.0f), max(p8 - ct, 0.0f));\nscores += vec2(max(c_t - p9, 0.0f), max(p9 - ct, 0.0f));\nscores += vec2(max(c_t - p10, 0.0f), max(p10 - ct, 0.0f));\nscores += vec2(max(c_t - p11, 0.0f), max(p11 - ct, 0.0f));\nscores /= 12.0f;\nfloat score = max(scores.x, scores.y) * step(1.0f, pixel.r);\ncolor = pixel;\ncolor.rb = encodeFloat16(score);\n}'},function(e,t){e.exports='@include "float16.glsl"\nuniform sampler2D image;\nuniform float threshold;\nconst vec4 zeroes = vec4(0.0f, 0.0f, 0.0f, 0.0f);\nconst vec4 ones = vec4(1.0f, 1.0f, 1.0f, 1.0f);\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nfloat t = clamp(threshold, 0.0f, 1.0f);\nfloat ct = pixel.g + t, c_t = pixel.g - t;\nmat4 mp = mat4(\npixelAtShortOffset(image, ivec2(0, 3)).g,\npixelAtShortOffset(image, ivec2(1, 3)).g,\npixelAtShortOffset(image, ivec2(2, 2)).g,\npixelAtShortOffset(image, ivec2(3, 1)).g,\npixelAtShortOffset(image, ivec2(3, 0)).g,\npixelAtShortOffset(image, ivec2(3, -1)).g,\npixelAtShortOffset(image, ivec2(2, -2)).g,\npixelAtShortOffset(image, ivec2(1, -3)).g,\npixelAtShortOffset(image, ivec2(0, -3)).g,\npixelAtShortOffset(image, ivec2(-1, -3)).g,\npixelAtShortOffset(image, ivec2(-2, -2)).g,\npixelAtShortOffset(image, ivec2(-3, -1)).g,\npixelAtShortOffset(image, ivec2(-3, 0)).g,\npixelAtShortOffset(image, ivec2(-3, 1)).g,\npixelAtShortOffset(image, ivec2(-2, 2)).g,\npixelAtShortOffset(image, ivec2(-1, 3)).g\n);\nmat4 mct = mp - mat4(\nct, ct, ct, ct,\nct, ct, ct, ct,\nct, ct, ct, ct,\nct, ct, ct, ct\n), mc_t = mat4(\nc_t, c_t, c_t, c_t,\nc_t, c_t, c_t, c_t,\nc_t, c_t, c_t, c_t,\nc_t, c_t, c_t, c_t\n) - mp;\nvec4 bs = max(mc_t[0], zeroes), ds = max(mct[0], zeroes);\nbs += max(mc_t[1], zeroes); ds += max(mct[1], zeroes);\nbs += max(mc_t[2], zeroes); ds += max(mct[2], zeroes);\nbs += max(mc_t[3], zeroes); ds += max(mct[3], zeroes);\nfloat score = max(dot(bs, ones), dot(ds, ones)) * step(1.0f, pixel.r);\nscore /= 16.0f;\ncolor = pixel;\ncolor.rb = encodeFloat16(score);\n}'},function(e,t){e.exports='@include "float16.glsl"\nuniform sampler2D image;\nuniform float threshold;\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nfloat t = clamp(threshold, 0.0f, 1.0f);\nfloat ct = pixel.g + t, c_t = pixel.g - t;\nfloat p0 = pixelAtShortOffset(image, ivec2(0, 1)).g;\nfloat p1 = pixelAtShortOffset(image, ivec2(1, 1)).g;\nfloat p2 = pixelAtShortOffset(image, ivec2(1, 0)).g;\nfloat p3 = pixelAtShortOffset(image, ivec2(1, -1)).g;\nfloat p4 = pixelAtShortOffset(image, ivec2(0, -1)).g;\nfloat p5 = pixelAtShortOffset(image, ivec2(-1, -1)).g;\nfloat p6 = pixelAtShortOffset(image, ivec2(-1, 0)).g;\nfloat p7 = pixelAtShortOffset(image, ivec2(-1, 1)).g;\nvec2 scores = vec2(0.0f, 0.0f);\nscores += vec2(max(c_t - p0, 0.0f), max(p0 - ct, 0.0f));\nscores += vec2(max(c_t - p1, 0.0f), max(p1 - ct, 0.0f));\nscores += vec2(max(c_t - p2, 0.0f), max(p2 - ct, 0.0f));\nscores += vec2(max(c_t - p3, 0.0f), max(p3 - ct, 0.0f));\nscores += vec2(max(c_t - p4, 0.0f), max(p4 - ct, 0.0f));\nscores += vec2(max(c_t - p5, 0.0f), max(p5 - ct, 0.0f));\nscores += vec2(max(c_t - p6, 0.0f), max(p6 - ct, 0.0f));\nscores += vec2(max(c_t - p7, 0.0f), max(p7 - ct, 0.0f));\nscores /= 8.0f;\nfloat score = max(scores.x, scores.y) * step(1.0f, pixel.r);\ncolor = pixel;\ncolor.rb = encodeFloat16(score);\n}'},function(e,t){e.exports='@include "pyramids.glsl"\nuniform sampler2D image;\nuniform float threshold;\nvoid main()\n{\nivec2 thread = threadLocation();\nivec2 size = outputSize();\nvec4 pixel = threadPixel(image);\ncolor = vec4(0.0f, pixel.g, 0.0f, encodeLod(0.0f));\nif(\nthread.x >= 3 && thread.x < size.x - 3 &&\nthread.y >= 3 && thread.y < size.y - 3\n) {\nfloat t = clamp(threshold, 0.0f, 1.0f);\nfloat c = pixel.g;\nfloat ct = c + t, c_t = c - t;\nfloat p0 = pixelAtShortOffset(image, ivec2(0, 1)).g;\nfloat p1 = pixelAtShortOffset(image, ivec2(1, 1)).g;\nfloat p2 = pixelAtShortOffset(image, ivec2(1, 0)).g;\nfloat p3 = pixelAtShortOffset(image, ivec2(1, -1)).g;\nfloat p4 = pixelAtShortOffset(image, ivec2(0, -1)).g;\nfloat p5 = pixelAtShortOffset(image, ivec2(-1, -1)).g;\nfloat p6 = pixelAtShortOffset(image, ivec2(-1, 0)).g;\nfloat p7 = pixelAtShortOffset(image, ivec2(-1, 1)).g;\nbool possibleCorner =\n((c_t > p1 || c_t > p5) && (c_t > p3 || c_t > p7)) ||\n((ct < p1  || ct < p5)  && (ct < p3  || ct < p7))  ;\nif(possibleCorner) {\nint bright = 0, dark = 0, bc = 0, dc = 0;\nif(c_t > p0) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p0) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p1) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p1) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p2) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p2) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p3) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p3) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p4) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p4) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p5) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p5) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p6) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p6) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p7) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p7) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(bright < 5 && dark < 5) {\nif(bc > 0 && bc < 5) do {\nif(c_t > p0)           bc += 1; else break;\nif(c_t > p1 && bc < 5) bc += 1; else break;\nif(c_t > p2 && bc < 5) bc += 1; else break;\nif(c_t > p3 && bc < 5) bc += 1; else break;\n} while(false);\nif(dc > 0 && dc < 5) do {\nif(ct < p0)           dc += 1; else break;\nif(ct < p1 && dc < 5) dc += 1; else break;\nif(ct < p2 && dc < 5) dc += 1; else break;\nif(ct < p3 && dc < 5) dc += 1; else break;\n} while(false);\nif(bc >= 5 || dc >= 5)\ncolor.r = 1.0f;\n}\nelse {\ncolor.r = 1.0f;\n}\n}\n}\n}'},function(e,t){e.exports='@include "pyramids.glsl"\nuniform sampler2D image;\nuniform float threshold;\nvoid main()\n{\nivec2 thread = threadLocation();\nivec2 size = outputSize();\nvec4 pixel = threadPixel(image);\ncolor = vec4(0.0f, pixel.g, 0.0f, encodeLod(0.0f));\nif(\nthread.x >= 3 && thread.x < size.x - 3 &&\nthread.y >= 3 && thread.y < size.y - 3\n) {\nfloat t = clamp(threshold, 0.0f, 1.0f);\nfloat c = pixel.g;\nfloat ct = c + t, c_t = c - t;\nfloat p0 = pixelAtShortOffset(image, ivec2(0, 2)).g;\nfloat p1 = pixelAtShortOffset(image, ivec2(1, 2)).g;\nfloat p2 = pixelAtShortOffset(image, ivec2(2, 1)).g;\nfloat p3 = pixelAtShortOffset(image, ivec2(2, 0)).g;\nfloat p4 = pixelAtShortOffset(image, ivec2(2, -1)).g;\nfloat p5 = pixelAtShortOffset(image, ivec2(1, -2)).g;\nfloat p6 = pixelAtShortOffset(image, ivec2(0, -2)).g;\nfloat p7 = pixelAtShortOffset(image, ivec2(-1, -2)).g;\nfloat p8 = pixelAtShortOffset(image, ivec2(-2, -1)).g;\nfloat p9 = pixelAtShortOffset(image, ivec2(-2, 0)).g;\nfloat p10 = pixelAtShortOffset(image, ivec2(-2, 1)).g;\nfloat p11 = pixelAtShortOffset(image, ivec2(-1, 2)).g;\nbool possibleCorner =\n((c_t > p0 || c_t > p6) && (c_t > p3 || c_t > p9)) ||\n((ct < p0  || ct < p6)  && (ct < p3  || ct < p9))  ;\nif(possibleCorner) {\nint bright = 0, dark = 0, bc = 0, dc = 0;\nif(c_t > p0) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p0) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p1) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p1) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p2) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p2) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p3) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p3) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p4) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p4) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p5) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p5) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p6) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p6) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p7) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p7) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p8) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p8) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p9) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p9) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p10) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p10) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p11) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p11) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(bright < 7 && dark < 7) {\nif(bc > 0 && bc < 7) do {\nif(c_t > p0)           bc += 1; else break;\nif(c_t > p1 && bc < 7) bc += 1; else break;\nif(c_t > p2 && bc < 7) bc += 1; else break;\nif(c_t > p3 && bc < 7) bc += 1; else break;\nif(c_t > p4 && bc < 7) bc += 1; else break;\nif(c_t > p5 && bc < 7) bc += 1; else break;\n} while(false);\nif(dc > 0 && dc < 7) do {\nif(ct < p0)           dc += 1; else break;\nif(ct < p1 && dc < 7) dc += 1; else break;\nif(ct < p2 && dc < 7) dc += 1; else break;\nif(ct < p3 && dc < 7) dc += 1; else break;\nif(ct < p4 && dc < 7) dc += 1; else break;\nif(ct < p5 && dc < 7) dc += 1; else break;\n} while(false);\nif(bc >= 7 || dc >= 7)\ncolor.r = 1.0f;\n}\nelse {\ncolor.r = 1.0f;\n}\n}\n}\n}'},function(e,t){e.exports='@include "pyramids.glsl"\nuniform sampler2D image;\nuniform float threshold;\nconst ivec4 margin = ivec4(3, 3, 4, 4);\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nivec2 thread = threadLocation();\nivec2 size = outputSize();\ncolor = vec4(0.0f, pixel.g, 0.0f, encodeLod(0.0f));\nif(any(lessThan(ivec4(thread, size - thread), margin)))\nreturn;\nfloat t = clamp(threshold, 0.0f, 1.0f);\nfloat ct = pixel.g + t, c_t = pixel.g - t;\nfloat p0 = pixelAtShortOffset(image, ivec2(0, 3)).g;\nfloat p4 = pixelAtShortOffset(image, ivec2(3, 0)).g;\nfloat p8 = pixelAtShortOffset(image, ivec2(0, -3)).g;\nfloat p12 = pixelAtShortOffset(image, ivec2(-3, 0)).g;\nif(!(\n((c_t > p0 || c_t > p8) && (c_t > p4 || c_t > p12)) ||\n((ct < p0  || ct < p8)  && (ct < p4  || ct < p12))\n))\nreturn;\nfloat p1 = pixelAtShortOffset(image, ivec2(1, 3)).g;\nfloat p2 = pixelAtShortOffset(image, ivec2(2, 2)).g;\nfloat p3 = pixelAtShortOffset(image, ivec2(3, 1)).g;\nfloat p5 = pixelAtShortOffset(image, ivec2(3, -1)).g;\nfloat p6 = pixelAtShortOffset(image, ivec2(2, -2)).g;\nfloat p7 = pixelAtShortOffset(image, ivec2(1, -3)).g;\nfloat p9 = pixelAtShortOffset(image, ivec2(-1, -3)).g;\nfloat p10 = pixelAtShortOffset(image, ivec2(-2, -2)).g;\nfloat p11 = pixelAtShortOffset(image, ivec2(-3, -1)).g;\nfloat p13 = pixelAtShortOffset(image, ivec2(-3, 1)).g;\nfloat p14 = pixelAtShortOffset(image, ivec2(-2, 2)).g;\nfloat p15 = pixelAtShortOffset(image, ivec2(-1, 3)).g;\nbool A=(p0>ct),B=(p1>ct),C=(p2>ct),D=(p3>ct),E=(p4>ct),F=(p5>ct),G=(p6>ct),H=(p7>ct),I=(p8>ct),J=(p9>ct),K=(p10>ct),L=(p11>ct),M=(p12>ct),N=(p13>ct),O=(p14>ct),P=(p15>ct),a=(p0<c_t),b=(p1<c_t),c=(p2<c_t),d=(p3<c_t),e=(p4<c_t),f=(p5<c_t),g=(p6<c_t),h=(p7<c_t),i=(p8<c_t),j=(p9<c_t),k=(p10<c_t),l=(p11<c_t),m=(p12<c_t),n=(p13<c_t),o=(p14<c_t),p=(p15<c_t);\nbool isCorner=A&&(B&&(K&&L&&J&&(M&&N&&O&&P||G&&H&&I&&(M&&N&&O||F&&(M&&N||E&&(M||D))))||C&&(K&&L&&M&&(N&&O&&P||G&&H&&I&&J&&(N&&O||F&&(N||E)))||D&&(N&&(L&&M&&(K&&G&&H&&I&&J&&(O||F)||O&&P)||k&&l&&m&&e&&f&&g&&h&&i&&j)||E&&(O&&(M&&N&&(K&&L&&G&&H&&I&&J||P)||k&&l&&m&&n&&f&&g&&h&&i&&j)||F&&(P&&(N&&O||k&&l&&m&&n&&o&&g&&h&&i&&j)||G&&(O&&P||H&&(P||I)||k&&l&&m&&n&&o&&p&&h&&i&&j)||k&&l&&m&&n&&o&&h&&i&&j&&(p||g))||k&&l&&m&&n&&h&&i&&j&&(o&&(p||g)||f&&(o&&p||g)))||k&&l&&m&&h&&i&&j&&(n&&(o&&p||g&&(o||f))||e&&(n&&o&&p||g&&(n&&o||f))))||k&&l&&h&&i&&j&&(m&&(n&&o&&p||g&&(n&&o||f&&(n||e)))||d&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e)))))||k&&h&&i&&j&&(l&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d))))))||K&&I&&J&&(L&&M&&N&&O&&P||G&&H&&(L&&M&&N&&O||F&&(L&&M&&N||E&&(L&&M||D&&(L||C)))))||h&&i&&j&&(b&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c)))))||k&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c)))))))||B&&(H&&I&&J&&(K&&L&&M&&N&&O&&P&&a||G&&(K&&L&&M&&N&&O&&a||F&&(K&&L&&M&&N&&a||E&&(K&&L&&M&&a||D&&(K&&L&&a||C)))))||a&&k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||C&&(K&&H&&I&&J&&(L&&M&&N&&O&&P&&a&&b||G&&(L&&M&&N&&O&&a&&b||F&&(L&&M&&N&&a&&b||E&&(L&&M&&a&&b||D))))||a&&b&&k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d)))))||D&&(K&&L&&H&&I&&J&&(M&&N&&O&&P&&a&&b&&c||G&&(M&&N&&O&&a&&b&&c||F&&(M&&N&&a&&b&&c||E)))||a&&b&&k&&l&&m&&c&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e))))||E&&(K&&L&&M&&H&&I&&J&&(N&&O&&P&&a&&b&&c&&d||G&&(N&&O&&a&&b&&c&&d||F))||a&&b&&l&&m&&n&&c&&d&&(k&&g&&h&&i&&j&&(o||f)||o&&p))||F&&(K&&L&&M&&N&&H&&I&&J&&(O&&P&&a&&b&&c&&d&&e||G)||a&&b&&m&&n&&o&&c&&d&&e&&(k&&l&&g&&h&&i&&j||p))||G&&(K&&L&&M&&N&&O&&H&&I&&J||a&&b&&n&&o&&p&&c&&d&&e&&f)||H&&(K&&L&&M&&N&&O&&P&&I&&J||a&&b&&o&&p&&c&&d&&e&&f&&g)||a&&(b&&(k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(k&&l&&m&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e)))||d&&(l&&m&&n&&(k&&g&&h&&i&&j&&(o||f)||o&&p)||e&&(m&&n&&o&&(k&&l&&g&&h&&i&&j||p)||f&&(n&&o&&p||g&&(o&&p||h&&(p||i)))))))||k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||h&&i&&j&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c&&(b||k))))));\ncolor.r = float(isCorner);\n}'},function(e,t){e.exports='@include "pyramids.glsl"\n@include "float16.glsl"\nuniform sampler2D pyramid;\nuniform float threshold;\nuniform int numberOfOctaves;\nuniform float lodStep;\nconst ivec4 margin = ivec4(3, 3, 4, 4);\nconst vec4 zeroes = vec4(0.0f, 0.0f, 0.0f, 0.0f);\nconst vec4 ones = vec4(1.0f, 1.0f, 1.0f, 1.0f);\nvoid main()\n{\nvec4 pixel = threadPixel(pyramid);\nivec2 thread = threadLocation();\nivec2 size = outputSize();\nfloat t = clamp(threshold, 0.0f, 1.0f);\nfloat ct = pixel.g + t, c_t = pixel.g - t;\nvec2 best = vec2(0.0f);\ncolor = vec4(0.0f, pixel.g, 0.0f, pixel.a);\nfloat lod = 0.0f, pot = 1.0f;\nfor(int octave = 0; octave < numberOfOctaves; octave++) {\npixel = pyrPixel(pyramid, lod);\nct = pixel.g + t;\nc_t = pixel.g - t;\nvec4 p4k = vec4(\npyrPixelAtOffset(pyramid, lod, pot, ivec2(0, 3)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(3, 0)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(0, -3)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-3, 0)).g\n);\nmat4 mp = mat4(\np4k.x,\np4k.y,\np4k.z,\np4k.w,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(1, 3)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(3, -1)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-1, -3)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-3, 1)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(2, 2)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(2, -2)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-2, -2)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-2, 2)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(3, 1)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(1, -3)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-3, -1)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-1, 3)).g\n);\nbool A=(mp[0][0]>ct),B=(mp[1][0]>ct),C=(mp[2][0]>ct),D=(mp[3][0]>ct),E=(mp[0][1]>ct),F=(mp[1][1]>ct),G=(mp[2][1]>ct),H=(mp[3][1]>ct),I=(mp[0][2]>ct),J=(mp[1][2]>ct),K=(mp[2][2]>ct),L=(mp[3][2]>ct),M=(mp[0][3]>ct),N=(mp[1][3]>ct),O=(mp[2][3]>ct),P=(mp[3][3]>ct),a=(mp[0][0]<c_t),b=(mp[1][0]<c_t),c=(mp[2][0]<c_t),d=(mp[3][0]<c_t),e=(mp[0][1]<c_t),f=(mp[1][1]<c_t),g=(mp[2][1]<c_t),h=(mp[3][1]<c_t),i=(mp[0][2]<c_t),j=(mp[1][2]<c_t),k=(mp[2][2]<c_t),l=(mp[3][2]<c_t),m=(mp[0][3]<c_t),n=(mp[1][3]<c_t),o=(mp[2][3]<c_t),p=(mp[3][3]<c_t);\nbool isCorner=A&&(B&&(K&&L&&J&&(M&&N&&O&&P||G&&H&&I&&(M&&N&&O||F&&(M&&N||E&&(M||D))))||C&&(K&&L&&M&&(N&&O&&P||G&&H&&I&&J&&(N&&O||F&&(N||E)))||D&&(N&&(L&&M&&(K&&G&&H&&I&&J&&(O||F)||O&&P)||k&&l&&m&&e&&f&&g&&h&&i&&j)||E&&(O&&(M&&N&&(K&&L&&G&&H&&I&&J||P)||k&&l&&m&&n&&f&&g&&h&&i&&j)||F&&(P&&(N&&O||k&&l&&m&&n&&o&&g&&h&&i&&j)||G&&(O&&P||H&&(P||I)||k&&l&&m&&n&&o&&p&&h&&i&&j)||k&&l&&m&&n&&o&&h&&i&&j&&(p||g))||k&&l&&m&&n&&h&&i&&j&&(o&&(p||g)||f&&(o&&p||g)))||k&&l&&m&&h&&i&&j&&(n&&(o&&p||g&&(o||f))||e&&(n&&o&&p||g&&(n&&o||f))))||k&&l&&h&&i&&j&&(m&&(n&&o&&p||g&&(n&&o||f&&(n||e)))||d&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e)))))||k&&h&&i&&j&&(l&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d))))))||K&&I&&J&&(L&&M&&N&&O&&P||G&&H&&(L&&M&&N&&O||F&&(L&&M&&N||E&&(L&&M||D&&(L||C)))))||h&&i&&j&&(b&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c)))))||k&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c)))))))||B&&(H&&I&&J&&(K&&L&&M&&N&&O&&P&&a||G&&(K&&L&&M&&N&&O&&a||F&&(K&&L&&M&&N&&a||E&&(K&&L&&M&&a||D&&(K&&L&&a||C)))))||a&&k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||C&&(K&&H&&I&&J&&(L&&M&&N&&O&&P&&a&&b||G&&(L&&M&&N&&O&&a&&b||F&&(L&&M&&N&&a&&b||E&&(L&&M&&a&&b||D))))||a&&b&&k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d)))))||D&&(K&&L&&H&&I&&J&&(M&&N&&O&&P&&a&&b&&c||G&&(M&&N&&O&&a&&b&&c||F&&(M&&N&&a&&b&&c||E)))||a&&b&&k&&l&&m&&c&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e))))||E&&(K&&L&&M&&H&&I&&J&&(N&&O&&P&&a&&b&&c&&d||G&&(N&&O&&a&&b&&c&&d||F))||a&&b&&l&&m&&n&&c&&d&&(k&&g&&h&&i&&j&&(o||f)||o&&p))||F&&(K&&L&&M&&N&&H&&I&&J&&(O&&P&&a&&b&&c&&d&&e||G)||a&&b&&m&&n&&o&&c&&d&&e&&(k&&l&&g&&h&&i&&j||p))||G&&(K&&L&&M&&N&&O&&H&&I&&J||a&&b&&n&&o&&p&&c&&d&&e&&f)||H&&(K&&L&&M&&N&&O&&P&&I&&J||a&&b&&o&&p&&c&&d&&e&&f&&g)||a&&(b&&(k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(k&&l&&m&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e)))||d&&(l&&m&&n&&(k&&g&&h&&i&&j&&(o||f)||o&&p)||e&&(m&&n&&o&&(k&&l&&g&&h&&i&&j||p)||f&&(n&&o&&p||g&&(o&&p||h&&(p||i)))))))||k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||h&&i&&j&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c&&(b||k))))));\nmat4 mct = mp - mat4(\nct, ct, ct, ct,\nct, ct, ct, ct,\nct, ct, ct, ct,\nct, ct, ct, ct\n), mc_t = mat4(\nc_t, c_t, c_t, c_t,\nc_t, c_t, c_t, c_t,\nc_t, c_t, c_t, c_t,\nc_t, c_t, c_t, c_t\n) - mp;\nvec4 bs = max(mc_t[0], zeroes), ds = max(mct[0], zeroes);\nbs += max(mc_t[1], zeroes); ds += max(mct[1], zeroes);\nbs += max(mc_t[2], zeroes); ds += max(mct[2], zeroes);\nbs += max(mc_t[3], zeroes); ds += max(mct[3], zeroes);\nfloat score = max(dot(bs, ones), dot(ds, ones)) / 16.0f;\nscore *= float(isCorner);\nbest = (score > best.x) ? vec2(score, lod) : best;\nlod += lodStep;\npot = exp2(lod);\n}\ncolor.rb = encodeFloat16(best.x);\ncolor.a = encodeLod(best.y);\n}'},function(e,t){e.exports='@include "float16.glsl"\nuniform sampler2D image;\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nfloat score = decodeFloat16(pixel.rb);\nfloat score8 = 1.0f - exp2(-score);\ncolor = vec4(score8, pixel.g, 0.0f, pixel.a);\n}'},function(e,t){e.exports='@include "float16.glsl"\nuniform sampler2D corners;\nuniform sampler2D maxScore;\nuniform float quality;\nvoid main()\n{\nvec4 pixel = threadPixel(corners);\nfloat maxval = decodeFloat16(threadPixel(maxScore).rb);\nfloat score = decodeFloat16(pixel.rb);\nfloat threshold = maxval * clamp(quality, 0.0f, 1.0f);\nscore *= step(threshold, score);\ncolor = pixel;\ncolor.rb = encodeFloat16(score);\n}'},function(e,t){e.exports='@include "float16.glsl"\nuniform sampler2D self;\nuniform int iterationNumber;\nvoid main()\n{\nivec2 thread = threadLocation();\nivec2 last = outputSize() - ivec2(1);\nint jump = (1 << iterationNumber);\nint clusterLength = jump << 1;\nint clusterMask = clusterLength - 1;\nivec2 clusterPos = ivec2(thread >> (1 + iterationNumber)) << (1 + iterationNumber);\nivec2 next1 = clusterPos + ((thread - clusterPos + ivec2(jump, 0)) & clusterMask);\nivec2 next2 = clusterPos + ((thread - clusterPos + ivec2(0, jump)) & clusterMask);\nivec2 next3 = clusterPos + ((thread - clusterPos + ivec2(jump, jump)) & clusterMask);\nvec4 p0 = texelFetch(self, thread, 0);\nvec4 p1 = texelFetch(self, min(next1, last), 0);\nvec4 p2 = texelFetch(self, min(next2, last), 0);\nvec4 p3 = texelFetch(self, min(next3, last), 0);\nfloat s0 = decodeFloat16(p0.rb);\nfloat s1 = decodeFloat16(p1.rb);\nfloat s2 = decodeFloat16(p2.rb);\nfloat s3 = decodeFloat16(p3.rb);\nbool b0 = s0 >= s1 && s0 >= s2 && s0 >= s3;\nbool b1 = s1 >= s0 && s1 >= s2 && s1 >= s3;\nbool b2 = s2 >= s0 && s2 >= s1 && s2 >= s3;\ncolor = vec4(0.0f);\ncolor.rb = b0 ? p0.rb : (\nb1 ? p1.rb : (\nb2 ? p2.rb : p3.rb\n)\n);\n}'},function(e,t){e.exports='@include "sobel.glsl"\n@include "pyramids.glsl"\n@include "float16.glsl"\nuniform sampler2D pyramid;\nuniform int windowSize;\nuniform int numberOfOctaves;\nuniform float lodStep;\nuniform sampler2D sobelDerivatives[@PYRAMID_MAX_OCTAVES@];\nvec4 pickSobelDerivatives(int index, ivec2 offset)\n{\n#define MAX_OCTAVES @PYRAMID_MAX_OCTAVES@\n#define CASE(k) case k: return textureLod(sobelDerivatives[k], texCoord + vec2(offset) / texSize, 0.0f)\n#if MAX_OCTAVES < 7 || MAX_OCTAVES > 16 || MAX_OCTAVES % 2 == 0\n#error MAX_OCTAVES cannot be @PYRAMID_MAX_OCTAVES@\n#endif\nswitch(index) {\n#if MAX_OCTAVES > 15\nCASE(15);\n#elif MAX_OCTAVES > 13\nCASE(14); CASE(13);\n#elif MAX_OCTAVES > 11\nCASE(12); CASE(11);\n#elif MAX_OCTAVES > 9\nCASE(10); CASE(9);\n#elif MAX_OCTAVES > 7\nCASE(8); CASE(7);\n#endif\nCASE(6); CASE(5); CASE(4); CASE(3); CASE(2); CASE(1); CASE(0);\ndefault: return vec4(0.0f);\n}\n}\nvoid main()\n{\nivec2 thread = threadLocation();\nvec4 pixel = threadPixel(pyramid);\nint r = (windowSize - 1) / 2;\nfloat windowArea = float(windowSize * windowSize);\nvec2 tmp = vec2(0.0f);\nfor(int octave = 0; octave < numberOfOctaves; octave++) {\nvec3 m = vec3(0.0f); vec2 df;\nfor(int j = 0; j < windowSize; j++) {\nfor(int i = 0; i < windowSize; i++) {\ndf = decodeSobel(pickSobelDerivatives(octave, ivec2(i-r, j-r)));\nm += vec3(df.x * df.x, df.x * df.y, df.y * df.y);\n}\n}\nfloat response = 0.5f * (m.x + m.z - sqrt((m.x - m.z) * (m.x - m.z) + 4.0f * m.y * m.y));\nfloat normalizer = 9.0f / windowArea;\nfloat score = response * normalizer;\nfloat lod = lodStep * float(octave);\ntmp = mix(tmp, vec2(score, lod), bvec2(score > tmp.x));\n}\nvec2 encodedScore = encodeFloat16(tmp.x);\nfloat encodedScale = encodeLod(tmp.y);\ncolor = vec4(0.0f, pixel.g, 0.0f, encodedScale);\ncolor.rb = encodedScore;\n}'},function(e,t){e.exports='@include "sobel.glsl"\n@include "pyramids.glsl"\nuniform sampler2D pyramid;\nuniform float lod;\nconst mat3 horizontalKernel = mat3(\n-1.0f, 0.0f, 1.0f,\n-2.0f, 0.0f, 2.0f,\n-1.0f, 0.0f, 1.0f\n);\nconst mat3 verticalKernel = mat3(\n1.0f, 2.0f, 1.0f,\n0.0f, 0.0f, 0.0f,\n-1.0f,-2.0f,-1.0f\n);\nconst vec3 ones = vec3(1.0f, 1.0f, 1.0f);\nvoid main()\n{\nfloat pot = exp2(lod);\nmat3 neighbors = mat3(\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-1, -1)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(0, -1)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(1, -1)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-1, 0)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(0, 0)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(1, 0)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-1, 1)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(0, 1)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(1, 1)).g\n);\nmat3 sobelX = matrixCompMult(horizontalKernel, neighbors);\nmat3 sobelY = matrixCompMult(verticalKernel, neighbors);\nvec2 df = vec2(\ndot(sobelX[0] + sobelX[1] + sobelX[2], ones),\ndot(sobelY[0] + sobelY[1] + sobelY[2], ones)\n);\ncolor = encodeSobel(df);\n}'},function(e,t){e.exports='@include "pyramids.glsl"\n@include "float16.glsl"\nuniform sampler2D image;\nuniform float lodStep;\n#if defined(MULTISCALE) && MULTISCALE != 0\n# define ENABLE_INNER_RING\n# define ENABLE_MIDDLE_RING\n# define ENABLE_OUTER_RING\n# define LOD_STEP (lodStep)\n#else\n# define ENABLE_INNER_RING\n# define LOD_STEP (0.0f)\n#endif\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nfloat lod = decodeLod(pixel.a);\nfloat score = decodeFloat16(pixel.rb);\ncolor = pixel;\nif(score == 0.0f)\nreturn;\n#ifdef ENABLE_INNER_RING\nvec4 p0 = pixelAtShortOffset(image, ivec2(0, 1));\nvec4 p1 = pixelAtShortOffset(image, ivec2(1, 1));\nvec4 p2 = pixelAtShortOffset(image, ivec2(1, 0));\nvec4 p3 = pixelAtShortOffset(image, ivec2(1, -1));\nvec4 p4 = pixelAtShortOffset(image, ivec2(0, -1));\nvec4 p5 = pixelAtShortOffset(image, ivec2(-1, -1));\nvec4 p6 = pixelAtShortOffset(image, ivec2(-1, 0));\nvec4 p7 = pixelAtShortOffset(image, ivec2(-1, 1));\n#else\nvec4 p0, p1, p2, p3, p4, p5, p6, p7;\np0 = p1 = p2 = p3 = p4 = p5 = p6 = p7 = vec4(0.0f);\n#endif\n#ifdef ENABLE_MIDDLE_RING\nvec4 q0 = pixelAtShortOffset(image, ivec2(0, 2));\nvec4 q1 = pixelAtShortOffset(image, ivec2(1, 2));\nvec4 q2 = pixelAtShortOffset(image, ivec2(2, 2));\nvec4 q3 = pixelAtShortOffset(image, ivec2(2, 1));\nvec4 q4 = pixelAtShortOffset(image, ivec2(2, 0));\nvec4 q5 = pixelAtShortOffset(image, ivec2(2, -1));\nvec4 q6 = pixelAtShortOffset(image, ivec2(2, -2));\nvec4 q7 = pixelAtShortOffset(image, ivec2(1, -2));\nvec4 q8 = pixelAtShortOffset(image, ivec2(0, -2));\nvec4 q9 = pixelAtShortOffset(image, ivec2(-1, -2));\nvec4 q10 = pixelAtShortOffset(image, ivec2(-2, -2));\nvec4 q11 = pixelAtShortOffset(image, ivec2(-2, -1));\nvec4 q12 = pixelAtShortOffset(image, ivec2(-2, 0));\nvec4 q13 = pixelAtShortOffset(image, ivec2(-2, 1));\nvec4 q14 = pixelAtShortOffset(image, ivec2(-2, 2));\nvec4 q15 = pixelAtShortOffset(image, ivec2(-1, 2));\n#else\nvec4 q0, q1, q2, q3, q4, q5, q6, q7, q8, q9, q10, q11, q12, q13, q14, q15;\nq0 = q1 = q2 = q3 = q4 = q5 = q6 = q7 = q8 = q9 = q10 =\nq11 = q12 = q13 = q14 = q15 = vec4(0.0f);\n#endif\n#ifdef ENABLE_OUTER_RING\nvec4 r0 = pixelAtShortOffset(image, ivec2(0, 3));\nvec4 r1 = pixelAtShortOffset(image, ivec2(1, 3));\nvec4 r2 = pixelAtShortOffset(image, ivec2(3, 1));\nvec4 r3 = pixelAtShortOffset(image, ivec2(3, 0));\nvec4 r4 = pixelAtShortOffset(image, ivec2(3, -1));\nvec4 r5 = pixelAtShortOffset(image, ivec2(1, -3));\nvec4 r6 = pixelAtShortOffset(image, ivec2(0, -3));\nvec4 r7 = pixelAtShortOffset(image, ivec2(-1, -3));\nvec4 r8 = pixelAtShortOffset(image, ivec2(-3, -1));\nvec4 r9 = pixelAtShortOffset(image, ivec2(-3, 0));\nvec4 r10 = pixelAtShortOffset(image, ivec2(-3, 1));\nvec4 r11 = pixelAtShortOffset(image, ivec2(-1, 3));\nvec4 r12 = pixelAtShortOffset(image, ivec2(0, 4));\nvec4 r13 = pixelAtShortOffset(image, ivec2(4, 0));\nvec4 r14 = pixelAtShortOffset(image, ivec2(0, -4));\nvec4 r15 = pixelAtShortOffset(image, ivec2(-4, 0));\n#else\nvec4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15;\nr0 = r1 = r2 = r3 = r4 = r5 = r6 = r7 = r8 = r9 = r10 =\nr11 = r12 = r13 = r14 = r15 = vec4(0.0f);\n#endif\nfloat lodPlus = lod + LOD_STEP;\nfloat lodMinus = lod - LOD_STEP;\nfloat alphaPlus = encodeLod(lodPlus);\nfloat alphaMinus = encodeLod(lodMinus);\nfloat alpha = encodeLod(lod);\nmat3 innerScore = mat3(\ndecodeFloat16(p0.rb) * float(isSameEncodedLod(p0.a, alpha) || isSameEncodedLod(p0.a, alphaPlus) || isSameEncodedLod(p0.a, alphaMinus)),\ndecodeFloat16(p1.rb) * float(isSameEncodedLod(p1.a, alpha) || isSameEncodedLod(p1.a, alphaPlus) || isSameEncodedLod(p1.a, alphaMinus)),\ndecodeFloat16(p2.rb) * float(isSameEncodedLod(p2.a, alpha) || isSameEncodedLod(p2.a, alphaPlus) || isSameEncodedLod(p2.a, alphaMinus)),\ndecodeFloat16(p3.rb) * float(isSameEncodedLod(p3.a, alpha) || isSameEncodedLod(p3.a, alphaPlus) || isSameEncodedLod(p3.a, alphaMinus)),\ndecodeFloat16(p4.rb) * float(isSameEncodedLod(p4.a, alpha) || isSameEncodedLod(p4.a, alphaPlus) || isSameEncodedLod(p4.a, alphaMinus)),\ndecodeFloat16(p5.rb) * float(isSameEncodedLod(p5.a, alpha) || isSameEncodedLod(p5.a, alphaPlus) || isSameEncodedLod(p5.a, alphaMinus)),\ndecodeFloat16(p6.rb) * float(isSameEncodedLod(p6.a, alpha) || isSameEncodedLod(p6.a, alphaPlus) || isSameEncodedLod(p6.a, alphaMinus)),\ndecodeFloat16(p7.rb) * float(isSameEncodedLod(p7.a, alpha) || isSameEncodedLod(p7.a, alphaPlus) || isSameEncodedLod(p7.a, alphaMinus)),\n0.0f\n);\nmat4 middleScore = mat4(\ndecodeFloat16(q0.rb) * float(isSameEncodedLod(q0.a, alphaPlus) || isSameEncodedLod(q0.a, alphaMinus)),\ndecodeFloat16(q1.rb) * float(isSameEncodedLod(q1.a, alphaPlus) || isSameEncodedLod(q1.a, alphaMinus)),\ndecodeFloat16(q2.rb) * float(isSameEncodedLod(q2.a, alphaPlus) || isSameEncodedLod(q2.a, alphaMinus)),\ndecodeFloat16(q3.rb) * float(isSameEncodedLod(q3.a, alphaPlus) || isSameEncodedLod(q3.a, alphaMinus)),\ndecodeFloat16(q4.rb) * float(isSameEncodedLod(q4.a, alphaPlus) || isSameEncodedLod(q4.a, alphaMinus)),\ndecodeFloat16(q5.rb) * float(isSameEncodedLod(q5.a, alphaPlus) || isSameEncodedLod(q5.a, alphaMinus)),\ndecodeFloat16(q6.rb) * float(isSameEncodedLod(q6.a, alphaPlus) || isSameEncodedLod(q6.a, alphaMinus)),\ndecodeFloat16(q7.rb) * float(isSameEncodedLod(q7.a, alphaPlus) || isSameEncodedLod(q7.a, alphaMinus)),\ndecodeFloat16(q8.rb) * float(isSameEncodedLod(q8.a, alphaPlus) || isSameEncodedLod(q8.a, alphaMinus)),\ndecodeFloat16(q9.rb) * float(isSameEncodedLod(q9.a, alphaPlus) || isSameEncodedLod(q9.a, alphaMinus)),\ndecodeFloat16(q10.rb) * float(isSameEncodedLod(q10.a, alphaPlus) || isSameEncodedLod(q10.a, alphaMinus)),\ndecodeFloat16(q11.rb) * float(isSameEncodedLod(q11.a, alphaPlus) || isSameEncodedLod(q11.a, alphaMinus)),\ndecodeFloat16(q12.rb) * float(isSameEncodedLod(q12.a, alphaPlus) || isSameEncodedLod(q12.a, alphaMinus)),\ndecodeFloat16(q13.rb) * float(isSameEncodedLod(q13.a, alphaPlus) || isSameEncodedLod(q13.a, alphaMinus)),\ndecodeFloat16(q14.rb) * float(isSameEncodedLod(q14.a, alphaPlus) || isSameEncodedLod(q14.a, alphaMinus)),\ndecodeFloat16(q15.rb) * float(isSameEncodedLod(q15.a, alphaPlus) || isSameEncodedLod(q15.a, alphaMinus))\n);\nmat4 outerScore = mat4(\ndecodeFloat16(r0.rb) * float(isSameEncodedLod(r0.a, alphaPlus) || isSameEncodedLod(r0.a, alphaMinus)),\ndecodeFloat16(r1.rb) * float(isSameEncodedLod(r1.a, alphaPlus) || isSameEncodedLod(r1.a, alphaMinus)),\ndecodeFloat16(r2.rb) * float(isSameEncodedLod(r2.a, alphaPlus) || isSameEncodedLod(r2.a, alphaMinus)),\ndecodeFloat16(r3.rb) * float(isSameEncodedLod(r3.a, alphaPlus) || isSameEncodedLod(r3.a, alphaMinus)),\ndecodeFloat16(r4.rb) * float(isSameEncodedLod(r4.a, alphaPlus) || isSameEncodedLod(r4.a, alphaMinus)),\ndecodeFloat16(r5.rb) * float(isSameEncodedLod(r5.a, alphaPlus) || isSameEncodedLod(r5.a, alphaMinus)),\ndecodeFloat16(r6.rb) * float(isSameEncodedLod(r6.a, alphaPlus) || isSameEncodedLod(r6.a, alphaMinus)),\ndecodeFloat16(r7.rb) * float(isSameEncodedLod(r7.a, alphaPlus) || isSameEncodedLod(r7.a, alphaMinus)),\ndecodeFloat16(r8.rb) * float(isSameEncodedLod(r8.a, alphaPlus) || isSameEncodedLod(r8.a, alphaMinus)),\ndecodeFloat16(r9.rb) * float(isSameEncodedLod(r9.a, alphaPlus) || isSameEncodedLod(r9.a, alphaMinus)),\ndecodeFloat16(r10.rb) * float(isSameEncodedLod(r10.a, alphaPlus) || isSameEncodedLod(r10.a, alphaMinus)),\ndecodeFloat16(r11.rb) * float(isSameEncodedLod(r11.a, alphaPlus) || isSameEncodedLod(r11.a, alphaMinus)),\ndecodeFloat16(r12.rb) * float(isSameEncodedLod(r12.a, alphaPlus) || isSameEncodedLod(r12.a, alphaMinus)),\ndecodeFloat16(r13.rb) * float(isSameEncodedLod(r13.a, alphaPlus) || isSameEncodedLod(r13.a, alphaMinus)),\ndecodeFloat16(r14.rb) * float(isSameEncodedLod(r14.a, alphaPlus) || isSameEncodedLod(r14.a, alphaMinus)),\ndecodeFloat16(r15.rb) * float(isSameEncodedLod(r15.a, alphaPlus) || isSameEncodedLod(r15.a, alphaMinus))\n);\nvec3 maxInnerScore3 = max(innerScore[0], max(innerScore[1], innerScore[2]));\nvec4 maxMiddleScore4 = max(max(middleScore[0], middleScore[1]), max(middleScore[2], middleScore[3]));\nvec4 maxOuterScore4 = max(max(outerScore[0], outerScore[1]), max(outerScore[2], outerScore[3]));\nfloat maxInnerScore = max(maxInnerScore3.x, max(maxInnerScore3.y, maxInnerScore3.z));\nfloat maxMiddleScore = max(max(maxMiddleScore4.x, maxMiddleScore4.y), max(maxMiddleScore4.z, maxMiddleScore4.w));\nfloat maxOuterScore = max(max(maxOuterScore4.x, maxOuterScore4.y), max(maxOuterScore4.z, maxOuterScore4.w));\nfloat maxScore = max(maxInnerScore, max(maxMiddleScore, maxOuterScore));\nfloat finalScore = step(maxScore, score) * score;\ncolor.rb = encodeFloat16(finalScore);\n}'},function(e,t){e.exports='@include "keypoints.glsl"\nuniform sampler2D encodedCorners;\nuniform int encoderLength;\nuniform sampler2D pyramid;\nuniform int extraSize;\nconst int descriptorSize = 32;\nconst ivec4 pat31[256] = ivec4[256](\nivec4(8,-3,9,5),\nivec4(4,2,7,-12),\nivec4(-11,9,-8,2),\nivec4(7,-12,12,-13),\nivec4(2,-13,2,12),\nivec4(1,-7,1,6),\nivec4(-2,-10,-2,-4),\nivec4(-13,-13,-11,-8),\nivec4(-13,-3,-12,-9),\nivec4(10,4,11,9),\nivec4(-13,-8,-8,-9),\nivec4(-11,7,-9,12),\nivec4(7,7,12,6),\nivec4(-4,-5,-3,0),\nivec4(-13,2,-12,-3),\nivec4(-9,0,-7,5),\nivec4(12,-6,12,-1),\nivec4(-3,6,-2,12),\nivec4(-6,-13,-4,-8),\nivec4(11,-13,12,-8),\nivec4(4,7,5,1),\nivec4(5,-3,10,-3),\nivec4(3,-7,6,12),\nivec4(-8,-7,-6,-2),\nivec4(-2,11,-1,-10),\nivec4(-13,12,-8,10),\nivec4(-7,3,-5,-3),\nivec4(-4,2,-3,7),\nivec4(-10,-12,-6,11),\nivec4(5,-12,6,-7),\nivec4(5,-6,7,-1),\nivec4(1,0,4,-5),\nivec4(9,11,11,-13),\nivec4(4,7,4,12),\nivec4(2,-1,4,4),\nivec4(-4,-12,-2,7),\nivec4(-8,-5,-7,-10),\nivec4(4,11,9,12),\nivec4(0,-8,1,-13),\nivec4(-13,-2,-8,2),\nivec4(-3,-2,-2,3),\nivec4(-6,9,-4,-9),\nivec4(8,12,10,7),\nivec4(0,9,1,3),\nivec4(7,-5,11,-10),\nivec4(-13,-6,-11,0),\nivec4(10,7,12,1),\nivec4(-6,-3,-6,12),\nivec4(10,-9,12,-4),\nivec4(-13,8,-8,-12),\nivec4(-13,0,-8,-4),\nivec4(3,3,7,8),\nivec4(5,7,10,-7),\nivec4(-1,7,1,-12),\nivec4(3,-10,5,6),\nivec4(2,-4,3,-10),\nivec4(-13,0,-13,5),\nivec4(-13,-7,-12,12),\nivec4(-13,3,-11,8),\nivec4(-7,12,-4,7),\nivec4(6,-10,12,8),\nivec4(-9,-1,-7,-6),\nivec4(-2,-5,0,12),\nivec4(-12,5,-7,5),\nivec4(3,-10,8,-13),\nivec4(-7,-7,-4,5),\nivec4(-3,-2,-1,-7),\nivec4(2,9,5,-11),\nivec4(-11,-13,-5,-13),\nivec4(-1,6,0,-1),\nivec4(5,-3,5,2),\nivec4(-4,-13,-4,12),\nivec4(-9,-6,-9,6),\nivec4(-12,-10,-8,-4),\nivec4(10,2,12,-3),\nivec4(7,12,12,12),\nivec4(-7,-13,-6,5),\nivec4(-4,9,-3,4),\nivec4(7,-1,12,2),\nivec4(-7,6,-5,1),\nivec4(-13,11,-12,5),\nivec4(-3,7,-2,-6),\nivec4(7,-8,12,-7),\nivec4(-13,-7,-11,-12),\nivec4(1,-3,12,12),\nivec4(2,-6,3,0),\nivec4(-4,3,-2,-13),\nivec4(-1,-13,1,9),\nivec4(7,1,8,-6),\nivec4(1,-1,3,12),\nivec4(9,1,12,6),\nivec4(-1,-9,-1,3),\nivec4(-13,-13,-10,5),\nivec4(7,7,10,12),\nivec4(12,-5,12,9),\nivec4(6,3,7,11),\nivec4(5,-13,6,10),\nivec4(2,-12,2,3),\nivec4(3,8,4,-6),\nivec4(2,6,12,-13),\nivec4(9,-12,10,3),\nivec4(-8,4,-7,9),\nivec4(-11,12,-4,-6),\nivec4(1,12,2,-8),\nivec4(6,-9,7,-4),\nivec4(2,3,3,-2),\nivec4(6,3,11,0),\nivec4(3,-3,8,-8),\nivec4(7,8,9,3),\nivec4(-11,-5,-6,-4),\nivec4(-10,11,-5,10),\nivec4(-5,-8,-3,12),\nivec4(-10,5,-9,0),\nivec4(8,-1,12,-6),\nivec4(4,-6,6,-11),\nivec4(-10,12,-8,7),\nivec4(4,-2,6,7),\nivec4(-2,0,-2,12),\nivec4(-5,-8,-5,2),\nivec4(7,-6,10,12),\nivec4(-9,-13,-8,-8),\nivec4(-5,-13,-5,-2),\nivec4(8,-8,9,-13),\nivec4(-9,-11,-9,0),\nivec4(1,-8,1,-2),\nivec4(7,-4,9,1),\nivec4(-2,1,-1,-4),\nivec4(11,-6,12,-11),\nivec4(-12,-9,-6,4),\nivec4(3,7,7,12),\nivec4(5,5,10,8),\nivec4(0,-4,2,8),\nivec4(-9,12,-5,-13),\nivec4(0,7,2,12),\nivec4(-1,2,1,7),\nivec4(5,11,7,-9),\nivec4(3,5,6,-8),\nivec4(-13,-4,-8,9),\nivec4(-5,9,-3,-3),\nivec4(-4,-7,-3,-12),\nivec4(6,5,8,0),\nivec4(-7,6,-6,12),\nivec4(-13,6,-5,-2),\nivec4(1,-10,3,10),\nivec4(4,1,8,-4),\nivec4(-2,-2,2,-13),\nivec4(2,-12,12,12),\nivec4(-2,-13,0,-6),\nivec4(4,1,9,3),\nivec4(-6,-10,-3,-5),\nivec4(-3,-13,-1,1),\nivec4(7,5,12,-11),\nivec4(4,-2,5,-7),\nivec4(-13,9,-9,-5),\nivec4(7,1,8,6),\nivec4(7,-8,7,6),\nivec4(-7,-4,-7,1),\nivec4(-8,11,-7,-8),\nivec4(-13,6,-12,-8),\nivec4(2,4,3,9),\nivec4(10,-5,12,3),\nivec4(-6,-5,-6,7),\nivec4(8,-3,9,-8),\nivec4(2,-12,2,8),\nivec4(-11,-2,-10,3),\nivec4(-12,-13,-7,-9),\nivec4(-11,0,-10,-5),\nivec4(5,-3,11,8),\nivec4(-2,-13,-1,12),\nivec4(-1,-8,0,9),\nivec4(-13,-11,-12,-5),\nivec4(-10,-2,-10,11),\nivec4(-3,9,-2,-13),\nivec4(2,-3,3,2),\nivec4(-9,-13,-4,0),\nivec4(-4,6,-3,-10),\nivec4(-4,12,-2,-7),\nivec4(-6,-11,-4,9),\nivec4(6,-3,6,11),\nivec4(-13,11,-5,5),\nivec4(11,11,12,6),\nivec4(7,-5,12,-2),\nivec4(-1,12,0,7),\nivec4(-4,-8,-3,-2),\nivec4(-7,1,-6,7),\nivec4(-13,-12,-8,-13),\nivec4(-7,-2,-6,-8),\nivec4(-8,5,-6,-9),\nivec4(-5,-1,-4,5),\nivec4(-13,7,-8,10),\nivec4(1,5,5,-13),\nivec4(1,0,10,-13),\nivec4(9,12,10,-1),\nivec4(5,-8,10,-9),\nivec4(-1,11,1,-13),\nivec4(-9,-3,-6,2),\nivec4(-1,-10,1,12),\nivec4(-13,1,-8,-10),\nivec4(8,-11,10,-6),\nivec4(2,-13,3,-6),\nivec4(7,-13,12,-9),\nivec4(-10,-10,-5,-7),\nivec4(-10,-8,-8,-13),\nivec4(4,-6,8,5),\nivec4(3,12,8,-13),\nivec4(-4,2,-3,-3),\nivec4(5,-13,10,-12),\nivec4(4,-13,5,-1),\nivec4(-9,9,-4,3),\nivec4(0,3,3,-9),\nivec4(-12,1,-6,1),\nivec4(3,2,4,-8),\nivec4(-10,-10,-10,9),\nivec4(8,-13,12,12),\nivec4(-8,-12,-6,-5),\nivec4(2,2,3,7),\nivec4(10,6,11,-8),\nivec4(6,8,8,-12),\nivec4(-7,10,-6,5),\nivec4(-3,-9,-3,9),\nivec4(-1,-13,-1,5),\nivec4(-3,-7,-3,4),\nivec4(-8,-2,-8,3),\nivec4(4,2,12,12),\nivec4(2,-5,3,11),\nivec4(6,-9,11,-13),\nivec4(3,-1,7,12),\nivec4(11,-1,12,4),\nivec4(-3,0,-3,6),\nivec4(4,-11,4,12),\nivec4(2,-4,2,1),\nivec4(-10,-6,-8,1),\nivec4(-13,7,-11,1),\nivec4(-13,12,-11,-13),\nivec4(6,0,11,-13),\nivec4(0,-1,1,4),\nivec4(-13,3,-9,-2),\nivec4(-9,8,-6,-3),\nivec4(-13,-6,-8,-2),\nivec4(5,-9,8,10),\nivec4(2,7,3,-9),\nivec4(-1,-6,-1,-1),\nivec4(9,5,11,-2),\nivec4(11,-3,12,-8),\nivec4(3,0,3,5),\nivec4(-1,4,0,10),\nivec4(3,-6,4,5),\nivec4(-13,0,-10,5),\nivec4(5,8,12,11),\nivec4(8,9,9,-6),\nivec4(7,-4,8,-12),\nivec4(-10,4,-10,9),\nivec4(7,3,12,4),\nivec4(9,-7,10,-2),\nivec4(7,0,12,-2),\nivec4(-1,-6,0,-11)\n);\nvoid getPair(int index, float kcos, float ksin, out ivec2 p, out ivec2 q)\n{\nivec4 data = pat31[index];\nvec2 op = vec2(data.xy);\nvec2 oq = vec2(data.zw);\np = ivec2(round(op.x * kcos - op.y * ksin), round(op.x * ksin + op.y * kcos));\nq = ivec2(round(oq.x * kcos - oq.y * ksin), round(oq.x * ksin + oq.y * kcos));\n}\nvoid main()\n{\nvec4 pixel = threadPixel(encodedCorners);\nivec2 thread = threadLocation();\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nint descriptorCell = address.offset - sizeofEncodedKeypoint(0, extraSize) / 4;\ncolor = pixel;\nif(descriptorCell < 0)\nreturn;\nKeypoint keypoint = decodeKeypoint(encodedCorners, encoderLength, address);\nif(isBadKeypoint(keypoint))\nreturn;\nfloat pot = exp2(keypoint.lod);\nfloat kcos = cos(keypoint.orientation);\nfloat ksin = sin(keypoint.orientation);\nvec2 imageSize = vec2(textureSize(pyramid, 0));\nint patternStart = 32 * descriptorCell;\nuint test[4] = uint[4](0u, 0u, 0u, 0u);\nfor(int t = 0; t < 4; t++) {\nuint bits = 0u;\nivec2 p, q;\nvec4 a, b;\nint i = t * 8;\n@unroll\nfor(int j = 0; j < 8; j++) {\ngetPair(patternStart + i + j, kcos, ksin, p, q);\na = pyrPixelAtEx(pyramid, round(keypoint.position + pot * vec2(p)), keypoint.lod, imageSize);\nb = pyrPixelAtEx(pyramid, round(keypoint.position + pot * vec2(q)), keypoint.lod, imageSize);\nbits |= uint(a.g < b.g) << j;\n}\ntest[t] = bits;\n}\ncolor = vec4(test[0], test[1], test[2], test[3]) / 255.0f;\n}'},function(e,t){e.exports='@include "keypoints.glsl"\nuniform sampler2D pyramid;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nconst int diskPointCount[16] = int[16](0, 4, 12, 28, 48, 80, 112, 148, 196, 252, 316, 376, 440, 528, 612, 708);\nconst ivec2 diskPoint[708] = ivec2[708](\nivec2(0,-1),ivec2(-1,0),ivec2(1,0),ivec2(0,1),\nivec2(-1,-1),ivec2(1,-1),ivec2(-1,1),ivec2(1,1),ivec2(0,-2),ivec2(-2,0),ivec2(2,0),ivec2(0,2),\nivec2(-1,-2),ivec2(1,-2),ivec2(-2,-1),ivec2(2,-1),ivec2(-2,1),ivec2(2,1),ivec2(-1,2),ivec2(1,2),ivec2(-2,-2),ivec2(2,-2),ivec2(-2,2),ivec2(2,2),ivec2(0,-3),ivec2(-3,0),ivec2(3,0),ivec2(0,3),\nivec2(-1,-3),ivec2(1,-3),ivec2(-3,-1),ivec2(3,-1),ivec2(-3,1),ivec2(3,1),ivec2(-1,3),ivec2(1,3),ivec2(-2,-3),ivec2(2,-3),ivec2(-3,-2),ivec2(3,-2),ivec2(-3,2),ivec2(3,2),ivec2(-2,3),ivec2(2,3),ivec2(0,-4),ivec2(-4,0),ivec2(4,0),ivec2(0,4),\nivec2(-1,-4),ivec2(1,-4),ivec2(-4,-1),ivec2(4,-1),ivec2(-4,1),ivec2(4,1),ivec2(-1,4),ivec2(1,4),ivec2(-3,-3),ivec2(3,-3),ivec2(-3,3),ivec2(3,3),ivec2(-2,-4),ivec2(2,-4),ivec2(-4,-2),ivec2(4,-2),ivec2(-4,2),ivec2(4,2),ivec2(-2,4),ivec2(2,4),ivec2(0,-5),ivec2(-3,-4),ivec2(3,-4),ivec2(-4,-3),ivec2(4,-3),ivec2(-5,0),ivec2(5,0),ivec2(-4,3),ivec2(4,3),ivec2(-3,4),ivec2(3,4),ivec2(0,5),\nivec2(-1,-5),ivec2(1,-5),ivec2(-5,-1),ivec2(5,-1),ivec2(-5,1),ivec2(5,1),ivec2(-1,5),ivec2(1,5),ivec2(-2,-5),ivec2(2,-5),ivec2(-5,-2),ivec2(5,-2),ivec2(-5,2),ivec2(5,2),ivec2(-2,5),ivec2(2,5),ivec2(-4,-4),ivec2(4,-4),ivec2(-4,4),ivec2(4,4),ivec2(-3,-5),ivec2(3,-5),ivec2(-5,-3),ivec2(5,-3),ivec2(-5,3),ivec2(5,3),ivec2(-3,5),ivec2(3,5),ivec2(0,-6),ivec2(-6,0),ivec2(6,0),ivec2(0,6),\nivec2(-1,-6),ivec2(1,-6),ivec2(-6,-1),ivec2(6,-1),ivec2(-6,1),ivec2(6,1),ivec2(-1,6),ivec2(1,6),ivec2(-2,-6),ivec2(2,-6),ivec2(-6,-2),ivec2(6,-2),ivec2(-6,2),ivec2(6,2),ivec2(-2,6),ivec2(2,6),ivec2(-4,-5),ivec2(4,-5),ivec2(-5,-4),ivec2(5,-4),ivec2(-5,4),ivec2(5,4),ivec2(-4,5),ivec2(4,5),ivec2(-3,-6),ivec2(3,-6),ivec2(-6,-3),ivec2(6,-3),ivec2(-6,3),ivec2(6,3),ivec2(-3,6),ivec2(3,6),ivec2(0,-7),ivec2(-7,0),ivec2(7,0),ivec2(0,7),\nivec2(-1,-7),ivec2(1,-7),ivec2(-5,-5),ivec2(5,-5),ivec2(-7,-1),ivec2(7,-1),ivec2(-7,1),ivec2(7,1),ivec2(-5,5),ivec2(5,5),ivec2(-1,7),ivec2(1,7),ivec2(-4,-6),ivec2(4,-6),ivec2(-6,-4),ivec2(6,-4),ivec2(-6,4),ivec2(6,4),ivec2(-4,6),ivec2(4,6),ivec2(-2,-7),ivec2(2,-7),ivec2(-7,-2),ivec2(7,-2),ivec2(-7,2),ivec2(7,2),ivec2(-2,7),ivec2(2,7),ivec2(-3,-7),ivec2(3,-7),ivec2(-7,-3),ivec2(7,-3),ivec2(-7,3),ivec2(7,3),ivec2(-3,7),ivec2(3,7),ivec2(-5,-6),ivec2(5,-6),ivec2(-6,-5),ivec2(6,-5),ivec2(-6,5),ivec2(6,5),ivec2(-5,6),ivec2(5,6),ivec2(0,-8),ivec2(-8,0),ivec2(8,0),ivec2(0,8),\nivec2(-1,-8),ivec2(1,-8),ivec2(-4,-7),ivec2(4,-7),ivec2(-7,-4),ivec2(7,-4),ivec2(-8,-1),ivec2(8,-1),ivec2(-8,1),ivec2(8,1),ivec2(-7,4),ivec2(7,4),ivec2(-4,7),ivec2(4,7),ivec2(-1,8),ivec2(1,8),ivec2(-2,-8),ivec2(2,-8),ivec2(-8,-2),ivec2(8,-2),ivec2(-8,2),ivec2(8,2),ivec2(-2,8),ivec2(2,8),ivec2(-6,-6),ivec2(6,-6),ivec2(-6,6),ivec2(6,6),ivec2(-3,-8),ivec2(3,-8),ivec2(-8,-3),ivec2(8,-3),ivec2(-8,3),ivec2(8,3),ivec2(-3,8),ivec2(3,8),ivec2(-5,-7),ivec2(5,-7),ivec2(-7,-5),ivec2(7,-5),ivec2(-7,5),ivec2(7,5),ivec2(-5,7),ivec2(5,7),ivec2(-4,-8),ivec2(4,-8),ivec2(-8,-4),ivec2(8,-4),ivec2(-8,4),ivec2(8,4),ivec2(-4,8),ivec2(4,8),ivec2(0,-9),ivec2(-9,0),ivec2(9,0),ivec2(0,9),\nivec2(-1,-9),ivec2(1,-9),ivec2(-9,-1),ivec2(9,-1),ivec2(-9,1),ivec2(9,1),ivec2(-1,9),ivec2(1,9),ivec2(-2,-9),ivec2(2,-9),ivec2(-6,-7),ivec2(6,-7),ivec2(-7,-6),ivec2(7,-6),ivec2(-9,-2),ivec2(9,-2),ivec2(-9,2),ivec2(9,2),ivec2(-7,6),ivec2(7,6),ivec2(-6,7),ivec2(6,7),ivec2(-2,9),ivec2(2,9),ivec2(-5,-8),ivec2(5,-8),ivec2(-8,-5),ivec2(8,-5),ivec2(-8,5),ivec2(8,5),ivec2(-5,8),ivec2(5,8),ivec2(-3,-9),ivec2(3,-9),ivec2(-9,-3),ivec2(9,-3),ivec2(-9,3),ivec2(9,3),ivec2(-3,9),ivec2(3,9),ivec2(-4,-9),ivec2(4,-9),ivec2(-9,-4),ivec2(9,-4),ivec2(-9,4),ivec2(9,4),ivec2(-4,9),ivec2(4,9),ivec2(-7,-7),ivec2(7,-7),ivec2(-7,7),ivec2(7,7),ivec2(0,-10),ivec2(-6,-8),ivec2(6,-8),ivec2(-8,-6),ivec2(8,-6),ivec2(-10,0),ivec2(10,0),ivec2(-8,6),ivec2(8,6),ivec2(-6,8),ivec2(6,8),ivec2(0,10),\nivec2(-1,-10),ivec2(1,-10),ivec2(-10,-1),ivec2(10,-1),ivec2(-10,1),ivec2(10,1),ivec2(-1,10),ivec2(1,10),ivec2(-2,-10),ivec2(2,-10),ivec2(-10,-2),ivec2(10,-2),ivec2(-10,2),ivec2(10,2),ivec2(-2,10),ivec2(2,10),ivec2(-5,-9),ivec2(5,-9),ivec2(-9,-5),ivec2(9,-5),ivec2(-9,5),ivec2(9,5),ivec2(-5,9),ivec2(5,9),ivec2(-3,-10),ivec2(3,-10),ivec2(-10,-3),ivec2(10,-3),ivec2(-10,3),ivec2(10,3),ivec2(-3,10),ivec2(3,10),ivec2(-7,-8),ivec2(7,-8),ivec2(-8,-7),ivec2(8,-7),ivec2(-8,7),ivec2(8,7),ivec2(-7,8),ivec2(7,8),ivec2(-4,-10),ivec2(4,-10),ivec2(-10,-4),ivec2(10,-4),ivec2(-10,4),ivec2(10,4),ivec2(-4,10),ivec2(4,10),ivec2(-6,-9),ivec2(6,-9),ivec2(-9,-6),ivec2(9,-6),ivec2(-9,6),ivec2(9,6),ivec2(-6,9),ivec2(6,9),ivec2(0,-11),ivec2(-11,0),ivec2(11,0),ivec2(0,11),\nivec2(-1,-11),ivec2(1,-11),ivec2(-11,-1),ivec2(11,-1),ivec2(-11,1),ivec2(11,1),ivec2(-1,11),ivec2(1,11),ivec2(-2,-11),ivec2(2,-11),ivec2(-5,-10),ivec2(5,-10),ivec2(-10,-5),ivec2(10,-5),ivec2(-11,-2),ivec2(11,-2),ivec2(-11,2),ivec2(11,2),ivec2(-10,5),ivec2(10,5),ivec2(-5,10),ivec2(5,10),ivec2(-2,11),ivec2(2,11),ivec2(-8,-8),ivec2(8,-8),ivec2(-8,8),ivec2(8,8),ivec2(-3,-11),ivec2(3,-11),ivec2(-7,-9),ivec2(7,-9),ivec2(-9,-7),ivec2(9,-7),ivec2(-11,-3),ivec2(11,-3),ivec2(-11,3),ivec2(11,3),ivec2(-9,7),ivec2(9,7),ivec2(-7,9),ivec2(7,9),ivec2(-3,11),ivec2(3,11),ivec2(-6,-10),ivec2(6,-10),ivec2(-10,-6),ivec2(10,-6),ivec2(-10,6),ivec2(10,6),ivec2(-6,10),ivec2(6,10),ivec2(-4,-11),ivec2(4,-11),ivec2(-11,-4),ivec2(11,-4),ivec2(-11,4),ivec2(11,4),ivec2(-4,11),ivec2(4,11),ivec2(0,-12),ivec2(-12,0),ivec2(12,0),ivec2(0,12),\nivec2(-1,-12),ivec2(1,-12),ivec2(-8,-9),ivec2(8,-9),ivec2(-9,-8),ivec2(9,-8),ivec2(-12,-1),ivec2(12,-1),ivec2(-12,1),ivec2(12,1),ivec2(-9,8),ivec2(9,8),ivec2(-8,9),ivec2(8,9),ivec2(-1,12),ivec2(1,12),ivec2(-5,-11),ivec2(5,-11),ivec2(-11,-5),ivec2(11,-5),ivec2(-11,5),ivec2(11,5),ivec2(-5,11),ivec2(5,11),ivec2(-2,-12),ivec2(2,-12),ivec2(-12,-2),ivec2(12,-2),ivec2(-12,2),ivec2(12,2),ivec2(-2,12),ivec2(2,12),ivec2(-7,-10),ivec2(7,-10),ivec2(-10,-7),ivec2(10,-7),ivec2(-10,7),ivec2(10,7),ivec2(-7,10),ivec2(7,10),ivec2(-3,-12),ivec2(3,-12),ivec2(-12,-3),ivec2(12,-3),ivec2(-12,3),ivec2(12,3),ivec2(-3,12),ivec2(3,12),ivec2(-6,-11),ivec2(6,-11),ivec2(-11,-6),ivec2(11,-6),ivec2(-11,6),ivec2(11,6),ivec2(-6,11),ivec2(6,11),ivec2(-4,-12),ivec2(4,-12),ivec2(-12,-4),ivec2(12,-4),ivec2(-12,4),ivec2(12,4),ivec2(-4,12),ivec2(4,12),ivec2(-9,-9),ivec2(9,-9),ivec2(-9,9),ivec2(9,9),ivec2(-8,-10),ivec2(8,-10),ivec2(-10,-8),ivec2(10,-8),ivec2(-10,8),ivec2(10,8),ivec2(-8,10),ivec2(8,10),ivec2(0,-13),ivec2(-5,-12),ivec2(5,-12),ivec2(-12,-5),ivec2(12,-5),ivec2(-13,0),ivec2(13,0),ivec2(-12,5),ivec2(12,5),ivec2(-5,12),ivec2(5,12),ivec2(0,13),\nivec2(-1,-13),ivec2(1,-13),ivec2(-7,-11),ivec2(7,-11),ivec2(-11,-7),ivec2(11,-7),ivec2(-13,-1),ivec2(13,-1),ivec2(-13,1),ivec2(13,1),ivec2(-11,7),ivec2(11,7),ivec2(-7,11),ivec2(7,11),ivec2(-1,13),ivec2(1,13),ivec2(-2,-13),ivec2(2,-13),ivec2(-13,-2),ivec2(13,-2),ivec2(-13,2),ivec2(13,2),ivec2(-2,13),ivec2(2,13),ivec2(-3,-13),ivec2(3,-13),ivec2(-13,-3),ivec2(13,-3),ivec2(-13,3),ivec2(13,3),ivec2(-3,13),ivec2(3,13),ivec2(-6,-12),ivec2(6,-12),ivec2(-12,-6),ivec2(12,-6),ivec2(-12,6),ivec2(12,6),ivec2(-6,12),ivec2(6,12),ivec2(-9,-10),ivec2(9,-10),ivec2(-10,-9),ivec2(10,-9),ivec2(-10,9),ivec2(10,9),ivec2(-9,10),ivec2(9,10),ivec2(-4,-13),ivec2(4,-13),ivec2(-8,-11),ivec2(8,-11),ivec2(-11,-8),ivec2(11,-8),ivec2(-13,-4),ivec2(13,-4),ivec2(-13,4),ivec2(13,4),ivec2(-11,8),ivec2(11,8),ivec2(-8,11),ivec2(8,11),ivec2(-4,13),ivec2(4,13),ivec2(-7,-12),ivec2(7,-12),ivec2(-12,-7),ivec2(12,-7),ivec2(-12,7),ivec2(12,7),ivec2(-7,12),ivec2(7,12),ivec2(-5,-13),ivec2(5,-13),ivec2(-13,-5),ivec2(13,-5),ivec2(-13,5),ivec2(13,5),ivec2(-5,13),ivec2(5,13),ivec2(0,-14),ivec2(-14,0),ivec2(14,0),ivec2(0,14),\nivec2(-1,-14),ivec2(1,-14),ivec2(-14,-1),ivec2(14,-1),ivec2(-14,1),ivec2(14,1),ivec2(-1,14),ivec2(1,14),ivec2(-2,-14),ivec2(2,-14),ivec2(-10,-10),ivec2(10,-10),ivec2(-14,-2),ivec2(14,-2),ivec2(-14,2),ivec2(14,2),ivec2(-10,10),ivec2(10,10),ivec2(-2,14),ivec2(2,14),ivec2(-9,-11),ivec2(9,-11),ivec2(-11,-9),ivec2(11,-9),ivec2(-11,9),ivec2(11,9),ivec2(-9,11),ivec2(9,11),ivec2(-3,-14),ivec2(3,-14),ivec2(-6,-13),ivec2(6,-13),ivec2(-13,-6),ivec2(13,-6),ivec2(-14,-3),ivec2(14,-3),ivec2(-14,3),ivec2(14,3),ivec2(-13,6),ivec2(13,6),ivec2(-6,13),ivec2(6,13),ivec2(-3,14),ivec2(3,14),ivec2(-8,-12),ivec2(8,-12),ivec2(-12,-8),ivec2(12,-8),ivec2(-12,8),ivec2(12,8),ivec2(-8,12),ivec2(8,12),ivec2(-4,-14),ivec2(4,-14),ivec2(-14,-4),ivec2(14,-4),ivec2(-14,4),ivec2(14,4),ivec2(-4,14),ivec2(4,14),ivec2(-7,-13),ivec2(7,-13),ivec2(-13,-7),ivec2(13,-7),ivec2(-13,7),ivec2(13,7),ivec2(-7,13),ivec2(7,13),ivec2(-5,-14),ivec2(5,-14),ivec2(-10,-11),ivec2(10,-11),ivec2(-11,-10),ivec2(11,-10),ivec2(-14,-5),ivec2(14,-5),ivec2(-14,5),ivec2(14,5),ivec2(-11,10),ivec2(11,10),ivec2(-10,11),ivec2(10,11),ivec2(-5,14),ivec2(5,14),ivec2(0,-15),ivec2(-9,-12),ivec2(9,-12),ivec2(-12,-9),ivec2(12,-9),ivec2(-15,0),ivec2(15,0),ivec2(-12,9),ivec2(12,9),ivec2(-9,12),ivec2(9,12),ivec2(0,15)\n);\nconst int DEFAULT_PATCH_RADIUS = 15;\nconst int MIN_PATCH_RADIUS = 2;\nvoid main()\n{\nvec4 pixel = threadPixel(encodedKeypoints);\nivec2 thread = threadLocation();\nint keypointIndex = thread.x + thread.y * outputSize().x;\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress address = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\nvec2 m = vec2(0.0f);\nfloat pot = exp2(keypoint.lod);\nivec2 pyrBaseSize = textureSize(pyramid, 0);\nint scaledRadius = int(ceil(float(DEFAULT_PATCH_RADIUS) / pot));\nint radius = max(scaledRadius, MIN_PATCH_RADIUS);\nint count = diskPointCount[radius];\nfor(int j = 0; j < count; j++) {\nvec2 offset = vec2(diskPoint[j]);\nvec2 position = keypoint.position + round(pot * offset);\nvec4 patchPixel = pyrPixelAtEx(pyramid, position, keypoint.lod, pyrBaseSize);\nm += offset * patchPixel.g;\n}\nfloat angle = fastAtan2(m.y, m.x);\nfloat encodedOrientation = encodeOrientation(angle);\nfloat encodedFlags = encodeKeypointFlags(keypoint.flags | KPF_ORIENTED);\ncolor = vec4(0.0f, encodedOrientation, 0.0f, encodedFlags);\n}'},function(e,t){e.exports='@include "keypoints.glsl"\nuniform sampler2D encodedKeypoints;\nuniform int estimatedKeypointCount;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\n#if !defined(MAX_KEYPOINTS)\n#error Must define MAX_KEYPOINTS\n#elif MAX_KEYPOINTS >= 65536\n#error MAX_KEYPOINTS is too large!\n#endif\nuint tuple[1 + MAX_KEYPOINTS];\nuint encodeTuple(Keypoint keypoint, int index)\n{\nuint mask = uint(-int(!isBadKeypoint(keypoint)));\nuint score = uint(clamp(keypoint.score, 0.0f, 1.0f) * 65535.0f);\nuint data = (uint(index) & 65535u) | (score << 16u);\nreturn data & mask;\n}\n#define decodeTupleIndex(tuple) int((tuple) & 16777215u)\n#define QUICKSELECT_UNSIGNED\n#define QUICKSELECT_DESCENDING\n#define QUICKSELECT_ARRAY tuple\n@include "quickselect.glsl"\nvoid main()\n{\nvec4 pixel = threadPixel(encodedKeypoints);\nivec2 thread = threadLocation();\nKeypointAddress myAddress = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nint myIndex = findKeypointIndex(myAddress, descriptorSize, extraSize);\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\ncolor = pixel;\nif(myIndex >= estimatedKeypointCount)\nreturn;\nKeypoint keypoint;\nKeypointAddress address = KeypointAddress(0, 0);\nint actualKeypointCount = estimatedKeypointCount;\nfor(int i = 0; i < estimatedKeypointCount; i++) {\nkeypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\ntuple[min(i, MAX_KEYPOINTS)] = encodeTuple(keypoint, i);\nactualKeypointCount = isBadKeypoint(keypoint) ? min(actualKeypointCount, i) : actualKeypointCount;\naddress.base += pixelsPerKeypoint;\n}\nint desiredTuple = quickselect(0, min(MAX_KEYPOINTS, actualKeypointCount - 1), myIndex);\nint desiredIndex = decodeTupleIndex(desiredTuple);\nKeypointAddress desiredAddress = KeypointAddress(desiredIndex * pixelsPerKeypoint, myAddress.offset);\nvec4 desiredPixel = readKeypointData(encodedKeypoints, encoderLength, desiredAddress);\ncolor = myIndex < actualKeypointCount ? desiredPixel : encodeNullKeypoint();\n}'},function(e,t){e.exports='@include "keypoints.glsl"\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nuniform int suppressedEncoderLength;\nvoid main()\n{\nivec2 thread = threadLocation();\nKeypointAddress myAddress = findKeypointAddress(thread, suppressedEncoderLength, 0, extraSize);\nint myIndex = findKeypointIndex(myAddress, 0, extraSize);\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress otherAddress = KeypointAddress(myIndex * pixelsPerKeypoint, myAddress.offset);\ncolor = readKeypointData(encodedKeypoints, encoderLength, otherAddress);\n}'},function(e,t){e.exports='@include "keypoints.glsl"\nuniform sampler2D encodedOrientations;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nvoid main()\n{\nvec4 pixel = threadPixel(encodedKeypoints);\nivec2 thread = threadLocation();\nKeypointAddress myAddress = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nint myIndex = findKeypointIndex(myAddress, descriptorSize, extraSize);\nint orientationEncoderLength = textureSize(encodedOrientations, 0).x;\nivec2 location = ivec2(myIndex % orientationEncoderLength, myIndex / orientationEncoderLength);\nvec4 targetPixel = pixelAt(encodedOrientations, location);\nfloat encodedOrientation = targetPixel.g;\nfloat encodedFlags = targetPixel.a;\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, myAddress);\nbool isValid = !isBadKeypoint(keypoint);\ncolor = isValid && myAddress.offset == 1 ? vec4(pixel.r, encodedOrientation, pixel.b, encodedFlags) : pixel;\n}'},function(e,t){e.exports="uniform sampler2D image;\nvoid main()\n{\nivec2 thread = threadLocation();\nivec2 pos = min(thread * 2, textureSize(image, 0) - ivec2(1));\ncolor = pixelAt(image, pos);\n}"},function(e,t){e.exports="uniform sampler2D image;\nvoid main()\n{\nivec2 thread = threadLocation();\nvec4 pixel = pixelAt(image, thread / 2);\ncolor = (((thread.x + thread.y) & 1) == 0) ? pixel : vec4(0.0f, 0.0f, 0.0f, pixel.a);\n}"},function(e,t){e.exports='@include "keypoints.glsl"\nuniform sampler2D pyramid;\nuniform sampler2D encodedKeypoints;\nuniform int windowSize;\nuniform float discardThreshold;\nuniform int firstKeypointIndex, lastKeypointIndex;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\n#ifndef MAX_WINDOW_SIZE\n#error Must define MAX_WINDOW_SIZE\n#endif\nconst int MAX_WINDOW_SIZE_PLUS = MAX_WINDOW_SIZE + 2;\nconst int MAX_WINDOW_SIZE_PLUS_SQUARED = MAX_WINDOW_SIZE_PLUS * MAX_WINDOW_SIZE_PLUS;\nconst int MAX_WINDOW_RADIUS_PLUS = (MAX_WINDOW_SIZE_PLUS - 1) / 2;\nconst float DISCARD_SCALE = 0.00024318695068359375f;\nfloat pixelBuffer[MAX_WINDOW_SIZE_PLUS_SQUARED];\n#define pixelIndex(i, j) (((j) + MAX_WINDOW_RADIUS_PLUS) * MAX_WINDOW_SIZE_PLUS + ((i) + MAX_WINDOW_RADIUS_PLUS))\n#define windowRadius() ((windowSize - 1) / 2)\nvoid readWindow(vec2 center, float lod)\n{\nivec2 pyrBaseSize = textureSize(pyramid, 0);\nfloat pot = exp2(lod);\nint r = windowRadius();\n#define readPixelAt(ox, oy) pixelBuffer[pixelIndex((ox), (oy))] = pyrSubpixelAtExOffset(pyramid, center, lod, pot, ivec2((ox), (oy)), pyrBaseSize).g\nfor(int j = 0; j < windowSize; j++) {\nfor(int i = 0; i < windowSize; i++) {\nreadPixelAt(i-r, j-r);\n}\n}\nint r1 = r+1;\nfor(int k = 0; k < windowSize; k++) {\nreadPixelAt(-r1, k-r);\nreadPixelAt( r1, k-r);\nreadPixelAt(k-r,-r1);\nreadPixelAt(k-r, r1);\n}\nreadPixelAt(-r1,-r1);\nreadPixelAt( r1,-r1);\nreadPixelAt(-r1, r1);\nreadPixelAt( r1, r1);\n}\nvec2 computeDerivatives(ivec2 offset)\n{\nconst mat3 derivX = mat3(\n3, 0, -3,\n10, 0, -10,\n3, 0, -3\n);\nconst mat3 derivY = mat3(\n3, 10, 3,\n0, 0, 0,\n-3, -10, -3\n);\nmat3 window = mat3(\npixelBuffer[pixelIndex(offset.x-1, offset.y-1)],\npixelBuffer[pixelIndex(offset.x+0, offset.y-1)],\npixelBuffer[pixelIndex(offset.x+1, offset.y-1)],\npixelBuffer[pixelIndex(offset.x-1, offset.y+0)],\n0.0f,\npixelBuffer[pixelIndex(offset.x+1, offset.y+0)],\npixelBuffer[pixelIndex(offset.x-1, offset.y+1)],\npixelBuffer[pixelIndex(offset.x+0, offset.y+1)],\npixelBuffer[pixelIndex(offset.x+1, offset.y+1)]\n);\nmat3 fx = matrixCompMult(derivX, window);\nmat3 fy = matrixCompMult(derivY, window);\nconst vec3 ones = vec3(1.0f);\nreturn vec2(\ndot(fx[0], ones) + dot(fx[1], ones) + dot(fx[2], ones),\ndot(fy[0], ones) + dot(fy[1], ones) + dot(fy[2], ones)\n);\n}\nvoid main()\n{\nvec4 pixel = threadPixel(encodedKeypoints);\nivec2 thread = threadLocation();\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nint r = windowRadius();\ncolor = pixel;\nif(address.offset != 1)\nreturn;\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\nif(isBadKeypoint(keypoint))\nreturn;\nint idx = findKeypointIndex(address, descriptorSize, extraSize);\nif(idx < firstKeypointIndex || idx > lastKeypointIndex)\nreturn;\ncolor = vec4(pixel.rgb, encodeKeypointFlags(keypoint.flags | KPF_DISCARD));\nif(isKeypointAtInfinity(keypoint))\nreturn;\nreadWindow(keypoint.position, keypoint.lod);\nvec2 derivatives = vec2(0.0f);\nmat2 harris = mat2(0.0f, 0.0f, 0.0f, 0.0f);\nfor(int j = 0; j < windowSize; j++) {\nfor(int i = 0; i < windowSize; i++) {\nderivatives = computeDerivatives(ivec2(i-r, j-r));\nharris += mat2(\nderivatives.x * derivatives.x, derivatives.x * derivatives.y,\nderivatives.x * derivatives.y, derivatives.y * derivatives.y\n) * DISCARD_SCALE;\n}\n}\nfloat delta = harris[0][0] - harris[1][1];\nfloat eigenvalue = 0.5f * ((harris[0][0] + harris[1][1]) - sqrt(delta * delta - 4.0f * harris[0][1] * harris[0][1]));\nint windowArea = windowSize * windowSize;\nfloat cornerness = eigenvalue / float(windowArea);\nint flags = keypoint.flags;\nflags |= int(cornerness < discardThreshold) * KPF_DISCARD;\ncolor = vec4(pixel.rgb, encodeKeypointFlags(flags));\n}'},function(e,t){e.exports='@include "keypoints.glsl"\nuniform sampler2D nextPyramid;\nuniform sampler2D prevPyramid;\nuniform sampler2D prevKeypoints;\nuniform int windowSize;\nuniform int depth;\nuniform int firstKeypointIndex, lastKeypointIndex;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\n#ifndef NUM_ITERATIONS\n#define NUM_ITERATIONS 5\n#endif\n#ifndef MAX_WINDOW_SIZE\n#error Must define MAX_WINDOW_SIZE\n#endif\n#ifndef DISCARD_MARGIN\n#define DISCARD_MARGIN 20\n#endif\n#define NEXT_IMAGE 1\n#define PREV_IMAGE 0\nconst int MAX_WINDOW_SIZE_PLUS = MAX_WINDOW_SIZE + 2;\nconst int MAX_WINDOW_SIZE_PLUS_SQUARED = MAX_WINDOW_SIZE_PLUS * MAX_WINDOW_SIZE_PLUS;\nconst int DBL_MAX_WINDOW_SIZE_PLUS_SQUARED = 2 * MAX_WINDOW_SIZE_PLUS_SQUARED;\nconst int MAX_WINDOW_RADIUS_PLUS = (MAX_WINDOW_SIZE_PLUS - 1) / 2;\n#define windowRadius() ((windowSize - 1) / 2)\nfloat pixelBuffer[DBL_MAX_WINDOW_SIZE_PLUS_SQUARED];\n#define prevPixel(index) pixelBuffer[(index)]\n#define nextPixel(index) pixelBuffer[MAX_WINDOW_SIZE_PLUS_SQUARED + (index)]\n#define pixelIndex(i, j) (((j) + MAX_WINDOW_RADIUS_PLUS) * MAX_WINDOW_SIZE_PLUS + ((i) + MAX_WINDOW_RADIUS_PLUS))\nvoid readWindow(vec2 center, float lod)\n{\nivec2 pyrBaseSize = textureSize(prevPyramid, 0);\nfloat pot = exp2(lod);\nint r = windowRadius();\nivec2 offset; int idx;\n#define readPixelsAt(ox, oy) offset = ivec2((ox), (oy)); idx = pixelIndex(offset.x, offset.y); nextPixel(idx) = pyrSubpixelAtExOffset(nextPyramid, center, lod, pot, offset, pyrBaseSize).g; prevPixel(idx) = pyrSubpixelAtExOffset(prevPyramid, center, lod, pot, offset, pyrBaseSize).g\nfor(int j = 0; j < windowSize; j++) {\nfor(int i = 0; i < windowSize; i++) {\nreadPixelsAt(i-r, j-r);\n}\n}\nint r1 = r+1;\nfor(int k = 0; k < windowSize; k++) {\nreadPixelsAt(-r1, k-r);\nreadPixelsAt( r1, k-r);\nreadPixelsAt(k-r,-r1);\nreadPixelsAt(k-r, r1);\n}\nreadPixelsAt(-r1,-r1);\nreadPixelsAt( r1,-r1);\nreadPixelsAt(-r1, r1);\nreadPixelsAt( r1, r1);\n}\nvec2 computeDerivatives(int imageCode, ivec2 offset)\n{\nconst mat3 derivX = mat3(\n3, 0, -3,\n10, 0, -10,\n3, 0, -3\n);\nconst mat3 derivY = mat3(\n3, 10, 3,\n0, 0, 0,\n-3, -10, -3\n);\nint indexOffset = imageCode * MAX_WINDOW_SIZE_PLUS_SQUARED;\nmat3 window = mat3(\npixelBuffer[indexOffset + pixelIndex(offset.x-1, offset.y-1)],\npixelBuffer[indexOffset + pixelIndex(offset.x+0, offset.y-1)],\npixelBuffer[indexOffset + pixelIndex(offset.x+1, offset.y-1)],\npixelBuffer[indexOffset + pixelIndex(offset.x-1, offset.y+0)],\n0.0f,\npixelBuffer[indexOffset + pixelIndex(offset.x+1, offset.y+0)],\npixelBuffer[indexOffset + pixelIndex(offset.x-1, offset.y+1)],\npixelBuffer[indexOffset + pixelIndex(offset.x+0, offset.y+1)],\npixelBuffer[indexOffset + pixelIndex(offset.x+1, offset.y+1)]\n);\nmat3 fx = matrixCompMult(derivX, window);\nmat3 fy = matrixCompMult(derivY, window);\nconst vec3 ones = vec3(1.0f);\nreturn vec2(\ndot(fx[0], ones) + dot(fx[1], ones) + dot(fx[2], ones),\ndot(fy[0], ones) + dot(fy[1], ones) + dot(fy[2], ones)\n);\n}\nfloat readBufferedPixel(int imageCode, ivec2 offset)\n{\nivec2 limit = ivec2(windowRadius());\noffset = clamp(offset, -limit, limit);\nint indexOffset = imageCode * MAX_WINDOW_SIZE_PLUS_SQUARED;\nreturn pixelBuffer[indexOffset + pixelIndex(offset.x, offset.y)];\n}\nvoid main()\n{\nvec4 pixel = threadPixel(prevKeypoints);\nivec2 thread = threadLocation();\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nint r = windowRadius();\ncolor = pixel;\nif(address.offset > 0)\nreturn;\nKeypoint keypoint = decodeKeypoint(prevKeypoints, encoderLength, address);\nif(isBadKeypoint(keypoint))\nreturn;\nint idx = findKeypointIndex(address, descriptorSize, extraSize);\nif(idx < firstKeypointIndex || idx > lastKeypointIndex)\nreturn;\nvec2 pyrGuess = vec2(0.0f);\nfor(int d = 0; d < depth; d++) {\nfloat lod = float(depth - 1 - d);\nreadWindow(keypoint.position, lod);\nhighp mat2 invHarris = mat2(0.0f, 0.0f, 0.0f, 0.0f);\nfor(int j = 0; j < windowSize; j++) {\nfor(int i = 0; i < windowSize; i++) {\nvec2 derivatives = computeDerivatives(PREV_IMAGE, ivec2(i-r, j-r));\ninvHarris += mat2(\nderivatives.y * derivatives.y, -derivatives.x * derivatives.y,\n-derivatives.x * derivatives.y, derivatives.x * derivatives.x\n);\n}\n}\nconst float minDet = 0.00001f;\nhighp float det = invHarris[0][0] * invHarris[1][1] - invHarris[0][1] * invHarris[1][0];\nhighp vec2 localGuess = vec2(0.0f);\nfor(int k = 0; k < NUM_ITERATIONS; k++) {\nhighp vec2 spaceTime = vec2(0.0f);\nfor(int _y = 0; _y < windowSize; _y++) {\nfor(int _x = 0; _x < windowSize; _x++) {\nint x = _x - r; int y = _y - r;\nvec2 spatialDerivative = computeDerivatives(PREV_IMAGE, ivec2(x, y));\nfloat timeDerivative = readBufferedPixel(NEXT_IMAGE,\nivec2(round(vec2(x, y) + pyrGuess + localGuess))\n) - readBufferedPixel(PREV_IMAGE, ivec2(x, y));\nspaceTime += spatialDerivative * timeDerivative;\n}\n}\nhighp vec2 localOpticalFlow = float(abs(det) >= minDet) * (invHarris * spaceTime / det);\nlocalGuess += localOpticalFlow;\n}\npyrGuess = 2.0f * (pyrGuess + localGuess);\n}\nvec2 opticalFlow = pyrGuess;\nvec2 nextPosition = keypoint.position + opticalFlow;\nvec2 imageSize = vec2(textureSize(nextPyramid, 0));\nfloat margin = float(DISCARD_MARGIN);\nbool isKeypointWithinBoundaries = (\nnextPosition.x >= margin &&\nnextPosition.y >= margin &&\nnextPosition.x <= imageSize.x - margin &&\nnextPosition.y <= imageSize.y - margin\n);\ncolor = isKeypointWithinBoundaries ? encodeKeypointPosition(nextPosition) : encodeKeypointPositionAtInfinity();\n}'},function(e,t){e.exports='@include "colors.glsl"\nuniform sampler2D dest, src;\nuniform int destComponents;\nuniform int srcComponentId;\nvoid main()\n{\nvec4 destPixel = threadPixel(dest);\nvec4 srcPixel = threadPixel(src);\nbvec4 flags = bvec4(\n(destComponents & PIXELCOMPONENT_RED) != 0,\n(destComponents & PIXELCOMPONENT_GREEN) != 0,\n(destComponents & PIXELCOMPONENT_BLUE) != 0,\n(destComponents & PIXELCOMPONENT_ALPHA) != 0\n);\ncolor = mix(destPixel, vec4(srcPixel[srcComponentId]), flags);\n}'},function(e,t){e.exports='@include "colors.glsl"\nuniform sampler2D image;\nuniform int pixelComponents;\nuniform float value;\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nbvec4 flags = bvec4(\n(pixelComponents & PIXELCOMPONENT_RED) != 0,\n(pixelComponents & PIXELCOMPONENT_GREEN) != 0,\n(pixelComponents & PIXELCOMPONENT_BLUE) != 0,\n(pixelComponents & PIXELCOMPONENT_ALPHA) != 0\n);\ncolor = mix(pixel, vec4(value), flags);\n}'},function(e,t){e.exports="uniform float value;\nvoid main()\n{\ncolor = vec4(value);\n}"},function(e,t){e.exports="uniform sampler2D image;\nvoid main() {\nivec2 pos = threadLocation();\npos.y = int(texSize.y) - 1 - pos.y;\ncolor = pixelAt(image, pos);\n}"},function(e,t){e.exports="uniform sampler2D image;\nvoid main()\n{\ncolor = threadPixel(image);\n}"},function(e,t){e.exports="uniform sampler2D image;\nuniform int iterationNumber;\nvoid main()\n{\nivec2 thread = threadLocation();\nivec2 last = outputSize() - ivec2(1);\nint jump = (1 << iterationNumber);\nint clusterLength = jump << 1;\nint clusterMask = clusterLength - 1;\nivec2 clusterPos = ivec2(thread >> (1 + iterationNumber)) << (1 + iterationNumber);\nivec2 next1 = clusterPos + ((thread - clusterPos + ivec2(jump, 0)) & clusterMask);\nivec2 next2 = clusterPos + ((thread - clusterPos + ivec2(0, jump)) & clusterMask);\nivec2 next3 = clusterPos + ((thread - clusterPos + ivec2(jump, jump)) & clusterMask);\nvec4 p0 = texelFetch(image, thread, 0);\nvec4 p1 = texelFetch(image, min(next1, last), 0);\nvec4 p2 = texelFetch(image, min(next2, last), 0);\nvec4 p3 = texelFetch(image, min(next3, last), 0);\nvec4 pmax = max(max(p0, p1), max(p2, p3));\nvec4 pmin = min(min(p0, p1), min(p2, p3));\ncolor = vec4(pmax.r, pmin.g, pmax.r - pmin.g, p0.a);\n}"},function(e,t,n){"use strict";function i(e,t,n){}function r(e,t,n){const{rows:i,columns:r,stride:s,length:o}=e,{value:a}=e.custom;if(i*r!=o)for(let e=0;e<r;e++)t.fill(a,e*s,e*s+i);else t.fill(a,0,o)}function s(e,t,n){const{rows:i,columns:r,stride:s,length:o}=e,[a]=e.strideOfInputs,[c]=n;if(o==e.lengthOfInputs[0]&&i*r==o)return void t.set(c,0,o);let l,d,f,h;for(f=h=d=0;d<r;d++,f+=s,h+=a)for(l=0;l<i;l++)t[f+l]=c[h+l]}function o(e,t,n){const{rows:i,columns:r,stride:s}=e,[o]=e.strideOfInputs,[a]=n;let c,l,d,f;for(d=c=0;c<i;c++,d+=o)for(f=l=0;l<r;l++,f+=s)t[f+c]=a[d+l]}function a(e,t,n){const{rows:i,columns:r,stride:s}=e,[o,a]=e.strideOfInputs,[c,l]=n;let d,f,h,p,u;for(f=0;f<r;f++)for(h=f*s,p=f*o,u=f*a,d=0;d<i;d++)t[h+d]=c[p+d]+l[u+d]}function c(e,t,n){const{rows:i,columns:r,stride:s}=e,[o,a]=e.strideOfInputs,[c,l]=n;let d,f,h,p,u;for(f=0;f<r;f++)for(h=f*s,p=f*o,u=f*a,d=0;d<i;d++)t[h+d]=c[p+d]-l[u+d]}function l(e,t,n){const{rows:i,columns:r,stride:s,length:o}=e,[a,c]=e.columnsOfInputs,[l,d]=e.strideOfInputs,[f,h]=n;if(i*r!=o)for(let e=0;e<r;e++)t.fill(0,e*s,e*s+i);else t.fill(0,0,o);let p,u,m,v,_,g,x;for(v=g=m=0;m<c;m++,v+=s,g+=d)for(_=u=0;u<a;u++,_+=l)for(x=h[g+u],p=0;p<i;p++)t[v+p]+=f[_+p]*x}function d(e,t,n){const{rows:i,columns:r,stride:s,length:o}=e,[a,c]=e.columnsOfInputs,[l,d]=e.rowsOfInputs,[f,h]=e.strideOfInputs,[p,u]=n;let m,v,_,g,x,y,S;for(y=x=_=0;_<c;_++,y+=s,x+=h)for(g=v=0;v<a;v++,g+=f)for(t[S=y+v]=0,m=0;m<d;m++)t[S]+=p[g+m]*u[x+m]}function f(e,t,n){const{rows:i,columns:r,stride:s,length:o}=e,[a,c]=e.columnsOfInputs,[l,d]=e.rowsOfInputs,[f,h]=e.strideOfInputs,[p,u]=n;if(i*r!=o)for(let e=0;e<r;e++)t.fill(0,e*s,e*s+i);else t.fill(0,0,o);let m,v,_,g,x,y,S;for(x=y=v=0;v<a;v++,x+=f,y+=h)for(g=_=0;_<d;_++,g+=s)for(S=u[y+_],m=0;m<i;m++)t[g+m]+=p[x+m]*S}function h(e,t,n){const[i]=e.rowsOfInputs,[r]=e.columnsOfInputs,[s]=e.strideOfInputs,[o,a]=n;let c,l,d,f;for(t.fill(0,0,i),d=l=0;l<r;l++,d+=s)for(f=a[l],c=0;c<i;c++)t[c]+=o[d+c]*f}function p(e,t,n){const{rows:i,columns:r,stride:s}=e,{scalar:o}=e.custom,[a]=n;let c,l,d;for(l=0;l<r;l++)for(d=l*s,c=0;c<i;c++)t[d+c]=a[d+c]*o}function u(e,t,n){const{rows:i,columns:r,stride:s}=e,[o,a]=e.strideOfInputs,[c,l]=n;let d,f,h,p,u;for(f=0;f<r;f++)for(h=f*s,p=f*o,u=f*a,d=0;d<i;d++)t[h+d]=c[p+d]*l[u+d]}function m(e,t,n){const{rows:i,columns:r,stride:s}=e,[o,a]=e.strideOfInputs,[c,l]=n;let d,f,h,p;for(f=0;f<r;f++)for(h=l[f*a],p=f*s,d=0;d<i;d++)t[p+d]=c[d]*h}n.r(t),n.d(t,"nop",(function(){return i})),n.d(t,"fill",(function(){return r})),n.d(t,"copy",(function(){return s})),n.d(t,"transpose",(function(){return o})),n.d(t,"add",(function(){return a})),n.d(t,"subtract",(function(){return c})),n.d(t,"multiply",(function(){return l})),n.d(t,"multiplylt",(function(){return d})),n.d(t,"multiplyrt",(function(){return f})),n.d(t,"multiplyvec",(function(){return h})),n.d(t,"scale",(function(){return p})),n.d(t,"compmult",(function(){return u})),n.d(t,"outer",(function(){return m}))},function(e,t,n){"use strict";function i(e,t,n){const{rows:i,columns:r}=e,[s]=n,[o]=e.rowsOfInputs,[a]=e.columnsOfInputs,[c]=e.strideOfInputs;if(a!==o+1)throw new Error(`Invalid input for backsub: expected ${o} x ${o+1} or ${a-1} x ${a} matrix, but found ${o} x ${a} matrix`);if(i!==o||1!==r)throw new Error(`Invalid output for backsub: expected ${o} x 1 matrix, but found ${i} x ${r} matrix`);const l=o,d=t,f=s.subarray(0,c),h=s.subarray(c);let p,u,m,v=(l-1)*c;for(d[l-1]=f[l-1]/h[v+(l-1)],u=l-2;u>=0;u--){for(d[u]=f[u],p=u+1;p<l;p++)d[u]-=d[p]*h[c*p+u];v-=c,m=h[v+u],d[u]/=m}}function r(e,t,n){const{stride:i,dtype:r}=e,[s,o]=[e.rowsOfInputs[0],e.columnsOfInputs[0]],a=n[2]||this.createTypedArray(r,s*(o+1)),c=Object.assign({},e);c.rows=s,c.columns=o+1,c.stride=s,c.custom={mode:"reduced-Q'x"},c.byteOffset=0,c.length=a.length,this.qr(c,a,[n[0],n[1]]);const l=this.submatrices(c,t,[a],i,[s],[0,o-1,0,0],[[0,o-1,0,o]]);this.backsub(l[0],l[1],l[2])}n.r(t),n.d(t,"backsub",(function(){return i})),n.d(t,"lssolve",(function(){return r}))},function(e,t,n){"use strict";function i(e,t,n){const{stride:i,dtype:r}=e,[s,o]=[e.rows,e.columns],[a,c]=e.rowsOfInputs,[l,d]=e.columnsOfInputs,[f]=e.strideOfInputs,[h,p]=n,{mode:u}=e.custom,m=Object.assign({},e,{custom:null}),v="full-qr"==u||"reduced-qr"==u;let _=[null,null,null];const g=this.createTypedArray(r,2*a*l+l),x=g.subarray(0,a*l),y=g.subarray(a*l,a*l+l),S=g.subarray(a*l+l,2*a*l+l),b=i,w=v?t.subarray(("reduced-qr"==u?l:a)*i):t.subarray(i);if(a<l)throw new Error(`Can't compute the QR decomposition of a ${a} x ${l} matrix`);if(s!=a)throw new Error(`Can't compute the QR decomposition of a ${a} x ${l} matrix: expected an output matrix of ${a} rows, but found a matrix of ${s} rows`);let A,O,E,I,T,M,L,P;for(h.length!=w.length?(_=this.submatrices(m,w,[h],b,[f],[0,a-1,0,l-1],[[0,a-1,0,l-1]]),this.copy(_[0],_[1],_[2])):w.set(h,0,h.length),E=0;E<l;E++){for(L=E*a+E,P=E*b+E,I=a-E,M=+(w[P]>=0)-+(w[P]<0),A=0;A<I;A++)x[L+A]=w[P+A];for(x[L]+=M*this.norm2(x,L,I),T=this.norm2(x,L,I),A=L+I-1;A>=L;A--)x[A]/=T;_=this.submatrices(m,y,[x,w],1,[a,b],[0,0,0,l-E-1],[[E,a-1,E,E],[E,a-1,E,l-1]]),this.multiplylt(_[0],_[1],_[2]),_=this.submatrices(m,S,[x,y],a,[a,1],[0,a-E-1,0,l-E-1],[[E,a-1,E,E],[0,0,0,l-E-1]]),this.outer(_[0],_[1],_[2]),_=this.submatrices(m,w,[w,S],b,[b,a],[E,a-1,E,l-1],[[E,a-1,E,l-1],[0,a-E-1,0,l-E-1]]),this.addInPlace(_[0],_[1],_[2],1,-2)}switch(u){case"full-qr":{const e=i,n=t.subarray(0,e*a).fill(0);let r,c,d;if(s!=a||o!=l+a)throw new Error(`Can't compute the full QR decomposition of a ${a} x ${l} matrix: expected an output matrix of size ${a} x ${l+a}, found ${s} x ${o}`);for(O=0;O<a;O++)for(c=O*e,n[c+O]=1,E=l-1;E>=0;E--)for(r=E*a,d=-2*this.dot(n,x,c+E,r+E,a-E),A=a-1;A>=E;A--)n[c+A]+=d*x[r+A];break}case"reduced-qr":{const e=i,n=t.subarray(0,e*l).fill(0);let r,c,d;if(s!=a||o!=l+l)throw new Error(`Can't compute the reduced QR decomposition of a ${a} x ${l} matrix: expected an output matrix of size ${a} x ${l+l}, found ${s} x ${o}`);for(O=0;O<l;O++)for(c=O*e,n[c+O]=1,E=l-1;E>=0;E--)for(r=E*a,d=-2*this.dot(n,x,c+E,r+E,a-E),A=a-1;A>=E;A--)n[c+A]+=d*x[r+A];break}case"Q'x":{const e=i,n=t.subarray(0,e),r=a,f=l;let h,u;if(r!=c||1!=d)throw new Error(`QR decomposition: the input vector is expected to be ${r} x 1, but is ${c} x ${d}`);if(r!=s||1+f!=o)throw new Error(`QR decomposition: the output matrix is expected to be ${r} x ${1+f}, but is ${s} x ${o}`);for(A=0;A<r;A++)n[A]=p[A];for(E=0;E<f;E++)for(h=E*a,u=-2*this.dot(n,x,E,h+E,r-E),A=E;A<r;A++)n[A]+=u*x[h+A];break}case"Qx":{const e=i,n=t.subarray(0,e),r=a,f=l;let h,u;if(r!=c||1!=d)throw new Error(`QR decomposition: the input vector is expected to be ${r} x 1, but is ${c} x ${d}`);if(r!=s||1+f!=o)throw new Error(`QR decomposition: the output matrix is expected to be ${r} x ${1+f}, but is ${s} x ${o}`);for(A=0;A<r;A++)n[A]=p[A];for(E=f-1;E>=0;E--)for(h=E*a,u=-2*this.dot(n,x,E,h+E,r-E),A=E;A<r;A++)n[A]+=u*x[h+A];break}case"reduced-Q'x":{const e=a,n=l,i=t.subarray(0,n),r=S.subarray(0,e);let f,h;if(e!=c||1!=d)throw new Error(`QR decomposition: the input vector is expected to be ${e} x 1, but is ${c} x ${d}`);if(e!=s||1+n!=o)throw new Error(`QR decomposition: the output matrix is expected to be ${e} x ${1+n}, but is ${s} x ${o}`);for(O=0;O<n;O++){for(r.fill(0),r[O]=1,E=n-1;E>=0;E--)for(f=E*a,h=-2*this.dot(r,x,E,f+E,e-E),A=e-1;A>=E;A--)r[A]+=h*x[f+A];i[O]=this.dot(p,r,0,0,e)}break}default:throw new Error(`QR decomposition: unknown mode "${u}"`)}}n.r(t),n.d(t,"qr",(function(){return i}))},function(e,t,n){"use strict";function i(e,...t){return this.MatrixType.createTypedArray(e,...t)}function r(e,t=0,n=e.length){let i,r=0,s=t+n;for(i=t;i<s;i++)r+=e[i]*e[i];return Math.sqrt(r)}function s(e,t,n=0,i=0,r=e.length){let s,o=0;for(s=0;s<r;s++)o+=e[n+s]*t[i+s];return o}function o(e,t,n,i,r){const{rows:s,columns:o,stride:a}=e,[c,l]=e.strideOfInputs,[d,f]=n;let h,p,u,m,v;for(m=v=u=p=0;p<o;p++,u+=a,m+=c,v+=l)for(h=0;h<s;h++)t[u+h]=i*d[m+h]+r*f[v+h]}function a(e,t,n,i,r,s,o){let a,c;for(e.rows=s[1]-s[0]+1,e.columns=s[3]-s[2]+1,e.stride=i,t=t.subarray(s[2]*i+s[0],s[3]*i+s[1]+1),e.length=t.length,e.byteOffset=t.byteOffset,a=n.length-1;a>=0;a--)c=o[a],e.rowsOfInputs[a]=c[1]-c[0]+1,e.columnsOfInputs[a]=c[3]-c[2]+1,e.strideOfInputs[a]=r[a],n[a]=n[a].subarray(c[2]*r[a]+c[0],c[3]*r[a]+c[1]+1),e.lengthOfInputs[a]=n[a].length,e.byteOffsetOfInputs[a]=n[a].byteOffset;return[e,t,n]}n.r(t),n.d(t,"createTypedArray",(function(){return i})),n.d(t,"norm2",(function(){return r})),n.d(t,"dot",(function(){return s})),n.d(t,"addInPlace",(function(){return o})),n.d(t,"submatrices",(function(){return a}))},function(e,t,n){"use strict";n.r(t),n.d(t,"Speedy",(function(){return yn}));var i=n(1),r=n(5),s=n(0);const o=navigator.userAgent.includes("Firefox");class a{static getError(e){const t=e.getError(),n=["NO_ERROR","INVALID_ENUM","INVALID_VALUE","INVALID_OPERATION","INVALID_FRAMEBUFFER_OPERATION","OUT_OF_MEMORY","CONTEXT_LOST_WEBGL"].find(n=>e[n]==t)||"Unknown";return new s.e(n)}static createShader(e,t,n){const i=e.createShader(t);return e.shaderSource(i,n),e.compileShader(i),i}static createProgram(e,t,n){const i=e.createProgram(),r=a.createShader(e,e.VERTEX_SHADER,t),o=a.createShader(e,e.FRAGMENT_SHADER,n);if(e.attachShader(i,r),e.attachShader(i,o),e.linkProgram(i),e.validateProgram(i),!e.getProgramParameter(i,e.LINK_STATUS)&&!e.isContextLost()){const t=[e.getShaderInfoLog(o),e.getShaderInfoLog(r),e.getProgramInfoLog(i)];e.deleteProgram(i),e.deleteShader(o),e.deleteShader(r);const a=e=>Math.max(0,2-Math.floor(Math.log10(e))),c=e=>Array(a(e)).fill(" ").join("")+e+". ",l=n.split("\n").map((e,t)=>c(1+t)+e).join("\n");throw new s.e("Can't create shader.\n\n---------- ERROR ----------\n"+t.join("\n")+"\n\n---------- SOURCE CODE ----------\n"+l)}return i}static createTexture(e,t,n){if(t<=0||n<=0)throw new s.f("Invalid dimensions given to createTexture()");const i=e.createTexture();return e.bindTexture(e.TEXTURE_2D,i),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.MIRRORED_REPEAT),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.MIRRORED_REPEAT),e.texImage2D(e.TEXTURE_2D,0,e.RGBA8,t,n,0,e.RGBA,e.UNSIGNED_BYTE,null),e.bindTexture(e.TEXTURE_2D,null),i}static destroyTexture(e,t){return e.deleteTexture(t),null}static uploadToTexture(e,t,n,i,r,s=0){return e.bindTexture(e.TEXTURE_2D,t),e.texImage2D(e.TEXTURE_2D,s,e.RGBA8,n,i,0,e.RGBA,e.UNSIGNED_BYTE,r),e.bindTexture(e.TEXTURE_2D,null),t}static copyToTexture(e,t,n,i,r,s,o,a=0){return e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,n),e.bindFramebuffer(e.FRAMEBUFFER,t),e.copyTexSubImage2D(e.TEXTURE_2D,a,0,0,i,r,s,o),e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindTexture(e.TEXTURE_2D,null),n}static generateMipmap(e,t){e.bindTexture(e.TEXTURE_2D,t),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR_MIPMAP_NEAREST),e.generateMipmap(e.TEXTURE_2D),e.bindTexture(e.TEXTURE_2D,null)}static bindTextures(e,t,n){const i=Object.keys(t);if(!e.isContextLost()){if(i.length>e.MAX_COMBINED_TEXTURE_IMAGE_UNITS)throw new s.e(`Can't bind ${i.length} textures to a program: max is ${e.MAX_COMBINED_TEXTURE_IMAGE_UNITS}`);for(let r=0;r<i.length;r++)e.activeTexture(e.TEXTURE0+r),e.bindTexture(e.TEXTURE_2D,t[i[r]]),e.uniform1i(n[i[r]],r)}}static createFramebuffer(e,t){const n=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,n),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0);const i=e.checkFramebufferStatus(e.FRAMEBUFFER);if(i!=e.FRAMEBUFFER_COMPLETE){const t=["FRAMEBUFFER_UNSUPPORTED","FRAMEBUFFER_INCOMPLETE_ATTACHMENT","FRAMEBUFFER_INCOMPLETE_DIMENSIONS","FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT","FRAMEBUFFER_INCOMPLETE_MULTISAMPLE"].filter(t=>e[t]===i)[0]||"unknown error";throw new s.e(`Can't create framebuffer: ${t} (${i})`)}return e.bindFramebuffer(e.FRAMEBUFFER,null),n}static destroyFramebuffer(e,t){return e.deleteFramebuffer(t),null}static clientWaitAsync(e,t,n=0){return this._checkStatus=this._checkStatus||(this._checkStatus=function e(t,n,r,s,c){const l=t.clientWaitSync(n,r,0);l==t.TIMEOUT_EXPIRED?i.a.setZeroTimeout(()=>e.call(this,t,n,r,s,c)):l==t.WAIT_FAILED?o&&t.getError()==t.NO_ERROR?i.a.setZeroTimeout(()=>e.call(this,t,n,r,s,c)):c(a.getError(t)):s()}),new r.a((i,r)=>{this._checkStatus(e,t,n,i,r)})}static getBufferSubDataAsync(e,t,n,i,r,o=0,c=0){const l=e.fenceSync(e.SYNC_GPU_COMMANDS_COMPLETE,0),d=performance.now();return e.flush(),a.clientWaitAsync(e,l).then(()=>(e.bindBuffer(n,t),e.getBufferSubData(n,i,r,o,c),e.bindBuffer(n,null),performance.now()-d)).catch(e=>{throw new s.g("Can't getBufferSubDataAsync(): error in clientWaitAsync()",e)}).finally(()=>{e.deleteSync(l)})}static readPixelsViaPBO(e,t,n,i,r,o,c=null){const l=e.createBuffer();if(!(t.byteLength>=r*o*4))throw new s.f("Can't read pixels: invalid buffer size");return e.bindBuffer(e.PIXEL_PACK_BUFFER,l),e.bufferData(e.PIXEL_PACK_BUFFER,t.byteLength,e.STREAM_READ),c?(e.bindFramebuffer(e.FRAMEBUFFER,c),e.readPixels(n,i,r,o,e.RGBA,e.UNSIGNED_BYTE,0),e.bindFramebuffer(e.FRAMEBUFFER,null)):e.readPixels(n,i,r,o,e.RGBA,e.UNSIGNED_BYTE,0),e.bindBuffer(e.PIXEL_PACK_BUFFER,null),a.getBufferSubDataAsync(e,l,e.PIXEL_PACK_BUFFER,0,t,0,0).then(e=>e).catch(e=>{throw new s.g("Can't read pixels",e)}).finally(()=>{e.deleteBuffer(l)})}}var c=n(4);class l{constructor(e,t,n){this._gl=e,this._width=Math.max(1,0|t),this._height=Math.max(1,0|n),this._glTexture=a.createTexture(this._gl,this._width,this._height),this._hasMipmaps=!1}release(){if(null===this._glTexture)throw new s.g("The SpeedyTexture has already been released");return this._glTexture=a.destroyTexture(this._gl,this._glTexture),this._width=this._height=0,this._hasMipmaps=!1,null}upload(e){return this._hasMipmaps=!1,a.uploadToTexture(this._gl,this._glTexture,this._width,this._height,e,0),this}generatePyramid(e,t=!0){if(this._hasMipmaps)return this;if(i.a.assert(e.gl===this._gl),a.generateMipmap(this._gl,this._glTexture),this._hasMipmaps=!0,t){let t=this,n=null;for(let i=1;i<c.k;i++)n=e.programs.pyramids(i-1),t=n.reduce(t),n.exportTo(this,i)}return this}discardPyramid(){this._hasMipmaps=!1}get glTexture(){return this._glTexture}get width(){return this._width}get height(){return this._height}get gl(){return this._gl}}const d=Object.freeze({position:0,texCoord:1}),f=Object.freeze({sampler2D:"uniform1i",float:"uniform1f",int:"uniform1i",uint:"uniform1ui",bool:"uniform1i",vec2:"uniform2f",vec3:"uniform3f",vec4:"uniform4f",ivec2:"uniform2i",ivec3:"uniform3i",ivec4:"uniform4i",uvec2:"uniform2ui",uvec3:"uniform3ui",uvec4:"uniform4ui",bvec2:"uniform2i",bvec3:"uniform3i",bvec4:"uniform4i"}),h=new WeakMap;class p extends Function{constructor(e,t,n={}){return super("...args","return this._self._call(...args)"),this._self=this.bind(this),this._self._init(e,t,n),this._self}_init(e,t,n){if(this._gl=e,this._program=a.createProgram(e,t.vertexSource,t.fragmentSource),this._geometry=this._createGeometry(e),this._argnames=t.arguments,this._argIsArray=new Array(this._argnames.length).fill(!1),this._options=Object.freeze({output:[e.drawingBufferWidth,e.drawingBufferHeight],renderToTexture:!0,recycleTexture:!0,pingpong:!1,...n}),this._width=Math.max(1,0|this._options.output[0]),this._height=Math.max(1,0|this._options.output[1]),this._dirtySize=!0,this._uniform=new Map,this._ubo=null,this._texture=this._options.renderToTexture?new Array(this._options.pingpong?2:1).fill(null):[],this._fbo=this._options.renderToTexture?new Array(this._options.pingpong?2:1).fill(null):[],this._textureIndex=0,this._pixelBuffer=new Array(1).fill(null),this._pixelBufferSize=[0,0],this._pboConsumerQueue=new Array(1).fill(0).map((e,t)=>t),this._pboProducerQueue=[],this._options.pingpong&&!this._options.renderToTexture)throw new s.g("Pingpong rendering can only be used when rendering to textures");if(e.isContextLost())throw new s.g("Can't initialize SpeedyProgram: lost context");const i=e.canvas;this._width>i.width&&(i.width=this._width),this._height>i.height&&(i.height=this._height),e.bindAttribLocation(this._program,d.position,t.attributes.position),e.bindAttribLocation(this._program,d.texCoord,t.attributes.texCoord);for(let t=0;t<this._texture.length;t++)this._texture[t]=new l(e,this._width,this._height),this._fbo[t]=a.createFramebuffer(e,this._texture[t].glTexture);e.useProgram(this._program);for(const n of t.uniforms){const i=t.uniformType(n),r=e.getUniformLocation(this._program,n);this._uniform.set(n,new m(i,r))}for(let e=0;e<this._argnames.length;e++){const t=this._argnames[e];if(!this._uniform.has(t)&&(this._argIsArray[e]=this._uniform.has(t+"[0]"),!this._argIsArray[e]))throw new s.g(`Expected uniform "${t}", as declared in the argument list`)}}_call(...e){const t=this._gl,n=this._options,i=this._argnames;if(e.length!=i.length)throw new s.f("Can't run shader: incorrect number of arguments");if(t.isContextLost())return this._texture[this._textureIndex];if(t.useProgram(this._program),this._dirtySize){const e=this._uniform.get("texSize");t.uniform2f(e.location,this._width,this._height),this._dirtySize=!1}for(let t=0,n=0;t<e.length;t++){const r=i[t];if(this._argIsArray[t]){const i=e[t];if(this._uniform.has(`${r}[${i.length}]`))throw new s.f(`Can't run shader: too few elements in the "${r}" array`);for(let e=0,t=void 0;void 0!==(t=this._uniform.get(`${r}[${e}]`));e++)n=this._setUniform(t,i[e],n)}else{const i=this._uniform.get(r);n=this._setUniform(i,e[t],n)}}null!==this._ubo&&this._ubo.update();const r=n.renderToTexture?this._fbo[this._textureIndex]:null;if(t.bindFramebuffer(t.FRAMEBUFFER,r),t.viewport(0,0,this._width,this._height),t.drawArrays(t.TRIANGLE_STRIP,0,4),t.bindFramebuffer(t.FRAMEBUFFER,null),null!==r){const e=this._texture[this._textureIndex];e.discardPyramid();let i=e;return n.recycleTexture||(i=new l(t,this._width,this._height),a.copyToTexture(t,r,i.glTexture,0,0,this._width,this._height)),this._pingpong(),i}return null}resize(e,t){const n=this._gl,i=this._width,r=this._height;if(n.isContextLost())return;if(e=Math.max(1,0|e),t=Math.max(1,0|t),e===this._width&&t===this._height)return;this._width=e,this._height=t,this._dirtySize=!0,this._reallocatePixelBuffers(e,t);const s=this._texture.length,o=s>0?new Uint8Array(e*t*4):null;for(let c=0;c<s;c++){const s=new l(n,e,t);s.upload(o),a.copyToTexture(n,this._fbo[c],s.glTexture,0,0,Math.min(e,i),Math.min(t,r)),n.bindFramebuffer(n.FRAMEBUFFER,this._fbo[c]),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,s.glTexture,0),n.bindFramebuffer(n.FRAMEBUFFER,null),this._texture[c].release(),this._texture[c]=s}}clear(e=0,t=0,n=0,i=0){const r=this._gl,s=this._texture[this._textureIndex];if(r.isContextLost())return s;for(let s=0;s<this._fbo.length;s++)r.bindFramebuffer(r.FRAMEBUFFER,this._fbo[s]),r.viewport(0,0,this._width,this._height),r.clearColor(e,t,n,i),r.clear(r.COLOR_BUFFER_BIT),r.bindFramebuffer(r.FRAMEBUFFER,null);return this._pingpong(),s}readPixelsSync(e=0,t=0,n=this._width,i=this._height){const r=this._gl;if(!this._options.renderToTexture)throw new s.g("Can't read pixels from a SpeedyProgram that doesn't render to an internal texture");if(r.isContextLost())return this._pixelBuffer[0];n=Math.max(0,Math.min(n,this._width)),i=Math.max(0,Math.min(i,this._height)),e=Math.max(0,Math.min(e,n-1)),t=Math.max(0,Math.min(t,i-1)),null==this._pixelBuffer[0]&&this._reallocatePixelBuffers(this._width,this._height);const o=this._fbo[this._options.pingpong?1-this._textureIndex:this._textureIndex];return r.bindFramebuffer(r.FRAMEBUFFER,o),r.readPixels(e,t,n,i,r.RGBA,r.UNSIGNED_BYTE,this._pixelBuffer[0]),r.bindFramebuffer(r.FRAMEBUFFER,null),this._pixelBuffer[0]}readPixelsAsync(e=!0,t=0,n=0,i=this._width,o=this._height){const c=this._gl;if(!this._options.renderToTexture)throw new s.g("Can't read pixels from a SpeedyProgram that doesn't render to an internal texture");if(c.isContextLost())return r.a.resolve(this._pixelBuffer[0]);i=Math.max(0,Math.min(i,this._width)),o=Math.max(0,Math.min(o,this._height)),t=Math.max(0,Math.min(t,i-1)),n=Math.max(0,Math.min(n,o-1)),null==this._pixelBuffer[0]&&this._reallocatePixelBuffers(this._width,this._height);const l=this._fbo[this._options.pingpong?1-this._textureIndex:this._textureIndex];if(!e)return a.readPixelsViaPBO(c,this._pixelBuffer[0],t,n,i,o,l).then(()=>this._pixelBuffer[0]);if(this._pboProducerQueue.length>0){const e=this._pboProducerQueue.shift();a.readPixelsViaPBO(c,this._pixelBuffer[e],t,n,i,o,l).then(()=>{this._pboConsumerQueue.push(e)})}else this._waitForQueueNotEmpty(this._pboProducerQueue).then(()=>{const e=this._pboProducerQueue.shift();a.readPixelsViaPBO(c,this._pixelBuffer[e],t,n,i,o,l).then(()=>{this._pboConsumerQueue.push(e)})}).turbocharge();if(this._pboConsumerQueue.length>0){const e=this._pboConsumerQueue.shift();return new r.a(t=>{t(this._pixelBuffer[e]),this._pboProducerQueue.push(e)})}return new r.a(e=>{this._waitForQueueNotEmpty(this._pboConsumerQueue).then(()=>{const t=this._pboConsumerQueue.shift();e(this._pixelBuffer[t]),this._pboProducerQueue.push(t)}).turbocharge()})}setUBO(e,t){null===this._ubo&&(this._ubo=new v(this._gl,this._program)),this._ubo.set(e,t)}exportTo(e,t=0){const n=this._gl,r=this._fbo[this._textureIndex],o=1<<(t|=0),c=Math.max(1,Math.floor(e.width/o)),l=Math.max(1,Math.floor(e.height/o));if(i.a.assert(this._width===c&&this._height===l),this._options.pingpong)throw new s.i("Can't copy the output of a pingpong-enabled SpeedyProgram");a.copyToTexture(n,r,e.glTexture,0,0,this._width,this._height,t)}get width(){return this._width}get height(){return this._height}_pingpong(){this._options.pingpong&&(this._textureIndex=1-this._textureIndex)}_setUniform(e,t,n){const i=this._gl;if("sampler2D"==e.type){if(n>i.MAX_COMBINED_TEXTURE_IMAGE_UNITS)throw new s.i(`Can't bind ${n} textures to a program: max is ${i.MAX_COMBINED_TEXTURE_IMAGE_UNITS}`);if(t===this._texture[this._textureIndex])throw new s.i("Can't run shader: cannot use its output texture as an input to itself");if(null==t)throw new s.f("Can't run shader: cannot use null as an input texture");i.activeTexture(i.TEXTURE0+n),i.bindTexture(i.TEXTURE_2D,t.glTexture),i.uniform1i(e.location,n),n++}else if("number"==typeof t||"boolean"==typeof t)i[e.setter](e.location,t);else{if(!Array.isArray(t)||t.length!==e.length)throw new s.f(`Can't run shader: unrecognized argument "${t}"`);i[e.setter](e.location,...t)}return n}_createGeometry(e){if(h.has(e))return h.get(e);const t=e.createVertexArray(),n=[e.createBuffer(),e.createBuffer()];e.bindVertexArray(t),e.bindBuffer(e.ARRAY_BUFFER,n[0]),e.bufferData(e.ARRAY_BUFFER,new Float32Array([-1,-1,1,-1,-1,1,1,1]),e.STATIC_DRAW),e.enableVertexAttribArray(d.position),e.vertexAttribPointer(d.position,2,e.FLOAT,!1,0,0),e.bindBuffer(e.ARRAY_BUFFER,n[1]),e.bufferData(e.ARRAY_BUFFER,new Float32Array([0,0,1,0,0,1,1,1]),e.STATIC_DRAW),e.enableVertexAttribArray(d.texCoord),e.vertexAttribPointer(d.texCoord,2,e.FLOAT,!1,0,0),e.bindBuffer(e.ARRAY_BUFFER,null);const i=new u(t,n[0],n[1]);return h.set(e,i),i}_reallocatePixelBuffers(e,t){if(!(e*t<=this._pixelBufferSize[0]*this._pixelBufferSize[1])){this._pixelBufferSize[0]=e,this._pixelBufferSize[1]=t;for(let n=0;n<1;n++){const i=this._pixelBuffer[n];this._pixelBuffer[n]=new Uint8Array(e*t*4),this._pixelBuffer[n].fill(255,0,4),i&&(i.length>this._pixelBuffer[n].length?this._pixelBuffer[n].set(i.slice(0,this._pixelBuffer[n].length)):this._pixelBuffer[n].set(i))}}}_waitForQueueNotEmpty(e){return new r.a(t=>{!function n(){e.length>0?t():setTimeout(n,0)}()})}}function u(e,t,n){return this.vao=e,this.vbo=Object.freeze({position:t,texCoord:n}),Object.freeze(this)}function m(e,t){if(this.type=String(e),!Object.prototype.hasOwnProperty.call(f,this.type))throw new s.i("Unsupported uniform type: "+this.type);return this.location=t,this.setter=f[this.type],this.length=0|this.setter.match(/^uniform(\d)/)[1],Object.freeze(this)}function v(e,t){this._gl=e,this._program=t,this._nextIndex=0,this._ubo=Object.create(null)}v.prototype.set=function(e,t){const n=this._gl;void 0===this._ubo[e]&&(this._ubo[e]={buffer:n.createBuffer(),blockBindingIndex:this._nextIndex++,blockIndex:null,data:null});const i=this._ubo[e];if(null===i.blockIndex){const t=n.getUniformBlockIndex(this._program,e);n.uniformBlockBinding(this._program,t,i.blockBindingIndex),i.blockIndex=t}i.data=t},v.prototype.update=function(){const e=this._gl;for(const t in this._ubo){const n=this._ubo[t];e.bindBuffer(e.UNIFORM_BUFFER,n.buffer),e.bufferData(e.UNIFORM_BUFFER,n.data.byteLength,e.DYNAMIC_DRAW),e.bufferData(e.UNIFORM_BUFFER,n.data,e.DYNAMIC_DRAW),e.bindBufferBase(e.UNIFORM_BUFFER,n.blockBindingIndex,n.buffer),e.bindBuffer(e.UNIFORM_BUFFER,null)}};class _{constructor(e,t,n){this._gpu=e,this._width=t,this._height=n}declare(e,t,n={}){return Object.defineProperty(this,e,{get:(()=>{const i="__k_"+e;return function(){return this[i]||(this[i]=this._createProgram(t,n))}.bind(this)})()}),this}compose(e,...t){return Object.defineProperty(this,e,{get:(()=>{const n="__c_"+e;return function(){return this[n]||(this[n]=2==t.length?(()=>(t=t.map(e=>this[e]),function(e,...n){return t[1](t[0](e,...n),...n)}))():3==t.length?(()=>(t=t.map(e=>this[e]),function(e,...n){return t[2](t[1](t[0](e,...n),...n),...n)}))():4==t.length?(()=>(t=t.map(e=>this[e]),function(e,...n){return t[3](t[2](t[1](t[0](e,...n),...n),...n),...n)}))():(()=>(t=t.map(e=>this[e]),function(e,...n){return t.reduce((e,t)=>t(e,...n),e)}))())}.bind(this)})()}),this}get program(){return this._helpers||(this.helpers={hasTextureSize:(e,t)=>({output:[Math.max(1,0|e),Math.max(1,0|t)]}),displaysGraphics:()=>({renderToTexture:!1}),doesNotRecycleTextures:()=>({recycleTexture:!1}),usesPingpongRendering:()=>({pingpong:!0})})}_createProgram(e,t={}){return new p(this._gpu.gl,e,{output:[this._width,this._height],...t})}}var g=n(2),x=n(6);const y=Object(g.b)("utils/identity.glsl").withArguments("image"),S=Object(g.b)("utils/flip-y.glsl").withArguments("image"),b=Object(g.b)("utils/fill.glsl").withArguments("value"),w=Object(g.b)("utils/fill-components.glsl").withArguments("image","pixelComponents","value"),A=Object(g.b)("utils/copy-components.glsl").withArguments("dest","src","destComponents","srcComponentId"),O=Object(g.b)("utils/scan-minmax2d.glsl").withArguments("image","iterationNumber");class E extends _{constructor(e,t,n){super(e,t,n),this.declare("identity",y).declare("output",S,{...this.program.displaysGraphics()}).declare("clone",y,{...this.program.doesNotRecycleTextures()}).declare("flipY",S).declare("fill",b).declare("fillComponents",w).declare("_copyComponents",A).declare("_scanMinMax2D",O,{...this.program.usesPingpongRendering()})}scanMax(e,t){const n=this._scanMinMax(e,t);return this.copyComponents(e,n,t,x.d.RED)}scanMin(e,t){const n=this._scanMinMax(e,t);return this.copyComponents(e,n,t,x.d.GREEN)}copyComponents(e,t,n,i){if(!x.a.hasOwnProperty(i))throw new s.f("Invalid srcComponent: "+i);const r=x.a[i];return this._copyComponents(e,t,n,r)}_scanMinMax(e,t){const n=0|Math.ceil(Math.log2(Math.max(this._width,this._height)));let i=this.copyComponents(e,e,x.d.ALL,t);for(let e=0;e<n;e++)i=this._scanMinMax2D(i,e);return i}}const I=Object(g.b)("colors/rgb2grey.glsl").withArguments("image");class T extends _{constructor(e,t,n){super(e,t,n),this.declare("rgb2grey",I)}}var M=n(3),L=n(9);const P=Object(g.b)("filters/fast-median.glsl").withArguments("image").withDefines({WINDOW_SIZE:3}),R=Object(g.b)("filters/fast-median.glsl").withArguments("image").withDefines({WINDOW_SIZE:5}),k=e=>Math.max(1,e/6);class C extends _{constructor(e,t,n){super(e,t,n),this.compose("gauss3","_gauss3x","_gauss3y").compose("gauss5","_gauss5x","_gauss5y").compose("gauss7","_gauss7x","_gauss7y").compose("gauss9","_gauss9x","_gauss9y").compose("gauss11","_gauss11x","_gauss11y").compose("box3","_box3x","_box3y").compose("box5","_box5x","_box5y").compose("box7","_box7x","_box7y").compose("box9","_box9x","_box9y").compose("box11","_box11x","_box11y").declare("median3",P).declare("median5",R).declare("median7",Object(L.median)(7)).compose("dog16_1","_dog16_1x","_dog16_1y").declare("texConv2D3",Object(M.texConv2D)(3),{...this.program.usesPingpongRendering()}).declare("texConv2D5",Object(M.texConv2D)(5),{...this.program.usesPingpongRendering()}).declare("texConv2D7",Object(M.texConv2D)(7),{...this.program.usesPingpongRendering()}).compose("texConvXY3","texConvX3","texConvY3").declare("texConvX3",Object(M.texConvX)(3)).declare("texConvY3",Object(M.texConvY)(3)).compose("texConvXY5","texConvX5","texConvY5").declare("texConvX5",Object(M.texConvX)(5)).declare("texConvY5",Object(M.texConvY)(5)).compose("texConvXY7","texConvX7","texConvY7").declare("texConvX7",Object(M.texConvX)(7)).declare("texConvY7",Object(M.texConvY)(7)).compose("texConvXY9","texConvX9","texConvY9").declare("texConvX9",Object(M.texConvX)(9)).declare("texConvY9",Object(M.texConvY)(9)).compose("texConvXY11","texConvX11","texConvY11").declare("texConvX11",Object(M.texConvX)(11)).declare("texConvY11",Object(M.texConvY)(11)).declare("createKernel3x3",Object(M.createKernel2D)(3),{...this.program.hasTextureSize(3,3),...this.program.doesNotRecycleTextures()}).declare("createKernel5x5",Object(M.createKernel2D)(5),{...this.program.hasTextureSize(5,5),...this.program.doesNotRecycleTextures()}).declare("createKernel7x7",Object(M.createKernel2D)(7),{...this.program.hasTextureSize(7,7),...this.program.doesNotRecycleTextures()}).declare("createKernel3x1",Object(M.createKernel1D)(3),{...this.program.hasTextureSize(3,1),...this.program.doesNotRecycleTextures()}).declare("createKernel5x1",Object(M.createKernel1D)(5),{...this.program.hasTextureSize(5,1),...this.program.doesNotRecycleTextures()}).declare("createKernel7x1",Object(M.createKernel1D)(7),{...this.program.hasTextureSize(7,1),...this.program.doesNotRecycleTextures()}).declare("createKernel9x1",Object(M.createKernel1D)(9),{...this.program.hasTextureSize(9,1),...this.program.doesNotRecycleTextures()}).declare("createKernel11x1",Object(M.createKernel1D)(11),{...this.program.hasTextureSize(11,1),...this.program.doesNotRecycleTextures()}).declare("_gauss3x",Object(M.convX)([.25,.5,.25])).declare("_gauss3y",Object(M.convY)([.25,.5,.25])).declare("_gauss5x",Object(M.convX)([.05,.25,.4,.25,.05])).declare("_gauss5y",Object(M.convY)([.05,.25,.4,.25,.05])).declare("_gauss7x",Object(M.convX)(i.a.gaussianKernel(k(7),7))).declare("_gauss7y",Object(M.convY)(i.a.gaussianKernel(k(7),7))).declare("_gauss9x",Object(M.convX)(i.a.gaussianKernel(k(9),9))).declare("_gauss9y",Object(M.convY)(i.a.gaussianKernel(k(9),9))).declare("_gauss11x",Object(M.convX)(i.a.gaussianKernel(k(11),11))).declare("_gauss11y",Object(M.convY)(i.a.gaussianKernel(k(11),11))).declare("_box3x",Object(M.convX)([1,1,1],1/3)).declare("_box3y",Object(M.convY)([1,1,1],1/3)).declare("_box5x",Object(M.convX)([1,1,1,1,1],.2)).declare("_box5y",Object(M.convY)([1,1,1,1,1],.2)).declare("_box7x",Object(M.convX)([1,1,1,1,1,1,1],1/7)).declare("_box7y",Object(M.convY)([1,1,1,1,1,1,1],1/7)).declare("_box9x",Object(M.convX)([1,1,1,1,1,1,1,1,1],1/9)).declare("_box9y",Object(M.convY)([1,1,1,1,1,1,1,1,1],1/9)).declare("_box11x",Object(M.convX)([1,1,1,1,1,1,1,1,1,1,1],1/11)).declare("_box11y",Object(M.convY)([1,1,1,1,1,1,1,1,1,1,1],1/11)).declare("_dog16_1x",Object(M.convX)([.011725,.038976,.055137,-.037649,-.136377,-.037649,.055137,.038976,.011725])).declare("_dog16_1y",Object(M.convY)([.011725,.038976,.055137,-.037649,-.136377,-.037649,.055137,.038976,.011725]))}}const z=Object(g.b)("keypoints/fast/fast9.glsl").withArguments("image","threshold"),D=Object(g.b)("keypoints/fast/fast7.glsl").withArguments("image","threshold"),K=Object(g.b)("keypoints/fast/fast5.glsl").withArguments("image","threshold"),N=Object(g.b)("keypoints/fast/fast-score16.glsl").withArguments("image","threshold"),F=Object(g.b)("keypoints/fast/fast-score12.glsl").withArguments("image","threshold"),j=Object(g.b)("keypoints/fast/fast-score8.glsl").withArguments("image","threshold"),B=Object(g.b)("keypoints/fast/multiscale-fast.glsl").withArguments("pyramid","threshold","numberOfOctaves","lodStep"),U=Object(g.b)("keypoints/fast/encode-fast-score.glsl").withArguments("image"),$=Object(g.b)("keypoints/harris/multiscale-harris.glsl").withArguments("pyramid","windowSize","numberOfOctaves","lodStep","sobelDerivatives"),X=Object(g.b)("keypoints/harris/harris-cutoff.glsl").withArguments("corners","maxScore","quality"),q=Object(g.b)("keypoints/harris/encode-harris-score.glsl").withArguments("image"),G=Object(g.b)("keypoints/harris/max-harris-score.glsl").withArguments("self","iterationNumber"),W=Object(g.b)("keypoints/harris/multiscale-sobel.glsl").withArguments("pyramid","lod"),Y=Object(g.b)("keypoints/brisk.glsl").withArguments("image","layerA","layerB","scaleA","scaleB","lgM","h"),Q=Object(g.b)("keypoints/orb-descriptor.glsl").withArguments("pyramid","encodedCorners","extraSize","encoderLength"),H=Object(g.b)("keypoints/orb-orientation.glsl").withArguments("pyramid","encodedKeypoints","descriptorSize","extraSize","encoderLength"),V=Object(g.b)("keypoints/nonmax-suppression.glsl").withArguments("image","lodStep"),Z=Object(g.b)("keypoints/nonmax-suppression.glsl").withArguments("image","lodStep").withDefines({MULTISCALE:1}),J=Object(g.b)("keypoints/transfer-orientation.glsl").withArguments("encodedOrientations","encodedKeypoints","descriptorSize","extraSize","encoderLength"),ee=Object(g.b)("keypoints/suppress-descriptors.glsl").withArguments("encodedKeypoints","descriptorSize","extraSize","encoderLength","suppressedEncoderLength");class te extends _{constructor(e,t,n){super(e,t,n),this.compose("fast9","_fast9","_fastScore16").declare("_fast9",z).declare("_fastScore16",N).compose("fast7","_fast7","_fastScore12").declare("_fast7",D).declare("_fastScore12",F).compose("fast5","_fast5","_fastScore8").declare("_fast5",K).declare("_fastScore8",j).declare("multiscaleFast",B).declare("encodeFastScore",U).declare("brisk",Y).declare("multiscaleHarris",$).declare("harrisCutoff",X).declare("encodeHarrisScore",q).declare("maxHarrisScore",G,{...this.program.usesPingpongRendering()}).declare("_nonMaxSuppression",V).declare("_multiscaleNonMaxSuppression",Z).declare("_orb",Q).declare("_orbOrientation",H).declare("multiscaleSobel",W,{...this.program.doesNotRecycleTextures()}).declare("_transferOrientation",J).declare("_suppressDescriptors",ee)}nonMaxSuppression(e,t=0){return t>0?this._multiscaleNonMaxSuppression(e,t):this._nonMaxSuppression(e,0)}orb(e,t,n,r,s){return i.a.assert(32===n),this._orb.resize(s,s),this._orb(e,t,r,s)}orbOrientation(e,t,n,i,r){const s=(c.j+n+i)/4,o=Math.ceil(r*r/s),a=Math.max(1,Math.ceil(Math.sqrt(o)));this._orbOrientation.resize(a,a);const l=this._orbOrientation(e,t,n,i,r);return this._transferOrientation.resize(r,r),this._transferOrientation(l,t,n,i,r)}suppressDescriptors(e,t,n,r,s){return i.a.assert(s<=r),this._suppressDescriptors.resize(s,s),this._suppressDescriptors(e,t,n,r,s)}}class ne extends class{constructor(){}get data(){return null}get size(){return 0}}{constructor(e){super(),this._data=e,this._size=e.length}get data(){return this._data}get size(){return this._size}}const ie=new Uint8Array([]);class re{constructor(e,t,n=0,i=0,r=0,s=0,o=null,a=null){this._x=+e,this._y=+t,this._lod=+n,this._rotation=+i,this._score=+r,this._scale=Math.pow(2,+n),this._flags=0|s,this._extraBytes=o||ie,this._descriptorBytes=a||ie}toString(){return`(${this._x},${this._y})`}get x(){return this._x}get y(){return this._y}get lod(){return this._lod}get scale(){return this._scale}get rotation(){return this._rotation}get score(){return this._score}get flags(){return this._flags}}class se extends re{constructor(e,t){super(e._x,e._y,e._lod,e._rotation,e._score,e._flags,e._extraBytes,e._descriptorBytes),this._descriptor=t(this._descriptorBytes)}get descriptor(){return this._descriptor}}const oe=c.j/4,ae=[32,32],ce=Object(g.b)("encoders/encode-keypoint-offsets.glsl").withArguments("image","imageSize").withDefines({MAX_ITERATIONS:ae[0]}),le=Object(g.b)("encoders/encode-keypoint-long-offsets.glsl").withArguments("offsetsImage","imageSize").withDefines({MAX_ITERATIONS:ae[1]}),de=Object(g.b)("encoders/encode-keypoints.glsl").withArguments("offsetsImage","encodedKeypoints","imageSize","passId","numPasses","descriptorSize","extraSize","encoderLength"),fe=Object(g.b)("encoders/resize-encoded-keypoints.glsl").withArguments("inputTexture","inputDescriptorSize","inputExtraSize","inputEncoderLength","outputDescriptorSize","outputExtraSize","outputEncoderLength"),he=Object(g.b)("utils/identity.glsl").withArguments("image"),pe=Object(g.b)("encoders/upload-keypoints.glsl").withArguments("keypointCount","encoderLength","descriptorSize","extraSize").withDefines({KEYPOINT_BUFFER_LENGTH:1024});class ue extends _{constructor(e,t,n){super(e,t,n),this.declare("_encodeKeypointSkipOffsets",ce).declare("_encodeKeypointLongSkipOffsets",le,{...this.program.usesPingpongRendering()}).declare("_encodeKeypoints",de,{...this.program.hasTextureSize(16,16),...this.program.usesPingpongRendering()}).declare("_resizeEncodedKeypoints",fe,{...this.program.hasTextureSize(16,16)}).declare("_downloadEncodedKeypoints",he,{...this.program.hasTextureSize(16,16)}).declare("_uploadKeypoints",pe,{...this.program.hasTextureSize(16,16)}),this._encoderLength=16,this._keypointCapacity=256/c.j|0,this._uploadBuffer=null}get encoderLength(){return this._encoderLength}get keypointCapacity(){return this._keypointCapacity}optimize(e,t,n){const i=Math.ceil(e),r=this.minimumEncoderLength(i,t,n),s=this._encoderLength;return this._encoderLength=r,this._keypointCapacity=i,r-s!=0}reserveSpace(e,t,n){return this.minimumEncoderLength(e,t,n)>this._encoderLength&&this.optimize(e,t,n)}encodeKeypoints(e,t,n){const i=this._encoderLength,r=[this._width,this._height];let s=this._encodeKeypointSkipOffsets(e,r);for(let e=0;e<2;e++)s=this._encodeKeypointLongSkipOffsets(s,r);const o=oe,a=Math.max(1,Math.ceil(Math.sqrt(this._keypointCapacity*o)));this._encodeKeypoints.resize(a,a);let c=this._encodeKeypoints.clear(0,0,0,0);for(let e=0;e<8;e++)c=this._encodeKeypoints(s,c,r,e,8,0,0,a);return this._resizeEncodedKeypoints.resize(i,i),this._resizeEncodedKeypoints(c,0,0,a,t,n,i)}downloadEncodedKeypoints(e,t=!0){return this._downloadEncodedKeypoints.resize(e.width,e.height),this._downloadEncodedKeypoints(e),this._downloadEncodedKeypoints.readPixelsAsync(t).catch(e=>new s.g("Can't download encoded keypoint texture",e))}uploadKeypoints(e,t,n){const r=e.length;if(r>1024)throw new s.i(`Can't upload ${r} keypoints: maximum is currently 1024`);if(null===this._uploadBuffer){const e=4*Float32Array.BYTES_PER_ELEMENT,t=new ArrayBuffer(1024*e);i.a.assert(t.byteLength<=16384),this._uploadBuffer=new Float32Array(t)}for(let t=0;t<r;t++){const n=e[t],i=4*t;this._uploadBuffer[i]=+n.x||0,this._uploadBuffer[i+1]=+n.y||0,this._uploadBuffer[i+2]=+n.lod||0,this._uploadBuffer[i+3]=+n.score||0}return this.reserveSpace(r,t,n),this._uploadKeypoints.resize(this._encoderLength,this._encoderLength),this._uploadKeypoints.setUBO("KeypointBuffer",this._uploadBuffer),this._uploadKeypoints(r,this._encoderLength,t,n)}minimumEncoderLength(e,t,n){const i=Math.max(0,Math.min(Math.ceil(e),8192)),r=Math.ceil((c.j+t+n)/4),s=Math.ceil(Math.sqrt(i*r));return Math.max(1,s)}}const me=Object(g.b)("pyramids/upsample2.glsl").withArguments("image"),ve=Object(g.b)("pyramids/downsample2.glsl").withArguments("image");class _e extends _{constructor(e,t,n){super(e,t,n),this.declare("_smoothX",Object(M.convX)([.05,.25,.4,.25,.05])).declare("_smoothY",Object(M.convY)([.05,.25,.4,.25,.05])).declare("_smoothX2",Object(M.convX)([.1,.5,.8,.5,.1]),this.program.hasTextureSize(2*this._width,2*this._height)).declare("_smoothY2",Object(M.convY)([.1,.5,.8,.5,.1],.5),this.program.hasTextureSize(2*this._width,2*this._height)).declare("_upsample2",me,this.program.hasTextureSize(2*this._width,2*this._height)).declare("_downsample2",ve,this.program.hasTextureSize(Math.max(1,Math.floor(this._width/2)),Math.max(1,Math.floor(this._height/2)))),this._lastOperation=null}reduce(e){const t=this._smoothY(this._smoothX(e)),n=this._downsample2(t);return this._lastOperation=this._downsample2,n}expand(e){const t=this._upsample2(e),n=this._smoothY2(this._smoothX2(t));return this._lastOperation=this._smoothY2,n}exportTo(e,t){if(null===this._lastOperation)throw new s.g("Can't export pyramid level before generating it");this._lastOperation.exportTo(e,t)}}const ge=Object(g.b)("enhancements/normalize-image.glsl").withArguments("minmax2d","minValue","maxValue").withDefines({GREYSCALE:1}),xe=Object(g.b)("enhancements/normalize-image.glsl").withArguments("minmax2dRGB","minValue","maxValue"),ye=Object(g.b)("enhancements/nightvision.glsl").withArguments("image","illuminationMap","gain","offset","decay"),Se=Object(g.b)("enhancements/nightvision.glsl").withArguments("image","illuminationMap","gain","offset","decay").withDefines({GREYSCALE:1});class be extends _{constructor(e,t,n){super(e,t,n),this.declare("_normalizeGreyscaleImage",ge).declare("_normalizeColoredImage",xe).declare("_nightvision",ye).declare("_nightvisionGreyscale",Se).compose("_illuminationMapLo","_illuminationMapLoX","_illuminationMapLoY").declare("_illuminationMapLoX",Object(M.convX)(i.a.gaussianKernel(80,31))).declare("_illuminationMapLoY",Object(M.convY)(i.a.gaussianKernel(80,31))).compose("_illuminationMap","_illuminationMapX","_illuminationMapY").declare("_illuminationMapX",Object(M.convX)(i.a.gaussianKernel(80,63))).declare("_illuminationMapY",Object(M.convY)(i.a.gaussianKernel(80,63))).compose("_illuminationMapHi","_illuminationMapHiX","_illuminationMapHiY").declare("_illuminationMapHiX",Object(M.convX)(i.a.gaussianKernel(80,255))).declare("_illuminationMapHiY",Object(M.convY)(i.a.gaussianKernel(80,255)))}normalizeGreyscaleImage(e,t=0,n=255){const i=this._gpu.programs.utils._scanMinMax(e,x.d.GREEN);return this._normalizeGreyscaleImage(i,Math.min(t,n),Math.max(t,n))}normalizeColoredImage(e,t=0,n=255){const i=this._gpu,r=new Array(3);r[0]=i.programs.utils.clone(i.programs.utils._scanMinMax(e,x.d.RED)),r[1]=i.programs.utils.clone(i.programs.utils._scanMinMax(e,x.d.GREEN)),r[2]=i.programs.utils._scanMinMax(e,x.d.BLUE);const s=this._normalizeColoredImage(r,Math.min(t,n),Math.max(t,n));return r[1].release(),r[0].release(),s}nightvision(e,t=.5,n=.5,i=0,r="medium",o=!1){let a=null;if("medium"==r)a=this._illuminationMap(e);else if("high"==r)a=this._illuminationMapHi(e);else{if("low"!=r)throw new s.f(`Invalid quality level for nightvision: "${r}"`);a=this._illuminationMapLo(e)}return(o?this._nightvisionGreyscale:this._nightvision)(e,a,t,n,i)}}const we=Object(g.b)("trackers/lk.glsl").withArguments("nextPyramid","prevPyramid","prevKeypoints","windowSize","depth","firstKeypointIndex","lastKeypointIndex","descriptorSize","extraSize","encoderLength").withDefines({MAX_WINDOW_SIZE:21}),Ae=Object(g.b)("trackers/lk-discard.glsl").withArguments("pyramid","encodedKeypoints","windowSize","discardThreshold","firstKeypointIndex","lastKeypointIndex","descriptorSize","extraSize","encoderLength").withDefines({MAX_WINDOW_SIZE:21}),Oe=Object(g.b)("trackers/lk.glsl").withArguments("nextPyramid","prevPyramid","prevKeypoints","windowSize","depth","firstKeypointIndex","lastKeypointIndex","descriptorSize","extraSize","encoderLength").withDefines({MAX_WINDOW_SIZE:15}),Ee=Object(g.b)("trackers/lk-discard.glsl").withArguments("pyramid","encodedKeypoints","windowSize","discardThreshold","firstKeypointIndex","lastKeypointIndex","descriptorSize","extraSize","encoderLength").withDefines({MAX_WINDOW_SIZE:15}),Ie=Object(g.b)("trackers/lk.glsl").withArguments("nextPyramid","prevPyramid","prevKeypoints","windowSize","depth","firstKeypointIndex","lastKeypointIndex","descriptorSize","extraSize","encoderLength").withDefines({MAX_WINDOW_SIZE:11}),Te=Object(g.b)("trackers/lk-discard.glsl").withArguments("pyramid","encodedKeypoints","windowSize","discardThreshold","firstKeypointIndex","lastKeypointIndex","descriptorSize","extraSize","encoderLength").withDefines({MAX_WINDOW_SIZE:11}),Me=Object(g.b)("trackers/lk.glsl").withArguments("nextPyramid","prevPyramid","prevKeypoints","windowSize","depth","firstKeypointIndex","lastKeypointIndex","descriptorSize","extraSize","encoderLength").withDefines({MAX_WINDOW_SIZE:7}),Le=Object(g.b)("trackers/lk-discard.glsl").withArguments("pyramid","encodedKeypoints","windowSize","discardThreshold","firstKeypointIndex","lastKeypointIndex","descriptorSize","extraSize","encoderLength").withDefines({MAX_WINDOW_SIZE:7});class Pe extends _{constructor(e,t,n){super(e,t,n),this.declare("_lk",we).declare("_lkSmall",Oe).declare("_lkSmaller",Ie).declare("_lkSmallest",Me).declare("_lkDiscard",Ae).declare("_lkDiscardSmall",Ee).declare("_lkDiscardSmaller",Te).declare("_lkDiscardSmallest",Le)}lk(e,t,n,i,r,s,o,a,l){const d=c.k;r=Math.max(1,Math.min(0|r,d)),i+=(i+1)%2;let f="_lk",h="_lkDiscard";(i=Math.max(5,Math.min(i,21)))<=7?(f="_lkSmallest",h="_lkDiscardSmallest"):i<=11?(f="_lkSmaller",h="_lkDiscardSmaller"):i<=15&&(f="_lkSmall",h="_lkDiscardSmall"),this[f].resize(l,l),this[h].resize(l,l);const p=l*l/((c.j+o+a)/4),u=Math.ceil(Math.max(1,p)/100);let m=n;for(let n=0;n<u;n++){const c=100*n,d=c+100-1;m=this[f](e,t,m,i,r,c,d,o,a,l),m=this[h](e,m,i,s,c,d,o,a,l)}return m}}class Re{constructor(e,t,n){this._gpu=e,this._width=t,this._height=n,this._utils=null,this._colors=null,this._filters=null,this._keypoints=null,this._encoders=null,this._descriptors=null,this._enhancements=null,this._trackers=null,this._pyramids=new Array(c.k).fill(null)}get width(){return this._width}get height(){return this._height}get utils(){return this._utils||(this._utils=new E(this._gpu,this._width,this._height))}get colors(){return this._colors||(this._colors=new T(this._gpu,this._width,this._height))}get filters(){return this._filters||(this._filters=new C(this._gpu,this._width,this._height))}get keypoints(){return this._keypoints||(this._keypoints=new te(this._gpu,this._width,this._height))}get encoders(){return this._encoders||(this._encoders=new ue(this._gpu,this._width,this._height))}get trackers(){return this._trackers||(this._trackers=new Pe(this._gpu,this._width,this._height))}get enhancements(){return this._enhancements||(this._enhancements=new be(this._gpu,this._width,this._height))}pyramids(e=0){const t=0|e,n=1<<t;if(t<0||t>=c.k)throw new s.f(`Invalid pyramid level: ${t} (outside of range [0,${c.k-1}])`);return this._pyramids[t]||(this._pyramids[t]=new _e(this._gpu,Math.max(1,Math.floor(this._width/n)),Math.max(1,Math.floor(this._height/n))))}}class ke{constructor(e,t){this._gl=null,this._canvas=null,this._width=0,this._height=0,this._programs=null,this._inputTexture=null,this._inputTextureIndex=0,this._omitGLContextWarning=!1,function(){if("undefined"==typeof WebGL2RenderingContext)throw new s.i("WebGL2 is required by this application, but it's not available in your browser. Please use a different browser.")}(),this._width=Math.max(1,0|e),this._height=Math.max(1,0|t),(this._width>c.i||this._height>c.i)&&(i.a.warning(`Maximum texture size exceeded (using ${this._width} x ${this._height}).`),this._width=Math.min(this._width,c.i),this._height=Math.min(this._height,c.i)),this._setupWebGL()}get gl(){return this._gl}get canvas(){return this._canvas}get programs(){return this._programs}upload(e,t=-1,n=-1){const r=this._gl;if(r.isContextLost())return i.a.warning("Can't upload texture without a WebGL context"),this._inputTexture=null;if(t<0&&(t=r.canvas.width),n<0&&(n=r.canvas.height),0==t||0==n)throw new s.f("Can't upload an image of area 0");if(null===this._inputTexture)r.canvas.width=Math.max(r.canvas.width,t),r.canvas.height=Math.max(r.canvas.height,n),this._inputTexture=Array(4).fill(null).map(e=>new l(r,r.canvas.width,r.canvas.height));else if(t>r.canvas.width||n>r.canvas.height)return i.a.log(`Resizing input texture to ${t} x ${n}`),this._inputTexture.forEach(e=>e.release()),this._inputTexture=null,this.upload(e,t,n);if("HTMLVideoElement"==e.constructor.name&&e.readyState<2){if(null!=this._inputTexture[this._inputTextureIndex])return this._inputTexture[this._inputTextureIndex];i.a.warning("Trying to process a video that isn't ready yet")}this._inputTextureIndex=(1+this._inputTextureIndex)%4;const o=this._inputTexture[this._inputTextureIndex];return o.upload(e),o}loseAndRestoreWebGLContext(e=1){const t=this._gl;if(t.isContextLost())return Promise.reject("Context already lost");const n=t.getExtension("WEBGL_lose_context");if(n)return n.loseContext(),new Promise(t=>{isFinite(e)?setTimeout(()=>{n.restoreContext(),setTimeout(()=>t(),0)},1e3*Math.max(e,0)):t()});throw new s.i("WEBGL_lose_context is unavailable")}loseWebGLContext(){return this._omitGLContextWarning=!0,this.loseAndRestoreWebGLContext(1/0)}_setupWebGL(){const e=this._width,t=this._height;this._programs=null,this._inputTexture=null,this._inputTextureIndex=0,this._omitGLContextWarning=!1,void 0!==this._canvas&&delete this._canvas,this._canvas=function(e,t){if("function"==typeof importScripts&&"undefined"!=typeof WorkerGlobalScope){if("function"!=typeof OffscreenCanvas)throw new s.i("OffscreenCanvas is not available in your browser. Please upgrade.");return new OffscreenCanvas(e,t)}return i.a.createCanvas(e,t)}(e,t),this._canvas.addEventListener("webglcontextlost",e=>{this._omitGLContextWarning||i.a.warning("Lost WebGL context"),e.preventDefault()},!1),this._canvas.addEventListener("webglcontextrestored",e=>{this._omitGLContextWarning||i.a.warning("Restoring WebGL context..."),this._setupWebGL()},!1),this._gl=function(e){const t=e.getContext("webgl2",{premultipliedAlpha:!1,preserveDrawingBuffer:!1,alpha:!0,antialias:!1,depth:!1,stencil:!1});if(!t)throw new s.i("Can't create WebGL2 context. Try in a different browser.");return t}(this._canvas),this._programs=new Re(this,e,t)}}class Ce{constructor(){throw new s.a("Namespaces can't be instantiated")}}const ze=Object.freeze({FEATURE_DETECTOR_RESET_CAPACITY:1});class De{constructor(e=0,t=0){i.a.assert(e<=c.h),i.a.assert(e%4==0),i.a.assert(t%4==0),this._descriptorSize=e,this._extraSize=t}run(e,t){throw new s.a}download(e,t,n=0){throw new s.a}upload(e,t){return e.programs.encoders.uploadKeypoints(t,this.descriptorSize,this.extraSize)}get extraSize(){return this._extraSize}set extraSize(e){this._extraSize=Math.max(0,0|e),i.a.assert(this._extraSize%4==0)}get descriptorSize(){return this._descriptorSize}set descriptorSize(e){this._descriptorSize=Math.max(0,0|e),i.a.assert(this._descriptorSize%4==0)}}class Ke{constructor(){this._gain=.85,this._state=600,this._prevState=this._state}estimate(e){const t=Math.max(0,this._state+(this._state-this._prevState)),n=t+this._gain*(e-t);return this._gain=Math.min(.85,this._gain+.3),this._prevState=this._state,this._state=n,Math.round(this._state)}reset(){this._gain=0,this._state=this._prevState=600}get maxGrowth(){return 1.5}}class Ne extends class{constructor(){this._subscribers=[]}subscribe(e){this._subscribers.indexOf(e)<0&&this._subscribers.push(e)}unsubscribe(e){this._subscribers=this._subscribers.filter(t=>t!==e)}_notify(e){for(const t of this._subscribers)t(e)}}{constructor(){super(),this._estimator=new Ke}download(e,t,n,i,r=0){r&0!=Ne.RESET_DOWNLOADER_STATE&&this._estimator.reset();const o=0!=(r&Ne.USE_BUFFERED_DOWNLOADS);return e.programs.encoders.downloadEncodedKeypoints(t,o).then(s=>{const o=t.width,a=0!=(r&Ne.SUPPRESS_DESCRIPTORS)?0:1,c=this._decodeKeypoints(s,n*a,i,o),l=this._countDiscardedKeypoints(c),d=this._estimator.estimate(c.length-l),f=Math.max(d,32),h=this._estimator.maxGrowth*f;return e.programs.encoders.optimize(h,n,i),this._notify(c),c}).catch(e=>{throw new s.g("Can't download keypoints",e)})}_countDiscardedKeypoints(e){let t,n=0;for(t=e.length-1;t>=0;t--)n+=0!=(e[t].flags&c.c)|0;return n}_decodeKeypoints(e,t,n,i){const r=(c.j+t+n)/4;let s,o,a,l,d,f,h,p,u,m;const v=[],_=i*i*r*4,g=Math.min(e.length,_);for(let i=0;i<g&&(s=e[i+1]<<8|e[i],o=e[i+3]<<8|e[i+2],!(s>=65535&&o>=65535));i+=4*r)s+o==0&&0==e[i+6]||(s/=c.b,o/=c.b,f=e[i+7],u=e[i+4]<255,a=u?-c.g+(c.g+c.k)*e[i+4]/255:0,m=f&0!=c.e,l=m?(2*e[i+5]/255-1)*Math.PI:0,d=e[i+6]/255,h=e.slice(8+i,8+i+n),p=e.slice(8+i+n,8+i+n+t),p.length<t||h.length<n||v.push(new re(s,o,a,l,d,f,h,p)));return v}static get RESET_DOWNLOADER_STATE(){return 1}static get USE_BUFFERED_DOWNLOADS(){return 2}static get SUPPRESS_DESCRIPTORS(){return 4}}const Fe=Object.freeze({gain:.9,offset:.5,decay:0,quality:"low"});class je extends De{constructor(){super(0,0),this._enhancements=null,this._downloader=new Ne}run(e,t){const n=this._enhanceTexture(e,t);return this._detect(e,n)}download(e,t,n=0){return this._downloader.download(e,t,this.descriptorSize,this.extraSize,n)}setEnhancements(e){this._enhancements=!0===e?Fe:"object"==typeof e&&null!==e?Object.assign({},Fe,e):null}_detect(e,t){throw new s.a}_enhanceTexture(e,t){let n=t;const i=this._enhancements;return null!==i&&(n=e.programs.enhancements.nightvision(n,i.gain,i.offset,i.decay,i.quality,!0),n=e.programs.filters.gauss3(n)),n}}class Be extends De{constructor(e,t=0,n=0){i.a.assert(e instanceof De),i.a.assert(t>=e.descriptorSize),i.a.assert(n>=e.extraSize),super(t,n),this._decoratedAlgorithm=e,this._decoratedAlgorithm.descriptorSize=this.descriptorSize,this._decoratedAlgorithm.extraSize=this.extraSize}run(e,t){return this._decoratedAlgorithm.run(e,t)}download(e,t,n=0){return i.a.assert(this.extraSize==this._decoratedAlgorithm.extraSize),i.a.assert(this.descriptorSize==this._decoratedAlgorithm.descriptorSize),this._decoratedAlgorithm.download(e,t,n)}get decoratedAlgorithm(){return this._decoratedAlgorithm}get extraSize(){return super.extraSize}set extraSize(e){super.extraSize=e,this._decoratedAlgorithm.extraSize=e}get descriptorSize(){return super.descriptorSize}set descriptorSize(e){super.descriptorSize=e,this._decoratedAlgorithm.descriptorSize=e}}class Ue extends Be{constructor(e,t){i.a.assert(e instanceof De),i.a.assert(t>0),super(e,t,e.extraSize)}run(e,t){const n=this.decoratedAlgorithm.run(e,t);return this._describe(e,t,n)}download(e,t,n=0){return super.download(e,t,n).then(e=>this._postProcess(e))}_describe(e,t,n){throw new s.a}_postProcess(e){throw new s.a}}class $e extends je{constructor(){super(),this._n=9,this._threshold=20}get n(){return this._n}set n(e){this._n=0|e,i.a.assert(9===this._n||7===this._n||5===this._n)}get threshold(){return this._threshold}set threshold(e){this._threshold=0|e,i.a.assert(this._threshold>=0&&this._threshold<=255)}_detect(e,t){const n=this._n,i=this._threshold/255,r=this.descriptorSize,o=this.extraSize;let a=null;if(9==n)a=e.programs.keypoints.fast9(t,i);else if(7==n)a=e.programs.keypoints.fast7(t,i);else{if(5!=n)throw new s.i;a=e.programs.keypoints.fast5(t,i)}const c=e.programs.keypoints.nonMaxSuppression(a),l=e.programs.keypoints.encodeFastScore(c);return e.programs.encoders.encodeKeypoints(l,r,o)}}class Xe extends je{constructor(){super(),this._n=9,this._threshold=20,this._depth=4,this._scaleFactor=1.4142135623730951}get n(){return this._n}set n(e){this._n=0|e,i.a.assert(9===this._n)}get threshold(){return this._threshold}set threshold(e){this._threshold=0|e,i.a.assert(this._threshold>=0&&this._threshold<=255)}get depth(){return this._depth}set depth(e){this._depth=0|e,i.a.assert(this._depth>=1&&this._depth<=c.k)}get scaleFactor(){return this._scaleFactor}set scaleFactor(e){this._scaleFactor=Math.min(Math.max(1,+e),2)}_detect(e,t){const n=this._threshold/255,i=2*this._depth-1,r=Math.log2(this._scaleFactor),s=this.descriptorSize,o=this.extraSize,a=t.generatePyramid(e),c=e.programs.keypoints.multiscaleFast(a,n,i,r),l=e.programs.keypoints.nonMaxSuppression(c,r),d=e.programs.keypoints.encodeFastScore(l);return e.programs.encoders.encodeKeypoints(d,s,o)}}const qe=2*c.k-1;class Ge extends je{constructor(){super(),this._quality=.1}get quality(){return this._quality}set quality(e){this._quality=+e,i.a.assert(this._quality>=0&&this._quality<=1)}_detect(e,t){const n=this._quality,i=this.descriptorSize,r=this.extraSize,s=e.programs.keypoints.multiscaleSobel(t,0),o=new Array(qe).fill(s),a=e.programs.keypoints.multiscaleHarris(t,3,1,1,o);s.release();const c=Math.ceil(Math.log2(Math.max(a.width,a.height)));let l=a;for(let t=0;t<c;t++)l=e.programs.keypoints.maxHarrisScore(l,t);const d=e.programs.keypoints.harrisCutoff(a,l,n),f=e.programs.keypoints.nonMaxSuppression(d),h=e.programs.keypoints.encodeHarrisScore(f);return e.programs.encoders.encodeKeypoints(h,i,r)}}class We extends je{constructor(){super(),this._quality=.1,this._depth=4,this._scaleFactor=1.4142135623730951}get quality(){return this._quality}set quality(e){this._quality=+e,i.a.assert(this._quality>=0&&this._quality<=1)}get depth(){return this._depth}set depth(e){this._depth=0|e,i.a.assert(this._depth>=1&&this._depth<=c.k)}get scaleFactor(){return this._scaleFactor}set scaleFactor(e){this._scaleFactor=Math.min(Math.max(1,+e),2)}_detect(e,t){const n=this._quality,i=this._depth,r=this.descriptorSize,s=this.extraSize,o=2*i-1,a=Math.log2(this._scaleFactor),c=t.generatePyramid(e),l=new Array(qe);for(let t=0;t<o;t++)l[t]=e.programs.keypoints.multiscaleSobel(c,t*a);for(let e=o;e<l.length;e++)l[e]=l[e-1];const d=e.programs.keypoints.multiscaleHarris(c,3,o,a,l);for(let e=0;e<o;e++)l[e].release();const f=Math.ceil(Math.log2(Math.max(d.width,d.height)));let h=d;for(let t=0;t<f;t++)h=e.programs.keypoints.maxHarrisScore(h,t);const p=e.programs.keypoints.harrisCutoff(d,h,n),u=e.programs.keypoints.nonMaxSuppression(p,a),m=e.programs.keypoints.encodeHarrisScore(u);return e.programs.encoders.encodeKeypoints(m,r,s)}}class Ye{constructor(e,...t){this._decorator=e,this._args=t}decorate(e){const t=Reflect.construct(this._decorator,[e].concat(this._args));return i.a.assert(t instanceof Be),t}}class Qe{constructor(e){this._algorithm=e,this._decoratedAlgorithm=this._algorithm,this._sensitivity=0,this._max=void 0,this._capKeypoints=this._capKeypoints.bind(this),this._enhancements={denoise:!0,illumination:!1,nightvision:null}}link(e){return this._decoratedAlgorithm=e.decorate(this._decoratedAlgorithm),this}detect(e,t=0){const n=e._gpu,i="static"==e.options.usage,r=this._decoratedAlgorithm.descriptorSize,o=this._decoratedAlgorithm.extraSize;let a=0;if(e.isReleased())throw new s.g("Can't detect features: the SpeedyMedia has been released");if(i){const e=8192;n.programs.encoders.reserveSpace(e,r,o)}else a|=Ne.USE_BUFFERED_DOWNLOADS;if(t&ze.FEATURE_DETECTOR_RESET_CAPACITY){a|=Ne.RESET_DOWNLOADER_STATE;const e=2048;n.programs.encoders.reserveSpace(e,r,o),a&=~Ne.USE_BUFFERED_DOWNLOADS}const c=n.upload(e.source),l=this._preprocessTexture(n,c,1==this._enhancements.denoise,e._colorFormat!=x.b.Greyscale);this._algorithm.setEnhancements(this._enhancements.nightvision||this._enhancements.illumination);const d=this._decoratedAlgorithm.run(n,l);return this._decoratedAlgorithm.download(n,d,a).then(this._capKeypoints)}get sensitivity(){return this._sensitivity}set sensitivity(e){this._sensitivity=Math.max(0,Math.min(+e,1)),this._onSensitivityChange(this._sensitivity)}get max(){return this._max}set max(e){this._max=void 0!==e?Math.max(0,0|e):void 0}enhance(e){if("object"!=typeof e)throw new s.f("enhancements must be an object");this._enhancements=Object.assign(this._enhancements,e)}_preprocessTexture(e,t,n=!0,i=!0){let r=t;return n&&(r=e.programs.filters.gauss5(r)),i&&(r=e.programs.colors.rgb2grey(r)),r}_onSensitivityChange(e){throw new s.a}_compareKeypoints(e,t){return+t.score-+e.score}_capKeypoints(e){return void 0===this._max?e:e.sort(this._compareKeypoints).slice(0,this._max)}}class He extends Qe{constructor(e=9){if(super(new $e),9!==e&&7!==e&&5!==e)throw new s.i("Can't create FAST feature detector with n = "+e);this._algorithm.n=e}get n(){return this._algorithm.n}get threshold(){return this._algorithm.threshold}set threshold(e){this._algorithm.threshold=e}_onSensitivityChange(e){this.threshold=Math.round(255*(1-Math.tanh(2.77*e)))}}class Ve extends Qe{constructor(e=9){if(super(new Xe),9!==e)throw new s.i("Can't create Multiscale FAST feature detector with n = "+e);this._algorithm.n=e}get n(){return this._algorithm.n}get threshold(){return this._algorithm.threshold}set threshold(e){this._algorithm.threshold=e}get depth(){return this._algorithm.depth}set depth(e){this._algorithm.depth=e}get scaleFactor(){return this._algorithm.scaleFactor}set scaleFactor(e){this._algorithm.scaleFactor=e}_onSensitivityChange(e){this.threshold=Math.round(255*(1-Math.tanh(2.77*e)))}}class Ze extends Qe{constructor(){super(new Ge)}get quality(){return this._algorithm.quality}set quality(e){this._algorithm.quality=Math.max(0,Math.min(e,1))}_onSensitivityChange(e){this.quality=1-e}}class Je extends Qe{constructor(){super(new We)}get depth(){return this._algorithm.depth}set depth(e){this._algorithm.depth=e}get scaleFactor(){return this._algorithm.scaleFactor}set scaleFactor(e){this._algorithm.scaleFactor=e}get quality(){return this._algorithm.quality}set quality(e){this._algorithm.quality=Math.max(0,Math.min(e,1))}_onSensitivityChange(e){this.quality=1-e}}class et extends Ue{constructor(e){super(e,32)}_describe(e,t,n){const i=this.descriptorSize,r=this.extraSize,s=this._computeOrientation(e,t,n),o=e.programs.filters.gauss7(t).generatePyramid(e),a=e.programs.encoders.encoderLength;return e.programs.keypoints.orb(o,s,i,r,a)}_computeOrientation(e,t,n){const i=this.descriptorSize,r=this.extraSize,s=t.generatePyramid(e),o=e.programs.encoders.encoderLength;return e.programs.keypoints.orbOrientation(s,n,i,r,o)}_postProcess(e){return e.map(e=>new se(e,e=>new ne(e)))}}class tt extends Ce{static ORB(){return new Ye(et)}}class nt extends Ce{static FAST(e=9){return new He(e)}static MultiscaleFAST(e=9){return new Ve(e)}static Harris(){return new Ze}static MultiscaleHarris(){return new Je}static ORB(){const e=tt.ORB(),t=(new Je).link(e);return t.scaleFactor=1.19,t}static BRISK(){throw new s.h}}class it{constructor(){this._data=null,this._width=0,this._height=0}static load(e){const t=e.constructor.name;if("HTMLImageElement"==t)return(new rt)._load(e);if("HTMLVideoElement"==t)return(new st)._load(e);if("HTMLCanvasElement"==t)return(new ot)._load(e);if("ImageBitmap"==t)return(new at)._load(e);throw new s.f("Unsupported media type: "+e)}get data(){return this._data}get width(){return this._width}get height(){return this._height}isLoaded(){return null!==this._data}get type(){throw new s.a}clone(){throw new s.a}_load(){throw new s.a}_waitUntil(e,t,n=3e4){return new r.a((r,o)=>{i.a.log(`Waiting for ${t} to be triggered in ${e}...`);const a=setTimeout(()=>{o(new s.k(`${t} has not been triggered in ${e}: timeout (${n}ms)`))},n);e.addEventListener(t,()=>{clearTimeout(a),r(e)},!1)})}}class rt extends it{get type(){return x.c.Image}clone(){if(null==this._data)throw new s.g("Media not loaded");const e=this._data.cloneNode(!0);return(new rt)._load(e)}_load(e){return e.complete&&0!==e.naturalWidth?r.a.resolve().then(()=>(this._data=e,this._width=e.naturalWidth,this._height=e.naturalHeight,this)):this._waitUntil(e,"load").then(()=>(this._data=e,this._width=e.naturalWidth,this._height=e.naturalHeight,this))}}class st extends it{get type(){return x.c.Video}clone(){if(null==this._data)throw new s.g("Media not loaded");const e=this._data.cloneNode(!0);return(new st)._load(e)}_load(e){return e.readyState>=4?r.a.resolve().then(()=>(this._data=e,this._width=e.videoWidth,this._height=e.videoHeight,this)):this._waitUntil(e,"canplaythrough").then(()=>(this._data=e,this._width=e.videoWidth,this._height=e.videoHeight,this))}}class ot extends it{get type(){return x.c.Canvas}clone(){if(null==this._data)throw new s.g("Media not loaded");const e=i.a.createCanvas(this._width,this._height);return e.getContext("2d").draw(this._data,0,0),(new ot)._load(e)}_load(e){return r.a.resolve().then(()=>(this._data=e,this._width=e.width,this._height=e.height,this))}}class at extends it{get type(){return x.c.Bitmap}clone(){if(null==this._data)throw new s.g("Media not loaded");const e=new at;return createImageBitmap(this._data).then(t=>e._load(t))}_load(e){return r.a.resolve().then(()=>(this._data=e,this._width=e.width,this._height=e.height,this))}}const ct={};class lt{constructor(){this._loadOptions=()=>({})}run(e,t,n){return e}release(){}_saveOptions(e,t={}){if("object"==typeof e){const n=Object.assign(t,e);this._loadOptions=()=>n}else{if("function"!=typeof e)throw new s.f("Expected an options object | function");this._loadOptions=()=>Object.assign(t,e())}}}ct.ConvertToGreyscale=class extends lt{run(e,t,n){if(n._colorFormat==x.b.RGB)e=t.programs.colors.rgb2grey(e);else if(n._colorFormat!=x.b.Greyscale)throw new s.i("Can't convert image to greyscale: unknown color format");return n._colorFormat=x.b.Greyscale,e}},ct.Blur=class extends lt{constructor(e={}){super(),this._saveOptions(e,{filter:"gaussian",size:5})}run(e,t,n){const{filter:i,size:r}=this._loadOptions();if("gaussian"!=i&&"box"!=i)throw new s.f(`Invalid filter: "${i}"`);if(3!=r&&5!=r&&7!=r)throw new s.f("Invalid kernel size: "+r);let o="gaussian"==i?"gauss":"box";return t.programs.filters[o+r](e)}},ct.Convolve=class extends lt{constructor(e,t=1){let n=new Float32Array(e).map(e=>e/t);const i=n.length,r=0|Math.sqrt(i),o={3:["createKernel3x3","texConv2D3"],5:["createKernel5x5","texConv2D5"],7:["createKernel7x7","texConv2D7"]}[r]||null;if(super(),1==i)throw new s.f("Cannot convolve with a kernel containing a single element");if(r*r!=i||!o)throw new s.f(`Cannot convolve with a non-square kernel of ${i} elements`);const a=Math.min(...n),c=Math.max(...n),l=a,d=Math.abs(c-a)>1e-5?c-a:1;n=n.map(e=>(e-l)/d),this._method=o,this._scale=d,this._offset=l,this._kernel=n,this._kernelSize=r,this._texKernel=null,this._gl=null}run(e,t,n){if(t.gl.isContextLost())this._texKernel=null,this._gl=null;else if(null==this._texKernel||this._gl!==t.gl&&null!==this._gl){if(this._gl!==t.gl&&null!==this._gl&&!this._gl.isContextLost()){const e="Performance warning: need to recreate the texture kernel. Consider duplicating the pipeline when using convolutions for different media objects.";i.a.warning(e),this._texKernel.release()}this._texKernel=t.programs.filters[this._method[0]](this._kernel),this._gl=t.gl}return t.programs.filters[this._method[1]](e,this._texKernel,this._scale,this._offset)}release(){null!=this._texKernel&&(this._texKernel.release(),this._texKernel=this._gl=null),super.release()}},ct.Normalize=class extends lt{constructor(e={}){super(),this._saveOptions(e,{min:void 0,max:void 0})}run(e,t,n){const{min:i,max:r}=this._loadOptions();if(n._colorFormat==x.b.RGB)return t.programs.enhancements.normalizeColoredImage(e,i,r);if(n._colorFormat==x.b.Greyscale)return t.programs.enhancements.normalizeGreyscaleImage(e,i,r);throw new s.i("Invalid color format")}},ct.Nightvision=class extends lt{constructor(e={}){super(),this._saveOptions(e,{gain:void 0,offset:void 0,decay:void 0,quality:void 0})}run(e,t,n){const{gain:i,offset:r,decay:o,quality:a}=this._loadOptions();if(n._colorFormat==x.b.RGB)return t.programs.enhancements.nightvision(e,i,r,o,a,!1);if(n._colorFormat==x.b.Greyscale)return t.programs.enhancements.nightvision(e,i,r,o,a,!0);throw new s.i("Invalid color format")}};class dt{constructor(){this._operations=[]}get length(){return this._operations.length}release(){return new Promise((e,t)=>{for(let e=this._operations.length-1;e>=0;e--)this._operations[e].release();this._operations.length=0,e(this)})}_spawn(e){return this._operations.push(e),this}_run(e,t,n){for(let i=0;i<this._operations.length;i++)e=this._operations[i].run(e,t,n);return e}concat(e){if(e instanceof dt)return this._operations=this._operations.concat(e._operations),this;throw new s.f(`Invalid argument "${e}" given to SpeedyPipeline.concatenate()`)}convertTo(e=null){if("greyscale"==e||"grayscale"==e)return this._spawn(new ct.ConvertToGreyscale);throw new s.f(`Can't convert to unknown color space: "${e}"`)}blur(e={}){return this._spawn(new ct.Blur(e))}convolve(e,t=1){return this._spawn(new ct.Convolve(e,t))}normalize(e={}){return this._spawn(new ct.Normalize(e))}nightvision(e={}){return this._spawn(new ct.Nightvision(e))}}class ft{constructor(e,t={}){if(this._source=null,this._gpu=null,this._colorFormat=x.b.RGB,this._options=null,"SpeedyMedia"==e.constructor.name){const t=e;this._source=t._source,this._colorFormat=t._colorFormat,this._options=t._options,this._gpu=t._gpu}else i.a.assert(e.isLoaded()),this._source=e,this._source.type==x.c.Canvas&&void 0===t.usage&&i.a.warning('Loading a canvas without an explicit usage flag. I will set the usage to "static". This will result in suboptimal performance if the canvas is animated'),this._options=this._buildOptions(t,{usage:this._source.type==x.c.Video?"dynamic":"static"}),this._gpu=new ke(this._source.width,this._source.height)}static load(e,t={}){return it.load(e).then(n=>{i.a.assert(0!==n.width&&0!==n.height);const r=new ft(n,t);return i.a.log(`Loaded SpeedyMedia with a ${e}.`),r})}static loadCameraStream(e=426,t=240,n={},r={}){return i.a.requestCameraStream(e,t,n).then(e=>ft.load(e,r))}get source(){return this._source.data}get width(){return this._source.width}get height(){return this._source.height}get type(){switch(this._source.type){case x.c.Image:return"image";case x.c.Video:return"video";case x.c.Canvas:return"canvas";case x.c.Bitmap:return"bitmap";default:return"unknown"}}get options(){return this._options}release(){return this.isReleased()||(i.a.log("Releasing SpeedyMedia object..."),this._gpu.loseWebGLContext(),this._gpu=null,this._source=null),r.a.resolve()}isReleased(){return null==this._gpu}clone(e={}){if(e={lightweight:!1,...e},this.isReleased())throw new s.g("Can't clone a SpeedyMedia that has been released");return e.lightweight?r.a.resolve(new ft(this,this._options)):this._source.clone().then(e=>new ft(e,this._options))}run(e){if(this.isReleased())throw new s.g("Can't run pipeline: SpeedyMedia has been released");return this.clone({lightweight:!0}).then(t=>{let n=t._gpu.upload(t._source.data);return n=e._run(n,t._gpu,t),t._gpu.programs.utils.output(n),createImageBitmap(t._gpu.canvas,0,0,t.width,t.height).then(e=>it.load(e).then(e=>(t._source=e,t)))})}draw(e,t=0,n=0,i=this.width,r=this.height){if(this.isReleased())return;t=Math.max(+t,0),n=Math.max(+n,0),i=Math.max(+i,0),r=Math.max(+r,0),e.getContext("2d").drawImage(this._source.data,t,n,i,r)}toBitmap(){if(this.isReleased())throw new s.g("Can't convert SpeedyMedia to ImageBitmap: the media has been released");if(!this._source.isLoaded())throw new s.g("Can't convert SpeedyMedia to bitmap: the media hasn't been loaded");return createImageBitmap(this._source.data)}_buildOptions(e,t){return"dynamic"!=(e=Object.assign({},t,e)).usage&&"static"!=e.usage&&(i.a.warning(`Can't load media. Unrecognized usage option: "${e.usage}"`),e.usage=t.usage,i.a.assert("dynamic"==e.usage||"static"==e.usage)),Object.freeze(e)}}let ht=null;class pt{constructor(){if(this._fps=60,this._frames=0,this._updateInterval=500,this._lastUpdate=performance.now(),this._boundUpdate=this._update.bind(this),null!==ht)throw new s.g("Can't have multiple instances of FPSCounter");this._boundUpdate()}static get instance(){return null===ht&&(ht=new pt),ht}get fps(){return this._fps}_update(){const e=performance.now(),t=e-this._lastUpdate;t>=this._updateInterval&&(this._fps=Math.round(this._frames/(.001*t)),this._frames=0,this._lastUpdate=e),this._frames++,requestAnimationFrame(this._boundUpdate)}}class ut extends De{constructor(){super(0,0),this._prevImage=null,this._prevKeypoints=null,this._downloader=new Ne}run(e,t){return this._track(e,t)}get prevImage(){return this._prevImage}set prevImage(e){this._prevImage=e}get prevKeypoints(){return this._prevKeypoints}set prevKeypoints(e){this._prevKeypoints=e}download(e,t,n=0){return n&0!=Ne.USE_BUFFERED_DOWNLOADS&&i.a.warning("Feature trackers shouldn't use buffered downloads"),this._downloader.download(e,t,this.descriptorSize,this.extraSize,n)}_track(e,t){throw new s.a}}class mt{constructor(e,t){this._data=new Float32Array([e,t])}get x(){return this._data[0]}set x(e){this._data[0]=e}get y(){return this._data[1]}set y(e){this._data[1]=e}toString(){return`SpeedyVector2(${this._data[0].toFixed(5)}, ${this._data[1].toFixed(5)})`}at(e){return this._data[e]}dot(e){return this._data[0]*e._data[0]+this._data[1]*e._data[1]}distanceTo(e){const t=this._data[0]-e._data[0],n=this._data[1]-e._data[1];return Math.sqrt(t*t+n*n)}length(){return Math.sqrt(this._data[0]*this._data[0]+this._data[1]*this._data[1])}normalize(){const e=this.length();return 0==e?(this._data.fill(0),this):(this._data[0]/=e,this._data[1]/=e,this)}}class vt extends ut{constructor(){super(),this._windowSize=15,this._depth=5,this._discardThreshold=1e-4}get windowSize(){return this._windowSize}set windowSize(e){this._windowSize=0|e,i.a.assert(this._windowSize%2==1&&this._windowSize>=1)}get depth(){return this._depth}set depth(e){this._depth=0|e,i.a.assert(this._depth>=1)}get discardThreshold(){return this._discardThreshold}set discardThreshold(e){this._discardThreshold=Math.max(0,+e)}_track(e,t){const n=this.prevImage,i=this.prevKeypoints,r=this.descriptorSize,s=this.extraSize,o=this.windowSize,a=this.depth,c=this.discardThreshold,l=t.generatePyramid(e),d=n.generatePyramid(e),f=e.programs.encoders.encoderLength;return e.programs.trackers.lk(l,d,i,o,a,c,r,s,f)}}class _t extends class{constructor(e,t){this._trackingAlgorithm=e,this._decoratedAlgorithm=this._trackingAlgorithm,this._media=t,this._inputTexture=null,this._prevInputTexture=null}link(e){return this._decoratedAlgorithm=e.decorate(this._decoratedAlgorithm),this}track(e,t=null,n=null){const i=this._media._gpu,r=this._decoratedAlgorithm.descriptorSize,o=this._decoratedAlgorithm.extraSize;if(!Array.isArray(e)||null!=n&&!Array.isArray(n)||null!=t&&!Array.isArray(t))throw new s.f;const[a,l]=this._updatedImages(this._media,i,this._prevInputTexture);this._prevInputTexture=l,this._inputTexture=a,i.programs.encoders.optimize(e.length,r,o),this._trackingAlgorithm.prevImage=l,this._trackingAlgorithm.prevKeypoints=this._trackingAlgorithm.upload(i,e);const d=this._decoratedAlgorithm.run(i,a);return this._decoratedAlgorithm.download(i,d,0).then(i=>{const r=[];null!=n&&(n.length=i.length),null!=t&&(t.length=i.length);for(let s=0;s<i.length;s++){const o=0==(i[s].flags&c.c);o&&r.push(i[s]),null!=n&&(n[s]=o),null!=t&&(t[s]=o?new mt(i[s].x-e[s].x,i[s].y-e[s].y):new mt(0,0))}return r})}_updatedImages(e,t,n){if(e.isReleased())throw new s.g("The media has been released");const i=t.upload(e.source);if(null==i)throw new s.g("Tracking error: can't upload image to the GPU "+e.source);return[i,n||i]}}{constructor(e){super(new vt,e)}get windowSize(){return this._trackingAlgorithm.windowSize}set windowSize(e){if("number"!=typeof e||e<1||e%2==0)throw new s.f("Window size must be a positive odd number");this._trackingAlgorithm.windowSize=e}get depth(){return this._trackingAlgorithm.depth}set depth(e){if("number"!=typeof e||e<1)throw new s.f("Invalid depth: "+e);this._trackingAlgorithm.depth=e}get discardThreshold(){return this._trackingAlgorithm.discardThreshold}set discardThreshold(e){if("number"!=typeof e||e<0)throw new s.f("Invalid discardThreshold");this._trackingAlgorithm.discardThreshold=e}}class gt extends Ce{static LK(e){return new _t(e)}}var xt=n(7);class yt{constructor(e,t=null,n=xt.MatrixType.default,i=null){if(e|=0,!xt.MatrixType.isValid(n))throw new s.f(`Invalid data type: "${n}"`);if(e<=0)throw new s.f("Invalid matrix length");const r=null==t?xt.MatrixType.createTypedArray(n,e):Array.isArray(t)?xt.MatrixType.createTypedArray(n,t):t;this._dtype=n,this._data=r,this._byteOffset=r.byteOffset,this._length=r.length,this._pendingOperations=i?i._pendingOperations:0,this._pendingAccessesQueue=[],this._children=[],this._parent=i}get dtype(){return this._dtype}get data(){return this._data}ready(){return this._pendingOperations>0?new r.a(e=>{this._pendingAccessesQueue.push(()=>e(this))}):r.a.resolve(this)}lock(e=!0){let t=this;if(t._parent&&e)do{t=t._parent}while(t._parent);++t._pendingOperations;for(let e=t._children.length-1;e>=0;e--)t._children[e].lock(!1)}unlock(e=!0){let t=this;if(t._parent&&e)do{t=t._parent}while(t._parent);if(--t._pendingOperations<=0){const e=t._pendingAccessesQueue.slice(0);t._pendingOperations=0,t._pendingAccessesQueue.length=0;for(let n=0;n<e.length;n++){if(t._pendingOperations>0){for(let i=e.length-1;i>=n;i--)t._pendingAccessesQueue.unshift(e[i]);break}e[n].call(t)}}for(let e=t._children.length-1;e>=0;e--)t._children[e].unlock(!1)}replace(e,t=!0){let n=this;if(n._parent&&t)do{n=n._parent}while(n._parent);n._data=xt.MatrixType.createTypedArray(this._dtype,e,n._byteOffset,n._length);for(let t=n._children.length-1;t>=0;t--)n._children[t].replace(e,!1)}createSharedBuffer(e=0,t=this._length){return this.ready().then(()=>{const n=Math.min(e+t,this._length),i=this._data.subarray(e,n),r=new yt(t,i,this._dtype,this);return this._children.push(r),r})}}var St=n(8);class bt{static get instance(){return this._instance||(this._instance=new bt)}constructor(){this._msgId=0,this._callbackTable=new Map,this._worker=this._createWorker()}run(e,t,n){if("nop"===e.method)return r.a.resolve([t,n]);const i=this._msgId=this._msgId+1&(1<<30)-1,s=[t,...n].filter((e,t,n)=>n.indexOf(e)===t),o={id:i,header:e,outputBuffer:t,inputBuffers:n,transferables:s};return new r.a(e=>{this._callbackTable.set(i,(t,n)=>{e([t,n]),this._callbackTable.delete(i)}),this._worker.postMessage(o,s)},!0)}_createWorker(){const e="self.LinAlg = "+St.LinAlg.toString()+";\nself.onmessage = "+wt.toString()+";",t=new Blob([e],{type:"application/javascript"}),n=new Worker(URL.createObjectURL(t));return n.onmessage=e=>{const t=e.data;this._callbackTable.get(t.id)(t.outputBuffer,t.inputBuffers)},n.onerror=e=>{throw new s.g("Worker error: "+e.message)},n}}function wt(e){const{id:t,header:n,outputBuffer:i,inputBuffers:r,transferables:s}=e.data,o=self.LinAlg,a=o.lib.createTypedArray(n.dtype,i,n.byteOffset,n.length),c=r.map((e,t)=>o.lib.createTypedArray(n.dtype,e,n.byteOffsetOfInputs[t],n.lengthOfInputs[t]));o.lib[n.method](n,a,c);const l={id:t,outputBuffer:i,inputBuffers:r};self.postMessage(l,s)}const At=bt.instance;class Ot{constructor(e,t,n,i,r=[],o=null){const a=r.length,c=a>0,l=c&&r.map(e=>e.rows),d=c&&r.map(e=>e.columns),f=c&&new Array(a),h=c&&new Array(a),p=c&&new Array(a);if(this._header={method:e,dtype:i,rows:t,columns:n,stride:null,byteOffset:null,length:null,rowsOfInputs:l,columnsOfInputs:d,strideOfInputs:f,byteOffsetOfInputs:h,lengthOfInputs:p,custom:o},this._inputMatrices=r,this._inputBuffers=new Array(a),this._workloadOfInputs=r.reduce((e,t)=>e+this._workload(t),0),!St.LinAlg.hasMethod(e))throw new s.f(`Invalid method: "${e}"`)}get rows(){return this._header.rows}get columns(){return this._header.columns}get dtype(){return this._header.dtype}update(e){if(this._inputMatrices.length!==e.length)throw new s.g;for(let t=e.length-1;t>=0;t--){const n=e[t],i=this._inputMatrices[t];if(n!==i){if(n.rows!==i.rows||n.columns!==i.columns||n.dtype!==i.dtype)throw new s.g("Can't change the input matrix shape / type");this._inputMatrices[t]=n}}return this}run(e){const{rows:t,columns:n,stride:i,dtype:r}=e,s=this._header;if(this._workloadOfInputs+this._workload(e)<=40)return this._runLocally(e);this._assertCompatibility(t,n,r);const o=e.buffer.data;s.stride=i,s.byteOffset=o.byteOffset,s.length=o.length;const a=this._inputMatrices,c=this._inputBuffers;for(let e=a.length-1;e>=0;e--){const t=a[e],n=t.buffer.data;s.strideOfInputs[e]=t.stride,s.byteOffsetOfInputs[e]=n.byteOffset,s.lengthOfInputs[e]=n.length,c[e]=n.buffer}return At.run(s,o.buffer,c).then(([t,n])=>{e.buffer.replace(t);for(let e=a.length-1;e>=0;e--)a[e].buffer.replace(n[e])})}_runLocally(e){const{rows:t,columns:n,stride:i,dtype:s}=e,o=this._header;this._assertCompatibility(t,n,s);const a=e.buffer.data;o.stride=i,o.byteOffset=a.byteOffset,o.length=a.length;const c=this._inputMatrices,l=this._inputBuffers;for(let e=c.length-1;e>=0;e--){const t=c[e],n=t.buffer.data;o.strideOfInputs[e]=t.stride,o.byteOffsetOfInputs[e]=n.byteOffset,o.lengthOfInputs[e]=n.length,l[e]=n}return St.LinAlg.lib[o.method](o,a,l),r.a.resolve()}get inputMatrices(){return this._inputMatrices}_assertCompatibility(e,t,n=this._header.dtype){const{rows:i,columns:r,dtype:o}=this._header;if(e!==i||t!==r||n!==o)throw n!==o?new s.g(`Incompatible matrix type: "${n}" vs "${o}"`):new s.g(`Invalid matrix size: ${i} x ${r} (expected ${e} x ${t})`)}_workload(e){return e.rows*e.columns}}class Et extends Ot{constructor(e,t,n){super("nop",e,t,n)}}class It extends Ot{constructor(e,t,n,i){super("fill",e,t,n,[],{value:+i})}}class Tt extends Ot{constructor(e){super("copy",e.rows,e.columns,e.dtype,[e])}}class Mt extends Ot{constructor(e){super("transpose",e.columns,e.rows,e.dtype,[e])}}class Lt extends Ot{constructor(e,t){super("add",e.rows,e.columns,e.dtype,[e,t])}}class Pt extends Ot{constructor(e,t){super("subtract",e.rows,e.columns,e.dtype,[e,t])}}class Rt extends Ot{constructor(e,t){super("multiply",e.rows,t.columns,e.dtype,[e,t])}}class kt extends Ot{constructor(e,t){super("scale",e.rows,e.columns,e.dtype,[e],{scalar:+t})}}class Ct extends Ot{constructor(e,t){super("compmult",e.rows,e.columns,e.dtype,[e,t])}}class zt extends Ot{constructor(e,t){super("multiplylt",e.columns,t.columns,e.dtype,[e,t])}}class Dt extends Ot{constructor(e,t){super("multiplyrt",e.rows,t.rows,e.dtype,[e,t])}}class Kt extends Ot{constructor(e,t){super("multiplyvec",e.rows,1,e.dtype,[e,t])}}class Nt extends Ot{constructor(e,t){const n={full:"full-qr",reduced:"reduced-qr"}[t];if(void 0===n)throw new s.f(`QR decomposition: unknown mode "${t}"`);const i="full-qr"==n?e.columns+e.rows:2*e.columns;super("qr",e.rows,i,e.dtype,[e],{mode:n})}}class Ft extends Ot{constructor(e,t){super("qr",e.rows,e.columns+1,e.dtype,[e,t],{mode:"reduced-Q'x"})}}class jt extends Ot{constructor(e){super("backsub",e.rows,1,e.dtype,[e])}}class Bt extends Ot{constructor(e,t){super("lssolve",e.columns,1,e.dtype,[e,t])}}class Ut{constructor(){this._queue=[],this._busy=!1}static get instance(){return this._instance||(this._instance=new Ut)}enqueue(e,t){return new r.a(n=>{this._queue.push([e,t,n]),this._busy||(this._busy=!0,this._resolveAll())})}_resolveAll(){if(0==this._queue.length)return void(this._busy=!1);const[e,t,n]=this._queue.shift();t.lock(),e.inputMatrices.forEach(e=>e.lock()),e.run(t).then(()=>{e.inputMatrices.forEach(e=>e.unlock()),t.unlock(),n(),this._resolveAll()}).turbocharge()}}const $t=Ut.instance;class Xt{constructor(e,t=e,n=null,i=xt.MatrixType.default,r=e,o=null){if(e<=0||t<=0)throw new s.f("Invalid dimensions");if(r<e)throw new s.f("Invalid stride");if(!xt.MatrixType.isValid(i))throw new s.f(`Invalid data type: "${i}"`);if(Array.isArray(n)&&n.length!=e*t)throw new s.f(`Incorrect number of matrix elements (expected ${e*t}, found ${n.length})`);this._rows=0|e,this._columns=0|t,this._stride=0|r,this._dtype=i,this._buffer=o||new yt(this._stride*this._columns,n,this._dtype),this._nop=null}get rows(){return this._rows}get columns(){return this._columns}get stride(){return this._stride}get dtype(){return this._dtype}read(e,t){const n=this._rows,i=this._columns,r=this._stride;if(void 0===e)return this.sync().then(()=>this._buffer.ready().turbocharge()).then(e=>{const s=e.data,o=n*i;(t=t||new Array(o)).length!=o&&(t.length=o);let a,c,l=0;for(c=0;c<i;c++)for(a=0;a<n;a++)t[l++]=s[c*r+a];return t}).turbocharge();if(e.length%2>0)throw new s.f("Can't read matrix entries: missing index");return this.sync().then(()=>this._buffer.ready().turbocharge()).then(s=>{const o=s.data,a=e.length>>1;let c,l;(t=t||new Array(a)).length!=a&&(t.length=a);for(let s=0;s<a;s++)c=0|e[s<<1],l=0|e[1+(s<<1)],t[s]=c>=0&&c<n&&l>=0&&l<i&&o[l*r+c]||void 0;return t}).turbocharge()}at(e,t){return this.read([e,t]).then(e=>e[0]).turbocharge()}print(e,t=console.log){return this.read().then(n=>{const i=this.rows,r=this.columns,s=new Array(i);let o,a;for(o=0;o<i;o++)for(s[o]=new Array(r),a=0;a<r;a++)s[o][a]=n[a*i+o];const c=void 0!==e?t=>t.toFixed(e):e=>e,l=s.map(e=>"    "+e.map(c).join(", ")).join(",\n"),d=`SpeedyMatrix(rows=${i}, cols=${r}, dtype="${this.dtype}", data=[\n${l}\n])`;t(d)})}block(e,t,n,i){const r=this._rows,o=this._columns;if(t<e||i<n)throw new s.f(`Can't create empty submatrix - invalid range [${e}:${t}, ${n}:${i}]`);if(e<0||t>=r||n<0||i>=o)throw new s.f(`Can't create submatrix - invalid range [${e}:${t}, ${n}:${i}] of ${r} x ${o} matrix`);const a=t-e+1,c=i-n+1,l=this._stride,d=n*l+e,f=(i-n)*l+a;return this._buffer.createSharedBuffer(d,f).then(e=>new Xt(a,c,void 0,this._dtype,l,e)).turbocharge()}diagonal(){const e=this._rows,t=this._stride,n=Math.min(e,this._columns),i=(n-1)*t+e;return this._buffer.createSharedBuffer(0,i).then(e=>new Xt(1,n,void 0,this._dtype,t+1,e)).turbocharge()}toString(){return`SpeedyMatrix(rows=${this.rows}, cols=${this.columns}, dtype="${this.dtype}")`}lock(){this._buffer.lock()}unlock(){this._buffer.unlock()}get buffer(){return this._buffer}sync(){return this._nop=this._nop||(this._nop=new Et(this._rows,this._columns,this._dtype)),$t.enqueue(this._nop,this)}}const qt=Ut.instance;class Gt{constructor(e,t,n){if(this._rows=0|e,this._columns=0|t,this._dtype=n,this._readbuf=null,this._rows<=0||this._columns<=0)throw new s.f(`Invalid dimensions for a matrix expression: ${this._rows} x ${this._columns}`);if(!xt.MatrixType.isValid(this._dtype))throw new s.f(`Invalid type for a matrix expression: "${this._dtype}"`)}get rows(){return this._rows}get columns(){return this._columns}get dtype(){return this._dtype}_assertCompatibility(e,t,n=this._dtype){if(e!==this._rows||t!==this._columns||n!==this._dtype)throw n!==this._dtype?new s.g(`Incompatible matrix type (expected "${n}", found "${this._dtype}")`):new s.g(`Incompatible matrix shape (expected ${e} x ${t}, found ${this._rows} x ${this._columns})`)}_evaluate(){throw new s.a}get _matrix(){throw new s.a}_assign(e){throw new s.g("Can't assign matrix: not a l-value")}assign(e){throw new s.g("Can't assign matrix: not a l-value")}fill(e){throw new s.g("Can't fill matrix: not a l-value")}read(){return this._readbuf=this._readbuf||[],this._evaluate().then(e=>e._matrix.read(void 0,this._readbuf)).turbocharge()}print(e,t){return this._evaluate().then(n=>n._matrix.print(e,t)).turbocharge()}toString(){return this._matrix.toString()}block(e,t,n,i){return new Ht(this,e,t,n,i)}row(e){return this.block(e,e,0,this._columns-1)}column(e){return this.block(0,this._rows-1,e,e)}rowSpan(e,t){return this.block(e,t,0,this._columns-1)}columnSpan(e,t){return this.block(0,this._rows-1,e,t)}diagonal(){return new Vt(this)}clone(){return new sn(this)}transpose(){return new on(this)}plus(e){return new an(this,e)}minus(e){return new cn(this,e)}times(e){return e instanceof Gt?new ln(this,e):new pn(this,e)}compMult(e){return new un(this,e)}qr(e="reduced"){return new mn(this,e)}lssolve(e){return new gn(this,e)}solve(e,t="qr"){const n=this._rows,i=this._columns;if(n!==i)throw new s.f(`solve expects a square matrix, but received a ${n} x ${i} matrix`);if(e.rows!==n||1!==e.columns)throw new s.f(`solve expected a ${n} x 1 input vector, but received a ${e.rows} x ${e.columns} matrix`);switch(t){case"qr":return this.lssolve(e);default:throw new s.f(`Unknown method for solve: "${t}"`)}}_qrSolve(e){return new vn(this,e)}_backSubstitution(){return new _n(this)}}class Wt extends Gt{constructor(e,t,n){super(e,t,n),this._tmpmatrix=new Xt(e,t,void 0,n)}get _matrix(){return this._tmpmatrix}}class Yt extends Wt{constructor(e,t,n,i,...r){super(e,t,n.dtype),this._expr=n,this._operationClass=i,this._operation=null,this._args=r}_evaluate(){return this._expr._evaluate().then(e=>qt.enqueue(this._operation?this._operation.update([e._matrix]):this._operation=new this._operationClass(e._matrix,...this._args),this._matrix)).then(()=>this)}get child(){return this._expr}}class Qt extends Wt{constructor(e,t,n,i,r,...s){super(e,t,n.dtype),this._leftExpr=n,this._rightExpr=i,this._operationClass=r,this._operation=null,this._args=s,i.dtype!==n.dtype&&this._assertCompatibility(e,t,i.dtype)}_evaluate(){return r.a.all([this._leftExpr._evaluate().turbocharge(),this._rightExpr._evaluate().turbocharge()]).then(([e,t])=>qt.enqueue(this._operation?this._operation.update([e._matrix,t._matrix]):this._operation=new this._operationClass(e._matrix,t._matrix,...this._args),this._matrix)).then(()=>this)}get leftChild(){return this._leftExpr}get rightChild(){return this._rightExpr}}class Ht extends Gt{constructor(e,t,n,i,r){super(n-t+1,r-i+1,e.dtype),this._expr=e,this._firstRow=t,this._lastRow=n,this._firstColumn=i,this._lastColumn=r,this._submatrix=null,this._cachedMatrix=null}get _matrix(){return this._submatrix}_evaluate(){return this._expr._evaluate().then(e=>e._matrix!==this._cachedMatrix||null===this._submatrix?(this._cachedMatrix=e._matrix,this._cachedMatrix.block(this._firstRow,this._lastRow,this._firstColumn,this._lastColumn)):this._submatrix).then(e=>(this._submatrix=e,this))}}class Vt extends Gt{constructor(e){super(1,Math.min(e.rows,e.columns),e.dtype),this._expr=e,this._diagonal=null,this._cachedMatrix=null}get _matrix(){return this._diagonal}_evaluate(){return this._expr._evaluate().then(e=>e._matrix!==this._cachedMatrix||null===this._diagonal?(this._cachedMatrix=e._matrix,this._cachedMatrix.diagonal()):this._diagonal).then(e=>(this._diagonal=e,this))}}class Zt extends Gt{get _matrix(){throw new s.a}_assign(e){throw new s.a}assign(e){return new Jt(this,e)._evaluate().turbocharge()}fill(e){return this.assign(new rn(this._rows,this._columns,this._dtype,+e))}block(e,t,n,i){return new tn(this,e,t,n,i)}diagonal(){return new nn(this)}}class Jt extends Zt{constructor(e,t){const{rows:n,columns:i,dtype:r}=e;if(super(n,i,r),!(t instanceof Gt)){if(!Array.isArray(t))throw new s.f("Can't assign matrix to "+t);{const e=new Xt(n,i,t,r);t=new en(n,i,r,e)}}this._assertCompatibility(t.rows,t.columns,t.dtype),this._lvalue=e,this._rvalue=t}_evaluate(){return r.a.all([this._lvalue._evaluate().turbocharge(),this._rvalue._evaluate().turbocharge()]).then(([e,t])=>e._assign(t._matrix).turbocharge()).then(()=>this)}get _matrix(){return this._lvalue._matrix}}class en extends Zt{constructor(e,t,n,i=null){super(e,t,n),null!=i&&this._assertCompatibility(i.rows,i.columns,i.dtype),this._usermatrix=i}get _matrix(){if(null==this._usermatrix)throw new s.g("Matrix doesn't have any data. Make sure you assign data to it.");return this._usermatrix}_evaluate(){return r.a.resolve(this)}_assign(e){return this._usermatrix=e,r.a.resolve()}}class tn extends Zt{constructor(e,t,n,i,r){super(n-t+1,r-i+1,e.dtype),this._expr=e,this._firstRow=t,this._lastRow=n,this._firstColumn=i,this._lastColumn=r,this._submatrix=null,this._cachedMatrix=null,this._operation=null}get _matrix(){return this._submatrix}_evaluate(){return this._expr._evaluate().then(e=>e._matrix!==this._cachedMatrix||null===this._submatrix?(this._cachedMatrix=e._matrix,this._cachedMatrix.block(this._firstRow,this._lastRow,this._firstColumn,this._lastColumn)):this._submatrix).then(e=>(this._submatrix=e,this))}_assign(e){return qt.enqueue(this._operation?this._operation.update([e]):this._operation=new Tt(e),this._submatrix)}}class nn extends Zt{constructor(e){super(1,Math.min(e.rows,e.columns),e.dtype),this._expr=e,this._diagonal=null,this._cachedMatrix=null}get _matrix(){return this._diagonal}_evaluate(){return this._expr._evaluate().then(e=>e._matrix!==this._cachedMatrix||null===this._diagonal?(this._cachedMatrix=e._matrix,this._cachedMatrix.diagonal()):this._diagonal).then(e=>(this._diagonal=e,this))}_assign(e){return qt.enqueue(this._operation?this._operation.update([e]):this._operation=new Tt(e),this._diagonal)}}class rn extends Wt{constructor(e,t,n,i){super(e,t,n),this._operation=new It(e,t,n,i)}_evaluate(){return qt.enqueue(this._operation,this._matrix).then(()=>this)}}class sn extends Yt{constructor(e){super(e.rows,e.columns,e,Tt)}}class on extends Yt{constructor(e){if(e instanceof on)return e.child;super(e.columns,e.rows,e,Mt)}}class an extends Qt{constructor(e,t){super(e.rows,e.columns,e,t,Lt),this._assertCompatibility(t.rows,t.columns)}}class cn extends Qt{constructor(e,t){super(e.rows,e.columns,e,t,Pt),this._assertCompatibility(t.rows,t.columns)}}class ln extends Qt{constructor(e,t){const n=e instanceof on,i=t instanceof on;if(n&&i)return new on(new ln(t.child,e.child));if(n&&!i)return new dn(e.child,t);if(!n&&i)return new fn(e,t.child);if(1===t.columns)return new hn(e,t);if(super(e.rows,t.columns,e,t,Rt),e.columns!==t.rows)throw new s.f(`Can't multiply a ${e.rows} x ${e.columns} matrix by a ${t.rows} x ${t.columns} matrix`)}}class dn extends Qt{constructor(e,t){if(super(e.columns,t.columns,e,t,zt),e.rows!==t.rows)throw new s.f(`Can't multiply a ${e.columns} x ${e.rows} (transposed) matrix by a ${t.rows} x ${t.columns} matrix`)}}class fn extends Qt{constructor(e,t){if(super(e.rows,t.rows,e,t,Dt),e.columns!==t.columns)throw new s.f(`Can't multiply a ${e.rows} x ${e.columns} matrix by a ${t.columns} x ${t.rows} (transposed) matrix`)}}class hn extends Qt{constructor(e,t){if(super(e.rows,t.columns,e,t,Kt),e.columns!==t.rows||1!==t.columns)throw new s.f(`Can't multiply a ${e.rows} x ${e.columns} matrix by a ${t.rows} x ${t.columns} matrix / column-vector`)}}class pn extends Yt{constructor(e,t){super(e.rows,e.columns,e,kt,t)}}class un extends Qt{constructor(e,t){super(e.rows,e.columns,e,t,Ct),this._assertCompatibility(t.rows,t.columns)}}class mn extends Yt{constructor(e,t){const n="full"==t?e.columns+e.rows:2*e.columns;if(e.rows<e.columns)throw new s.f(`Can't compute the QR decomposition of a ${e.rows} x ${e.columns} matrix`);super(e.rows,n,e,Nt,t)}}class vn extends Qt{constructor(e,t){if(e.rows<e.columns)throw new s.f(`Can't compute the QR decomposition of a ${e.rows} x ${e.columns} matrix`);if(1!=t.columns||t.rows!=e.rows)throw new s.f(`Expected a ${e.rows} x 1 column-vector, but found a ${t.rows} x ${t.columns} matrix`);super(e.rows,e.columns+1,e,t,Ft)}}class _n extends Yt{constructor(e){if(e.columns!=e.rows+1)throw new s.f(`Expected a ${e.rows} x ${e.rows+1} matrix, but found a ${e.rows} x ${e.columns} matrix`);super(e.rows,1,e,jt)}}class gn extends Qt{constructor(e,t){const[n,i]=[e.rows,e.columns];if(n<i)throw new s.f(`Input matrix has more columns than rows - it's ${n} x ${i}`);if(t.rows!=n||1!=t.columns)throw new s.f(`Expected a ${n} x 1 column-vector, but found a ${t.rows} x ${t.columns} matrix`);super(i,1,e,t,Bt)}}const xn=new class extends Function{_create(e,t=e,n=null,i=xt.MatrixType.default){let r=null;if(!xt.MatrixType.isValid(i))throw new s.f(`Invalid matrix type: "${i}"`);if(null!=n){if(!Array.isArray(n))throw new s.f("Can't initialize Matrix with values "+n);n.length>0&&(r=new Xt(e,t,n,i))}return new en(e,t,i,r)}Zeros(e,t=e,n=xt.MatrixType.default){const i=new Array(e*t).fill(0);return this._create(e,t,i,n)}Ones(e,t=e,n=xt.MatrixType.default){const i=new Array(e*t).fill(1);return this._create(e,t,i,n)}Eye(e,t=e,n=xt.MatrixType.default){const i=new Array(e*t).fill(0);for(let n=Math.min(e,t)-1;n>=0;n--)i[n*e+n]=1;return this._create(e,t,i,n)}constructor(){return super("...args","return this._create(...args)"),this.bind(this)}};class yn{static load(e,t={}){return ft.load(e,t)}static camera(e=426,t=240,n={},i={}){return ft.loadCameraStream(e,t,n,i)}static pipeline(){return new dt}static get version(){return"0.5.1-wip"}static get fps(){return pt.instance.fps}static get FeatureDetector(){return nt}static get FeatureTracker(){return gt}static get FeatureDescriptor(){return tt}static Vector2(e,t=e){return new mt(e,t)}static get Matrix(){return xn}static get Promise(){return r.a}}Object.assign(yn.constructor.prototype,ze),c.f||i.a.warn("Running on a big-endian machine")}]);