/*!
 * speedy-vision.js v0.3.2
 * https://github.com/alemart/speedy-vision-js
 * 
 * GPU-accelerated Computer Vision for the web
 * Copyright 2020 Alexandre Martins <alemartf(at)gmail.com> (https://github.com/alemart)
 * @license Apache-2.0
 * 
 * Date: 2020-07-23T21:30:59.159Z
 */
var Speedy=function(modules){var installedModules={};function __webpack_require__(moduleId){if(installedModules[moduleId])return installedModules[moduleId].exports;var module=installedModules[moduleId]={i:moduleId,l:!1,exports:{}};return modules[moduleId].call(module.exports,module,module.exports,__webpack_require__),module.l=!0,module.exports}return __webpack_require__.m=modules,__webpack_require__.c=installedModules,__webpack_require__.d=function(exports,name,getter){__webpack_require__.o(exports,name)||Object.defineProperty(exports,name,{enumerable:!0,get:getter})},__webpack_require__.r=function(exports){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(exports,"__esModule",{value:!0})},__webpack_require__.t=function(value,mode){if(1&mode&&(value=__webpack_require__(value)),8&mode)return value;if(4&mode&&"object"==typeof value&&value&&value.__esModule)return value;var ns=Object.create(null);if(__webpack_require__.r(ns),Object.defineProperty(ns,"default",{enumerable:!0,value:value}),2&mode&&"string"!=typeof value)for(var key in value)__webpack_require__.d(ns,key,function(key){return value[key]}.bind(null,key));return ns},__webpack_require__.n=function(module){var getter=module&&module.__esModule?function(){return module.default}:function(){return module};return __webpack_require__.d(getter,"a",getter),getter},__webpack_require__.o=function(object,property){return Object.prototype.hasOwnProperty.call(object,property)},__webpack_require__.p="",__webpack_require__(__webpack_require__.s=28)}([function(module,exports,__webpack_require__){var map={"./global.glsl":1,"./math.glsl":2,"./pyramids.glsl":3};function webpackContext(req){var id=webpackContextResolve(req);return __webpack_require__(id)}function webpackContextResolve(req){if(!__webpack_require__.o(map,req)){var e=new Error("Cannot find module '"+req+"'");throw e.code="MODULE_NOT_FOUND",e}return map[req]}webpackContext.keys=function(){return Object.keys(map)},webpackContext.resolve=webpackContextResolve,module.exports=webpackContext,webpackContext.id=0},function(module,exports){module.exports="#define threadLocation() ivec2(texCoord * texSize)\n#define outputSize() ivec2(texSize)\n#define threadPixel(img) textureLod((img), texCoord, 0.0f)\n#define pixelAt(img, pos) texelFetch((img), (pos), 0)\n#define pixelAtOffset(img, offset) textureLodOffset((img), texCoord, 0.0f, (offset))"},function(module,exports){module.exports="#ifndef _MATH_GLSL\n#define _MATH_GLSL\n#define PI              3.14159265359f\n#define PI_OVER_2       1.57079632679f\n#define PI_OVER_4       0.78539816339f\n#define USE_FAST_ATAN\n#ifdef USE_FAST_ATAN\nfloat fastAtan(float x)\n{\nfloat w = 1.0f - abs(x);\nreturn (w >= 0.0f) ?\n(PI_OVER_4 + 0.273f * w) * x :\nsign(x) * PI_OVER_2 - (PI_OVER_4 + 0.273f * (1.0f - abs(1.0f / x))) / x;\n}\n#else\n#define fastAtan(x) atan(x)\n#endif\n#ifdef USE_FAST_ATAN\nfloat fastAtan2(float y, float x)\n{\nreturn (x == 0.0f) ? PI_OVER_2 * sign(y) : fastAtan(y / x) + float(x < 0.0f) * PI * sign(y);\n}\n#else\n#define fastAtan2(y, x) atan((y), (x))\n#endif\n#endif"},function(module,exports){module.exports="#define pyrPixel(img, lod) textureLod((img), texCoord, (lod))\n#define pyrPixelAtOffset(img, lod, pot, offset) textureLod((img), texCoord + ((pot) * vec2(offset)) / texSize, (lod))\nfloat encodeLod(float lod, float log2PyrMaxScale, float pyrMaxLevels)\n{\nreturn (log2PyrMaxScale + lod) / (log2PyrMaxScale + pyrMaxLevels);\n}\nfloat decodeLod(float encodedLod, float log2PyrMaxScale, float pyrMaxLevels)\n{\nreturn encodedLod * (log2PyrMaxScale + pyrMaxLevels) - log2PyrMaxScale;\n}"},function(module,exports){module.exports="uniform sampler2D image;\nvoid main()\n{\ncolor = threadPixel(image);\n}"},function(module,exports){module.exports="uniform sampler2D image;\nvoid main() {\nivec2 pos = threadLocation();\npos.y = int(texSize.y) - 1 - pos.y;\ncolor = pixelAt(image, pos);\n}"},function(module,exports){module.exports="const vec4 grey = vec4(0.299f, 0.587f, 0.114f, 0.0f);\nuniform sampler2D image;\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nfloat g = dot(pixel, grey);\ncolor = vec4(g, g, g, 1.0f);\n}"},function(module,exports){module.exports="uniform sampler2D image;\nuniform float threshold;\nconst ivec4 margin = ivec4(3, 3, 4, 4);\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nivec2 thread = threadLocation();\nivec2 size = outputSize();\ncolor = vec4(0.0f, pixel.gba);\nif(any(lessThan(ivec4(thread, size - thread), margin)))\nreturn;\nfloat t = clamp(threshold, 0.0f, 1.0f);\nfloat ct = pixel.g + t, c_t = pixel.g - t;\nfloat p0 = pixelAtOffset(image, ivec2(0, 3)).g;\nfloat p4 = pixelAtOffset(image, ivec2(3, 0)).g;\nfloat p8 = pixelAtOffset(image, ivec2(0, -3)).g;\nfloat p12 = pixelAtOffset(image, ivec2(-3, 0)).g;\nif(!(\n((c_t > p0 || c_t > p8) && (c_t > p4 || c_t > p12)) ||\n((ct < p0  || ct < p8)  && (ct < p4  || ct < p12))\n))\nreturn;\nfloat p1 = pixelAtOffset(image, ivec2(1, 3)).g;\nfloat p2 = pixelAtOffset(image, ivec2(2, 2)).g;\nfloat p3 = pixelAtOffset(image, ivec2(3, 1)).g;\nfloat p5 = pixelAtOffset(image, ivec2(3, -1)).g;\nfloat p6 = pixelAtOffset(image, ivec2(2, -2)).g;\nfloat p7 = pixelAtOffset(image, ivec2(1, -3)).g;\nfloat p9 = pixelAtOffset(image, ivec2(-1, -3)).g;\nfloat p10 = pixelAtOffset(image, ivec2(-2, -2)).g;\nfloat p11 = pixelAtOffset(image, ivec2(-3, -1)).g;\nfloat p13 = pixelAtOffset(image, ivec2(-3, 1)).g;\nfloat p14 = pixelAtOffset(image, ivec2(-2, 2)).g;\nfloat p15 = pixelAtOffset(image, ivec2(-1, 3)).g;\nbool A=(p0>ct),B=(p1>ct),C=(p2>ct),D=(p3>ct),E=(p4>ct),F=(p5>ct),G=(p6>ct),H=(p7>ct),I=(p8>ct),J=(p9>ct),K=(p10>ct),L=(p11>ct),M=(p12>ct),N=(p13>ct),O=(p14>ct),P=(p15>ct),a=(p0<c_t),b=(p1<c_t),c=(p2<c_t),d=(p3<c_t),e=(p4<c_t),f=(p5<c_t),g=(p6<c_t),h=(p7<c_t),i=(p8<c_t),j=(p9<c_t),k=(p10<c_t),l=(p11<c_t),m=(p12<c_t),n=(p13<c_t),o=(p14<c_t),p=(p15<c_t);\nbool isCorner=A&&(B&&(K&&L&&J&&(M&&N&&O&&P||G&&H&&I&&(M&&N&&O||F&&(M&&N||E&&(M||D))))||C&&(K&&L&&M&&(N&&O&&P||G&&H&&I&&J&&(N&&O||F&&(N||E)))||D&&(N&&(L&&M&&(K&&G&&H&&I&&J&&(O||F)||O&&P)||k&&l&&m&&e&&f&&g&&h&&i&&j)||E&&(O&&(M&&N&&(K&&L&&G&&H&&I&&J||P)||k&&l&&m&&n&&f&&g&&h&&i&&j)||F&&(P&&(N&&O||k&&l&&m&&n&&o&&g&&h&&i&&j)||G&&(O&&P||H&&(P||I)||k&&l&&m&&n&&o&&p&&h&&i&&j)||k&&l&&m&&n&&o&&h&&i&&j&&(p||g))||k&&l&&m&&n&&h&&i&&j&&(o&&(p||g)||f&&(o&&p||g)))||k&&l&&m&&h&&i&&j&&(n&&(o&&p||g&&(o||f))||e&&(n&&o&&p||g&&(n&&o||f))))||k&&l&&h&&i&&j&&(m&&(n&&o&&p||g&&(n&&o||f&&(n||e)))||d&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e)))))||k&&h&&i&&j&&(l&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d))))))||K&&I&&J&&(L&&M&&N&&O&&P||G&&H&&(L&&M&&N&&O||F&&(L&&M&&N||E&&(L&&M||D&&(L||C)))))||h&&i&&j&&(b&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c)))))||k&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c)))))))||B&&(H&&I&&J&&(K&&L&&M&&N&&O&&P&&a||G&&(K&&L&&M&&N&&O&&a||F&&(K&&L&&M&&N&&a||E&&(K&&L&&M&&a||D&&(K&&L&&a||C)))))||a&&k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||C&&(K&&H&&I&&J&&(L&&M&&N&&O&&P&&a&&b||G&&(L&&M&&N&&O&&a&&b||F&&(L&&M&&N&&a&&b||E&&(L&&M&&a&&b||D))))||a&&b&&k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d)))))||D&&(K&&L&&H&&I&&J&&(M&&N&&O&&P&&a&&b&&c||G&&(M&&N&&O&&a&&b&&c||F&&(M&&N&&a&&b&&c||E)))||a&&b&&k&&l&&m&&c&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e))))||E&&(K&&L&&M&&H&&I&&J&&(N&&O&&P&&a&&b&&c&&d||G&&(N&&O&&a&&b&&c&&d||F))||a&&b&&l&&m&&n&&c&&d&&(k&&g&&h&&i&&j&&(o||f)||o&&p))||F&&(K&&L&&M&&N&&H&&I&&J&&(O&&P&&a&&b&&c&&d&&e||G)||a&&b&&m&&n&&o&&c&&d&&e&&(k&&l&&g&&h&&i&&j||p))||G&&(K&&L&&M&&N&&O&&H&&I&&J||a&&b&&n&&o&&p&&c&&d&&e&&f)||H&&(K&&L&&M&&N&&O&&P&&I&&J||a&&b&&o&&p&&c&&d&&e&&f&&g)||a&&(b&&(k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(k&&l&&m&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e)))||d&&(l&&m&&n&&(k&&g&&h&&i&&j&&(o||f)||o&&p)||e&&(m&&n&&o&&(k&&l&&g&&h&&i&&j||p)||f&&(n&&o&&p||g&&(o&&p||h&&(p||i)))))))||k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||h&&i&&j&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c&&(b||k))))));\ncolor = vec4(float(isCorner), pixel.gba);\n}"},function(module,exports){module.exports='@include "pyramids.glsl"\nuniform sampler2D image;\nuniform float threshold;\nuniform float minLod, maxLod;\nuniform float log2PyrMaxScale, pyrMaxLevels;\nuniform bool resetCorners;\nconst ivec4 margin = ivec4(3, 3, 4, 4);\nconst vec4 zeroes = vec4(0.0f, 0.0f, 0.0f, 0.0f);\nconst vec4 ones = vec4(1.0f, 1.0f, 1.0f, 1.0f);\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nivec2 thread = threadLocation();\nivec2 size = outputSize();\nfloat t = clamp(threshold, 0.0f, 1.0f);\nfloat ct = pixel.g + t, c_t = pixel.g - t;\nfloat pot = pow(2.0f, minLod);\ncolor = resetCorners ? vec4(0.0f, pixel.g, 0.0f, pixel.a) : pixel;\nfor(float lod = minLod; lod <= maxLod; (lod += 1.0f), (pot += pot)) {\npixel = pyrPixel(image, lod);\nct = pixel.g + t;\nc_t = pixel.g - t;\nvec4 p4k = vec4(\npyrPixelAtOffset(image, lod, pot, ivec2(0, 3)).g,\npyrPixelAtOffset(image, lod, pot, ivec2(3, 0)).g,\npyrPixelAtOffset(image, lod, pot, ivec2(0, -3)).g,\npyrPixelAtOffset(image, lod, pot, ivec2(-3, 0)).g\n);\nmat4 mp = mat4(\np4k.x,\np4k.y,\np4k.z,\np4k.w,\npyrPixelAtOffset(image, lod, pot, ivec2(1, 3)).g,\npyrPixelAtOffset(image, lod, pot, ivec2(3, -1)).g,\npyrPixelAtOffset(image, lod, pot, ivec2(-1, -3)).g,\npyrPixelAtOffset(image, lod, pot, ivec2(-3, 1)).g,\npyrPixelAtOffset(image, lod, pot, ivec2(2, 2)).g,\npyrPixelAtOffset(image, lod, pot, ivec2(2, -2)).g,\npyrPixelAtOffset(image, lod, pot, ivec2(-2, -2)).g,\npyrPixelAtOffset(image, lod, pot, ivec2(-2, 2)).g,\npyrPixelAtOffset(image, lod, pot, ivec2(3, 1)).g,\npyrPixelAtOffset(image, lod, pot, ivec2(1, -3)).g,\npyrPixelAtOffset(image, lod, pot, ivec2(-3, -1)).g,\npyrPixelAtOffset(image, lod, pot, ivec2(-1, 3)).g\n);\nbool A=(mp[0][0]>ct),B=(mp[1][0]>ct),C=(mp[2][0]>ct),D=(mp[3][0]>ct),E=(mp[0][1]>ct),F=(mp[1][1]>ct),G=(mp[2][1]>ct),H=(mp[3][1]>ct),I=(mp[0][2]>ct),J=(mp[1][2]>ct),K=(mp[2][2]>ct),L=(mp[3][2]>ct),M=(mp[0][3]>ct),N=(mp[1][3]>ct),O=(mp[2][3]>ct),P=(mp[3][3]>ct),a=(mp[0][0]<c_t),b=(mp[1][0]<c_t),c=(mp[2][0]<c_t),d=(mp[3][0]<c_t),e=(mp[0][1]<c_t),f=(mp[1][1]<c_t),g=(mp[2][1]<c_t),h=(mp[3][1]<c_t),i=(mp[0][2]<c_t),j=(mp[1][2]<c_t),k=(mp[2][2]<c_t),l=(mp[3][2]<c_t),m=(mp[0][3]<c_t),n=(mp[1][3]<c_t),o=(mp[2][3]<c_t),p=(mp[3][3]<c_t);\nbool isCorner=A&&(B&&(K&&L&&J&&(M&&N&&O&&P||G&&H&&I&&(M&&N&&O||F&&(M&&N||E&&(M||D))))||C&&(K&&L&&M&&(N&&O&&P||G&&H&&I&&J&&(N&&O||F&&(N||E)))||D&&(N&&(L&&M&&(K&&G&&H&&I&&J&&(O||F)||O&&P)||k&&l&&m&&e&&f&&g&&h&&i&&j)||E&&(O&&(M&&N&&(K&&L&&G&&H&&I&&J||P)||k&&l&&m&&n&&f&&g&&h&&i&&j)||F&&(P&&(N&&O||k&&l&&m&&n&&o&&g&&h&&i&&j)||G&&(O&&P||H&&(P||I)||k&&l&&m&&n&&o&&p&&h&&i&&j)||k&&l&&m&&n&&o&&h&&i&&j&&(p||g))||k&&l&&m&&n&&h&&i&&j&&(o&&(p||g)||f&&(o&&p||g)))||k&&l&&m&&h&&i&&j&&(n&&(o&&p||g&&(o||f))||e&&(n&&o&&p||g&&(n&&o||f))))||k&&l&&h&&i&&j&&(m&&(n&&o&&p||g&&(n&&o||f&&(n||e)))||d&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e)))))||k&&h&&i&&j&&(l&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d))))))||K&&I&&J&&(L&&M&&N&&O&&P||G&&H&&(L&&M&&N&&O||F&&(L&&M&&N||E&&(L&&M||D&&(L||C)))))||h&&i&&j&&(b&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c)))))||k&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c)))))))||B&&(H&&I&&J&&(K&&L&&M&&N&&O&&P&&a||G&&(K&&L&&M&&N&&O&&a||F&&(K&&L&&M&&N&&a||E&&(K&&L&&M&&a||D&&(K&&L&&a||C)))))||a&&k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||C&&(K&&H&&I&&J&&(L&&M&&N&&O&&P&&a&&b||G&&(L&&M&&N&&O&&a&&b||F&&(L&&M&&N&&a&&b||E&&(L&&M&&a&&b||D))))||a&&b&&k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d)))))||D&&(K&&L&&H&&I&&J&&(M&&N&&O&&P&&a&&b&&c||G&&(M&&N&&O&&a&&b&&c||F&&(M&&N&&a&&b&&c||E)))||a&&b&&k&&l&&m&&c&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e))))||E&&(K&&L&&M&&H&&I&&J&&(N&&O&&P&&a&&b&&c&&d||G&&(N&&O&&a&&b&&c&&d||F))||a&&b&&l&&m&&n&&c&&d&&(k&&g&&h&&i&&j&&(o||f)||o&&p))||F&&(K&&L&&M&&N&&H&&I&&J&&(O&&P&&a&&b&&c&&d&&e||G)||a&&b&&m&&n&&o&&c&&d&&e&&(k&&l&&g&&h&&i&&j||p))||G&&(K&&L&&M&&N&&O&&H&&I&&J||a&&b&&n&&o&&p&&c&&d&&e&&f)||H&&(K&&L&&M&&N&&O&&P&&I&&J||a&&b&&o&&p&&c&&d&&e&&f&&g)||a&&(b&&(k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(k&&l&&m&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e)))||d&&(l&&m&&n&&(k&&g&&h&&i&&j&&(o||f)||o&&p)||e&&(m&&n&&o&&(k&&l&&g&&h&&i&&j||p)||f&&(n&&o&&p||g&&(o&&p||h&&(p||i)))))))||k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||h&&i&&j&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c&&(b||k))))));\nfloat scale = encodeLod(lod, log2PyrMaxScale, pyrMaxLevels);\nmat4 mct = mp - mat4(\nct, ct, ct, ct,\nct, ct, ct, ct,\nct, ct, ct, ct,\nct, ct, ct, ct\n), mc_t = mat4(\nc_t, c_t, c_t, c_t,\nc_t, c_t, c_t, c_t,\nc_t, c_t, c_t, c_t,\nc_t, c_t, c_t, c_t\n) - mp;\nvec4 bs = max(mc_t[0], zeroes), ds = max(mct[0], zeroes);\nbs += max(mc_t[1], zeroes); ds += max(mct[1], zeroes);\nbs += max(mc_t[2], zeroes); ds += max(mct[2], zeroes);\nbs += max(mc_t[3], zeroes); ds += max(mct[3], zeroes);\nfloat score = max(dot(bs, ones), dot(ds, ones)) / 16.0f;\nivec2 remainder = thread % int(pot);\nscore *= float(remainder.x + remainder.y == 0);\nbool isBestCorner = isCorner && (score > color.r);\ncolor = isBestCorner ? vec4(score, color.g, score, scale) : color;\n}\n}'},function(module,exports){module.exports="uniform sampler2D image;\nuniform float threshold;\nvoid main()\n{\nivec2 thread = threadLocation();\nivec2 size = outputSize();\nvec4 pixel = threadPixel(image);\ncolor = vec4(0.0f, pixel.gba);\nif(\nthread.x >= 3 && thread.x < size.x - 3 &&\nthread.y >= 3 && thread.y < size.y - 3\n) {\nfloat t = clamp(threshold, 0.0f, 1.0f);\nfloat c = pixel.g;\nfloat ct = c + t, c_t = c - t;\nfloat p0 = pixelAtOffset(image, ivec2(0, 2)).g;\nfloat p1 = pixelAtOffset(image, ivec2(1, 2)).g;\nfloat p2 = pixelAtOffset(image, ivec2(2, 1)).g;\nfloat p3 = pixelAtOffset(image, ivec2(2, 0)).g;\nfloat p4 = pixelAtOffset(image, ivec2(2, -1)).g;\nfloat p5 = pixelAtOffset(image, ivec2(1, -2)).g;\nfloat p6 = pixelAtOffset(image, ivec2(0, -2)).g;\nfloat p7 = pixelAtOffset(image, ivec2(-1, -2)).g;\nfloat p8 = pixelAtOffset(image, ivec2(-2, -1)).g;\nfloat p9 = pixelAtOffset(image, ivec2(-2, 0)).g;\nfloat p10 = pixelAtOffset(image, ivec2(-2, 1)).g;\nfloat p11 = pixelAtOffset(image, ivec2(-1, 2)).g;\nbool possibleCorner =\n((c_t > p0 || c_t > p6) && (c_t > p3 || c_t > p9)) ||\n((ct < p0  || ct < p6)  && (ct < p3  || ct < p9))  ;\nif(possibleCorner) {\nint bright = 0, dark = 0, bc = 0, dc = 0;\nif(c_t > p0) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p0) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p1) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p1) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p2) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p2) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p3) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p3) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p4) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p4) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p5) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p5) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p6) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p6) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p7) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p7) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p8) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p8) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p9) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p9) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p10) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p10) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p11) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p11) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(bright < 7 && dark < 7) {\nif(bc > 0 && bc < 7) do {\nif(c_t > p0)           bc += 1; else break;\nif(c_t > p1 && bc < 7) bc += 1; else break;\nif(c_t > p2 && bc < 7) bc += 1; else break;\nif(c_t > p3 && bc < 7) bc += 1; else break;\nif(c_t > p4 && bc < 7) bc += 1; else break;\nif(c_t > p5 && bc < 7) bc += 1; else break;\n} while(false);\nif(dc > 0 && dc < 7) do {\nif(ct < p0)           dc += 1; else break;\nif(ct < p1 && dc < 7) dc += 1; else break;\nif(ct < p2 && dc < 7) dc += 1; else break;\nif(ct < p3 && dc < 7) dc += 1; else break;\nif(ct < p4 && dc < 7) dc += 1; else break;\nif(ct < p5 && dc < 7) dc += 1; else break;\n} while(false);\nif(bc >= 7 || dc >= 7)\ncolor = vec4(1.0f, pixel.gba);\n}\nelse {\ncolor = vec4(1.0f, pixel.gba);\n}\n}\n}\n}"},function(module,exports){module.exports="uniform sampler2D image;\nuniform float threshold;\nvoid main()\n{\nivec2 thread = threadLocation();\nivec2 size = outputSize();\nvec4 pixel = threadPixel(image);\ncolor = vec4(0.0f, pixel.gba);\nif(\nthread.x >= 3 && thread.x < size.x - 3 &&\nthread.y >= 3 && thread.y < size.y - 3\n) {\nfloat t = clamp(threshold, 0.0f, 1.0f);\nfloat c = pixel.g;\nfloat ct = c + t, c_t = c - t;\nfloat p0 = pixelAtOffset(image, ivec2(0, 1)).g;\nfloat p1 = pixelAtOffset(image, ivec2(1, 1)).g;\nfloat p2 = pixelAtOffset(image, ivec2(1, 0)).g;\nfloat p3 = pixelAtOffset(image, ivec2(1, -1)).g;\nfloat p4 = pixelAtOffset(image, ivec2(0, -1)).g;\nfloat p5 = pixelAtOffset(image, ivec2(-1, -1)).g;\nfloat p6 = pixelAtOffset(image, ivec2(-1, 0)).g;\nfloat p7 = pixelAtOffset(image, ivec2(-1, 1)).g;\nbool possibleCorner =\n((c_t > p1 || c_t > p5) && (c_t > p3 || c_t > p7)) ||\n((ct < p1  || ct < p5)  && (ct < p3  || ct < p7))  ;\nif(possibleCorner) {\nint bright = 0, dark = 0, bc = 0, dc = 0;\nif(c_t > p0) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p0) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p1) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p1) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p2) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p2) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p3) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p3) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p4) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p4) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p5) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p5) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p6) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p6) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p7) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p7) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(bright < 5 && dark < 5) {\nif(bc > 0 && bc < 5) do {\nif(c_t > p0)           bc += 1; else break;\nif(c_t > p1 && bc < 5) bc += 1; else break;\nif(c_t > p2 && bc < 5) bc += 1; else break;\nif(c_t > p3 && bc < 5) bc += 1; else break;\n} while(false);\nif(dc > 0 && dc < 5) do {\nif(ct < p0)           dc += 1; else break;\nif(ct < p1 && dc < 5) dc += 1; else break;\nif(ct < p2 && dc < 5) dc += 1; else break;\nif(ct < p3 && dc < 5) dc += 1; else break;\n} while(false);\nif(bc >= 5 || dc >= 5)\ncolor = vec4(1.0f, pixel.gba);\n}\nelse {\ncolor = vec4(1.0f, pixel.gba);\n}\n}\n}\n}"},function(module,exports){module.exports="uniform sampler2D image;\nuniform float threshold;\nconst vec4 zeroes = vec4(0.0f, 0.0f, 0.0f, 0.0f);\nconst vec4 ones = vec4(1.0f, 1.0f, 1.0f, 1.0f);\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nfloat t = clamp(threshold, 0.0f, 1.0f);\nfloat ct = pixel.g + t, c_t = pixel.g - t;\nmat4 mp = mat4(\npixelAtOffset(image, ivec2(0, 3)).g,\npixelAtOffset(image, ivec2(1, 3)).g,\npixelAtOffset(image, ivec2(2, 2)).g,\npixelAtOffset(image, ivec2(3, 1)).g,\npixelAtOffset(image, ivec2(3, 0)).g,\npixelAtOffset(image, ivec2(3, -1)).g,\npixelAtOffset(image, ivec2(2, -2)).g,\npixelAtOffset(image, ivec2(1, -3)).g,\npixelAtOffset(image, ivec2(0, -3)).g,\npixelAtOffset(image, ivec2(-1, -3)).g,\npixelAtOffset(image, ivec2(-2, -2)).g,\npixelAtOffset(image, ivec2(-3, -1)).g,\npixelAtOffset(image, ivec2(-3, 0)).g,\npixelAtOffset(image, ivec2(-3, 1)).g,\npixelAtOffset(image, ivec2(-2, 2)).g,\npixelAtOffset(image, ivec2(-1, 3)).g\n);\nmat4 mct = mp - mat4(\nct, ct, ct, ct,\nct, ct, ct, ct,\nct, ct, ct, ct,\nct, ct, ct, ct\n), mc_t = mat4(\nc_t, c_t, c_t, c_t,\nc_t, c_t, c_t, c_t,\nc_t, c_t, c_t, c_t,\nc_t, c_t, c_t, c_t\n) - mp;\nvec4 bs = max(mc_t[0], zeroes), ds = max(mct[0], zeroes);\nbs += max(mc_t[1], zeroes); ds += max(mct[1], zeroes);\nbs += max(mc_t[2], zeroes); ds += max(mct[2], zeroes);\nbs += max(mc_t[3], zeroes); ds += max(mct[3], zeroes);\nfloat score = max(dot(bs, ones), dot(ds, ones)) / 16.0f;\ncolor = vec4(score * step(1.0f, pixel.r), pixel.g, score, pixel.a);\n}"},function(module,exports){module.exports="uniform sampler2D image;\nuniform float threshold;\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nfloat t = clamp(threshold, 0.0f, 1.0f);\nfloat ct = pixel.g + t, c_t = pixel.g - t;\nfloat p0 = pixelAtOffset(image, ivec2(0, 2)).g;\nfloat p1 = pixelAtOffset(image, ivec2(1, 2)).g;\nfloat p2 = pixelAtOffset(image, ivec2(2, 1)).g;\nfloat p3 = pixelAtOffset(image, ivec2(2, 0)).g;\nfloat p4 = pixelAtOffset(image, ivec2(2, -1)).g;\nfloat p5 = pixelAtOffset(image, ivec2(1, -2)).g;\nfloat p6 = pixelAtOffset(image, ivec2(0, -2)).g;\nfloat p7 = pixelAtOffset(image, ivec2(-1, -2)).g;\nfloat p8 = pixelAtOffset(image, ivec2(-2, -1)).g;\nfloat p9 = pixelAtOffset(image, ivec2(-2, 0)).g;\nfloat p10 = pixelAtOffset(image, ivec2(-2, 1)).g;\nfloat p11 = pixelAtOffset(image, ivec2(-1, 2)).g;\nvec2 scores = vec2(0.0f, 0.0f);\nscores += vec2(max(c_t - p0, 0.0f), max(p0 - ct, 0.0f));\nscores += vec2(max(c_t - p1, 0.0f), max(p1 - ct, 0.0f));\nscores += vec2(max(c_t - p2, 0.0f), max(p2 - ct, 0.0f));\nscores += vec2(max(c_t - p3, 0.0f), max(p3 - ct, 0.0f));\nscores += vec2(max(c_t - p4, 0.0f), max(p4 - ct, 0.0f));\nscores += vec2(max(c_t - p5, 0.0f), max(p5 - ct, 0.0f));\nscores += vec2(max(c_t - p6, 0.0f), max(p6 - ct, 0.0f));\nscores += vec2(max(c_t - p7, 0.0f), max(p7 - ct, 0.0f));\nscores += vec2(max(c_t - p8, 0.0f), max(p8 - ct, 0.0f));\nscores += vec2(max(c_t - p9, 0.0f), max(p9 - ct, 0.0f));\nscores += vec2(max(c_t - p10, 0.0f), max(p10 - ct, 0.0f));\nscores += vec2(max(c_t - p11, 0.0f), max(p11 - ct, 0.0f));\nfloat score = max(scores.x, scores.y) / 12.0f;\ncolor = vec4(score * step(1.0f, pixel.r), pixel.g, score, pixel.a);\n}"},function(module,exports){module.exports="uniform sampler2D image;\nuniform float threshold;\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nfloat t = clamp(threshold, 0.0f, 1.0f);\nfloat ct = pixel.g + t, c_t = pixel.g - t;\nfloat p0 = pixelAtOffset(image, ivec2(0, 1)).g;\nfloat p1 = pixelAtOffset(image, ivec2(1, 1)).g;\nfloat p2 = pixelAtOffset(image, ivec2(1, 0)).g;\nfloat p3 = pixelAtOffset(image, ivec2(1, -1)).g;\nfloat p4 = pixelAtOffset(image, ivec2(0, -1)).g;\nfloat p5 = pixelAtOffset(image, ivec2(-1, -1)).g;\nfloat p6 = pixelAtOffset(image, ivec2(-1, 0)).g;\nfloat p7 = pixelAtOffset(image, ivec2(-1, 1)).g;\nvec2 scores = vec2(0.0f, 0.0f);\nscores += vec2(max(c_t - p0, 0.0f), max(p0 - ct, 0.0f));\nscores += vec2(max(c_t - p1, 0.0f), max(p1 - ct, 0.0f));\nscores += vec2(max(c_t - p2, 0.0f), max(p2 - ct, 0.0f));\nscores += vec2(max(c_t - p3, 0.0f), max(p3 - ct, 0.0f));\nscores += vec2(max(c_t - p4, 0.0f), max(p4 - ct, 0.0f));\nscores += vec2(max(c_t - p5, 0.0f), max(p5 - ct, 0.0f));\nscores += vec2(max(c_t - p6, 0.0f), max(p6 - ct, 0.0f));\nscores += vec2(max(c_t - p7, 0.0f), max(p7 - ct, 0.0f));\nfloat score = max(scores.x, scores.y) / 8.0f;\ncolor = vec4(score * step(1.0f, pixel.r), pixel.g, score, pixel.a);\n}"},function(module,exports){module.exports="uniform sampler2D image;\nvoid main()\n{\nfloat p0 = pixelAtOffset(image, ivec2(0, 1)).r;\nfloat p1 = pixelAtOffset(image, ivec2(1, 1)).r;\nfloat p2 = pixelAtOffset(image, ivec2(1, 0)).r;\nfloat p3 = pixelAtOffset(image, ivec2(1, -1)).r;\nfloat p4 = pixelAtOffset(image, ivec2(0, -1)).r;\nfloat p5 = pixelAtOffset(image, ivec2(-1, -1)).r;\nfloat p6 = pixelAtOffset(image, ivec2(-1, 0)).r;\nfloat p7 = pixelAtOffset(image, ivec2(-1, 1)).r;\nfloat m = max(\nmax(max(p0, p1), max(p2, p3)),\nmax(max(p4, p5), max(p6, p7))\n);\nvec4 pixel = threadPixel(image);\nfloat score = step(m, pixel.r) * pixel.r;\ncolor = vec4(score, pixel.gba);\n}"},function(module,exports){module.exports='@include "pyramids.glsl"\nuniform sampler2D image;\nuniform float lodJump;\nuniform float log2PyrMaxScale, pyrMaxLevels;\nconst float scaleEps = 1e-5;\n#define ENABLE_INNER_RING\n#define ENABLE_MIDDLE_RING\n#define ENABLE_OUTER_RING\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nfloat lod = decodeLod(pixel.a, log2PyrMaxScale, pyrMaxLevels);\ncolor = pixel;\nif(pixel.r == 0.0f)\nreturn;\n#ifdef ENABLE_INNER_RING\nvec4 p0 = pixelAtOffset(image, ivec2(0, 1));\nvec4 p1 = pixelAtOffset(image, ivec2(1, 1));\nvec4 p2 = pixelAtOffset(image, ivec2(1, 0));\nvec4 p3 = pixelAtOffset(image, ivec2(1, -1));\nvec4 p4 = pixelAtOffset(image, ivec2(0, -1));\nvec4 p5 = pixelAtOffset(image, ivec2(-1, -1));\nvec4 p6 = pixelAtOffset(image, ivec2(-1, 0));\nvec4 p7 = pixelAtOffset(image, ivec2(-1, 1));\n#else\nvec4 p0, p1, p2, p3, p4, p5, p6, p7;\np0 = p1 = p2 = p3 = p4 = p5 = p6 = p7 = vec4(0.0f, 0.0f, 0.0f, 1.0f);\n#endif\n#ifdef ENABLE_MIDDLE_RING\nvec4 q0 = pixelAtOffset(image, ivec2(0, 2));\nvec4 q1 = pixelAtOffset(image, ivec2(1, 2));\nvec4 q2 = pixelAtOffset(image, ivec2(2, 2));\nvec4 q3 = pixelAtOffset(image, ivec2(2, 1));\nvec4 q4 = pixelAtOffset(image, ivec2(2, 0));\nvec4 q5 = pixelAtOffset(image, ivec2(2, -1));\nvec4 q6 = pixelAtOffset(image, ivec2(2, -2));\nvec4 q7 = pixelAtOffset(image, ivec2(1, -2));\nvec4 q8 = pixelAtOffset(image, ivec2(0, -2));\nvec4 q9 = pixelAtOffset(image, ivec2(-1, -2));\nvec4 q10 = pixelAtOffset(image, ivec2(-2, -2));\nvec4 q11 = pixelAtOffset(image, ivec2(-2, -1));\nvec4 q12 = pixelAtOffset(image, ivec2(-2, 0));\nvec4 q13 = pixelAtOffset(image, ivec2(-2, 1));\nvec4 q14 = pixelAtOffset(image, ivec2(-2, 2));\nvec4 q15 = pixelAtOffset(image, ivec2(-1, 2));\n#else\nvec4 q0, q1, q2, q3, q4, q5, q6, q7, q8, q9, q10, q11, q12, q13, q14, q15;\nq0 = q1 = q2 = q3 = q4 = q5 = q6 = q7 = q8 = q9 = q10 =\nq11 = q12 = q13 = q14 = q15= vec4(0.0f, 0.0f, 0.0f, 1.0f);\n#endif\n#ifdef ENABLE_OUTER_RING\nvec4 r0 = pixelAtOffset(image, ivec2(0, 3));\nvec4 r1 = pixelAtOffset(image, ivec2(1, 3));\nvec4 r2 = pixelAtOffset(image, ivec2(3, 1));\nvec4 r3 = pixelAtOffset(image, ivec2(3, 0));\nvec4 r4 = pixelAtOffset(image, ivec2(3, -1));\nvec4 r5 = pixelAtOffset(image, ivec2(1, -3));\nvec4 r6 = pixelAtOffset(image, ivec2(0, -3));\nvec4 r7 = pixelAtOffset(image, ivec2(-1, -3));\nvec4 r8 = pixelAtOffset(image, ivec2(-3, -1));\nvec4 r9 = pixelAtOffset(image, ivec2(-3, 0));\nvec4 r10 = pixelAtOffset(image, ivec2(-3, 1));\nvec4 r11 = pixelAtOffset(image, ivec2(-1, 3));\nvec4 r12 = pixelAtOffset(image, ivec2(0, 4));\nvec4 r13 = pixelAtOffset(image, ivec2(4, 0));\nvec4 r14 = pixelAtOffset(image, ivec2(0, -4));\nvec4 r15 = pixelAtOffset(image, ivec2(-4, 0));\n#else\nvec4 r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15;\nr0 = r1 = r2 = r3 = r4 = r5 = r6 = r7 = r8 = r9 = r10 =\nr11 = r12 = r13 = r14 = r15 = vec4(0.0f, 0.0f, 0.0f, 1.0f);\n#endif\nfloat lodPlus = min(lod + lodJump, pyrMaxLevels - 1.0f);\nfloat lodMinus = max(lod - lodJump, 0.0f);\nfloat alphaPlus = encodeLod(lodPlus, log2PyrMaxScale, pyrMaxLevels);\nfloat alphaMinus = encodeLod(lodMinus, log2PyrMaxScale, pyrMaxLevels);\nmat3 innerScore = mat3(\np0.r * float(abs(p0.a - alphaPlus) < scaleEps || abs(p0.a - alphaMinus) < scaleEps),\np1.r * float(abs(p1.a - alphaPlus) < scaleEps || abs(p1.a - alphaMinus) < scaleEps),\np2.r * float(abs(p2.a - alphaPlus) < scaleEps || abs(p2.a - alphaMinus) < scaleEps),\np3.r * float(abs(p3.a - alphaPlus) < scaleEps || abs(p3.a - alphaMinus) < scaleEps),\np4.r * float(abs(p4.a - alphaPlus) < scaleEps || abs(p4.a - alphaMinus) < scaleEps),\np5.r * float(abs(p5.a - alphaPlus) < scaleEps || abs(p5.a - alphaMinus) < scaleEps),\np6.r * float(abs(p6.a - alphaPlus) < scaleEps || abs(p6.a - alphaMinus) < scaleEps),\np7.r * float(abs(p7.a - alphaPlus) < scaleEps || abs(p7.a - alphaMinus) < scaleEps),\n0.0f\n);\nmat4 middleScore = mat4(\nq0.r * float(abs(q0.a - alphaPlus) < scaleEps || abs(q0.a - alphaMinus) < scaleEps),\nq1.r * float(abs(q1.a - alphaPlus) < scaleEps || abs(q1.a - alphaMinus) < scaleEps),\nq2.r * float(abs(q2.a - alphaPlus) < scaleEps || abs(q2.a - alphaMinus) < scaleEps),\nq3.r * float(abs(q3.a - alphaPlus) < scaleEps || abs(q3.a - alphaMinus) < scaleEps),\nq4.r * float(abs(q4.a - alphaPlus) < scaleEps || abs(q4.a - alphaMinus) < scaleEps),\nq5.r * float(abs(q5.a - alphaPlus) < scaleEps || abs(q5.a - alphaMinus) < scaleEps),\nq6.r * float(abs(q6.a - alphaPlus) < scaleEps || abs(q6.a - alphaMinus) < scaleEps),\nq7.r * float(abs(q7.a - alphaPlus) < scaleEps || abs(q7.a - alphaMinus) < scaleEps),\nq8.r * float(abs(q8.a - alphaPlus) < scaleEps || abs(q8.a - alphaMinus) < scaleEps),\nq9.r * float(abs(q9.a - alphaPlus) < scaleEps || abs(q9.a - alphaMinus) < scaleEps),\nq10.r * float(abs(q10.a - alphaPlus) < scaleEps || abs(q10.a - alphaMinus) < scaleEps),\nq11.r * float(abs(q11.a - alphaPlus) < scaleEps || abs(q11.a - alphaMinus) < scaleEps),\nq12.r * float(abs(q12.a - alphaPlus) < scaleEps || abs(q12.a - alphaMinus) < scaleEps),\nq13.r * float(abs(q13.a - alphaPlus) < scaleEps || abs(q13.a - alphaMinus) < scaleEps),\nq14.r * float(abs(q14.a - alphaPlus) < scaleEps || abs(q14.a - alphaMinus) < scaleEps),\nq15.r * float(abs(q15.a - alphaPlus) < scaleEps || abs(q15.a - alphaMinus) < scaleEps)\n);\nmat4 outerScore = mat4(\nr0.r * float(abs(r0.a - alphaPlus) < scaleEps || abs(r0.a - alphaMinus) < scaleEps),\nr1.r * float(abs(r1.a - alphaPlus) < scaleEps || abs(r1.a - alphaMinus) < scaleEps),\nr2.r * float(abs(r2.a - alphaPlus) < scaleEps || abs(r2.a - alphaMinus) < scaleEps),\nr3.r * float(abs(r3.a - alphaPlus) < scaleEps || abs(r3.a - alphaMinus) < scaleEps),\nr4.r * float(abs(r4.a - alphaPlus) < scaleEps || abs(r4.a - alphaMinus) < scaleEps),\nr5.r * float(abs(r5.a - alphaPlus) < scaleEps || abs(r5.a - alphaMinus) < scaleEps),\nr6.r * float(abs(r6.a - alphaPlus) < scaleEps || abs(r6.a - alphaMinus) < scaleEps),\nr7.r * float(abs(r7.a - alphaPlus) < scaleEps || abs(r7.a - alphaMinus) < scaleEps),\nr8.r * float(abs(r8.a - alphaPlus) < scaleEps || abs(r8.a - alphaMinus) < scaleEps),\nr9.r * float(abs(r9.a - alphaPlus) < scaleEps || abs(r9.a - alphaMinus) < scaleEps),\nr10.r * float(abs(r10.a - alphaPlus) < scaleEps || abs(r10.a - alphaMinus) < scaleEps),\nr11.r * float(abs(r11.a - alphaPlus) < scaleEps || abs(r11.a - alphaMinus) < scaleEps),\nr12.r * float(abs(r12.a - alphaPlus) < scaleEps || abs(r12.a - alphaMinus) < scaleEps),\nr13.r * float(abs(r13.a - alphaPlus) < scaleEps || abs(r13.a - alphaMinus) < scaleEps),\nr14.r * float(abs(r14.a - alphaPlus) < scaleEps || abs(r14.a - alphaMinus) < scaleEps),\nr15.r * float(abs(r15.a - alphaPlus) < scaleEps || abs(r15.a - alphaMinus) < scaleEps)\n);\nvec3 maxInnerScore3 = max(innerScore[0], max(innerScore[1], innerScore[2]));\nvec4 maxMiddleScore4 = max(max(middleScore[0], middleScore[1]), max(middleScore[2], middleScore[3]));\nvec4 maxOuterScore4 = max(max(outerScore[0], outerScore[1]), max(outerScore[2], outerScore[3]));\nfloat maxInnerScore = max(maxInnerScore3.x, max(maxInnerScore3.y, maxInnerScore3.z));\nfloat maxMiddleScore = max(max(maxMiddleScore4.x, maxMiddleScore4.y), max(maxMiddleScore4.z, maxMiddleScore4.w));\nfloat maxOuterScore = max(max(maxOuterScore4.x, maxOuterScore4.y), max(maxOuterScore4.z, maxOuterScore4.w));\nfloat maxScore = max(maxInnerScore, max(maxMiddleScore, maxOuterScore));\nfloat myScore = step(maxScore, pixel.r) * pixel.r;\ncolor = vec4(myScore, pixel.gba);\n}'},function(module,exports){module.exports='@include "pyramids.glsl"\nuniform sampler2D image;\nuniform float log2PyrMaxScale, pyrMaxLevels;\nconst float scaleEps = 1e-5;\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nivec2 thread = threadLocation();\nfloat lod = decodeLod(pixel.a, log2PyrMaxScale, pyrMaxLevels);\nfloat pot = pow(2.0f, lod);\ncolor = pixel;\nif(pixel.r == 0.0f)\nreturn;\nvec4 p0 = pixelAtOffset(image, ivec2(0, 1));\nvec4 p1 = pixelAtOffset(image, ivec2(1, 1));\nvec4 p2 = pixelAtOffset(image, ivec2(1, 0));\nvec4 p3 = pixelAtOffset(image, ivec2(1, -1));\nvec4 p4 = pixelAtOffset(image, ivec2(0, -1));\nvec4 p5 = pixelAtOffset(image, ivec2(-1, -1));\nvec4 p6 = pixelAtOffset(image, ivec2(-1, 0));\nvec4 p7 = pixelAtOffset(image, ivec2(-1, 1));\nmat3 score = mat3(\np0.r * float(abs(p0.a - pixel.a) < scaleEps),\np1.r * float(abs(p1.a - pixel.a) < scaleEps),\np2.r * float(abs(p2.a - pixel.a) < scaleEps),\np3.r * float(abs(p3.a - pixel.a) < scaleEps),\np4.r * float(abs(p4.a - pixel.a) < scaleEps),\np5.r * float(abs(p5.a - pixel.a) < scaleEps),\np6.r * float(abs(p6.a - pixel.a) < scaleEps),\np7.r * float(abs(p7.a - pixel.a) < scaleEps),\n0.0f\n);\nvec3 maxScore3 = max(score[0], max(score[1], score[2]));\nfloat maxScore = max(maxScore3.x, max(maxScore3.y, maxScore3.z));\nfloat myScore = step(maxScore, pixel.r) * pixel.r;\ncolor = vec4(myScore, pixel.gba);\n}'},function(module,exports){module.exports="uniform sampler2D image, layerA, layerB;\nuniform float scaleA, scaleB, lgM, h;\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nfloat score = pixel.r;\nivec2 zero = ivec2(0, 0);\nivec2 sizeA = textureSize(layerA, 0);\nivec2 sizeB = textureSize(layerB, 0);\nvec2 mid = (texCoord * texSize) + vec2(0.5f, 0.5f);\nivec2 pa = clamp(ivec2(ceil(mid * scaleA - 1.0f)), zero, sizeA - 2);\nivec2 pb = clamp(ivec2(ceil(mid * scaleB - 1.0f)), zero, sizeB - 2);\nvec4 a00 = pixelAt(layerA, pa);\nvec4 a10 = pixelAt(layerA, pa + ivec2(1, 0));\nvec4 a01 = pixelAt(layerA, pa + ivec2(0, 1));\nvec4 a11 = pixelAt(layerA, pa + ivec2(1, 1));\nvec4 b00 = pixelAt(layerB, pb);\nvec4 b10 = pixelAt(layerB, pb + ivec2(1, 0));\nvec4 b01 = pixelAt(layerB, pb + ivec2(0, 1));\nvec4 b11 = pixelAt(layerB, pb + ivec2(1, 1));\nfloat maxScore = max(\nmax(max(a00.r, a10.r), max(a01.r, a11.r)),\nmax(max(b00.r, b10.r), max(b01.r, b11.r))\n);\ncolor = vec4(0.0f, pixel.gba);\nif(score < maxScore || score == 0.0f)\nreturn;\nvec2 ea = fract(mid * scaleA);\nvec2 eb = fract(mid * scaleB);\nfloat isa = a00.b * (1.0f - ea.x) * (1.0f - ea.y) +\na10.b * ea.x * (1.0f - ea.y) +\na01.b * (1.0f - ea.x) * ea.y +\na11.b * ea.x * ea.y;\nfloat isb = b00.b * (1.0f - eb.x) * (1.0f - eb.y) +\nb10.b * eb.x * (1.0f - eb.y) +\nb01.b * (1.0f - eb.x) * eb.y +\nb11.b * eb.x * eb.y;\ncolor = (isa > score && isa > isb) ? vec4(isa, pixel.gb, a00.a) : pixel;\ncolor = (isb > score && isb > isa) ? vec4(isb, pixel.gb, b00.a) : pixel;\nfloat y1 = isa, y2 = isb, y3 = score;\nfloat x1 = lgM - (lgM + h) * a00.a;\nfloat x2 = lgM - (lgM + h) * b00.a;\nfloat x3 = lgM - (lgM + h) * pixel.a;\nfloat dn = (x1 - x2) * (x1 - x3) * (x2 - x3);\nif(abs(dn) < 0.00001f)\nreturn;\nfloat a = (x3 * (y2 - y1) + x2 * (y1 - y3) + x1 * (y3 - y2)) / dn;\nif(a >= 0.0f)\nreturn;\nfloat b = (x3 * x3 * (y1 - y2) + x2 * x2 * (y3 - y1) + x1 * x1 * (y2 - y3)) / dn;\nfloat c = (x2 * x3 * (x2 - x3) * y1 + x3 * x1 * (x3 - x1) * y2 + x1 * x2 * (x1 - x2) * y3) / dn;\nfloat xv = -b / (2.0f * a);\nfloat yv = c - (b * b) / (4.0f * a);\nif(xv < min(x1, min(x2, x3)) || xv > max(x1, max(x2, x3)))\nreturn;\nfloat interpolatedScale = (lgM - xv) / (lgM + h);\nfloat interpolatedScore = clamp(yv, 0.0f, 1.0f);\ncolor = vec4(interpolatedScore, pixel.gb, interpolatedScale);\n}"},function(module,exports){module.exports="uniform sampler2D image;\nuniform ivec2 imageSize;\nuniform int maxIterations;\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nivec2 pos = threadLocation();\nint offset = -1;\nwhile(offset < maxIterations && pos.y < imageSize.y && pixelAt(image, pos).r == 0.0f) {\n++offset;\npos.x = (pos.x + 1) % imageSize.x;\npos.y += int(pos.x == 0);\n}\ncolor = vec4(pixel.rg, float(max(0, offset)) / 255.0f, pixel.a);\n}"},function(module,exports){module.exports="uniform sampler2D image;\nuniform ivec2 imageSize;\nuniform int encoderLength;\nuniform int descriptorSize;\nbool findQthKeypoint(int q, out ivec2 position, out vec4 pixel)\n{\nint i = 0, p = 0;\nfor(position = ivec2(0, 0); position.y < imageSize.y; ) {\npixel = pixelAt(image, position);\nif(pixel.r > 0.0f) {\nif(p++ == q)\nreturn true;\n}\ni += 1 + int(pixel.b * 255.0f);\nposition = ivec2(i % imageSize.x, i / imageSize.x);\n}\nreturn false;\n}\nvoid main()\n{\nvec4 pixel;\nivec2 position;\nivec2 thread = threadLocation();\nint p = encoderLength * thread.y + thread.x;\nint d = 2 + descriptorSize / 4;\nint q = p / d;\ncolor = vec4(1.0f, 1.0f, 1.0f, 1.0f);\nif(findQthKeypoint(q, position, pixel)) {\nint r = p % d;\nswitch(r) {\ncase 0: {\nivec2 lo = position & 255;\nivec2 hi = position >> 8;\ncolor = vec4(float(lo.x), float(hi.x), float(lo.y), float(hi.y)) / 255.0f;\nbreak;\n}\ncase 1: {\nfloat scale = pixel.a;\nfloat rotation = 0.0f;\ncolor = vec4(scale, rotation, 0.0f, 0.0f);\nbreak;\n}\ndefault: {\nint i = r - 2;\nbreak;\n}\n}\n}\n}"},function(module,exports){module.exports="uniform sampler2D image;\nvoid main()\n{\nivec2 thread = threadLocation();\nvec4 pixel = pixelAt(image, thread / 2);\ncolor = (((thread.x + thread.y) & 1) == 0) ? pixel : vec4(0.0f, 0.0f, 0.0f, pixel.a);\n}"},function(module,exports){module.exports="uniform sampler2D image;\nvoid main()\n{\nivec2 thread = threadLocation();\nivec2 pos = min(thread * 2, textureSize(image, 0) - 1);\ncolor = pixelAt(image, pos);\n}"},function(module,exports){module.exports="uniform sampler2D image;\nvoid main()\n{\nivec2 thread = threadLocation();\nvec4 pixel = pixelAt(image, thread / 3);\nbool cond = ((thread.x - (thread.y % 3) + 3) % 3) == 0;\ncolor = (((thread.x - (thread.y % 3) + 3) % 3) == 0) ? pixel : vec4(0.0f, 0.0f, 0.0f, pixel.a);\n}"},function(module,exports){module.exports="uniform sampler2D image;\nvoid main()\n{\nivec2 thread = threadLocation();\nivec2 pos = min(thread * 3, textureSize(image, 0) - 1);\ncolor = pixelAt(image, pos);\n}"},function(module,exports){module.exports="uniform sampler2D target;\nuniform sampler2D source;\nvoid main()\n{\nvec4 a = threadPixel(target);\nvec4 b = threadPixel(source);\ncolor = (b.r > a.r) ? vec4(b.r, a.gb, b.a) : a;\n}"},function(module,exports){module.exports="uniform sampler2D largerImage;\nuniform sampler2D smallerImage;\nvoid main()\n{\nivec2 thread = threadLocation();\nvec4 lg = pixelAt(largerImage, min(thread, textureSize(largerImage, 0) - 1));\nvec4 sm = pixelAt(smallerImage, min(thread / 2, textureSize(smallerImage, 0) - 1));\ncolor = ((((thread.x & 1) + (thread.y & 1)) == 0) && (sm.r > lg.r)) ? vec4(sm.r, lg.gb, sm.a) : lg;\n}"},function(module,exports){module.exports="uniform sampler2D image;\nuniform float imageScale;\nconst ivec2 one = ivec2(1, 1);\n#define B2(expr) bvec2((expr),(expr))\nvoid main()\n{\nivec2 thread = threadLocation();\nivec2 size = outputSize();\nivec2 scaled = ivec2((texCoord * texSize) * imageScale);\nivec2 imageSize = textureSize(image, 0);\nvec4 pixel = threadPixel(image);\nvec4 p0 = pixelAt(image, min(scaled, imageSize-1));\nvec4 p1 = pixelAt(image, min(scaled + ivec2(0, 1), imageSize-1));\nvec4 p2 = pixelAt(image, min(scaled + ivec2(1, 0), imageSize-1));\nvec4 p3 = pixelAt(image, min(scaled + ivec2(1, 1), imageSize-1));\nbool gotCorner = ((thread.x & 1) + (thread.y & 1) == 0) &&\n(all(lessThan(scaled + one, size))) &&\n(p0.r + p1.r + p2.r + p3.r > 0.0f);\nvec2 best = mix(\nvec2(0.0f, pixel.a),\nmix(\nmix(\np1.r > p3.r ? p1.ra : p3.ra,\np1.r > p2.r ? p1.ra : p2.ra,\nB2(p2.r > p3.r)\n),\nmix(\np0.r > p3.r ? p0.ra : p3.ra,\np0.r > p2.r ? p0.ra : p2.ra,\nB2(p2.r > p3.r)\n),\nB2(p0.r > p1.r)\n),\nB2(gotCorner)\n);\ncolor = vec4(best.x, pixel.gb, best.y);\n}"},function(module,exports){module.exports="uniform sampler2D image;\nvoid main()\n{\nivec2 thread = threadLocation();\nivec2 size = outputSize();\nivec2 zero = ivec2(0, 0);\ncolor = pixelAt(image, clamp(thread, zero, size - 1));\n}"},function(module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,"load",(function(){return load})),__webpack_require__.d(__webpack_exports__,"camera",(function(){return camera})),__webpack_require__.d(__webpack_exports__,"pipeline",(function(){return speedy_pipeline})),__webpack_require__.d(__webpack_exports__,"version",(function(){return version})),__webpack_require__.d(__webpack_exports__,"fps",(function(){return fps}));class SpeedyError extends Error{constructor(message,...args){const text=[message,...args].join(" ");console.error("[speedy-vision.js]",text),super(text)}get name(){return this.constructor.name}}class utils_Utils{static fatal(text,...args){throw new SpeedyError(text,...args)}static warning(text,...args){const message=[text,...args].join(" ");return console.warn("[speedy-vision.js]",message),message}static log(text,...args){const message=[text,...args].join(" ");return console.log("[speedy-vision.js]",message),message}static assert(expr,text=""){if(!expr)throw new SpeedyError("Assertion failed.",text)}static enum(...values){return Object.freeze(values.reduce((acc,cur)=>(acc[cur]=Symbol(cur),acc),{}))}static get setZeroTimeout(){return this._setZeroTimeout||(this._setZeroTimeout=(()=>{const msgId="0%"+Math.random().toString(36).slice(2),queue=[];return window.addEventListener("message",ev=>{ev.source===window&&ev.data===msgId&&(event.stopPropagation(),queue.shift().call(window))},!0),function(fn){queue.push(fn),window.postMessage(msgId,"*")}})())}static gaussianNoise(mu=0,sigma=1){const TWO_PI=2*Math.PI;let a,b=Math.random();do{a=Math.random()}while(a<=Number.EPSILON);return Math.sqrt(-2*Math.log(a))*Math.sin(TWO_PI*b)*sigma+mu}static gaussianKernel(sigma,kernelSize=-1,normalized=!0){kernelSize<0&&(kernelSize=0|Math.ceil(5*sigma),kernelSize+=1-kernelSize%2),(kernelSize|=0)<1||kernelSize%2==0?utils_Utils.fatal(`Invalid kernel size given to gaussianKernel: ${kernelSize} x 1`):sigma<=0&&utils_Utils.fatal("Invalid sigma given to gaussianKernel: "+sigma);const kernel=new Array(kernelSize),N=kernelSize>>1,c=+sigma*Math.sqrt(2),m=.3275911,a1=.254829592,a2=-.284496736,a3=1.421413741,a4=-1.453152027,a5=1.061405429;let sum=0;for(let j=0;j<kernelSize;j++){let xa=(j-N+.5)/c,xb=(j-N-.5)/c,sa=1,sb=1;xa<0&&(sa=-1,xa=-xa),xb<0&&(sb=-1,xb=-xb);const ta=1/(1+m*xa),tb=1/(1+m*xb),pb=((((a5*tb+a4)*tb+a3)*tb+a2)*tb+a1)*tb,fp=(sa*(1-((((a5*ta+a4)*ta+a3)*ta+a2)*ta+a1)*ta*Math.exp(-xa*xa))-sb*(1-pb*Math.exp(-xb*xb)))/(2*c);kernel[j]=fp,sum+=fp}return normalized?kernel.map(k=>k/sum):kernel}}class GLError extends Error{constructor(message){super("[GLError] "+message),this.name=this.constructor.name}}class GLUtils{static Error(message){return new GLError(message)}static getError(gl){const glError=gl.getError(),message=["NO_ERROR","INVALID_ENUM","INVALID_VALUE","INVALID_OPERATION","INVALID_FRAMEBUFFER_OPERATION","OUT_OF_MEMORY","CONTEXT_LOST_WEBGL"].find(error=>gl[error]==glError)||"Unknown";return new GLError(message)}static createShader(gl,type,source){const shader=gl.createShader(type);return gl.shaderSource(shader,source),gl.compileShader(shader),shader}static createProgram(gl,vertexShaderSource,fragmentShaderSource){const program=gl.createProgram(),vertexShader=GLUtils.createShader(gl,gl.VERTEX_SHADER,vertexShaderSource),fragmentShader=GLUtils.createShader(gl,gl.FRAGMENT_SHADER,fragmentShaderSource);if(gl.attachShader(program,vertexShader),gl.attachShader(program,fragmentShader),gl.linkProgram(program),!gl.getProgramParameter(program,gl.LINK_STATUS)&&!gl.isContextLost()){const errors=[gl.getShaderInfoLog(fragmentShader),gl.getShaderInfoLog(vertexShader),gl.getProgramInfoLog(program)],spaces=i=>Math.max(0,2-Math.floor(Math.log10(i))),col=k=>Array(spaces(k)).fill(" ").join("")+k+". ",formattedSource=fragmentShaderSource.split("\n").map((line,no)=>col(1+no)+line).join("\n");throw gl.deleteProgram(program),gl.deleteShader(fragmentShader),gl.deleteShader(vertexShader),GLUtils.Error("Can't create shader program.\n\n---------- ERROR ----------\n"+errors.join("\n")+"\n\n---------- SOURCE CODE ----------\n"+formattedSource)}return program}static createTexture(gl,width,height){if(width<=0||height<=0)throw GLUtils.Error("Invalid dimensions given to createTexture()");const texture=gl.createTexture();return gl.bindTexture(gl.TEXTURE_2D,texture),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.MIRRORED_REPEAT),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.MIRRORED_REPEAT),gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA8,width,height,0,gl.RGBA,gl.UNSIGNED_BYTE,null),gl.bindTexture(gl.TEXTURE_2D,null),texture}static destroyTexture(gl,texture){return gl.deleteTexture(texture),null}static uploadToTexture(gl,texture,width,height,pixels){return gl.bindTexture(gl.TEXTURE_2D,texture),gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA8,gl.RGBA,gl.UNSIGNED_BYTE,pixels),gl.bindTexture(gl.TEXTURE_2D,null),texture}static generateMipmap(gl,texture){gl.bindTexture(gl.TEXTURE_2D,texture),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR_MIPMAP_NEAREST),gl.generateMipmap(gl.TEXTURE_2D),gl.bindTexture(gl.TEXTURE_2D,null)}static bindTextures(gl,textureMap,locationMap){const names=Object.keys(textureMap);if(!gl.isContextLost()){if(names.length>gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS)throw GLUtils.Error(`Can't bind ${names.length} textures to a program: max is ${gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS}`);for(let i=0;i<names.length;i++)gl.activeTexture(gl.TEXTURE0+i),gl.bindTexture(gl.TEXTURE_2D,textureMap[names[i]]),gl.uniform1i(locationMap[names[i]],i)}}static createFramebuffer(gl,texture){const fbo=gl.createFramebuffer();gl.bindFramebuffer(gl.FRAMEBUFFER,fbo),gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,texture,0);const status=gl.checkFramebufferStatus(gl.FRAMEBUFFER);if(status!=gl.FRAMEBUFFER_COMPLETE){const error=["FRAMEBUFFER_UNSUPPORTED","FRAMEBUFFER_INCOMPLETE_ATTACHMENT","FRAMEBUFFER_INCOMPLETE_DIMENSIONS","FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT","FRAMEBUFFER_INCOMPLETE_MULTISAMPLE"].filter(err=>gl[err]===status)[0]||"unknown error";throw GLUtils.Error(`Can't create framebuffer: ${error} (${status})`)}return gl.bindFramebuffer(gl.FRAMEBUFFER,null),fbo}static destroyFramebuffer(gl,fbo){return gl.deleteFramebuffer(fbo),null}static clientWaitAsync(gl,sync,flags=0){return new Promise((resolve,reject)=>{const isFirefox=navigator.userAgent.includes("Firefox");!function checkStatus(){const status=gl.clientWaitSync(sync,flags,0);status==gl.TIMEOUT_EXPIRED?setTimeout(checkStatus,0):status==gl.WAIT_FAILED?isFirefox&&gl.getError()==gl.NO_ERROR?setTimeout(checkStatus,0):reject(GLUtils.getError(gl)):resolve()}()})}static getBufferSubDataAsync(gl,glBuffer,target,srcByteOffset,destBuffer,destOffset=0,length=0){const sync=gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE,0),start=performance.now();return gl.flush(),GLUtils.clientWaitAsync(gl,sync).then(()=>(gl.bindBuffer(target,glBuffer),gl.getBufferSubData(target,srcByteOffset,destBuffer,destOffset,length),gl.bindBuffer(target,null),performance.now()-start)).catch(err=>{throw GLUtils.Error(`Can't getBufferSubDataAsync(): got ${err.message} in clientWaitAsync()`)}).finally(()=>{gl.deleteSync(sync)})}}class ShaderPreprocessor{static run(gl,code){return ShaderPreprocessor._includeRegex=ShaderPreprocessor._includeRegex||(ShaderPreprocessor._includeRegex=/^\s*@\s*include\s+"(.*?)"/gm),ShaderPreprocessor._commentsRegex=ShaderPreprocessor._commentsRegex||(ShaderPreprocessor._commentsRegex=[/\/\*(.|\s)*?\*\//g,/\/\/.*$/gm]),String(code).replace(ShaderPreprocessor._commentsRegex[0],"").replace(ShaderPreprocessor._commentsRegex[1],"").replace(ShaderPreprocessor._includeRegex,(_,filename)=>function(gl,filename){if(String(filename).match(/^[a-zA-Z0-9_\-]+\.glsl$/))return __webpack_require__(0)("./"+filename);throw GLUtils.Error(`Shader preprocessor: can't read file "${filename}"`)}(0,filename))}}const UNIFORM_TYPES={sampler2D:"uniform1i",float:"uniform1f",int:"uniform1i",uint:"uniform1ui",bool:"uniform1i",vec2:"uniform2f",vec3:"uniform3f",vec4:"uniform4f",ivec2:"uniform2i",ivec3:"uniform3i",ivec4:"uniform4i",uvec2:"uniform2ui",uvec3:"uniform3ui",uvec4:"uniform4ui",bvec2:"uniform2i",bvec3:"uniform3i",bvec4:"uniform4i"};class speedy_program_SpeedyProgram extends Function{constructor(gl,shaderdecl,options={}){return super("...args","return this._self._call(...args)"),this._self=this.bind(this),this._self._init(gl,shaderdecl,options),this._self}resize(width,height){const gl=this._gl,options=this._options;if(gl.isContextLost())return;if(width===this._stdprog.width&&height===this._stdprog.height)return;width=Math.max(1,0|width),height=Math.max(1,0|height),options.output[0]=width,options.output[1]=height,this._stdprog.width=width,this._stdprog.height=height;const uniform=this._stdprog.uniform.texSize;gl[UNIFORM_TYPES[uniform.type]](uniform.location,width,height),this._reallocatePixelBuffers(width,height)}readPixelsSync(x=0,y=0,width=-1,height=-1){const gl=this._gl;return gl.isContextLost()||(width<0&&(width=this._stdprog.width),height<0&&(height=this._stdprog.height),width=Math.min(width,this._stdprog.width),height=Math.min(height,this._stdprog.height),x=Math.max(0,Math.min(x,width-1)),y=Math.max(0,Math.min(y,height-1)),null==this._pixelBuffer[0]&&this._reallocatePixelBuffers(this._stdprog.width,this._stdprog.height),this._stdprog.hasOwnProperty("fbo")?(gl.bindFramebuffer(gl.FRAMEBUFFER,this._stdprog.fbo),gl.readPixels(x,y,width,height,gl.RGBA,gl.UNSIGNED_BYTE,this._pixelBuffer[0]),gl.bindFramebuffer(gl.FRAMEBUFFER,null)):gl.readPixels(x,y,width,height,gl.RGBA,gl.UNSIGNED_BYTE,this._pixelBuffer[0])),this._pixelBuffer[0]}readPixelsAsync(x=0,y=0,width=-1,height=-1){const gl=this._gl;if(gl.isContextLost())return Promise.resolve(this._pixelBuffer[0]);if(width<0&&(width=this._stdprog.width),height<0&&(height=this._stdprog.height),width=Math.min(width,this._stdprog.width),height=Math.min(height,this._stdprog.height),x=Math.max(0,Math.min(x,width-1)),y=Math.max(0,Math.min(y,height-1)),null==this._pixelBuffer[0]&&this._reallocatePixelBuffers(this._stdprog.width,this._stdprog.height),this._pboProducerQueue.length>0){const nextPBO=this._pboProducerQueue.shift();downloadDMA(gl,this._pixelBuffer[nextPBO],x,y,width,height,this._stdprog.fbo).then(downloadTime=>{this._pboConsumerQueue.push(nextPBO)})}else waitForQueueNotEmpty(this._pboProducerQueue).then(waitTime=>{const nextPBO=this._pboProducerQueue.shift();downloadDMA(gl,this._pixelBuffer[nextPBO],x,y,width,height,this._stdprog.fbo).then(downloadTime=>{this._pboConsumerQueue.push(nextPBO)})});if(this._pboConsumerQueue.length>0){const readyPBO=this._pboConsumerQueue.shift();return new Promise(resolve=>{resolve(this._pixelBuffer[readyPBO]),this._pboProducerQueue.push(readyPBO)})}return new Promise(resolve=>{waitForQueueNotEmpty(this._pboConsumerQueue).then(waitTime=>{const readyPBO=this._pboConsumerQueue.shift();resolve(this._pixelBuffer[readyPBO]),this._pboProducerQueue.push(readyPBO)})})}get uniforms(){return this._stdprog.uniform}_init(gl,shaderdecl,options){options={output:[gl.drawingBufferWidth,gl.drawingBufferHeight],uniforms:{},renderToTexture:!0,recycleTexture:!0,...options};let width=Math.max(1,0|options.output[0]),height=Math.max(1,0|options.output[1]);options.output=[width,height];const canvas=gl.canvas;width>canvas.width&&(canvas.width=width),height>canvas.height&&(canvas.height=height);const source=shaderdecl();let stdprog=function(gl,width,height,fragmentShaderSource,uniforms={}){const source=ShaderPreprocessor.run(gl,'#version 300 es\nprecision highp float;\nprecision highp int;\nprecision mediump sampler2D;\n \nout vec4 color;\nin vec2 texCoord;\nuniform vec2 texSize;\n\n@include "global.glsl"\n'+fragmentShaderSource),program=GLUtils.createProgram(gl,"#version 300 es\nin vec2 a_position;\nin vec2 a_texCoord;\nout vec2 texCoord;\n \nvoid main() {\n    gl_Position = vec4(a_position, 0, 1);\n    texCoord = a_texCoord;\n}",source);gl.bindAttribLocation(program,0,"a_position"),gl.bindAttribLocation(program,1,"a_texCoord");const vertexObjects=createStandardGeometry(gl);width=Math.max(0|width,1),height=Math.max(0|height,1),uniforms.texSize=[width,height];const uniform=function(shaderSource){const sourceWithoutComments=shaderSource,regex=/uniform\s+(\w+)\s+([^;]+)/g,uniforms={};let match;for(;null!==(match=regex.exec(sourceWithoutComments));){const type=match[1],names=match[2].split(",").map(name=>name.trim()).filter(name=>name);for(const name of names)if(name.endsWith("]")){if(!(match=name.match(/(\w+)\s*\[\s*(\d+)\s*\]$/)))throw GLUtils.Error(`Unspecified array length for uniform "${name}" in the shader`);const[array,length]=[match[1],Number(match[2])];for(let i=0;i<length;i++)uniforms[`${array}[${i}]`]={type:type}}else uniforms[name]={type:type}}return Object.freeze(uniforms)}(source);gl.useProgram(program);for(const u in uniform){if(uniform[u].location=gl.getUniformLocation(program,u),!UNIFORM_TYPES.hasOwnProperty(uniform[u].type))throw GLUtils.Error("Unknown uniform type: "+uniform[u].type);if(uniforms.hasOwnProperty(u)){const value=uniforms[u];if("number"==typeof value||"boolean"==typeof value)gl[UNIFORM_TYPES[uniform[u].type]](uniform[u].location,value);else{if("object"!=typeof value)throw GLUtils.Error(`Unrecognized uniform value: "${value}"`);gl[UNIFORM_TYPES[uniform[u].type]](uniform[u].location,...Array.from(value))}}}return{program:program,gl:gl,uniform:uniform,width:width,height:height,...vertexObjects}}(gl,width,height,source,options.uniforms);options.renderToTexture&&(stdprog=function(stdprog){const gl=stdprog.gl,width=stdprog.width,height=stdprog.height,texture=GLUtils.createTexture(gl,width,height),fbo=GLUtils.createFramebuffer(gl,texture);return Object.assign(stdprog,{texture:texture,fbo:fbo})}(stdprog));const params=function(fun){const code=fun.toString(),regex=code.startsWith("function")?"function\\s.*\\(([^)]*)\\)":code.startsWith("(")?"\\(([^)]*)\\).*=>":"([^=]+).*=>",match=new RegExp(regex).exec(code);if(null!==match){return match[1].replace(/\/\*.*?\*\//g,"").split(",").map(argname=>argname.replace(/=.*$/,"").trim()).filter(argname=>argname)}throw GLUtils.Error("Can't detect function arguments of "+code)}(shaderdecl);for(let j=0;j<params.length;j++)if(!stdprog.uniform.hasOwnProperty(params[j])&&!stdprog.uniform.hasOwnProperty(params[j]+"[0]"))throw GLUtils.Error(`Can't run shader: expected uniform "${params[j]}"`);this._gl=gl,this._source=source,this._options=options,this._stdprog=stdprog,this._params=params,this._initPixelBuffers()}_call(...args){const gl=this._gl,options=this._options,stdprog=this._stdprog,params=this._params;if(gl.isContextLost())return stdprog.texture||null;if(args.length!=params.length)throw GLUtils.Error("Can't run shader: incorrect number of arguments");gl.useProgram(stdprog.program);for(let i=0,texNo=0;i<args.length;i++){const argname=params[i];let uniform=stdprog.uniform[argname];if(uniform)texNo=this._setUniform(uniform,args[i],texNo);else{if(!stdprog.uniform.hasOwnProperty(argname+"[0]"))throw GLUtils.Error(`Can't run shader: unknown parameter "${argname}": ${args[i]}`);{const array=args[i];if(stdprog.uniform.hasOwnProperty(`${argname}[${array.length}]`))throw GLUtils.Error(`Can't run shader: too few elements in array "${argname}"`);for(let j=0;uniform=stdprog.uniform[`${argname}[${j}]`];j++)texNo=this._setUniform(uniform,array[j],texNo)}}}options.renderToTexture?gl.bindFramebuffer(gl.FRAMEBUFFER,stdprog.fbo):gl.bindFramebuffer(gl.FRAMEBUFFER,null),gl.viewport(0,0,stdprog.width,stdprog.height),gl.drawArrays(gl.TRIANGLE_STRIP,0,4);let outputTexture=null;if(options.renderToTexture&&(outputTexture=stdprog.texture,!options.recycleTexture)){const cloneTexture=GLUtils.createTexture(gl,stdprog.width,stdprog.height);gl.activeTexture(gl.TEXTURE0),gl.bindTexture(gl.TEXTURE_2D,cloneTexture),gl.copyTexSubImage2D(gl.TEXTURE_2D,0,0,0,0,0,stdprog.width,stdprog.height),gl.bindTexture(gl.TEXTURE_2D,null),outputTexture=cloneTexture}return gl.bindFramebuffer(gl.FRAMEBUFFER,null),outputTexture}_setUniform(uniform,value,texNo){const gl=this._gl;if("sampler2D"==uniform.type){if(texNo>gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS)throw GLUtils.Error(`Can't bind ${texNo} textures to a program: max is ${gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS}`);if(value===this._stdprog.texture)throw GLUtils.Error("Can't run shader: cannot use its output texture as an input to itself");gl.activeTexture(gl.TEXTURE0+texNo),gl.bindTexture(gl.TEXTURE_2D,value),gl.uniform1i(uniform.location,texNo),texNo++}else if("number"==typeof value||"boolean"==typeof value)gl[UNIFORM_TYPES[uniform.type]](uniform.location,value);else{if(!Array.isArray(value))throw GLUtils.Error(`Can't run shader: unrecognized argument "${value}"`);gl[UNIFORM_TYPES[uniform.type]](uniform.location,...value)}return texNo}_initPixelBuffers(){this._pixelBuffer=Array(2).fill(null),this._pixelBufferSize=[0,0],this._pboConsumerQueue=Array(2).fill(0).map((_,i)=>i),this._pboProducerQueue=[]}_reallocatePixelBuffers(width,height){if(!(width*height<=this._pixelBufferSize[0]*this._pixelBufferSize[1])){this._pixelBufferSize[0]=width,this._pixelBufferSize[1]=height;for(let i=0;i<2;i++){const oldBuffer=this._pixelBuffer[i];this._pixelBuffer[i]=createPixelBuffer(width,height),oldBuffer&&(oldBuffer.length>this._pixelBuffer[i].length?this._pixelBuffer[i].set(oldBuffer.slice(0,this._pixelBuffer[i].length)):this._pixelBuffer[i].set(oldBuffer))}}}}function waitForQueueNotEmpty(queue){return new Promise(resolve=>{const start=performance.now();!function wait(){queue.length>0?resolve(performance.now()-start):setTimeout(wait,0)}()})}function createStandardGeometry(gl){const f=createStandardGeometry,cache=f._cache||(f._cache=new WeakMap);if(cache.has(gl))return cache.get(gl);const vao=gl.createVertexArray(),vbo=[gl.createBuffer(),gl.createBuffer()];gl.bindVertexArray(vao),gl.bindBuffer(gl.ARRAY_BUFFER,vbo[0]),gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([-1,-1,1,-1,-1,1,1,1]),gl.STATIC_DRAW),gl.vertexAttribPointer(0,2,gl.FLOAT,!1,0,0),gl.enableVertexAttribArray(0),gl.bindBuffer(gl.ARRAY_BUFFER,vbo[1]),gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([0,0,1,0,0,1,1,1]),gl.STATIC_DRAW),gl.vertexAttribPointer(1,2,gl.FLOAT,!1,0,0),gl.enableVertexAttribArray(1),gl.bindBuffer(gl.ARRAY_BUFFER,null);const result={vao:vao,vbo:vbo};return cache.set(gl,result),result}function createPixelBuffer(width,height){const pixels=new Uint8Array(width*height*4);return pixels.fill(255,0,4),pixels}function downloadDMA(gl,arrayBuffer,x,y,width,height,fbo=null){const pbo=gl.createBuffer();return gl.bindBuffer(gl.PIXEL_PACK_BUFFER,pbo),gl.bufferData(gl.PIXEL_PACK_BUFFER,arrayBuffer.byteLength,gl.STREAM_READ),fbo?(gl.bindFramebuffer(gl.FRAMEBUFFER,fbo),gl.readPixels(x,y,width,height,gl.RGBA,gl.UNSIGNED_BYTE,0),gl.bindFramebuffer(gl.FRAMEBUFFER,null)):gl.readPixels(x,y,width,height,gl.RGBA,gl.UNSIGNED_BYTE,0),gl.bindBuffer(gl.PIXEL_PACK_BUFFER,null),GLUtils.getBufferSubDataAsync(gl,pbo,gl.PIXEL_PACK_BUFFER,0,arrayBuffer,0,0).then(timeInMs=>timeInMs).catch(err=>{throw err}).finally(()=>{gl.deleteBuffer(pbo)})}class GPUProgramGroup{constructor(gpu,width,height){this._gpu=gpu,this._width=width,this._height=height}declare(name,shaderdecl,settings={}){return Object.defineProperty(this,name,{get:(()=>{const key="__k_"+name;return function(){return this[key]||(this[key]=this._createProgram(shaderdecl,settings))}.bind(this)})()}),this}compose(name,...fn){return Object.defineProperty(this,name,{get:(()=>{const key="__c_"+name;return function(){return this[key]||(this[key]=2==fn.length?(()=>(fn=fn.map(fi=>this[fi]),function(image,...args){return fn[1](fn[0](image,...args),...args)}))():3==fn.length?(()=>(fn=fn.map(fi=>this[fi]),function(image,...args){return fn[2](fn[1](fn[0](image,...args),...args),...args)}))():4==fn.length?(()=>(fn=fn.map(fi=>this[fi]),function(image,...args){return fn[3](fn[2](fn[1](fn[0](image,...args),...args),...args),...args)}))():(()=>(fn=fn.map(fi=>this[fi]),function(image,...args){return fn.reduce((img,fi)=>fi(img,...args),image)}))())}.bind(this)})()}),this}get program(){return this._helpers||(this.helpers={hasTextureSize:(width,height)=>({output:[0|width,0|height]}),displaysGraphics:()=>({renderToTexture:!1}),doesNotRecycleTextures:()=>({recycleTexture:!1})})}_createProgram(shaderdecl,settings={}){return this._gpu.createProgram(shaderdecl,{output:[this._width,this._height],...settings})}}const identity=image=>__webpack_require__(4),flipY=image=>__webpack_require__(5);const rgb2grey=image=>__webpack_require__(6);const cartesian=(a,b)=>[].concat(...a.map(a=>b.map(b=>[a,b]))),symmetricRange=n=>[...Array(2*n+1).keys()].map(x=>x-n);function convX(kernel,normalizationConstant=1){return conv1D("x",kernel,normalizationConstant)}function convY(kernel,normalizationConstant=1){return conv1D("y",kernel,normalizationConstant)}function conv1D(axis,kernel,normalizationConstant){const kernel32=new Float32Array(kernel.map(x=>+x*+normalizationConstant)),kSize=kernel32.length,N=kSize/2|0;kSize<1||kSize%2==0?utils_Utils.fatal("Can't perform a 1D convolution with an invalid kSize of "+kSize):"x"!=axis&&"y"!=axis&&utils_Utils.fatal(`Can't perform 1D convolution: invalid axis "${axis}"`);const shader=`\n    uniform sampler2D image;\n\n    void main()\n    {\n        float alpha = threadPixel(image).a;\n        vec4 pixel = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n\n        ${fn=(k,i)=>"x"==axis?`\n        pixel += pixelAtOffset(image, ivec2(${0|i}, 0)) * float(${+k});\n    `:`\n        pixel += pixelAtOffset(image, ivec2(0, ${0|i})) * float(${+k});\n    `,symmetricRange(N).reduce((acc,cur)=>acc+fn(kernel32[cur+N],cur),"")}\n\n        color = vec4(pixel.rgb, alpha);\n    }\n    `;var fn;return image=>shader}function createKernel2D(kernelSize){((kernelSize|=0)<1||kernelSize%2==0)&&utils_Utils.fatal("Can't create a 2D texture kernel of size "+kernelSize);const shader=`\n    uniform float kernel[${kernelSize*kernelSize}];\n\n    void main()\n    {\n        ivec2 thread = threadLocation();\n        float val = kernel[(${kernelSize}) * thread.y + thread.x];\n\n        float e0 = floor(val);\n        float e1 = 256.0f * fract(val);\n        float e2 = 256.0f * fract(e1);\n        float e3 = 256.0f * fract(e2);\n\n        color = vec4(e0, floor(e1) / 256.0f, floor(e2) / 256.0f, floor(e3) / 256.0f);\n    }\n    `;return kernel=>shader}function createKernel1D(kernelSize){((kernelSize|=0)<1||kernelSize%2==0)&&utils_Utils.fatal("Can't create a 1D texture kernel of size "+kernelSize);const shader=`\n    uniform float kernel[${kernelSize}];\n\n    void main()\n    {\n        ivec2 thread = threadLocation();\n        float val = kernel[thread.x];\n\n        float e0 = floor(val);\n        float e1 = 256.0f * fract(val);\n        float e2 = 256.0f * fract(e1);\n        float e3 = 256.0f * fract(e2);\n\n        color = vec4(e0, floor(e1) / 256.0f, floor(e2) / 256.0f, floor(e3) / 256.0f);\n    }\n    `;return kernel=>shader}function texConv2D(kernelSize){const N=kernelSize>>1;(kernelSize<1||kernelSize%2==0)&&utils_Utils.fatal("Can't perform a texture-based 2D convolution with an invalid kernel size of "+kernelSize);const shader=`\n    const vec4 magic = vec4(1.0f, 1.0f, 1.0f / 256.0f, 1.0f / 65536.0f);\n    uniform sampler2D image, texKernel;\n    uniform float scale, offset;\n\n    void main()\n    {\n        vec4 kernel = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n        vec4 result = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n        float alpha = threadPixel(image).a;\n        float value = 0.0f;\n\n        ${fn=(i,j)=>`\n        kernel = pixelAt(texKernel, ivec2(${i+N}, ${j+N}));\n        value = dot(kernel, magic) * scale + offset;\n        result += pixelAtOffset(image, ivec2(${i}, ${j})) * value;\n    `,cartesian(symmetricRange(N),symmetricRange(N)).map(ij=>fn(ij[0],ij[1])).join("\n")}\n\n        result = clamp(result, 0.0f, 1.0f);\n        color = vec4(result.rgb, alpha);\n    }\n    `;var fn;return(image,texKernel,scale,offset)=>shader}const texConvX=kernelSize=>texConv1D(kernelSize,"x"),texConvY=kernelSize=>texConv1D(kernelSize,"y");function texConv1D(kernelSize,axis){const N=kernelSize>>1;kernelSize<1||kernelSize%2==0?utils_Utils.fatal("Can't perform a texture-based 2D convolution with an invalid kernel size of "+kernelSize):"x"!=axis&&"y"!=axis&&utils_Utils.fatal(`Can't perform a texture-based 1D convolution: invalid axis "${axis}"`);const shader=`\n    const vec4 magic = vec4(1.0f, 1.0f, 1.0f / 256.0f, 1.0f / 65536.0f);\n    uniform sampler2D image, texKernel;\n    uniform float scale, offset;\n\n    void main()\n    {\n        vec4 kernel = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n        vec4 result = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n        float alpha = threadPixel(image).a;\n        float value = 0.0f;\n\n        ${fn=i=>"x"==axis?`\n        kernel = pixelAt(texKernel, ivec2(${i+N}, 0));\n        value = dot(kernel, magic) * scale + offset;\n        result += pixelAtOffset(image, ivec2(${i}, 0)) * value;\n    `:`\n        kernel = pixelAt(texKernel, ivec2(${i+N}, 0));\n        value = dot(kernel, magic) * scale + offset;\n        result += pixelAtOffset(image, ivec2(0, ${i})) * value;\n    `,symmetricRange(N).map(fn).join("\n")}\n\n        result = clamp(result, 0.0f, 1.0f);\n        color = vec4(result.rgb, alpha);\n    }\n    `;var fn;return(image,texKernel,scale,offset)=>shader}const fast9=(image,threshold)=>__webpack_require__(7),fast9pyr=(image,threshold,minLod,maxLod,log2PyrMaxScale,pyrMaxLevels,resetCorners)=>__webpack_require__(8),fast7=(image,threshold)=>__webpack_require__(9),fast5=(image,threshold)=>__webpack_require__(10),fastScore16=(image,threshold)=>__webpack_require__(11),fastScore12=(image,threshold)=>__webpack_require__(12),fastScore8=(image,threshold)=>__webpack_require__(13),fastSuppression=image=>__webpack_require__(14),multiscaleSuppression=(image,lodJump,log2PyrMaxScale,pyrMaxLevels)=>__webpack_require__(15),samescaleSuppression=(image,log2PyrMaxScale,pyrMaxLevels)=>__webpack_require__(16),brisk=(image,layerA,layerB,scaleA,scaleB,lgM,h)=>__webpack_require__(17);const encodeKeypointOffsets=(image,imageSize,maxIterations)=>__webpack_require__(18),encodeKeypoints=(image,imageSize,encoderLength,descriptorSize)=>__webpack_require__(19);class SpeedyFeature{constructor(x,y,scale=1,rotation=0,descriptor=null){this._x=+x,this._y=+y,this._scale=+scale,this._rotation=+rotation,this._descriptor=descriptor}toString(){return`(${this._x},${this._y})`}get x(){return this._x}get y(){return this._y}get scale(){return this._scale}get rotation(){return this._rotation}get descriptor(){return this._descriptor}}class tuner_Bucket{constructor(bucketSize=32,windowSize=5){this._bucketSize=1<<Math.ceil(Math.log2(bucketSize)),this._windowSize=windowSize+(1-windowSize%2),bucketSize<this._windowSize&&utils_Utils.fatal("Invalid bucketSize of "+bucketSize),this._head=this._bucketSize-1,this._rawData=new Float32Array(this._bucketSize).fill(0),this._smoothedData=new Float32Array(this._bucketSize).fill(0),this._average=0,this._isSmooth=!0}put(value){this._head=this._head+1&this._bucketSize-1,this._rawData[this._head]=value,this._isSmooth=!1}get size(){return this._bucketSize}get average(){return this._isSmooth||this._smooth(),this._average}fill(value){return this._rawData.fill(value),this._smoothedData.fill(value),this._average=value,this._isSmooth=!0,this._head=this._bucketSize-1,this}_smooth(){this._average=0;for(let i=0;i<this._bucketSize;i++)this._smoothedData[i]=this._median(this._window(i)),this._average+=this._smoothedData[i];this._average/=this._bucketSize,this._isSmooth=!0}_window(i){const arr=this._rawData,win=this._win||(this._win=new Float32Array(this._windowSize)),n=arr.length,wOver2=win.length>>1,head=this._head,tail=head+1&n-1;for(let j=0,k=-wOver2;k<=wOver2;k++){let pos=i+k;i<=head?pos>head&&(pos=head+(head-pos)):pos<tail&&(pos=tail+(tail-pos)),pos<0?pos+=n:pos>=n&&(pos-=n),win[j++]=arr[pos]}return win}_median(v){switch(v.length){case 1:return v[0];case 3:return v[0]>v[1]&&([v[0],v[1]]=[v[1],v[0]]),v[1]>v[2]&&([v[1],v[2]]=[v[2],v[1]]),v[0]>v[1]&&([v[0],v[1]]=[v[1],v[0]]),v[1];case 5:return v[0]>v[1]&&([v[0],v[1]]=[v[1],v[0]]),v[3]>v[4]&&([v[3],v[4]]=[v[4],v[3]]),v[0]>v[3]&&([v[0],v[3]]=[v[3],v[0]]),v[1]>v[4]&&([v[1],v[4]]=[v[4],v[1]]),v[1]>v[2]&&([v[1],v[2]]=[v[2],v[1]]),v[2]>v[3]&&([v[2],v[3]]=[v[3],v[2]]),v[1]>v[2]&&([v[1],v[2]]=[v[2],v[1]]),v[2];case 7:return v[0]>v[5]&&([v[0],v[5]]=[v[5],v[0]]),v[0]>v[3]&&([v[0],v[3]]=[v[3],v[0]]),v[1]>v[6]&&([v[1],v[6]]=[v[6],v[1]]),v[2]>v[4]&&([v[2],v[4]]=[v[4],v[2]]),v[0]>v[1]&&([v[0],v[1]]=[v[1],v[0]]),v[3]>v[5]&&([v[3],v[5]]=[v[5],v[3]]),v[2]>v[6]&&([v[2],v[6]]=[v[6],v[2]]),v[2]>v[3]&&([v[2],v[3]]=[v[3],v[2]]),v[3]>v[6]&&([v[3],v[6]]=[v[6],v[3]]),v[4]>v[5]&&([v[4],v[5]]=[v[5],v[4]]),v[1]>v[4]&&([v[1],v[4]]=[v[4],v[1]]),v[1]>v[3]&&([v[1],v[3]]=[v[3],v[1]]),v[3]>v[4]&&([v[3],v[4]]=[v[4],v[3]]),v[3];default:return v.sort((a,b)=>a-b),(v[v.length-1>>1]+v[v.length>>1])/2}}}class tuner_Tuner{constructor(initialState,minState,maxState){minState>=maxState&&utils_Utils.fatal(`Invalid boundaries [${minState},${maxState}] given to the Tuner`),initialState=Math.max(minState,Math.min(initialState,maxState)),this._state=initialState,this._prevState=initialState,this._prevPrevState=initialState,this._initialState=initialState,this._minState=minState,this._maxState=maxState,this._bucket=new Array(maxState-minState+1).fill(null).map(x=>new tuner_Bucket(this._bucketSetup().size,this._bucketSetup().window)),this._iterations=0,this._epoch=0}currentValue(){return this._state}feedObservation(y){const bucket=this._bucketOf(this._state);if(bucket.put(+y),++this._iterations>=bucket.size){0==this._epoch&&(this._bucket.forEach(bk=>bk.fill(bucket.average)),isFinite(this._costOfBestState)||(this._costOfBestState=bucket.average));const clip=s=>Math.max(this._minState,Math.min(0|s,this._maxState)),prevPrevState=this._prevState,prevState=this._state;this._state=clip(this._nextState()),this._prevState=prevState,this._prevPrevState=prevPrevState,this._iterations=0,this._epoch++}}reset(){this._state=this._initialState,this._prevState=this._initialState,this._prevPrevState=this._initialState,this._iterations=0,this._epoch=0}finished(){return!1}_bucketOf(state){return state=Math.max(this._minState,Math.min(0|state,this._maxState)),this._bucket[state-this._minState]}_bucketSetup(){return{size:32,window:5}}_nextState(){return this._state}info(){const bucket=this._bucketOf(this._state),prevBucket=this._bucketOf(this._prevState);return{now:this._state,avg:bucket.average,itr:[this._iterations,this._epoch],bkt:bucket._smoothedData,cur:new Array(bucket.size).fill(0).map((x,i)=>i==bucket._head?1:0),prv:[this._prevState,prevBucket.average],fim:this.finished()}}}class StochasticTuner extends tuner_Tuner{constructor(initialState,minState,maxState,alpha=.5,maxIterationsPerTemperature=8,initialTemperature=100,neighborFn=null){super(initialState,minState,maxState),this._bestState=this._initialState,this._costOfBestState=1/0,this._initialTemperature=Math.max(0,initialTemperature),this._temperature=this._initialTemperature,this._numIterations=0,this._maxIterationsPerTemperature=Math.max(1,maxIterationsPerTemperature),this._alpha=Math.max(0,Math.min(alpha,1)),neighborFn||(neighborFn=s=>this._minState+Math.floor(Math.random()*(this._maxState-this._minState+1))),this._pickNeighbor=neighborFn}reset(){this._temperature=this._initialTemperature,this._numIterations=0}finished(){return this._temperature<=1e-5}_nextState(){if(this.finished())return this._bestState;const f=s=>this._bucketOf(s).average;let nextState=this._state,neighbor=0|this._pickNeighbor(this._state,f(this._state));return neighbor=Math.max(this._minState,Math.min(neighbor,this._maxState)),(f(neighbor)<f(this._state)||Math.random()<Math.exp((f(this._state)-f(neighbor))/this._temperature))&&(nextState=neighbor),f(nextState)<this._costOfBestState&&(this._bestState=nextState,this._costOfBestState=f(nextState)),++this._numIterations>=this._maxIterationsPerTemperature&&(this._temperature*=this._alpha,this._numIterations=0),nextState}_bucketSetup(){return{size:4,window:3}}info(){return{best:[this._bestState,this._costOfBestState],state:[this._state,this._bucketOf(this._state).average],iterations:[this._numIterations,this._maxIterationsPerTemperature],temperature:this._temperature,alpha:this._alpha,cool:this.finished()}}}class tuner_OnlineErrorTuner extends tuner_Tuner{constructor(minState,maxState,tolerance=.1,learningRate=.05){super(Math.round(utils_Utils.gaussianNoise((minState+maxState)/2,5)),minState,maxState),this._tolerance=Math.max(0,tolerance),this._bestState=this._initialState,this._expected=null,this._learningRate=Math.max(0,learningRate)}reset(){super.reset(),this._expected=null}feedObservation(observedValue,expectedValue){const obs=+observedValue,expected=+expectedValue;expected!==this._expected&&this.reset(),this._expected=expected;const err=(obs-expected)*(obs-expected)/(expected*expected);super.feedObservation(err)}finished(){return(s=>Math.sqrt(this._bucketOf(s).average)*Math.abs(this._expected))(this._bestState)<=this._tolerance*this._expected}get tolerance(){return this._tolerance}set tolerance(value){this._tolerance=Math.max(0,value)}_nextState(){if(this.finished())return this._bestState;const E=s=>Math.sqrt(this._bucketOf(s).average)*Math.abs(this._expected);E(this._state)<E(this._bestState)&&(this._bestState=this._state);const worldScale=Math.abs(this._maxState),stepSize=this._learningRate*(s=>Math.sqrt(this._bucketOf(s).average)*worldScale)(this._state),sign=x=>(x>=0)-(x<0),direction=sign(E(this._state)-E(this._prevState))*-sign(this._state-this._prevState)*sign(Math.random()-.15),weight=utils_Utils.gaussianNoise(1,.1);let newState=Math.round(this._state+direction*weight*stepSize);return(newState>this._maxState||newState<this._minState)&&(newState=this._bestState),newState}_bucketSetup(){return{size:4,window:3}}info(){return{now:[this._state,this._prevState],bkt:this._bucketOf(this._state)._rawData,cur:this._bucketOf(this._state)._head,err:[this._bucketOf(this._state).average,this._bucketOf(this._prevState).average],sqt:Math.sqrt(this._bucketOf(this._state).average),done:this.finished()}}}const TWO_PI=2*Math.PI;const upsample2=image=>__webpack_require__(20),downsample2=image=>__webpack_require__(21),upsample3=image=>__webpack_require__(22),downsample3=image=>__webpack_require__(23),mergeKeypoints=(target,source)=>__webpack_require__(24),mergeKeypointsAtConsecutiveLevels=(largerImage,smallerImage)=>__webpack_require__(25),normalizeKeypoints=(image,imageScale)=>__webpack_require__(26),crop=image=>__webpack_require__(27);function pyramids_scale(scaleFactor,pyramidHeight,pyramidMaxScale){const lgM=Math.log2(pyramidMaxScale),s=Math.max(1e-5,scaleFactor),delta=-Math.log2(s)/(lgM+pyramidHeight);return image=>`\n    uniform sampler2D image;\n\n    void main()\n    {\n        vec4 pixel = threadPixel(image);\n        float alpha = clamp(pixel.a + float(${delta}), 0.0f, 1.0f);\n\n        color = vec4(pixel.rgb, alpha);\n    }\n    `}const PROGRAM_GROUPS={utils:class extends GPUProgramGroup{constructor(gpu,width,height){super(gpu,width,height),this.declare("identity",identity).declare("flipY",flipY).declare("output",flipY,this.program.displaysGraphics())}},colors:class extends GPUProgramGroup{constructor(gpu,width,height){super(gpu,width,height),this.declare("rgb2grey",rgb2grey)}},filters:class extends GPUProgramGroup{constructor(gpu,width,height){super(gpu,width,height),this.compose("gauss5","_gauss5x","_gauss5y").compose("gauss3","_gauss3x","_gauss3y").compose("gauss7","_gauss7x","_gauss7y").compose("box5","_box5x","_box5y").compose("box3","_box3x","_box3y").compose("box7","_box7x","_box7y").compose("box9","_box9x","_box9y").compose("box11","_box11x","_box11y").compose("texConv2D3","_idConv2D3","_texConv2D3").compose("texConv2D5","_idConv2D5","_texConv2D5").compose("texConv2D7","_idConv2D7","_texConv2D7").declare("_texConv2D3",texConv2D(3)).declare("_idConv2D3",(image,texKernel,scale,offset)=>"\n    uniform sampler2D image, texKernel;\n    uniform float scale, offset;\n\n    void main()\n    {\n        color = threadPixel(image);\n    }\n    ").declare("_texConv2D5",texConv2D(5)).declare("_idConv2D5",(image,texKernel,scale,offset)=>"\n    uniform sampler2D image, texKernel;\n    uniform float scale, offset;\n\n    void main()\n    {\n        color = threadPixel(image);\n    }\n    ").declare("_texConv2D7",texConv2D(7)).declare("_idConv2D7",(image,texKernel,scale,offset)=>"\n    uniform sampler2D image, texKernel;\n    uniform float scale, offset;\n\n    void main()\n    {\n        color = threadPixel(image);\n    }\n    ").compose("texConvXY3","texConvX3","texConvY3").declare("texConvX3",texConvX(3)).declare("texConvY3",texConvY(3)).compose("texConvXY5","texConvX5","texConvY5").declare("texConvX5",texConvX(5)).declare("texConvY5",texConvY(5)).compose("texConvXY7","texConvX7","texConvY7").declare("texConvX7",texConvX(7)).declare("texConvY7",texConvY(7)).compose("texConvXY9","texConvX9","texConvY9").declare("texConvX9",texConvX(9)).declare("texConvY9",texConvY(9)).compose("texConvXY11","texConvX11","texConvY11").declare("texConvX11",texConvX(11)).declare("texConvY11",texConvY(11)).declare("createKernel3x3",createKernel2D(3),{...this.program.hasTextureSize(3,3),...this.program.doesNotRecycleTextures()}).declare("createKernel5x5",createKernel2D(5),{...this.program.hasTextureSize(5,5),...this.program.doesNotRecycleTextures()}).declare("createKernel7x7",createKernel2D(7),{...this.program.hasTextureSize(7,7),...this.program.doesNotRecycleTextures()}).declare("createKernel3x1",createKernel1D(3),{...this.program.hasTextureSize(3,1),...this.program.doesNotRecycleTextures()}).declare("createKernel5x1",createKernel1D(5),{...this.program.hasTextureSize(5,1),...this.program.doesNotRecycleTextures()}).declare("createKernel7x1",createKernel1D(7),{...this.program.hasTextureSize(7,1),...this.program.doesNotRecycleTextures()}).declare("createKernel9x1",createKernel1D(9),{...this.program.hasTextureSize(9,1),...this.program.doesNotRecycleTextures()}).declare("createKernel11x1",createKernel1D(11),{...this.program.hasTextureSize(11,1),...this.program.doesNotRecycleTextures()}).declare("_gauss5x",convX([.05,.25,.4,.25,.05])).declare("_gauss5y",convY([.05,.25,.4,.25,.05])).declare("_gauss3x",convX([.25,.5,.25])).declare("_gauss3y",convY([.25,.5,.25])).declare("_gauss7x",convX([.00598,.060626,.241843,.383103,.241843,.060626,.00598])).declare("_gauss7y",convY([.00598,.060626,.241843,.383103,.241843,.060626,.00598])).declare("_box3x",convX([1,1,1],1/3)).declare("_box3y",convY([1,1,1],1/3)).declare("_box5x",convX([1,1,1,1,1],.2)).declare("_box5y",convY([1,1,1,1,1],.2)).declare("_box7x",convX([1,1,1,1,1,1,1],1/7)).declare("_box7y",convY([1,1,1,1,1,1,1],1/7)).declare("_box9x",convX([1,1,1,1,1,1,1,1,1],1/9)).declare("_box9y",convY([1,1,1,1,1,1,1,1,1],1/9)).declare("_box11x",convX([1,1,1,1,1,1,1,1,1,1,1],1/11)).declare("_box11y",convY([1,1,1,1,1,1,1,1,1,1,1],1/11))}},keypoints:class extends GPUProgramGroup{constructor(gpu,width,height){super(gpu,width,height),this.compose("fast9","_fast9","_fastScore16").declare("_fast9",fast9).declare("_fastScore16",fastScore16).compose("fast7","_fast7","_fastScore12").declare("_fast7",fast7).declare("_fastScore12",fastScore12).compose("fast5","_fast5","_fastScore8").declare("_fast5",fast5).declare("_fastScore8",fastScore8).declare("fast9pyr",fast9pyr).declare("fastSuppression",fastSuppression).declare("brisk",brisk).declare("multiscaleSuppression",multiscaleSuppression).declare("samescaleSuppression",samescaleSuppression)}},encoders:class extends GPUProgramGroup{constructor(gpu,width,height){super(gpu,width,height),this.declare("_encodeKeypointOffsets",encodeKeypointOffsets).declare("_encodeKeypoints",encodeKeypoints,{output:[128,128],renderToTexture:!1});this._tuner=new StochasticTuner(48,32,48,.2,8,60,s=>Math.round(utils_Utils.gaussianNoise(s,64))%256),this._keypointEncoderLength=128,this._descriptorSize=0,this._spawnedAt=performance.now()}optimizeKeypointEncoder(keypointCount){const clampedKeypointCount=Math.max(0,Math.min(keypointCount,5e3)),pixelsPerKeypoint=Math.ceil(2+this._descriptorSize/4),len=Math.ceil(Math.sqrt((4+1.05*clampedKeypointCount)*pixelsPerKeypoint)),newEncoderLength=Math.max(1,Math.min(len,300)),oldEncoderLength=this._keypointEncoderLength;return newEncoderLength!=oldEncoderLength&&(this._keypointEncoderLength=newEncoderLength,this._encodeKeypoints.resize(newEncoderLength,newEncoderLength)),newEncoderLength-oldEncoderLength}async encodeKeypoints(corners,useAsyncTransfer=!0){const encoderLength=this._keypointEncoderLength,descriptorSize=this._descriptorSize,imageSize=[this._width,this._height],maxIterations=this._tuner.currentValue();try{let encodingTime=performance.now();const offsets=this._encodeKeypointOffsets(corners,imageSize,maxIterations);let pixels,transferTime;if(this._encodeKeypoints(offsets,imageSize,encoderLength,descriptorSize),encodingTime=performance.now()-encodingTime,useAsyncTransfer?(transferTime=performance.now(),pixels=await this._encodeKeypoints.readPixelsAsync(0,0,-1,-1),transferTime=performance.now()-transferTime):(transferTime=performance.now(),pixels=this._encodeKeypoints.readPixelsSync(),transferTime=performance.now()-transferTime),performance.now()>=this._spawnedAt+2e3){const time=encodingTime+transferTime;this._tuner.feedObservation(time)}return window._p=window._p||0,window._m=window._m||0,window._m=.9*window._m+.1*(encodingTime+transferTime),window._p++%50==0&&console.log(window._m," | ",maxIterations),pixels}catch(err){utils_Utils.fatal(err)}}decodeKeypoints(pixels){const[w,h]=[this._width,this._height],hasRotation=this._descriptorSize>0,pixelsPerKeypoint=2+this._descriptorSize/4,lgM=Math.log2(this._gpu.pyramidMaxScale),pyrHeight=this._gpu.pyramidHeight,keypoints=[];let x,y,scale,rotation;for(let i=0;i<pixels.length&&(x=pixels[i+1]<<8|pixels[i],y=pixels[i+3]<<8|pixels[i+2],!(x>=w||y>=h));i+=4*pixelsPerKeypoint)scale=255==pixels[i+4]?1:Math.pow(2,-lgM+(lgM+pyrHeight)*pixels[i+4]/255),rotation=hasRotation?pixels[i+5]*TWO_PI/255:0,keypoints.push(new SpeedyFeature(x,y,scale,rotation));return 0==keypoints.length&&this._tuner.finished()&&this._tuner.reset(),keypoints}},pyramids:class extends GPUProgramGroup{constructor(gpu,width,height){super(gpu,width,height),this.declare("setBase",function(scale,pyramidHeight,pyramidMaxScale){const lgM=Math.log2(pyramidMaxScale),pyramidMinScale=Math.pow(2,-pyramidHeight)+1e-5,x=Math.max(pyramidMinScale,Math.min(scale,pyramidMaxScale)),alpha=(lgM-Math.log2(x))/(lgM+pyramidHeight);return image=>`\n    uniform sampler2D image;\n\n    void main()\n    {\n        color = vec4(threadPixel(image).rgb, float(${alpha}));\n    }\n    `}(1,gpu.pyramidHeight,gpu.pyramidMaxScale)).compose("reduce","_smoothX","_smoothY","_downsample2","_scale1/2").compose("expand","_upsample2","_smoothX2","_smoothY2","_scale2").compose("intraReduce","_upsample2","_smoothX2","_smoothY2","_downsample3/2","_scale2/3").compose("intraExpand","_upsample3","_smoothX3","_smoothY3","_downsample2/3","_scale3/2").declare("mergeKeypoints",mergeKeypoints).declare("mergeKeypointsAtConsecutiveLevels",mergeKeypointsAtConsecutiveLevels).declare("normalizeKeypoints",normalizeKeypoints).declare("crop",crop).declare("output",flipY,{...this.program.hasTextureSize(this._width,this._height),...this.program.displaysGraphics()}).declare("output2",flipY,{...this.program.hasTextureSize(2*this._width,2*this._height),...this.program.displaysGraphics()}).declare("output3",flipY,{...this.program.hasTextureSize(3*this._width,3*this._height),...this.program.displaysGraphics()}).declare("_smoothX",convX([.05,.25,.4,.25,.05])).declare("_smoothY",convY([.05,.25,.4,.25,.05])).declare("_smoothX2",convX([.1,.5,.8,.5,.1]),this.program.hasTextureSize(2*this._width,2*this._height)).declare("_smoothY2",convY([.1,.5,.8,.5,.1],.5),this.program.hasTextureSize(2*this._width,2*this._height)).declare("_smoothX3",convX([.2,.8,1,.8,.2]),this.program.hasTextureSize(3*this._width,3*this._height)).declare("_smoothY3",convY([.2,.8,1,.8,.2],1/3),this.program.hasTextureSize(3*this._width,3*this._height)).declare("_upsample2",upsample2,this.program.hasTextureSize(2*this._width,2*this._height)).declare("_downsample2",downsample2,this.program.hasTextureSize((1+this._width)/2,(1+this._height)/2)).declare("_upsample3",upsample3,this.program.hasTextureSize(3*this._width,3*this._height)).declare("_downsample3",downsample3,this.program.hasTextureSize((2+this._width)/3,(2+this._height)/3)).declare("_downsample2/3",downsample2,this.program.hasTextureSize(3*this._width/2,3*this._height/2)).declare("_downsample3/2",downsample3,this.program.hasTextureSize(2*this._width/3,2*this._height/3)).declare("_scale2",pyramids_scale(2,gpu.pyramidHeight,gpu.pyramidMaxScale),this.program.hasTextureSize(2*this._width,2*this._height)).declare("_scale1/2",pyramids_scale(.5,gpu.pyramidHeight,gpu.pyramidMaxScale),this.program.hasTextureSize((1+this._width)/2,(1+this._height)/2)).declare("_scale3/2",pyramids_scale(1.5,gpu.pyramidHeight,gpu.pyramidMaxScale),this.program.hasTextureSize(3*this._width/2,3*this._height/2)).declare("_scale2/3",pyramids_scale(2/3,gpu.pyramidHeight,gpu.pyramidMaxScale),this.program.hasTextureSize(2*this._width/3,2*this._height/3))}}};class speedy_gpu_SpeedyGPU{constructor(width,height){!function(){if("undefined"==typeof WebGL2RenderingContext)throw GLUtils.Error("WebGL2 is required by this application, but it's not available in your browser. Please use a different browser.")}(),this._width=Math.max(1,0|width),this._height=Math.max(1,0|height),(this._width>65534||this._height>65534)&&(utils_Utils.warning(`Maximum texture size exceeded (using ${this._width} x ${this._height}).`),this._width=Math.min(this._width,65534),this._height=Math.min(this._height,65534)),this._setupWebGL()}get width(){return this._width}get height(){return this._height}pyramid(level){const lv=0|level;return(lv<0||lv>=4)&&utils_Utils.fatal("Invalid pyramid level: "+lv),this._pyramid[lv]}intraPyramid(level){const lv=0|level;return(lv<0||lv>=5)&&utils_Utils.fatal("Invalid intra-pyramid level: "+lv),this._intraPyramid[lv]}get pyramidHeight(){return 4}get pyramidMaxScale(){return 2}get gl(){return this._gl}get canvas(){return this._canvas}upload(data,width=-1,height=-1){const gl=this._gl;if(gl.isContextLost())return utils_Utils.warning("Can't upload texture without a WebGL context"),this._inputTexture=null;if(width<0&&(width=gl.canvas.width),height<0&&(height=gl.canvas.height),0==width||0==height)throw GLUtils.Error("Can't upload an image of area 0");if(null===this._inputTexture)gl.canvas.width=Math.max(gl.canvas.width,width),gl.canvas.height=Math.max(gl.canvas.height,height),this._inputTexture=Array(2).fill(null).map(_=>GLUtils.createTexture(gl,gl.canvas.width,gl.canvas.height));else if(width>gl.canvas.width||height>gl.canvas.height)return utils_Utils.warning(`Resizing input texture to ${width} x ${height}`),this._inputTexture.forEach(inputTexture=>GLUtils.destroyTexture(gl,inputTexture)),this.upload(data,width,height);return this._inputTextureIndex=1-this._inputTextureIndex,GLUtils.uploadToTexture(gl,this._inputTexture[this._inputTextureIndex],width,height,data),this._inputTexture[this._inputTextureIndex]}createProgram(shaderdecl,options={}){const gl=this._gl;return new speedy_program_SpeedyProgram(gl,shaderdecl,{output:[gl.canvas.width,gl.canvas.height],...options})}loseAndRestoreWebGLContext(timeToRestore=1){const gl=this._gl;if(gl.isContextLost())return Promise.reject("Context already lost");const ext=gl.getExtension("WEBGL_lose_context");if(ext)return ext.loseContext(),new Promise(resolve=>{isFinite(timeToRestore)?setTimeout(()=>{ext.restoreContext(),setTimeout(()=>resolve(),0)},1e3*Math.max(timeToRestore,0)):resolve()});throw GLUtils.Error("WEBGL_lose_context is unavailable")}loseWebGLContext(){return this._omitGLContextWarning=!0,this.loseAndRestoreWebGLContext(1/0)}_setupWebGL(){const width=this._width,height=this._height;this._pyramid=null,this._intraPyramid=null,this._inputTexture=null,this._inputTextureIndex=0,this._omitGLContextWarning=!1,void 0!==this._canvas&&delete this._canvas,this._canvas=function(width,height){if("function"==typeof importScripts&&"undefined"!=typeof WorkerGlobalScope){if("function"!=typeof OffscreenCanvas)throw GLUtils.Error("OffscreenCanvas is not available in your browser. Please upgrade.");return new OffscreenCanvas(width,height)}{const canvas=document.createElement("canvas");return canvas.width=width,canvas.height=height,canvas}}(width,height),this._canvas.addEventListener("webglcontextlost",ev=>{this._omitGLContextWarning||utils_Utils.warning("Lost WebGL context"),ev.preventDefault()},!1),this._canvas.addEventListener("webglcontextrestored",ev=>{this._omitGLContextWarning||utils_Utils.warning("Restoring WebGL context..."),this._setupWebGL()},!1),this._gl=function(canvas){const gl=canvas.getContext("webgl2",{premultipliedAlpha:!1,preserveDrawingBuffer:!1,alpha:!0,antialias:!1,depth:!1,stencil:!1});if(!gl)throw GLUtils.Error("Can't create WebGL2 context. Try in a different browser.");return gl}(this._canvas),spawnProgramGroups.call(this,this,width,height),this._pyramid=this._buildPyramid(width,height,1,4),this._intraPyramid=this._buildPyramid(width,height,1.5,5)}_buildPyramid(imageWidth,imageHeight,baseScale,numLevels){let scale=+baseScale,width=imageWidth*scale|0,height=imageHeight*scale|0,pyramid=new Array(numLevels);for(let i=0;i<pyramid.length;i++)pyramid[i]={width:width,height:height,scale:scale},spawnProgramGroups.call(pyramid[i],this,width,height),width=(1+width)/2|0,height=(1+height)/2|0,scale/=2;return pyramid}}function spawnProgramGroups(gpu,width,height){void 0===spawnProgramGroups._cnt&&(spawnProgramGroups._cnt=0),gpu==this&&++spawnProgramGroups._cnt;const cnt=spawnProgramGroups._cnt;for(let g in PROGRAM_GROUPS)Object.defineProperty(this,g,{get:(()=>{const grp="_"+g+cnt,prevGrp="_"+g+(cnt-1);return this.hasOwnProperty(prevGrp)&&delete this[prevGrp],function(){return this[grp]||(this[grp]=new PROGRAM_GROUPS[g](gpu,width,height))}.bind(this)})(),configurable:!0})}const MediaType=utils_Utils.enum("Image","Video","Canvas","Texture"),ColorFormat=utils_Utils.enum("RGB","Greyscale","Binary");class fast_FAST{static run(gpu,greyscale,n,settings){utils_Utils.assert(9==n||7==n||5==n,"Not implemented: FAST-"+n),settings.hasOwnProperty("threshold")||(settings.threshold=10);const rawCorners=(this.run._vtable||(this.run._vtable={5:gpu=>gpu.keypoints.fast5,7:gpu=>gpu.keypoints.fast7,9:gpu=>gpu.keypoints.fast9}))[n](gpu)(greyscale,settings.threshold);return gpu.keypoints.fastSuppression(rawCorners)}static sensitivity2threshold(sensitivity){return sensitivity=Math.max(0,Math.min(sensitivity,1)),1-Math.tanh(2.77*sensitivity)}static normalizedThreshold(threshold){return(threshold=Math.max(0,Math.min(threshold,255)))/255}}class fast_FASTPlus extends fast_FAST{static run(gpu,greyscale,n,settings){utils_Utils.assert(9==n,`Not implemented: FAST-${n}-plus`),settings.hasOwnProperty("threshold")||(settings.threshold=10),settings.hasOwnProperty("depth")||(settings.depth=3);const MAX_DEPTH=gpu.pyramidHeight,maxLod=Math.max(1,Math.min(0|settings.depth,MAX_DEPTH))-1,log2PyrMaxScale=Math.log2(gpu.pyramidMaxScale),pyrMaxLevels=gpu.pyramidHeight,pyramid=greyscale;GLUtils.generateMipmap(gpu.gl,pyramid);const fastPyr=gpu.keypoints.fast9pyr;let multiScaleCorners=fastPyr(pyramid,settings.threshold,0,Math.min(1,maxLod),log2PyrMaxScale,pyrMaxLevels,!0);if(maxLod>1){multiScaleCorners=fastPyr(gpu.utils.identity(multiScaleCorners),settings.threshold,2,maxLod,log2PyrMaxScale,pyrMaxLevels,!1)}const orientedMultiScaleCorners=multiScaleCorners,suppressed1=gpu.keypoints.samescaleSuppression(orientedMultiScaleCorners,log2PyrMaxScale,pyrMaxLevels);return gpu.keypoints.multiscaleSuppression(suppressed1,1,log2PyrMaxScale,pyrMaxLevels)}}let shortPairs=null,longPairs=null;function briskPoints(layer){const{n:n,r:r,l:l}=layer,twoPi=2*Math.PI;return[...Array(n).keys()].map(j=>({x:l*Math.cos(twoPi*j/n),y:l*Math.sin(twoPi*j/n),r:r,l:l,j:j,n:n}))}function briskPairs(threshold,scale=1){const p=function(scale=1){const piOverTwo=Math.PI/2,s10=Math.sin(piOverTwo/10),s14=Math.sin(piOverTwo/14),s15=Math.sin(piOverTwo/15),s20=Math.sin(piOverTwo/20),l10=4.21*scale,r10=2*l10*s10,r14=2*(l10+r10)*s14/(1-2*s14),l14=l10+r10+r14,r15=2*(l14+r14)*s15/(1-2*s15),l15=l14+r14+r15,r20=2*(l15+r15)*s20/(1-2*s20);return[{n:1,r:.8*r10,l:0},{n:10,r:r10,l:l10},{n:14,r:r14,l:l14},{n:15,r:r15,l:l15},{n:20,r:r20,l:l15+r15+r20}]}(scale).map(briskPoints).reduce((v,e)=>v.concat(e),[]);const n=p.length,t=+threshold*scale,dist2=(p,q)=>(p.x-q.x)*(p.x-q.x)+(p.y-q.y)*(p.y-q.y),wanted=t<0?(p,q)=>dist2(p,q)<t*t:(p,q)=>dist2(p,q)>t*t,pairs=[];for(let i=1;i<n;i++)for(let j=0;j<i;j++)wanted(p[i],p[j])&&(pairs.push(p[i].x),pairs.push(p[i].y),pairs.push(p[j].x),pairs.push(p[j].y));return new Float32Array(pairs)}class feature_detector_FeatureDetector{constructor(gpu,optimizeForDynamicUsage){this._gpu=gpu,this._lastKeypointCount=0,this._sensitivityTuner=null,this._optimizeForDynamicUsage=optimizeForDynamicUsage}fast(media,n=9,settings={}){const gpu=this._gpu;(settings={threshold:10,denoise:!0,...settings}).hasOwnProperty("expected")&&(settings.sensitivity=this._findSensitivity(settings.expected)),settings.hasOwnProperty("sensitivity")?settings.threshold=fast_FAST.sensitivity2threshold(settings.sensitivity):settings.threshold=fast_FAST.normalizedThreshold(settings.threshold);const source=media._gpu.upload(media.source),texture=settings.denoise?gpu.filters.gauss5(source):source,greyscale=gpu.colors.rgb2grey(texture),keypoints=fast_FAST.run(gpu,greyscale,n,settings);return this._extractKeypoints(keypoints,this._optimizeForDynamicUsage)}fastPlus(media,n=9,settings={}){const gpu=this._gpu;(settings={depth:3,threshold:10,denoise:!0,...settings}).hasOwnProperty("expected")&&(settings.sensitivity=this._findSensitivity(settings.expected)),settings.hasOwnProperty("sensitivity")?settings.threshold=fast_FASTPlus.sensitivity2threshold(settings.sensitivity):settings.threshold=fast_FASTPlus.normalizedThreshold(settings.threshold);const source=media._gpu.upload(media.source),texture=settings.denoise?gpu.filters.gauss5(source):source,greyscale=gpu.colors.rgb2grey(texture),keypoints=fast_FASTPlus.run(gpu,greyscale,n,settings);return this._extractKeypoints(keypoints,this._optimizeForDynamicUsage)}brisk(media,settings={}){const gpu=this._gpu;(settings={threshold:10,denoise:!0,depth:4,...settings}).hasOwnProperty("expected")&&(settings.sensitivity=this._findSensitivity(settings.expected)),settings.hasOwnProperty("sensitivity")?settings.threshold=fast_FAST.sensitivity2threshold(settings.sensitivity):settings.threshold=fast_FAST.normalizedThreshold(settings.threshold);const source=media._gpu.upload(media.source),texture=settings.denoise?gpu.filters.gauss5(source):source,greyscale=gpu.colors.rgb2grey(texture),keypoints=class{static run(gpu,greyscale,settings){const MAX_DEPTH=gpu.pyramidHeight;settings.depth=0|Math.max(1,Math.min(settings.depth,MAX_DEPTH));const pyramid=new Array(settings.depth),intraPyramid=new Array(pyramid.length+1);pyramid[0]=gpu.pyramid(0).pyramids.setBase(greyscale);for(let i=1;i<pyramid.length;i++)pyramid[i]=gpu.pyramid(i-1).pyramids.reduce(pyramid[i-1]);intraPyramid[0]=gpu.pyramid(0).pyramids.intraExpand(pyramid[0]);for(let i=1;i<intraPyramid.length;i++)intraPyramid[i]=gpu.intraPyramid(i-1).pyramids.reduce(intraPyramid[i-1]);const pyramidCorners=new Array(pyramid.length),intraPyramidCorners=new Array(intraPyramid.length);for(let j=0;j<pyramidCorners.length;j++)pyramidCorners[j]=gpu.pyramid(j).keypoints.fast9(pyramid[j],settings.threshold),pyramidCorners[j]=gpu.pyramid(j).keypoints.fastSuppression(pyramidCorners[j]);for(let j=0;j<intraPyramidCorners.length;j++)intraPyramidCorners[j]=gpu.intraPyramid(j).keypoints.fast9(intraPyramid[j],settings.threshold),intraPyramidCorners[j]=gpu.intraPyramid(j).keypoints.fastSuppression(intraPyramidCorners[j]);const lgM=Math.log2(gpu.pyramidMaxScale),h=gpu.pyramidHeight,suppressedPyramidCorners=new Array(pyramidCorners.length),suppressedIntraPyramidCorners=new Array(intraPyramidCorners.length);suppressedIntraPyramidCorners[0]=gpu.intraPyramid(0).keypoints.brisk(intraPyramidCorners[0],intraPyramidCorners[0],pyramidCorners[0],1,2/3,lgM,h);for(let j=0;j<suppressedPyramidCorners.length;j++)suppressedPyramidCorners[j]=gpu.pyramid(j).keypoints.brisk(pyramidCorners[j],intraPyramidCorners[j],intraPyramidCorners[j+1],1.5,.75,lgM,h),j+1<suppressedPyramidCorners.length?suppressedIntraPyramidCorners[j+1]=gpu.intraPyramid(j+1).keypoints.brisk(intraPyramidCorners[j+1],pyramidCorners[j],pyramidCorners[j+1],4/3,2/3,lgM,h):suppressedIntraPyramidCorners[j+1]=gpu.intraPyramid(j+1).keypoints.brisk(intraPyramidCorners[j+1],pyramidCorners[j],intraPyramidCorners[j+1],4/3,1,lgM,h);for(let j=suppressedPyramidCorners.length-2;j>=0;j--)suppressedPyramidCorners[j]=gpu.pyramid(j).pyramids.mergeKeypointsAtConsecutiveLevels(suppressedPyramidCorners[j],suppressedPyramidCorners[j+1]);for(let j=suppressedIntraPyramidCorners.length-2;j>=0;j--)suppressedIntraPyramidCorners[j]=gpu.intraPyramid(j).pyramids.mergeKeypointsAtConsecutiveLevels(suppressedIntraPyramidCorners[j],suppressedIntraPyramidCorners[j+1]);return suppressedIntraPyramidCorners[0]=gpu.intraPyramid(0).pyramids.normalizeKeypoints(suppressedIntraPyramidCorners[0],1.5),suppressedIntraPyramidCorners[0]=gpu.pyramid(0).pyramids.crop(suppressedIntraPyramidCorners[0]),gpu.pyramid(0).pyramids.mergeKeypoints(suppressedPyramidCorners[0],suppressedIntraPyramidCorners[0])}static get shortDistancePairs(){return shortPairs||(shortPairs=function(threshold=9.75,scale=1){return briskPairs(-threshold,scale)}())}static get longDistancePairs(){return longPairs||(longPairs=function(threshold=13.67,scale=1){return briskPairs(threshold,scale)}())}}.run(gpu,greyscale,settings);return this._extractKeypoints(keypoints,this._optimizeForDynamicUsage)}_extractKeypoints(corners,useAsyncTransfer=!0,gpu=this._gpu){return new Promise((resolve,reject)=>{gpu.encoders.encodeKeypoints(corners,useAsyncTransfer).then(encodedKeypoints=>{const keypoints=gpu.encoders.decodeKeypoints(encodedKeypoints),slack=this._lastKeypointCount>0?Math.max(1,Math.min(keypoints.length/this._lastKeypointCount),2):1;gpu.encoders.optimizeKeypointEncoder(keypoints.length*slack),this._lastKeypointCount=keypoints.length,resolve(keypoints)}).catch(err=>{reject(err)})})}_findSensitivity(param){const expected={number:0,tolerance:.1,..."object"==typeof param?param:{number:0|param}};this._optimizeForDynamicUsage||this._findSensitivity._warning||(utils_Utils.warning("Finding an expected number of features in a media configured for static usage"),this._findSensitivity._warning=!0),this._sensitivityTuner=this._sensitivityTuner||new tuner_OnlineErrorTuner(0,1200);this._sensitivityTuner.tolerance=Math.max(expected.tolerance,0),this._sensitivityTuner.feedObservation(this._lastKeypointCount,Math.max(expected.number,0));const sensitivity=.001*this._sensitivityTuner.currentValue();return Math.max(0,Math.min(sensitivity,1))}}class speedy_media_SpeedyMedia{constructor(mediaSource,width,height,options={}){if(arguments.length>1)this._source=mediaSource,this._width=0|width,this._height=0|height,this._type=function(mediaSource){if(mediaSource&&mediaSource.constructor)switch(mediaSource.constructor.name){case"HTMLImageElement":return MediaType.Image;case"HTMLVideoElement":return MediaType.Video;case"HTMLCanvasElement":return MediaType.Canvas;default:return MediaType.Texture}return utils_Utils.fatal("Can't get media type: invalid media source. "+mediaSource),null}(this._source),this._colorFormat=ColorFormat.RGB,this._options=buildOptions(options,{usage:this._type!=MediaType.Image?"dynamic":"static"}),this._gpu=new speedy_gpu_SpeedyGPU(this._width,this._height),this._featureDetector=null;else if(1==arguments.length){const media=arguments[0];this._source=media._source,this._width=media._width,this._height=media._height,this._type=media._type,this._colorFormat=media._colorFormat,this._gpu=media._gpu,this._featureDetector=media._featureDetector}else utils_Utils.fatal("Invalid instantiation of SpeedyMedia")}static load(mediaSource,options={}){return new Promise((resolve,reject)=>{const dimensions=getMediaDimensions(mediaSource);null!=dimensions?function loadMedia(dimensions,k=500){if(dimensions.width>0&&dimensions.height>0){const media=new speedy_media_SpeedyMedia(mediaSource,dimensions.width,dimensions.height,options);utils_Utils.log(`Loaded SpeedyMedia with a ${mediaSource}.`),resolve(media)}else k>0?setTimeout(()=>loadMedia(getMediaDimensions(mediaSource),k-1),10):reject(new SpeedyError(`Can't load SpeedyMedia with a ${mediaSource}: timeout.`))}(dimensions):reject(new SpeedyError(`Can't load SpeedyMedia with a ${mediaSource}: invalid media source.`))})}static loadCameraStream(width=426,height=240,cameraOptions={},mediaOptions={}){return function(width,height,options={}){return new Promise((resolve,reject)=>{if(utils_Utils.log("Accessing the webcam..."),!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia)return reject(new SpeedyError("Unsupported browser: no mediaDevices.getUserMedia()"));navigator.mediaDevices.getUserMedia({audio:!1,video:{width:{ideal:width},height:{ideal:height},aspectRatio:{ideal:width/height},facingMode:"environment"},...options}).then(stream=>{const video=document.createElement("video");video.srcObject=stream,video.onloadedmetadata=e=>{video.play(),utils_Utils.log("The camera device is turned on!"),resolve(video,stream)}}).catch(err=>{reject(new SpeedyError(`Please give access to the camera and reload the page.\n${err.name}. ${err.message}.`))})})}(width,height,cameraOptions).then(video=>speedy_media_SpeedyMedia.load(function(video){const canvas=document.createElement("canvas"),ctx=canvas.getContext("2d");function render(){ctx.drawImage(video,0,0),requestAnimationFrame(render)}return canvas.width=video.videoWidth,canvas.height=video.videoHeight,render(),canvas}(video),mediaOptions))}get source(){return this._source}get width(){return this._width}get height(){return this._height}get type(){switch(this._type){case MediaType.Image:return"image";case MediaType.Video:return"video";case MediaType.Canvas:return"canvas";case MediaType.Texture:return"internal";default:return"unknown"}}get options(){return this._options}release(){return this.isReleased()||(this._featureDetector=null,this._gpu.loseWebGLContext(),this._gpu=null,this._source=null),Promise.resolve()}isReleased(){return null==this._gpu}clone(options={}){if(options={lightweight:!1,...options},this.isReleased()&&utils_Utils.fatal("Can't clone a SpeedyMedia that has been released"),options.lightweight)return new speedy_media_SpeedyMedia(this);{let source=this._source;return this._type!=MediaType.Texture&&this._type!=MediaType.Canvas||(source=function(media){const canvas=document.createElement("canvas");return canvas.width=media.width,canvas.height=media.height,media.draw(canvas),canvas}(this)),new speedy_media_SpeedyMedia(source,this._width,this._height)}}run(pipeline){this.isReleased()&&utils_Utils.fatal("Can't run pipeline: SpeedyMedia has been released");const media=this.clone({lightweight:!0});return media._type=MediaType.Texture,pipeline._run(media)}draw(canvas,x=0,y=0,width=this.width,height=this.height){if(this.isReleased())return;const ctx=canvas.getContext("2d");switch(x=+x,y=+y,width=Math.max(width,0),height=Math.max(height,0),this._type){case MediaType.Image:case MediaType.Video:case MediaType.Canvas:ctx.drawImage(this._source,x,y,width,height);break;case MediaType.Texture:ctx.drawImage(this._gpu.canvas,x,y,width,height)}}findFeatures(settings={}){settings=Object.assign({method:"fast"},settings),this.isReleased()&&utils_Utils.fatal("Can't find features: SpeedyMedia has been released"),this._featureDetector=this._featureDetector||new feature_detector_FeatureDetector(this._gpu,"dynamic"==this.options.usage);const fn=this._featureDetector._table||(this._featureDetector._table={fast:(media,settings)=>this._featureDetector.fast(media,9,settings),fast9:(media,settings)=>this._featureDetector.fast(media,9,settings),fast7:(media,settings)=>this._featureDetector.fast(media,7,settings),fast5:(media,settings)=>this._featureDetector.fast(media,5,settings),fast9plus:(media,settings)=>this._featureDetector.fastPlus(media,9,settings),brisk:(media,settings)=>this._featureDetector.brisk(media,settings)}),method=String(settings.method).toLowerCase();return fn.hasOwnProperty(method)||utils_Utils.fatal(`Invalid method "${method}" for keypoint detection.`),fn[method](this,settings)}}function getMediaDimensions(mediaSource){if(mediaSource&&mediaSource.constructor&&mediaSource.constructor.name){const element=mediaSource.constructor.name,key={HTMLImageElement:{width:"naturalWidth",height:"naturalHeight"},HTMLVideoElement:{width:"videoWidth",height:"videoHeight"},HTMLCanvasElement:{width:"width",height:"height"}};if(key.hasOwnProperty(element))return{width:mediaSource[key[element].width],height:mediaSource[key[element].height]}}return null}function buildOptions(options,defaultOptions){const warn=buildOptions._err||(buildOptions._err=(...args)=>utils_Utils.warning("Invalid option when loading media.",...args));return"dynamic"!=(options=Object.assign(defaultOptions,options)).usage&&"static"!=options.usage&&(warn(`Unrecognized usage: "${options.usage}"`),options.usage=defaultOptions.usage),Object.freeze(options)}const PipelineOperation={};class SpeedyPipelineOperation{run(texture,gpu,media){return texture}release(){}}PipelineOperation.ConvertToGreyscale=class extends SpeedyPipelineOperation{run(texture,gpu,media){return media._colorFormat==ColorFormat.RGB?texture=gpu.colors.rgb2grey(texture):media._colorFormat!=ColorFormat.Greyscale&&utils_Utils.fatal("Can't convert image to greyscale: unknown color format"),media._colorFormat=ColorFormat.Greyscale,texture}},PipelineOperation.Blur=class extends SpeedyPipelineOperation{constructor(options={}){const{filter:filter,size:size}=options={filter:"gaussian",size:5,...options};super(),3!=size&&5!=size&&7!=size&&utils_Utils.fatal("Invalid kernel size: "+size),"gaussian"==filter?this._filter="gauss"+size:"box"==filter?this._filter="box"+size:utils_Utils.fatal(`Invalid filter: "${filter}"`)}run(texture,gpu,media){return gpu.filters[this._filter](texture)}},PipelineOperation.Convolve=class extends SpeedyPipelineOperation{constructor(kernel,divisor=1){let kern=new Float32Array(kernel).map(x=>x/divisor);const len=kern.length,size=0|Math.sqrt(len),method={3:["createKernel3x3","texConv2D3"],5:["createKernel5x5","texConv2D5"],7:["createKernel7x7","texConv2D7"]}[size]||null;super(),1==len?utils_Utils.fatal("Cannot convolve with a kernel containing a single element"):size*size==len&&method||utils_Utils.fatal(`Cannot convolve with a non-square kernel of ${len} elements`);const min=Math.min(...kern),max=Math.max(...kern),offset=min,scale=Math.abs(max-min)>1e-5?max-min:1;kern=kern.map(x=>(x-offset)/scale),this._method=method,this._scale=scale,this._offset=offset,this._kernel=kern,this._kernelSize=size,this._texKernel=null,this._gl=null}run(texture,gpu,media){if(gpu.gl.isContextLost())this._texKernel=null,this._gl=null;else if(null==this._texKernel||this._gl!==gpu.gl&&null!==this._gl){if(this._gl!==gpu.gl&&null!==this._gl&&!this._gl.isContextLost()){const warn="Performance warning: need to recreate the texture kernel. Consider duplicating the pipeline when using convolutions for different media objects.";utils_Utils.warning(warn),GLUtils.destroyTexture(this._gl,this._texKernel)}this._texKernel=gpu.filters[this._method[0]](this._kernel),this._gl=gpu.gl}return gpu.filters[this._method[1]](texture,this._texKernel,this._scale,this._offset)}release(){null!=this._texKernel&&(GLUtils.destroyTexture(this._gl,this._texKernel),this._texKernel=this._gl=null),super.release()}};class speedy_pipeline_SpeedyPipeline{constructor(){this._operations=[]}get length(){return this._operations.length}release(){return new Promise((resolve,reject)=>{for(let i=this._operations.length-1;i>=0;i--)this._operations[i].release();this._operations.length=0,resolve(this)})}_spawn(operation){return this._operations.push(operation),this}_run(media){return new Promise((resolve,reject)=>{if(media._type==MediaType.Texture){let texture=media._gpu.upload(media._source);for(let i=0;i<this._operations.length;i++)texture=this._operations[i].run(texture,media._gpu,media);media._gpu.utils.output(texture),media._source=media._gpu.canvas,resolve(media)}else reject(new SpeedyError("Can't run a pipeline on a media that is not a texture"))})}concat(pipeline){return pipeline instanceof speedy_pipeline_SpeedyPipeline?(this._operations=this._operations.concat(pipeline._operations),this):(utils_Utils.fatal(`Invalid argument "${pipeline}" given to SpeedyPipeline.concatenate()`),this)}convertTo(colorSpace=null){return"greyscale"==colorSpace||"grayscale"==colorSpace?this._spawn(new PipelineOperation.ConvertToGreyscale):(utils_Utils.fatal(`Can't convert to unknown color space: "${colorSpace}"`),this)}blur(options={}){return this._spawn(new PipelineOperation.Blur(options))}convolve(kernel,divisor=1){return this._spawn(new PipelineOperation.Convolve(kernel,divisor))}}let instance=null;class fps_counter_FPSCounter{constructor(){this._fps=60,this._frames=0,this._updateInterval=500,this._lastUpdate=performance.now(),null!==instance&&utils_Utils.fatal("Can't have multiple instances of FPSCounter"),requestAnimationFrame(this._update.bind(this))}static get instance(){return null===instance&&(instance=new fps_counter_FPSCounter),instance}get fps(){return this._fps}_update(){const now=performance.now(),deltaTime=now-this._lastUpdate;deltaTime>=this._updateInterval&&(this._fps=Math.round(this._frames/(.001*deltaTime)),this._frames=0,this._lastUpdate=now),this._frames++,requestAnimationFrame(this._update.bind(this))}}class speedy_Speedy{static load(sourceElement,options={}){return speedy_media_SpeedyMedia.load(sourceElement,options)}static camera(width=426,height=240,cameraOptions={},mediaOptions={}){return speedy_media_SpeedyMedia.loadCameraStream(width,height,cameraOptions,mediaOptions)}static pipeline(){return new speedy_pipeline_SpeedyPipeline}static get version(){return"0.3.2"}static get fps(){return{get value(){return fps_counter_FPSCounter.instance.fps}}}}const load=speedy_Speedy.load,camera=speedy_Speedy.camera,speedy_pipeline=speedy_Speedy.pipeline,version=speedy_Speedy.version,fps=speedy_Speedy.fps}]);