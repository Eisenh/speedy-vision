/*!
 * speedy-vision.js v0.7.0-wip
 * GPU-accelerated Computer Vision for JavaScript
 * https://github.com/alemart/speedy-vision-js
 * 
 * Copyright 2020-2021 Alexandre Martins <alemartf(at)gmail.com> (https://github.com/alemart)
 * @license Apache-2.0
 * 
 * Date: 2021-07-14T23:44:39.277Z
 */
var Speedy=function(e){var t={};function n(i){if(t[i])return t[i].exports;var s=t[i]={i:i,l:!1,exports:{}};return e[i].call(s.exports,s,s.exports,n),s.l=!0,s.exports}return n.m=e,n.c=t,n.d=function(e,t,i){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:i})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var i=Object.create(null);if(n.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var s in e)n.d(i,s,function(t){return e[t]}.bind(null,s));return i},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=20)}([function(e,t,n){"use strict";n.d(t,"i",(function(){return s})),n.d(t,"h",(function(){return r})),n.d(t,"e",(function(){return o})),n.d(t,"a",(function(){return a})),n.d(t,"f",(function(){return c})),n.d(t,"g",(function(){return l})),n.d(t,"j",(function(){return d})),n.d(t,"d",(function(){return h})),n.d(t,"l",(function(){return u})),n.d(t,"k",(function(){return p})),n.d(t,"c",(function(){return f})),n.d(t,"b",(function(){return m}));class i extends Error{constructor(e,t=null){super([e,t?t.toString():"[speedy-vision.js]"].join("\n-> ")),this._cause=t}get name(){return this.constructor.name}set name(e){}get cause(){return this._cause}}class s extends i{constructor(e="",t=null){super("Unsupported operation. "+e,t)}}class r extends i{constructor(e="",t=null){super("Method not implemented. "+e,t)}}class o extends i{constructor(e="",t=null){super("WebGL error. "+e,t)}}class a extends i{constructor(e="",t=null){super("Can't call abstract method. "+e,t)}}class c extends i{constructor(e="",t=null){super("Illegal argument. "+e,t)}}class l extends i{constructor(e="",t=null){super("Illegal operation. "+e,t)}}class d extends i{constructor(e="",t=null){super("Out of memory. "+e,t)}}class h extends i{constructor(e="",t=null){super("File not found. "+e,t)}}class u extends i{constructor(e="",t=null){super("Timeout error. "+e,t)}}class p extends i{constructor(e="",t=null){super("Parse error. "+e,t)}}class f extends i{constructor(e="",t=null){super("Assertion failed. "+e,t)}}class m extends i{constructor(e="",t=null){super("Access denied. "+e,t)}}},function(e,t,n){"use strict";n.d(t,"a",(function(){return r}));var i=n(0),s=n(3);class r{static warning(e,...t){const n=[e,...t].join(" ");return console.warn("[speedy-vision.js]",n),n}static log(e,...t){return[e,...t].join(" ")}static assert(e,t=""){if(!e)throw new i.c(t)}static enum(...e){return Object.freeze(e.reduce((e,t)=>(e[t]=Symbol(t),e),{}))}static setZeroTimeout(e){const t=r._setZeroTimeoutContext=r._setZeroTimeoutContext||(r._setZeroTimeoutContext={callbacks:new Map,_setup:window.addEventListener("message",e=>{if(e.source===window){const t=r._setZeroTimeoutContext,n=e.data,i=t.callbacks.get(n);void 0!==i&&(e.stopPropagation(),i.call(window),t.callbacks.delete(n))}},!0)}),n="0%"+Math.random();t.callbacks.set(n,e),window.postMessage(n,"*")}static functionArguments(e){const t=e.toString(),n=t.startsWith("function")?"function\\s.*\\(([^)]*)\\)":t.startsWith("(")?"\\(([^)]*)\\).*=>":"([^=]+).*=>",s=new RegExp(n).exec(t);if(null!==s){return s[1].replace(/\/\*.*?\*\//g,"").split(",").map(e=>e.replace(/=.*$/,"").trim()).filter(e=>e)}throw new i.k("Can't detect function arguments of "+t)}static getAllPropertyDescriptors(e){if(e){const t=Object.getPrototypeOf(e);return{...r.getAllPropertyDescriptors(t),...Object.getOwnPropertyDescriptors(e)}}return Object.create(null)}static createCanvas(e,t){const n=document.createElement("canvas");return n.width=e,n.height=t,n}static gaussianNoise(e=0,t=1){const n=2*Math.PI;let i,s=Math.random();do{i=Math.random()}while(i<=Number.EPSILON);return Math.sqrt(-2*Math.log(i))*Math.sin(n*s)*t+e}static gaussianKernel(e,t=0,n=!0){if(0==t&&(t=0|Math.ceil(5*e),t+=1-t%2),(t|=0)<1||t%2==0)throw new i.f(`Invalid kernel size given to gaussianKernel: ${t} x 1`);if(e<=0)throw new i.f("Invalid sigma given to gaussianKernel: "+e);const s=new Array(t),r=t>>1,o=1.4142135623730951*+e,a=.3275911,c=.254829592,l=-.284496736,d=1.421413741,h=-1.453152027,u=1.061405429;let p=0;for(let e=0;e<t;e++){let t=(e-r+.5)/o,n=(e-r-.5)/o,i=1,f=1;t<0&&(i=-1,t=-t),n<0&&(f=-1,n=-n);const m=1/(1+a*t),_=1/(1+a*n),g=((((u*_+h)*_+d)*_+l)*_+c)*_,x=(i*(1-((((u*m+h)*m+d)*m+l)*m+c)*m*Math.exp(-t*t))-f*(1-g*Math.exp(-n*n)))/(2*o);s[e]=x,p+=x}return n?s.map(e=>e/p):s}static kernel2d(e,t=e){const n=e.length;r.assert(e.length==e.length),r.assert(n>=1&&n%2==1);let i=new Array(n*n),s=0;for(let r=0;r<n;r++)for(let o=0;o<n;o++)i[s++]=e[o]*t[r];return i}static cartesian(e,t){return[].concat(...e.map(e=>t.map(t=>[e,t])))}static symmetricRange(e){if((e|=0)<0)throw new i.f("Expected a non-negative integer as input");return[...Array(2*e+1).keys()].map(t=>t-e)}static range(e){if((e|=0)<=0)throw new i.f("Expected a positive integer as input");return[...Array(e).keys()]}static requestCameraStream(e,t,n={}){if(r.log("Accessing the webcam..."),!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia)throw new i.i("Unsupported browser: no mediaDevices.getUserMedia()");return new s.a((s,o)=>{navigator.mediaDevices.getUserMedia({audio:!1,video:{width:{ideal:e},height:{ideal:t},aspectRatio:e/t,facingMode:"environment",frameRate:30},...n}).then(e=>{const t=document.createElement("video");t.onloadedmetadata=()=>{t.play(),r.log("The camera device is turned on!"),s(t)},t.srcObject=e}).catch(e=>{o(new i.b("Please give access to the camera and reload the page",e))})})}}},function(e,t,n){"use strict";n.d(t,"n",(function(){return i})),n.d(t,"h",(function(){return s})),n.d(t,"a",(function(){return r})),n.d(t,"b",(function(){return o})),n.d(t,"k",(function(){return a})),n.d(t,"i",(function(){return c})),n.d(t,"m",(function(){return l})),n.d(t,"l",(function(){return d})),n.d(t,"j",(function(){return h})),n.d(t,"c",(function(){return u})),n.d(t,"e",(function(){return p})),n.d(t,"f",(function(){return f})),n.d(t,"d",(function(){return m})),n.d(t,"g",(function(){return _}));const i=8,s=Math.log2(1),r=4,o=1*(1<<r),a=(1<<16-r)-2,c=64,l=8,d=Math.ceil(Math.sqrt(l/4)),h=8192,u=32,p=0,f=1,m=128,_=51966===new Uint16Array(new Uint8Array([254,202]).buffer)[0]},function(e,t,n){"use strict";(function(e){n.d(t,"a",(function(){return s}));const i="undefined"!=typeof queueMicrotask&&queueMicrotask||void 0!==e&&e.nextTick||(e=>Promise.resolve().then(e));class s{constructor(e){this._state=0,this._value=void 0,this._onFulfillment=null,this._onRejection=null,this._children=0,this[0]=this,this._parent=void 0,this._flags=0,this._fulfill=this._fulfill.bind(this),this._reject=this._reject.bind(this),this._resolve=this._resolve.bind(this),this._broadcastIfAsync=this._broadcastIfAsync.bind(this),e(this._fulfill,this._reject)}then(e,t=null){const n=new s(this._nop);return n._onFulfillment="function"==typeof e&&e,n._onRejection="function"==typeof t&&t,n._parent=this,this[this._children++]=n,this._flags&=-2,this._notify(),n}catch(e){return this.then(null,e)}finally(e){const t=t=>(e(),t);return this.then(t,t)}turbocharge(){let e=this;for(this._flags|=1;void 0!==e._parent;)e=e._parent,e._flags|=1;return e._notify(),this}toString(){switch(this._state){case 0:return"SpeedyPromise { <pending> }";case 1:return`SpeedyPromise { <fulfilled> ${this._value} }`;case 2:return`SpeedyPromise { <rejected> ${this._value} }`;default:return""}}static resolve(e){const t=new s(this._snop);return"object"==typeof e&&null!==e&&"then"in e||"function"==typeof e&&"then"in e?t._resolve(e):(t._value=e,t._state=1),t}static reject(e){const t=new s(this._snop);return t._value=e,t._state=2,t}static all(e){return new s((t,n)=>{const i=[];for(const t of e)i.push(t);const r=i.length;if(0==r)return void t([]);let o=r;const a=new Array(r),c=e=>n=>{a[e]=n,0==--o&&t(a)};for(let e=0;e<r;e++){const t=i[e];t.__proto__===s.prototype||t.__proto__===Promise.prototype?t.then(c(e),n):s.resolve(t).then(c(e),n)}})}static race(e){return new s((t,n)=>{const i=[];for(const t of e)i.push(t);const r=i.length;for(let e=0;e<r;e++){const r=i[e];r.__proto__===s.prototype||r.__proto__===Promise.prototype?r.then(t,n):s.resolve(r).then(t,n)}})}_fulfill(e){this._setState(1,e)}_reject(e){this._setState(2,e)}_setState(e,t){0==this._state&&(this._state=e,this._value=t,this._notify())}_notify(){0!=this._state&&(1&this._flags?this._broadcast():i(this._broadcastIfAsync))}_broadcastIfAsync(){1&this._flags||this._broadcast()}_broadcast(){const e=this._children,t=this._state;if(1===t)for(let t=0;t<e;t++){const e=this[t],n=e._onFulfillment;try{n?n!==e._nop&&(e._resolve(n(this._value)),e._onFulfillment=e._nop):e._fulfill(this._value)}catch(t){e._reject(t)}}else if(2===t)for(let t=0;t<e;t++){const e=this[t],n=e._onRejection;try{n?n!==e._nop&&(e._resolve(n(this._value)),e._onRejection=e._nop):e._reject(this._value)}catch(t){e._reject(t)}}}_resolve(e){if("object"!=typeof e&&"function"!=typeof e||null===e)this._fulfill(e);else{if(e===this)throw new TypeError;if(e.__proto__!==s.prototype&&e.__proto__!==Promise.prototype)try{const t=e.then;if("function"==typeof t){let n=this._resolve,i=this._reject;try{t.call(e,e=>{n(e),n=i=this._nop},e=>{i(e),n=i=this._nop})}catch(e){n!==this._nop&&i!==this._nop&&this._reject(e)}}else this._fulfill(e)}catch(e){this._reject(e)}else e.then(this._resolve,this._reject)}}_nop(){}static _snop(){}}}).call(this,n(21))},function(e,t,n){"use strict";n.d(t,"b",(function(){return v})),n.d(t,"a",(function(){return w}));var i=n(2),s=n(1),r=n(5),o=n(0);const a=[/\/\*(.|\s)*?\*\//g,/\/\/.*$/gm],c=/^\s*@\s*include\s+"(.*?)"/gm,l=/@(\w+)@/g,d=[/@\s*unroll\s+?for\s*\(\s*(int|)\s*(?<counter>\w+)\s*\=\s*(-?\d+|\w+)\s*;\s*\k<counter>\s*(<=?)\s*(-?\d+|\w+)\s*;\s*\k<counter>\s*\+\+()\s*\)\s*\{\s*([\s\S]+?)\s*\}/g,/@\s*unroll\s+?for\s*\(\s*(int|)\s*(?<counter>\w+)\s*\=\s*(-?\d+|\w+)\s*;\s*\k<counter>\s*(<=?)\s*(-?\d+|\w+)\s*;\s*\k<counter>\s*\+=\s*(-?\d+)\s*\)\s*\{\s*([\s\S]+?)\s*\}/g],h=Object.freeze({MAX_TEXTURE_LENGTH:i.k,LITTLE_ENDIAN:i.g?1:0,PYRAMID_MAX_LEVELS:i.n,LOG2_PYRAMID_MAX_SCALE:i.h,PIXELCOMPONENT_RED:r.e.RED,PIXELCOMPONENT_GREEN:r.e.GREEN,PIXELCOMPONENT_BLUE:r.e.BLUE,PIXELCOMPONENT_ALPHA:r.e.ALPHA,FIX_BITS:i.a,FIX_RESOLUTION:i.b,MAX_DESCRIPTOR_SIZE:i.i,MIN_KEYPOINT_SIZE:i.m,KPF_NONE:i.e,KPF_ORIENTED:i.f,KPF_DISCARD:i.d});class u{static run(e,t=new Map){const n=[];return function(e,t){const n=f.bind(t),i=d.length;for(let t=0;t<i;t++)e=e.replace(d[t],n);return e}(String(e).replace(a[0],"").replace(a[1],"").replace(c,(e,n)=>u.run(p(n),t)).replace(l,(e,i)=>String(void 0!==h[i]?Number(h[i]):t.has(i)?Number(t.get(i)):(n.push("Undefined constant: "+i),0))),t)+(n.length>0?n.map(e=>`\n#error ${e}\n`).join(""):"")}}function p(e){if(String(e).match(/^[a-zA-Z0-9_\-]+\.glsl$/))return n(22)("./"+e);throw new o.d(`Shader preprocessor: can't read file "${e}"`)}function f(e,t,n,i,r,a,c,l){const d=this;if(i=Number.isFinite(+i)?i:d.get(i),a=Number.isFinite(+a)?a:d.get(a),void 0===i||void 0===a){if(d.size>0)throw new o.k(`Can't unroll loop: unknown limits (start=${i}, end=${a}). Code:\n\n${e}`);return e}i=parseInt(i),a=parseInt(a),c=0==c.length?1:parseInt(c),s.a.assert(i<=a&&c>0);let h=null!==l.match(/\bbreak\s*;/)?"switch(1) { default:\n":"{\n";h+=`${t} ${n};\n`,a+="<="==r?1:0;for(let e=i;e<a;e+=c)h+=`{\n${n} = ${e};\n${l}\n}\n`;return h+="}\n",h}const m=Object.freeze({position:"a_position",texCoord:"a_texCoord"}),_=Object.freeze({position:0,texCoord:1}),g=`#version 300 es\nlayout (location=${_.position}) in vec2 ${m.position};\nlayout (location=${_.texCoord}) in vec2 ${m.texCoord};\nout vec2 texCoord;\n\nvoid main() {\n    gl_Position = vec4(${m.position}, 0.0f, 1.0f);\n    texCoord = ${m.texCoord};\n}\n`,x='#version 300 es\nprecision highp int; // int32\nprecision mediump float; // ~float16\nprecision mediump sampler2D;\n\nout vec4 color;\nin vec2 texCoord;\nuniform vec2 texSize;\n\n@include "global.glsl"\n\n';class y{constructor(e){const t=e.filepath||null,i=t?n(23)("./"+t):e.source||"";if(0==i.length)throw new o.f("Can't import shader: empty code");this._userSource=i,this._vertexSource=u.run(g),this._fragmentSource=u.run(x+this._userSource),this._filepath=t||"<in-memory>",this._arguments=[],this._uniforms=this._autodetectUniforms(this._fragmentSource),this._defines=new Map}static create(e){return new y({source:e})}static import(e){if(!String(e).match(/^[a-zA-Z0-9_\-\/]+\.glsl$/))throw new o.d(`Can't import shader: "${e}"`);return new y({filepath:e})}withArguments(...e){if(this._arguments.length>0)throw new o.g("Redefinition of shader arguments");this._arguments=e.map(e=>String(e));for(const e of this._arguments)if(!this._uniforms.has(e)&&!this._uniforms.has(e+"[0]"))throw new o.f(`Argument "${e}" has not been declared in the shader`);return this}withDefines(e){if(this._defines.size>0)throw new o.g("Redefinition of externally defined constants of a shader");const t=[];for(const n of Object.keys(e)){const i=Number(e[n]);this._defines.set(n,i),t.push(`#define ${n} ${i}\n`)}const n=x+t.join("")+this._userSource;return this._fragmentSource=u.run(n,this._defines),this._uniforms=this._autodetectUniforms(this._fragmentSource),this}get fragmentSource(){return this._fragmentSource}get vertexSource(){return this._vertexSource}get attributes(){return m}get locationOfAttributes(){return _}get arguments(){return this._arguments}get uniforms(){return Array.from(this._uniforms.keys())}uniformType(e){if(!this._uniforms.has(e))throw new o.f(`Unrecognized uniform variable: "${e}"`);return this._uniforms.get(e)}definedConstant(e){if(!this._defines.has(e))throw new o.f(`Unrecognized externally defined constant: "${e}"`);return this._defines.get(e)}_autodetectUniforms(e){const t=e,n=/^\s*uniform\s+(highp\s+|mediump\s+|lowp\s+)?(\w+)\s+([^;]+)/gm,i=new Map;let s;for(;null!==(s=n.exec(t));){const e=s[2],t=s[3].split(",").map(e=>e.trim()).filter(e=>e);for(const n of t)if(n.endsWith("]")){if(!(s=n.match(/(\w+)\s*\[\s*(\d+)\s*\]$/)))throw new o.k(`Unspecified array length for uniform "${n}" in the shader`);const[t,r]=[s[1],Number(s[2])];for(let n=0;n<r;n++)i.set(`${t}[${n}]`,e)}else i.set(n,e)}return i}}function v(e){return y.import(e)}function w(e){return y.create(e)}},function(e,t,n){"use strict";n.d(t,"d",(function(){return s})),n.d(t,"c",(function(){return r})),n.d(t,"b",(function(){return o})),n.d(t,"e",(function(){return a})),n.d(t,"a",(function(){return c}));var i=n(1);const s=i.a.enum("Image","Video","Canvas","Bitmap"),r=Object.freeze({RGBA:0,GREY:1}),o=i.a.enum("RGB","Greyscale","Binary"),a=Object.freeze({RED:1,GREEN:2,BLUE:4,ALPHA:8,ALL:15}),c=Object.freeze({[a.RED]:0,[a.GREEN]:1,[a.BLUE]:2,[a.ALPHA]:3})},function(e,t,n){"use strict";n.r(t),n.d(t,"conv2D",(function(){return o})),n.d(t,"convX",(function(){return a})),n.d(t,"convY",(function(){return c}));var i=n(4),s=n(1),r=n(0);function o(e,t=1){const n=new Float32Array(e.map(e=>+e*+t)),o=0|Math.sqrt(n.length),a=o>>1;if(o<1||o%2==0)throw new r.f("Can't perform a 2D convolution with an invalid kSize of "+o);if(o*o!=n.length)throw new r.f(`Invalid 2D convolution kernel of ${n.length} elements (expected: square)`);const c=a<=7?"pixelAtShortOffset":"pixelAtLongOffset",l=`\n    uniform sampler2D image;\n\n    void main()\n    {\n        float alpha = threadPixel(image).a;\n        vec4 result = vec4(0.0f);\n\n        ${d=(e,t,n)=>`\n        result += ${c}(image, ivec2(${0|-n}, ${0|-t})) * float(${+e});\n    `,s.a.cartesian(s.a.symmetricRange(a),s.a.symmetricRange(a)).map(e=>d(n[(e[0]+a)*o+(e[1]+a)],e[0],e[1])).join("\n")}\n\n        color = vec4(result.rgb, alpha);\n    }\n    `;var d;return Object(i.a)(l).withArguments("image")}function a(e,t=1){return l("x",e,t)}function c(e,t=1){return l("y",e,t)}function l(e,t,n=1){const o=new Float32Array(t.map(e=>+e*+n)),a=o.length,c=a>>1;if(a<1||a%2==0)throw new r.f("Can't perform a 1D convolution with an invalid kSize of "+a);if("x"!=e&&"y"!=e)throw new r.f(`Can't perform 1D convolution: invalid axis "${e}"`);const l=c<=7?"pixelAtShortOffset":"pixelAtLongOffset",d=`\n    uniform sampler2D image;\n\n    void main()\n    {\n        float alpha = threadPixel(image).a;\n        vec4 pixel = vec4(0.0f);\n\n        ${h=(t,n)=>"x"==e?`\n        pixel += ${l}(image, ivec2(${0|-n}, 0)) * float(${+t});\n    `:`\n        pixel += ${l}(image, ivec2(0, ${0|-n})) * float(${+t});\n    `,s.a.symmetricRange(c).reduce((e,t)=>e+h(o[t+c],t),"")}\n\n        color = vec4(pixel.rgb, alpha);\n    }\n    `;var h;return Object(i.a)(d).withArguments("image")}},function(e,t){e.exports={MatrixType:
//! No imports here
//! MatrixType is exported to a WebWorker
class{static isValid(e){return Object.prototype.hasOwnProperty.call(this._classOf,e)}static createTypedArray(e,...t){if(!this.isValid(e))throw new Error(`Invalid matrix type: "${e}"`);return Reflect.construct(this._classOf[e],t)}static get default(){return"float32"}static get _classOf(){return this._dataType||(this._dataType=Object.freeze({float32:Float32Array,float64:Float64Array,int32:Int32Array,uint8:Uint8Array}))}static freeze(){const e=(this._classOf,this);return Object.freeze(e)}}.freeze()}},function(e,t,n){const{MatrixType:i}=n(7),s={...n(78),...n(79),...n(80),...n(81),...n(82),...n(83),...n(84),...n(85),...n(86),...n(87)},r=function(){"use strict";function e(){}e.lib=Object.create(null);const t=Object.create(null);return e.register=function(n,i){if("function"!=typeof i)throw new Error("Not a function: "+n);if("string"!=typeof n||!n.match(/^[a-z_][0-9a-z_]*$/i))throw new Error("Undesirable identifier: "+n);if(e.hasMethod(n))throw new Error("Can't redefine method "+n);const s={enumerable:!0,writable:!1,configurable:!1};Object.defineProperty(e.lib,n,{value:i.bind(e.lib),...s}),Object.defineProperty(t,n,{value:i.toString(),...s})},e.hasMethod=function(t){return Object.prototype.hasOwnProperty.call(e.lib,t)},e.toString=function(){const e=Object.keys(t).map(e=>`LinAlg.lib.${e} = (${t[e]}).bind(LinAlg.lib);`).join("\n");return`(function() {\n'use strict';\nfunction LinAlg() { }\nLinAlg.lib = Object.create(null);\nLinAlg.lib.MatrixType = (${i.toString()}).freeze();\n\n${e}\n\nObject.freeze(LinAlg.lib);\nreturn Object.freeze(LinAlg);\n})()`},Object.defineProperty(e.lib,"MatrixType",{value:i.freeze(),writable:!1,configurable:!1,enumerable:!1}),Object.keys(s).forEach(t=>{e.register(t,s[t])}),Object.freeze(e)}();e.exports={LinAlg:r}},function(e,t){e.exports="#ifndef _COLORS_GLSL\n#define _COLORS_GLSL\n#define PIXELCOMPONENT_RED   @PIXELCOMPONENT_RED@\n#define PIXELCOMPONENT_GREEN @PIXELCOMPONENT_GREEN@\n#define PIXELCOMPONENT_BLUE  @PIXELCOMPONENT_BLUE@\n#define PIXELCOMPONENT_ALPHA @PIXELCOMPONENT_ALPHA@\n#endif"},function(e,t){e.exports="#ifndef _FIXEDPOINT_GLSL\n#define _FIXEDPOINT_GLSL\n#define fixed_t int\n#define fixed2_t ivec2\nconst int FIX_BITS = int(@FIX_BITS@);\nconst float FIX_RESOLUTION = float(@FIX_RESOLUTION@);\n#define itofix(x) fixed_t((x) << FIX_BITS)\n#define fixtoi(f) int((x) >> FIX_BITS)\n#define ftofix(x) fixed_t((x) * FIX_RESOLUTION + 0.5f)\n#define fixtof(f) (float(f) / FIX_RESOLUTION)\n#define ivec2tofix(x) fixed2_t((x) << FIX_BITS)\n#define fixtoivec2(f) ivec2((f) >> FIX_BITS)\n#define vec2tofix(v) fixed2_t((v) * FIX_RESOLUTION + vec2(0.5f))\n#define fixtovec2(f) (vec2(f) / FIX_RESOLUTION)\n#endif"},function(e,t){e.exports="#ifndef _FLOAT16_GLSL\n#define _FLOAT16_GLSL\n#define encodeFloat16(f) (vec2(packf16(f)) / 255.0f)\n#define decodeFloat16(v) unpackf16(uvec2((v) * 255.0f))\nuvec2 packf16( float f)\n{\nuint y = packHalf2x16(vec2(f, 0.0f));\nreturn uvec2(y, y >> 8) & 0xFFu;\n}\nfloat unpackf16(uvec2 v)\n{\nv &= 0xFFu;\nreturn unpackHalf2x16(v.x | (v.y << 8)).x;\n}\n#endif"},function(e,t){e.exports="#ifndef _GLOBAL_GLSL\n#define _GLOBAL_GLSL\n#define threadLocation() ivec2(texCoord * texSize)\n#define outputSize() ivec2(texSize)\n#define threadPixel(img) textureLod((img), texCoord, 0.0f)\n#define pixelAt(img, pos) texelFetch((img), (pos), 0)\n#define pixelAtShortOffset(img, offset) textureLodOffset((img), texCoord, 0.0f, (offset))\n#define pixelAtLongOffset(img, offset) textureLod((img), texCoord + vec2(offset) / texSize, 0.0f)\n#endif"},function(e,t){e.exports='#ifndef _KEYPOINTS_GLSL\n#define _KEYPOINTS_GLSL\n@include "pyramids.glsl"\n@include "orientation.glsl"\n@include "fixed-point.glsl"\nstruct Keypoint\n{\nvec2 position;\nfloat orientation;\nfloat lod;\nfloat score;\nint flags;\n};\nstruct KeypointAddress\n{\nint base;\nint offset;\n};\nconst int MAX_DESCRIPTOR_SIZE = int(@MAX_DESCRIPTOR_SIZE@);\nconst int MIN_KEYPOINT_SIZE = int(@MIN_KEYPOINT_SIZE@);\nconst int KPF_NONE = int(@KPF_NONE@);\nconst int KPF_ORIENTED = int(@KPF_ORIENTED@);\nconst int KPF_DISCARD = int(@KPF_DISCARD@);\n#define encodeKeypointFlags(flags) (float(flags) / 255.0f)\n#define decodeKeypointFlags(encodedFlags) int((encodedFlags) * 255.0f)\n#define encodeNullKeypoint() (vec4(1.0f))\n#define encodeDiscardedKeypoint() (vec4(0.0f))\n#define sizeofEncodedKeypoint(descriptorSize, extraSize) (MIN_KEYPOINT_SIZE + (descriptorSize) + (extraSize))\n#define findKeypointIndex(address, descriptorSize, extraSize) ((address).base / ((sizeofEncodedKeypoint((descriptorSize), (extraSize))) / 4))\nvec4 readKeypointData(sampler2D encodedKeypoints, int encoderLength, KeypointAddress address)\n{\nint rasterIndex = address.base + address.offset;\nvec4 data = pixelAt(encodedKeypoints, ivec2(rasterIndex % encoderLength, rasterIndex / encoderLength));\nreturn rasterIndex < encoderLength * encoderLength ? data : encodeNullKeypoint();\n}\nKeypointAddress findKeypointAddress(ivec2 thread, int encoderLength, int descriptorSize, int extraSize)\n{\nint threadRaster = thread.y * encoderLength + thread.x;\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nint keypointIndex = int(threadRaster / pixelsPerKeypoint);\nKeypointAddress address = KeypointAddress(\nkeypointIndex * pixelsPerKeypoint,\nthreadRaster % pixelsPerKeypoint\n);\nreturn address;\n}\nKeypoint decodeKeypoint(sampler2D encodedKeypoints, int encoderLength, KeypointAddress address)\n{\nconst vec4 ones = vec4(1.0f);\nKeypoint keypoint;\nKeypointAddress positionAddress = KeypointAddress(address.base, 0);\nKeypointAddress propertiesAddress = KeypointAddress(address.base, 1);\nvec4 rawEncodedPosition = readKeypointData(encodedKeypoints, encoderLength, positionAddress);\nivec4 encodedPosition = ivec4(rawEncodedPosition * 255.0f);\nkeypoint.position = fixtovec2(fixed2_t(\nencodedPosition.r | (encodedPosition.g << 8),\nencodedPosition.b | (encodedPosition.a << 8)\n));\nvec4 encodedProperties = readKeypointData(encodedKeypoints, encoderLength, propertiesAddress);\nkeypoint.orientation = decodeOrientation(encodedProperties.g);\nkeypoint.lod = decodeLod(encodedProperties.r);\nkeypoint.score = encodedProperties.b;\nkeypoint.flags = decodeKeypointFlags(encodedProperties.a);\nbool isNull = all(greaterThanEqual(rawEncodedPosition, ones));\nkeypoint.score = keypoint.score * float(!isNull) - float(isNull);\nkeypoint.score -= float(keypoint.score == 0.0f) * float(all(equal(keypoint.position, vec2(0.0f))));\nreturn keypoint;\n}\nvec4 encodeKeypointPosition(vec2 position)\n{\nconst vec2 zeros = vec2(0.0f);\nfixed2_t pos = vec2tofix(max(position, zeros));\nfixed2_t lo = pos & 255;\nfixed2_t hi = pos >> 8;\nreturn vec4(lo.x, hi.x, lo.y, hi.y) / 255.0f;\n}\n#define isBadKeypoint(keypoint) ((keypoint).score < 0.0f)\n#define encodeKeypointPositionAtInfinity() (vec4(254.0f / 255.0f, vec3(1.0f)))\nbool isKeypointAtInfinity(Keypoint keypoint)\n{\nconst vec2 V2_MAX_TEXTURE_LENGTH = vec2(@MAX_TEXTURE_LENGTH@);\nreturn any(greaterThan(keypoint.position, V2_MAX_TEXTURE_LENGTH));\n}\n#endif'},function(e,t){e.exports="#ifndef _MATH_GLSL\n#define _MATH_GLSL\n#define TWO_PI          6.28318530718f\n#define PI              3.14159265359f\n#define PI_OVER_2       1.57079632679f\n#define PI_OVER_4       0.78539816339f\n#define INV_PI          0.3183098861837907f\n#define USE_FAST_ATAN\n#ifdef USE_FAST_ATAN\nfloat fastAtan(float x)\n{\nfloat w = 1.0f - abs(x);\nreturn (w >= 0.0f) ? ((PI_OVER_4 + 0.273 * w) * x) :\n(sign(x) * PI_OVER_2 - (PI_OVER_4 + 0.273 * (1.0f - abs(1.0f / x))) / x);\n}\n#else\n#define fastAtan(x) atan(x)\n#endif\n#ifdef USE_FAST_ATAN\nfloat fastAtan2(float y, float x)\n{\nreturn (x == 0.0f) ? PI_OVER_2 * sign(y) : fastAtan(y / x) + float(x < 0.0f) * PI * sign(y);\n}\n#else\n#define fastAtan2(y, x) atan((y), (x))\n#endif\n#endif"},function(e,t){e.exports='#ifndef _ORIENTATION_GLSL\n#define _ORIENTATION_GLSL\n@include "math.glsl"\n#define encodeOrientation(angle) (((angle) * INV_PI + 1.0f) * 0.5f)\n#define decodeOrientation(value) (((value) * 2.0f - 1.0f) * PI)\n#endif'},function(e,t){e.exports="#ifndef _PYRAMIDS_GLSL\n#define _PYRAMIDS_GLSL\n#define pyrPixel(pyr, lod) textureLod((pyr), texCoord, (lod))\n#define pyrPixelAtOffset(pyr, lod, pot, offset) textureLod((pyr), texCoord + ((pot) * vec2(offset)) / texSize, (lod))\n#define pyrPixelAt(pyr, pos, lod) textureLod((pyr), (vec2(pos) + vec2(0.5f)) / texSize, (lod))\n#define pyrPixelAtEx(pyr, pos, lod, pyrBaseSize) textureLod((pyr), (vec2(pos) + vec2(0.5f)) / vec2(pyrBaseSize), (lod))\n#define pyrSubpixelAtEx(pyr, pos, lod, pyrBaseSize) textureLod((pyr), ((pos) + vec2(0.5f)) / vec2(pyrBaseSize), (lod))\n#define pyrSubpixelAtExOffset(pyr, pos, lod, pot, offset, pyrBaseSize) textureLod((pyr), (((pos) + vec2(0.5f)) + ((pot) * vec2(offset))) / vec2(pyrBaseSize), (lod))\nconst int PYRAMID_MAX_LEVELS = int(@PYRAMID_MAX_LEVELS@);\nconst float F_PYRAMID_MAX_LEVELS = float(@PYRAMID_MAX_LEVELS@);\nconst float LOG2_PYRAMID_MAX_SCALE = float(@LOG2_PYRAMID_MAX_SCALE@);\nfloat encodeLod(float lod)\n{\nreturn (LOG2_PYRAMID_MAX_SCALE + lod) / (LOG2_PYRAMID_MAX_SCALE + F_PYRAMID_MAX_LEVELS);\n}\nfloat decodeLod(float encodedLod)\n{\nfloat lod = encodedLod * (LOG2_PYRAMID_MAX_SCALE + F_PYRAMID_MAX_LEVELS) - LOG2_PYRAMID_MAX_SCALE;\nreturn lod - lod * step(1.0f, encodedLod);\n}\n#define isSameEncodedLod(alpha1, alpha2) (abs((alpha1) - (alpha2)) < encodedLodEps)\nconst float encodedLodEps = 0.2f / (LOG2_PYRAMID_MAX_SCALE + F_PYRAMID_MAX_LEVELS);\n#endif"},function(e,t){e.exports="#ifndef _QUICKSELECT_GLSL\n#define _QUICKSELECT_GLSL\n#if defined(QUICKSELECT_UNSIGNED) && !defined(QUICKSELECT_SIGNED)\n#define QS_TYPE uint\n#define QS_TYPE4 uvec4\n#elif !defined(QUICKSELECT_UNSIGNED) && defined(QUICKSELECT_SIGNED)\n#define QS_TYPE int\n#define QS_TYPE4 ivec4\n#else\n#error Must define either QUICKSELECT_SIGNED or QUICKSELECT_UNSIGNED before including quickselect\n#endif\n#if defined(QUICKSELECT_ASCENDING) && !defined(QUICKSELECT_DESCENDING)\n#define QS_ORD(element,pivot) ((element) < (pivot))\n#elif defined(QUICKSELECT_DESCENDING) && !defined(QUICKSELECT_ASCENDING)\n#define QS_ORD(element,pivot) ((element) > (pivot))\n#else\n#error Must define either QUICKSELECT_ASCENDING or QUICKSELECT_DESCENDING before including quickselect\n#endif\n#ifdef QUICKSELECT_ARRAY\n#define QS_ARRAY QUICKSELECT_ARRAY\n#else\n#error Must define QUICKSELECT_ARRAY before including quickselect\n#endif\nint qspart(int l, int r, int p)\n{\n#define QS_SWAP(a,b) t = QS_ARRAY[(a)]; QS_ARRAY[(a)] = QS_ARRAY[(b)]; QS_ARRAY[(b)] = t\nhighp QS_TYPE e, t, mask, pivot = QS_ARRAY[p];\nhighp QS_TYPE4 tmp;\nint q, cond;\nQS_SWAP(p, r);\nq = l;\nfor(int i = l; i < r; i++) {\ne = QS_ARRAY[i];\nt = QS_ARRAY[q];\ncond = int(QS_ORD(e, pivot));\nmask = QS_TYPE(-cond);\ntmp = QS_TYPE4(mask & t, (~mask) & e, mask & e, (~mask) & t);\nQS_ARRAY[i] = tmp.x | tmp.y;\nQS_ARRAY[q] = tmp.z | tmp.w;\nq += cond;\n}\nQS_SWAP(q, r);\nreturn q;\n}\nhighp QS_TYPE quickselect(int l, int r, int k)\n{\nint p = -1337;\nivec2 idx = ivec2(l, r);\nwhile(idx.s < idx.t && p != k) {\np = qspart(idx.s, idx.t, (idx.s + idx.t) / 2);\nidx = int(k < p) * ivec2(idx.s, p-1) + int(k >= p) * ivec2(p+1, idx.t);\n}\nreturn (p == k) ? QS_ARRAY[k] : QS_ARRAY[idx.s];\n}\n#endif"},function(e,t){e.exports="#ifndef _SOBEL_GLSL\n#define _SOBEL_GLSL\nvec4 encodeSobel(vec2 df)\n{\n#ifdef SOBEL_USE_LOG\nconst vec2 zero = vec2(0.0f);\nvec2 dmax = -max(df, zero);\nvec2 dmin = min(df, zero);\nreturn exp2(vec4(dmax, dmin));\n#else\nuint data = packHalf2x16(df);\nuvec4 bytes = uvec4(data, data >> 8, data >> 16, data >> 24) & 255u;\nreturn vec4(bytes) / 255.0f;\n#endif\n}\nvec2 decodeSobel(vec4 encodedSobel)\n{\n#ifdef SOBEL_USE_LOG\nvec4 lg = log2(encodedSobel);\nreturn vec2(lg.b - lg.r, lg.a - lg.g);\n#else\nuvec4 bytes = uvec4(encodedSobel * 255.0f);\nuint data = bytes.r | (bytes.g << 8) | (bytes.b << 16) | (bytes.a << 24);\nreturn unpackHalf2x16(data);\n#endif\n}\n#endif"},function(e,t){e.exports="#ifndef _SUBPIXEL_GLSL\n#define _SUBPIXEL_GLSL\n#define subpixelAtHW(image, pos) textureLod((image), ((pos) + vec2(0.5f)) / texSize, 0.0f)\nvec4 subpixelAtBI(sampler2D image, vec2 pos)\n{\nvec2 frc = fract(pos);\nvec2 ifrc = vec2(1.0f) - frc;\nvec2 p = (floor(pos) + vec2(0.5f)) / vec2(textureSize(image, 0));\nvec4 pix00 = textureLod(image, p, 0.0f);\nvec4 pix10 = textureLodOffset(image, p, 0.0f, ivec2(1,0));\nvec4 pix01 = textureLodOffset(image, p, 0.0f, ivec2(0,1));\nvec4 pix11 = textureLodOffset(image, p, 0.0f, ivec2(1,1));\nmat4 pix = mat4(pix00, pix10, pix01, pix11);\nvec4 mul = vec4(ifrc.x * ifrc.y, frc.x * ifrc.y, ifrc.x * frc.y, frc.x * frc.y);\nreturn pix * mul;\n}\n#endif"},function(e,t,n){e.exports=n(88).Speedy},function(e,t){var n,i,s=e.exports={};function r(){throw new Error("setTimeout has not been defined")}function o(){throw new Error("clearTimeout has not been defined")}function a(e){if(n===setTimeout)return setTimeout(e,0);if((n===r||!n)&&setTimeout)return n=setTimeout,setTimeout(e,0);try{return n(e,0)}catch(t){try{return n.call(null,e,0)}catch(t){return n.call(this,e,0)}}}!function(){try{n="function"==typeof setTimeout?setTimeout:r}catch(e){n=r}try{i="function"==typeof clearTimeout?clearTimeout:o}catch(e){i=o}}();var c,l=[],d=!1,h=-1;function u(){d&&c&&(d=!1,c.length?l=c.concat(l):h=-1,l.length&&p())}function p(){if(!d){var e=a(u);d=!0;for(var t=l.length;t;){for(c=l,l=[];++h<t;)c&&c[h].run();h=-1,t=l.length}c=null,d=!1,function(e){if(i===clearTimeout)return clearTimeout(e);if((i===o||!i)&&clearTimeout)return i=clearTimeout,clearTimeout(e);try{i(e)}catch(t){try{return i.call(null,e)}catch(t){return i.call(this,e)}}}(e)}}function f(e,t){this.fun=e,this.array=t}function m(){}s.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)t[n-1]=arguments[n];l.push(new f(e,t)),1!==l.length||d||a(p)},f.prototype.run=function(){this.fun.apply(null,this.array)},s.title="browser",s.browser=!0,s.env={},s.argv=[],s.version="",s.versions={},s.on=m,s.addListener=m,s.once=m,s.off=m,s.removeListener=m,s.removeAllListeners=m,s.emit=m,s.prependListener=m,s.prependOnceListener=m,s.listeners=function(e){return[]},s.binding=function(e){throw new Error("process.binding is not supported")},s.cwd=function(){return"/"},s.chdir=function(e){throw new Error("process.chdir is not supported")},s.umask=function(){return 0}},function(e,t,n){var i={"./colors.glsl":9,"./fixed-point.glsl":10,"./float16.glsl":11,"./global.glsl":12,"./keypoints.glsl":13,"./math.glsl":14,"./orientation.glsl":15,"./pyramids.glsl":16,"./quickselect.glsl":17,"./sobel.glsl":18,"./subpixel.glsl":19};function s(e){var t=r(e);return n(t)}function r(e){if(!n.o(i,e)){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}return i[e]}s.keys=function(){return Object.keys(i)},s.resolve=r,e.exports=s,s.id=22},function(e,t,n){var i={"./colors/rgb2grey.glsl":24,"./encoders/encode-keypoint-long-offsets.glsl":25,"./encoders/encode-keypoint-offsets.glsl":26,"./encoders/encode-keypoints.glsl":27,"./encoders/encode-null-keypoints.glsl":28,"./encoders/resize-encoded-keypoints.glsl":29,"./encoders/upload-keypoints.glsl":30,"./enhancements/nightvision.glsl":31,"./enhancements/normalize-image.glsl":32,"./filters/convolution":6,"./filters/convolution.js":6,"./filters/convolution1d.glsl":33,"./filters/convolution2d.glsl":34,"./filters/fast-median.glsl":35,"./include/colors.glsl":9,"./include/fixed-point.glsl":10,"./include/float16.glsl":11,"./include/global.glsl":12,"./include/keypoints.glsl":13,"./include/math.glsl":14,"./include/orientation.glsl":15,"./include/pyramids.glsl":16,"./include/quickselect.glsl":17,"./include/sobel.glsl":18,"./include/subpixel.glsl":19,"./keypoints/brisk.glsl":36,"./keypoints/expand-encoder.glsl":37,"./keypoints/fast.glsl":38,"./keypoints/fast/fast-score12.glsl":39,"./keypoints/fast/fast-score16.glsl":40,"./keypoints/fast/fast-score8.glsl":41,"./keypoints/fast/fast5.glsl":42,"./keypoints/fast/fast7.glsl":43,"./keypoints/fast/fast9.glsl":44,"./keypoints/fast/multiscale-fast.glsl":45,"./keypoints/harris-cutoff.glsl":46,"./keypoints/harris-derivatives.glsl":47,"./keypoints/harris.glsl":48,"./keypoints/harris/encode-harris-score.glsl":49,"./keypoints/harris/multiscale-harris.glsl":50,"./keypoints/harris/multiscale-sobel.glsl":51,"./keypoints/mix-keypoints.glsl":52,"./keypoints/nonmax-suppression.glsl":53,"./keypoints/orb-descriptor.glsl":54,"./keypoints/orb-orientation.glsl":55,"./keypoints/score-8bits.glsl":56,"./keypoints/score-findmax.glsl":57,"./keypoints/sort-applyperm.glsl":58,"./keypoints/sort-createperm.glsl":59,"./keypoints/sort-mergeperm.glsl":60,"./keypoints/suppress-descriptors.glsl":61,"./keypoints/transfer-orientation.glsl":62,"./keypoints/upload-keypoints.glsl":63,"./pyramids/downsample2.glsl":64,"./pyramids/upsample2.glsl":65,"./trackers/lk-discard-old.glsl":66,"./trackers/lk-discard.glsl":67,"./trackers/lk.glsl":68,"./trackers/transfer-flow.glsl":69,"./transforms/resize.glsl":70,"./transforms/warp-perspective.glsl":71,"./utils/copy-components.glsl":72,"./utils/fill-components.glsl":73,"./utils/fill.glsl":74,"./utils/flip-y.glsl":75,"./utils/identity.glsl":76,"./utils/scan-minmax2d.glsl":77};function s(e){var t=r(e);return n(t)}function r(e){if(!n.o(i,e)){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}return i[e]}s.keys=function(){return Object.keys(i)},s.resolve=r,e.exports=s,s.id=23},function(e,t){e.exports="const vec4 grey = vec4(0.299f, 0.587f, 0.114f, 0.0f);\nuniform sampler2D image;\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nfloat g = dot(pixel, grey);\ncolor = vec4(g, g, g, 1.0f);\n}"},function(e,t){e.exports="uniform sampler2D offsetsImage;\nuniform ivec2 imageSize;\n#ifndef MAX_ITERATIONS\n#error Must define MAX_ITERATIONS\n#endif\n#define decodeSkipOffset(pixel) (int((pixel).g * 255.0f) | (int((pixel).b * 255.0f) << 8))\n#define encodeSkipOffset(offset) (vec2((offset) & 255, (offset) >> 8) / 255.0f)\nvoid main()\n{\nvec4 pixel = threadPixel(offsetsImage);\nivec2 thread = threadLocation();\nfloat score = pixel.r;\nfloat scale = pixel.a;\nint rasterIndex = thread.y * imageSize.x + thread.x;\nint offset = decodeSkipOffset(pixel);\nint totalOffset = offset;\nivec2 pos = thread;\n#if 0\nwhile(offset < MAX_ITERATIONS && pos.y < imageSize.y && pixel.r == 0.0f) {\nrasterIndex += offset;\npos = ivec2(rasterIndex % imageSize.x, rasterIndex / imageSize.x);\npixel = pixelAt(offsetsImage, pos);\noffset = decodeSkipOffset(pixel);\ntotalOffset += offset;\n}\n#else\nint allow = 1;\nfor(int i = 0; i < MAX_ITERATIONS; i++) {\nallow *= int(pos.y < imageSize.y) * int(pixel.r == 0.0f);\nrasterIndex += allow * offset;\npos = ivec2(rasterIndex % imageSize.x, rasterIndex / imageSize.x);\npixel = pixelAt(offsetsImage, pos);\noffset = decodeSkipOffset(pixel);\ntotalOffset += allow * offset;\n}\n#endif\ntotalOffset = min(totalOffset, 65535);\ncolor = vec4(score, encodeSkipOffset(totalOffset), scale);\n}"},function(e,t){e.exports="uniform sampler2D corners;\nuniform ivec2 imageSize;\n#if !defined(MAX_ITERATIONS)\n#error Must define MAX_ITERATIONS\n#elif MAX_ITERATIONS > 255\n#error MAX_ITERATIONS must be less than 256\n#endif\nvoid main()\n{\nvec4 pixel = threadPixel(corners);\nivec2 pos = threadLocation();\nfloat score = pixel.r;\nfloat scale = pixel.a;\nint offset = 0;\n#if 0\nwhile(offset < MAX_ITERATIONS && pos.y < imageSize.y && pixelAt(corners, pos).r == 0.0f) {\n++offset;\npos.x = (pos.x + 1) % imageSize.x;\npos.y += int(pos.x == 0);\n}\n#else\nint allow = 1;\nfor(int i = 0; i < MAX_ITERATIONS; i++) {\nallow *= int(pos.y < imageSize.y) * int(pixel.r == 0.0f);\noffset += allow;\npos.x = (pos.x + 1) % imageSize.x;\npos.y += int(pos.x == 0);\npixel = pixelAt(corners, pos);\n}\n#endif\ncolor = vec4(score, float(offset) / 255.0f, 0.0f, scale);\n}"},function(e,t){e.exports='@include "keypoints.glsl"\nuniform sampler2D offsetsImage;\nuniform ivec2 imageSize;\nuniform int passId;\nuniform int numPasses;\nuniform int keypointLimit;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\n#define decodeSkipOffset(pixel) (int((pixel).g * 255.0f) | (int((pixel).b * 255.0f) << 8))\nbool findQthKeypoint(int q, int p, inout ivec2 position, out vec4 pixel)\n{\nint notFirstPass = int(passId > 0);\nposition *= notFirstPass;\np |= -(1 - notFirstPass);\np -= notFirstPass;\nint rasterIndex = position.y * imageSize.x + position.x;\nwhile(position.y < imageSize.y && p != q) {\nposition = ivec2(rasterIndex % imageSize.x, rasterIndex / imageSize.x);\npixel = texelFetch(offsetsImage, position, 0);\np += int(pixel.r > 0.0f);\nrasterIndex += max(1, decodeSkipOffset(pixel));\n}\nreturn (p == q);\n}\nvoid main()\n{\nivec2 thread = threadLocation();\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nint q = findKeypointIndex(address, descriptorSize, extraSize);\ncolor = vec4(0.0f);\nif(address.offset > 1)\nreturn;\ncolor = threadPixel(encodedKeypoints);\nint numPixels = encoderLength * encoderLength;\nint maxKeypoints = numPixels / pixelsPerKeypoint;\nint maxKeypointsPerPass = maxKeypoints / numPasses + int(maxKeypoints % numPasses != 0);\nint targetPassId = q / maxKeypointsPerPass;\nif(passId != targetPassId)\nreturn;\nint lastIndexFromPrevPass = passId * maxKeypointsPerPass - 1;\nKeypointAddress lastAddressFromPrevPass = KeypointAddress(max(0, lastIndexFromPrevPass) * pixelsPerKeypoint, 0);\nKeypoint lastKeypointFromPrevPass = decodeKeypoint(encodedKeypoints, encoderLength, lastAddressFromPrevPass);\nivec2 position = ivec2(lastKeypointFromPrevPass.position);\nvec4 pixel;\ncolor = encodeNullKeypoint();\nif(q >= min(maxKeypoints, keypointLimit) || !findQthKeypoint(q, lastIndexFromPrevPass, position, pixel))\nreturn;\ncolor = (address.offset == 1) ? vec4(\npixel.a,\nencodeOrientation(0.0f),\npixel.r,\nencodeKeypointFlags(KPF_NONE)\n) : encodeKeypointPosition(\nvec2(position)\n);\n}'},function(e,t){e.exports='@include "keypoints.glsl"\nvoid main()\n{\ncolor = encodeNullKeypoint();\n}'},function(e,t){e.exports='@include "keypoints.glsl"\nuniform sampler2D inputTexture;\nuniform int inputDescriptorSize;\nuniform int inputExtraSize;\nuniform int inputEncoderLength;\nuniform int outputDescriptorSize;\nuniform int outputExtraSize;\nuniform int outputEncoderLength;\nvoid main()\n{\nvec4 pixel = threadPixel(inputTexture);\nivec2 thread = threadLocation();\nKeypointAddress myAddress = findKeypointAddress(\nthread,\noutputEncoderLength,\noutputDescriptorSize,\noutputExtraSize\n);\nint myIndex = findKeypointIndex(\nmyAddress,\noutputDescriptorSize,\noutputExtraSize\n);\nint pixelsPerKeypoint = sizeofEncodedKeypoint(inputDescriptorSize, inputExtraSize) / 4;\nKeypointAddress otherAddress = KeypointAddress(\nmyIndex * pixelsPerKeypoint,\nmyAddress.offset\n);\nint head = MIN_KEYPOINT_SIZE / 4;\ncolor = (myAddress.offset >= head) ? vec4(0.0f) :\nreadKeypointData(inputTexture, inputEncoderLength, otherAddress);\n}'},function(e,t){e.exports='@include "keypoints.glsl"\nuniform int keypointCount;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\n#ifndef KEYPOINT_BUFFER_LENGTH\n#error Must specify KEYPOINT_BUFFER_LENGTH\n#endif\nlayout(std140) uniform KeypointBuffer\n{\nvec4 keypointBuffer[KEYPOINT_BUFFER_LENGTH];\n};\nvoid main()\n{\nivec2 thread = threadLocation();\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nint index = findKeypointIndex(address, descriptorSize, extraSize);\ncolor = encodeNullKeypoint();\nif(index >= keypointCount)\nreturn;\nvec4 data = keypointBuffer[index];\nswitch(address.offset) {\ncase 0: {\nfixed2_t pos = vec2tofix(data.xy);\nfixed2_t lo = pos & 255;\nfixed2_t hi = (pos >> 8) & 255;\ncolor = vec4(float(lo.x), float(hi.x), float(lo.y), float(hi.y)) / 255.0f;\nbreak;\n}\ncase 1: {\nfloat score = clamp(data.w, 0.0f, 1.0f);\nfloat scale = encodeLod(data.z);\nfloat rotation = encodeOrientation(0.0f);\nfloat flags = encodeKeypointFlags(KPF_NONE);\ncolor = vec4(scale, rotation, score, flags);\nbreak;\n}\ndefault: {\ncolor = vec4(0.0f);\nbreak;\n}\n}\n}'},function(e,t){e.exports="uniform sampler2D image;\nuniform sampler2D illuminationMap;\nuniform float gain;\nuniform float offset;\nuniform float decay;\nconst mat3 rgb2yuv = mat3(\n0.299f, -0.14713f, 0.615f,\n0.587f, -0.28886f, -0.51499f,\n0.114f, 0.436f, -0.10001f\n);\nconst mat3 yuv2rgb = mat3(\n1.0f, 1.0f, 1.0f,\n0.0f, -0.39465f, 2.03211f,\n1.13983f, -0.58060f, 0.0f\n);\nconst float eps = 0.0001f;\nconst float sqrt2 = 1.4142135623730951f;\nconst float magic = 20.0f;\nconst vec2 center = vec2(0.5f);\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nvec4 imapPixel = threadPixel(illuminationMap);\nfloat lambda = -sqrt2 * log(max(1.0f - decay, eps));\nfloat dist = length(texCoord - center);\nfloat vgain = gain * exp(-lambda * dist);\nfloat normalizedGain = 2.0f * vgain;\nfloat normalizedOffset = 2.0f * offset - 1.0f;\n#ifdef GREYSCALE\nfloat luma = 1.0 / (1.0 + exp(-normalizedGain * magic * (pixel.g - imapPixel.g)));\nluma = clamp(luma + normalizedOffset, 0.0f, 1.0f);\ncolor = vec4(luma, luma, luma, 1.0f);\n#else\nvec3 yuvPixel = rgb2yuv * pixel.rgb;\nvec3 yuvImapPixel = rgb2yuv * imapPixel.rgb;\nfloat luma = 1.0 / (1.0 + exp(-normalizedGain * magic * (yuvPixel.r - yuvImapPixel.r)));\nluma += normalizedOffset;\nvec3 rgbCorrectedPixel = yuv2rgb * vec3(luma, yuvPixel.gb);\nrgbCorrectedPixel = clamp(rgbCorrectedPixel, 0.0f, 1.0f);\ncolor = vec4(rgbCorrectedPixel, 1.0f);\n#endif\n}"},function(e,t){e.exports="#ifdef GREYSCALE\nuniform sampler2D minmax2d;\n#else\nuniform sampler2D minmax2dRGB[3];\n#endif\nuniform float minValue;\nuniform float maxValue;\nconst float eps = 1.0f / 255.0f;\nvoid main()\n{\nvec2 minmax = clamp(vec2(minValue, maxValue), 0.0f, 255.0f) / 255.0f;\nvec4 newMin = vec4(minmax.x);\nvec4 newRange = vec4(minmax.y - minmax.x);\nvec4 alpha = vec4(1.0f, newMin.x, newRange.x, 1.0f);\n#ifdef GREYSCALE\nvec4 pixel = threadPixel(minmax2d);\nmat4 channel = mat4(pixel, pixel, pixel, alpha);\n#else\nmat4 channel = mat4(\nthreadPixel(minmax2dRGB[0]),\nthreadPixel(minmax2dRGB[1]),\nthreadPixel(minmax2dRGB[2]),\nalpha\n);\n#endif\nvec4 oldMin = vec4(channel[0].g, channel[1].g, channel[2].g, channel[3].g);\nvec4 oldRange = max(vec4(channel[0].b, channel[1].b, channel[2].b, channel[3].b), eps);\nvec4 oldIntensity = vec4(channel[0].a, channel[1].a, channel[2].a, channel[3].a);\nvec4 newIntensity = (oldIntensity - oldMin) * newRange / oldRange + newMin;\ncolor = newIntensity;\n}"},function(e,t){e.exports="#if !defined(KERNEL_SIZE) || !defined(AXIS)\n#define Must define KERNEL_SIZE and AXIS\n#endif\nuniform sampler2D image;\nuniform float kernel[@KERNEL_SIZE@];\n#define S(x,y,k) result += pixelAtShortOffset(image, ivec2((x),(y))) * kernel[k]\nvoid main()\n{\nvec4 result = vec4(0.0f);\n#if AXIS == 0 && KERNEL_SIZE == 3\nS(-1, 0, 2);\nS( 0, 0, 1);\nS( 1, 0, 0);\n#elif AXIS == 1 && KERNEL_SIZE == 3\nS( 0,-1, 2);\nS( 0, 0, 1);\nS( 0, 1, 0);\n#elif AXIS == 0 && KERNEL_SIZE == 5\nS(-2, 0, 4);\nS(-1, 0, 3);\nS( 0, 0, 2);\nS( 1, 0, 1);\nS( 2, 0, 0);\n#elif AXIS == 1 && KERNEL_SIZE == 5\nS(0,-2, 4);\nS(0,-1, 3);\nS(0, 0, 2);\nS(0, 1, 1);\nS(0, 2, 0);\n#elif AXIS == 0 && KERNEL_SIZE == 7\nS(-3, 0, 6);\nS(-2, 0, 5);\nS(-1, 0, 4);\nS( 0, 0, 3);\nS( 1, 0, 2);\nS( 2, 0, 1);\nS( 3, 0, 0);\n#elif AXIS == 1 && KERNEL_SIZE == 7\nS(0,-3, 6);\nS(0,-2, 5);\nS(0,-1, 4);\nS(0, 0, 3);\nS(0, 1, 2);\nS(0, 2, 1);\nS(0, 3, 0);\n#elif AXIS == 0 && KERNEL_SIZE == 9\nS(-4, 0, 8);\nS(-3, 0, 7);\nS(-2, 0, 6);\nS(-1, 0, 5);\nS( 0, 0, 4);\nS( 1, 0, 3);\nS( 2, 0, 2);\nS( 3, 0, 1);\nS( 4, 0, 0);\n#elif AXIS == 1 && KERNEL_SIZE == 9\nS(0,-4, 8);\nS(0,-3, 7);\nS(0,-2, 6);\nS(0,-1, 5);\nS(0, 0, 4);\nS(0, 1, 3);\nS(0, 2, 2);\nS(0, 3, 1);\nS(0, 4, 0);\n#elif AXIS == 0 && KERNEL_SIZE == 11\nS(-5, 0, 10);\nS(-4, 0, 9);\nS(-3, 0, 8);\nS(-2, 0, 7);\nS(-1, 0, 6);\nS( 0, 0, 5);\nS( 1, 0, 4);\nS( 2, 0, 3);\nS( 3, 0, 2);\nS( 4, 0, 1);\nS( 5, 0, 0);\n#elif AXIS == 1 && KERNEL_SIZE == 11\nS(0,-5, 10);\nS(0,-4, 9);\nS(0,-3, 8);\nS(0,-2, 7);\nS(0,-1, 6);\nS(0, 0, 5);\nS(0, 1, 4);\nS(0, 2, 3);\nS(0, 3, 2);\nS(0, 4, 1);\nS(0, 5, 0);\n#elif AXIS == 0 && KERNEL_SIZE == 13\nS(-6, 0, 12);\nS(-5, 0, 11);\nS(-4, 0, 10);\nS(-3, 0, 9);\nS(-2, 0, 8);\nS(-1, 0, 7);\nS( 0, 0, 6);\nS( 1, 0, 5);\nS( 2, 0, 4);\nS( 3, 0, 3);\nS( 4, 0, 2);\nS( 5, 0, 1);\nS( 6, 0, 0);\n#elif AXIS == 1 && KERNEL_SIZE == 13\nS(0,-6, 12);\nS(0,-5, 11);\nS(0,-4, 10);\nS(0,-3, 9);\nS(0,-2, 8);\nS(0,-1, 7);\nS(0, 0, 6);\nS(0, 1, 5);\nS(0, 2, 4);\nS(0, 3, 3);\nS(0, 4, 2);\nS(0, 5, 1);\nS(0, 6, 0);\n#elif AXIS == 0 && KERNEL_SIZE == 15\nS(-7, 0, 14);\nS(-6, 0, 13);\nS(-5, 0, 12);\nS(-4, 0, 11);\nS(-3, 0, 10);\nS(-2, 0, 9);\nS(-1, 0, 8);\nS( 0, 0, 7);\nS( 1, 0, 6);\nS( 2, 0, 5);\nS( 3, 0, 4);\nS( 4, 0, 3);\nS( 5, 0, 2);\nS( 6, 0, 1);\nS( 7, 0, 0);\n#elif AXIS == 1 && KERNEL_SIZE == 15\nS(0,-7, 14);\nS(0,-6, 13);\nS(0,-5, 12);\nS(0,-4, 11);\nS(0,-3, 10);\nS(0,-2, 9);\nS(0,-1, 8);\nS(0, 0, 7);\nS(0, 1, 6);\nS(0, 2, 5);\nS(0, 3, 4);\nS(0, 4, 3);\nS(0, 5, 2);\nS(0, 6, 1);\nS(0, 7, 0);\n#else\n#error Invalid parameters\n#endif\ncolor = vec4(result.rgb, 1.0f);\n}"},function(e,t){e.exports="#ifndef KERNEL_SIZE_SQUARED\n#define Must define KERNEL_SIZE_SQUARED\n#endif\nuniform sampler2D image;\nuniform float kernel[@KERNEL_SIZE_SQUARED@];\n#define S(x,y,k) result += pixelAtShortOffset(image, ivec2((x),(y))) * kernel[k]\nvoid main()\n{\nvec4 result = vec4(0.0f);\n#if KERNEL_SIZE_SQUARED == 9\nS(-1,-1, 8);\nS(-1, 0, 7);\nS(-1, 1, 6);\nS( 0,-1, 5);\nS( 0, 0, 4);\nS( 0, 1, 3);\nS( 1,-1, 2);\nS( 1, 0, 1);\nS( 1, 1, 0);\n#elif KERNEL_SIZE_SQUARED == 25\nS(-2,-2, 24);\nS(-2,-1, 23);\nS(-2, 0, 22);\nS(-2, 1, 21);\nS(-2, 2, 20);\nS(-1,-2, 19);\nS(-1,-1, 18);\nS(-1, 0, 17);\nS(-1, 1, 16);\nS(-1, 2, 15);\nS( 0,-2, 14);\nS( 0,-1, 13);\nS( 0, 0, 12);\nS( 0, 1, 11);\nS( 0, 2, 10);\nS( 1,-2, 9);\nS( 1,-1, 8);\nS( 1, 0, 7);\nS( 1, 1, 6);\nS( 1, 2, 5);\nS( 2,-2, 4);\nS( 2,-1, 3);\nS( 2, 0, 2);\nS( 2, 1, 1);\nS( 2, 2, 0);\n#elif KERNEL_SIZE_SQUARED == 49\nS(-3,-3, 48);\nS(-3,-2, 47);\nS(-3,-1, 46);\nS(-3, 0, 45);\nS(-3, 1, 44);\nS(-3, 2, 43);\nS(-3, 3, 42);\nS(-2,-3, 41);\nS(-2,-2, 40);\nS(-2,-1, 39);\nS(-2, 0, 38);\nS(-2, 1, 37);\nS(-2, 2, 36);\nS(-2, 3, 35);\nS(-1,-3, 34);\nS(-1,-2, 33);\nS(-1,-1, 32);\nS(-1, 0, 31);\nS(-1, 1, 30);\nS(-1, 2, 29);\nS(-1, 3, 28);\nS( 0,-3, 27);\nS( 0,-2, 26);\nS( 0,-1, 25);\nS( 0, 0, 24);\nS( 0, 1, 23);\nS( 0, 2, 22);\nS( 0, 3, 21);\nS( 1,-3, 20);\nS( 1,-2, 19);\nS( 1,-1, 18);\nS( 1, 0, 17);\nS( 1, 1, 16);\nS( 1, 2, 15);\nS( 1, 3, 14);\nS( 2,-3, 13);\nS( 2,-2, 12);\nS( 2,-1, 11);\nS( 2, 0, 10);\nS( 2, 1, 9);\nS( 2, 2, 8);\nS( 2, 3, 7);\nS( 3,-3, 6);\nS( 3,-2, 5);\nS( 3,-1, 4);\nS( 3, 0, 3);\nS( 3, 1, 2);\nS( 3, 2, 1);\nS( 3, 3, 0);\n#else\n#error Invalid KERNEL_SIZE_SQUARED\n#endif\ncolor = vec4(result.rgb, 1.0f);\n}"},function(e,t){e.exports="uniform sampler2D image;\n#define X(i,j) t = vec2(min(p[i], p[j]), max(p[i], p[j])); p[i] = t.x; p[j] = t.y;\n#define S(i,x,y) p[i] = pixelAtShortOffset(image, ivec2((x),(y))).g\nvoid main()\n{\nfloat median;\nvec2 t;\n#if !defined(KERNEL_SIZE)\n#error Must define KERNEL_SIZE\n#elif KERNEL_SIZE == 3\nfloat p[9];\nS(0,-1,-1);\nS(1, 0,-1);\nS(2, 1,-1);\nS(3,-1, 0);\nS(4, 0, 0);\nS(5, 1, 0);\nS(6,-1, 1);\nS(7, 0, 1);\nS(8, 1, 1);\nX(1,2);X(4,5);X(7,8);X(0,1);X(3,4);X(6,7);X(1,2);X(4,5);X(7,8);X(0,3);X(5,8);X(4,7);X(3,6);X(1,4);X(2,5);X(4,7);X(4,2);X(6,4);X(4,2);\nmedian = p[4];\n#elif KERNEL_SIZE == 5\nfloat p[25];\nS( 0,-2,-2);\nS( 1,-1,-2);\nS( 2, 0,-2);\nS( 3, 1,-2);\nS( 4, 2,-2);\nS( 5,-2,-1);\nS( 6,-1,-1);\nS( 7, 0,-1);\nS( 8, 1,-1);\nS( 9, 2,-1);\nS(10,-2, 0);\nS(11,-1, 0);\nS(12, 0, 0);\nS(13, 1, 0);\nS(14, 2, 0);\nS(15,-2, 1);\nS(16,-1, 1);\nS(17, 0, 1);\nS(18, 1, 1);\nS(19, 2, 1);\nS(20,-2, 2);\nS(21,-1, 2);\nS(22, 0, 2);\nS(23, 1, 2);\nS(24, 2, 2);\nX(0,1);X(3,4);X(2,4);X(2,3);X(6,7);X(5,7);X(5,6);X(9,10);X(8,10);X(8,9);X(12,13);X(11,13);X(11,12);X(15,16);X(14,16);X(14,15);X(18,19);X(17,19);X(17,18);X(21,22);X(20,22);X(20,21);X(23,24);X(2,5);X(3,6);X(0,6);X(0,3);X(4,7);X(1,7);X(1,4);X(11,14);X(8,14);X(8,11);X(12,15);X(9,15);X(9,12);X(13,16);X(10,16);X(10,13);X(20,23);X(17,23);X(17,20);X(21,24);X(18,24);X(18,21);X(19,22);X(8,17);X(9,18);X(0,18);X(0,9);X(10,19);X(1,19);X(1,10);X(11,20);X(2,20);X(2,11);X(12,21);X(3,21);X(3,12);X(13,22);X(4,22);X(4,13);X(14,23);X(5,23);X(5,14);X(15,24);X(6,24);X(6,15);X(7,16);X(7,19);X(13,21);X(15,23);X(7,13);X(7,15);X(1,9);X(3,11);X(5,17);X(11,17);X(9,17);X(4,10);X(6,12);X(7,14);X(4,6);X(4,7);X(12,14);X(10,14);X(6,7);X(10,12);X(6,10);X(6,17);X(12,17);X(7,17);X(7,10);X(12,18);X(7,12);X(10,18);X(12,20);X(10,20);X(10,12);\nmedian = p[12];\n#elif KERNEL_SIZE == 7\nfloat p[49];\nS( 0,-3,-3);\nS( 1,-2,-3);\nS( 2,-1,-3);\nS( 3, 0,-3);\nS( 4, 1,-3);\nS( 5, 2,-3);\nS( 6, 3,-3);\nS( 7,-3,-2);\nS( 8,-2,-2);\nS( 9,-1,-2);\nS(10, 0,-2);\nS(11, 1,-2);\nS(12, 2,-2);\nS(13, 3,-2);\nS(14,-3,-1);\nS(15,-2,-1);\nS(16,-1,-1);\nS(17, 0,-1);\nS(18, 1,-1);\nS(19, 2,-1);\nS(20, 3,-1);\nS(21,-3, 0);\nS(22,-2, 0);\nS(23,-1, 0);\nS(24, 0, 0);\nS(25, 1, 0);\nS(26, 2, 0);\nS(27, 3, 0);\nS(28,-3, 1);\nS(29,-2, 1);\nS(30,-1, 1);\nS(31, 0, 1);\nS(32, 1, 1);\nS(33, 2, 1);\nS(34, 3, 1);\nS(35,-3, 2);\nS(36,-2, 2);\nS(37,-1, 2);\nS(38, 0, 2);\nS(39, 1, 2);\nS(40, 2, 2);\nS(41, 3, 2);\nS(42,-3, 3);\nS(43,-2, 3);\nS(44,-1, 3);\nS(45, 0, 3);\nS(46, 1, 3);\nS(47, 2, 3);\nS(48, 3, 3);\nX(0,1);X(2,3);X(0,2);X(1,3);X(1,2);X(4,5);X(6,7);X(4,6);X(5,7);X(5,6);X(0,4);X(2,6);X(2,4);X(1,5);X(3,7);X(3,5);X(1,2);X(3,4);X(5,6);X(8,9);X(10,11);X(8,10);X(9,11);X(9,10);X(12,13);X(14,15);X(12,14);X(13,15);X(13,14);X(8,12);X(10,14);X(10,12);X(9,13);X(11,15);X(11,13);X(9,10);X(11,12);X(13,14);X(0,8);X(4,12);X(4,8);X(2,10);X(6,14);X(6,10);X(2,4);X(6,8);X(10,12);X(1,9);X(5,13);X(5,9);X(3,11);X(7,15);X(7,11);X(3,5);X(7,9);X(11,13);X(1,2);X(3,4);X(5,6);X(7,8);X(9,10);X(11,12);X(13,14);X(16,17);X(18,19);X(16,18);X(17,19);X(17,18);X(20,21);X(22,23);X(20,22);X(21,23);X(21,22);X(16,20);X(18,22);X(18,20);X(17,21);X(19,23);X(19,21);X(17,18);X(19,20);X(21,22);X(24,25);X(26,27);X(24,26);X(25,27);X(25,26);X(28,29);X(30,31);X(28,30);X(29,31);X(29,30);X(24,28);X(26,30);X(26,28);X(25,29);X(27,31);X(27,29);X(25,26);X(27,28);X(29,30);X(16,24);X(20,28);X(20,24);X(18,26);X(22,30);X(22,26);X(18,20);X(22,24);X(26,28);X(17,25);X(21,29);X(21,25);X(19,27);X(23,31);X(23,27);X(19,21);X(23,25);X(27,29);X(17,18);X(19,20);X(21,22);X(23,24);X(25,26);X(27,28);X(29,30);X(0,16);X(8,24);X(8,16);X(4,20);X(12,28);X(12,20);X(4,8);X(12,16);X(20,24);X(2,18);X(10,26);X(10,18);X(6,22);X(14,30);X(14,22);X(6,10);X(14,18);X(22,26);X(2,4);X(6,8);X(10,12);X(14,16);X(18,20);X(22,24);X(26,28);X(1,17);X(9,25);X(9,17);X(5,21);X(13,29);X(13,21);X(5,9);X(13,17);X(21,25);X(3,19);X(11,27);X(11,19);X(7,23);X(15,31);X(15,23);X(7,11);X(15,19);X(23,27);X(3,5);X(7,9);X(11,13);X(15,17);X(19,21);X(23,25);X(27,29);X(1,2);X(3,4);X(5,6);X(7,8);X(9,10);X(11,12);X(13,14);X(15,16);X(17,18);X(19,20);X(21,22);X(23,24);X(25,26);X(27,28);X(29,30);X(32,33);X(34,35);X(32,34);X(33,35);X(33,34);X(36,37);X(38,39);X(36,38);X(37,39);X(37,38);X(32,36);X(34,38);X(34,36);X(33,37);X(35,39);X(35,37);X(33,34);X(35,36);X(37,38);X(40,41);X(42,43);X(40,42);X(41,43);X(41,42);X(44,45);X(46,47);X(44,46);X(45,47);X(45,46);X(40,44);X(42,46);X(42,44);X(41,45);X(43,47);X(43,45);X(41,42);X(43,44);X(45,46);X(32,40);X(36,44);X(36,40);X(34,42);X(38,46);X(38,42);X(34,36);X(38,40);X(42,44);X(33,41);X(37,45);X(37,41);X(35,43);X(39,47);X(39,43);X(35,37);X(39,41);X(43,45);X(33,34);X(35,36);X(37,38);X(39,40);X(41,42);X(43,44);X(45,46);X(32,48);X(40,48);X(36,40);X(44,48);X(38,42);X(34,36);X(38,40);X(42,44);X(46,48);X(37,41);X(39,43);X(35,37);X(39,41);X(43,45);X(33,34);X(35,36);X(37,38);X(39,40);X(41,42);X(43,44);X(45,46);X(47,48);X(0,32);X(16,48);X(16,32);X(8,40);X(24,40);X(8,16);X(24,32);X(40,48);X(4,36);X(20,36);X(12,44);X(28,44);X(12,20);X(28,36);X(4,8);X(12,16);X(20,24);X(28,32);X(36,40);X(44,48);X(2,34);X(18,34);X(10,42);X(26,42);X(10,18);X(26,34);X(6,38);X(22,38);X(14,46);X(30,46);X(14,22);X(30,38);X(6,10);X(14,18);X(22,26);X(30,34);X(38,42);X(2,4);X(6,8);X(10,12);X(14,16);X(18,20);X(22,24);X(26,28);X(30,32);X(34,36);X(38,40);X(42,44);X(46,48);X(1,33);X(17,33);X(9,41);X(25,41);X(9,17);X(25,33);X(5,37);X(21,37);X(13,45);X(29,45);X(13,21);X(29,37);X(5,9);X(13,17);X(21,25);X(29,33);X(37,41);X(3,35);X(19,35);X(11,43);X(27,43);X(11,19);X(27,35);X(7,39);X(23,39);X(15,47);X(31,47);X(15,23);X(31,39);X(7,11);X(15,19);X(23,27);X(31,35);X(39,43);X(3,5);X(7,9);X(11,13);X(15,17);X(19,21);X(23,25);X(27,29);X(31,33);X(35,37);X(39,41);X(43,45);X(1,2);X(3,4);X(5,6);X(7,8);X(9,10);X(11,12);X(13,14);X(15,16);X(17,18);X(19,20);X(21,22);X(23,24);\nmedian = p[24];\n#else\n#error Unsupported kernel size\n#endif\ncolor = vec4(median, median, median, 1.0f);\n}"},function(e,t){e.exports="uniform sampler2D image, layerA, layerB;\nuniform float scaleA, scaleB, lgM, h;\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nfloat score = pixel.r;\nivec2 zero = ivec2(0, 0);\nivec2 sizeA = textureSize(layerA, 0);\nivec2 sizeB = textureSize(layerB, 0);\nvec2 mid = (texCoord * texSize) + vec2(0.5f, 0.5f);\nivec2 pa = clamp(ivec2(ceil(mid * scaleA - 1.0f)), zero, sizeA - 2);\nivec2 pb = clamp(ivec2(ceil(mid * scaleB - 1.0f)), zero, sizeB - 2);\nvec4 a00 = pixelAt(layerA, pa);\nvec4 a10 = pixelAt(layerA, pa + ivec2(1, 0));\nvec4 a01 = pixelAt(layerA, pa + ivec2(0, 1));\nvec4 a11 = pixelAt(layerA, pa + ivec2(1, 1));\nvec4 b00 = pixelAt(layerB, pb);\nvec4 b10 = pixelAt(layerB, pb + ivec2(1, 0));\nvec4 b01 = pixelAt(layerB, pb + ivec2(0, 1));\nvec4 b11 = pixelAt(layerB, pb + ivec2(1, 1));\nfloat maxScore = max(\nmax(max(a00.r, a10.r), max(a01.r, a11.r)),\nmax(max(b00.r, b10.r), max(b01.r, b11.r))\n);\ncolor = vec4(0.0f, pixel.gba);\nif(score < maxScore || score == 0.0f)\nreturn;\nvec2 ea = fract(mid * scaleA);\nvec2 eb = fract(mid * scaleB);\nfloat isa = a00.b * (1.0f - ea.x) * (1.0f - ea.y) +\na10.b * ea.x * (1.0f - ea.y) +\na01.b * (1.0f - ea.x) * ea.y +\na11.b * ea.x * ea.y;\nfloat isb = b00.b * (1.0f - eb.x) * (1.0f - eb.y) +\nb10.b * eb.x * (1.0f - eb.y) +\nb01.b * (1.0f - eb.x) * eb.y +\nb11.b * eb.x * eb.y;\ncolor = (isa > score && isa > isb) ? vec4(isa, pixel.gb, a00.a) : pixel;\ncolor = (isb > score && isb > isa) ? vec4(isb, pixel.gb, b00.a) : pixel;\nfloat y1 = isa, y2 = isb, y3 = score;\nfloat x1 = lgM - (lgM + h) * a00.a;\nfloat x2 = lgM - (lgM + h) * b00.a;\nfloat x3 = lgM - (lgM + h) * pixel.a;\nfloat dn = (x1 - x2) * (x1 - x3) * (x2 - x3);\nif(abs(dn) < 0.00001f)\nreturn;\nfloat a = (x3 * (y2 - y1) + x2 * (y1 - y3) + x1 * (y3 - y2)) / dn;\nif(a >= 0.0f)\nreturn;\nfloat b = (x3 * x3 * (y1 - y2) + x2 * x2 * (y3 - y1) + x1 * x1 * (y2 - y3)) / dn;\nfloat c = (x2 * x3 * (x2 - x3) * y1 + x3 * x1 * (x3 - x1) * y2 + x1 * x2 * (x1 - x2) * y3) / dn;\nfloat xv = -b / (2.0f * a);\nfloat yv = c - (b * b) / (4.0f * a);\nif(xv < min(x1, min(x2, x3)) || xv > max(x1, max(x2, x3)))\nreturn;\nfloat interpolatedScale = (lgM - xv) / (lgM + h);\nfloat interpolatedScore = clamp(yv, 0.0f, 1.0f);\ncolor = vec4(interpolatedScore, pixel.gb, interpolatedScale);\n}"},function(e,t){e.exports='@include "keypoints.glsl"\nuniform sampler2D encodedKeypoints;\nuniform int inputDescriptorSize;\nuniform int inputExtraSize;\nuniform int inputEncoderLength;\nuniform int outputDescriptorSize;\nuniform int outputExtraSize;\nuniform int outputEncoderLength;\nvoid main()\n{\nvec4 pixel = threadPixel(encodedKeypoints);\nivec2 thread = threadLocation();\nKeypointAddress myAddress = findKeypointAddress(\nthread,\noutputEncoderLength,\noutputDescriptorSize,\noutputExtraSize\n);\nint myIndex = findKeypointIndex(\nmyAddress,\noutputDescriptorSize,\noutputExtraSize\n);\nint pixelsPerKeypoint = sizeofEncodedKeypoint(inputDescriptorSize, inputExtraSize) / 4;\nKeypointAddress otherAddress = KeypointAddress(\nmyIndex * pixelsPerKeypoint,\nmyAddress.offset\n);\nbool head = myAddress.offset < MIN_KEYPOINT_SIZE / 4;\nvec4 data = head ? readKeypointData(encodedKeypoints, inputEncoderLength, otherAddress) : vec4(0.0f);\nbool drop = outputDescriptorSize < inputDescriptorSize || outputExtraSize < inputExtraSize;\ncolor = drop ? encodeNullKeypoint() : data;\n}'},function(e,t){e.exports='@include "pyramids.glsl"\n@include "float16.glsl"\nuniform sampler2D corners;\nuniform sampler2D pyramid;\nuniform float lod;\nuniform int threshold;\n#define PIX(x,y) pyrPixelAtOffset(pyramid, lod, pot, ivec2((x),(y))).g\nvoid main()\n{\nfloat pixel = threadPixel(pyramid).g;\nvec4 prev = threadPixel(corners);\nivec2 thread = threadLocation();\nivec2 size = outputSize();\nfloat pot = exp2(lod);\nfloat t = float(clamp(threshold, 0, 255)) / 255.0f;\nfloat ct = pixel + t, c_t = pixel - t;\ncolor = vec4(prev.r, pixel, prev.ba);\n#if !defined(FAST_TYPE)\n#error Must define FAST_TYPE\n#elif FAST_TYPE == 916\nconst ivec4 margin = ivec4(3, 3, 4, 4);\nif(any(lessThan(ivec4(thread, size - thread), margin)))\nreturn;\nfloat p0 = PIX(0,3), p4 = PIX(3,0), p8 = PIX(0,-3), p12 = PIX(-3,0);\nbvec4 brighter = bvec4(p0 > ct, p4 > ct, p8 > ct, p12 > ct);\nbvec4 darker = bvec4(p0 < c_t, p4 < c_t, p8 < c_t, p12 < c_t);\nbvec4 bpairs = bvec4(all(brighter.xy), all(brighter.yz), all(brighter.zw), all(brighter.wx));\nbvec4 dpairs = bvec4(all(darker.xy), all(darker.yz), all(darker.zw), all(darker.wx));\nif(!(any(bpairs) || any(dpairs)))\nreturn;\nfloat p1 = PIX(1,3), p2 = PIX(2,2), p3 = PIX(3,1);\nfloat p5 = PIX(3,-1), p6 = PIX(2,-2), p7 = PIX(1,-3);\nfloat p9 = PIX(-1,-3), p10 = PIX(-2,-2), p11 = PIX(-3,-1);\nfloat p13 = PIX(-3,1), p14 = PIX(-2,2), p15 = PIX(-1,3);\nbool A=(p0>ct),B=(p1>ct),C=(p2>ct),D=(p3>ct),E=(p4>ct),F=(p5>ct),G=(p6>ct),H=(p7>ct),I=(p8>ct),J=(p9>ct),K=(p10>ct),L=(p11>ct),M=(p12>ct),N=(p13>ct),O=(p14>ct),P=(p15>ct),a=(p0<c_t),b=(p1<c_t),c=(p2<c_t),d=(p3<c_t),e=(p4<c_t),f=(p5<c_t),g=(p6<c_t),h=(p7<c_t),i=(p8<c_t),j=(p9<c_t),k=(p10<c_t),l=(p11<c_t),m=(p12<c_t),n=(p13<c_t),o=(p14<c_t),p=(p15<c_t);\nbool isCorner=A&&(B&&(K&&L&&J&&(M&&N&&O&&P||G&&H&&I&&(M&&N&&O||F&&(M&&N||E&&(M||D))))||C&&(K&&L&&M&&(N&&O&&P||G&&H&&I&&J&&(N&&O||F&&(N||E)))||D&&(N&&(L&&M&&(K&&G&&H&&I&&J&&(O||F)||O&&P)||k&&l&&m&&e&&f&&g&&h&&i&&j)||E&&(O&&(M&&N&&(K&&L&&G&&H&&I&&J||P)||k&&l&&m&&n&&f&&g&&h&&i&&j)||F&&(P&&(N&&O||k&&l&&m&&n&&o&&g&&h&&i&&j)||G&&(O&&P||H&&(P||I)||k&&l&&m&&n&&o&&p&&h&&i&&j)||k&&l&&m&&n&&o&&h&&i&&j&&(p||g))||k&&l&&m&&n&&h&&i&&j&&(o&&(p||g)||f&&(o&&p||g)))||k&&l&&m&&h&&i&&j&&(n&&(o&&p||g&&(o||f))||e&&(n&&o&&p||g&&(n&&o||f))))||k&&l&&h&&i&&j&&(m&&(n&&o&&p||g&&(n&&o||f&&(n||e)))||d&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e)))))||k&&h&&i&&j&&(l&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d))))))||K&&I&&J&&(L&&M&&N&&O&&P||G&&H&&(L&&M&&N&&O||F&&(L&&M&&N||E&&(L&&M||D&&(L||C)))))||h&&i&&j&&(b&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c)))))||k&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c)))))))||B&&(H&&I&&J&&(K&&L&&M&&N&&O&&P&&a||G&&(K&&L&&M&&N&&O&&a||F&&(K&&L&&M&&N&&a||E&&(K&&L&&M&&a||D&&(K&&L&&a||C)))))||a&&k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||C&&(K&&H&&I&&J&&(L&&M&&N&&O&&P&&a&&b||G&&(L&&M&&N&&O&&a&&b||F&&(L&&M&&N&&a&&b||E&&(L&&M&&a&&b||D))))||a&&b&&k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d)))))||D&&(K&&L&&H&&I&&J&&(M&&N&&O&&P&&a&&b&&c||G&&(M&&N&&O&&a&&b&&c||F&&(M&&N&&a&&b&&c||E)))||a&&b&&k&&l&&m&&c&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e))))||E&&(K&&L&&M&&H&&I&&J&&(N&&O&&P&&a&&b&&c&&d||G&&(N&&O&&a&&b&&c&&d||F))||a&&b&&l&&m&&n&&c&&d&&(k&&g&&h&&i&&j&&(o||f)||o&&p))||F&&(K&&L&&M&&N&&H&&I&&J&&(O&&P&&a&&b&&c&&d&&e||G)||a&&b&&m&&n&&o&&c&&d&&e&&(k&&l&&g&&h&&i&&j||p))||G&&(K&&L&&M&&N&&O&&H&&I&&J||a&&b&&n&&o&&p&&c&&d&&e&&f)||H&&(K&&L&&M&&N&&O&&P&&I&&J||a&&b&&o&&p&&c&&d&&e&&f&&g)||a&&(b&&(k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(k&&l&&m&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e)))||d&&(l&&m&&n&&(k&&g&&h&&i&&j&&(o||f)||o&&p)||e&&(m&&n&&o&&(k&&l&&g&&h&&i&&j||p)||f&&(n&&o&&p||g&&(o&&p||h&&(p||i)))))))||k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||h&&i&&j&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c&&(b||k))))));\nif(!isCorner)\nreturn;\nmat4 mp = mat4(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15);\nmat4 mct = mp - mat4(ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct,ct);\nmat4 mc_t = mat4(c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t,c_t) - mp;\nconst vec4 zeros = vec4(0.0f), ones = vec4(1.0f);\nvec4 bs = max(mct[0], zeros), ds = max(mc_t[0], zeros);\nbs += max(mct[1], zeros);     ds += max(mc_t[1], zeros);\nbs += max(mct[2], zeros);     ds += max(mc_t[2], zeros);\nbs += max(mct[3], zeros);     ds += max(mc_t[3], zeros);\nfloat thisScore = max(dot(bs, ones), dot(ds, ones)) / 16.0f;\nfloat prevScore = decodeFloat16(prev.rb);\nvec3 thisResult = vec3(encodeFloat16(thisScore), encodeLod(lod));\ncolor.rba = thisScore > prevScore ? thisResult : color.rba;\n#else\n#error Unrecognized FAST_TYPE\n#endif\n}'},function(e,t){e.exports='@include "float16.glsl"\nuniform sampler2D image;\nuniform float threshold;\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nfloat t = clamp(threshold, 0.0f, 1.0f);\nfloat ct = pixel.g + t, c_t = pixel.g - t;\nfloat p0 = pixelAtShortOffset(image, ivec2(0, 2)).g;\nfloat p1 = pixelAtShortOffset(image, ivec2(1, 2)).g;\nfloat p2 = pixelAtShortOffset(image, ivec2(2, 1)).g;\nfloat p3 = pixelAtShortOffset(image, ivec2(2, 0)).g;\nfloat p4 = pixelAtShortOffset(image, ivec2(2, -1)).g;\nfloat p5 = pixelAtShortOffset(image, ivec2(1, -2)).g;\nfloat p6 = pixelAtShortOffset(image, ivec2(0, -2)).g;\nfloat p7 = pixelAtShortOffset(image, ivec2(-1, -2)).g;\nfloat p8 = pixelAtShortOffset(image, ivec2(-2, -1)).g;\nfloat p9 = pixelAtShortOffset(image, ivec2(-2, 0)).g;\nfloat p10 = pixelAtShortOffset(image, ivec2(-2, 1)).g;\nfloat p11 = pixelAtShortOffset(image, ivec2(-1, 2)).g;\nvec2 scores = vec2(0.0f, 0.0f);\nscores += vec2(max(c_t - p0, 0.0f), max(p0 - ct, 0.0f));\nscores += vec2(max(c_t - p1, 0.0f), max(p1 - ct, 0.0f));\nscores += vec2(max(c_t - p2, 0.0f), max(p2 - ct, 0.0f));\nscores += vec2(max(c_t - p3, 0.0f), max(p3 - ct, 0.0f));\nscores += vec2(max(c_t - p4, 0.0f), max(p4 - ct, 0.0f));\nscores += vec2(max(c_t - p5, 0.0f), max(p5 - ct, 0.0f));\nscores += vec2(max(c_t - p6, 0.0f), max(p6 - ct, 0.0f));\nscores += vec2(max(c_t - p7, 0.0f), max(p7 - ct, 0.0f));\nscores += vec2(max(c_t - p8, 0.0f), max(p8 - ct, 0.0f));\nscores += vec2(max(c_t - p9, 0.0f), max(p9 - ct, 0.0f));\nscores += vec2(max(c_t - p10, 0.0f), max(p10 - ct, 0.0f));\nscores += vec2(max(c_t - p11, 0.0f), max(p11 - ct, 0.0f));\nscores /= 12.0f;\nfloat score = max(scores.x, scores.y) * step(1.0f, pixel.r);\ncolor = pixel;\ncolor.rb = encodeFloat16(score);\n}'},function(e,t){e.exports='@include "float16.glsl"\nuniform sampler2D image;\nuniform float threshold;\nconst vec4 zeroes = vec4(0.0f, 0.0f, 0.0f, 0.0f);\nconst vec4 ones = vec4(1.0f, 1.0f, 1.0f, 1.0f);\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nfloat t = clamp(threshold, 0.0f, 1.0f);\nfloat ct = pixel.g + t, c_t = pixel.g - t;\nmat4 mp = mat4(\npixelAtShortOffset(image, ivec2(0, 3)).g,\npixelAtShortOffset(image, ivec2(1, 3)).g,\npixelAtShortOffset(image, ivec2(2, 2)).g,\npixelAtShortOffset(image, ivec2(3, 1)).g,\npixelAtShortOffset(image, ivec2(3, 0)).g,\npixelAtShortOffset(image, ivec2(3, -1)).g,\npixelAtShortOffset(image, ivec2(2, -2)).g,\npixelAtShortOffset(image, ivec2(1, -3)).g,\npixelAtShortOffset(image, ivec2(0, -3)).g,\npixelAtShortOffset(image, ivec2(-1, -3)).g,\npixelAtShortOffset(image, ivec2(-2, -2)).g,\npixelAtShortOffset(image, ivec2(-3, -1)).g,\npixelAtShortOffset(image, ivec2(-3, 0)).g,\npixelAtShortOffset(image, ivec2(-3, 1)).g,\npixelAtShortOffset(image, ivec2(-2, 2)).g,\npixelAtShortOffset(image, ivec2(-1, 3)).g\n);\nmat4 mct = mp - mat4(\nct, ct, ct, ct,\nct, ct, ct, ct,\nct, ct, ct, ct,\nct, ct, ct, ct\n), mc_t = mat4(\nc_t, c_t, c_t, c_t,\nc_t, c_t, c_t, c_t,\nc_t, c_t, c_t, c_t,\nc_t, c_t, c_t, c_t\n) - mp;\nvec4 bs = max(mc_t[0], zeroes), ds = max(mct[0], zeroes);\nbs += max(mc_t[1], zeroes); ds += max(mct[1], zeroes);\nbs += max(mc_t[2], zeroes); ds += max(mct[2], zeroes);\nbs += max(mc_t[3], zeroes); ds += max(mct[3], zeroes);\nfloat score = max(dot(bs, ones), dot(ds, ones)) * step(1.0f, pixel.r);\nscore /= 16.0f;\ncolor = pixel;\ncolor.rb = encodeFloat16(score);\n}'},function(e,t){e.exports='@include "float16.glsl"\nuniform sampler2D image;\nuniform float threshold;\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nfloat t = clamp(threshold, 0.0f, 1.0f);\nfloat ct = pixel.g + t, c_t = pixel.g - t;\nfloat p0 = pixelAtShortOffset(image, ivec2(0, 1)).g;\nfloat p1 = pixelAtShortOffset(image, ivec2(1, 1)).g;\nfloat p2 = pixelAtShortOffset(image, ivec2(1, 0)).g;\nfloat p3 = pixelAtShortOffset(image, ivec2(1, -1)).g;\nfloat p4 = pixelAtShortOffset(image, ivec2(0, -1)).g;\nfloat p5 = pixelAtShortOffset(image, ivec2(-1, -1)).g;\nfloat p6 = pixelAtShortOffset(image, ivec2(-1, 0)).g;\nfloat p7 = pixelAtShortOffset(image, ivec2(-1, 1)).g;\nvec2 scores = vec2(0.0f, 0.0f);\nscores += vec2(max(c_t - p0, 0.0f), max(p0 - ct, 0.0f));\nscores += vec2(max(c_t - p1, 0.0f), max(p1 - ct, 0.0f));\nscores += vec2(max(c_t - p2, 0.0f), max(p2 - ct, 0.0f));\nscores += vec2(max(c_t - p3, 0.0f), max(p3 - ct, 0.0f));\nscores += vec2(max(c_t - p4, 0.0f), max(p4 - ct, 0.0f));\nscores += vec2(max(c_t - p5, 0.0f), max(p5 - ct, 0.0f));\nscores += vec2(max(c_t - p6, 0.0f), max(p6 - ct, 0.0f));\nscores += vec2(max(c_t - p7, 0.0f), max(p7 - ct, 0.0f));\nscores /= 8.0f;\nfloat score = max(scores.x, scores.y) * step(1.0f, pixel.r);\ncolor = pixel;\ncolor.rb = encodeFloat16(score);\n}'},function(e,t){e.exports='@include "pyramids.glsl"\nuniform sampler2D image;\nuniform float threshold;\nvoid main()\n{\nivec2 thread = threadLocation();\nivec2 size = outputSize();\nvec4 pixel = threadPixel(image);\ncolor = vec4(0.0f, pixel.g, 0.0f, encodeLod(0.0f));\nif(\nthread.x >= 3 && thread.x < size.x - 3 &&\nthread.y >= 3 && thread.y < size.y - 3\n) {\nfloat t = clamp(threshold, 0.0f, 1.0f);\nfloat c = pixel.g;\nfloat ct = c + t, c_t = c - t;\nfloat p0 = pixelAtShortOffset(image, ivec2(0, 1)).g;\nfloat p1 = pixelAtShortOffset(image, ivec2(1, 1)).g;\nfloat p2 = pixelAtShortOffset(image, ivec2(1, 0)).g;\nfloat p3 = pixelAtShortOffset(image, ivec2(1, -1)).g;\nfloat p4 = pixelAtShortOffset(image, ivec2(0, -1)).g;\nfloat p5 = pixelAtShortOffset(image, ivec2(-1, -1)).g;\nfloat p6 = pixelAtShortOffset(image, ivec2(-1, 0)).g;\nfloat p7 = pixelAtShortOffset(image, ivec2(-1, 1)).g;\nbool possibleCorner =\n((c_t > p1 || c_t > p5) && (c_t > p3 || c_t > p7)) ||\n((ct < p1  || ct < p5)  && (ct < p3  || ct < p7))  ;\nif(possibleCorner) {\nint bright = 0, dark = 0, bc = 0, dc = 0;\nif(c_t > p0) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p0) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p1) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p1) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p2) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p2) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p3) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p3) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p4) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p4) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p5) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p5) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p6) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p6) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p7) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p7) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(bright < 5 && dark < 5) {\nif(bc > 0 && bc < 5) do {\nif(c_t > p0)           bc += 1; else break;\nif(c_t > p1 && bc < 5) bc += 1; else break;\nif(c_t > p2 && bc < 5) bc += 1; else break;\nif(c_t > p3 && bc < 5) bc += 1; else break;\n} while(false);\nif(dc > 0 && dc < 5) do {\nif(ct < p0)           dc += 1; else break;\nif(ct < p1 && dc < 5) dc += 1; else break;\nif(ct < p2 && dc < 5) dc += 1; else break;\nif(ct < p3 && dc < 5) dc += 1; else break;\n} while(false);\nif(bc >= 5 || dc >= 5)\ncolor.r = 1.0f;\n}\nelse {\ncolor.r = 1.0f;\n}\n}\n}\n}'},function(e,t){e.exports='@include "pyramids.glsl"\nuniform sampler2D image;\nuniform float threshold;\nvoid main()\n{\nivec2 thread = threadLocation();\nivec2 size = outputSize();\nvec4 pixel = threadPixel(image);\ncolor = vec4(0.0f, pixel.g, 0.0f, encodeLod(0.0f));\nif(\nthread.x >= 3 && thread.x < size.x - 3 &&\nthread.y >= 3 && thread.y < size.y - 3\n) {\nfloat t = clamp(threshold, 0.0f, 1.0f);\nfloat c = pixel.g;\nfloat ct = c + t, c_t = c - t;\nfloat p0 = pixelAtShortOffset(image, ivec2(0, 2)).g;\nfloat p1 = pixelAtShortOffset(image, ivec2(1, 2)).g;\nfloat p2 = pixelAtShortOffset(image, ivec2(2, 1)).g;\nfloat p3 = pixelAtShortOffset(image, ivec2(2, 0)).g;\nfloat p4 = pixelAtShortOffset(image, ivec2(2, -1)).g;\nfloat p5 = pixelAtShortOffset(image, ivec2(1, -2)).g;\nfloat p6 = pixelAtShortOffset(image, ivec2(0, -2)).g;\nfloat p7 = pixelAtShortOffset(image, ivec2(-1, -2)).g;\nfloat p8 = pixelAtShortOffset(image, ivec2(-2, -1)).g;\nfloat p9 = pixelAtShortOffset(image, ivec2(-2, 0)).g;\nfloat p10 = pixelAtShortOffset(image, ivec2(-2, 1)).g;\nfloat p11 = pixelAtShortOffset(image, ivec2(-1, 2)).g;\nbool possibleCorner =\n((c_t > p0 || c_t > p6) && (c_t > p3 || c_t > p9)) ||\n((ct < p0  || ct < p6)  && (ct < p3  || ct < p9))  ;\nif(possibleCorner) {\nint bright = 0, dark = 0, bc = 0, dc = 0;\nif(c_t > p0) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p0) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p1) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p1) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p2) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p2) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p3) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p3) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p4) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p4) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p5) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p5) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p6) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p6) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p7) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p7) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p8) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p8) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p9) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p9) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p10) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p10) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(c_t > p11) { dc = 0; bc += 1; if(bc > bright) bright = bc; }\nelse { bc = 0; if(ct < p11) { dc += 1; if(dc > dark) dark = dc; } else dc = 0; }\nif(bright < 7 && dark < 7) {\nif(bc > 0 && bc < 7) do {\nif(c_t > p0)           bc += 1; else break;\nif(c_t > p1 && bc < 7) bc += 1; else break;\nif(c_t > p2 && bc < 7) bc += 1; else break;\nif(c_t > p3 && bc < 7) bc += 1; else break;\nif(c_t > p4 && bc < 7) bc += 1; else break;\nif(c_t > p5 && bc < 7) bc += 1; else break;\n} while(false);\nif(dc > 0 && dc < 7) do {\nif(ct < p0)           dc += 1; else break;\nif(ct < p1 && dc < 7) dc += 1; else break;\nif(ct < p2 && dc < 7) dc += 1; else break;\nif(ct < p3 && dc < 7) dc += 1; else break;\nif(ct < p4 && dc < 7) dc += 1; else break;\nif(ct < p5 && dc < 7) dc += 1; else break;\n} while(false);\nif(bc >= 7 || dc >= 7)\ncolor.r = 1.0f;\n}\nelse {\ncolor.r = 1.0f;\n}\n}\n}\n}'},function(e,t){e.exports='@include "pyramids.glsl"\nuniform sampler2D image;\nuniform float threshold;\nconst ivec4 margin = ivec4(3, 3, 4, 4);\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nivec2 thread = threadLocation();\nivec2 size = outputSize();\ncolor = vec4(0.0f, pixel.g, 0.0f, encodeLod(0.0f));\nif(any(lessThan(ivec4(thread, size - thread), margin)))\nreturn;\nfloat t = clamp(threshold, 0.0f, 1.0f);\nfloat ct = pixel.g + t, c_t = pixel.g - t;\nfloat p0 = pixelAtShortOffset(image, ivec2(0, 3)).g;\nfloat p4 = pixelAtShortOffset(image, ivec2(3, 0)).g;\nfloat p8 = pixelAtShortOffset(image, ivec2(0, -3)).g;\nfloat p12 = pixelAtShortOffset(image, ivec2(-3, 0)).g;\nif(!(\n((c_t > p0 || c_t > p8) && (c_t > p4 || c_t > p12)) ||\n((ct < p0  || ct < p8)  && (ct < p4  || ct < p12))\n))\nreturn;\nfloat p1 = pixelAtShortOffset(image, ivec2(1, 3)).g;\nfloat p2 = pixelAtShortOffset(image, ivec2(2, 2)).g;\nfloat p3 = pixelAtShortOffset(image, ivec2(3, 1)).g;\nfloat p5 = pixelAtShortOffset(image, ivec2(3, -1)).g;\nfloat p6 = pixelAtShortOffset(image, ivec2(2, -2)).g;\nfloat p7 = pixelAtShortOffset(image, ivec2(1, -3)).g;\nfloat p9 = pixelAtShortOffset(image, ivec2(-1, -3)).g;\nfloat p10 = pixelAtShortOffset(image, ivec2(-2, -2)).g;\nfloat p11 = pixelAtShortOffset(image, ivec2(-3, -1)).g;\nfloat p13 = pixelAtShortOffset(image, ivec2(-3, 1)).g;\nfloat p14 = pixelAtShortOffset(image, ivec2(-2, 2)).g;\nfloat p15 = pixelAtShortOffset(image, ivec2(-1, 3)).g;\nbool A=(p0>ct),B=(p1>ct),C=(p2>ct),D=(p3>ct),E=(p4>ct),F=(p5>ct),G=(p6>ct),H=(p7>ct),I=(p8>ct),J=(p9>ct),K=(p10>ct),L=(p11>ct),M=(p12>ct),N=(p13>ct),O=(p14>ct),P=(p15>ct),a=(p0<c_t),b=(p1<c_t),c=(p2<c_t),d=(p3<c_t),e=(p4<c_t),f=(p5<c_t),g=(p6<c_t),h=(p7<c_t),i=(p8<c_t),j=(p9<c_t),k=(p10<c_t),l=(p11<c_t),m=(p12<c_t),n=(p13<c_t),o=(p14<c_t),p=(p15<c_t);\nbool isCorner=A&&(B&&(K&&L&&J&&(M&&N&&O&&P||G&&H&&I&&(M&&N&&O||F&&(M&&N||E&&(M||D))))||C&&(K&&L&&M&&(N&&O&&P||G&&H&&I&&J&&(N&&O||F&&(N||E)))||D&&(N&&(L&&M&&(K&&G&&H&&I&&J&&(O||F)||O&&P)||k&&l&&m&&e&&f&&g&&h&&i&&j)||E&&(O&&(M&&N&&(K&&L&&G&&H&&I&&J||P)||k&&l&&m&&n&&f&&g&&h&&i&&j)||F&&(P&&(N&&O||k&&l&&m&&n&&o&&g&&h&&i&&j)||G&&(O&&P||H&&(P||I)||k&&l&&m&&n&&o&&p&&h&&i&&j)||k&&l&&m&&n&&o&&h&&i&&j&&(p||g))||k&&l&&m&&n&&h&&i&&j&&(o&&(p||g)||f&&(o&&p||g)))||k&&l&&m&&h&&i&&j&&(n&&(o&&p||g&&(o||f))||e&&(n&&o&&p||g&&(n&&o||f))))||k&&l&&h&&i&&j&&(m&&(n&&o&&p||g&&(n&&o||f&&(n||e)))||d&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e)))))||k&&h&&i&&j&&(l&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d))))))||K&&I&&J&&(L&&M&&N&&O&&P||G&&H&&(L&&M&&N&&O||F&&(L&&M&&N||E&&(L&&M||D&&(L||C)))))||h&&i&&j&&(b&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c)))))||k&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c)))))))||B&&(H&&I&&J&&(K&&L&&M&&N&&O&&P&&a||G&&(K&&L&&M&&N&&O&&a||F&&(K&&L&&M&&N&&a||E&&(K&&L&&M&&a||D&&(K&&L&&a||C)))))||a&&k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||C&&(K&&H&&I&&J&&(L&&M&&N&&O&&P&&a&&b||G&&(L&&M&&N&&O&&a&&b||F&&(L&&M&&N&&a&&b||E&&(L&&M&&a&&b||D))))||a&&b&&k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d)))))||D&&(K&&L&&H&&I&&J&&(M&&N&&O&&P&&a&&b&&c||G&&(M&&N&&O&&a&&b&&c||F&&(M&&N&&a&&b&&c||E)))||a&&b&&k&&l&&m&&c&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e))))||E&&(K&&L&&M&&H&&I&&J&&(N&&O&&P&&a&&b&&c&&d||G&&(N&&O&&a&&b&&c&&d||F))||a&&b&&l&&m&&n&&c&&d&&(k&&g&&h&&i&&j&&(o||f)||o&&p))||F&&(K&&L&&M&&N&&H&&I&&J&&(O&&P&&a&&b&&c&&d&&e||G)||a&&b&&m&&n&&o&&c&&d&&e&&(k&&l&&g&&h&&i&&j||p))||G&&(K&&L&&M&&N&&O&&H&&I&&J||a&&b&&n&&o&&p&&c&&d&&e&&f)||H&&(K&&L&&M&&N&&O&&P&&I&&J||a&&b&&o&&p&&c&&d&&e&&f&&g)||a&&(b&&(k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(k&&l&&m&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e)))||d&&(l&&m&&n&&(k&&g&&h&&i&&j&&(o||f)||o&&p)||e&&(m&&n&&o&&(k&&l&&g&&h&&i&&j||p)||f&&(n&&o&&p||g&&(o&&p||h&&(p||i)))))))||k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||h&&i&&j&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c&&(b||k))))));\ncolor.r = float(isCorner);\n}'},function(e,t){e.exports='@include "pyramids.glsl"\n@include "float16.glsl"\nuniform sampler2D pyramid;\nuniform float threshold;\nuniform int numberOfLayers;\nuniform float lodStep;\nconst ivec4 margin = ivec4(3, 3, 4, 4);\nconst vec4 zeroes = vec4(0.0f, 0.0f, 0.0f, 0.0f);\nconst vec4 ones = vec4(1.0f, 1.0f, 1.0f, 1.0f);\nvoid main()\n{\nvec4 pixel = threadPixel(pyramid);\nivec2 thread = threadLocation();\nivec2 size = outputSize();\nfloat t = clamp(threshold, 0.0f, 1.0f);\nfloat ct = pixel.g + t, c_t = pixel.g - t;\nvec2 best = vec2(0.0f);\ncolor = vec4(0.0f, pixel.g, 0.0f, pixel.a);\nfloat lod = 0.0f, pot = 1.0f;\nfor(int layer = 0; layer < numberOfLayers; layer++) {\npixel = pyrPixel(pyramid, lod);\nct = pixel.g + t;\nc_t = pixel.g - t;\nvec4 p4k = vec4(\npyrPixelAtOffset(pyramid, lod, pot, ivec2(0, 3)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(3, 0)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(0, -3)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-3, 0)).g\n);\nmat4 mp = mat4(\np4k.x,\np4k.y,\np4k.z,\np4k.w,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(1, 3)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(3, -1)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-1, -3)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-3, 1)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(2, 2)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(2, -2)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-2, -2)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-2, 2)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(3, 1)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(1, -3)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-3, -1)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-1, 3)).g\n);\nbool A=(mp[0][0]>ct),B=(mp[1][0]>ct),C=(mp[2][0]>ct),D=(mp[3][0]>ct),E=(mp[0][1]>ct),F=(mp[1][1]>ct),G=(mp[2][1]>ct),H=(mp[3][1]>ct),I=(mp[0][2]>ct),J=(mp[1][2]>ct),K=(mp[2][2]>ct),L=(mp[3][2]>ct),M=(mp[0][3]>ct),N=(mp[1][3]>ct),O=(mp[2][3]>ct),P=(mp[3][3]>ct),a=(mp[0][0]<c_t),b=(mp[1][0]<c_t),c=(mp[2][0]<c_t),d=(mp[3][0]<c_t),e=(mp[0][1]<c_t),f=(mp[1][1]<c_t),g=(mp[2][1]<c_t),h=(mp[3][1]<c_t),i=(mp[0][2]<c_t),j=(mp[1][2]<c_t),k=(mp[2][2]<c_t),l=(mp[3][2]<c_t),m=(mp[0][3]<c_t),n=(mp[1][3]<c_t),o=(mp[2][3]<c_t),p=(mp[3][3]<c_t);\nbool isCorner=A&&(B&&(K&&L&&J&&(M&&N&&O&&P||G&&H&&I&&(M&&N&&O||F&&(M&&N||E&&(M||D))))||C&&(K&&L&&M&&(N&&O&&P||G&&H&&I&&J&&(N&&O||F&&(N||E)))||D&&(N&&(L&&M&&(K&&G&&H&&I&&J&&(O||F)||O&&P)||k&&l&&m&&e&&f&&g&&h&&i&&j)||E&&(O&&(M&&N&&(K&&L&&G&&H&&I&&J||P)||k&&l&&m&&n&&f&&g&&h&&i&&j)||F&&(P&&(N&&O||k&&l&&m&&n&&o&&g&&h&&i&&j)||G&&(O&&P||H&&(P||I)||k&&l&&m&&n&&o&&p&&h&&i&&j)||k&&l&&m&&n&&o&&h&&i&&j&&(p||g))||k&&l&&m&&n&&h&&i&&j&&(o&&(p||g)||f&&(o&&p||g)))||k&&l&&m&&h&&i&&j&&(n&&(o&&p||g&&(o||f))||e&&(n&&o&&p||g&&(n&&o||f))))||k&&l&&h&&i&&j&&(m&&(n&&o&&p||g&&(n&&o||f&&(n||e)))||d&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e)))))||k&&h&&i&&j&&(l&&(m&&n&&o&&p||g&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d))))))||K&&I&&J&&(L&&M&&N&&O&&P||G&&H&&(L&&M&&N&&O||F&&(L&&M&&N||E&&(L&&M||D&&(L||C)))))||h&&i&&j&&(b&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c)))))||k&&(l&&m&&n&&o&&p||g&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c)))))))||B&&(H&&I&&J&&(K&&L&&M&&N&&O&&P&&a||G&&(K&&L&&M&&N&&O&&a||F&&(K&&L&&M&&N&&a||E&&(K&&L&&M&&a||D&&(K&&L&&a||C)))))||a&&k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||C&&(K&&H&&I&&J&&(L&&M&&N&&O&&P&&a&&b||G&&(L&&M&&N&&O&&a&&b||F&&(L&&M&&N&&a&&b||E&&(L&&M&&a&&b||D))))||a&&b&&k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d)))))||D&&(K&&L&&H&&I&&J&&(M&&N&&O&&P&&a&&b&&c||G&&(M&&N&&O&&a&&b&&c||F&&(M&&N&&a&&b&&c||E)))||a&&b&&k&&l&&m&&c&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e))))||E&&(K&&L&&M&&H&&I&&J&&(N&&O&&P&&a&&b&&c&&d||G&&(N&&O&&a&&b&&c&&d||F))||a&&b&&l&&m&&n&&c&&d&&(k&&g&&h&&i&&j&&(o||f)||o&&p))||F&&(K&&L&&M&&N&&H&&I&&J&&(O&&P&&a&&b&&c&&d&&e||G)||a&&b&&m&&n&&o&&c&&d&&e&&(k&&l&&g&&h&&i&&j||p))||G&&(K&&L&&M&&N&&O&&H&&I&&J||a&&b&&n&&o&&p&&c&&d&&e&&f)||H&&(K&&L&&M&&N&&O&&P&&I&&J||a&&b&&o&&p&&c&&d&&e&&f&&g)||a&&(b&&(k&&l&&j&&(m&&n&&o&&p||g&&h&&i&&(m&&n&&o||f&&(m&&n||e&&(m||d))))||c&&(k&&l&&m&&(n&&o&&p||g&&h&&i&&j&&(n&&o||f&&(n||e)))||d&&(l&&m&&n&&(k&&g&&h&&i&&j&&(o||f)||o&&p)||e&&(m&&n&&o&&(k&&l&&g&&h&&i&&j||p)||f&&(n&&o&&p||g&&(o&&p||h&&(p||i)))))))||k&&i&&j&&(l&&m&&n&&o&&p||g&&h&&(l&&m&&n&&o||f&&(l&&m&&n||e&&(l&&m||d&&(l||c))))))||h&&i&&j&&(k&&l&&m&&n&&o&&p||g&&(k&&l&&m&&n&&o||f&&(k&&l&&m&&n||e&&(k&&l&&m||d&&(k&&l||c&&(b||k))))));\nmat4 mct = mp - mat4(\nct, ct, ct, ct,\nct, ct, ct, ct,\nct, ct, ct, ct,\nct, ct, ct, ct\n), mc_t = mat4(\nc_t, c_t, c_t, c_t,\nc_t, c_t, c_t, c_t,\nc_t, c_t, c_t, c_t,\nc_t, c_t, c_t, c_t\n) - mp;\nvec4 bs = max(mc_t[0], zeroes), ds = max(mct[0], zeroes);\nbs += max(mc_t[1], zeroes); ds += max(mct[1], zeroes);\nbs += max(mc_t[2], zeroes); ds += max(mct[2], zeroes);\nbs += max(mc_t[3], zeroes); ds += max(mct[3], zeroes);\nfloat score = max(dot(bs, ones), dot(ds, ones)) / 16.0f;\nscore *= float(isCorner);\nbest = (score > best.x) ? vec2(score, lod) : best;\nlod += lodStep;\npot = exp2(lod);\n}\ncolor.rb = encodeFloat16(best.x);\ncolor.a = encodeLod(best.y);\n}'},function(e,t){e.exports='@include "float16.glsl"\nuniform sampler2D corners;\nuniform sampler2D maxScore;\nuniform float quality;\nvoid main()\n{\nvec4 pixel = threadPixel(corners);\nfloat score = decodeFloat16(pixel.rb);\nfloat maxval = decodeFloat16(threadPixel(maxScore).rb);\nfloat threshold = maxval * clamp(quality, 0.0f, 1.0f);\ncolor = pixel;\ncolor.rb = score >= threshold ? color.rb : encodeFloat16(0.0f);\n}'},function(e,t){e.exports='@include "pyramids.glsl"\n@include "float16.glsl"\nuniform sampler2D pyramid;\nuniform float lod;\nconst mat3 hkern = mat3(\n1.0f, 0.0f,-1.0f,\n2.0f, 0.0f,-2.0f,\n1.0f, 0.0f,-1.0f\n), vkern = mat3(\n1.0f, 2.0f, 1.0f,\n0.0f, 0.0f, 0.0f,\n-1.0f,-2.0f,-1.0f\n);\n#define PIX(x,y) pyrPixelAtOffset(pyramid, lod, pot, ivec2((x),(y))).g\nconst vec3 ones = vec3(1.0f);\nvoid main()\n{\nfloat pot = exp2(lod);\nmat3 win = mat3(\nPIX(-1,-1), PIX(0,-1), PIX(1,-1),\nPIX(-1,0), PIX(0,0), PIX(1,0),\nPIX(-1,1), PIX(0,1), PIX(1,1)\n);\nmat3 dx = matrixCompMult(hkern, win);\nmat3 dy = matrixCompMult(vkern, win);\nvec2 df = vec2(\ndot(dx[0] + dx[1] + dx[2], ones),\ndot(dy[0] + dy[1] + dy[2], ones)\n);\ncolor = vec4(encodeFloat16(df.x), encodeFloat16(df.y));\n}'},function(e,t){e.exports='@include "pyramids.glsl"\n@include "float16.glsl"\nuniform sampler2D corners;\nuniform sampler2D derivatives;\nuniform float lod;\n#define H(ox,oy) dpix = pixelAtShortOffset(derivatives, ivec2((ox),(oy))); \\\ndf = vec2(decodeFloat16(dpix.xy), decodeFloat16(dpix.zw)); \\\nh += vec3(df.x * df.x, df.x * df.y, df.y * df.y)\nvoid main()\n{\nvec4 pixel = threadPixel(corners);\nvec4 dpix = vec4(0.0f);\nvec2 df = vec2(0.0f);\nvec3 h = vec3(0.0f);\ncolor = pixel;\n#if !defined(WINDOW_SIZE)\n#error Must define WINDOW_SIZE\n#elif WINDOW_SIZE == 1\nH(0,0);\n#elif WINDOW_SIZE == 3\nH(-1,-1); H(0,-1); H(1,-1);\nH(-1,0); H(0,0); H(1,0);\nH(-1,1); H(0,1); H(1,1);\n#elif WINDOW_SIZE == 5\nH(-2,-2); H(-1,-2); H(0,-2); H(1,-2); H(2,-2);\nH(-2,-1); H(-1,-1); H(0,-1); H(1,-1); H(2,-1);\nH(-2,0); H(-1,0); H(0,0); H(1,0); H(2,0);\nH(-2,1); H(-1,1); H(0,1); H(1,1); H(2,1);\nH(-2,2); H(-1,2); H(0,2); H(1,2); H(2,2);\n#elif WINDOW_SIZE == 7\nH(-3,-3); H(-2,-3); H(-1,-3); H(0,-3); H(1,-3); H(2,-3); H(3,-3);\nH(-3,-2); H(-2,-2); H(-1,-2); H(0,-2); H(1,-2); H(2,-2); H(3,-2);\nH(-3,-1); H(-2,-1); H(-1,-1); H(0,-1); H(1,-1); H(2,-1); H(3,-1);\nH(-3,0); H(-2,0); H(-1,0); H(0,0); H(1,0); H(2,0); H(3,0);\nH(-3,1); H(-2,1); H(-1,1); H(0,1); H(1,1); H(2,1); H(3,1);\nH(-3,2); H(-2,2); H(-1,2); H(0,2); H(1,2); H(2,2); H(3,2);\nH(-3,3); H(-2,3); H(-1,3); H(0,3); H(1,3); H(2,3); H(3,3);\n#else\n#error Invalid WINDOW_SIZE\n#endif\nfloat response = 0.5f * (h.x + h.z - sqrt((h.x - h.z) * (h.x - h.z) + 4.0f * h.y * h.y));\nvec3 result = vec3(encodeFloat16(response), encodeLod(lod));\nfloat prevResponse = decodeFloat16(pixel.rb);\ncolor.rba = response > prevResponse ? result : pixel.rba;\n}'},function(e,t){e.exports='@include "float16.glsl"\nuniform sampler2D image;\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nfloat score = decodeFloat16(pixel.rb);\nfloat score8 = 1.0f - exp2(-score);\ncolor = vec4(score8, pixel.g, 0.0f, pixel.a);\n}'},function(e,t){e.exports='@include "sobel.glsl"\n@include "pyramids.glsl"\n@include "float16.glsl"\n#if !defined(MAX_LAYERS) || MAX_LAYERS < 7 || MAX_LAYERS > 16 || MAX_LAYERS % 2 == 0\n#error Invalid MAX_LAYERS\n#endif\nuniform sampler2D pyramid;\nuniform int windowSize;\nuniform int numberOfLayers;\nuniform float lodStep;\nuniform sampler2D sobelDerivatives[@MAX_LAYERS@];\nvec4 pickSobelDerivatives(int index, ivec2 offset)\n{\n#define CASE(k) case k: return textureLod(sobelDerivatives[k], texCoord + vec2(offset) / texSize, 0.0f)\nswitch(index) {\n#if MAX_LAYERS > 15\nCASE(15);\n#elif MAX_LAYERS > 13\nCASE(14); CASE(13);\n#elif MAX_LAYERS > 11\nCASE(12); CASE(11);\n#elif MAX_LAYERS > 9\nCASE(10); CASE(9);\n#elif MAX_LAYERS > 7\nCASE(8); CASE(7);\n#endif\nCASE(6); CASE(5); CASE(4); CASE(3); CASE(2); CASE(1); CASE(0);\ndefault: return vec4(0.0f);\n}\n}\nvoid main()\n{\nivec2 thread = threadLocation();\nvec4 pixel = threadPixel(pyramid);\nint r = (windowSize - 1) / 2;\nfloat windowArea = float(windowSize * windowSize);\nvec2 tmp = vec2(0.0f);\nfor(int layer = 0; layer < numberOfLayers; layer++) {\nvec3 m = vec3(0.0f); vec2 df;\nfor(int j = 0; j < windowSize; j++) {\nfor(int i = 0; i < windowSize; i++) {\ndf = decodeSobel(pickSobelDerivatives(layer, ivec2(i-r, j-r)));\nm += vec3(df.x * df.x, df.x * df.y, df.y * df.y);\n}\n}\nfloat response = 0.5f * (m.x + m.z - sqrt((m.x - m.z) * (m.x - m.z) + 4.0f * m.y * m.y));\nfloat normalizer = 9.0f / windowArea;\nfloat score = response * normalizer;\nfloat lod = lodStep * float(layer);\ntmp = mix(tmp, vec2(score, lod), bvec2(score > tmp.x));\n}\nvec2 encodedScore = encodeFloat16(tmp.x);\nfloat encodedScale = encodeLod(tmp.y);\ncolor = vec4(0.0f, pixel.g, 0.0f, encodedScale);\ncolor.rb = encodedScore;\n}'},function(e,t){e.exports='@include "sobel.glsl"\n@include "pyramids.glsl"\nuniform sampler2D pyramid;\nuniform float lod;\nconst mat3 horizontalKernel = mat3(\n-1.0f, 0.0f, 1.0f,\n-2.0f, 0.0f, 2.0f,\n-1.0f, 0.0f, 1.0f\n);\nconst mat3 verticalKernel = mat3(\n1.0f, 2.0f, 1.0f,\n0.0f, 0.0f, 0.0f,\n-1.0f,-2.0f,-1.0f\n);\nconst vec3 ones = vec3(1.0f, 1.0f, 1.0f);\nvoid main()\n{\nfloat pot = exp2(lod);\nmat3 neighbors = mat3(\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-1, -1)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(0, -1)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(1, -1)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-1, 0)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(0, 0)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(1, 0)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(-1, 1)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(0, 1)).g,\npyrPixelAtOffset(pyramid, lod, pot, ivec2(1, 1)).g\n);\nmat3 sobelX = matrixCompMult(horizontalKernel, neighbors);\nmat3 sobelY = matrixCompMult(verticalKernel, neighbors);\nvec2 df = vec2(\ndot(sobelX[0] + sobelX[1] + sobelX[2], ones),\ndot(sobelY[0] + sobelY[1] + sobelY[2], ones)\n);\ncolor = encodeSobel(df);\n}'},function(e,t){e.exports='@include "keypoints.glsl"\nuniform sampler2D encodedKeypoints[2];\nuniform int encoderLength[2];\nuniform int encoderCapacity[2];\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int outEncoderLength;\nvoid main()\n{\nivec2 thread = threadLocation();\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress outAddr = findKeypointAddress(thread, outEncoderLength, descriptorSize, extraSize);\nint outIndex = findKeypointIndex(outAddr, descriptorSize, extraSize);\nint encoderIndex = int(outIndex >= encoderCapacity[0]);\nint inIndex = (outIndex - encoderCapacity[0] * encoderIndex);\nKeypointAddress inAddr = KeypointAddress(\ninIndex * pixelsPerKeypoint,\noutAddr.offset\n);\nvec4 data[2] = vec4[2](\nreadKeypointData(encodedKeypoints[0], encoderLength[0], inAddr),\nreadKeypointData(encodedKeypoints[1], encoderLength[1], inAddr)\n);\nbool valid = (inIndex < max(encoderCapacity[0], encoderCapacity[1]));\ncolor = valid ? data[encoderIndex] : encodeNullKeypoint();\n}'},function(e,t){e.exports='@include "pyramids.glsl"\n@include "float16.glsl"\nuniform sampler2D image;\nuniform float lodStep;\n#if !defined(MULTISCALE)\n#error Must define MULTISCALE\n#elif MULTISCALE != 0\n#define LOD_STEP (lodStep)\n#define USE_MIDDLE_RING\n#else\n#define LOD_STEP (0.0f)\n#endif\n#define PIX(x,y) pixelAtShortOffset(image, ivec2((x),(y)))\n#define L2(v,i) bvec2(isSameEncodedLod(v[i].a, alphaMinus), isSameEncodedLod(v[i].a, alphaPlus))\n#define L3(v,i) bvec3(isSameEncodedLod(v[i].a, alpha), isSameEncodedLod(v[i].a, alphaMinus), isSameEncodedLod(v[i].a, alphaPlus))\n#define S3(v,i) decodeFloat16(v[i].rb) * float(any(L3(v,i)))\n#define S2(v,i) decodeFloat16(v[i].rb) * float(any(L2(v,i)))\n#define P(i) S3(p,i)\n#define Q(i) S2(q,i)\n#define R(i) S2(r,i)\nconst vec4 O = vec4(0.0f);\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nfloat lod = decodeLod(pixel.a);\nfloat score = decodeFloat16(pixel.rb);\ncolor = pixel;\nif(score == 0.0f)\nreturn;\nvec4 p[8] = vec4[8](\nPIX(0,1), PIX(1,1), PIX(1,0), PIX(1,-1),\nPIX(0,-1), PIX(-1,-1), PIX(-1,0), PIX(-1,1)\n);\n#ifdef USE_MIDDLE_RING\nvec4 q[16] = vec4[16](\nPIX(0,2), PIX(1,2), PIX(2,2), PIX(2,1),\nPIX(2,0), PIX(2,-1), PIX(2,-2), PIX(1,-2),\nPIX(0,-2), PIX(-1,-2), PIX(-2,-2), PIX(-2,-1),\nPIX(-2,0), PIX(-2,1), PIX(-2,2), PIX(-1,2)\n);\n#else\nvec4 q[16] = vec4[16](O,O,O,O,O,O,O,O,O,O,O,O,O,O,O,O);\n#endif\n#ifdef USE_OUTER_RING\nvec4 r[16] = vec4[16](\nPIX(0,3), PIX(1,3), PIX(3,1), PIX(3,0),\nPIX(3,-1), PIX(1,-3), PIX(0,-3), PIX(-1,-3),\nPIX(-3,-1), PIX(-3,0), PIX(-3,1), PIX(-1,3),\nPIX(0,4), PIX(4,0), PIX(0,-4), PIX(-4,0)\n);\n#else\nvec4 r[16] = vec4[16](O,O,O,O,O,O,O,O,O,O,O,O,O,O,O,O);\n#endif\nfloat alphaPlus = encodeLod(lod + LOD_STEP);\nfloat alphaMinus = encodeLod(lod - LOD_STEP);\nfloat alpha = encodeLod(lod);\nmat3 innerScore = mat3(\nP(0), P(1), P(2), P(3),\nP(4), P(5), P(6), P(7),\n0.0f);\nmat4 middleScore = mat4(\nQ(0), Q(1), Q(2), Q(3),\nQ(4), Q(5), Q(6), Q(7),\nQ(8), Q(9), Q(10), Q(11),\nQ(12), Q(13), Q(14), Q(15)\n);\nmat4 outerScore = mat4(\nR(0), R(1), R(2), R(3),\nR(4), R(5), R(6), R(7),\nR(8), R(9), R(10), R(11),\nR(12), R(13), R(14), R(15)\n);\nvec3 maxInnerScore3 = max(innerScore[0], max(innerScore[1], innerScore[2]));\nvec4 maxMiddleScore4 = max(max(middleScore[0], middleScore[1]), max(middleScore[2], middleScore[3]));\nvec4 maxOuterScore4 = max(max(outerScore[0], outerScore[1]), max(outerScore[2], outerScore[3]));\nfloat maxInnerScore = max(maxInnerScore3.x, max(maxInnerScore3.y, maxInnerScore3.z));\nfloat maxMiddleScore = max(max(maxMiddleScore4.x, maxMiddleScore4.y), max(maxMiddleScore4.z, maxMiddleScore4.w));\nfloat maxOuterScore = max(max(maxOuterScore4.x, maxOuterScore4.y), max(maxOuterScore4.z, maxOuterScore4.w));\nfloat maxScore = max(maxInnerScore, max(maxMiddleScore, maxOuterScore));\nfloat finalScore = step(maxScore, score) * score;\ncolor.rb = encodeFloat16(finalScore);\n}'},function(e,t){e.exports='@include "keypoints.glsl"\nuniform sampler2D encodedCorners;\nuniform int encoderLength;\nuniform sampler2D pyramid;\nuniform int extraSize;\nconst int descriptorSize = 32;\nconst ivec4 pat31[256] = ivec4[256](\nivec4(8,-3,9,5),\nivec4(4,2,7,-12),\nivec4(-11,9,-8,2),\nivec4(7,-12,12,-13),\nivec4(2,-13,2,12),\nivec4(1,-7,1,6),\nivec4(-2,-10,-2,-4),\nivec4(-13,-13,-11,-8),\nivec4(-13,-3,-12,-9),\nivec4(10,4,11,9),\nivec4(-13,-8,-8,-9),\nivec4(-11,7,-9,12),\nivec4(7,7,12,6),\nivec4(-4,-5,-3,0),\nivec4(-13,2,-12,-3),\nivec4(-9,0,-7,5),\nivec4(12,-6,12,-1),\nivec4(-3,6,-2,12),\nivec4(-6,-13,-4,-8),\nivec4(11,-13,12,-8),\nivec4(4,7,5,1),\nivec4(5,-3,10,-3),\nivec4(3,-7,6,12),\nivec4(-8,-7,-6,-2),\nivec4(-2,11,-1,-10),\nivec4(-13,12,-8,10),\nivec4(-7,3,-5,-3),\nivec4(-4,2,-3,7),\nivec4(-10,-12,-6,11),\nivec4(5,-12,6,-7),\nivec4(5,-6,7,-1),\nivec4(1,0,4,-5),\nivec4(9,11,11,-13),\nivec4(4,7,4,12),\nivec4(2,-1,4,4),\nivec4(-4,-12,-2,7),\nivec4(-8,-5,-7,-10),\nivec4(4,11,9,12),\nivec4(0,-8,1,-13),\nivec4(-13,-2,-8,2),\nivec4(-3,-2,-2,3),\nivec4(-6,9,-4,-9),\nivec4(8,12,10,7),\nivec4(0,9,1,3),\nivec4(7,-5,11,-10),\nivec4(-13,-6,-11,0),\nivec4(10,7,12,1),\nivec4(-6,-3,-6,12),\nivec4(10,-9,12,-4),\nivec4(-13,8,-8,-12),\nivec4(-13,0,-8,-4),\nivec4(3,3,7,8),\nivec4(5,7,10,-7),\nivec4(-1,7,1,-12),\nivec4(3,-10,5,6),\nivec4(2,-4,3,-10),\nivec4(-13,0,-13,5),\nivec4(-13,-7,-12,12),\nivec4(-13,3,-11,8),\nivec4(-7,12,-4,7),\nivec4(6,-10,12,8),\nivec4(-9,-1,-7,-6),\nivec4(-2,-5,0,12),\nivec4(-12,5,-7,5),\nivec4(3,-10,8,-13),\nivec4(-7,-7,-4,5),\nivec4(-3,-2,-1,-7),\nivec4(2,9,5,-11),\nivec4(-11,-13,-5,-13),\nivec4(-1,6,0,-1),\nivec4(5,-3,5,2),\nivec4(-4,-13,-4,12),\nivec4(-9,-6,-9,6),\nivec4(-12,-10,-8,-4),\nivec4(10,2,12,-3),\nivec4(7,12,12,12),\nivec4(-7,-13,-6,5),\nivec4(-4,9,-3,4),\nivec4(7,-1,12,2),\nivec4(-7,6,-5,1),\nivec4(-13,11,-12,5),\nivec4(-3,7,-2,-6),\nivec4(7,-8,12,-7),\nivec4(-13,-7,-11,-12),\nivec4(1,-3,12,12),\nivec4(2,-6,3,0),\nivec4(-4,3,-2,-13),\nivec4(-1,-13,1,9),\nivec4(7,1,8,-6),\nivec4(1,-1,3,12),\nivec4(9,1,12,6),\nivec4(-1,-9,-1,3),\nivec4(-13,-13,-10,5),\nivec4(7,7,10,12),\nivec4(12,-5,12,9),\nivec4(6,3,7,11),\nivec4(5,-13,6,10),\nivec4(2,-12,2,3),\nivec4(3,8,4,-6),\nivec4(2,6,12,-13),\nivec4(9,-12,10,3),\nivec4(-8,4,-7,9),\nivec4(-11,12,-4,-6),\nivec4(1,12,2,-8),\nivec4(6,-9,7,-4),\nivec4(2,3,3,-2),\nivec4(6,3,11,0),\nivec4(3,-3,8,-8),\nivec4(7,8,9,3),\nivec4(-11,-5,-6,-4),\nivec4(-10,11,-5,10),\nivec4(-5,-8,-3,12),\nivec4(-10,5,-9,0),\nivec4(8,-1,12,-6),\nivec4(4,-6,6,-11),\nivec4(-10,12,-8,7),\nivec4(4,-2,6,7),\nivec4(-2,0,-2,12),\nivec4(-5,-8,-5,2),\nivec4(7,-6,10,12),\nivec4(-9,-13,-8,-8),\nivec4(-5,-13,-5,-2),\nivec4(8,-8,9,-13),\nivec4(-9,-11,-9,0),\nivec4(1,-8,1,-2),\nivec4(7,-4,9,1),\nivec4(-2,1,-1,-4),\nivec4(11,-6,12,-11),\nivec4(-12,-9,-6,4),\nivec4(3,7,7,12),\nivec4(5,5,10,8),\nivec4(0,-4,2,8),\nivec4(-9,12,-5,-13),\nivec4(0,7,2,12),\nivec4(-1,2,1,7),\nivec4(5,11,7,-9),\nivec4(3,5,6,-8),\nivec4(-13,-4,-8,9),\nivec4(-5,9,-3,-3),\nivec4(-4,-7,-3,-12),\nivec4(6,5,8,0),\nivec4(-7,6,-6,12),\nivec4(-13,6,-5,-2),\nivec4(1,-10,3,10),\nivec4(4,1,8,-4),\nivec4(-2,-2,2,-13),\nivec4(2,-12,12,12),\nivec4(-2,-13,0,-6),\nivec4(4,1,9,3),\nivec4(-6,-10,-3,-5),\nivec4(-3,-13,-1,1),\nivec4(7,5,12,-11),\nivec4(4,-2,5,-7),\nivec4(-13,9,-9,-5),\nivec4(7,1,8,6),\nivec4(7,-8,7,6),\nivec4(-7,-4,-7,1),\nivec4(-8,11,-7,-8),\nivec4(-13,6,-12,-8),\nivec4(2,4,3,9),\nivec4(10,-5,12,3),\nivec4(-6,-5,-6,7),\nivec4(8,-3,9,-8),\nivec4(2,-12,2,8),\nivec4(-11,-2,-10,3),\nivec4(-12,-13,-7,-9),\nivec4(-11,0,-10,-5),\nivec4(5,-3,11,8),\nivec4(-2,-13,-1,12),\nivec4(-1,-8,0,9),\nivec4(-13,-11,-12,-5),\nivec4(-10,-2,-10,11),\nivec4(-3,9,-2,-13),\nivec4(2,-3,3,2),\nivec4(-9,-13,-4,0),\nivec4(-4,6,-3,-10),\nivec4(-4,12,-2,-7),\nivec4(-6,-11,-4,9),\nivec4(6,-3,6,11),\nivec4(-13,11,-5,5),\nivec4(11,11,12,6),\nivec4(7,-5,12,-2),\nivec4(-1,12,0,7),\nivec4(-4,-8,-3,-2),\nivec4(-7,1,-6,7),\nivec4(-13,-12,-8,-13),\nivec4(-7,-2,-6,-8),\nivec4(-8,5,-6,-9),\nivec4(-5,-1,-4,5),\nivec4(-13,7,-8,10),\nivec4(1,5,5,-13),\nivec4(1,0,10,-13),\nivec4(9,12,10,-1),\nivec4(5,-8,10,-9),\nivec4(-1,11,1,-13),\nivec4(-9,-3,-6,2),\nivec4(-1,-10,1,12),\nivec4(-13,1,-8,-10),\nivec4(8,-11,10,-6),\nivec4(2,-13,3,-6),\nivec4(7,-13,12,-9),\nivec4(-10,-10,-5,-7),\nivec4(-10,-8,-8,-13),\nivec4(4,-6,8,5),\nivec4(3,12,8,-13),\nivec4(-4,2,-3,-3),\nivec4(5,-13,10,-12),\nivec4(4,-13,5,-1),\nivec4(-9,9,-4,3),\nivec4(0,3,3,-9),\nivec4(-12,1,-6,1),\nivec4(3,2,4,-8),\nivec4(-10,-10,-10,9),\nivec4(8,-13,12,12),\nivec4(-8,-12,-6,-5),\nivec4(2,2,3,7),\nivec4(10,6,11,-8),\nivec4(6,8,8,-12),\nivec4(-7,10,-6,5),\nivec4(-3,-9,-3,9),\nivec4(-1,-13,-1,5),\nivec4(-3,-7,-3,4),\nivec4(-8,-2,-8,3),\nivec4(4,2,12,12),\nivec4(2,-5,3,11),\nivec4(6,-9,11,-13),\nivec4(3,-1,7,12),\nivec4(11,-1,12,4),\nivec4(-3,0,-3,6),\nivec4(4,-11,4,12),\nivec4(2,-4,2,1),\nivec4(-10,-6,-8,1),\nivec4(-13,7,-11,1),\nivec4(-13,12,-11,-13),\nivec4(6,0,11,-13),\nivec4(0,-1,1,4),\nivec4(-13,3,-9,-2),\nivec4(-9,8,-6,-3),\nivec4(-13,-6,-8,-2),\nivec4(5,-9,8,10),\nivec4(2,7,3,-9),\nivec4(-1,-6,-1,-1),\nivec4(9,5,11,-2),\nivec4(11,-3,12,-8),\nivec4(3,0,3,5),\nivec4(-1,4,0,10),\nivec4(3,-6,4,5),\nivec4(-13,0,-10,5),\nivec4(5,8,12,11),\nivec4(8,9,9,-6),\nivec4(7,-4,8,-12),\nivec4(-10,4,-10,9),\nivec4(7,3,12,4),\nivec4(9,-7,10,-2),\nivec4(7,0,12,-2),\nivec4(-1,-6,0,-11)\n);\nvoid getPair(int index, mat2 rot, out vec2 p, out vec2 q)\n{\nivec4 data = pat31[index];\nvec2 op = vec2(data.xy);\nvec2 oq = vec2(data.zw);\np = rot * op;\nq = rot * oq;\n}\nvoid main()\n{\nvec4 pixel = threadPixel(encodedCorners);\nivec2 thread = threadLocation();\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nint descriptorCell = address.offset - sizeofEncodedKeypoint(0, extraSize) / 4;\ncolor = pixel;\nif(descriptorCell < 0)\nreturn;\nKeypoint keypoint = decodeKeypoint(encodedCorners, encoderLength, address);\nif(isBadKeypoint(keypoint))\nreturn;\nfloat degreesOrientation = round(360.0f + degrees(keypoint.orientation));\nfloat orientation = radians(degreesOrientation - mod(degreesOrientation, 12.0f));\nfloat kcos = cos(orientation);\nfloat ksin = sin(orientation);\nmat2 rot = mat2(kcos, ksin, -ksin, kcos);\nfloat pot = exp2(keypoint.lod);\nvec2 imageSize = vec2(textureSize(pyramid, 0));\nint patternStart = 32 * descriptorCell;\nuint test[4] = uint[4](0u, 0u, 0u, 0u);\nfor(int t = 0; t < 4; t++) {\nuint bits = 0u;\nvec2 p, q;\nvec4 a, b;\nint i = t * 8;\n@unroll\nfor(int j = 0; j < 8; j++) {\ngetPair(patternStart + i + j, rot, p, q);\na = pyrPixelAtEx(pyramid, round(keypoint.position + pot * p), keypoint.lod, imageSize);\nb = pyrPixelAtEx(pyramid, round(keypoint.position + pot * q), keypoint.lod, imageSize);\nbits |= uint(a.g < b.g) << j;\n}\ntest[t] = bits;\n}\ncolor = vec4(test[0], test[1], test[2], test[3]) / 255.0f;\n}'},function(e,t){e.exports='@include "keypoints.glsl"\nuniform sampler2D pyramid;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\n#define P(x,y) ivec2((x),(y))\nconst int diskPointCount[16] = int[16](0, 4, 12, 28, 48, 80, 112, 148, 196, 252, 316, 376, 440, 528, 612, 708);\nconst ivec2 diskPoint[708] = ivec2[708](\nP(0,-1),P(-1,0),P(1,0),P(0,1),\nP(-1,-1),P(1,-1),P(-1,1),P(1,1),P(0,-2),P(-2,0),P(2,0),P(0,2),\nP(-1,-2),P(1,-2),P(-2,-1),P(2,-1),P(-2,1),P(2,1),P(-1,2),P(1,2),P(-2,-2),P(2,-2),P(-2,2),P(2,2),P(0,-3),P(-3,0),P(3,0),P(0,3),\nP(-1,-3),P(1,-3),P(-3,-1),P(3,-1),P(-3,1),P(3,1),P(-1,3),P(1,3),P(-2,-3),P(2,-3),P(-3,-2),P(3,-2),P(-3,2),P(3,2),P(-2,3),P(2,3),P(0,-4),P(-4,0),P(4,0),P(0,4),\nP(-1,-4),P(1,-4),P(-4,-1),P(4,-1),P(-4,1),P(4,1),P(-1,4),P(1,4),P(-3,-3),P(3,-3),P(-3,3),P(3,3),P(-2,-4),P(2,-4),P(-4,-2),P(4,-2),P(-4,2),P(4,2),P(-2,4),P(2,4),P(0,-5),P(-3,-4),P(3,-4),P(-4,-3),P(4,-3),P(-5,0),P(5,0),P(-4,3),P(4,3),P(-3,4),P(3,4),P(0,5),\nP(-1,-5),P(1,-5),P(-5,-1),P(5,-1),P(-5,1),P(5,1),P(-1,5),P(1,5),P(-2,-5),P(2,-5),P(-5,-2),P(5,-2),P(-5,2),P(5,2),P(-2,5),P(2,5),P(-4,-4),P(4,-4),P(-4,4),P(4,4),P(-3,-5),P(3,-5),P(-5,-3),P(5,-3),P(-5,3),P(5,3),P(-3,5),P(3,5),P(0,-6),P(-6,0),P(6,0),P(0,6),\nP(-1,-6),P(1,-6),P(-6,-1),P(6,-1),P(-6,1),P(6,1),P(-1,6),P(1,6),P(-2,-6),P(2,-6),P(-6,-2),P(6,-2),P(-6,2),P(6,2),P(-2,6),P(2,6),P(-4,-5),P(4,-5),P(-5,-4),P(5,-4),P(-5,4),P(5,4),P(-4,5),P(4,5),P(-3,-6),P(3,-6),P(-6,-3),P(6,-3),P(-6,3),P(6,3),P(-3,6),P(3,6),P(0,-7),P(-7,0),P(7,0),P(0,7),\nP(-1,-7),P(1,-7),P(-5,-5),P(5,-5),P(-7,-1),P(7,-1),P(-7,1),P(7,1),P(-5,5),P(5,5),P(-1,7),P(1,7),P(-4,-6),P(4,-6),P(-6,-4),P(6,-4),P(-6,4),P(6,4),P(-4,6),P(4,6),P(-2,-7),P(2,-7),P(-7,-2),P(7,-2),P(-7,2),P(7,2),P(-2,7),P(2,7),P(-3,-7),P(3,-7),P(-7,-3),P(7,-3),P(-7,3),P(7,3),P(-3,7),P(3,7),P(-5,-6),P(5,-6),P(-6,-5),P(6,-5),P(-6,5),P(6,5),P(-5,6),P(5,6),P(0,-8),P(-8,0),P(8,0),P(0,8),\nP(-1,-8),P(1,-8),P(-4,-7),P(4,-7),P(-7,-4),P(7,-4),P(-8,-1),P(8,-1),P(-8,1),P(8,1),P(-7,4),P(7,4),P(-4,7),P(4,7),P(-1,8),P(1,8),P(-2,-8),P(2,-8),P(-8,-2),P(8,-2),P(-8,2),P(8,2),P(-2,8),P(2,8),P(-6,-6),P(6,-6),P(-6,6),P(6,6),P(-3,-8),P(3,-8),P(-8,-3),P(8,-3),P(-8,3),P(8,3),P(-3,8),P(3,8),P(-5,-7),P(5,-7),P(-7,-5),P(7,-5),P(-7,5),P(7,5),P(-5,7),P(5,7),P(-4,-8),P(4,-8),P(-8,-4),P(8,-4),P(-8,4),P(8,4),P(-4,8),P(4,8),P(0,-9),P(-9,0),P(9,0),P(0,9),\nP(-1,-9),P(1,-9),P(-9,-1),P(9,-1),P(-9,1),P(9,1),P(-1,9),P(1,9),P(-2,-9),P(2,-9),P(-6,-7),P(6,-7),P(-7,-6),P(7,-6),P(-9,-2),P(9,-2),P(-9,2),P(9,2),P(-7,6),P(7,6),P(-6,7),P(6,7),P(-2,9),P(2,9),P(-5,-8),P(5,-8),P(-8,-5),P(8,-5),P(-8,5),P(8,5),P(-5,8),P(5,8),P(-3,-9),P(3,-9),P(-9,-3),P(9,-3),P(-9,3),P(9,3),P(-3,9),P(3,9),P(-4,-9),P(4,-9),P(-9,-4),P(9,-4),P(-9,4),P(9,4),P(-4,9),P(4,9),P(-7,-7),P(7,-7),P(-7,7),P(7,7),P(0,-10),P(-6,-8),P(6,-8),P(-8,-6),P(8,-6),P(-10,0),P(10,0),P(-8,6),P(8,6),P(-6,8),P(6,8),P(0,10),\nP(-1,-10),P(1,-10),P(-10,-1),P(10,-1),P(-10,1),P(10,1),P(-1,10),P(1,10),P(-2,-10),P(2,-10),P(-10,-2),P(10,-2),P(-10,2),P(10,2),P(-2,10),P(2,10),P(-5,-9),P(5,-9),P(-9,-5),P(9,-5),P(-9,5),P(9,5),P(-5,9),P(5,9),P(-3,-10),P(3,-10),P(-10,-3),P(10,-3),P(-10,3),P(10,3),P(-3,10),P(3,10),P(-7,-8),P(7,-8),P(-8,-7),P(8,-7),P(-8,7),P(8,7),P(-7,8),P(7,8),P(-4,-10),P(4,-10),P(-10,-4),P(10,-4),P(-10,4),P(10,4),P(-4,10),P(4,10),P(-6,-9),P(6,-9),P(-9,-6),P(9,-6),P(-9,6),P(9,6),P(-6,9),P(6,9),P(0,-11),P(-11,0),P(11,0),P(0,11),\nP(-1,-11),P(1,-11),P(-11,-1),P(11,-1),P(-11,1),P(11,1),P(-1,11),P(1,11),P(-2,-11),P(2,-11),P(-5,-10),P(5,-10),P(-10,-5),P(10,-5),P(-11,-2),P(11,-2),P(-11,2),P(11,2),P(-10,5),P(10,5),P(-5,10),P(5,10),P(-2,11),P(2,11),P(-8,-8),P(8,-8),P(-8,8),P(8,8),P(-3,-11),P(3,-11),P(-7,-9),P(7,-9),P(-9,-7),P(9,-7),P(-11,-3),P(11,-3),P(-11,3),P(11,3),P(-9,7),P(9,7),P(-7,9),P(7,9),P(-3,11),P(3,11),P(-6,-10),P(6,-10),P(-10,-6),P(10,-6),P(-10,6),P(10,6),P(-6,10),P(6,10),P(-4,-11),P(4,-11),P(-11,-4),P(11,-4),P(-11,4),P(11,4),P(-4,11),P(4,11),P(0,-12),P(-12,0),P(12,0),P(0,12),\nP(-1,-12),P(1,-12),P(-8,-9),P(8,-9),P(-9,-8),P(9,-8),P(-12,-1),P(12,-1),P(-12,1),P(12,1),P(-9,8),P(9,8),P(-8,9),P(8,9),P(-1,12),P(1,12),P(-5,-11),P(5,-11),P(-11,-5),P(11,-5),P(-11,5),P(11,5),P(-5,11),P(5,11),P(-2,-12),P(2,-12),P(-12,-2),P(12,-2),P(-12,2),P(12,2),P(-2,12),P(2,12),P(-7,-10),P(7,-10),P(-10,-7),P(10,-7),P(-10,7),P(10,7),P(-7,10),P(7,10),P(-3,-12),P(3,-12),P(-12,-3),P(12,-3),P(-12,3),P(12,3),P(-3,12),P(3,12),P(-6,-11),P(6,-11),P(-11,-6),P(11,-6),P(-11,6),P(11,6),P(-6,11),P(6,11),P(-4,-12),P(4,-12),P(-12,-4),P(12,-4),P(-12,4),P(12,4),P(-4,12),P(4,12),P(-9,-9),P(9,-9),P(-9,9),P(9,9),P(-8,-10),P(8,-10),P(-10,-8),P(10,-8),P(-10,8),P(10,8),P(-8,10),P(8,10),P(0,-13),P(-5,-12),P(5,-12),P(-12,-5),P(12,-5),P(-13,0),P(13,0),P(-12,5),P(12,5),P(-5,12),P(5,12),P(0,13),\nP(-1,-13),P(1,-13),P(-7,-11),P(7,-11),P(-11,-7),P(11,-7),P(-13,-1),P(13,-1),P(-13,1),P(13,1),P(-11,7),P(11,7),P(-7,11),P(7,11),P(-1,13),P(1,13),P(-2,-13),P(2,-13),P(-13,-2),P(13,-2),P(-13,2),P(13,2),P(-2,13),P(2,13),P(-3,-13),P(3,-13),P(-13,-3),P(13,-3),P(-13,3),P(13,3),P(-3,13),P(3,13),P(-6,-12),P(6,-12),P(-12,-6),P(12,-6),P(-12,6),P(12,6),P(-6,12),P(6,12),P(-9,-10),P(9,-10),P(-10,-9),P(10,-9),P(-10,9),P(10,9),P(-9,10),P(9,10),P(-4,-13),P(4,-13),P(-8,-11),P(8,-11),P(-11,-8),P(11,-8),P(-13,-4),P(13,-4),P(-13,4),P(13,4),P(-11,8),P(11,8),P(-8,11),P(8,11),P(-4,13),P(4,13),P(-7,-12),P(7,-12),P(-12,-7),P(12,-7),P(-12,7),P(12,7),P(-7,12),P(7,12),P(-5,-13),P(5,-13),P(-13,-5),P(13,-5),P(-13,5),P(13,5),P(-5,13),P(5,13),P(0,-14),P(-14,0),P(14,0),P(0,14),\nP(-1,-14),P(1,-14),P(-14,-1),P(14,-1),P(-14,1),P(14,1),P(-1,14),P(1,14),P(-2,-14),P(2,-14),P(-10,-10),P(10,-10),P(-14,-2),P(14,-2),P(-14,2),P(14,2),P(-10,10),P(10,10),P(-2,14),P(2,14),P(-9,-11),P(9,-11),P(-11,-9),P(11,-9),P(-11,9),P(11,9),P(-9,11),P(9,11),P(-3,-14),P(3,-14),P(-6,-13),P(6,-13),P(-13,-6),P(13,-6),P(-14,-3),P(14,-3),P(-14,3),P(14,3),P(-13,6),P(13,6),P(-6,13),P(6,13),P(-3,14),P(3,14),P(-8,-12),P(8,-12),P(-12,-8),P(12,-8),P(-12,8),P(12,8),P(-8,12),P(8,12),P(-4,-14),P(4,-14),P(-14,-4),P(14,-4),P(-14,4),P(14,4),P(-4,14),P(4,14),P(-7,-13),P(7,-13),P(-13,-7),P(13,-7),P(-13,7),P(13,7),P(-7,13),P(7,13),P(-5,-14),P(5,-14),P(-10,-11),P(10,-11),P(-11,-10),P(11,-10),P(-14,-5),P(14,-5),P(-14,5),P(14,5),P(-11,10),P(11,10),P(-10,11),P(10,11),P(-5,14),P(5,14),P(0,-15),P(-9,-12),P(9,-12),P(-12,-9),P(12,-9),P(-15,0),P(15,0),P(-12,9),P(12,9),P(-9,12),P(9,12),P(0,15)\n);\nconst int DEFAULT_PATCH_RADIUS = 15;\nconst int MIN_PATCH_RADIUS = 2;\nvoid main()\n{\nvec4 pixel = threadPixel(encodedKeypoints);\nivec2 thread = threadLocation();\nint keypointIndex = thread.x + thread.y * outputSize().x;\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress address = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\nvec2 m = vec2(0.0f);\nfloat pot = exp2(keypoint.lod);\nivec2 pyrBaseSize = textureSize(pyramid, 0);\nint scaledRadius = int(ceil(float(DEFAULT_PATCH_RADIUS) / pot));\nint radius = max(scaledRadius, MIN_PATCH_RADIUS);\nint count = diskPointCount[radius];\nfor(int j = 0; j < count; j++) {\nvec2 offset = vec2(diskPoint[j]);\nvec2 position = keypoint.position + round(pot * offset);\nvec4 patchPixel = pyrPixelAtEx(pyramid, position, keypoint.lod, pyrBaseSize);\nm += offset * patchPixel.g;\n}\nfloat angle = fastAtan2(m.y, m.x);\nfloat encodedOrientation = encodeOrientation(angle);\nfloat encodedFlags = encodeKeypointFlags(keypoint.flags | KPF_ORIENTED);\ncolor = vec4(0.0f, encodedOrientation, 0.0f, encodedFlags);\n}'},function(e,t){e.exports='@include "float16.glsl"\nuniform sampler2D corners;\nvoid main()\n{\nvec4 pixel = threadPixel(corners);\nfloat score = decodeFloat16(pixel.rb);\n#if !defined(METHOD)\n#error Must define METHOD\n#elif METHOD == 0\nfloat score8 = clamp(score, 0.0f, 1.0f);\n#elif METHOD == 1\nfloat score8 = 1.0f - exp2(-score);\n#else\n#error Invalid METHOD\n#endif\ncolor = vec4(score8, pixel.g, 0.0f, pixel.a);\n}'},function(e,t){e.exports='@include "float16.glsl"\nuniform sampler2D corners;\nuniform int iterationNumber;\nvoid main()\n{\nivec2 thread = threadLocation();\nivec2 bounds = outputSize();\nint jump = (1 << iterationNumber);\nint clusterLength = jump << 1;\nint clusterMask = clusterLength - 1;\nivec2 clusterPos = ivec2(thread >> (1 + iterationNumber)) << (1 + iterationNumber);\nivec2 next1 = clusterPos + ((thread - clusterPos + ivec2(jump, 0)) & clusterMask);\nivec2 next2 = clusterPos + ((thread - clusterPos + ivec2(0, jump)) & clusterMask);\nivec2 next3 = clusterPos + ((thread - clusterPos + ivec2(jump, jump)) & clusterMask);\nvec4 p0 = texelFetch(corners, thread, 0);\nvec4 p1 = texelFetch(corners, next1 % bounds, 0);\nvec4 p2 = texelFetch(corners, next2 % bounds, 0);\nvec4 p3 = texelFetch(corners, next3 % bounds, 0);\nfloat s0 = decodeFloat16(p0.rb);\nfloat s1 = decodeFloat16(p1.rb);\nfloat s2 = decodeFloat16(p2.rb);\nfloat s3 = decodeFloat16(p3.rb);\nbool b0 = s0 >= s1 && s0 >= s2 && s0 >= s3;\nbool b1 = s1 >= s0 && s1 >= s2 && s1 >= s3;\nbool b2 = s2 >= s0 && s2 >= s1 && s2 >= s3;\ncolor = vec4(0.0f);\ncolor.rb = b0 ? p0.rb : (\nb1 ? p1.rb : (\nb2 ? p2.rb : p3.rb\n)\n);\n}'},function(e,t){e.exports='@include "keypoints.glsl"\nuniform sampler2D permutation;\nuniform int maxKeypoints;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nstruct PermutationElement\n{\nint keypointIndex;\nfloat score;\nbool valid;\n};\nPermutationElement decodePermutationElement(vec4 pixel)\n{\nPermutationElement element;\nelement.keypointIndex = int(pixel.r * 255.0f) | (int(pixel.g * 255.0f) << 8);\nelement.valid = (pixel.a > 0.0f);\nelement.score = element.valid ? pixel.b : -1.0f;\nreturn element;\n}\nPermutationElement readPermutationElement(sampler2D permutation, int elementIndex, int stride, int height)\n{\nconst vec4 INVALID_PIXEL = vec4(0.0f);\nivec2 pos = ivec2(elementIndex % stride, elementIndex / stride);\nvec4 pixel = pos.y < height ? pixelAt(permutation, pos) : INVALID_PIXEL;\nreturn decodePermutationElement(pixel);\n}\nvoid main()\n{\nivec2 thread = threadLocation();\nint newEncoderLength = outputSize().x;\nKeypointAddress myAddress = findKeypointAddress(thread, newEncoderLength, descriptorSize, extraSize);\nint myKeypointIndex = findKeypointIndex(myAddress, descriptorSize, extraSize);\nivec2 psize = textureSize(permutation, 0);\nPermutationElement element = readPermutationElement(permutation, myKeypointIndex, psize.x, psize.y);\nint oldEncoderLength = textureSize(encodedKeypoints, 0).x;\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress address = KeypointAddress(element.keypointIndex * pixelsPerKeypoint, myAddress.offset);\nvec4 keypointData = readKeypointData(encodedKeypoints, oldEncoderLength, address);\ncolor = myKeypointIndex < maxKeypoints && element.valid ? keypointData : encodeNullKeypoint();\n}'},function(e,t){e.exports='@include "keypoints.glsl"\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nstruct PermutationElement\n{\nint keypointIndex;\nfloat score;\nbool valid;\n};\nvec4 encodePermutationElement(PermutationElement element)\n{\nfloat valid = float(element.valid);\nfloat score = clamp(element.score, 0.0f, 1.0f);\nvec2 encodedIndex = vec2(element.keypointIndex & 255, (element.keypointIndex >> 8) & 255) / 255.0f;\nreturn vec4(encodedIndex, score, valid);\n}\nvoid main()\n{\nivec2 thread = threadLocation();\nint stride = outputSize().x;\nint keypointIndex = thread.y * stride + thread.x;\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress address = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\nPermutationElement element;\nelement.valid = !isBadKeypoint(keypoint);\nelement.score = keypoint.score;\nelement.keypointIndex = keypointIndex;\ncolor = encodePermutationElement(element);\n}'},function(e,t){e.exports="uniform sampler2D permutation;\nuniform int blockSize;\nuniform int dblLog2BlockSize;\nstruct PermutationElement\n{\nint keypointIndex;\nfloat score;\nbool valid;\n};\nPermutationElement decodePermutationElement(vec4 pixel)\n{\nPermutationElement element;\nelement.keypointIndex = int(pixel.r * 255.0f) | (int(pixel.g * 255.0f) << 8);\nelement.valid = (pixel.a > 0.0f);\nelement.score = element.valid ? pixel.b : -1.0f;\nreturn element;\n}\nvec4 encodePermutationElement(PermutationElement element)\n{\nfloat valid = float(element.valid);\nfloat score = clamp(element.score, 0.0f, 1.0f);\nvec2 encodedIndex = vec2(element.keypointIndex & 255, (element.keypointIndex >> 8) & 255) / 255.0f;\nreturn vec4(encodedIndex, score, valid);\n}\nPermutationElement readPermutationElement(sampler2D permutation, int elementIndex, int stride, int height)\n{\nconst vec4 INVALID_PIXEL = vec4(0.0f);\nivec2 pos = ivec2(elementIndex % stride, elementIndex / stride);\nvec4 pixel = pos.y < height ? pixelAt(permutation, pos) : INVALID_PIXEL;\nreturn decodePermutationElement(pixel);\n}\nPermutationElement selectKth(int k, int la, int ra, int lb, int rb)\n{\nPermutationElement a, b;\nint ha, hb, ma, mb;\nbool discard1stHalf, altb;\nbool locked = false;\nint tmp, result = 0;\nint stride = outputSize().x;\nint height = outputSize().y;\nfor(int i = 0; i < dblLog2BlockSize; i++) {\ntmp = (lb > rb && !locked) ? (la+k) : result;\nresult = (la > ra && !locked) ? (lb+k) : tmp;\nlocked = locked || (la > ra) || (lb > rb);\nha = (ra - la + 1) / 2;\nhb = (rb - lb + 1) / 2;\nma = la + ha;\nmb = lb + hb;\na = readPermutationElement(permutation, ma, stride, height);\nb = readPermutationElement(permutation, mb, stride, height);\ndiscard1stHalf = (k > ha + hb);\naltb = (-a.score < -b.score);\nk -= int(discard1stHalf && altb) * (ha + 1);\nk -= int(discard1stHalf && !altb) * (hb + 1);\nla += int(discard1stHalf && altb) * (ma + 1 - la);\nlb += int(discard1stHalf && !altb) * (mb + 1 - lb);\nra += int(!discard1stHalf && !altb) * (ma - 1 - ra);\nrb += int(!discard1stHalf && altb) * (mb - 1 - rb);\n}\nreturn readPermutationElement(permutation, result, stride, height);\n}\nvoid main()\n{\nivec2 thread = threadLocation();\nint stride = outputSize().x;\nint elementIndex = thread.y * stride + thread.x;\nint blockIndex = elementIndex / blockSize;\nint blockOffset = elementIndex % blockSize;\nint la = blockIndex * blockSize;\nint lb = la + blockSize / 2;\nint ra = lb - 1;\nint rb = (blockIndex + 1) * blockSize - 1;\nint k = blockOffset;\nPermutationElement element = selectKth(k, la, ra, lb, rb);\ncolor = encodePermutationElement(element);\n}"},function(e,t){e.exports='@include "keypoints.glsl"\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nuniform int suppressedEncoderLength;\nvoid main()\n{\nivec2 thread = threadLocation();\nKeypointAddress myAddress = findKeypointAddress(thread, suppressedEncoderLength, 0, extraSize);\nint myIndex = findKeypointIndex(myAddress, 0, extraSize);\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress otherAddress = KeypointAddress(myIndex * pixelsPerKeypoint, myAddress.offset);\ncolor = readKeypointData(encodedKeypoints, encoderLength, otherAddress);\n}'},function(e,t){e.exports='@include "keypoints.glsl"\nuniform sampler2D encodedOrientations;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nvoid main()\n{\nvec4 pixel = threadPixel(encodedKeypoints);\nivec2 thread = threadLocation();\nKeypointAddress myAddress = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nint myIndex = findKeypointIndex(myAddress, descriptorSize, extraSize);\nint orientationEncoderLength = textureSize(encodedOrientations, 0).x;\nivec2 location = ivec2(myIndex % orientationEncoderLength, myIndex / orientationEncoderLength);\nvec4 targetPixel = pixelAt(encodedOrientations, location);\nfloat encodedOrientation = targetPixel.g;\nfloat encodedFlags = targetPixel.a;\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, myAddress);\nkeypoint.flags |= decodeKeypointFlags(encodedFlags);\nbool isValid = !isBadKeypoint(keypoint);\ncolor = isValid && myAddress.offset == 1 ? vec4(pixel.r, encodedOrientation, pixel.b, encodeKeypointFlags(keypoint.flags)) : pixel;\n}'},function(e,t){e.exports='@include "keypoints.glsl"\nuniform sampler2D encodedKeypoints;\nuniform int startIndex;\nuniform int endIndex;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\n#ifndef BUFFER_SIZE\n#error Undefined BUFFER_SIZE\n#endif\nlayout(std140) uniform KeypointBuffer\n{\nvec4 keypointBuffer[BUFFER_SIZE];\n};\nvoid main()\n{\nvec4 pixel = threadPixel(encodedKeypoints);\nivec2 thread = threadLocation();\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nint index = findKeypointIndex(address, descriptorSize, extraSize);\ncolor = pixel;\nif(index < startIndex)\nreturn;\ncolor = encodeNullKeypoint();\nif(index >= endIndex)\nreturn;\nvec4 data = keypointBuffer[index - startIndex];\nswitch(address.offset) {\ncase 0: {\nfixed2_t pos = vec2tofix(data.xy);\nfixed2_t lo = pos & 255;\nfixed2_t hi = (pos >> 8) & 255;\ncolor = vec4(float(lo.x), float(hi.x), float(lo.y), float(hi.y)) / 255.0f;\nbreak;\n}\ncase 1: {\nfloat score = clamp(data.w, 0.0f, 1.0f);\nfloat scale = encodeLod(data.z);\nfloat rotation = encodeOrientation(0.0f);\nfloat flags = encodeKeypointFlags(KPF_NONE);\ncolor = vec4(scale, rotation, score, flags);\nbreak;\n}\ndefault: {\ncolor = vec4(0.0f);\nbreak;\n}\n}\n}'},function(e,t){e.exports="uniform sampler2D image;\nvoid main()\n{\nivec2 thread = threadLocation();\nivec2 pos = min(thread * 2, textureSize(image, 0) - ivec2(1));\ncolor = pixelAt(image, pos);\n}"},function(e,t){e.exports="uniform sampler2D image;\nvoid main()\n{\nivec2 thread = threadLocation();\nvec4 pixel = pixelAt(image, thread / 2);\ncolor = (((thread.x + thread.y) & 1) == 0) ? pixel : vec4(0.0f, 0.0f, 0.0f, pixel.a);\n}"},function(e,t){e.exports='@include "keypoints.glsl"\nuniform sampler2D pyramid;\nuniform sampler2D encodedKeypoints;\nuniform int windowSize;\nuniform float discardThreshold;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nbool isInsideImage(vec2 position)\n{\nvec2 imageSize = vec2(textureSize(pyramid, 0));\nfloat border = float(windowSize);\nreturn (\nposition.x > border && position.x < imageSize.x - border &&\nposition.y > border && position.y < imageSize.y - border\n);\n}\nvoid main()\n{\nvec4 pixel = threadPixel(encodedKeypoints);\nivec2 thread = threadLocation();\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\ncolor = pixel;\nif(address.offset != 1)\nreturn;\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\nif(isBadKeypoint(keypoint))\nreturn;\nbool shouldDiscard = isKeypointAtInfinity(keypoint) || !isInsideImage(keypoint.position);\nint newFlag = shouldDiscard ? KPF_DISCARD : 0;\ncolor.a = encodeKeypointFlags(keypoint.flags | newFlag);\n}'},function(e,t){e.exports='@include "keypoints.glsl"\nuniform sampler2D pyramid;\nuniform int windowSize;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nbool isInsideImage(vec2 position)\n{\nvec2 imageSize = vec2(textureSize(pyramid, 0));\nfloat border = float(windowSize);\nreturn (\nposition.x > border && position.x < imageSize.x - border &&\nposition.y > border && position.y < imageSize.y - border\n);\n}\nvoid main()\n{\nvec4 pixel = threadPixel(encodedKeypoints);\nivec2 thread = threadLocation();\nKeypointAddress address = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, address);\nbool shouldDiscard = isBadKeypoint(keypoint) || isKeypointAtInfinity(keypoint) || !isInsideImage(keypoint.position);\ncolor = shouldDiscard ? encodeDiscardedKeypoint() : pixel;\n}'},function(e,t){e.exports='@include "keypoints.glsl"\n@include "float16.glsl"\nuniform sampler2D nextPyramid;\nuniform sampler2D prevPyramid;\nuniform sampler2D encodedFlow;\nuniform sampler2D prevKeypoints;\nuniform int windowSize;\nuniform int level;\nuniform int depth;\nuniform int numberOfIterations;\nuniform float discardThreshold;\nuniform float epsilon;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\n#ifndef MAX_WINDOW_SIZE\n#error Must define MAX_WINDOW_SIZE\n#endif\n#define NEXT_IMAGE 1\n#define PREV_IMAGE 0\nconst int MAX_WINDOW_SIZE_SQUARED = (MAX_WINDOW_SIZE) * (MAX_WINDOW_SIZE);\nconst int MAX_WINDOW_SIZE_PLUS = (MAX_WINDOW_SIZE) + 2;\nconst int MAX_WINDOW_SIZE_PLUS_SQUARED = MAX_WINDOW_SIZE_PLUS * MAX_WINDOW_SIZE_PLUS;\nconst int DBL_MAX_WINDOW_SIZE_PLUS_SQUARED = 2 * MAX_WINDOW_SIZE_PLUS_SQUARED;\nconst int MAX_WINDOW_RADIUS_PLUS = (MAX_WINDOW_SIZE_PLUS - 1) / 2;\nconst int MAX_WINDOW_RADIUS = ((MAX_WINDOW_SIZE) - 1) / 2;\nconst highp float FLT_SCALE = 0.00000095367431640625f;\nconst highp float FLT_EPSILON = 0.00000011920929f;\nconst highp float INFINITY = 1.0f / 0.0f;\n#define windowRadius() ((windowSize - 1) / 2)\nfloat pixelBuffer[DBL_MAX_WINDOW_SIZE_PLUS_SQUARED];\n#define prevPixel(index) pixelBuffer[(index)]\n#define nextPixel(index) pixelBuffer[MAX_WINDOW_SIZE_PLUS_SQUARED + (index)]\n#define pixelIndex(i, j) (((j) + MAX_WINDOW_RADIUS_PLUS) * MAX_WINDOW_SIZE_PLUS + ((i) + MAX_WINDOW_RADIUS_PLUS))\nivec2 derivBuffer[MAX_WINDOW_SIZE_SQUARED];\n#define derivativesAt(x, y) derivBuffer[((y) + MAX_WINDOW_RADIUS) * MAX_WINDOW_SIZE + ((x) + MAX_WINDOW_RADIUS)]\nvoid readWindow(vec2 center, float lod)\n{\nivec2 pyrBaseSize = textureSize(prevPyramid, 0);\nfloat pot = exp2(lod);\nint r = windowRadius();\nivec2 offset; int idx;\n#define readPixelsAt(ox, oy) offset = ivec2((ox), (oy)); \\\nidx = pixelIndex(offset.x, offset.y); \\\nnextPixel(idx) = pyrSubpixelAtExOffset(nextPyramid, center, lod, pot, offset, pyrBaseSize).g; \\\nprevPixel(idx) = pyrSubpixelAtExOffset(prevPyramid, center, lod, pot, offset, pyrBaseSize).g\nfor(int j = 0; j < windowSize; j++) {\nfor(int i = 0; i < windowSize; i++) {\nreadPixelsAt(i-r, j-r);\n}\n}\nint r1 = r+1;\nfor(int k = 0; k < windowSize; k++) {\nreadPixelsAt(-r1, k-r);\nreadPixelsAt( r1, k-r);\nreadPixelsAt(k-r,-r1);\nreadPixelsAt(k-r, r1);\n}\nreadPixelsAt(-r1,-r1);\nreadPixelsAt( r1,-r1);\nreadPixelsAt(-r1, r1);\nreadPixelsAt( r1, r1);\n}\nvec2 computeDerivatives(int imageCode, ivec2 offset)\n{\nconst mat3 dx = mat3(\n3, 0, -3,\n10, 0, -10,\n3, 0, -3\n);\nconst mat3 dy = mat3(\n3, 10, 3,\n0, 0, 0,\n-3, -10, -3\n);\nint indexOffset = imageCode * MAX_WINDOW_SIZE_PLUS_SQUARED;\nmat3 window = mat3(\npixelBuffer[indexOffset + pixelIndex(offset.x-1, offset.y-1)],\npixelBuffer[indexOffset + pixelIndex(offset.x+0, offset.y-1)],\npixelBuffer[indexOffset + pixelIndex(offset.x+1, offset.y-1)],\npixelBuffer[indexOffset + pixelIndex(offset.x-1, offset.y+0)],\n0.0f,\npixelBuffer[indexOffset + pixelIndex(offset.x+1, offset.y+0)],\npixelBuffer[indexOffset + pixelIndex(offset.x-1, offset.y+1)],\npixelBuffer[indexOffset + pixelIndex(offset.x+0, offset.y+1)],\npixelBuffer[indexOffset + pixelIndex(offset.x+1, offset.y+1)]\n);\nmat3 fx = matrixCompMult(dx, window);\nmat3 fy = matrixCompMult(dy, window);\nconst vec3 ones = vec3(1.0f);\nreturn vec2(\ndot(fx[0], ones) + dot(fx[1], ones) + dot(fx[2], ones),\ndot(fy[0], ones) + dot(fy[1], ones) + dot(fy[2], ones)\n);\n}\nfloat readBufferedPixel(int imageCode, ivec2 offset)\n{\nivec2 limit = ivec2(windowRadius());\noffset = clamp(offset, -limit, limit);\nint indexOffset = imageCode * MAX_WINDOW_SIZE_PLUS_SQUARED;\nreturn pixelBuffer[indexOffset + pixelIndex(offset.x, offset.y)];\n}\nfloat readBufferedSubpixel(int imageCode, vec2 offset)\n{\nivec2 p = ivec2(floor(offset));\nvec2 frc = fract(offset);\nvec2 ifrc = vec2(1.0f) - frc;\nvec4 pix4 = vec4(\nreadBufferedPixel(imageCode, p),\nreadBufferedPixel(imageCode, ivec2(p.x + 1, p.y)),\nreadBufferedPixel(imageCode, ivec2(p.x, p.y + 1)),\nreadBufferedPixel(imageCode, ivec2(p.x + 1, p.y + 1))\n);\nreturn dot(vec4(\npix4.x * ifrc.x * ifrc.y,\npix4.y * frc.x * ifrc.y,\npix4.z * ifrc.x * frc.y,\npix4.w * frc.x * frc.y\n), vec4(1.0f));\n}\nivec2 computeMismatch(highp vec2 pyrGuess, highp vec2 localGuess)\n{\nint timeDerivative;\nivec2 mismatch = ivec2(0);\nint x, y, r = windowRadius();\nhighp vec2 d = pyrGuess + localGuess;\nfor(int _y = 0; _y < windowSize; _y++) {\nfor(int _x = 0; _x < windowSize; _x++) {\nx = _x - r; y = _y - r;\ntimeDerivative = int(round(255.0f * (\nreadBufferedSubpixel(NEXT_IMAGE, vec2(x, y) + d) -\nreadBufferedPixel(PREV_IMAGE, ivec2(x, y))\n)));\nmismatch += derivativesAt(x, y) * timeDerivative;\n}\n}\nreturn mismatch;\n}\nvec4 encodeFlow(vec2 flow)\n{\nreturn vec4(encodeFloat16(flow.x), encodeFloat16(flow.y));\n}\nvec2 decodeFlow(vec4 pix)\n{\nreturn vec2(decodeFloat16(pix.rg), decodeFloat16(pix.ba));\n}\nvoid main()\n{\nvec4 pixel = threadPixel(encodedFlow);\nivec2 thread = threadLocation();\nfloat windowArea = float(windowSize * windowSize);\nint r = windowRadius();\nint keypointIndex = thread.x + thread.y * outputSize().x;\nint pixelsPerKeypoint = sizeofEncodedKeypoint(descriptorSize, extraSize) / 4;\nKeypointAddress address = KeypointAddress(keypointIndex * pixelsPerKeypoint, 0);\nKeypoint keypoint = decodeKeypoint(prevKeypoints, encoderLength, address);\ncolor = encodeFlow(vec2(0.0f));\nif(isBadKeypoint(keypoint))\nreturn;\nhighp vec2 pyrGuess = (level < depth - 1) ? decodeFlow(pixel) : vec2(0.0f);\nreadWindow(keypoint.position, float(level));\nivec2 derivatives;\nivec3 harris3i = ivec3(0);\nfor(int j = 0; j < windowSize; j++) {\nfor(int i = 0; i < windowSize; i++) {\nderivatives = ivec2(floor(255.0f * computeDerivatives(PREV_IMAGE, ivec2(i-r, j-r))));\nharris3i += ivec3(\nderivatives.x * derivatives.x,\nderivatives.x * derivatives.y,\nderivatives.y * derivatives.y\n);\nderivativesAt(i-r, j-r) = derivatives;\n}\n}\nhighp vec3 harris = vec3(harris3i) * FLT_SCALE;\nhighp float det = harris.x * harris.z - harris.y * harris.y;\nhighp float invDet = 1.0f / det;\nhighp mat2 invHarris = mat2(harris.z, -harris.y, -harris.y, harris.x);\nhighp float minEigenvalue = 0.5f * ((harris.x + harris.z) - sqrt(\n(harris.x - harris.z) * (harris.x - harris.z) + 4.0f * (harris.y * harris.y)\n));\nint niceNumbers = int(det >= FLT_EPSILON && minEigenvalue >= discardThreshold * windowArea);\nbool goodKeypoint = (level > 0) || (niceNumbers != 0);\nhighp float eps2 = epsilon * epsilon;\nhighp vec2 mismatch, delta, localGuess = vec2(0.0f);\nfor(int k = 0; k < numberOfIterations; k++) {\nmismatch = vec2(computeMismatch(pyrGuess, localGuess)) * FLT_SCALE;\ndelta = mismatch * invHarris * invDet;\nniceNumbers *= int(eps2 <= dot(delta, delta));\nlocalGuess += float(niceNumbers) * delta;\n}\npyrGuess = 2.0f * (pyrGuess + localGuess);\nvec2 opticalFlow = goodKeypoint ? pyrGuess : vec2(INFINITY);\ncolor = encodeFlow(opticalFlow);\n}'},function(e,t){e.exports='@include "keypoints.glsl"\n@include "float16.glsl"\nuniform sampler2D encodedFlow;\nuniform sampler2D encodedKeypoints;\nuniform int descriptorSize;\nuniform int extraSize;\nuniform int encoderLength;\nvec2 decodeFlow(vec4 pix)\n{\nreturn vec2(decodeFloat16(pix.rg), decodeFloat16(pix.ba));\n}\nvoid main()\n{\nvec4 pixel = threadPixel(encodedKeypoints);\nivec2 thread = threadLocation();\nKeypointAddress myAddress = findKeypointAddress(thread, encoderLength, descriptorSize, extraSize);\nKeypoint keypoint = decodeKeypoint(encodedKeypoints, encoderLength, myAddress);\nint myIndex = findKeypointIndex(myAddress, descriptorSize, extraSize);\nint len = textureSize(encodedFlow, 0).x;\nivec2 location = ivec2(myIndex % len, myIndex / len);\nvec4 targetPixel = pixelAt(encodedFlow, location);\nvec2 flow = decodeFlow(targetPixel);\nvec4 newPosition = encodeKeypointPosition(keypoint.position + flow);\nvec4 encodedPosition = any(isinf(flow)) ? encodeKeypointPositionAtInfinity() : newPosition;\ncolor = myAddress.offset == 0 ? encodedPosition : pixel;\n}'},function(e,t){e.exports='@include "subpixel.glsl"\nuniform sampler2D image;\nvoid main()\n{\nvec2 imageSize = vec2(textureSize(image, 0));\n#if !defined(INTERPOLATION_METHOD)\n#error Must define INTERPOLATION_METHOD\n#elif INTERPOLATION_METHOD == 0\nvec2 pos = texCoord * imageSize;\ncolor = textureLod(image, (round(pos) + vec2(0.5f)) / imageSize, 0.0f);\n#elif INTERPOLATION_METHOD == 1\ncolor = subpixelAtBI(image, texCoord * imageSize);\n#else\n#error Invalid INTERPOLATION_METHOD\n#endif\n}'},function(e,t){e.exports='@include "subpixel.glsl"\nuniform sampler2D image;\nuniform mat3 inverseHomography;\nconst vec4 emptyColor = vec4(0.0f, 0.0f, 0.0f, 1.0f);\nvec2 perspectiveWarp(mat3 homography, vec2 p)\n{\nvec3 q = homography * vec3(p, 1.0f);\nreturn q.xy / q.z;\n}\nvoid main()\n{\nivec2 location = threadLocation();\nivec2 size = outputSize();\nconst vec2 zero = vec2(0.0f);\nvec2 target = perspectiveWarp(inverseHomography, vec2(location));\nbool withinBounds = all(bvec4(greaterThanEqual(target, zero), lessThan(target, vec2(size))));\ncolor = withinBounds ? subpixelAtBI(image, target) : emptyColor;\n}'},function(e,t){e.exports='@include "colors.glsl"\nuniform sampler2D dest, src;\nuniform int destComponents;\nuniform int srcComponentId;\nvoid main()\n{\nvec4 destPixel = threadPixel(dest);\nvec4 srcPixel = threadPixel(src);\nbvec4 flags = bvec4(\n(destComponents & PIXELCOMPONENT_RED) != 0,\n(destComponents & PIXELCOMPONENT_GREEN) != 0,\n(destComponents & PIXELCOMPONENT_BLUE) != 0,\n(destComponents & PIXELCOMPONENT_ALPHA) != 0\n);\ncolor = mix(destPixel, vec4(srcPixel[srcComponentId]), flags);\n}'},function(e,t){e.exports='@include "colors.glsl"\nuniform sampler2D image;\nuniform int pixelComponents;\nuniform float value;\nvoid main()\n{\nvec4 pixel = threadPixel(image);\nbvec4 flags = bvec4(\n(pixelComponents & PIXELCOMPONENT_RED) != 0,\n(pixelComponents & PIXELCOMPONENT_GREEN) != 0,\n(pixelComponents & PIXELCOMPONENT_BLUE) != 0,\n(pixelComponents & PIXELCOMPONENT_ALPHA) != 0\n);\ncolor = mix(pixel, vec4(value), flags);\n}'},function(e,t){e.exports="uniform float value;\nvoid main()\n{\ncolor = vec4(value);\n}"},function(e,t){e.exports="uniform sampler2D image;\nvoid main() {\nivec2 pos = threadLocation();\npos.y = int(texSize.y) - 1 - pos.y;\ncolor = pixelAt(image, pos);\n}"},function(e,t){e.exports="uniform sampler2D image;\nvoid main()\n{\ncolor = threadPixel(image);\n}"},function(e,t){e.exports="uniform sampler2D image;\nuniform int iterationNumber;\nvoid main()\n{\nivec2 thread = threadLocation();\nivec2 last = outputSize() - ivec2(1);\nint jump = (1 << iterationNumber);\nint clusterLength = jump << 1;\nint clusterMask = clusterLength - 1;\nivec2 clusterPos = ivec2(thread >> (1 + iterationNumber)) << (1 + iterationNumber);\nivec2 next1 = clusterPos + ((thread - clusterPos + ivec2(jump, 0)) & clusterMask);\nivec2 next2 = clusterPos + ((thread - clusterPos + ivec2(0, jump)) & clusterMask);\nivec2 next3 = clusterPos + ((thread - clusterPos + ivec2(jump, jump)) & clusterMask);\nvec4 p0 = texelFetch(image, thread, 0);\nvec4 p1 = texelFetch(image, min(next1, last), 0);\nvec4 p2 = texelFetch(image, min(next2, last), 0);\nvec4 p3 = texelFetch(image, min(next3, last), 0);\nvec4 pmax = max(max(p0, p1), max(p2, p3));\nvec4 pmin = min(min(p0, p1), min(p2, p3));\ncolor = vec4(pmax.r, pmin.g, pmax.r - pmin.g, p0.a);\n}"},function(e,t,n){"use strict";function i(e,t,n){}function s(e,t,n){const{rows:i,columns:s,stride:r}=e,{value:o}=e.custom,a=t.length;if(i*s!=a)for(let e=0;e<s;e++)t.fill(o,e*r,e*r+i);else t.fill(o,0,a)}function r(e,t,n){const{rows:i,columns:s,stride:r}=e,[o]=e.strideOfInputs,[a]=n,c=t.length;if(c==e.lengthOfInputs[0]&&i*s==c)return void t.set(a,0,c);let l,d,h,u;for(h=u=d=0;d<s;d++,h+=r,u+=o)for(l=0;l<i;l++)t[h+l]=a[u+l]}function o(e,t,n){const{rows:i,columns:s,stride:r}=e,[o]=e.strideOfInputs,[a]=n;let c,l,d,h;for(d=c=0;c<i;c++,d+=o)for(h=l=0;l<s;l++,h+=r)t[h+c]=a[d+l]}function a(e,t,n){const{rows:i,columns:s,stride:r}=e,[o,a]=e.strideOfInputs,[c,l]=n;let d,h,u,p,f;for(p=f=u=h=0;h<s;h++,u+=r,f+=a,p+=o)for(d=0;d<i;d++)t[u+d]=c[p+d]+l[f+d]}function c(e,t,n){const{rows:i,columns:s,stride:r}=e,[o,a]=e.strideOfInputs,[c,l]=n;let d,h,u,p,f;for(p=f=u=h=0;h<s;h++,u+=r,f+=a,p+=o)for(d=0;d<i;d++)t[u+d]=c[p+d]-l[f+d]}function l(e,t,n){const{rows:i,columns:s,stride:r}=e,[o,a]=e.columnsOfInputs,[c,l]=e.strideOfInputs,[d,h]=n,u=t.length;if(i*s!=u)for(let e=0;e<s;e++)t.fill(0,e*r,e*r+i);else t.fill(0,0,u);let p,f,m,_,g,x,y;for(_=x=m=0;m<a;m++,_+=r,x+=l)for(g=f=0;f<o;f++,g+=c)for(y=h[x+f],p=0;p<i;p++)t[_+p]+=d[g+p]*y}function d(e,t,n){const{rows:i,columns:s,stride:r}=e,[o,a]=e.columnsOfInputs,[c,l]=e.rowsOfInputs,[d,h]=e.strideOfInputs,[u,p]=n;let f,m,_,g,x,y,v;for(y=x=_=0;_<a;_++,y+=r,x+=h)for(g=m=0;m<o;m++,g+=d)for(t[v=y+m]=0,f=0;f<l;f++)t[v]+=u[g+f]*p[x+f]}function h(e,t,n){const{rows:i,columns:s,stride:r}=e,[o,a]=e.columnsOfInputs,[c,l]=e.rowsOfInputs,[d,h]=e.strideOfInputs,[u,p]=n,f=t.length;if(i*s!=f)for(let e=0;e<s;e++)t.fill(0,e*r,e*r+i);else t.fill(0,0,f);let m,_,g,x,y,v,w;for(y=v=_=0;_<o;_++,y+=d,v+=h)for(x=g=0;g<l;g++,x+=r)for(w=p[v+g],m=0;m<i;m++)t[x+m]+=u[y+m]*w}function u(e,t,n){const{stride:i}=e,[s,r]=n,[o,a]=e.strideOfInputs,c=o+o,l=a+a,d=i+i,h=s[0],u=s[0+o],p=s[0+c],f=s[1],m=s[1+o],_=s[1+c],g=s[2],x=s[2+o],y=s[2+c],v=r[0],w=r[0+a],S=r[0+l],b=r[1],P=r[1+a],A=r[1+l],E=r[2],I=r[2+a],O=r[2+l];t[0]=h*v+u*b+p*E,t[1]=f*v+m*b+_*E,t[2]=g*v+x*b+y*E,t[0+i]=h*w+u*P+p*I,t[1+i]=f*w+m*P+_*I,t[2+i]=g*w+x*P+y*I,t[0+d]=h*S+u*A+p*O,t[1+d]=f*S+m*A+_*O,t[2+d]=g*S+x*A+y*O}function p(e,t,n){const[i]=e.rowsOfInputs,[s]=e.columnsOfInputs,[r]=e.strideOfInputs,[o,a]=n;let c,l,d,h;for(t.fill(0,0,i),d=l=0;l<s;l++,d+=r)for(h=a[l],c=0;c<i;c++)t[c]+=o[d+c]*h}function f(e,t,n){const{rows:i,columns:s,stride:r}=e,{scalar:o}=e.custom,[a]=n;let c,l,d;for(l=0;l<s;l++)for(d=l*r,c=0;c<i;c++)t[d+c]=a[d+c]*o}function m(e,t,n){const{rows:i,columns:s,stride:r}=e,[o,a]=e.strideOfInputs,[c,l]=n;let d,h,u,p,f;for(p=f=u=h=0;h<s;h++,u+=r,p+=o,f+=a)for(d=0;d<i;d++)t[u+d]=c[p+d]*l[f+d]}function _(e,t,n){const{rows:i,columns:s,stride:r}=e,[o,a]=e.strideOfInputs,[c,l]=n;let d,h,u,p,f;for(f=p=h=0;h<s;h++,p+=r,f+=a)for(u=l[f],d=0;d<i;d++)t[p+d]=c[d]*u}function g(e,t,n){const{rows:i,columns:s,stride:r}=e,[o,a]=e.strideOfInputs,{alpha:c,beta:l}=e.custom,[d,h]=n;let u,p,f,m,_;for(m=_=f=p=0;p<s;p++,f+=r,m+=o,_+=a)for(u=0;u<i;u++)t[f+u]=c*d[m+u]+l*h[_+u]}n.r(t),n.d(t,"nop",(function(){return i})),n.d(t,"fill",(function(){return s})),n.d(t,"copy",(function(){return r})),n.d(t,"transpose",(function(){return o})),n.d(t,"add",(function(){return a})),n.d(t,"subtract",(function(){return c})),n.d(t,"multiply",(function(){return l})),n.d(t,"multiplylt",(function(){return d})),n.d(t,"multiplyrt",(function(){return h})),n.d(t,"multiply3",(function(){return u})),n.d(t,"multiplyvec",(function(){return p})),n.d(t,"scale",(function(){return f})),n.d(t,"compmult",(function(){return m})),n.d(t,"outer",(function(){return _})),n.d(t,"addInPlace",(function(){return g}))},function(e,t,n){"use strict";function i(e,t,n){t[0]=1/n[0][0]}function s(e,t,n){const i=e.stride,s=e.strideOfInputs[0],r=n[0],o=r[0],a=r[1],c=r[0+s],l=r[1+s],d=1/(o*l-c*a);t[0]=l*d,t[1]=-a*d,t[0+i]=-c*d,t[1+i]=o*d}function r(e,t,n){const i=e.stride,s=e.strideOfInputs[0],r=n[0],o=r[0],a=r[1],c=r[2],l=r[0+s],d=r[1+s],h=r[2+s],u=r[0+s+s],p=r[1+s+s],f=r[2+s+s],m=f*d-h*p,_=f*l-h*u,g=p*l-d*u,x=1/(o*m-a*_+c*g),y=i+i;t[0]=m*x,t[1]=-(f*a-c*p)*x,t[2]=(h*a-c*d)*x,t[0+i]=-_*x,t[1+i]=(f*o-c*u)*x,t[2+i]=-(h*o-c*l)*x,t[0+y]=g*x,t[1+y]=-(p*o-a*u)*x,t[2+y]=(d*o-a*l)*x}n.r(t),n.d(t,"inverse1",(function(){return i})),n.d(t,"inverse2",(function(){return s})),n.d(t,"inverse3",(function(){return r}))},function(e,t,n){"use strict";function i(e,t,n){const{rows:i,columns:s}=e,[r]=n,[o]=e.rowsOfInputs,[a]=e.columnsOfInputs,[c]=e.strideOfInputs;if(a!==o+1)throw new Error(`Invalid input for backsub: expected ${o} x ${o+1} or ${a-1} x ${a} matrix, but found ${o} x ${a} matrix`);if(i!==o||1!==s)throw new Error(`Invalid output for backsub: expected ${o} x 1 matrix, but found ${i} x ${s} matrix`);const l=o,d=t,h=r.subarray(0,c),u=r.subarray(c);let p,f,m,_=(l-1)*c;for(d[l-1]=h[l-1]/u[_+(l-1)],f=l-2;f>=0;f--){for(d[f]=h[f],p=f+1;p<l;p++)d[f]-=d[p]*u[c*p+f];_-=c,m=u[_+f],d[f]/=m}}function s(e,t,n){const{stride:i,dtype:s}=e,[r,o]=[e.rowsOfInputs[0],e.columnsOfInputs[0]],[a,c]=n,[l,d]=e.strideOfInputs,h=this.createTypedArray(s,r*(o+1));this.run(this.qr,s,[r,o+1,r,r,o,l,r,1,d],[h,a,c],{mode:"reduced-Q'x"}),this.runWithBlocks(this.backsub,s,[0,o-1,0,0,i,0,o-1,0,o,r],[t,h])}n.r(t),n.d(t,"backsub",(function(){return i})),n.d(t,"lssolve",(function(){return s}))},function(e,t,n){"use strict";function i(e,t,n){const{stride:i,dtype:s}=e,[r,o]=[e.rows,e.columns],[a,c]=e.rowsOfInputs,[l,d]=e.columnsOfInputs,[h]=e.strideOfInputs,[u,p]=n,{mode:f}=e.custom,m="full-qr"==f||"reduced-qr"==f,_=this.createTypedArray(s,2*a*l+l),g=_.subarray(0,a*l),x=_.subarray(a*l,a*l+l),y=_.subarray(a*l+l,2*a*l+l),v=i,w=m?t.subarray(("reduced-qr"==f?l:a)*i):t.subarray(i);if(a<l)throw new Error(`Can't compute the QR decomposition of a ${a} x ${l} matrix`);if(r!=a)throw new Error(`Can't compute the QR decomposition of a ${a} x ${l} matrix: expected an output matrix of ${a} rows, but found a matrix of ${r} rows`);let S,b,P,A,E,I,O,M;for(u.length!=w.length?this.runWithBlocks(this.copy,s,[0,a-1,0,l-1,v,0,a-1,0,l-1,h],[w,u]):w.set(u,0,u.length),P=0;P<l;P++){for(O=P*a+P,M=P*v+P,A=a-P,I=+(w[M]>=0)-+(w[M]<0),S=0;S<A;S++)g[O+S]=w[M+S];for(g[O]+=I*this.norm2(g,O,A),E=this.norm2(g,O,A),S=O+A-1;S>=O;S--)g[S]/=E;this.runWithBlocks(this.multiplylt,s,[0,0,0,l-P-1,1,P,a-1,P,P,a,P,a-1,P,l-1,v],[x,g,w]),this.runWithBlocks(this.outer,s,[0,a-P-1,0,l-P-1,a,P,a-1,P,P,a,0,0,0,l-P-1,1],[y,g,x]),this.runWithBlocks(this.addInPlace,s,[P,a-1,P,l-1,v,P,a-1,P,l-1,v,0,a-P-1,0,l-P-1,a],[w,w,y],{alpha:1,beta:-2})}switch(f){case"full-qr":{const e=i,n=t.subarray(0,e*a).fill(0);let s,c,d;if(r!=a||o!=l+a)throw new Error(`Can't compute the full QR decomposition of a ${a} x ${l} matrix: expected an output matrix of size ${a} x ${l+a}, found ${r} x ${o}`);for(b=0;b<a;b++)for(c=b*e,n[c+b]=1,P=l-1;P>=0;P--)for(s=P*a,d=-2*this.dot(n,g,c+P,s+P,a-P),S=a-1;S>=P;S--)n[c+S]+=d*g[s+S];break}case"reduced-qr":{const e=i,n=t.subarray(0,e*l).fill(0);let s,c,d;if(r!=a||o!=l+l)throw new Error(`Can't compute the reduced QR decomposition of a ${a} x ${l} matrix: expected an output matrix of size ${a} x ${l+l}, found ${r} x ${o}`);for(b=0;b<l;b++)for(c=b*e,n[c+b]=1,P=l-1;P>=0;P--)for(s=P*a,d=-2*this.dot(n,g,c+P,s+P,a-P),S=a-1;S>=P;S--)n[c+S]+=d*g[s+S];break}case"Q'x":{const e=i,n=t.subarray(0,e),s=a,h=l;let u,f;if(s!=c||1!=d)throw new Error(`QR decomposition: the input vector is expected to be ${s} x 1, but is ${c} x ${d}`);if(s!=r||1+h!=o)throw new Error(`QR decomposition: the output matrix is expected to be ${s} x ${1+h}, but is ${r} x ${o}`);for(S=0;S<s;S++)n[S]=p[S];for(P=0;P<h;P++)for(u=P*a,f=-2*this.dot(n,g,P,u+P,s-P),S=P;S<s;S++)n[S]+=f*g[u+S];break}case"Qx":{const e=i,n=t.subarray(0,e),s=a,h=l;let u,f;if(s!=c||1!=d)throw new Error(`QR decomposition: the input vector is expected to be ${s} x 1, but is ${c} x ${d}`);if(s!=r||1+h!=o)throw new Error(`QR decomposition: the output matrix is expected to be ${s} x ${1+h}, but is ${r} x ${o}`);for(S=0;S<s;S++)n[S]=p[S];for(P=h-1;P>=0;P--)for(u=P*a,f=-2*this.dot(n,g,P,u+P,s-P),S=P;S<s;S++)n[S]+=f*g[u+S];break}case"reduced-Q'x":{const e=a,n=l,i=t.subarray(0,n),s=y.subarray(0,e);let h,u;if(e!=c||1!=d)throw new Error(`QR decomposition: the input vector is expected to be ${e} x 1, but is ${c} x ${d}`);if(e!=r||1+n!=o)throw new Error(`QR decomposition: the output matrix is expected to be ${e} x ${1+n}, but is ${r} x ${o}`);for(b=0;b<n;b++){for(s.fill(0),s[b]=1,P=n-1;P>=0;P--)for(h=P*a,u=-2*this.dot(s,g,P,h+P,e-P),S=e-1;S>=P;S--)s[S]+=u*g[h+S];i[b]=this.dot(p,s,0,0,e)}break}default:throw new Error(`QR decomposition: unknown mode "${f}"`)}}n.r(t),n.d(t,"qr",(function(){return i}))},function(e,t,n){"use strict";function i(e,t,n){this.subroutine("sequence",e,n)}n.r(t),n.d(t,"sequence",(function(){return i}))},function(e,t,n){"use strict";function i(e,t,n){const[i,s,r,o]=n,{rows:a,columns:c,stride:l}=e,[d,h,u]=e.strideOfInputs,[p,f]=[e.rowsOfInputs[1],e.columnsOfInputs[1]],[m,_]=[e.rowsOfInputs[2],e.columnsOfInputs[2]],[g,x]=[n[0].length,n[2].length],y=c/_,v=u===d&&x===g?Array.from({length:y},(e,t)=>i.subarray(t*d*_,(t+1)*d*_)):null;let w,S,b,P,A;for(w=0;w<y;w++){if(null!=v)n[2]=v[w];else for(A=0,P=w*d*_,b=0;b<_;b++,A+=u,P+=d)for(S=0;S<m;S++)r[A+S]=i[P+S];for(o[0]=w,this.subroutine("mapfn",e,n),A=w*f*l,P=0,b=0;b<f;b++,A+=l,P+=h)for(S=0;S<p;S++)t[A+S]=s[P+S]}n[2]=r}function s(e,t,n){const[i,s,r,o,a,c]=n,{rows:l,columns:d,stride:h}=e,[u,p,f,m,_,g]=e.strideOfInputs,[x,y,v,w,S,b]=n.map(e=>e.length),[P,A]=[e.rowsOfInputs[3],e.columnsOfInputs[3]],E=t.length,I=f===g&&v===b,O=f===p&&v===y,M=f===h&&v===E,k=m===u&&w===x,X=e.columnsOfInputs[0]/A,L=k?Array.from({length:X},(e,t)=>i.subarray(t*u*A,(t+1)*u*A)):null;let z,T,R,N,K;if(I)r.set(c);else for(K=0,N=0,R=0;R<d;R++,N+=g,K+=f)for(T=0;T<l;T++)r[K+T]=c[N+T];for(z=0;z<X;z++){if(null!=L)n[3]=L[z];else for(K=0,N=z*u*A,R=0;R<A;R++,K+=m,N+=u)for(T=0;T<P;T++)o[K+T]=i[N+T];if(a[0]=z,this.subroutine("reducefn",e,n),O)r.set(s);else for(K=0,N=0,R=0;R<d;R++,N+=p,K+=f)for(T=0;T<l;T++)r[K+T]=s[N+T]}if(M)t.set(r);else for(K=0,N=0,R=0;R<d;R++,N+=f,K+=h)for(T=0;T<l;T++)t[K+T]=r[N+T];n[3]=o}function r(e,t,n){const[i,s,r,o]=n,{rows:a,columns:c,stride:l}=e,[d,h,u,p]=e.strideOfInputs,[f,m,_,g]=n.map(e=>e.length),[x,y]=[e.rowsOfInputs[2],e.columnsOfInputs[2]],v=c/y,w=u===d&&_===f&&(p===d&&g===f)?Array.from({length:v},(e,t)=>i.subarray(t*d*y,(t+1)*d*y)):null,S=this.range(v),b=new Array(v).fill(0);let P,A,E,I,O,M,k,X,L=-1,z=0,T=0,R=0,N=0;for(b[++L]=0,b[++L]=v-1;L>=0;){if(T=b[L--],z=b[L--],R=z+T>>>1,N=S[R],null!=w)n[3]=w[N];else for(E=0,I=N*d*y,A=0;A<y;A++,E+=p,I+=d)for(P=0;P<x;P++)o[E+P]=i[I+P];for(O=z-1,M=T+1;;){do{if(O++,null!=w)n[2]=w[S[O]];else for(E=0,I=S[O]*d*y,A=0;A<y;A++,E+=u,I+=d)for(P=0;P<x;P++)r[E+P]=i[I+P];this.subroutine("cmp",e,n)}while(s[0]<0&&O<T);do{if(M--,null!=w)n[2]=w[S[M]];else for(E=0,I=S[M]*d*y,A=0;A<y;A++,E+=u,I+=d)for(P=0;P<x;P++)r[E+P]=i[I+P];this.subroutine("cmp",e,n)}while(s[0]>0&&M>z);if(!(O<M))break;X=S[O],S[O]=S[M],S[M]=X}R=M,z<R&&(b[++L]=z,b[++L]=R),T>R+1&&(b[++L]=R+1,b[++L]=T)}for(M=0;M<v;M++)for(k=S[M]*y,E=M*y*l,I=k*d,A=0;A<y;A++,E+=l,I+=d)for(P=0;P<x;P++)t[E+P]=i[I+P];n[2]=r,n[3]=o}n.r(t),n.d(t,"map",(function(){return i})),n.d(t,"reduce",(function(){return s})),n.d(t,"sort",(function(){return r}))},function(e,t,n){"use strict";function i(e,t,n){const i=e.stride,s=e.strideOfInputs[0],r=e.strideOfInputs[1],o=n[0],a=n[1],c=1e-6;let l,d,h,u,p,f,m,_,g,x,y,v,w,S,b,P,A,E,I,O,M,k,X,L,z,T,R,N,K,D,C,F,j,B,$;const U=o[0],H=o[1],G=o[0+s],q=o[1+s],W=o[0+2*s],Y=o[1+2*s],Q=o[0+3*s],Z=o[1+3*s],V=a[0],J=a[1],ee=a[0+r],te=a[1+r],ne=a[0+2*r],ie=a[1+2*r],se=a[0+3*r],re=a[1+3*r];R=N=K=D=C=F=j=B=$=Number.NaN;do{const e=(Q-U)*(q-H)-(Z-H)*(G-U),t=(Q-U)*(Y-H)-(Z-H)*(W-U),n=(G-U)*(Y-H)-(q-H)*(W-U),i=(Q-G)*(Y-q)-(Z-q)*(W-G),s=-e;if(Math.abs(e)<c||Math.abs(t)<c||Math.abs(n)<c||Math.abs(i)<c)break;if(l=W*e-G*t,d=Y*e-q*t,h=Q*n-W*s,u=Z*n-Y*s,p=t-e,f=s-n,m=l*u-d*h,Math.abs(m)<c)break;if(_=1/m,b=(u*p-d*f)*_,P=(l*f-h*p)*_,Math.abs(e)>Math.abs(t)?(g=(1+b*G+P*q)*(Z-H)/-e,x=(1+b*G+P*q)*(Q-U)/e):(g=(1+b*W+P*Y)*(Z-H)/-t,x=(1+b*W+P*Y)*(Q-U)/t),Math.abs(n)>Math.abs(s)?(v=(1+b*W+P*Y)*(q-H)/-n,w=(1+b*W+P*Y)*(G-U)/n):(v=(1+b*Q+P*Z)*(q-H)/-s,w=(1+b*Q+P*Z)*(G-U)/s),y=-g*U-x*H,S=-v*U-w*H,A=1,m=g*w*1+x*S*b+y*v*P-x*v*1-g*S*P-y*w*b,Math.abs(m)<c)break;if(l=ee-ne,d=se-ne,h=te-ie,u=re-ie,p=V-ee+(ne-se),f=J-te+(ie-re),m=l*u-d*h,Math.abs(m)<c)break;if(_=1/m,L=(u*p-d*f)*_,z=(l*f-h*p)*_,E=L*ee+(ee-V),I=z*se+(se-V),O=V,M=L*te+(te-J),k=z*re+(re-J),X=J,T=1,m=E*k*1+I*X*L+O*M*z-I*M*1-E*X*z-O*k*L,Math.abs(m)<c)break;R=E*g+I*v+O*b,N=E*x+I*w+O*P,K=E*y+I*S+1*O,D=M*g+k*v+X*b,C=M*x+k*w+X*P,F=M*y+k*S+1*X,j=L*g+z*v+1*b,B=L*x+z*w+1*P,$=L*y+z*S+1}while(0);t[0]=R,t[1]=D,t[2]=j,t[0+i]=N,t[1+i]=C,t[2+i]=B,t[0+2*i]=K,t[1+2*i]=F,t[2+2*i]=$}function s(e,t,n){const i=e.stride,s=e.strideOfInputs[0],r=e.strideOfInputs[1],o=2*i,a=2*s,c=3*s,l=2*r,d=3*r,h=n[0],u=n[1],p=h[0],f=h[1],m=h[0+s],_=h[1+s],g=h[0+a],x=h[1+a],y=h[0+c],v=h[1+c],w=u[0],S=u[1],b=u[0+r],P=u[1+r],A=u[0+l],E=u[1+l],I=u[0+d],O=u[1+d],M=.25*(p+m+g+y),k=.25*(f+_+x+v),X=.25*(w+b+A+I),L=.25*(S+P+E+O),z=(p-M)*(p-M)+(f-k)*(f-k)+(m-M)*(m-M)+(_-k)*(_-k)+(g-M)*(g-M)+(x-k)*(x-k)+(y-M)*(y-M)+(v-k)*(v-k),T=(w-X)*(w-X)+(S-L)*(S-L)+(b-X)*(b-X)+(P-L)*(P-L)+(A-X)*(A-X)+(E-L)*(E-L)+(I-X)*(I-X)+(O-L)*(O-L),R=Math.sqrt(8/z),N=Math.sqrt(8/T);h[0]=R*(p-M),h[1]=R*(f-k),h[0+s]=R*(m-M),h[1+s]=R*(_-k),h[0+a]=R*(g-M),h[1+a]=R*(x-k),h[0+c]=R*(y-M),h[1+c]=R*(v-k),u[0]=N*(w-X),u[1]=N*(S-L),u[0+r]=N*(b-X),u[1+r]=N*(P-L),u[0+l]=N*(A-X),u[1+l]=N*(E-L),u[0+d]=N*(I-X),u[1+d]=N*(O-L),this.homography4p(e,t,n),h[0]=p,h[1]=f,h[0+s]=m,h[1+s]=_,h[0+a]=g,h[1+a]=x,h[0+c]=y,h[1+c]=v,u[0]=w,u[1]=S,u[0+r]=b,u[1+r]=P,u[0+l]=A,u[1+l]=E,u[0+d]=I,u[1+d]=O;const K=t[0],D=t[0+i],C=t[0+o],F=t[1],j=t[1+i],B=t[1+o],$=t[2],U=t[2+i],H=R,G=1/N,q=t[2+o]-H*(M*$+k*U);t[0]=H*(G*K+X*$),t[1]=H*(G*F+L*$),t[2]=H*$,t[0+i]=H*(G*D+X*U),t[1+i]=H*(G*j+L*U),t[2+i]=H*U,t[0+o]=X*q+G*(C-H*(M*K+k*D)),t[1+o]=L*q+G*(B-H*(M*F+k*j)),t[2+o]=q}function r(e,t,n){const i=e.dtype,s=e.columnsOfInputs[0],r=n[0],o=n[1],a=e.stride,c=e.strideOfInputs[0],l=e.strideOfInputs[1],d=2*s,h=this.createTypedArray(i,16*s).fill(0),u=this.createTypedArray(i,2*s),p=this.createTypedArray(i,8);let f,m,_,g,x,y,v,w,S,b,P,A,E,I,O,M,k,X;for(v=0,w=0,y=0,x=0;x<s;x++,y+=2,v+=c,w+=l)f=r[v+0],m=r[v+1],_=o[w+0],g=o[w+1],h[0+y]=f,h[d+0+y]=m,h[2*d+0+y]=1,h[3*d+1+y]=f,h[4*d+1+y]=m,h[5*d+1+y]=1,h[6*d+0+y]=-f*_,h[6*d+1+y]=-f*g,h[7*d+0+y]=-m*_,h[7*d+1+y]=-m*g,u[0+y]=_,u[1+y]=g;this.run(this.lssolve,i,[8,1,8,2*s,8,2*s,2*s,1,2*s],[p,h,u]),S=p[0],b=p[1],P=p[2],A=p[3],E=p[4],I=p[5],O=p[6],M=p[7],k=1,X=S*E*k+b*I*O+P*A*M-b*A*k-S*I*M-P*E*O,(Number.isNaN(X)||Math.abs(X)<1e-6)&&(S=b=P=A=E=I=O=M=k=Number.NaN);const L=a+a;t[0]=S,t[1]=A,t[2]=O,t[a+0]=b,t[a+1]=E,t[a+2]=M,t[L+0]=P,t[L+1]=I,t[L+2]=k}function o(e,t,n){const{dtype:i,stride:s}=e,r=e.columnsOfInputs[0],o=e.strideOfInputs[0],a=e.strideOfInputs[1],c=n[0],l=n[1],d=this.createTypedArray(i,4*r),h=this.createTypedArray(i,36),u=d.subarray(0,2*r),p=d.subarray(2*r,4*r),f=h.subarray(0,9),m=h.subarray(9,18),_=h.subarray(18,27),g=h.subarray(27,36),x=_,y=m;this.run(this.dltnorm2d,i,[2,r,2,2,r,o,3,3,3,3,3,3],[u,c,f,m]),this.run(this.dltnorm2d,i,[2,r,2,2,r,a,3,3,3,3,3,3],[p,l,_,g]),this.run(this.homographydlt,i,[3,3,3,2,r,2,2,r,2],[x,u,p]),this.run(this.multiply3,i,[3,3,3,3,3,3,3,3,3],[y,x,f]),this.run(this.multiply3,i,[3,3,s,3,3,3,3,3,3],[t,g,y])}function a(e,t,n){const i=e.stride,s=e.strideOfInputs[0],r=e.strideOfInputs[1],o=e.strideOfInputs[2],a=e.columnsOfInputs[0],c=n[0],l=n[1],d=n[2];let h=0,u=0,p=0,f=0,m=0,_=0,g=0,x=0,y=0,v=0;for(y=x=0;x<a;x++,y+=s)h+=c[y],u+=c[y+1];for(h/=a,u/=a,y=x=0;x<a;x++,y+=s)p=c[y]-h,f=c[y+1]-u,m+=p*p+f*f;m=Math.sqrt(m/a);const w=1.4142135623730951;_=w/m,g=m/w;const S=r+r;l[0]=_,l[0+r]=0,l[0+S]=-_*h,l[1]=0,l[1+r]=_,l[1+S]=-_*u,l[2]=0,l[2+r]=0,l[2+S]=1;const b=o+o;for(d[0]=g,d[0+o]=0,d[0+b]=h,d[1]=0,d[1+o]=g,d[1+b]=u,d[2]=0,d[2+o]=0,d[2+b]=1,v=0,y=0,x=0;x<a;x++,y+=s,v+=i)t[v]=_*(c[y]-h),t[v+1]=_*(c[y+1]-u)}n.r(t),n.d(t,"homography4p",(function(){return i})),n.d(t,"homographynorm4p",(function(){return s})),n.d(t,"homographydlt",(function(){return r})),n.d(t,"homographynormdlt",(function(){return o})),n.d(t,"dltnorm2d",(function(){return a}))},function(e,t,n){"use strict";function i(e,t,n){const{columns:i,stride:s}=e,[r,o]=n,[a,c]=e.strideOfInputs,l=a+a,d=r[0],h=r[1],u=r[2],p=r[0+a],f=r[1+a],m=r[2+a],_=r[0+l],g=r[1+l],x=r[2+l];let y,v,w,S,b,P;for(v=w=y=0;y<i;y++,v+=c,w+=s)S=o[v],b=o[v+1],P=u*S+m*b+x,t[w]=(d*S+p*b+_)/P,t[w+1]=(h*S+f*b+g)/P}function s(e,t,n){const{columns:i,stride:s}=e,[r,o]=n,[a,c]=e.strideOfInputs,l=a+a,d=r[0],h=r[1],u=r[0+a],p=r[1+a],f=r[0+l],m=r[1+l];let _,g,x,y,v;for(g=x=_=0;_<i;_++,g+=c,x+=s)y=o[g],v=o[g+1],t[x]=d*y+u*v+f,t[x+1]=h*y+p*v+m}function r(e,t,n){const{columns:i,stride:s}=e,[r,o]=n,[a,c]=e.strideOfInputs,l=r[0],d=r[1],h=r[0+a],u=r[1+a];let p,f,m,_,g;for(f=m=p=0;p<i;p++,f+=c,m+=s)_=o[f],g=o[f+1],t[m]=l*_+h*g,t[m+1]=d*_+u*g}n.r(t),n.d(t,"applyHomography",(function(){return i})),n.d(t,"applyAffine",(function(){return s})),n.d(t,"applyLinear2d",(function(){return r}))},function(e,t,n){"use strict";function i(e,t,n){const{dtype:i,rows:s,columns:r,stride:o}=e,a=n[0],c=n[1],l=n[2],d=e.columnsOfInputs[0],h=e.strideOfInputs[0],u=e.strideOfInputs[1],p=e.strideOfInputs[2],{numberOfHypotheses:f,bundleSize:m,reprojectionError:_}=e.custom,g=_*_,x=4*f,y=x+d-x%d,v=Array.from({length:y},(e,t)=>t%d),w=this.shuffle(this.range(d)),S=this.createTypedArray(i,9*f);function b(e){this.mat=e,this.err=0}const P=Array.from({length:f},(e,t)=>new b(S.subarray(9*t,9*(t+1)))),A=this.createTypedArray(i,8),E=this.createTypedArray(i,8),I=[A,E],O=this.run(null,i,[3,3,3,2,4,2,2,4,2],[P[0].mat,A,E]),M=(e,t)=>e.err-t.err,k=m;let X=f,L=0,z=0,T=0,R=0,N=0,K=0,D=0,C=0,F=0,j=0,B=0,$=0,U=0,H=0,G=0,q=0,W=0,Y=0,Q=0,Z=P[0].mat,V=0;for(z=0;z<y;z+=d)this.shuffle(v,z,z+d);for(L=0;L<X;L++)T=4*L,D=v[T],C=v[T+1],F=v[T+2],j=v[T+3],Z=P[L].mat,A[0]=a[h*D+0],A[1]=a[h*D+1],A[2]=a[h*C+0],A[3]=a[h*C+1],A[4]=a[h*F+0],A[5]=a[h*F+1],A[6]=a[h*j+0],A[7]=a[h*j+1],E[0]=c[u*D+0],E[1]=c[u*D+1],E[2]=c[u*C+0],E[3]=c[u*C+1],E[4]=c[u*F+0],E[5]=c[u*F+1],E[6]=c[u*j+0],E[7]=c[u*j+1],this.homographynorm4p(O,Z,I),Number.isNaN(Z[0])&&(P[L].err=d,V++);for(V=V<X?V:X-1,P.sort(M),P.length=X-=V,z=0;z<d&&(z%k==0&&X>1&&(P.sort(M),X>>>=1,P.length=X),1!=X);z++)for(D=w[z],q=a[h*D+0],W=a[h*D+1],Y=c[u*D+0],Q=c[u*D+1],L=0;L<X;L++)Z=P[L].mat,U=Z[2]*q+Z[5]*W+Z[8],B=(Z[0]*q+Z[3]*W+Z[6])/U,$=(Z[1]*q+Z[4]*W+Z[7])/U,H=B-Y,G=$-Q,P[L].err+=H*H+G*G>g|0;for(T=0,L=1;L<X;L++)P[L].err<P[T].err&&(T=L);Z=P[T].mat;const J=Z[0],ee=Z[3],te=Z[6],ne=Z[1],ie=Z[4],se=Z[7],re=Z[2],oe=Z[5],ae=Z[8],ce=[];for(R=0,N=0,K=0,T=0;T<d;T++,R+=h,N+=u,K+=p)q=a[R+0],W=a[R+1],U=re*q+oe*W+ae,B=(J*q+ee*W+te)/U,$=(ne*q+ie*W+se)/U,H=B-c[N+0],G=$-c[N+1],(l[K]=H*H+G*G<=g|0)&&ce.push(T);const le=o+o;if(t[0]=J,t[1]=ne,t[2]=re,t[0+o]=ee,t[1+o]=ie,t[2+o]=oe,t[0+le]=te,t[1+le]=se,t[2+le]=ae,ce.length>4){const e=ce.length,n=this.createTypedArray(i,4*e),l=n.subarray(0,2*e),d=n.subarray(2*e,4*e);for(z=T=0;T<e;T++,z+=2)D=ce[T],l[z+0]=a[h*D+0],l[z+1]=a[h*D+1],d[z+0]=c[u*D+0],d[z+1]=c[u*D+1];this.run(this.homographynormdlt,i,[s,r,o,2,e,2,2,e,2],[t,l,d])}else if(ce.length<4)for(z=0;z<3;z++)t[z]=t[z+o]=t[z+le]=Number.NaN}n.r(t),n.d(t,"pransacHomography",(function(){return i}))},function(e,t,n){"use strict";function i(e,t,n){const i=this.createTypedArray(e.dtype,t,e.byteOffset,e.length),s=n.map((t,n)=>this.createTypedArray(e.dtype,t,e.byteOffsetOfInputs[n],e.lengthOfInputs[n]));this[e.method](e,i,s)}function s(e,t,n,i,s={}){const r=i.length-1;if(3*r+3!==n.length||r<0)throw new Error("Can't run() routine with invalid input");const o=new Array(r),a=new Array(r),c=new Array(r),l=new Array(r);for(let e=3,t=0;t<r;t++,e+=3)o[t]=i[t+1],a[t]=n[e],c[t]=n[e+1],l[t]=n[e+2];const d={method:"",dtype:t,custom:s,rows:n[0],columns:n[1],stride:n[2],rowsOfInputs:a,columnsOfInputs:c,strideOfInputs:l,length:0,lengthOfInputs:[],byteOffset:0,byteOffsetOfInputs:[]};return null!=e&&e.call(this,d,i[0],o),d}function r(e,t,n,i,s={}){const r=i.length;if(n.length!==5*r)throw new Error("Can't runWithBlocks() with invalid input");const o=new Array(3*r),a=new Array(r);for(let e=0,t=0,s=0,c=0;c<r;c++,s+=3,e+=5)o[s+0]=n[e+1]-n[e+0]+1,o[s+1]=n[e+3]-n[e+2]+1,o[s+2]=t=n[e+4],a[c]=i[c].subarray(n[e+2]*t+n[e+0],n[e+3]*t+n[e+1]+1);return this.run(e,t,o,a,s)}function o(e,t,n){const i=t.custom.subroutine[e];for(let e=0,t=i.length;e<t;e++){const t=i[e],s=n[t.indexOfOutputMatrix],r=t.indicesOfInputMatrices.map(e=>n[e]);(0,this[t.header.method])(t.header,s,r)}}function a(e,...t){return this.MatrixType.createTypedArray(e,...t)}function c(e,t=0,n=e.length){let i,s=0,r=t+n;for(i=t;i<r;i++)s+=e[i]*e[i];return Math.sqrt(s)}function l(e,t,n=0,i=0,s=e.length){let r,o=0;for(r=0;r<s;r++)o+=e[n+r]*t[i+r];return o}function d(e,t=0,n=e.length){t=Math.max(t,0);for(let i,s,r=(n=Math.min(n,e.length))-1;r>t;r--)s=(Math.random()*(r+1-t)|0)+t,i=e[r],e[r]=e[s],e[s]=i;return e}function h(e){return Array.from({length:e},(e,t)=>t)}n.r(t),n.d(t,"execute",(function(){return i})),n.d(t,"run",(function(){return s})),n.d(t,"runWithBlocks",(function(){return r})),n.d(t,"subroutine",(function(){return o})),n.d(t,"createTypedArray",(function(){return a})),n.d(t,"norm2",(function(){return c})),n.d(t,"dot",(function(){return l})),n.d(t,"shuffle",(function(){return d})),n.d(t,"range",(function(){return h}))},function(e,t,n){"use strict";n.r(t),n.d(t,"Speedy",(function(){return Hs}));var i=n(1);var s=n(3),r=n(0);const o=Symbol();let a=null;class c extends class{constructor(){this._subscribers=[]}subscribe(e){this._subscribers.indexOf(e)<0&&this._subscribers.push(e)}unsubscribe(e){this._subscribers=this._subscribers.filter(t=>t!==e)}_notify(e){for(const t of this._subscribers)t(e)}}{constructor(e){if(i.a.assert(e===o),super(),"undefined"==typeof WebGL2RenderingContext)throw new r.i("This application requires WebGL2. Please use a different browser.");this._canvas=this._createCanvas(this._reinitialize.bind(this)),this._gl=this._createContext(this._canvas),this._reinitializeOnContextLoss=!0}static get instance(){return a||(a=new c(o))}get gl(){return this._gl}get canvas(){return this._canvas}_createCanvas(e){const t=i.a.createCanvas(2048,2048);return t.addEventListener("webglcontextlost",t=>{i.a.warning("Lost WebGL2 context"),setTimeout(e,0),t.preventDefault()},!1),t}_createContext(e){const t=e.getContext("webgl2",{premultipliedAlpha:!1,preserveDrawingBuffer:!1,alpha:!0,antialias:!1,depth:!1,stencil:!1});if(!t)throw new r.i("Can't create a WebGL2 Rendering Context. Try a different browser!");return t}_reinitialize(){this._reinitializeOnContextLoss&&(i.a.warning("Reinitializing WebGL2..."),this._canvas.remove(),this._canvas=this._createCanvas(this._reinitialize.bind(this)),this._gl=this._createContext(this._canvas),this._notify(this._gl))}loseContext(){const e=this._gl;if(e.isContextLost())return;const t=e.getExtension("WEBGL_lose_context");if(!t)throw new r.i("WEBGL_lose_context extension is unavailable");return this._reinitializeOnContextLoss=!1,t.loseContext(),t}loseAndRestoreContext(e=1){const t=1e3*Math.max(e,0),n=this.loseContext();return new s.a(e=>{setTimeout(()=>{this._reinitializeOnContextLoss=!0,this._reinitialize(),setTimeout(()=>e(n),0)},t)})}}var l=n(2);class d{constructor(e,t,n){this._gl=e,this._width=Math.max(1,0|t),this._height=Math.max(1,0|n),this._glTexture=d._createTexture(this._gl,this._width,this._height),this._hasMipmaps=!1}release(){const e=this._gl;if(null==this._glTexture)throw new r.g("The SpeedyTexture has already been released");return this.discardMipmaps(),e.deleteTexture(this._glTexture),this._glTexture=null,this._width=this._height=0,null}upload(e,t=this._width,n=this._height){return i.a.assert(t>0&&n>0),this.discardMipmaps(),this._width=t,this._height=n,d._upload(this._gl,this._glTexture,t,n,e,0),this}clear(){const e=this._gl;return e.isContextLost()||(e.bindTexture(e.TEXTURE_2D,this._glTexture),e.texImage2D(e.TEXTURE_2D,0,e.RGBA8,this._width,this._height,0,e.RGBA,e.UNSIGNED_BYTE,null),e.bindTexture(e.TEXTURE_2D,null),this.discardMipmaps()),this}resize(e,t){const n=this._gl;return this._width===e&&this._height===t?this:(e|=0,t|=0,i.a.assert(e>0&&t>0),n.isContextLost()||(this._width=e,this._height=t,n.bindTexture(n.TEXTURE_2D,this._glTexture),n.texImage2D(n.TEXTURE_2D,0,n.RGBA8,e,t,0,n.RGBA,n.UNSIGNED_BYTE,null),n.bindTexture(n.TEXTURE_2D,null),this.discardMipmaps()),this)}generateMipmaps(e=[]){const t=this._gl;if(this._hasMipmaps)return this;if(t.bindTexture(t.TEXTURE_2D,this._glTexture),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.NEAREST_MIPMAP_LINEAR),t.generateMipmap(t.TEXTURE_2D),t.bindTexture(t.TEXTURE_2D,null),e.length>0){const t=this.width,n=this.height,s=1+Math.floor(Math.log2(Math.max(t,n)));i.a.assert(e.length<=s);for(let s=1;s<e.length;s++){const r=Math.max(1,t>>>s),o=Math.max(1,n>>>s);i.a.assert(e[s].width===r&&e[s].height===o),e[s].copyTo(this,s)}}return this._hasMipmaps=!0,this}discardMipmaps(){const e=this._gl;this._hasMipmaps&&(e.bindTexture(e.TEXTURE_2D,this._glTexture),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),e.bindTexture(e.TEXTURE_2D,null),this._hasMipmaps=!1)}hasMipmaps(){return this._hasMipmaps}isReleased(){return null==this._glTexture}size(){return 4*this._width*this._height}get glTexture(){return this._glTexture}get width(){return this._width}get height(){return this._height}get gl(){return this._gl}static _createTexture(e,t,n){i.a.assert(t>0&&n>0);const s=e.createTexture();return e.bindTexture(e.TEXTURE_2D,s),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.MIRRORED_REPEAT),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.MIRRORED_REPEAT),e.texImage2D(e.TEXTURE_2D,0,e.RGBA8,t,n,0,e.RGBA,e.UNSIGNED_BYTE,null),e.bindTexture(e.TEXTURE_2D,null),s}static _upload(e,t,n,i,s,r=0){return e.bindTexture(e.TEXTURE_2D,t),e.texImage2D(e.TEXTURE_2D,r,e.RGBA8,n,i,0,e.RGBA,e.UNSIGNED_BYTE,s),e.bindTexture(e.TEXTURE_2D,null),t}}class h extends d{constructor(e,t,n){super(e,t,n),this._glFbo=h._createFramebuffer(e,this._glTexture)}release(){const e=this._gl;if(null==this._glFbo)throw new r.g("The SpeedyDrawableTexture has already been released");return e.deleteFramebuffer(this._glFbo),this._glFbo=null,super.release()}get glFbo(){return this._glFbo}copyTo(e,t=0){const n=this._gl;if(n.isContextLost())return;const s=1<<(t|=0),r=Math.max(1,Math.floor(e.width/s)),o=Math.max(1,Math.floor(e.height/s));i.a.assert(this._width===r&&this._height===o),h._copyToTexture(n,this._glFbo,e.glTexture,0,0,this._width,this._height,t)}clone(){const e=new d(this._gl,this._width,this._height);return this.copyTo(e),e}clear(){return this.clearToColor(0,0,0,0)}clearToColor(e,t,n,i){const s=this._gl;return s.isContextLost()||(e=Math.max(0,Math.min(+e,1)),t=Math.max(0,Math.min(+t,1)),n=Math.max(0,Math.min(+n,1)),i=Math.max(0,Math.min(+i,1)),this.discardMipmaps(),s.bindFramebuffer(s.FRAMEBUFFER,this._glFbo),s.viewport(0,0,this._width,this._height),s.clearColor(e,t,n,i),s.clear(s.COLOR_BUFFER_BIT),s.bindFramebuffer(s.FRAMEBUFFER,null)),this}static _createFramebuffer(e,t){const n=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,n),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0);const i=e.checkFramebufferStatus(e.FRAMEBUFFER);if(i!=e.FRAMEBUFFER_COMPLETE){const t=["FRAMEBUFFER_UNSUPPORTED","FRAMEBUFFER_INCOMPLETE_ATTACHMENT","FRAMEBUFFER_INCOMPLETE_DIMENSIONS","FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT","FRAMEBUFFER_INCOMPLETE_MULTISAMPLE"].filter(t=>e[t]===i)[0]||"unknown error";throw new r.e(`Can't create framebuffer: ${t} (${i})`)}return e.bindFramebuffer(e.FRAMEBUFFER,null),n}static _copyToTexture(e,t,n,i,s,r,o,a=0){return e.bindTexture(e.TEXTURE_2D,n),e.bindFramebuffer(e.FRAMEBUFFER,t),e.copyTexSubImage2D(e.TEXTURE_2D,a,0,0,i,s,r,o),e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindTexture(e.TEXTURE_2D,null),n}}var u=n(4);const p=Object.freeze({sampler2D:"uniform1i",float:"uniform1f",int:"uniform1i",uint:"uniform1ui",bool:"uniform1i",vec2:"uniform2f",vec3:"uniform3f",vec4:"uniform4f",ivec2:"uniform2i",ivec3:"uniform3i",ivec4:"uniform4i",uvec2:"uniform2ui",uvec3:"uniform3ui",uvec4:"uniform4ui",bvec2:"uniform2i",bvec3:"uniform3i",bvec4:"uniform4i",mat2:"uniformMatrix2fv",mat3:"uniformMatrix3fv",mat4:"uniformMatrix4fv"});class f extends Function{constructor(e,t,n={}){return super("...args","return this._self._call(...args)"),this._self=this.bind(this),this._self._init(e,t,n),this._self}_init(e,t,n){if(e.isContextLost())throw new r.g("Can't initialize SpeedyProgram: lost context");n=Object.assign({output:[1,1],renderToTexture:!0,pingpong:!1},n),this._gl=e,this._program=f._compile(e,t.vertexSource,t.fragmentSource),this._geometry=new m(e,{position:t.locationOfAttributes.position,texCoord:t.locationOfAttributes.texCoord}),this._argnames=t.arguments,this._argIsArray=new Array(this._argnames.length).fill(!1),this._ubo=null,this._renderToTexture=Boolean(n.renderToTexture),this._width=0|n.output[0],this._height=0|n.output[1],this._ownTexture=Array.from({length:n.pingpong?2:1},()=>new h(e,this._width,this._height)),this._texture=[].concat(this._ownTexture),this._textureIndex=0,this._uniform=new Map,e.useProgram(this._program);for(const n of t.uniforms){const i=t.uniformType(n),s=e.getUniformLocation(this._program,n);this._uniform.set(n,new _(i,s))}for(let e=0;e<this._argnames.length;e++){const t=this._argnames[e];if(!this._uniform.has(t)&&(this._argIsArray[e]=this._uniform.has(t+"[0]"),!this._argIsArray[e]))throw new r.g(`Expected uniform "${t}", as declared in the argument list`)}}_call(...e){const t=this._gl,n=this._argnames;if(e.length!=n.length)throw new r.f(`Can't run shader: incorrect number of arguments (expected ${n.length}, got ${e.length})`);const i=e.flat();for(let e=i.length-1;e>=0;e--)if(i[e]===this._texture[this._textureIndex])throw new r.i("Can't run shader: don't use its output texture as an input to itself. Consider using pingpong rendering!");if(t.isContextLost())return this._texture[this._textureIndex];t.useProgram(this._program),t.bindVertexArray(this._geometry.vao);const s=this._uniform.get("texSize");t.uniform2f(s.location,this.width,this.height);for(let i=0,s=0;i<e.length;i++){const o=n[i];if(this._argIsArray[i]){const n=e[i];if(this._uniform.has(`${o}[${n.length}]`))throw new r.f(`Can't run shader: too few elements in the "${o}" array`);for(let e=0,i=void 0;void 0!==(i=this._uniform.get(`${o}[${e}]`));e++)s=i.setValue(t,n[e],s)}else{s=this._uniform.get(o).setValue(t,e[i],s)}}null!==this._ubo&&this._ubo.update();const o=this._texture[this._textureIndex],a=this._renderToTexture?o.glFbo:null;return t.bindFramebuffer(t.FRAMEBUFFER,a),t.viewport(0,0,this.width,this.height),t.drawArrays(t.TRIANGLES,0,6),t.bindFramebuffer(t.FRAMEBUFFER,null),t.bindVertexArray(null),o.discardMipmaps(),this._pingpong(),o}outputs(e,t,...n){return this.setOutputTexture(...n),this.setOutputSize(e,t),this}setOutputSize(e,t){i.a.assert(e>0&&t>0),this._width=0|e,this._height=0|t;for(let e=0;e<this._texture.length;e++)null!=this._texture[e]&&this._texture[e].resize(this._width,this._height);return this}setOutputTexture(...e){const t=this._texture.length;i.a.assert(e.length===t,`Incorrect number of textures (expected ${t})`);const n=e.every(e=>null===e);return this._texture=n?this._ownTexture:e,this._textureIndex=0,this}clear(){const e=this._texture[this._textureIndex];for(let e=0;e<this._texture.length;e++)this._texture[e].clear();return this._pingpong(),e}setUBO(e,t){null===this._ubo&&(this._ubo=new g(this._gl,this._program)),this._ubo.set(e,t)}release(){const e=this._gl;null!=this._ubo&&(this._ubo=this._ubo.release());for(let e=0;e<this._ownTexture.length;e++)this._ownTexture[e]=this._ownTexture[e].release();return this._texture.fill(null),this._geometry=this._geometry.release(),e.deleteProgram(this._program),this._program=null,null}get width(){return this._width}get height(){return this._height}_pingpong(){this._texture.length>1&&(this._textureIndex=1-this._textureIndex)}static _compile(e,t,n){const i=e.createProgram(),s=e.createShader(e.VERTEX_SHADER),o=e.createShader(e.FRAGMENT_SHADER);if(e.shaderSource(s,t),e.compileShader(s),e.attachShader(i,s),e.shaderSource(o,n),e.compileShader(o),e.attachShader(i,o),e.linkProgram(i),e.validateProgram(i),!e.getProgramParameter(i,e.LINK_STATUS)&&!e.isContextLost()){const t=[e.getShaderInfoLog(o),e.getShaderInfoLog(s),e.getProgramInfoLog(i)];e.deleteProgram(i),e.deleteShader(o),e.deleteShader(s);const a=e=>Math.max(0,2-Math.floor(Math.log10(e))),c=e=>Array(a(e)).fill(" ").join("")+e+". ",l=n.split("\n").map((e,t)=>c(1+t)+e).join("\n");throw new r.e("Can't create shader.\n\n---------- ERROR ----------\n"+t.join("\n")+"\n\n---------- SOURCE CODE ----------\n"+l)}return i}}function m(e,t){return this.vao=e.createVertexArray(),this.vbo=Object.freeze({position:e.createBuffer(),texCoord:e.createBuffer()}),this._gl=e,e.bindVertexArray(this.vao),e.bindBuffer(e.ARRAY_BUFFER,this.vbo.position),e.bufferData(e.ARRAY_BUFFER,new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]),e.STATIC_DRAW),e.enableVertexAttribArray(t.position),e.vertexAttribPointer(t.position,2,e.FLOAT,!1,0,0),e.bindBuffer(e.ARRAY_BUFFER,this.vbo.texCoord),e.bufferData(e.ARRAY_BUFFER,new Float32Array([0,0,1,0,0,1,0,1,1,0,1,1]),e.STATIC_DRAW),e.enableVertexAttribArray(t.texCoord),e.vertexAttribPointer(t.texCoord,2,e.FLOAT,!1,0,0),e.bindBuffer(e.ARRAY_BUFFER,null),e.bindVertexArray(null),Object.freeze(this)}function _(e,t){if(this.type=String(e),!Object.prototype.hasOwnProperty.call(p,this.type))throw new r.i("Unsupported uniform type: "+this.type);this.location=t,this.setter=p[this.type];const n=0|Number(this.setter.match(/^uniform(Matrix)?(\d)/)[2]);return this.dim=this.type.startsWith("mat")?2:this.type.indexOf("vec")>=0|0,this.length=2==this.dim?n*n:n,Object.freeze(this)}function g(e,t){this._gl=e,this._program=t,this._nextIndex=0,this._ubo=Object.create(null)}m.prototype.release=function(){const e=this._gl;return e.deleteVertexArray(this.vao),e.deleteBuffer(this.vbo.position),e.deleteBuffer(this.vbo.texCoord),null},_.prototype.setValue=function(e,t,n){const i=e[this.setter];if("sampler2D"==this.type){if(n>e.MAX_COMBINED_TEXTURE_IMAGE_UNITS)throw new r.i(`Can't bind ${n} textures to a program: max is ${e.MAX_COMBINED_TEXTURE_IMAGE_UNITS}`);if(null==t)throw new r.f("Can't run shader: cannot use null as an input texture");e.activeTexture(e.TEXTURE0+n),e.bindTexture(e.TEXTURE_2D,t.glTexture),e.uniform1i(this.location,n),n++}else if("number"==typeof t||"boolean"==typeof t)i.call(e,this.location,t);else{if(!Array.isArray(t))throw new r.f(`Can't run shader: unrecognized argument "${t}"`);if(t.length!==this.length)throw new r.f(`Can't run shader: incorrect number of values for ${this.type}: "${t}"`);2==this.dim?i.call(e,this.location,!1,t):i.call(e,this.location,...t)}return n},g.prototype.set=function(e,t){const n=this._gl;void 0===this._ubo[e]&&(this._ubo[e]={buffer:n.createBuffer(),blockBindingIndex:this._nextIndex++,blockIndex:null,data:null});const i=this._ubo[e];if(null===i.blockIndex){const t=n.getUniformBlockIndex(this._program,e);n.uniformBlockBinding(this._program,t,i.blockBindingIndex),i.blockIndex=t}i.data=t},g.prototype.update=function(){const e=this._gl;for(const t in this._ubo){const n=this._ubo[t];e.bindBuffer(e.UNIFORM_BUFFER,n.buffer),e.bufferData(e.UNIFORM_BUFFER,n.data.byteLength,e.DYNAMIC_DRAW),e.bufferData(e.UNIFORM_BUFFER,n.data,e.DYNAMIC_DRAW),e.bindBufferBase(e.UNIFORM_BUFFER,n.blockBindingIndex,n.buffer),e.bindBuffer(e.UNIFORM_BUFFER,null)}},g.prototype.release=function(){const e=this._gl;for(const t in this._ubo){const n=this._ubo[t];e.deleteBuffer(n.buffer),n.data=null}return null};class x{constructor(e,t,n){this._gpu=e,this._width=t,this._height=n,this._helpers=null,this._programs=[]}declare(e,t,n={}){return Object.defineProperty(this,e,{get:(()=>{const i="__k_"+e;return function(){return this[i]||(this[i]=this._createProgram(t,n))}.bind(this)})()}),this}compose(e,...t){return Object.defineProperty(this,e,{get:(()=>{const n="__c_"+e;return function(){return this[n]||(this[n]=2==t.length?(()=>(t=t.map(e=>this[e]),function(e,...n){return t[1](t[0](e,...n),...n)}))():3==t.length?(()=>(t=t.map(e=>this[e]),function(e,...n){return t[2](t[1](t[0](e,...n),...n),...n)}))():4==t.length?(()=>(t=t.map(e=>this[e]),function(e,...n){return t[3](t[2](t[1](t[0](e,...n),...n),...n),...n)}))():(()=>(t=t.map(e=>this[e]),function(e,...n){return t.reduce((e,t)=>t(e,...n),e)}))())}.bind(this)})()}),this}get program(){return this._helpers||(this.helpers={hasTextureSize:(e,t)=>({output:[Math.max(1,0|e),Math.max(1,0|t)]}),rendersToCanvas:()=>({renderToTexture:!1}),usesPingpongRendering:()=>({pingpong:!0})})}release(){for(let e=0;e<this._programs.length;e++)this._programs[e].release();return null}_createProgram(e,t={}){const n=new f(this._gpu.gl,e,{output:[this._width,this._height],...t});return this._programs.push(n),n}}var y=n(5);const v=Object(u.b)("utils/identity.glsl").withArguments("image"),w=Object(u.b)("utils/flip-y.glsl").withArguments("image"),S=Object(u.b)("utils/fill.glsl").withArguments("value"),b=Object(u.b)("utils/fill-components.glsl").withArguments("image","pixelComponents","value"),P=Object(u.b)("utils/copy-components.glsl").withArguments("dest","src","destComponents","srcComponentId"),A=Object(u.b)("utils/scan-minmax2d.glsl").withArguments("image","iterationNumber");class E extends x{constructor(e,t,n){super(e,t,n),this.declare("identity",v).declare("_renderToCanvas",w,{...this.program.rendersToCanvas()}).declare("flipY",w).declare("fill",S).declare("fillComponents",b).declare("_copyComponents",P).declare("_scanMinMax2D",A,{...this.program.usesPingpongRendering()})}renderToCanvas(e){const t=e.width,n=e.height,s=this._gpu.canvas;return t==this._renderToCanvas.width&&n==this._renderToCanvas.height||this._renderToCanvas.setOutputSize(t,n),(t>s.width||n>s.height)&&(i.a.warning(`Resizing the canvas to ${t} x ${n}`),s.width=t,s.height=n),this._renderToCanvas(e),s}scanMax(e,t){const n=this._scanMinMax(e,t);return this.copyComponents(e,n,t,y.e.RED)}scanMin(e,t){const n=this._scanMinMax(e,t);return this.copyComponents(e,n,t,y.e.GREEN)}copyComponents(e,t,n,i){if(!Object.prototype.hasOwnProperty.call(y.a,i))throw new r.f("Invalid srcComponent: "+i);const s=y.a[i];return this._copyComponents(e,t,n,s)}_scanMinMax(e,t){const n=0|Math.ceil(Math.log2(Math.max(this._width,this._height)));let i=this.copyComponents(e,e,y.e.ALL,t);for(let e=0;e<n;e++)i=this._scanMinMax2D(i,e);return i}}const I=Object(u.b)("colors/rgb2grey.glsl").withArguments("image");class O extends x{constructor(e,t,n){super(e,t,n),this.declare("rgb2grey",I)}}var M=n(6);const k=[3,5,7].reduce((e,t)=>(e[t]=Object(u.b)("filters/convolution2d.glsl").withDefines({KERNEL_SIZE_SQUARED:t*t}).withArguments("image","kernel"),e),{}),X=[3,5,7,9,11,13,15].reduce((e,t)=>(e[t]=Object(u.b)("filters/convolution1d.glsl").withDefines({KERNEL_SIZE:t,AXIS:0}).withArguments("image","kernel"),e),{}),L=[3,5,7,9,11,13,15].reduce((e,t)=>(e[t]=Object(u.b)("filters/convolution1d.glsl").withDefines({KERNEL_SIZE:t,AXIS:1}).withArguments("image","kernel"),e),{}),z=[3,5,7].reduce((e,t)=>(e[t]=Object(u.b)("filters/fast-median.glsl").withDefines({KERNEL_SIZE:t}).withArguments("image"),e),{}),T=e=>Math.max(1,e/6);class R extends x{constructor(e,t,n){super(e,t,n),this.compose("gauss3","_gauss3x","_gauss3y").compose("gauss5","_gauss5x","_gauss5y").compose("gauss7","_gauss7x","_gauss7y").compose("gauss9","_gauss9x","_gauss9y").compose("gauss11","_gauss11x","_gauss11y").compose("box3","_box3x","_box3y").compose("box5","_box5x","_box5y").compose("box7","_box7x","_box7y").compose("box9","_box9x","_box9y").compose("box11","_box11x","_box11y").declare("median3",z[3]).declare("median5",z[5]).declare("median7",z[7]).declare("convolution3",k[3]).declare("convolution5",k[5]).declare("convolution7",k[7]).declare("convolution3x",X[3]).declare("convolution3y",L[3]).declare("convolution5x",X[5]).declare("convolution5y",L[5]).declare("convolution7x",X[7]).declare("convolution7y",L[7]).declare("convolution9x",X[9]).declare("convolution9y",L[9]).declare("convolution11x",X[11]).declare("convolution11y",L[11]).declare("convolution13x",X[13]).declare("convolution13y",L[13]).declare("convolution15x",X[15]).declare("convolution15y",L[15]).declare("_gauss3x",Object(M.convX)([.25,.5,.25])).declare("_gauss3y",Object(M.convY)([.25,.5,.25])).declare("_gauss5x",Object(M.convX)([.05,.25,.4,.25,.05])).declare("_gauss5y",Object(M.convY)([.05,.25,.4,.25,.05])).declare("_gauss7x",Object(M.convX)(i.a.gaussianKernel(T(7),7))).declare("_gauss7y",Object(M.convY)(i.a.gaussianKernel(T(7),7))).declare("_gauss9x",Object(M.convX)(i.a.gaussianKernel(T(9),9))).declare("_gauss9y",Object(M.convY)(i.a.gaussianKernel(T(9),9))).declare("_gauss11x",Object(M.convX)(i.a.gaussianKernel(T(11),11))).declare("_gauss11y",Object(M.convY)(i.a.gaussianKernel(T(11),11))).declare("_box3x",Object(M.convX)(new Array(3).fill(1/3))).declare("_box3y",Object(M.convY)(new Array(3).fill(1/3))).declare("_box5x",Object(M.convX)(new Array(5).fill(.2))).declare("_box5y",Object(M.convY)(new Array(5).fill(.2))).declare("_box7x",Object(M.convX)(new Array(7).fill(1/7))).declare("_box7y",Object(M.convY)(new Array(7).fill(1/7))).declare("_box9x",Object(M.convX)(new Array(9).fill(1/9))).declare("_box9y",Object(M.convY)(new Array(9).fill(1/9))).declare("_box11x",Object(M.convX)(new Array(11).fill(1/11))).declare("_box11y",Object(M.convY)(new Array(11).fill(1/11)))}}class N extends class{constructor(){}get data(){return null}get size(){return 0}}{constructor(e){super(),this._data=e,this._size=e.length}get data(){return this._data}get size(){return this._size}}const K=new Uint8Array([]);class D{constructor(e,t,n=0,i=0,s=0,r=0,o=null,a=null){this._x=+e,this._y=+t,this._lod=+n,this._rotation=+i,this._score=+s,this._scale=Math.pow(2,+n),this._flags=0|r,this._extraBytes=o||K,this._descriptorBytes=a||K}toString(){return`(${this._x},${this._y})`}get x(){return this._x}get y(){return this._y}get lod(){return this._lod}get scale(){return this._scale}get rotation(){return this._rotation}get score(){return this._score}get flags(){return this._flags}}class C extends D{constructor(e,t){super(e._x,e._y,e._lod,e._rotation,e._score,e._flags,e._extraBytes,e._descriptorBytes),this._descriptor=t(this._descriptorBytes)}get descriptor(){return this._descriptor}}const F=Math.ceil(Math.sqrt(l.m/4));class j{static minLength(e,t,n){const i=Math.ceil((l.m+t+n)/4),s=Math.max(0,Math.ceil(e)),r=Math.ceil(Math.sqrt(s*i));return Math.max(F,Math.min(r,300))}static capacity(e,t,n){const i=Math.ceil((l.m+e+t)/4),s=n*n;return Math.floor(s/i)}static decode(e,t,n,i){const s=Math.ceil((l.m+t+n)/4);let r,o,a,c,d,h,u,p,f,m;const _=[],g=i*i*s*4,x=Math.min(e.length,g);t+n>0&&(e=new Uint8Array(e));for(let i=0;i<x&&(r=e[i+1]<<8|e[i],o=e[i+3]<<8|e[i+2],!(r>=65535&&o>=65535));i+=4*s)r+o==0&&0==e[i+6]||(r/=l.b,o/=l.b,h=e[i+7],f=e[i+4]<255,a=f?-l.h+(l.h+l.n)*e[i+4]/255:0,m=h&0!=l.f,c=m?(2*e[i+5]/255-1)*Math.PI:0,d=e[i+6]/255,u=e.subarray(8+i,8+i+n),p=e.subarray(8+i+n,8+i+n+t),p.length<t||u.length<n||_.push(new D(r,o,a,c,d,h,u,p)));return _}}const B=Object(u.b)("keypoints/fast.glsl").withDefines({FAST_TYPE:916}).withArguments("corners","pyramid","lod","threshold"),$=Object(u.b)("keypoints/score-8bits.glsl").withDefines({METHOD:0}).withArguments("corners"),U=[1,3,5,7].reduce((e,t)=>(e[t]=Object(u.b)("keypoints/harris.glsl").withDefines({WINDOW_SIZE:t}).withArguments("corners","derivatives","lod"),e),{}),H=Object(u.b)("keypoints/harris-derivatives.glsl").withArguments("pyramid","lod"),G=Object(u.b)("keypoints/score-findmax.glsl").withArguments("corners","iterationNumber"),q=Object(u.b)("keypoints/harris-cutoff.glsl").withArguments("corners","maxScore","quality"),W=Object(u.b)("keypoints/score-8bits.glsl").withDefines({METHOD:1}).withArguments("corners"),Y=Object(u.b)("keypoints/orb-descriptor.glsl").withArguments("pyramid","encodedCorners","extraSize","encoderLength"),Q=Object(u.b)("keypoints/orb-orientation.glsl").withArguments("pyramid","encodedKeypoints","descriptorSize","extraSize","encoderLength"),Z=Object(u.b)("keypoints/nonmax-suppression.glsl").withDefines({MULTISCALE:0}).withArguments("image","lodStep"),V=Object(u.b)("keypoints/nonmax-suppression.glsl").withDefines({MULTISCALE:1}).withArguments("image","lodStep"),J=Object(u.b)("keypoints/sort-createperm.glsl").withArguments("encodedKeypoints","descriptorSize","extraSize","encoderLength"),ee=Object(u.b)("keypoints/sort-mergeperm.glsl").withArguments("permutation","blockSize","dblLog2BlockSize"),te=Object(u.b)("keypoints/sort-applyperm.glsl").withArguments("permutation","maxKeypoints","encodedKeypoints","descriptorSize","extraSize"),ne=Object(u.b)("keypoints/expand-encoder.glsl").withArguments("encodedKeypoints","inputDescriptorSize","inputExtraSize","inputEncoderLength","outputDescriptorSize","outputExtraSize","outputEncoderLength"),ie=Object(u.b)("keypoints/transfer-orientation.glsl").withArguments("encodedOrientations","encodedKeypoints","descriptorSize","extraSize","encoderLength"),se=Object(u.b)("keypoints/suppress-descriptors.glsl").withArguments("encodedKeypoints","descriptorSize","extraSize","encoderLength","suppressedEncoderLength"),re=Object(u.b)("keypoints/upload-keypoints.glsl").withDefines({BUFFER_SIZE:1024}).withArguments("encodedKeypoints","startIndex","endIndex","descriptorSize","extraSize","encoderLength"),oe=Object(u.b)("keypoints/mix-keypoints.glsl").withArguments("encodedKeypoints","encoderLength","encoderCapacity","descriptorSize","extraSize","outEncoderLength"),ae=Object(u.b)("keypoints/fast/fast9.glsl").withArguments("image","threshold"),ce=Object(u.b)("keypoints/fast/fast7.glsl").withArguments("image","threshold"),le=Object(u.b)("keypoints/fast/fast5.glsl").withArguments("image","threshold"),de=Object(u.b)("keypoints/fast/fast-score16.glsl").withArguments("image","threshold"),he=Object(u.b)("keypoints/fast/fast-score12.glsl").withArguments("image","threshold"),ue=Object(u.b)("keypoints/fast/fast-score8.glsl").withArguments("image","threshold"),pe=Object(u.b)("keypoints/fast/multiscale-fast.glsl").withArguments("pyramid","threshold","numberOfLayers","lodStep"),fe=$,me=Object(u.b)("keypoints/harris/multiscale-harris.glsl").withDefines({MAX_LAYERS:2*l.n-1}).withArguments("pyramid","windowSize","numberOfLayers","lodStep","sobelDerivatives"),_e=q,ge=Object(u.b)("keypoints/harris/encode-harris-score.glsl").withArguments("image"),xe=G,ye=Object(u.b)("keypoints/harris/multiscale-sobel.glsl").withArguments("pyramid","lod"),ve=Object(u.b)("keypoints/brisk.glsl").withArguments("image","layerA","layerB","scaleA","scaleB","lgM","h");class we extends x{constructor(e,t,n){super(e,t,n),this.declare("fast9_16",B,{...this.program.usesPingpongRendering()}).declare("fastScoreTo8bits",$).declare("harris1",U[1],{...this.program.usesPingpongRendering()}).declare("harris3",U[3],{...this.program.usesPingpongRendering()}).declare("harris5",U[5],{...this.program.usesPingpongRendering()}).declare("harris7",U[7],{...this.program.usesPingpongRendering()}).declare("harrisDerivatives",H).declare("harrisScoreFindMax",G,{...this.program.usesPingpongRendering()}).declare("harrisScoreCutoff",q).declare("harrisScoreTo8bits",W).declare("orbDescriptor",Y).declare("orbOrientation",Q).declare("nonmax",Z).declare("pyrnonmax",V).declare("sortCreatePermutation",J).declare("sortMergePermutation",ee,{...this.program.usesPingpongRendering()}).declare("sortApplyPermutation",te).declare("expandEncoder",ne).declare("transferOrientation",ie).declare("suppressDescriptors",se).declare("uploadKeypoints",re,{...this.program.usesPingpongRendering()}).declare("mixKeypoints",oe).compose("fast9","_fast9","_fastScore16").declare("_fast9",ae).declare("_fastScore16",de).compose("fast7","_fast7","_fastScore12").declare("_fast7",ce).declare("_fastScore12",he).compose("fast5","_fast5","_fastScore8").declare("_fast5",le).declare("_fastScore8",ue).declare("multiscaleFast",pe).declare("encodeFastScore",fe).declare("brisk",ve).declare("multiscaleHarris",me).declare("harrisCutoff",_e).declare("encodeHarrisScore",ge).declare("maxHarrisScore",xe,{...this.program.usesPingpongRendering()}).declare("multiscaleSobel",ye).declare("_nonMaxSuppression",Z).declare("_multiscaleNonMaxSuppression",V)}nonMaxSuppression(e,t=0){return t>0?this._multiscaleNonMaxSuppression(e,t):this._nonMaxSuppression(e,0)}orbOld(e,t,n,s,r){return i.a.assert(32===n),this.orbDescriptor.setOutputSize(r,r),this.orbDescriptor(e,t,s,r)}orbOrientationOld(e,t,n,i,s){const r=j.capacity(n,i,s),o=Math.max(1,Math.ceil(Math.sqrt(r)));this.orbOrientation.setOutputSize(o,o);const a=this.orbOrientation(e,t,n,i,s);return this.transferOrientation.setOutputSize(s,s),this.transferOrientation(a,t,n,i,s)}suppressDescriptorsOld(e,t,n,s,r){return i.a.assert(r<=s),this.suppressDescriptors.setOutputSize(r,r),this.suppressDescriptors(e,t,n,s,r)}}const Se=navigator.userAgent.includes("Firefox");class be{static getError(e){const t=e.getError(),n=["NO_ERROR","INVALID_ENUM","INVALID_VALUE","INVALID_OPERATION","INVALID_FRAMEBUFFER_OPERATION","OUT_OF_MEMORY","CONTEXT_LOST_WEBGL"].find(n=>e[n]==t)||"Unknown";return new r.e(n)}static clientWaitAsync(e,t,n=0){return this._checkStatus=this._checkStatus||(this._checkStatus=function e(t,n,s,r,o){const a=t.clientWaitSync(n,s,0);a==t.TIMEOUT_EXPIRED?i.a.setZeroTimeout(()=>e.call(this,t,n,s,r,o)):a==t.WAIT_FAILED?Se&&t.getError()==t.NO_ERROR?i.a.setZeroTimeout(()=>e.call(this,t,n,s,r,o)):o(be.getError(t)):r()}),new s.a((i,s)=>{this._checkStatus(e,t,n,i,s)})}static getBufferSubDataAsync(e,t,n,i,s,o=0,a=0){const c=e.fenceSync(e.SYNC_GPU_COMMANDS_COMPLETE,0),l=performance.now();return e.flush(),be.clientWaitAsync(e,c).then(()=>(e.bindBuffer(n,t),e.getBufferSubData(n,i,s,o,a),e.bindBuffer(n,null),performance.now()-l)).catch(e=>{throw new r.g("Can't getBufferSubDataAsync(): error in clientWaitAsync()",e)}).finally(()=>{e.deleteSync(c)})}}class Pe{constructor(e=1){i.a.assert(e>0),this._pixelBuffer=new Array(e).fill(null).map(()=>new Uint8Array(0)),this._consumerQueue=new Array(e).fill(0).map((e,t)=>t),this._producerQueue=[]}readPixelsSync(e,t=0,n=0,i=e.width,s=e.height){const r=e.gl,o=e.glFbo;i=Math.max(0,Math.min(i,e.width)),s=Math.max(0,Math.min(s,e.height)),t=Math.max(0,Math.min(t,e.width-i)),n=Math.max(0,Math.min(n,e.height-s));const a=i*s*4;return this._reallocate(a),r.isContextLost()||(r.bindFramebuffer(r.FRAMEBUFFER,o),r.readPixels(t,n,i,s,r.RGBA,r.UNSIGNED_BYTE,this._pixelBuffer[0]),r.bindFramebuffer(r.FRAMEBUFFER,null)),this._pixelBuffer[0].subarray(0,a)}readPixelsAsync(e,t=!1,n=0,i=0,r=e.width,o=e.height){const a=e.gl,c=e.glFbo;r=Math.max(0,Math.min(r,e.width)),o=Math.max(0,Math.min(o,e.height)),n=Math.max(0,Math.min(n,e.width-r)),i=Math.max(0,Math.min(i,e.height-o));const l=r*o*4;if(this._reallocate(l),a.isContextLost())return s.a.resolve(this._pixelBuffer[0].subarray(0,l));if(!t)return Pe._readPixelsViaPBO(a,this._pixelBuffer[0],c,n,i,r,o).then(()=>this._pixelBuffer[0].subarray(0,l));if(this._producerQueue.length>0){const e=this._producerQueue.shift();Pe._readPixelsViaPBO(a,this._pixelBuffer[e],c,n,i,r,o).then(()=>{this._consumerQueue.push(e)})}else this._waitForQueueNotEmpty(this._producerQueue).then(()=>{const e=this._producerQueue.shift();Pe._readPixelsViaPBO(a,this._pixelBuffer[e],c,n,i,r,o).then(()=>{this._consumerQueue.push(e)})}).turbocharge();if(this._consumerQueue.length>0){const e=this._consumerQueue.shift();return new s.a(t=>{t(this._pixelBuffer[e].subarray(0,l)),this._producerQueue.push(e)})}return new s.a(e=>{this._waitForQueueNotEmpty(this._consumerQueue).then(()=>{const t=this._consumerQueue.shift();e(this._pixelBuffer[t].subarray(0,l)),this._producerQueue.push(t)}).turbocharge()})}_reallocate(e){if(!(e<=this._pixelBuffer[0].byteLength))for(let t=0;t<this._pixelBuffer.length;t++){const n=new Uint8Array(e);n.set(this._pixelBuffer[t]),this._pixelBuffer[t]=n}}_waitForQueueNotEmpty(e){return new s.a(t=>{!function n(){e.length>0?t():setTimeout(n,0)}()})}static _readPixelsViaPBO(e,t,n,i,s,o,a){const c=e.createBuffer();if(!(t.byteLength>=o*a*4))throw new r.f("Can't read pixels: invalid buffer size");return e.bindBuffer(e.PIXEL_PACK_BUFFER,c),e.bufferData(e.PIXEL_PACK_BUFFER,t.byteLength,e.STREAM_READ),e.bindFramebuffer(e.FRAMEBUFFER,n),e.readPixels(i,s,o,a,e.RGBA,e.UNSIGNED_BYTE,0),e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindBuffer(e.PIXEL_PACK_BUFFER,null),be.getBufferSubDataAsync(e,c,e.PIXEL_PACK_BUFFER,0,t,0,0).catch(e=>{throw new r.g("Can't read pixels",e)}).finally(()=>{e.deleteBuffer(c)})}}const Ae=l.m/4,Ee=[32,32],Ie=Object(u.b)("encoders/encode-keypoint-offsets.glsl").withArguments("corners","imageSize").withDefines({MAX_ITERATIONS:Ee[0]}),Oe=Object(u.b)("encoders/encode-keypoint-long-offsets.glsl").withArguments("offsetsImage","imageSize").withDefines({MAX_ITERATIONS:Ee[1]}),Me=Object(u.b)("encoders/encode-keypoints.glsl").withArguments("offsetsImage","imageSize","passId","numPasses","keypointLimit","encodedKeypoints","descriptorSize","extraSize","encoderLength"),ke=Object(u.b)("encoders/encode-null-keypoints.glsl"),Xe=Object(u.b)("encoders/resize-encoded-keypoints.glsl").withArguments("inputTexture","inputDescriptorSize","inputExtraSize","inputEncoderLength","outputDescriptorSize","outputExtraSize","outputEncoderLength"),Le=Object(u.b)("utils/identity.glsl").withArguments("image"),ze=Object(u.b)("encoders/upload-keypoints.glsl").withArguments("keypointCount","descriptorSize","extraSize","encoderLength").withDefines({KEYPOINT_BUFFER_LENGTH:1024});class Te extends x{constructor(e,t,n){super(e,t,n),this.declare("_encodeKeypointSkipOffsets",Ie).declare("_encodeKeypointLongSkipOffsets",Oe,{...this.program.usesPingpongRendering()}).declare("_encodeKeypoints",Me,{...this.program.hasTextureSize(l.c,l.c),...this.program.usesPingpongRendering()}).declare("_encodeNullKeypoints",ke,{...this.program.hasTextureSize(l.c,l.c)}).declare("_resizeEncodedKeypoints",Xe,{...this.program.hasTextureSize(l.c,l.c)}).declare("_downloadEncodedKeypoints",Le,{...this.program.hasTextureSize(l.c,l.c)}).declare("uploadKeypoints",ze,{...this.program.hasTextureSize(l.c,l.c)}),this._textureReader=new Pe,this._uploadBuffer=null}encodeKeypoints(e,t,n,i){const s=[this._width,this._height];let r=this._encodeKeypointSkipOffsets(e,s);for(let e=0;e<2;e++)r=this._encodeKeypointLongSkipOffsets(r,s);const o=l.j,a=Ae,c=j.capacity(t,n,i),d=Math.max(1,Math.ceil(Math.sqrt(c*a)));this._encodeKeypoints.setOutputSize(d,d);let h=this._encodeKeypoints.clear();for(let e=0;e<8;e++)h=this._encodeKeypoints(r,s,e,8,o,h,0,0,d);return this._resizeEncodedKeypoints.setOutputSize(i,i),this._resizeEncodedKeypoints(h,0,0,d,t,n,i)}downloadEncodedKeypoints(e,t=!0){return e instanceof h||(this._downloadEncodedKeypoints.setOutputSize(e.width,e.height),e=this._downloadEncodedKeypoints(e)),this._textureReader.readPixelsAsync(e,t).catch(e=>new r.g("Can't download the encoded keypoint texture",e))}uploadKeypointsOld(e,t,n,s){const o=e.length;if(o>1024)throw new r.i(`Can't upload ${o} keypoints: maximum is currently 1024`);if(s<j.minLength(o,t,n)&&i.a.warning(`Insufficient encoderLength (${s}) for ${e.length} keypoints (descriptorSize: ${t}, extraSize: ${n})`),null===this._uploadBuffer){const e=4*Float32Array.BYTES_PER_ELEMENT,t=new ArrayBuffer(1024*e);i.a.assert(t.byteLength<=16384),this._uploadBuffer=new Float32Array(t)}for(let t=0;t<o;t++){const n=e[t],i=4*t;this._uploadBuffer[i]=+n.x||0,this._uploadBuffer[i+1]=+n.y||0,this._uploadBuffer[i+2]=+n.lod||0,this._uploadBuffer[i+3]=+n.score||0}return this.uploadKeypoints.setOutputSize(s,s),this.uploadKeypoints.setUBO("KeypointBuffer",this._uploadBuffer),this.uploadKeypoints(o,t,n,s)}}const Re=Object(u.b)("pyramids/upsample2.glsl").withArguments("image"),Ne=Object(u.b)("pyramids/downsample2.glsl").withArguments("image");class Ke extends x{constructor(e,t,n){super(e,t,n),this.declare("upsample2",Re,{...this.program.hasTextureSize(2*this._width,2*this._height)}).declare("downsample2",Ne,{...this.program.hasTextureSize(Math.max(1,Math.floor(this._width/2)),Math.max(1,Math.floor(this._height/2)))}).declare("smoothX",Object(M.convX)([.05,.25,.4,.25,.05])).declare("smoothY",Object(M.convY)([.05,.25,.4,.25,.05])).declare("smoothX2",Object(M.convX)([.1,.5,.8,.5,.1]),{...this.program.hasTextureSize(2*this._width,2*this._height)}).declare("smoothY2",Object(M.convY)([.1,.5,.8,.5,.1],.5),{...this.program.hasTextureSize(2*this._width,2*this._height)}).compose("_reduce","_smoothX","_smoothY","_downsample2").compose("_expand","_upsample2","_smoothX2","_smoothY2").declare("_smoothX",Object(M.convX)([.05,.25,.4,.25,.05])).declare("_smoothY",Object(M.convY)([.05,.25,.4,.25,.05])).declare("_smoothX2",Object(M.convX)([.1,.5,.8,.5,.1]),{...this.program.hasTextureSize(2*this._width,2*this._height)}).declare("_smoothY2",Object(M.convY)([.1,.5,.8,.5,.1],.5),{...this.program.hasTextureSize(2*this._width,2*this._height)}).declare("_upsample2",Re,{...this.program.hasTextureSize(2*this._width,2*this._height)}).declare("_downsample2",Ne,{...this.program.hasTextureSize(Math.max(1,Math.floor(this._width/2)),Math.max(1,Math.floor(this._height/2)))})}reduce(e){return this._reduce(e)}expand(e){return this._expand(e)}}const De=Object(u.b)("enhancements/normalize-image.glsl").withArguments("minmax2d","minValue","maxValue").withDefines({GREYSCALE:1}),Ce=Object(u.b)("enhancements/normalize-image.glsl").withArguments("minmax2dRGB","minValue","maxValue"),Fe=Object(u.b)("enhancements/nightvision.glsl").withArguments("image","illuminationMap","gain","offset","decay"),je=Object(u.b)("enhancements/nightvision.glsl").withArguments("image","illuminationMap","gain","offset","decay").withDefines({GREYSCALE:1});class Be extends x{constructor(e,t,n){super(e,t,n),this.declare("_normalizeGreyscaleImage",De).declare("_normalizeColoredImage",Ce).declare("_nightvision",Fe).declare("_nightvisionGreyscale",je).compose("_illuminationMapLo","_illuminationMapLoX","_illuminationMapLoY").declare("_illuminationMapLoX",Object(M.convX)(i.a.gaussianKernel(80,31))).declare("_illuminationMapLoY",Object(M.convY)(i.a.gaussianKernel(80,31))).compose("_illuminationMap","_illuminationMapX","_illuminationMapY").declare("_illuminationMapX",Object(M.convX)(i.a.gaussianKernel(80,63))).declare("_illuminationMapY",Object(M.convY)(i.a.gaussianKernel(80,63))).compose("_illuminationMapHi","_illuminationMapHiX","_illuminationMapHiY").declare("_illuminationMapHiX",Object(M.convX)(i.a.gaussianKernel(80,255))).declare("_illuminationMapHiY",Object(M.convY)(i.a.gaussianKernel(80,255)))}normalizeGreyscaleImage(e,t=0,n=255){const i=this._gpu.programs.utils._scanMinMax(e,y.e.GREEN);return this._normalizeGreyscaleImage(i,Math.min(t,n),Math.max(t,n))}normalizeColoredImage(e,t=0,n=255){const i=this._gpu,s=new Array(3);s[0]=i.programs.utils._scanMinMax(e,y.e.RED).clone(),s[1]=i.programs.utils._scanMinMax(e,y.e.GREEN).clone(),s[2]=i.programs.utils._scanMinMax(e,y.e.BLUE);const r=this._normalizeColoredImage(s,Math.min(t,n),Math.max(t,n));return s[1].release(),s[0].release(),r}nightvision(e,t=.5,n=.5,i=0,s="medium",o=!1){let a=null;if("medium"==s)a=this._illuminationMap(e);else if("high"==s)a=this._illuminationMapHi(e);else{if("low"!=s)throw new r.f(`Invalid quality level for nightvision: "${s}"`);a=this._illuminationMapLo(e)}return(o?this._nightvisionGreyscale:this._nightvision)(e,a,t,n,i)}}const $e=Object(u.b)("trackers/lk.glsl").withArguments("encodedFlow","prevKeypoints","nextPyramid","prevPyramid","windowSize","level","depth","numberOfIterations","discardThreshold","epsilon","descriptorSize","extraSize","encoderLength").withDefines({MAX_WINDOW_SIZE:21}),Ue=Object(u.b)("trackers/lk.glsl").withArguments("encodedFlow","prevKeypoints","nextPyramid","prevPyramid","windowSize","level","depth","numberOfIterations","discardThreshold","epsilon","descriptorSize","extraSize","encoderLength").withDefines({MAX_WINDOW_SIZE:15}),He=Object(u.b)("trackers/lk.glsl").withArguments("encodedFlow","prevKeypoints","nextPyramid","prevPyramid","windowSize","level","depth","numberOfIterations","discardThreshold","epsilon","descriptorSize","extraSize","encoderLength").withDefines({MAX_WINDOW_SIZE:11}),Ge=Object(u.b)("trackers/lk.glsl").withArguments("encodedFlow","prevKeypoints","nextPyramid","prevPyramid","windowSize","level","depth","numberOfIterations","discardThreshold","epsilon","descriptorSize","extraSize","encoderLength").withDefines({MAX_WINDOW_SIZE:7}),qe=Object(u.b)("trackers/lk-discard-old.glsl").withArguments("pyramid","encodedKeypoints","windowSize","discardThreshold","descriptorSize","extraSize","encoderLength"),We=Object(u.b)("trackers/lk-discard.glsl").withArguments("pyramid","windowSize","encodedKeypoints","descriptorSize","extraSize","encoderLength"),Ye=Object(u.b)("trackers/transfer-flow.glsl").withArguments("encodedFlow","encodedKeypoints","descriptorSize","extraSize","encoderLength");class Qe extends x{constructor(e,t,n){super(e,t,n),this.declare("lk21",$e,{...this.program.usesPingpongRendering()}).declare("lk15",Ue,{...this.program.usesPingpongRendering()}).declare("lk11",He,{...this.program.usesPingpongRendering()}).declare("lk7",Ge,{...this.program.usesPingpongRendering()}).declare("lkDiscard",We).declare("transferFlow",Ye).declare("_lk",$e,{...this.program.usesPingpongRendering()}).declare("_lkSmall",Ue,{...this.program.usesPingpongRendering()}).declare("_lkSmaller",He,{...this.program.usesPingpongRendering()}).declare("_lkSmallest",Ge,{...this.program.usesPingpongRendering()}).declare("_lkDiscard",qe).declare("_transferFlow",Ye)}lk(e,t,n,i,s,r,o,a,c,d,h){const u=l.n;s=Math.max(1,Math.min(0|s,u)),i+=(i+1)%2,i=Math.max(5,Math.min(i,21)),r=Math.max(1,r);let p=null;p=i<=7?this._lkSmallest:i<=11?this._lkSmaller:i<=15?this._lkSmall:this._lk;const f=j.capacity(c,d,h),m=Math.max(1,Math.ceil(Math.sqrt(f)));p.setOutputSize(m,m);let _=p.clear();for(let l=s-1;l>=0;l--)_=p(_,n,e,t,i,l,s,r,o,a,c,d,h);this._transferFlow.setOutputSize(h,h);const g=this._transferFlow(_,n,c,d,h);return this._lkDiscard.setOutputSize(h,h),this._lkDiscard(e,g,i,o,c,d,h)}}const Ze=Object(u.b)("transforms/warp-perspective.glsl").withArguments("image","inverseHomography"),Ve=Object(u.b)("transforms/resize.glsl").withDefines({INTERPOLATION_METHOD:0}).withArguments("image"),Je=Object(u.b)("transforms/resize.glsl").withDefines({INTERPOLATION_METHOD:1}).withArguments("image");class et extends x{constructor(e,t,n){super(e,t,n),this.declare("_warpPerspective",Ze).declare("resizeNN",Ve).declare("resizeBI",Je)}warpPerspective(e,t){if(!Array.isArray(t)||9!=t.length)throw new r.f("Not a homography: "+t);const n=this._inverse3(t);return Number.isNaN(n[0])?this._warpPerspective(e,[0,0,0,0,0,0,0,0,1]):this._warpPerspective(e,n)}_inverse3(e){const t=Number.NaN,n=[t,t,t,t,t,t,t,t,t],i=e[0],s=e[1],r=e[2],o=e[3],a=e[4],c=e[5],l=e[6],d=e[7],h=e[8],u=h*a-c*d,p=h*o-c*l,f=d*o-a*l,m=i*u-s*p+r*f;if(!(Math.abs(m)<1e-6)){const e=1/m;n[0]=u*e,n[1]=-(h*s-r*d)*e,n[2]=(c*s-r*a)*e,n[3]=-p*e,n[4]=(h*i-r*l)*e,n[5]=-(c*i-r*o)*e,n[6]=f*e,n[7]=-(d*i-s*l)*e,n[8]=(a*i-s*o)*e}return n}}class tt{constructor(e,t,n){this._gpu=e,this._width=t,this._height=n,this._utils=null,this._colors=null,this._filters=null,this._keypoints=null,this._encoders=null,this._descriptors=null,this._enhancements=null,this._trackers=null,this._transforms=null,this._pyramids=new Array(l.n).fill(null)}get width(){return this._width}get height(){return this._height}get utils(){return this._utils||(this._utils=new E(this._gpu,this._width,this._height))}get colors(){return this._colors||(this._colors=new O(this._gpu,this._width,this._height))}get filters(){return this._filters||(this._filters=new R(this._gpu,this._width,this._height))}get keypoints(){return this._keypoints||(this._keypoints=new we(this._gpu,this._width,this._height))}get encoders(){return this._encoders||(this._encoders=new Te(this._gpu,this._width,this._height))}get trackers(){return this._trackers||(this._trackers=new Qe(this._gpu,this._width,this._height))}get enhancements(){return this._enhancements||(this._enhancements=new Be(this._gpu,this._width,this._height))}get transforms(){return this._transforms||(this._transforms=new et(this._gpu,this._width,this._height))}pyramids(e=0){const t=0|e,n=1<<t;if(t<0||t>=l.n)throw new r.f(`Invalid pyramid level: ${t} (outside of range [0,${l.n-1}])`);return this._pyramids[t]||(this._pyramids[t]=new Ke(this._gpu,Math.max(1,Math.floor(this._width/n)),Math.max(1,Math.floor(this._height/n))))}release(){for(const e in this)Object.prototype.hasOwnProperty.call(this,e)&&null!=this[e]&&this[e]instanceof x&&this[e].release();for(let e=0;e<this._pyramids.length;e++)null!=this._pyramids[e]&&this._pyramids[e].release();return null}}const nt=Symbol("Bucket");class it{constructor(e,t,n){this.texture=e,this.index=t,this.next=n,this.free=!0}}class st{constructor(e,t=80){i.a.assert(t>0),this._bucket=Array.from({length:t},(e,t)=>new it(null,t,t-1)),this._head=t-1,this._gpu=e}allocate(){if(this._head<0)throw new r.j(`Exhausted pool (capacity: ${this._bucket.length})`);const e=this._bucket[this._head];return e.free=!1,this._head=e.next,null==e.texture&&(e.texture=st._createManagedTexture(this._gpu.gl,e)),e.texture}free(e){const t=e[nt];return i.a.assert(void 0!==t&&!t.free,"Unmanaged texture or double free"),t.next=this._head,t.free=!0,this._head=t.index,null}release(){for(let e=0;e<this._bucket.length;e++)null!=this._bucket[e].texture&&(this._bucket[e].texture=this._bucket[e].texture.release());return null}static _createManagedTexture(e,t){const n=new h(e,1,1);return Object.defineProperty(n,nt,{configurable:!1,enumerable:!1,writable:!1,value:t})}}class rt{constructor(){this._data=null,this._width=0,this._height=0}static load(e){const t=e.constructor.name;if("HTMLImageElement"==t)return(new ot)._load(e);if("HTMLVideoElement"==t)return(new at)._load(e);if("HTMLCanvasElement"==t)return(new ct)._load(e);if("ImageBitmap"==t)return(new lt)._load(e);throw new r.f("Unsupported media type: "+e)}get data(){return this._data}get width(){return this._width}get height(){return this._height}isLoaded(){return null!==this._data}get type(){throw new r.a}clone(){throw new r.a}_load(){throw new r.a}_waitUntil(e,t,n=3e4){return new s.a((s,o)=>{i.a.log(`Waiting for ${t} to be triggered in ${e}...`);const a=setTimeout(()=>{o(new r.l(`${t} has not been triggered in ${e}: timeout (${n}ms)`))},n);e.addEventListener(t,()=>{clearTimeout(a),s(e)},!1)})}}class ot extends rt{get type(){return y.d.Image}clone(){if(null==this._data)throw new r.g("Media not loaded");const e=this._data.cloneNode(!0);return(new ot)._load(e)}_load(e){return e.complete&&0!==e.naturalWidth?s.a.resolve().then(()=>(this._data=e,this._width=e.naturalWidth,this._height=e.naturalHeight,this)):this._waitUntil(e,"load").then(()=>(this._data=e,this._width=e.naturalWidth,this._height=e.naturalHeight,this))}}class at extends rt{get type(){return y.d.Video}clone(){if(null==this._data)throw new r.g("Media not loaded");const e=this._data.cloneNode(!0);return(new at)._load(e)}_load(e){return e.readyState>=4?s.a.resolve().then(()=>(this._data=e,this._width=e.videoWidth,this._height=e.videoHeight,this)):this._waitUntil(e,"canplaythrough").then(()=>(this._data=e,this._width=e.videoWidth,this._height=e.videoHeight,this))}}class ct extends rt{get type(){return y.d.Canvas}clone(){if(null==this._data)throw new r.g("Media not loaded");const e=i.a.createCanvas(this._width,this._height);return e.getContext("2d").draw(this._data,0,0),(new ct)._load(e)}_load(e){return s.a.resolve().then(()=>(this._data=e,this._width=e.width,this._height=e.height,this))}}class lt extends rt{get type(){return y.d.Bitmap}clone(){if(null==this._data)throw new r.g("Media not loaded");const e=new lt;return createImageBitmap(this._data).then(t=>e._load(t))}_load(e){return s.a.resolve().then(()=>(this._data=e,this._width=e.width,this._height=e.height,this))}}class dt{constructor(e){this._gpu=e,this._texture=new Array(2).fill(null),this._textureIndex=0}upload(e,t=null){const n=this._gpu.gl,i=e.data;if(null==t&&null==this._texture[0])for(let t=0;t<this._texture.length;t++)this._texture[t]=new d(n,e.width,e.height);return"HTMLVideoElement"==i.constructor.name&&i.readyState<2?t||this._texture[this._textureIndex]:null!=t?t.upload(i,e.width,e.height):(this._textureIndex=(this._textureIndex+1)%2,this._texture[this._textureIndex].upload(i,e.width,e.height))}release(){for(let e=0;e<this._texture.length;e++)null!=this._texture[e]&&(this._texture[e]=this._texture[e].release());return null}}class ht{constructor(e,t){if(e>l.k||t>l.k)throw new r.i(`Maximum texture size exceeded. Using ${e} x ${t}, expected up to ${l.k} x ${l.k}.`);if(e<1||t<1)throw new r.f(`Invalid texture size: ${e} x ${t}`);this._speedyGL=c.instance,this._width=0|e,this._height=0|t,this._programs=new tt(this,this._width,this._height),this._texturePool=new st(this),this._textureUploader=new dt(this),this._speedyGL.subscribe(this._reset=this._reset.bind(this))}get programs(){return this._programs}get gl(){return this._speedyGL.gl}get canvas(){return this._speedyGL.canvas}get texturePool(){return this._texturePool}renderToCanvas(e){return this.programs.utils.renderToCanvas(e)}upload(e,t=null){return this._textureUploader.upload(e,t)}release(){return i.a.assert(!this.isReleased()),this._programs=this._programs.release(),this._texturePool=this._texturePool.release(),this._textureUploader=this._textureUploader.release(),this._speedyGL.unsubscribe(this._reset),null}isReleased(){return null==this._programs}loseAndRestoreWebGLContext(){return this._speedyGL.loseAndRestoreContext().then(()=>{})}_reset(){this.isReleased()||(this._programs=new tt(this,this._width,this._height),this._texturePool=new st(this),this._textureUploader=new dt(this))}}class ut{constructor(e,t={},n=y.b.RGB){i.a.assert(e.isLoaded()),this._source=e,this._options=this._buildOptions(t,{usage:this._source.type==y.d.Video?"dynamic":"static"}),this._colorFormat=n,this._gpu=t.lightweight?Object.create(null):new ht(this._source.width,this._source.height),this._source.type==y.d.Canvas&&void 0===this._options.usage&&i.a.warning('Loading a canvas without an explicit usage flag. I will set the usage to "static". This will result in suboptimal performance if the canvas is animated')}static load(e,t={}){return rt.load(e).then(n=>{i.a.assert(0!==n.width&&0!==n.height);const s=new ut(n,t);return i.a.log(`Loaded SpeedyMedia with a ${e}.`),s})}static loadCameraStream(e,t,n={},s={}){return i.a.requestCameraStream(e,t,n).then(e=>ut.load(e,s))}get source(){return this._source.data}get width(){return this._source.width}get height(){return this._source.height}get type(){switch(this._source.type){case y.d.Image:return"image";case y.d.Video:return"video";case y.d.Canvas:return"canvas";case y.d.Bitmap:return"bitmap";default:return"unknown"}}get options(){return this._options}release(){return this.isReleased()||(i.a.log("Releasing SpeedyMedia object..."),this._gpu=this._gpu.release()),null}isReleased(){return null==this._gpu}clone(){if(this.isReleased())throw new r.g("Can't clone a SpeedyMedia that has been released");const e=new ut(this._source,this.options,this._colorFormat);return s.a.resolve(e)}draw(e,t=0,n=0,i=this.width,s=this.height){if(this.isReleased())return;i=Math.max(+i,0),s=Math.max(+s,0),e.getContext("2d").drawImage(this._source.data,+t,+n,i,s)}toBitmap(){if(this.isReleased())throw new r.g("Can't convert SpeedyMedia to ImageBitmap: the media has been released");if(!this._source.isLoaded())throw new r.g("Can't convert SpeedyMedia to bitmap: the media hasn't been loaded");return new s.a((e,t)=>createImageBitmap(this._source.data).then(e,t))}_buildOptions(e,t){return"dynamic"!=(e=Object.assign({},t,e)).usage&&"static"!=e.usage&&(i.a.warning(`Can't load media. Unrecognized usage option: "${e.usage}"`),e.usage=t.usage,i.a.assert("dynamic"==e.usage||"static"==e.usage)),Object.freeze(e)}_upload(){return this._gpu.upload(this._source)}}let pt=null;class ft{constructor(){if(this._fps=60,this._frames=0,this._updateInterval=500,this._lastUpdate=performance.now(),this._boundUpdate=this._update.bind(this),null!==pt)throw new r.g("Can't have multiple instances of FPSCounter");this._boundUpdate()}static get instance(){return null===pt&&(pt=new ft),pt}get fps(){return this._fps}_update(){const e=performance.now(),t=e-this._lastUpdate;t>=this._updateInterval&&(this._fps=Math.round(this._frames/(.001*t)),this._frames=0,this._lastUpdate=e),this._frames++,requestAnimationFrame(this._boundUpdate)}}class mt{constructor(){throw new r.a("Namespaces can't be instantiated")}}const _t=Object.freeze({});class gt{constructor(e=0,t=0){i.a.assert(e<=l.i),i.a.assert(e%4==0),i.a.assert(t%4==0),this._descriptorSize=e,this._extraSize=t}run(e,t){throw new r.a}download(e,t,n=0){throw new r.a}get extraSize(){return this._extraSize}set extraSize(e){this._extraSize=Math.max(0,0|e),i.a.assert(this._extraSize%4==0)}get descriptorSize(){return this._descriptorSize}set descriptorSize(e){this._descriptorSize=Math.max(0,0|e),i.a.assert(this._descriptorSize%4==0)}get encoderLength(){throw new r.a}}const xt=j.capacity(0,0,l.c);class yt{constructor(){this._gain=.85,this._state=xt,this._prevState=this._state}estimate(e){const t=Math.max(0,this._state+(this._state-this._prevState)),n=t+this._gain*(e-t);return this._gain=Math.min(.85,this._gain+.3),this._prevState=this._state,this._state=n,Math.round(this._state)}reset(){this._gain=0,this._state=this._prevState=xt}get maxGrowth(){return 1.5}}class vt{constructor(){this._encoderLength=l.c,this._estimator=new yt}download(e,t,n,s,o=0){i.a.assert(t.width===t.height),i.a.assert(t.width===this._encoderLength),o&0!=vt.RESET_DOWNLOADER_STATE&&this._estimator.reset();const a=0!=(o&vt.USE_BUFFERED_DOWNLOADS);return e.programs.encoders.downloadEncodedKeypoints(t,a).then(e=>{const i=t.width,r=0!=(o&vt.SUPPRESS_DESCRIPTORS)?0:1,a=j.decode(e,n*r,s,i),c=this._countDiscardedKeypoints(a),l=this._estimator.estimate(a.length-c),d=Math.max(l,32),h=this._estimator.maxGrowth*d;return this._encoderLength=j.minLength(h,n,s),a}).catch(e=>{throw new r.g("Can't download keypoints",e)})}get encoderLength(){return this._encoderLength}reserveSpace(e,t,n,i=!1){const s=j.minLength(e,t,n);this._encoderLength=i?s:Math.max(this._encoderLength,s)}_countDiscardedKeypoints(e){let t,n=0;for(t=e.length-1;t>=0;t--)n+=0!=(e[t].flags&l.d)|0;return n}static get RESET_DOWNLOADER_STATE(){return 1}static get USE_BUFFERED_DOWNLOADS(){return 2}static get SUPPRESS_DESCRIPTORS(){return 4}}const wt=Object.freeze({gain:.9,offset:.5,decay:0,quality:"low"});class St extends gt{constructor(){super(0,0),this._enhancements=null,this._downloader=new vt}run(e,t){const n=this._enhanceTexture(e,t);return this._detect(e,n)}download(e,t,n=0){return this._downloader.download(e,t,this.descriptorSize,this.extraSize,n)}get encoderLength(){return this._downloader.encoderLength}get downloader(){return this._downloader}setEnhancements(e){this._enhancements=!0===e?wt:"object"==typeof e&&null!==e?Object.assign({},wt,e):null}_detect(e,t){throw new r.a}_enhanceTexture(e,t){let n=t;const i=this._enhancements;return null!==i&&(n=e.programs.enhancements.nightvision(n,i.gain,i.offset,i.decay,i.quality,!0),n=e.programs.filters.gauss3(n)),n}}class bt extends gt{constructor(e,t=0,n=0){i.a.assert(e instanceof gt),i.a.assert(t>=e.descriptorSize),i.a.assert(n>=e.extraSize),super(t,n),this._decoratedAlgorithm=e,this._decoratedAlgorithm.descriptorSize=this.descriptorSize,this._decoratedAlgorithm.extraSize=this.extraSize}run(e,t){return this._decoratedAlgorithm.run(e,t)}download(e,t,n=0){return i.a.assert(this.extraSize==this._decoratedAlgorithm.extraSize),i.a.assert(this.descriptorSize==this._decoratedAlgorithm.descriptorSize),this._decoratedAlgorithm.download(e,t,n)}get decoratedAlgorithm(){return this._decoratedAlgorithm}get extraSize(){return super.extraSize}set extraSize(e){super.extraSize=e,this._decoratedAlgorithm.extraSize=e}get descriptorSize(){return super.descriptorSize}set descriptorSize(e){super.descriptorSize=e,this._decoratedAlgorithm.descriptorSize=e}get encoderLength(){return this._decoratedAlgorithm.encoderLength}}class Pt extends bt{constructor(e,t){i.a.assert(e instanceof gt),i.a.assert(t>0),super(e,t,e.extraSize)}run(e,t){const n=this.decoratedAlgorithm.run(e,t);return this._describe(e,t,n)}download(e,t,n=0){return super.download(e,t,n).then(e=>this._postProcess(e))}_describe(e,t,n){throw new r.a}_postProcess(e){throw new r.a}}class At extends St{constructor(){super(),this._n=9,this._threshold=20}get n(){return this._n}set n(e){this._n=0|e,i.a.assert(9===this._n||7===this._n||5===this._n)}get threshold(){return this._threshold}set threshold(e){this._threshold=0|e,i.a.assert(this._threshold>=0&&this._threshold<=255)}_detect(e,t){const n=this._n,i=this._threshold/255,s=this.descriptorSize,o=this.extraSize,a=this.encoderLength;let c=null;if(9==n)c=e.programs.keypoints.fast9(t,i);else if(7==n)c=e.programs.keypoints.fast7(t,i);else{if(5!=n)throw new r.i;c=e.programs.keypoints.fast5(t,i)}const l=e.programs.keypoints.nonMaxSuppression(c),d=e.programs.keypoints.encodeFastScore(l);return e.programs.encoders.encodeKeypoints(d,s,o,a)}}class Et extends St{constructor(){super(),this._n=9,this._threshold=20,this._depth=4,this._scaleFactor=1.4142135623730951}get n(){return this._n}set n(e){this._n=0|e,i.a.assert(9===this._n)}get threshold(){return this._threshold}set threshold(e){this._threshold=0|e,i.a.assert(this._threshold>=0&&this._threshold<=255)}get depth(){return this._depth}set depth(e){this._depth=0|e,i.a.assert(this._depth>=1&&this._depth<=l.n)}get scaleFactor(){return this._scaleFactor}set scaleFactor(e){this._scaleFactor=Math.min(Math.max(1,+e),2)}_detect(e,t){const n=this._threshold/255,i=2*this._depth-1,s=Math.log2(this._scaleFactor),r=this.descriptorSize,o=this.extraSize,a=this.encoderLength,c=t.generateMipmaps(),l=e.programs.keypoints.multiscaleFast(c,n,i,s),d=e.programs.keypoints.nonMaxSuppression(l,s),h=e.programs.keypoints.encodeFastScore(d);return e.programs.encoders.encodeKeypoints(h,r,o,a)}}const It=2*l.n-1;class Ot extends St{constructor(){super(),this._quality=.1}get quality(){return this._quality}set quality(e){this._quality=+e,i.a.assert(this._quality>=0&&this._quality<=1)}_detect(e,t){const{width:n,height:i}=e.programs.keypoints.multiscaleSobel,s=this._quality,r=this.descriptorSize,o=this.extraSize,a=this.encoderLength;e.programs.keypoints.multiscaleSobel.outputs(n,i,null);const c=e.programs.keypoints.multiscaleSobel(t,0),l=new Array(It).fill(c),d=e.programs.keypoints.multiscaleHarris(t,3,1,1,l),h=Math.ceil(Math.log2(Math.max(d.width,d.height)));let u=d;for(let t=0;t<h;t++)u=e.programs.keypoints.maxHarrisScore(u,t);const p=e.programs.keypoints.harrisCutoff(d,u,s),f=e.programs.keypoints.nonMaxSuppression(p),m=e.programs.keypoints.encodeHarrisScore(f);return e.programs.encoders.encodeKeypoints(m,r,o,a)}}class Mt extends St{constructor(){super(),this._quality=.1,this._depth=4,this._scaleFactor=1.4142135623730951,this._derivativesTexture=Array.from({length:It},()=>new h(c.instance.gl,1,1))}get quality(){return this._quality}set quality(e){this._quality=+e,i.a.assert(this._quality>=0&&this._quality<=1)}get depth(){return this._depth}set depth(e){this._depth=0|e,i.a.assert(this._depth>=1&&this._depth<=l.n)}get scaleFactor(){return this._scaleFactor}set scaleFactor(e){this._scaleFactor=Math.min(Math.max(1,+e),2)}_detect(e,t){const{width:n,height:i}=e.programs.keypoints.multiscaleSobel,s=this._quality,r=this._depth,o=this.descriptorSize,a=this.extraSize,c=this.encoderLength,l=2*r-1,d=Math.log2(this._scaleFactor),h=t.generateMipmaps(),u=new Array(It);for(let t=0;t<l;t++)e.programs.keypoints.multiscaleSobel.outputs(n,i,this._derivativesTexture[t]),u[t]=e.programs.keypoints.multiscaleSobel(h,t*d),e.programs.keypoints.multiscaleSobel.outputs(n,i,null);for(let e=l;e<u.length;e++)u[e]=u[e-1];const p=e.programs.keypoints.multiscaleHarris(h,3,l,d,u),f=Math.ceil(Math.log2(Math.max(p.width,p.height)));let m=p;for(let t=0;t<f;t++)m=e.programs.keypoints.maxHarrisScore(m,t);const _=e.programs.keypoints.harrisCutoff(p,m,s),g=e.programs.keypoints.nonMaxSuppression(_,d),x=e.programs.keypoints.encodeHarrisScore(g);return e.programs.encoders.encodeKeypoints(x,o,a,c)}}class kt{constructor(e,...t){this._decorator=e,this._args=t}decorate(e){const t=Reflect.construct(this._decorator,[e].concat(this._args));return i.a.assert(t instanceof bt),t}}class Xt{constructor(e){this._algorithm=e,this._decoratedAlgorithm=this._algorithm,this._sensitivity=0,this._max=void 0,this._capKeypoints=this._capKeypoints.bind(this),this._enhancements={denoise:!0,illumination:!1,nightvision:null},this._useBufferedDownloads=!0}link(e){return this._decoratedAlgorithm=e.decorate(this._decoratedAlgorithm),this}detect(e){const t=e._gpu,n="static"==e.options.usage,i=this._decoratedAlgorithm.descriptorSize,s=this._decoratedAlgorithm.extraSize;let o=0;if(e.isReleased())throw new r.g("Can't detect features: the SpeedyMedia has been released");if(n){const e=8192;this._algorithm.downloader.reserveSpace(e,i,s)}else this._useBufferedDownloads&&(o|=vt.USE_BUFFERED_DOWNLOADS);const a=e._upload(),c=this._preprocessTexture(t,a,1==this._enhancements.denoise,e._colorFormat!=y.b.Greyscale);this._algorithm.setEnhancements(this._enhancements.nightvision||this._enhancements.illumination);const l=this._decoratedAlgorithm.run(t,c);return this._decoratedAlgorithm.download(t,l,o).then(this._capKeypoints)}get sensitivity(){return this._sensitivity}set sensitivity(e){this._sensitivity=Math.max(0,Math.min(+e,1)),this._onSensitivityChange(this._sensitivity)}get max(){return this._max}set max(e){this._max=void 0!==e?Math.max(0,0|e):void 0}enhance(e){if("object"!=typeof e)throw new r.f("enhancements must be an object");this._enhancements=Object.assign(this._enhancements,e)}get useBufferedDownloads(){return this._useBufferedDownloads}set useBufferedDownloads(e){this._useBufferedDownloads=Boolean(e)}_preprocessTexture(e,t,n=!0,i=!0){let s=t;return n&&(s=e.programs.filters.gauss5(s)),i&&(s=e.programs.colors.rgb2grey(s)),s}_onSensitivityChange(e){throw new r.a}_compareKeypoints(e,t){return+t.score-+e.score}_capKeypoints(e){return void 0===this._max||(e.sort(this._compareKeypoints),e.length=Math.min(e.length,this._max)),e}}class Lt extends Xt{constructor(e=9){if(super(new At),9!==e&&7!==e&&5!==e)throw new r.i("Can't create FAST feature detector with n = "+e);this._algorithm.n=e}get n(){return this._algorithm.n}get threshold(){return this._algorithm.threshold}set threshold(e){this._algorithm.threshold=e}_onSensitivityChange(e){this.threshold=Math.round(255*(1-Math.tanh(2.77*e)))}}class zt extends Xt{constructor(e=9){if(super(new Et),9!==e)throw new r.i("Can't create Multiscale FAST feature detector with n = "+e);this._algorithm.n=e}get n(){return this._algorithm.n}get threshold(){return this._algorithm.threshold}set threshold(e){this._algorithm.threshold=e}get depth(){return this._algorithm.depth}set depth(e){this._algorithm.depth=e}get scaleFactor(){return this._algorithm.scaleFactor}set scaleFactor(e){this._algorithm.scaleFactor=e}_onSensitivityChange(e){this.threshold=Math.round(255*(1-Math.tanh(2.77*e)))}}class Tt extends Xt{constructor(){super(new Ot)}get quality(){return this._algorithm.quality}set quality(e){this._algorithm.quality=Math.max(0,Math.min(e,1))}_onSensitivityChange(e){this.quality=1-e}}class Rt extends Xt{constructor(){super(new Mt)}get depth(){return this._algorithm.depth}set depth(e){this._algorithm.depth=e}get scaleFactor(){return this._algorithm.scaleFactor}set scaleFactor(e){this._algorithm.scaleFactor=e}get quality(){return this._algorithm.quality}set quality(e){this._algorithm.quality=Math.max(0,Math.min(e,1))}_onSensitivityChange(e){this.quality=1-e}}class Nt extends Pt{constructor(e){super(e,32)}_describe(e,t,n){const i=this.descriptorSize,s=this.extraSize,r=this.encoderLength,o=this._computeOrientation(e,t,n),a=e.programs.filters.gauss7(t).generateMipmaps();return e.programs.keypoints.orbOld(a,o,i,s,r)}_computeOrientation(e,t,n){const i=this.descriptorSize,s=this.extraSize,r=this.encoderLength,o=t.generateMipmaps();return e.programs.keypoints.orbOrientationOld(o,n,i,s,r)}_postProcess(e){return e.map(e=>new C(e,e=>new N(e)))}}class Kt extends mt{static ORB(){return new kt(Nt)}}class Dt extends mt{static FAST(e=9){return new Lt(e)}static MultiscaleFAST(e=9){return new zt(e)}static Harris(){return new Tt}static MultiscaleHarris(){return new Rt}static ORB(){const e=Kt.ORB(),t=(new Rt).link(e);return t.scaleFactor=1.19,t}static BRISK(){throw new r.h}}class Ct extends gt{constructor(){super(0,0),this._prevImage=null,this._prevKeypoints=null,this._downloader=new vt}run(e,t){return this._track(e,t)}get prevImage(){return this._prevImage}set prevImage(e){this._prevImage=e}get prevKeypoints(){return this._prevKeypoints}set prevKeypoints(e){this._prevKeypoints=e}download(e,t,n=0){return n&0!=vt.USE_BUFFERED_DOWNLOADS&&i.a.warning("Feature trackers shouldn't use buffered downloads"),this._downloader.download(e,t,this.descriptorSize,this.extraSize,n)}get encoderLength(){return this._downloader.encoderLength}get downloader(){return this._downloader}upload(e,t){const n=j.minLength(t.length,this.descriptorSize,this.extraSize);return e.programs.encoders.uploadKeypointsOld(t,this.descriptorSize,this.extraSize,n)}_track(e,t){throw new r.a}}class Ft{constructor(e,t){return this.x=+e,this.y=+t,Object.freeze(this)}toString(){return`SpeedyVector2(${this.x.toFixed(5)}, ${this.y.toFixed(5)})`}equals(e){return this.x===e.x&&this.y===e.y}dot(e){return this.x*e.x+this.y*e.y}distanceTo(e){const t=this.x-e.x,n=this.y-e.y;return Math.sqrt(t*t+n*n)}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}normalized(){const e=this.length();return e>0?new Ft(this.x/e,this.y/e):new Ft(0,0)}plus(e){return new Ft(this.x+e.x,this.y+e.y)}minus(e){return new Ft(this.x-e.x,this.y-e.y)}times(e){return new Ft(this.x*e,this.y*e)}}const jt=Math.min(6,l.n);class Bt extends Ct{constructor(){super(),this._windowSize=15,this._depth=jt,this._numberOfIterations=5,this._discardThreshold=1e-4,this._epsilon=.01}get windowSize(){return this._windowSize}set windowSize(e){this._windowSize=0|e,i.a.assert(this._windowSize%2==1&&this._windowSize>=1)}get depth(){return this._depth}set depth(e){this._depth=0|e,i.a.assert(this._depth>=1&&this._depth<=l.n)}get numberOfIterations(){return this._numberOfIterations}set numberOfIterations(e){this._numberOfIterations=0|e,i.a.assert(this._numberOfIterations>=1)}get discardThreshold(){return this._discardThreshold}set discardThreshold(e){this._discardThreshold=+e,i.a.assert(this._discardThreshold>=0)}get epsilon(){return this._epsilon}set epsilon(e){this._epsilon=+e,i.a.assert(this._epsilon>=0)}_track(e,t){const n=this.prevImage,i=this.prevKeypoints,s=this.descriptorSize,r=this.extraSize,o=this.encoderLength,a=this.windowSize,c=this.depth,l=this.numberOfIterations,d=this.discardThreshold,h=this.epsilon,u=t.generateMipmaps(),p=n.generateMipmaps();return e.programs.trackers.lk(u,p,i,a,c,l,d,h,s,r,o)}}class $t extends class{constructor(e,t){this._trackingAlgorithm=e,this._decoratedAlgorithm=this._trackingAlgorithm,this._media=t,this._inputTexture=null,this._prevInputTexture=null}link(e){return this._decoratedAlgorithm=e.decorate(this._decoratedAlgorithm),this}track(e,t=null,n=null){const i=this._media._gpu,s=this._decoratedAlgorithm.descriptorSize,o=this._decoratedAlgorithm.extraSize;if(!Array.isArray(e)||null!=n&&!Array.isArray(n)||null!=t&&!Array.isArray(t))throw new r.f;const[a,c]=this._updatedImages(this._media,i,this._inputTexture);this._prevInputTexture=c,this._inputTexture=a,this._trackingAlgorithm.downloader.reserveSpace(e.length,s,o,!0),this._trackingAlgorithm.prevImage=c,this._trackingAlgorithm.prevKeypoints=this._trackingAlgorithm.upload(i,e);const d=this._decoratedAlgorithm.run(i,a);return this._decoratedAlgorithm.download(i,d,0).then(i=>{const s=[];null!=n&&(n.length=i.length),null!=t&&(t.length=i.length);for(let r=0;r<i.length;r++){const o=0==(i[r].flags&l.d);o&&s.push(i[r]),null!=n&&(n[r]=o),null!=t&&(t[r]=o?new Ft(i[r].x-e[r].x,i[r].y-e[r].y):new Ft(0,0))}return s})}_updatedImages(e,t,n){if(e.isReleased())throw new r.g("The media has been released");const i=e._upload();if(null==i)throw new r.g("Tracking error: can't upload image to the GPU "+e.source);return[i,n||i]}}{constructor(e){super(new Bt,e)}get windowSize(){return this._trackingAlgorithm.windowSize}set windowSize(e){this._trackingAlgorithm.windowSize=0|e}get depth(){return this._trackingAlgorithm.depth}set depth(e){this._trackingAlgorithm.depth=0|e}get discardThreshold(){return this._trackingAlgorithm.discardThreshold}set discardThreshold(e){this._trackingAlgorithm.discardThreshold=+e}get numberOfIterations(){return this._trackingAlgorithm.numberOfIterations}set numberOfIterations(e){this._trackingAlgorithm.numberOfIterations=0|e}get epsilon(){return this._trackingAlgorithm.epsilon}set epsilon(e){this._trackingAlgorithm.epsilon=+e}}class Ut extends mt{static LK(e){return new $t(e)}}class Ht{constructor(e,t){return this.x=+e,this.y=+t,Object.freeze(this)}toString(){return`SpeedyPoint2(${this.x.toFixed(5)}, ${this.y.toFixed(5)})`}plus(e){return new Ht(this.x+e.x,this.y+e.y)}minus(e){return new Ft(this.x-e.x,this.y-e.y)}equals(e){return this.x===e.x&&this.y===e.y}}class Gt{constructor(e,t){return this.width=Math.max(0,+e),this.height=Math.max(0,+t),Object.freeze(this)}toString(){return`SpeedySize(${this.width}, ${this.height})`}equals(e){return this.width===e.width&&this.height===e.height}area(){return this.width*this.height}}var qt=n(7);class Wt{constructor(e,t,n=qt.MatrixType.default){if(this.rows=0|e,this.columns=0|t,this.dtype=String(n),!qt.MatrixType.isValid(this.dtype))throw new r.f(`Invalid matrix data type: "${this.dtype}"`);if(this.rows<1||this.columns<1)throw new r.f(`Invalid matrix size: ${this.rows} x ${this.columns}`);return Object.freeze(this)}equals(e){return this.rows===e.rows&&this.columns===e.columns&&this.dtype===e.dtype}toString(){return`MatrixShape(rows=${this.rows},cols=${this.columns},dtype="${this.dtype}")`}}class Yt{constructor(e,t=null,n=qt.MatrixType.default,i=null){if(e|=0,!qt.MatrixType.isValid(n))throw new r.f(`Invalid data type: "${n}"`);if(e<=0)throw new r.f("Invalid matrix length");const s=null==t?qt.MatrixType.createTypedArray(n,e):Array.isArray(t)?qt.MatrixType.createTypedArray(n,t):t;this._dtype=n,this._data=s,this._byteOffset=s.byteOffset,this._length=s.length,this._pendingOperations=i?i._pendingOperations:0,this._pendingAccessesQueue=[],this._children=[],this._parent=i}get dtype(){return this._dtype}get data(){return this._data}ready(){return this._pendingOperations>0?new s.a(e=>{this._pendingAccessesQueue.push(()=>e(this))}):s.a.resolve(this)}lock(e=!0){let t=this;if(e&&t._parent)do{t=t._parent}while(t._parent);++t._pendingOperations;for(let e=t._children.length-1;e>=0;e--)t._children[e].lock(!1)}unlock(e=!0){let t=this;if(e&&t._parent)do{t=t._parent}while(t._parent);if(--t._pendingOperations<=0){const e=t._pendingAccessesQueue.slice(0),n=e.length;t._pendingOperations=0,t._pendingAccessesQueue.length=0;for(let i=0;i<n;i++){if(t._pendingOperations>0){for(let s=n-1;s>=i;s--)t._pendingAccessesQueue.unshift(e[s]);break}e[i].call(t)}}for(let e=t._children.length-1;e>=0;e--)t._children[e].unlock(!1)}replace(e){this._data.buffer!==e&&this._replace(e,!0)}createSharedBuffer(e=0,t=this._length){return this.ready().then(()=>{const n=Math.min(e+t,this._length),i=this._data.subarray(e,n),s=new Yt(t,i,this._dtype,this);return this._children.push(s),s})}_replace(e,t=!0){let n=this;if(n._parent&&t)do{n=n._parent}while(n._parent);n._data=qt.MatrixType.createTypedArray(this._dtype,e,n._byteOffset,n._length);for(let t=n._children.length-1;t>=0;t--)n._children[t]._replace(e,!1)}}var Qt=n(8);class Zt{constructor(e,t,n,i=null){const s=0|t;this.method=String(e),this.dtype=n.dtype,this.rows=n.rows,this.columns=n.columns,this.stride=0,this.byteOffset=0,this.length=0,this.rowsOfInputs=new Array(s).fill(0),this.columnsOfInputs=new Array(s).fill(0),this.strideOfInputs=new Array(s).fill(0),this.byteOffsetOfInputs=new Array(s).fill(0),this.lengthOfInputs=new Array(s).fill(0),this.custom=new Object(i)}updateMetadata(e,t){this._updateOutputMetadata(e),this._updateInputMetadata(t)}_updateOutputMetadata(e){const t=e.buffer.data;this.stride=e.stride,this.byteOffset=t.byteOffset,this.length=t.length,i.a.assert(e.rows===this.rows&&e.columns===this.columns&&e.dtype===this.dtype)}_updateInputMetadata(e){const t=e.length,n=0==this.rowsOfInputs.length||0==this.rowsOfInputs[0];i.a.assert(this.rowsOfInputs.length===t);for(let s=0;s<t;s++){const t=e[s],r=t.buffer.data;this.strideOfInputs[s]=t.stride,this.byteOffsetOfInputs[s]=r.byteOffset,this.lengthOfInputs[s]=r.length,n?(this.rowsOfInputs[s]=t.rows,this.columnsOfInputs[s]=t.columns):i.a.assert(t.rows===this.rowsOfInputs[s]&&t.columns===this.columnsOfInputs[s]&&t.dtype===this.dtype)}}}class Vt{static get instance(){return this._instance||(this._instance=new Vt)}constructor(){this._msgId=0,this._callbackTable=new Map,this._worker=this._createWorker()}run(e,t,n){if("nop"===e.method)return s.a.resolve([t,n]);const i=this._msgId=this._msgId+1&2147483647,r=n.concat(t).filter((e,t,n)=>n.indexOf(e)===t),o={id:i,header:e,outputBuffer:t,inputBuffers:n,transferables:r};return new s.a(e=>{this._callbackTable.set(i,e),this._worker.postMessage(o,r)})}_createWorker(){const e="self.LinAlg = "+Qt.LinAlg.toString()+";\nself.onmessage = "+Jt.toString()+";",t=new Blob([e],{type:"application/javascript"}),n=new Worker(URL.createObjectURL(t));return n.onmessage=e=>{const t=e.data;this._callbackTable.get(t.id)([t.outputBuffer,t.inputBuffers]),this._callbackTable.delete(t.id)},n.onerror=e=>{throw new r.g("Worker error: "+e.message)},n}}function Jt(e){const{id:t,header:n,outputBuffer:i,inputBuffers:s,transferables:r}=e.data;self.LinAlg.lib.execute(n,i,s);const o={id:t,outputBuffer:i,inputBuffers:s};self.postMessage(o,r)}const en=Vt.instance;class tn{constructor(e,t,n,i=null){this._shape=n,this._header=new Zt(e,t,n,i)}get rows(){return this._shape.rows}get columns(){return this._shape.columns}get dtype(){return this._shape.dtype}get shape(){return this._shape}numberOfInputMatrices(){return this._header.rowsOfInputs.length}run(e,t,n=!0){return n?this._runInWorker(e,t):this._runLocally(e,t)}_runInWorker(e,t){return this._assertCompatibility(t.shape),0==e.length?s.a.resolve():(this._header.updateMetadata(t,e),en.run(this._header,this._arrayBufferOf(t),this._arrayBuffersOf(e)).then(([n,i])=>{t.buffer.replace(n);for(let t=e.length-1;t>=0;t--)e[t].buffer.replace(i[t])}))}_runLocally(e,t){return this._assertCompatibility(t.shape),0==e.length||(this._header.updateMetadata(t,e),Qt.LinAlg.lib.execute(this._header,this._arrayBufferOf(t),this._arrayBuffersOf(e))),s.a.resolve()}_assertCompatibility(e){if(!this._shape.equals(e))throw this.dtype!==e.dtype?new r.g(`Incompatible matrix type: expected "${e.dtype}", found "${this.dtype}"`):new r.g(`Invalid matrix size: ${this.rows} x ${this.columns} (expected ${e.rows} x ${e.columns})`)}_computeWorkload(e){let t=0;for(let n=e.length-1;n>=0;n--)t+=e[n].rows*e[n].columns;return t}_arrayBuffersOf(e){const t=new Array(e.length);for(let n=t.length-1;n>=0;n--)t[n]=e[n].buffer.data.buffer;return t}_arrayBufferOf(e){return e.buffer.data.buffer}}class nn extends tn{constructor(e){super("nop",0,e)}}class sn extends tn{constructor(e,t){super("fill",0,e,{value:+t})}}class rn extends tn{constructor(e){super("copy",1,e)}}class on extends tn{constructor(e){super("transpose",1,new Wt(e.columns,e.rows,e.dtype))}}class an extends tn{constructor(e){i.a.assert(e.rows===e.columns&&e.rows<=3),super("inverse"+String(e.rows),1,e)}}class cn extends tn{constructor(e,t){i.a.assert(e.equals(t)),super("add",2,e)}}class ln extends tn{constructor(e,t){i.a.assert(e.equals(t)),super("subtract",2,e)}}class dn extends tn{constructor(e,t){i.a.assert(e.columns===t.rows&&e.dtype===t.dtype),super(3===e.rows&&3===e.columns&&3===t.columns?"multiply3":"multiply",2,new Wt(e.rows,t.columns,e.dtype))}}class hn extends tn{constructor(e,t){super("scale",1,e,{scalar:+t})}}class un extends tn{constructor(e,t){i.a.assert(e.equals(t)),super("compmult",2,e)}}class pn extends tn{constructor(e,t){i.a.assert(e.rows===t.rows&&e.dtype===t.dtype),super("multiplylt",2,new Wt(e.columns,t.columns,e.dtype))}}class fn extends tn{constructor(e,t){i.a.assert(e.columns===t.columns&&e.dtype===t.dtype),super("multiplyrt",2,new Wt(e.rows,t.rows,e.dtype))}}class mn extends tn{constructor(e,t){i.a.assert(e.columns===t.rows&&1===t.columns&&e.dtype===t.dtype),super("multiplyvec",2,new Wt(e.rows,1,e.dtype))}}class _n extends tn{constructor(e,t){const n={full:"full-qr",reduced:"reduced-qr"}[t];if(void 0===n)throw new r.f(`QR decomposition: unknown mode "${t}"`);const i="full-qr"==n?e.columns+e.rows:2*e.columns;super("qr",1,new Wt(e.rows,i,e.dtype),{mode:n})}}class gn extends tn{constructor(e,t){i.a.assert(e.rows===t.rows&&1===t.columns&&e.dtype===t.dtype),super("qr",2,new Wt(e.rows,e.columns+1,e.dtype),{mode:"reduced-Q'x"})}}class xn extends tn{constructor(e){i.a.assert(e.columns===e.rows+1),super("backsub",1,new Wt(e.rows,1,e.dtype))}}class yn extends tn{constructor(e,t){i.a.assert(e.rows===t.rows&&1===t.columns&&e.dtype===t.dtype),super("lssolve",2,new Wt(e.columns,1,e.dtype))}}class vn extends tn{constructor(e,t,n,i,s={}){super(e,t,n,{...s,subroutine:i.reduce((e,t)=>Object.assign(e,{[t]:[]}),{})})}static step(e,t,n){return{header:e._header,indexOfOutputMatrix:t,indicesOfInputMatrices:n}}_stepsOf(e){const t=this._header.custom.subroutine;return i.a.assert(Object.prototype.hasOwnProperty.call(t,e)),t[e]}setStepsOf(e,t){const n=this._header.custom.subroutine;i.a.assert(Array.isArray(n[e])&&0==n[e].length),i.a.assert(Array.isArray(t)),n[e]=t}adjustIndices(e,t){const n=this._header.custom.subroutine;for(let i in n)if(Object.prototype.hasOwnProperty.call(n,i)){const s=n[i];for(let n=0,i=s.length,r=null;n<i;n++){r=s[n],r.indexOfOutputMatrix=e(t[r.indexOfOutputMatrix]);for(let n=r.indicesOfInputMatrices.length-1;n>=0;n--)r.indicesOfInputMatrices[n]=e(t[r.indicesOfInputMatrices[n]])}}}}class wn extends vn{constructor(e,t,n){super("sequence",e,t,["sequence"]),this.setStepsOf("sequence",n)}steps(){return this._stepsOf("sequence")}}class Sn extends vn{constructor(e){super("sort",4,e,["cmp"])}}class bn extends vn{constructor(e){super("map",4,e,["mapfn"])}}class Pn extends vn{constructor(e){super("reduce",6,e,["reducefn"])}}class An extends tn{constructor(e,t){i.a.assert(e.equals(t)),super("homographynorm4p",2,new Wt(3,3,e.dtype))}}class En extends tn{constructor(e,t){i.a.assert(e.equals(t)),super("homographynormdlt",2,new Wt(3,3,e.dtype))}}class In extends tn{constructor(e,t){i.a.assert(t.dtype===e.dtype),super("applyHomography",2,t)}}class On extends tn{constructor(e,t){i.a.assert(t.dtype===e.dtype),super("applyAffine",2,t)}}class Mn extends tn{constructor(e,t){i.a.assert(t.dtype===e.dtype),super("applyLinear2d",2,t)}}class kn extends tn{constructor(e,t,n,s,r,o){i.a.assert(e.equals(t)),i.a.assert(e.columns===o.columns),super("pransacHomography",3,new Wt(3,3,e.dtype),{numberOfHypotheses:n,bundleSize:s,reprojectionError:r})}}let Xn=null;class Ln{constructor(){this._queue=[],this._busy=!1,this._useWorker=!0}static get instance(){return Xn||(Xn=new Ln)}set useWorker(e){this._useWorker=Boolean(e)}get useWorker(){return this._useWorker}enqueue(e,t,n){return new s.a(i=>{this._queue.push([e,n,t,i]),this._busy||(this._busy=!0,this._resolveAll())})}_resolveAll(){if(0==this._queue.length)return void(this._busy=!1);const[e,t,n,i]=this._queue.shift();n.lock();for(let e=t.length-1;e>=0;e--)t[e].lock();e.run(t,n,this._useWorker).then(()=>{for(let e=t.length-1;e>=0;e--)t[e].unlock();n.unlock(),i(),this._resolveAll()}).turbocharge()}}const zn=Ln.instance;class Tn{constructor(e,t=null,n=e.rows,i=null){if(this._shape=e,this._stride=0|n,this._buffer=i||new Yt(this.stride*this.columns,t,this.dtype),this._nop=null,this.stride<this.rows)throw new r.f(`Invalid stride (expected ${this.rows} or greater, found ${this.stride})`);if(Array.isArray(t)&&t.length!=this.rows*this.columns)throw new r.f(`Incorrect number of matrix elements (expected ${this.rows*this.columns}, found ${t.length})`)}get rows(){return this._shape.rows}get columns(){return this._shape.columns}get dtype(){return this._shape.dtype}get stride(){return this._stride}get shape(){return this._shape}read(){const e=this.rows,t=this.columns,n=this.stride;return this.sync().then(()=>this._buffer.ready().turbocharge()).then(i=>{const s=i.data,r=new Array(e*t);let o,a,c=0;for(a=0;a<t;a++)for(o=0;o<e;o++)r[c++]=s[a*n+o];return r}).turbocharge()}print(e,t=console.log){return this.read().then(n=>{const i=this.rows,s=this.columns,r=new Array(i);let o,a;for(o=0;o<i;o++)for(r[o]=new Array(s),a=0;a<s;a++)r[o][a]=n[a*i+o];const c=void 0!==e?t=>t.toFixed(e):e=>e,l=r.map(e=>"    "+e.map(c).join(", ")).join(",\n"),d=`SpeedyMatrix(rows=${i}, cols=${s}, dtype="${this.dtype}", data=[\n${l}\n])`;t(d)})}block(e,t,n,i){const s=this.rows,o=this.columns;if(t<e||i<n)throw new r.f(`Can't create empty submatrix - invalid range [${e}:${t}, ${n}:${i}]`);if(e<0||t>=s||n<0||i>=o)throw new r.f(`Can't create submatrix - invalid range [${e}:${t}, ${n}:${i}] of ${s} x ${o} matrix`);const a=t-e+1,c=new Wt(a,i-n+1,this.dtype),l=this.stride,d=n*l+e,h=(i-n)*l+a;return this._buffer.createSharedBuffer(d,h).then(e=>new Tn(c,void 0,l,e))}diagonal(){const e=this.rows,t=this.stride,n=Math.min(e,this.columns),i=(n-1)*t+e,s=new Wt(1,n,this.dtype);return this._buffer.createSharedBuffer(0,i).then(e=>new Tn(s,void 0,t+1,e))}toString(){return`SpeedyMatrix(rows=${this.rows}, cols=${this.columns}, dtype="${this.dtype}")`}lock(){this._buffer.lock()}unlock(){this._buffer.unlock()}get buffer(){return this._buffer}sync(){return this._nop=this._nop||(this._nop=new nn(this.shape)),zn.enqueue(this._nop,this,[])}}let Rn=null;class Nn{static get instance(){return Rn||(Rn=new Nn)}get useWorker(){return Ln.instance.useWorker}set useWorker(e){Ln.instance.useWorker=Boolean(e)}}class Kn{constructor(e,t,n){return this.operation=e,this.outputMatrix=t,this.inputMatrices=n,null!==this.operation&&i.a.assert(this.operation.numberOfInputMatrices()===this.inputMatrices.length),Object.freeze(this)}}class Dn{constructor(e,t,n=[],i=[]){return this._boundOperation=new Kn(e,t,n.map(e=>e._boundOperation.outputMatrix)),this._children=n,this._subroutines=i,Object.freeze(this)}get operation(){return this._boundOperation.operation}get outputMatrix(){return this._boundOperation.outputMatrix}pack(){const e=[],t=[[this,!1]],n=[];for(;t.length>0;){const[i,s]=t.pop();if(s){if(null!==i._boundOperation.operation){const{operation:t,outputMatrix:s,inputMatrices:r}=i._boundOperation,o=this._findOrAdd(e,s),a=r.map(t=>this._findOrAdd(e,t));for(let n=i._subroutines.length-1;n>=0;n--){const[s,r]=i._subroutines[n],o=r.pack(),c=t=>this._findOrAdd(a,this._findOrAdd(e,t));o.operation.adjustIndices(c,o.inputMatrices),t.setStepsOf(s,o.operation.steps())}const c=wn.step(t,o,a);c.header.updateMetadata(s,r),n.push(c)}}else{t.push([i,!0]);for(let e=i._children.length-1;e>=0;e--)t.push([i._children[e],!1])}}return new Kn(new wn(e.length,this.outputMatrix.shape,n),this.outputMatrix,e)}_findOrAdd(e,t){i.a.assert(void 0!==t);const n=e.lastIndexOf(t);return n>=0?n:e.push(t)-1}}const Cn=Ln.instance;class Fn{constructor(e){this._shape=e,this._compiledExpr=null}get rows(){return this._shape.rows}get columns(){return this._shape.columns}get dtype(){return this._shape.dtype}_compile(){throw new r.a}_compileAndEvaluate(){return null===this._compiledExpr?this._compile().then(e=>this._compiledExpr=e.pack()).then(e=>Cn.enqueue(e.operation,e.outputMatrix,e.inputMatrices)).then(()=>this):Cn.enqueue(this._compiledExpr.operation,this._compiledExpr.outputMatrix,this._compiledExpr.inputMatrices).then(()=>this)}get _matrix(){throw new r.a}_assign(e){throw new r.g("Can't assign matrix: not a l-value")}_compileAssignment(e){throw new r.g("Can't assign matrix: not a l-value")}static _assertSameShape(e,t){if(!e.equals(t))throw e.dtype!==t.dtype?new r.g(`Incompatible matrix data type (expected "${t.dtype}", found "${e.dtype}")`):new r.g(`Incompatible matrix shape (expected ${t.rows} x ${t.columns}, found ${e.rows} x ${e.columns})`)}assign(e){throw new r.g("Can't assign matrix: not a l-value")}fill(e){throw new r.g("Can't fill matrix: not a l-value")}read(){return this._compileAndEvaluate().then(e=>e._matrix.read()).turbocharge()}print(e,t){return this._compileAndEvaluate().then(n=>n._matrix.print(e,t)).turbocharge()}toString(){return this._matrix.toString()}block(e,t,n,i){return new Hn(this,e,t,n,i)}row(e){return this.block(e,e,0,this.columns-1)}column(e){return this.block(0,this.rows-1,e,e)}rowSpan(e,t){return this.block(e,t,0,this.columns-1)}columnSpan(e,t){return this.block(0,this.rows-1,e,t)}diagonal(){return new Gn(this)}transpose(){return new ti(this)}plus(e){return new ii(this,e)}minus(e){return new si(this,e)}times(e){return e instanceof Fn?new ri(this,e):new li(this,e)}compMult(e){return new di(this,e)}inverse(){return new ni(this)}followedBy(e){return new Wn(this,e)}setTo(e){throw new r.g("Can't create an assignment expression: not a l-value")}map(e,t,n){if("function"!=typeof n)throw new r.f("map() expects a mapping function");if(e!==this.rows)throw new r.f(`map() expects blockRows (${e}) to be the number of rows of the matrix (${this.rows})`);if(t<=0||this.columns%t!=0)throw new r.f(`map() expects the number of columns of the matrix (${this.columns}) to be divisible by blockColumns (${t})`);const i=new Wt(e,t,this.dtype),s=new Wt(1,1,this.dtype),o=new Qn(i,new Tn(i)),a=new Qn(s,new Tn(s)),c=n(o,a,new Jn(this));if(!(c instanceof Fn))throw new r.g("map() expects that the mapping function returns a matrix expression for all input blocks");return new ui(this,c,o._matrix,a._matrix)}reduce(e,t,n,i){if("function"!=typeof n)throw new r.f("reduce() expects a reducer function");if(e!==this.rows)throw new r.f(`reduce() expects blockRows (${e}) to be the number of rows of the matrix (${this.rows})`);if(t<=0||this.columns%t!=0)throw new r.f(`reduce() expects the number of columns of the matrix (${this.columns}) to be divisible by blockColumns (${t})`);if(!(i instanceof Fn))throw new r.f("reduce() expects initialMatrix to be a SpeedyMatrixExpr");const s=new Wt(e,t,this.dtype),o=new Wt(1,1,this.dtype),a=new Qn(s,new Tn(s)),c=new Qn(i._shape,new Tn(i._shape)),l=new Qn(o,new Tn(o)),d=n(c,a,l,new Jn(this));if(!(d instanceof Fn))throw new r.g("reduce() expects that the reducer function returns a SpeedyMatrixExpr for all input blocks");if(!d._shape.equals(i._shape))throw new r.g("reduce() expects that the reducer function returns matrices of the same shape as the initial matrix for all input blocks");return new pi(this,d,c._matrix,a._matrix,l._matrix,i)}sort(e,t,n){if("function"!=typeof n)throw new r.f("sort() expects a comparison function");if(e!==this.rows)throw new r.f(`sort() expects blockRows (${e}) to be the number of rows of the matrix (${this.rows})`);if(t<=0||this.columns%t!=0)throw new r.f(`sort() expects the number of columns of the matrix (${this.columns}) to be divisible by blockColumns (${t})`);const i=new Wt(e,t,this.dtype),s=new Qn(i,new Tn(i)),o=new Qn(i,new Tn(i)),a=n(s,o);if(!(a instanceof Fn&&1===a._shape.rows&&1===a._shape.columns))throw new r.g("sort() expects that the comparator function returns a 1x1 matrix expression for all comparison pairs");return new fi(this,a,s._matrix,o._matrix)}qr(e="reduced"){return new hi(this,e)}lssolve(e){return new bi(this,e)}solve(e,t="qr"){const n=this.rows,i=this.columns;if(n!==i)throw new r.f(`solve expects a square matrix, but received a ${n} x ${i} matrix`);if(e.rows!==n||1!==e.columns)throw new r.f(`solve expected a ${n} x 1 input vector, but received a ${e.rows} x ${e.columns} matrix`);switch(t){case"qr":return this.lssolve(e);default:throw new r.f(`Unknown method for solve: "${t}"`)}}static create(e,t,n){const i=new Wt(e,t),s=new Tn(i,n);return new Qn(i,s)}_qrSolve(e){return new wi(this,e)}_backSubstitution(){return new Si(this)}}class jn extends Fn{constructor(e){super(e),this._tmpmatrix=new Tn(e)}get _matrix(){return this._tmpmatrix}}class Bn extends jn{constructor(e,t){super(t.shape),this._expr=e,this._operation=t,i.a.assert(1===t.numberOfInputMatrices())}_compile(){return this._expr._compile().then(e=>new Dn(this._operation,this._matrix,[e]))}get child(){return this._expr}}class $n extends jn{constructor(e,t,n){if(super(n.shape),this._leftExpr=e,this._rightExpr=t,this._operation=n,i.a.assert(2===n.numberOfInputMatrices()),t.dtype!==e.dtype)throw new r.f(`Found a binary expression with different data types: "${e.dtype}" (left operand) x "${t.dtype}" (right operand)`)}_compile(){return s.a.all([this._leftExpr._compile().turbocharge(),this._rightExpr._compile().turbocharge()]).then(([e,t])=>new Dn(this._operation,this._matrix,[e,t]))}get leftChild(){return this._leftExpr}get rightChild(){return this._rightExpr}}class Un extends jn{constructor(e,t,n,s){if(super(s.shape),this._firstExpr=e,this._secondExpr=t,this._thirdExpr=n,this._operation=s,i.a.assert(3===s.numberOfInputMatrices()),e.dtype!==t.dtype||e.dtype!==n.dtype)throw new r.f(`Found a ternary expression with different data types: "${e.dtype}" (first operand) x "${t.dtype}" (second operand) x "${n.dtype}" (third operand)`)}_compile(){return s.a.all([this._firstExpr._compile().turbocharge(),this._secondExpr._compile().turbocharge(),this._thirdExpr._compile().turbocharge()]).then(([e,t,n])=>new Dn(this._operation,this._matrix,[e,t,n]))}get firstChild(){return this._firstExpr}get secondChild(){return this._secondExpr}get thirdChild(){return this._thirdExpr}}class Hn extends Fn{constructor(e,t,n,i,s){super(new Wt(n-t+1,s-i+1,e.dtype)),this._expr=e,this._firstRow=t,this._lastRow=n,this._firstColumn=i,this._lastColumn=s,this._submatrix=null,this._cachedMatrix=null}get _matrix(){return this._submatrix}_compile(){return this._expr._compile().then(e=>e.outputMatrix!==this._cachedMatrix||null===this._submatrix?(this._cachedMatrix=e.outputMatrix,this._cachedMatrix.block(this._firstRow,this._lastRow,this._firstColumn,this._lastColumn).then(t=>(this._submatrix=t,e))):e).then(e=>new Dn(null,this._matrix,[e]))}}class Gn extends Fn{constructor(e){const t=Math.min(e.rows,e.columns);super(new Wt(1,t,e.dtype)),this._expr=e,this._diagonal=null,this._cachedMatrix=null}get _matrix(){return this._diagonal}_compile(){return this._expr._compile().then(e=>e.outputMatrix!==this._cachedMatrix||null===this._diagonal?(this._cachedMatrix=e.outputMatrix,this._cachedMatrix.diagonal().then(t=>(this._diagonal=t,e))):e).then(e=>new Dn(null,this._matrix,[e]))}}class qn extends Fn{constructor(e,t){super(e._shape),this._lvalue=e,this._rvalue=t,Fn._assertSameShape(e._shape,t._shape)}get _matrix(){return this._lvalue._matrix}_compile(){return s.a.all([this._lvalue._compile().turbocharge(),this._rvalue._compile().turbocharge()]).then(([e,t])=>this._lvalue._compileAssignment(t).then(t=>new Dn(null,this._matrix,[e,t])))}}class Wn extends Fn{constructor(e,t){super(t._shape),this._first=e,this._second=t}get _matrix(){return this._second._matrix}_compile(){return s.a.all([this._first._compile().turbocharge(),this._second._compile().turbocharge()]).then(([e,t])=>new Dn(null,this._matrix,[e,t]))}}class Yn extends Fn{get _matrix(){throw new r.a}_evaluateLvalue(){throw new r.a}_assign(e){throw new r.a}_compileAssignment(e){throw new r.a}assign(e){if(Array.isArray(e)){const t=new Tn(this._shape,e);return this._evaluateLvalue().then(e=>e._assign(t)).then(()=>this)}return this._evaluateLvalue().then(t=>e._compileAndEvaluate().then(e=>t._assign(e._matrix))).then(()=>this)}fill(e){return this.assign(new ei(this._shape,+e))}setTo(e){if(Array.isArray(e)){const t=new Tn(this._shape,e);e=new Qn(t.shape,t)}return new qn(this,e)}block(e,t,n,i){return new Zn(this,e,t,n,i)}diagonal(){return new Vn(this)}}class Qn extends Yn{constructor(e,t=null){super(e),this._usermatrix=t||new Tn(this._shape),this._copy=new rn(this._shape),null!=t&&Fn._assertSameShape(this._shape,t.shape)}read(){return this._usermatrix.read().turbocharge()}get _matrix(){return this._usermatrix}_evaluateLvalue(){return s.a.resolve(this)}_assign(e){return Cn.enqueue(this._copy,this._matrix,[e])}_compile(){return s.a.resolve(new Dn(null,this._matrix,[]))}_compileAssignment(e){return s.a.resolve(new Dn(this._copy,this._matrix,[e]))}}class Zn extends Yn{constructor(e,t,n,i,s){super(new Wt(n-t+1,s-i+1,e.dtype)),this._expr=e,this._firstRow=t,this._lastRow=n,this._firstColumn=i,this._lastColumn=s,this._submatrix=null,this._cachedMatrix=null,this._copy=new rn(this._shape)}get _matrix(){return this._submatrix}_evaluateLvalue(){return this._expr._evaluateLvalue().then(e=>e._matrix!==this._cachedMatrix||null===this._submatrix?(this._cachedMatrix=e._matrix,this._cachedMatrix.block(this._firstRow,this._lastRow,this._firstColumn,this._lastColumn)):this._submatrix).then(e=>(this._submatrix=e,this))}_assign(e){return Cn.enqueue(this._copy,this._matrix,[e])}_compile(){return this._expr._compile().then(e=>e.outputMatrix!==this._cachedMatrix||null===this._submatrix?(this._cachedMatrix=e.outputMatrix,this._cachedMatrix.block(this._firstRow,this._lastRow,this._firstColumn,this._lastColumn).then(t=>(this._submatrix=t,e))):e).then(e=>new Dn(null,this._matrix,[e]))}_compileAssignment(e){return s.a.resolve(new Dn(this._copy,this._matrix,[e]))}}class Vn extends Yn{constructor(e){const t=Math.min(e.rows,e.columns);super(new Wt(1,t,e.dtype)),this._expr=e,this._diagonal=null,this._cachedMatrix=null,this._copy=new rn(this._shape)}get _matrix(){return this._diagonal}_evaluateLvalue(){return this._expr._evaluateLvalue().then(e=>e._matrix!==this._cachedMatrix||null===this._diagonal?(this._cachedMatrix=e._matrix,this._cachedMatrix.diagonal()):this._diagonal).then(e=>(this._diagonal=e,this))}_assign(e){return Cn.enqueue(this._copy,this._matrix,[e])}_compile(){return this._expr._compile().then(e=>e.outputMatrix!==this._cachedMatrix||null===this._diagonal?(this._cachedMatrix=e.outputMatrix,this._cachedMatrix.diagonal().then(t=>(this._diagonal=t,e))):e).then(e=>new Dn(null,this._matrix,[e]))}_compileAssignment(e){return s.a.resolve(new Dn(this._copy,this._matrix,[e]))}}class Jn extends Fn{constructor(e){super(e._shape),this._expr=e}get _matrix(){return this._expr._matrix}_compile(){return this._expr._compile()}}class ei extends jn{constructor(e,t){super(e),this._operation=new sn(this._shape,t)}_compile(){return s.a.resolve(new Dn(this._operation,this._matrix,[]))}}class ti extends Bn{constructor(e){if(e instanceof ti)return e.child;super(e,new on(e._shape))}}class ni extends Bn{constructor(e){if(e.rows!==e.columns)throw new r.g("Can't compute the inverse of a non-square matrix");if(e.rows>3)throw new r.i("Currently, only matrices up to 3x3 may be inverted");super(e,new an(e._shape))}}class ii extends $n{constructor(e,t){Fn._assertSameShape(e._shape,t._shape),super(e,t,new cn(e._shape,t._shape))}}class si extends $n{constructor(e,t){Fn._assertSameShape(e._shape,t._shape),super(e,t,new ln(e._shape,t._shape))}}class ri extends $n{constructor(e,t){const n=e instanceof ti,i=t instanceof ti;if(n&&i)return new ti(new ri(t.child,e.child));if(n&&!i)return new oi(e.child,t);if(!n&&i)return new ai(e,t.child);if(1===t.columns)return new ci(e,t);if(e.columns!==t.rows)throw new r.f(`Can't multiply a ${e.rows} x ${e.columns} matrix by a ${t.rows} x ${t.columns} matrix`);super(e,t,new dn(e._shape,t._shape))}}class oi extends $n{constructor(e,t){if(e.rows!==t.rows)throw new r.f(`Can't multiply a ${e.columns} x ${e.rows} (transposed) matrix by a ${t.rows} x ${t.columns} matrix`);super(e,t,new pn(e._shape,t._shape))}}class ai extends $n{constructor(e,t){if(e.columns!==t.columns)throw new r.f(`Can't multiply a ${e.rows} x ${e.columns} matrix by a ${t.columns} x ${t.rows} (transposed) matrix`);super(e,t,new fn(e._shape,t._shape))}}class ci extends $n{constructor(e,t){if(e.columns!==t.rows||1!==t.columns)throw new r.f(`Can't multiply a ${e.rows} x ${e.columns} matrix by a ${t.rows} x ${t.columns} matrix / column-vector`);super(e,t,new mn(e._shape,t._shape))}}class li extends Bn{constructor(e,t){super(e,new hn(e._shape,t))}}class di extends $n{constructor(e,t){Fn._assertSameShape(e._shape,t._shape),super(e,t,new un(e._shape,t._shape))}}class hi extends Bn{constructor(e,t){if(e.rows<e.columns)throw new r.f(`Can't compute the QR decomposition of a ${e.rows} x ${e.columns} matrix`);super(e,new _n(e._shape,t))}}class ui extends jn{constructor(e,t,n,s){i.a.assert(n.shape.rows===e.rows&&e.columns%n.shape.columns==0),i.a.assert(e.dtype===t.dtype);const r=e.columns/n.shape.columns;super(new Wt(t.rows,t.columns*r,t.dtype)),this._inputMatrix=e,this._mapfn=t,this._bi=n,this._index=s}_compile(){return this._inputMatrix._compile().then(e=>this._mapfn._compile().then(t=>new Dn(new bn(this._shape),this._matrix,[e,new Dn(null,t.outputMatrix),new Dn(null,this._bi),new Dn(null,this._index)],[["mapfn",t]])))}}class pi extends jn{constructor(e,t,n,s,r,o){i.a.assert(s.shape.rows===e.rows&&e.columns%s.shape.columns==0),i.a.assert(e.dtype===t.dtype),i.a.assert(t._shape.equals(o._shape)),i.a.assert(t._shape.equals(n.shape)),super(t._shape),this._inputMatrix=e,this._reducefn=t,this._accumulator=n,this._bi=s,this._index=r,this._initialMatrix=o}_compile(){return this._inputMatrix._compile().then(e=>this._initialMatrix._compile().then(t=>this._reducefn._compile().then(n=>new Dn(new Pn(this._shape),this._matrix,[e,new Dn(null,n.outputMatrix),new Dn(null,this._accumulator),new Dn(null,this._bi),new Dn(null,this._index),t],[["reducefn",n]]))))}}class fi extends jn{constructor(e,t,n,s){super(e._shape),i.a.assert(n.shape.equals(s.shape)),i.a.assert(n.rows===e.rows&&e.columns%n.columns==0),this._inputMatrix=e,this._comparator=t,this._blockShape=n.shape,this._bi=n,this._bj=s}_compile(){return this._inputMatrix._compile().then(e=>this._comparator._compile().then(t=>new Dn(new Sn(this._shape,this._blockShape),this._matrix,[e,new Dn(null,t.outputMatrix),new Dn(null,this._bi),new Dn(null,this._bj)],[["cmp",t]])))}}class mi extends $n{constructor(e,t){i.a.assert(2===e._shape.rows&&4===e._shape.columns),i.a.assert(e._shape.equals(t._shape)),super(e,t,new An(e._shape,t._shape))}}class _i extends $n{constructor(e,t){i.a.assert(2===e._shape.rows&&e._shape.columns>=4),i.a.assert(e._shape.equals(t._shape)),super(e,t,new En(e._shape,t._shape))}}class gi extends $n{constructor(e,t){i.a.assert(3===e.rows&&3===e.columns),i.a.assert(2===t.rows),super(e,t,new In(e._shape,t._shape))}}class xi extends $n{constructor(e,t){i.a.assert(2===e.rows&&3===e.columns),i.a.assert(2===t.rows),super(e,t,new On(e._shape,t._shape))}}class yi extends $n{constructor(e,t){i.a.assert(2===e.rows&&2===e.columns),i.a.assert(2===t.rows),super(e,t,new Mn(e._shape,t._shape))}}class vi extends Un{constructor(e,t,n,s,r,o){i.a.assert(2===e.rows&&e.columns>=4),i.a.assert(e._shape.equals(t._shape)),i.a.assert(1===o.rows&&o.columns===e.columns),i.a.assert(o.dtype===e.dtype),i.a.assert(o instanceof Yn),i.a.assert(n>0&&s>0&&r>=0),super(e,t,o,new kn(e._shape,t._shape,n,s,r,o._shape))}}class wi extends $n{constructor(e,t){if(e.rows<e.columns)throw new r.f(`Can't compute the QR decomposition of a ${e.rows} x ${e.columns} matrix`);if(1!=t.columns||t.rows!=e.rows)throw new r.f(`Expected a ${e.rows} x 1 column-vector, but found a ${t.rows} x ${t.columns} matrix`);super(e,t,new gn(e._shape,t._shape))}}class Si extends Bn{constructor(e){if(e.columns!=e.rows+1)throw new r.f(`Expected a ${e.rows} x ${e.rows+1} matrix, but found a ${e.rows} x ${e.columns} matrix`);super(e,new xn(e._shape))}}class bi extends $n{constructor(e,t){const[n,i]=[e.rows,e.columns];if(n<i)throw new r.f(`Input matrix has more columns than rows - it's ${n} x ${i}`);if(t.rows!=n||1!=t.columns)throw new r.f(`Expected a ${n} x 1 column-vector, but found a ${t.rows} x ${t.columns} matrix`);super(e,t,new yn(e._shape,t._shape))}}const Pi=Object.freeze({Nothing:0,Image:1,Keypoints:2});class Ai{constructor(e){this._type=e}get type(){return this._type}hasType(e){return this._type===e}isEmpty(){return this.hasType(Pi.Nothing)}toString(){return"message of type "+Object.keys(Pi).find(e=>Pi[e]===this.type)}set(...e){throw new r.a}static create(e){return function(e){return new Ii[e]}(e)}}class Ei extends Ai{constructor(){super(Pi.Nothing,null)}set(){return this}}const Ii=Object.freeze({[Pi.Nothing]:Ei,[Pi.Image]:class extends Ai{constructor(){super(Pi.Image),this._image=null,this._format=y.c.RGBA}set(e,t=y.c.RGBA){return this._image=e,this._format=t,this}get image(){return this._image}get format(){return this._format}},[Pi.Keypoints]:class extends Ai{constructor(){super(Pi.Keypoints),this._encodedKeypoints=null,this._descriptorSize=0,this._extraSize=0,this._encoderLength=1}set(e,t,n,s){return this._encodedKeypoints=e,this._descriptorSize=0|t,this._extraSize=0|n,this._encoderLength=0|s,i.a.assert(this._descriptorSize>=0&&this._extraSize>=0),i.a.assert(this._encoderLength===this._encodedKeypoints.width,"Invalid encoderLength"),i.a.assert(this._encodedKeypoints.width===this._encodedKeypoints.height,"Invalid encodedKeypoints texture"),this}get encodedKeypoints(){return this._encodedKeypoints}get descriptorSize(){return this._descriptorSize}get extraSize(){return this._extraSize}get encoderLength(){return this._encoderLength}hasDescriptors(){return this._descriptorSize>0}hasMatches(){return this._extraSize>0}}});const Oi=e=>!0;class Mi{constructor(e,t=Oi){this._expectedMessageType=e,this._isValidMessage="function"==typeof t?t:Oi,i.a.assert(this._expectedMessageType!=Pi.Nothing)}isCompatibleWith(e){return this._expectedMessageType==e._expectedMessageType}accepts(e){return e.hasType(this._expectedMessageType)&&this._isValidMessage(e)}toString(){return`Port expects ${Object.keys(Pi).find(e=>Pi[e]===this._expectedMessageType)} satisfying ${this._isValidMessage}`}get expectedMessageType(){return this._expectedMessageType}}const ki=/^[a-z][a-zA-Z0-9]*$/,Xi=new Ei;class Li{constructor(e,t,n){this._name=String(e),this._spec=t,this._node=n,this._message=Xi,i.a.assert(ki.test(this._name),`Port name "${this._name}" is not acceptable`)}get name(){return this._name}get node(){return this._node}connectTo(e){throw new r.a}isInputPort(){throw new r.a}isOutputPort(){return!this.isInputPort()}clearMessage(){this._message=Xi}hasMessage(){return!this._message.isEmpty()}read(){if(this._message.isEmpty())throw new r.g(`Can't read from port ${this.name}: nothing to read`);return this._message}write(e){throw new r.i(`Can't write ${e} to port ${this.name}: unsupported operation`)}static get DEFAULT_NAME(){throw new r.a}}class zi extends Li{constructor(e,t,n){super(e,t,n),this._cachedMessage=null}connectTo(e){if(!e.isInputPort())throw new r.f(`Can't connect output port ${this.name} to port ${e.name}: expected an input port`);e.connectTo(this)}isInputPort(){return!1}write(e){if(!this._spec.accepts(e))throw new r.f(`Can't write ${e} to port ${this.name}. ${this._spec}`);this._message=e}swrite(...e){null==this._cachedMessage&&(this._cachedMessage=Ai.create(this._spec.expectedMessageType)),this.write(this._cachedMessage.set(...e))}static get DEFAULT_NAME(){return"out"}}class Ti extends Li{constructor(e,t,n){super(e,t,n),this._incomingLink=null}get incomingLink(){return this._incomingLink}connectTo(e){if(!e.isOutputPort())throw new r.f(`Can't connect input port ${this.name} to port ${e.name}: expected an output port`);if(!this._spec.isCompatibleWith(e._spec))throw new r.f(`Can't connect ports ${this.name} and ${e.name}: incompatible types`);this._incomingLink=e}disconnect(){this._incomingLink=null}isInputPort(){return!0}pullMessage(e=""){const t=e.length>0?`${this.name} of ${e}`:this.name;if(null==this._incomingLink)throw new r.g("No incoming link for input port "+t);const n=this._incomingLink.read();if(!this._spec.accepts(n))throw new r.f(`Can't receive ${n} at port ${t}: ${this._spec}`);return this._message=n}static get DEFAULT_NAME(){return"in"}}class Ri{constructor(e,t){this._class=e,this._name=String(t),this._type=Pi.Nothing,this._messageConstraint=void 0}expects(e){return i.a.assert(this._type==Pi.Nothing),i.a.assert(e!=Pi.Nothing),this._type=e,this}satisfying(e){return i.a.assert(this._type!=Pi.Nothing,"You must first declare what type of message this port expects"),i.a.assert(void 0===this._messageConstraint),i.a.assert("function"==typeof e),this._messageConstraint=e,this}build(e){const t=new Mi(this._type,this._messageConstraint);return Reflect.construct(this._class,[this._name,t,e])}}function Ni(e=Ti.DEFAULT_NAME){return new Ri(Ti,e)}function Ki(e=zi.DEFAULT_NAME){return new Ri(zi,e)}const Di=e=>e.reduce((e,t)=>(e[t.name]=t,e),Object.create(null)),Ci=function(){let e=0;return()=>e++}();class Fi{constructor(e=(()=>Math.random().toString(16).substr(2))(),t=0,n=[]){this._id=Ci(),this._name=String(e);const i=n.map(e=>e.build(this));if(this._inputPorts=Di(i.filter(e=>e.isInputPort())),this._outputPorts=Di(i.filter(e=>e.isOutputPort())),this._outputTextures=new Array(this._outputPorts.length).fill(null),this._tex=new Array(t).fill(null),0==this._name.length)throw new r.f(`Invalid name "${this._name}" for node ${this.fullName}`);if(0==n.length)throw new r.f("No ports have been found in node "+this.fullName)}get name(){return this._name}get fullName(){return`${this.constructor.name}[${this.name}]`}get id(){return this._id}input(e=Ti.DEFAULT_NAME){if(e in this._inputPorts)return this._inputPorts[e];throw new r.f(`Can't find input port ${e} in node ${this.fullName}`)}output(e=zi.DEFAULT_NAME){if(e in this._outputPorts)return this._outputPorts[e];throw new r.f(`Can't find output port ${e} in node ${this.fullName}`)}execute(e){let t;for(t in this._outputPorts)this._outputPorts[t].clearMessage();for(t in this._inputPorts)this._inputPorts[t].pullMessage(this.fullName);const n=this._run(e);if(null!=n)return n.then(()=>{for(t in this._outputPorts)i.a.assert(this._outputPorts[t].hasMessage(),`Did you forget to write data to the output port ${t} of ${this.fullName}?`)});for(t in this._outputPorts)i.a.assert(this._outputPorts[t].hasMessage(),`Did you forget to write data to the output port ${t} of ${this.fullName}?`)}_run(e){throw new r.a}init(e){for(let t=0;t<this._outputTextures.length;t++)this._outputTextures[t]=e.texturePool.allocate();for(let t=0;t<this._tex.length;t++)this._tex[t]=e.texturePool.allocate()}release(e){for(let t=this._tex.length-1;t>=0;t--)this._tex[t]=e.texturePool.free(this._tex[t]);for(let t=this._outputTextures.length-1;t>=0;t--)this._outputTextures[t]=e.texturePool.free(this._outputTextures[t])}clearTextures(){for(let e=0;e<this._outputTextures.length;e++)this._outputTextures[e].clear()}clearPorts(){let e;for(e in this._inputPorts)this._inputPorts[e].clearMessage();for(e in this._outputPorts)this._outputPorts[e].clearMessage()}inputNodes(){const e=[];for(const t in this._inputPorts){const n=this._inputPorts[t];null!=n.incomingLink&&e.push(n.incomingLink.node)}return e}isSource(){return 0==Object.keys(this._inputPorts).length}isSink(){return 0==Object.keys(this._outputPorts).length}get _outputTexture(){return i.a.assert(1==this._outputTextures.length),this._outputTextures[0]}}class ji extends Fi{constructor(e,t,n){super(e,t,n),i.a.assert(this.isSource())}}class Bi extends Fi{constructor(e,t,n){super(e,t,n),i.a.assert(this.isSink())}export(){throw new r.a}}class $i{constructor(){this._nodes=[],this._sequence=[],this._template=$i._createOutputTemplate(),this._gpu=null,this._busy=!1}node(e){for(let t=0,n=this._nodes.length;t<n;t++)if(this._nodes[t].name===e)return this._nodes[t];return null}init(...e){if(this._nodes.length>0)throw new r.g("The pipeline has already been initialized");if(0==e.length)throw new r.f("Can't initialize the pipeline. Please specify its nodes");this._gpu=new ht(1,1);for(let t=0;t<e.length;t++){const n=e[t];this._nodes.includes(n)||this._nodes.push(n)}this._template=$i._createOutputTemplate(this._nodes),this._sequence=$i._tsort(this._nodes),$i._validateSequence(this._sequence);for(let e=0;e<this._sequence.length;e++)this._sequence[e].init(this._gpu);return this}release(){if(0==this._nodes.length)throw new r.g("The pipeline has already been released or has never been initialized");for(let e=this._sequence.length-1;e>=0;e--)this._sequence[e].release(this._gpu);return this._sequence.length=0,this._nodes.length=0,this._gpu=this._gpu.release(),this._template=$i._createOutputTemplate(),null}run(){if(i.a.assert(null!=this._gpu,"Pipeline has not been initialized or has been released"),this._busy)return new s.a((e,t)=>{setTimeout(()=>this.run().then(e,t),0)});this._busy=!0;const e=this._sequence.filter(e=>e.isSink());for(let e=0;e<this._sequence.length;e++)this._sequence[e].clearTextures();return $i._runSequence(this._sequence,this._gpu).then(()=>s.a.all(e.map(e=>e.export())).then(t=>t.reduce((t,n,i)=>(t[e[i].name]=n,t),this._template))).then(e=>{for(let e=this._sequence.length-1;e>=0;e--)this._sequence[e].clearPorts();return this._busy=!1,e}).turbocharge()}static _runSequence(e,t,n=0,i=e.length){if(n>=i)return s.a.resolve();const r=e[n].execute(t);return t.gl.flush(),null==r?$i._runSequence(e,t,n+1,i):r.then(()=>$i._runSequence(e,t,n+1,i))}static _tsort(e){const t=$i._outlinks(e),n=e.map(e=>[e,!1]),i=new Set,s=new Array(e.length);let o=s.length;for(;n.length>0;){const[e,a]=n.pop();if(a)s[--o]=e;else if(!i.has(e)){const o=t.get(e);if(i.add(e),n.push([e,!0]),n.push(...o.map(e=>[e,!1])),o.some(e=>i.has(e)&&!s.includes(e)))throw new r.g("Pipeline networks cannot have cycles!")}}return s}static _outlinks(e){const t=new Map;for(let n=0;n<e.length;n++)t.set(e[n],[]);for(let n=0;n<e.length;n++){const i=e[n],s=i.inputNodes();for(let e=0;e<s.length;e++){const n=s[e],o=t.get(n);if(!o)throw new r.g(`Can't initialize the pipeline. Missing node: ${n.fullName}. Did you forget to add it to the initialization list?`);o.includes(i)||o.push(i)}}return t}static _createOutputTemplate(e=[]){const t=Object.create(null);return e.filter(e=>e.isSink()).reduce((e,t)=>(e[t.name]=null,e),t)}static _validateSequence(e){if(0==e.length)throw new r.g("Pipeline doesn't have nodes");if(!e[0].isSource())throw new r.g("Pipeline doesn't have a source");if(!e[e.length-1].isSink())throw new r.g("Pipeline doesn't have a sink")}}class Ui extends ji{constructor(e){super(e,0,[Ki().expects(Pi.Image)]),this._media=null}get media(){return this._media}set media(e){i.a.assert(e instanceof ut),this._media=e}_run(e){e.upload(this._media._source,this._outputTexture),this.output().swrite(this._outputTexture,y.c.RGBA)}}class Hi extends Bi{constructor(e="image"){super(e,0,[Ni().expects(Pi.Image)]),this._bitmap=null,this._format=y.c.RGBA}export(){return i.a.assert(null!=this._bitmap),rt.load(this._bitmap).then(e=>new ut(e,{lightweight:1}))}_run(e){const{image:t,format:n}=this.input().read();return new s.a(i=>{const s=e.renderToCanvas(t);createImageBitmap(s,0,s.height-t.height,t.width,t.height).then(e=>{this._bitmap=e,this._format=n,i()})})}}const Gi=["in0","in1"];class qi extends Fi{constructor(e){super(e,0,[...Gi.map(e=>Ni(e).expects(Pi.Image)),Ki().expects(Pi.Image)]),this._port=0}get port(){return this._port}set port(e){if(e<0||e>=Gi.length)throw new r.f("Invalid port: "+e);this._port=0|e}_run(e){const t=this.input(Gi[this._port]).read();this.output().write(t)}}class Wi extends Fi{constructor(e){super(e,2,[Ni().expects(Pi.Image),Ki().expects(Pi.Image)]),this._pageIndex=0,this._initialized=!1,this._previousFormat=y.c.RGBA}release(e){this._initialized=!1,super.release(e)}_run(e){const{image:t,format:n}=this.input().read(),i=this._previousFormat,s=this._tex,o=s[1-this._pageIndex],a=s[this._pageIndex];if(t.hasMipmaps())throw new r.i("Can't bufferize a pyramid");if(this._previousFormat=n,o.resize(t.width,t.height),t.copyTo(o),this._pageIndex=1-this._pageIndex,!this._initialized)return this._initialized=!0,void this.output().swrite(o,n);this.output().swrite(a,i)}}const Yi=l.n,Qi=2*Yi-1;class Zi extends Fi{constructor(e){super(e,Qi,[Ni().expects(Pi.Image),Ki().expects(Pi.Image)])}_run(e){const{image:t,format:n}=this.input().read(),i=this._outputTexture,s=e.programs.pyramids(0);let r=t.width,o=t.height;const a=1+Math.floor(Math.log2(Math.max(r,o))),c=new Array(Qi+1);for(let e=0;e<Qi;e++)c[e+1]=this._tex[e];c[0]=t;const l=Math.min(a,Yi);for(let e=1;e<l;e++){const t=Math.max(1,r>>>1),n=Math.max(1,o>>>1),i=e-1+Yi;s.smoothX.outputs(r,o,c[i])(c[e-1]),s.smoothY.outputs(r,o,c[e-1])(c[i]),s.downsample2.outputs(t,n,c[e])(c[e-1]),r=t,o=n}i.resize(t.width,t.height),t.copyTo(i),i.generateMipmaps(c.slice(0,l)),this.output().swrite(i,n)}}class Vi extends mt{static Source(e){return new Ui(e)}static Sink(e){return new Hi(e)}static Multiplexer(e){return new qi(e)}static Buffer(e){return new Wi(e)}static Pyramid(e){return new Zi(e)}}class Ji extends Fi{constructor(e){super(e,0,[Ni().expects(Pi.Image),Ki().expects(Pi.Image)])}_run(e){const{image:t}=this.input().read(),n=t.width,i=t.height,s=this._outputTexture;e.programs.colors.rgb2grey.outputs(n,i,s)(t),this.output().swrite(s,y.c.GREY)}}const es={3:[.27901008925473514,.44197982149052983,.27901008925473514],5:[.06135959781344021,.2447701955296099,.3877404133138998,.2447701955296099,.06135959781344021],7:[.03873542500847274,.11308485700794121,.2150068609928349,.26634571398150225,.2150068609928349,.11308485700794121,.03873542500847274],9:[.028532262603370988,.067234535494912,.12400932997922749,.17904386461741617,.20236001461014655,.17904386461741617,.12400932997922749,.067234535494912,.028532262603370988],11:[.022656882730580346,.04610857898527292,.08012661469398517,.11890414969751599,.15067709325491124,.16305336127546846,.15067709325491124,.11890414969751599,.08012661469398517,.04610857898527292,.022656882730580346],13:[.018815730430644363,.03447396964662016,.05657737457255748,.08317258170844948,.10952340502389682,.12918787500405662,.13649812722755,.12918787500405662,.10952340502389682,.08317258170844948,.05657737457255748,.03447396964662016,.018815730430644363],15:[.016100340991695383,.027272329212157102,.042598338587449644,.06135478775568558,.08148767614129326,.09979838342934616,.11270444144735056,.11736740487004466,.11270444144735056,.09979838342934616,.08148767614129326,.06135478775568558,.042598338587449644,.027272329212157102,.016100340991695383]},ts=new Ft(0,0),ns={3:"convolution3x",5:"convolution5x",7:"convolution7x",9:"convolution9x",11:"convolution11x",13:"convolution13x",15:"convolution15x"},is={3:"convolution3y",5:"convolution5y",7:"convolution7y",9:"convolution9y",11:"convolution11y",13:"convolution13y",15:"convolution15y"};class ss extends Fi{constructor(e){super(e,1,[Ni().expects(Pi.Image),Ki().expects(Pi.Image)]),this._kernelSize=new Gt(5,5),this._sigma=ts,this._kernel={x:es[this._kernelSize.width],y:es[this._kernelSize.height]}}get kernelSize(){return this._kernelSize}set kernelSize(e){i.a.assert(e instanceof Gt);const t=e.width,n=e.height;if(t<3||n<3||t>15||n>15||t%2==0||n%2==0)throw new r.i(`Unsupported kernel size: ${t}x${n}`);this._kernelSize=e,this._updateKernel()}get sigma(){return this._sigma}set sigma(e){i.a.assert(e instanceof Ft,"Sigma must be a SpeedyVector2"),i.a.assert(e.x>=0&&e.y>=0),this._sigma=e,this._updateKernel()}_run(e){const{image:t,format:n}=this.input().read(),i=t.width,s=t.height,r=this._outputTexture,o=this._kernel.x,a=this._kernel.y,c=ns[this._kernelSize.width],l=is[this._kernelSize.height],d=this._tex[0];e.programs.filters[c].outputs(i,s,d)(t,o),e.programs.filters[l].outputs(i,s,r)(d,a),this.output().swrite(r,n)}_updateKernel(){this._sigma.x==ts.x?this._kernel.x=es[this._kernelSize.width]:this._kernel.x=i.a.gaussianKernel(this._sigma.x,this._kernelSize.width,!0),this._sigma.y==ts.y?this._kernel.y=es[this._kernelSize.height]:this._kernel.y=i.a.gaussianKernel(this._sigma.y,this._kernelSize.height,!0)}}const rs={3:new Array(3).fill(1/3),5:new Array(5).fill(.2),7:new Array(7).fill(1/7),9:new Array(9).fill(1/9),11:new Array(11).fill(1/11),13:new Array(13).fill(1/13),15:new Array(15).fill(1/15)},os={3:"convolution3x",5:"convolution5x",7:"convolution7x",9:"convolution9x",11:"convolution11x",13:"convolution13x",15:"convolution15x"},as={3:"convolution3y",5:"convolution5y",7:"convolution7y",9:"convolution9y",11:"convolution11y",13:"convolution13y",15:"convolution15y"};class cs extends Fi{constructor(e){super(e,1,[Ni().expects(Pi.Image),Ki().expects(Pi.Image)]),this._kernelSize=new Gt(5,5),this._kernel={x:rs[this._kernelSize.width],y:rs[this._kernelSize.height]}}get kernelSize(){return this._kernelSize}set kernelSize(e){i.a.assert(e instanceof Gt);const t=e.width,n=e.height;if(t<3||n<3||t>15||n>15||t%2==0||n%2==0)throw new r.i(`Unsupported kernel size: ${t}x${n}`);this._kernelSize=e,this._kernel.x=rs[this._kernelSize.width],this._kernel.y=rs[this._kernelSize.height]}_run(e){const{image:t,format:n}=this.input().read(),i=t.width,s=t.height,r=this._outputTexture,o=this._kernel.x,a=this._kernel.y,c=os[this._kernelSize.width],l=as[this._kernelSize.height],d=this._tex[0];e.programs.filters[c].outputs(i,s,d)(t,o),e.programs.filters[l].outputs(i,s,r)(d,a),this.output().swrite(r,n)}}const ls={3:"median3",5:"median5",7:"median7"};class ds extends Fi{constructor(e){super(e,0,[Ni().expects(Pi.Image).satisfying(e=>e.format===y.c.GREY),Ki().expects(Pi.Image)]),this._kernelSize=new Gt(5,5)}get kernelSize(){return this._kernelSize}set kernelSize(e){i.a.assert(e instanceof Gt);const t=e.width;if(3!=t&&5!=t&&7!=t)throw new r.i("Supported kernel sizes: 3x3, 5x5, 7x7");if(e.width!=e.height)throw new r.i("Use a square kernel");this._kernelSize=e}_run(e){const{image:t,format:n}=this.input().read(),i=t.width,s=t.height,r=this._outputTexture,o=this._kernelSize.width,a=ls[o];e.programs.filters[a].outputs(i,s,r)(t),this.output().swrite(r,n)}}const hs={3:"convolution3",5:"convolution5",7:"convolution7"};class us extends Fi{constructor(e){super(e,0,[Ni().expects(Pi.Image),Ki().expects(Pi.Image)]),this._kernel=Fn.create(3,3,[0,0,0,0,1,0,0,0,0])}get kernel(){return this._kernel}set kernel(e){if(e.rows!=e.columns)throw new r.i("Use a square kernel");if(3!=e.rows&&5!=e.rows&&7!=e.rows)throw new r.i("Invalid kernel size. Supported sizes: 3x3, 5x5, 7x7");this._kernel=e}_run(e){const{image:t,format:n}=this.input().read(),i=t.width,s=t.height,r=this._outputTexture,o=this._kernel.rows,a=hs[o];return this._kernel.read().then(o=>{e.programs.filters[a].outputs(i,s,r)(t,o),this.output().swrite(r,n)})}}class ps extends Fi{constructor(e){super(e,2,[Ni().expects(Pi.Image).satisfying(e=>e.format===y.c.RGBA||e.format===y.c.GREY),Ki().expects(Pi.Image)]),this._gain=.5,this._offset=.5,this._decay=0,this._quality="medium"}get gain(){return this._gain}set gain(e){this._gain=+e}get offset(){return this._offset}set offset(e){this._offset=+e}get decay(){return this._decay}set decay(e){this._decay=Math.max(0,Math.min(+e,1))}get quality(){return this._quality}set quality(e){if("high"!=e&&"medium"!=e&&"low"!=e)throw new r.f(`Invalid quality level for the Nightvision filter: "${e}"`);this._quality=String(e)}_run(e){const{image:t,format:n}=this.input().read(),i=t.width,s=t.height,r=this._outputTexture,o=this._gain,a=this._offset,c=this._decay,l=this._quality,d=e.programs.enhancements,h=this._tex[0],u=this._tex[1];"medium"==l?(d._illuminationMapX.outputs(i,s,h)(t),d._illuminationMapY.outputs(i,s,u)(h)):"high"==l?(d._illuminationMapHiX.outputs(i,s,h)(t),d._illuminationMapHiY.outputs(i,s,u)(h)):"low"==l&&(d._illuminationMapLoX.outputs(i,s,h)(t),d._illuminationMapLoY.outputs(i,s,u)(h)),n===y.c.GREY?d._nightvisionGreyscale.outputs(i,s,r)(t,u,o,a,c):n===y.c.RGBA&&d._nightvision.outputs(i,s,r)(t,u,o,a,c),this.output().swrite(r,n)}}class fs extends Fi{constructor(e){super(e,3,[Ni().expects(Pi.Image).satisfying(e=>e.format===y.c.GREY),Ki().expects(Pi.Image)]),this._minValue=0,this._maxValue=255}get minValue(){return this._minValue}set minValue(e){this._minValue=Math.max(0,Math.min(+e,255))}get maxValue(){return this._maxValue}set maxValue(e){this._maxValue=Math.max(0,Math.min(+e,255))}_run(e){const{image:t,format:n}=this.input().read(),i=t.width,s=t.height,r=this._outputTexture;let o=this._minValue,a=this._maxValue;o>a&&(o=a=(o+a)/2);const c=this._scanMinMax(e,t,y.e.GREEN);e.programs.enhancements._normalizeGreyscaleImage.outputs(i,s,r)(c,o,a),this.output().swrite(r,n)}_scanMinMax(e,t,n){const s=this._tex,r=e.programs.utils,o=t.width,a=t.height,c=0|Math.ceil(Math.log2(Math.max(o,a)));i.a.assert(void 0!==y.a[n]),r._copyComponents.outputs(o,a,s[2]),r._scanMinMax2D.outputs(o,a,s[0],s[1]);let l=r._copyComponents(t,t,y.e.ALL,y.a[n]);for(let e=0;e<c;e++)l=r._scanMinMax2D(l,e);return l}}class ms extends mt{static Greyscale(e){return new Ji(e)}static GaussianBlur(e){return new ss(e)}static SimpleBlur(e){return new cs(e)}static MedianBlur(e){return new ds(e)}static Convolution(e){return new us(e)}static Nightvision(e){return new ps(e)}static Normalize(e){return new fs(e)}}const _s=[0,0,0,0,0,0,0,0,1];class gs extends Fi{constructor(e){super(e,0,[Ni().expects(Pi.Image),Ki().expects(Pi.Image)]),this._transform=Fn.create(3,3,[1,0,0,0,1,0,0,0,1])}get transform(){return this._transform}set transform(e){if(3!=e.rows||3!=e.columns)throw new r.f("Not a 3x3 transformation matrix: "+e);this._transform=e}_run(e){const{image:t,format:n}=this.input().read(),i=t.width,s=t.height,r=this._outputTexture;return this._transform.read().then(o=>{let a=this._inverse3(o);Number.isNaN(a[0])&&(a=_s),e.programs.transforms._warpPerspective.outputs(i,s,r)(t,a),this.output().swrite(r,n)})}_inverse3(e,t=1e-6){const n=e[0],i=e[1],s=e[2],r=e[3],o=e[4],a=e[5],c=e[6],l=e[7],d=e[8],h=d*o-a*l,u=d*r-a*c,p=l*r-o*c,f=n*h-i*u+s*p;if(Math.abs(f)<t)e.fill(Number.NaN,0,9);else{const t=1/f;e[0]=h*t,e[1]=-(d*i-s*l)*t,e[2]=(a*i-s*o)*t,e[3]=-u*t,e[4]=(d*n-s*c)*t,e[5]=-(a*n-s*r)*t,e[6]=p*t,e[7]=-(l*n-i*c)*t,e[8]=(o*n-i*r)*t}return e}}class xs extends Fi{constructor(e){super(e,0,[Ni().expects(Pi.Image),Ki().expects(Pi.Image)]),this._size=new Gt(0,0),this._scale=new Ft(1,1),this._method="bilinear"}get size(){return this._size}set size(e){this._size=e}get scale(){return this._scale}set scale(e){this._scale=e}get method(){return this._method}set method(e){if("nearest"!==e&&"bilinear"!==e)throw new r.f(`Invalid method method: "${e}"`);this._method=e}_run(e){const{image:t,format:n}=this.input().read(),i=t.width,s=t.height,r=this._outputTexture,o=this._method,a=this._size.width||Math.max(1,this._scale.x*i),c=this._size.height||Math.max(1,this._scale.y*s);"bilinear"==o?e.programs.transforms.resizeBI.outputs(a,c,r)(t):"nearest"==o&&e.programs.transforms.resizeNN.outputs(a,c,r)(t),this.output().swrite(r,n)}}class ys extends mt{static Resize(e){return new xs(e)}static PerspectiveWarp(e){return new gs(e)}}const vs=l.j;class ws extends Fi{constructor(e,t=0,n){super(e,t+4,n),this._capacity=2048}get capacity(){return this._capacity}set capacity(e){this._capacity=Math.min(Math.max(0,0|e),vs)}_encodeKeypoints(e,t,n){const i=this._capacity,s=ws.encoderLength(i,0,0),r=t.width,o=t.height,a=[r,o],c=this._tex.slice(this._tex.length-4),l=e.programs.encoders;l._encodeKeypointSkipOffsets.outputs(r,o,c[0]),l._encodeKeypointLongSkipOffsets.outputs(r,o,c[1],c[0]),l._encodeKeypoints.outputs(s,s,c[2],c[3]);let d=l._encodeKeypointSkipOffsets(t,a);for(let e=0;e<2;e++)d=l._encodeKeypointLongSkipOffsets(d,a);let h=c[3].clear();for(let e=0;e<8;e++)h=l._encodeKeypoints(d,a,e,8,i,h,0,0,s);return n.resize(s,s),h.copyTo(n),n}_encodeZeroKeypoints(e,t){const n=ws.encoderLength(0,0,0),i=e.programs.encoders;return i._encodeNullKeypoints.outputs(n,n,t),i._encodeNullKeypoints(),t}static encoderLength(e,t,n){const i=e*Math.ceil((l.m+t+n)/4);return Math.max(l.l,Math.ceil(Math.sqrt(i)))}static encoderCapacity(e,t,n){const i=Math.ceil((l.m+e+t)/4),s=n*n;return Math.floor(s/i)}}class Ss extends ws{constructor(e,t,n){super(e,t,n),this._levels=1,this._scaleFactor=1.4142135623730951}get levels(){return this._levels}set levels(e){this._levels=Math.max(1,0|e)}get scaleFactor(){return this._scaleFactor}set scaleFactor(e){this._scaleFactor=Math.max(1,Math.min(+e,2))}}const bs=new Uint8Array([]);class Ps{constructor(e,t,n=0,i=0,s=0,r=0,o=null,a=null){this._position=new Ht(+e,+t),this._lod=+n,this._rotation=+i,this._score=+s,this._flags=0|r,this._extraBytes=a||bs,this._descriptorBytes=o||bs}toString(){return`(${this.x},${this.y})`}get position(){return this._position}get x(){return this._position.x}get y(){return this._position.y}get lod(){return this._lod}get scale(){return Math.pow(2,this._lod)}get rotation(){return this._rotation}get score(){return this._score}get flags(){return this._flags}get descriptor(){return this._descriptorBytes}}const As=4*Float32Array.BYTES_PER_ELEMENT;class Es extends ji{constructor(e){super(e,1,[Ki().expects(Pi.Keypoints)]),this._keypoints=[],this._buffer=Es._createUploadBuffer(1024)}get keypoints(){return this._keypoints}set keypoints(e){i.a.assert(Array.isArray(e)),this._keypoints=e}_run(e){const t=this._keypoints,n=t.length,i=Math.max(1,Math.ceil(n/1024)),s=this._buffer,r=this._tex[0],o=this._outputTexture,a=e.programs.keypoints.uploadKeypoints,c=ws.encoderLength(n,0,0);a.outputs(c,c,o,r);let l=0,d=r;for(let e=0;e<i;e++){const e=l+Math.min(1024,n-l);a.setUBO("KeypointBuffer",Es._fillUploadBuffer(s,t,l,e)),d=a(d,l,e,0,0,c),l=e}d!=o&&d.copyTo(o),this.output().swrite(o,0,0,c)}static _createUploadBuffer(e){const t=new ArrayBuffer(As*e);return i.a.assert(t.byteLength<=16384),new Float32Array(t)}static _fillUploadBuffer(e,t,n,i){const s=i-n;for(let i=0;i<s;i++){const s=t[n+i],r=4*i;e[r]=+s.position.x||0,e[r+1]=+s.position.y||0,e[r+2]=+s.lod||0,e[r+3]=+s.score||0}return e}}class Is extends Bi{constructor(e="keypoints"){super(e,0,[Ni().expects(Pi.Keypoints)]),this._keypoints=[],this._textureReader=new Pe}export(){return s.a.resolve(this._keypoints)}_run(e){const{encodedKeypoints:t,descriptorSize:n,extraSize:i,encoderLength:s}=this.input().read();return this._textureReader.readPixelsAsync(t,!1).then(e=>{this._keypoints=Is._decode(e,n,i,s)})}static _decode(e,t,n,i){const s=Math.ceil((l.m+t+n)/4),r=4*s;let o,a,c,d,h,u,p,f,m,_;const g=[],x=i*i*s*4,y=Math.min(e.length,x);t+n>0&&(e=new Uint8Array(e));for(let i=0;i<y&&(o=e[i+1]<<8|e[i],a=e[i+3]<<8|e[i+2],!(o>=65535&&a>=65535));i+=r)o+a==0&&0==e[i+6]||(o/=l.b,a/=l.b,u=e[i+7],m=e[i+4]<255,c=m?-l.h+(l.h+l.n)*e[i+4]/255:0,_=u&0!=l.f,d=_?(2*e[i+5]/255-1)*Math.PI:0,h=e[i+6]/255,p=e.subarray(8+i,8+i+n),f=e.subarray(8+i+n,8+i+n+t),f.length<t||p.length<n||g.push(new Ps(o,a,c,d,h,u,f,p)));return g}}const Os=l.j;class Ms extends Fi{constructor(e){super(e,3,[Ni().expects(Pi.Keypoints).satisfying(e=>0==e.descriptorSize&&0==e.extraSize),Ki().expects(Pi.Keypoints)]),this._size=Os}get size(){return this._size}set size(e){this._size=Math.max(0,Math.min(0|e,Os))}_run(e){const{encodedKeypoints:t,descriptorSize:n,extraSize:i,encoderLength:s}=this.input().read(),r=e.programs.keypoints,o=this._outputTexture,a=this._size,c=this._tex,l=ws.encoderCapacity(n,i,s),d=Math.ceil(l/32),h=32*d,u=Math.min(l,a),p=ws.encoderLength(u,n,i);r.sortCreatePermutation.outputs(32,d,c[0]);let f=r.sortCreatePermutation(t,n,i,s);const m=Math.ceil(Math.log2(h));r.sortMergePermutation.outputs(32,d,c[1],c[2]);for(let e=1;e<=m;e++){const t=1<<e,n=e<<1;f=r.sortMergePermutation(f,t,n)}r.sortApplyPermutation.outputs(p,p,o),r.sortApplyPermutation(f,u,t,n,i),this.output().swrite(o,n,i,p)}}class ks extends Fi{constructor(e){super(e,2,[Ni().expects(Pi.Keypoints),Ki().expects(Pi.Keypoints)]),this._pageIndex=0,this._initialized=!1,this._previousDescriptorSize=0,this._previousExtraSize=0,this._previousEncoderLength=0}release(e){this._initialized=!1,super.release(e)}_run(e){const{encodedKeypoints:t,descriptorSize:n,extraSize:i,encoderLength:s}=this.input().read(),r=this._previousDescriptorSize,o=this._previousExtraSize,a=this._previousEncoderLength,c=this._tex,l=c[1-this._pageIndex],d=c[this._pageIndex];if(this._previousDescriptorSize=n,this._previousExtraSize=i,this._previousEncoderLength=s,l.resize(s,s),t.copyTo(l),this._pageIndex=1-this._pageIndex,!this._initialized)return this._initialized=!0,void this.output().swrite(l,n,i,s);this.output().swrite(d,r,o,a)}}class Xs extends Fi{constructor(e){super(e,4,[Ni("in0").expects(Pi.Keypoints),Ni("in1").expects(Pi.Keypoints),Ki().expects(Pi.Keypoints)])}_run(e){const t=this.input("in0").read(),n=this.input("in1").read(),i=t.descriptorSize,s=t.extraSize,o=e.programs.keypoints,a=this._outputTexture,c=this._tex;if(t.descriptorSize!==n.descriptorSize||t.extraSize!=t.extraSize)throw new r.g("Can't merge two sets of keypoints that have different formats");const l=ws.encoderCapacity(t.descriptorSize,t.extraSize,t.encoderLength),d=ws.encoderCapacity(n.descriptorSize,n.extraSize,n.encoderLength),h=l+d,u=ws.encoderLength(h,i,s);o.mixKeypoints.outputs(u,u,c[3]);const p=o.mixKeypoints([t.encodedKeypoints,n.encodedKeypoints],[t.encoderLength,n.encoderLength],[l,d],i,s,u),f=Math.ceil(h/32),m=32*f;o.sortCreatePermutation.outputs(32,f,c[0]);let _=o.sortCreatePermutation(p,i,s,u);const g=Math.ceil(Math.log2(m));o.sortMergePermutation.outputs(32,f,c[1],c[2]);for(let e=1;e<=g;e++){const t=1<<e,n=e<<1;_=o.sortMergePermutation(_,t,n)}o.sortApplyPermutation.outputs(u,u,a),o.sortApplyPermutation(_,h,p,i,s),this.output().swrite(a,i,s,u)}}class Ls extends Ss{constructor(e){super(e,3,[Ni().expects(Pi.Image).satisfying(e=>e.format===y.c.GREY),Ki().expects(Pi.Keypoints)]),this._threshold=20}get threshold(){return this._threshold}set threshold(e){this._threshold=Math.max(0,Math.min(0|e,255))}_run(e){const t=this.input().read().image,n=t.width,i=t.height,s=this._tex,o=this._capacity,a=this._threshold,c=Math.log2(this.scaleFactor),d=this.levels,h=e.programs.keypoints,u=d>1?h.pyrnonmax:h.nonmax;if(1!=d&&!t.hasMipmaps())throw new r.g("Expected a pyramid in "+this.fullName);if(0==o){const t=this._encodeZeroKeypoints(e,this._outputTexture),n=t.width;return void this.output().swrite(t,0,0,n)}h.fast9_16.outputs(n,i,s[0],s[1]);let p=s[1].clear(),f=Math.min(l.n-1,(d-1)*c);for(let e=0,n=0;e<d&&n<l.n;e++,n+=c)p=h.fast9_16(p,t,f-n,a);const m=u.outputs(n,i,s[2])(p,c),_=h.fastScoreTo8bits.outputs(n,i,s[0])(m),g=this._encodeKeypoints(e,_,this._outputTexture),x=g.width;this.output().swrite(g,0,0,x)}}const zs={1:"harris1",3:"harris3",5:"harris5",7:"harris7"};class Ts extends Ss{constructor(e){super(e,3,[Ni().expects(Pi.Image).satisfying(e=>e.format===y.c.GREY),Ki().expects(Pi.Keypoints)]),this._windowSize=new Gt(3,3),this._quality=.1}get quality(){return this._quality}set quality(e){this._quality=Math.max(0,Math.min(+e,1))}get windowSize(){return this._windowSize}set windowSize(e){const t=e.width;if(t!=e.height||1!=t&&3!=t&&5!=t&&7!=t)throw new r.f(`Invalid window: ${e}. Acceptable sizes: 1x1, 3x3, 5x5, 7x7`);this._windowSize=e}_run(e){const t=this.input().read().image,n=t.width,i=t.height,s=this._tex,o=this._capacity,a=this._quality,c=this._windowSize,d=Math.log2(this.scaleFactor),h=this.levels,u=e.programs.keypoints,p=h>1?u.pyrnonmax:u.nonmax,f=u[zs[c.width]];if(1!=h&&!t.hasMipmaps())throw new r.g("Expected a pyramid in "+this.fullName);if(0==o){const t=this._encodeZeroKeypoints(e,this._outputTexture),n=t.width;return void this.output().swrite(t,0,0,n)}f.outputs(n,i,s[0],s[1]),u.harrisDerivatives.outputs(n,i,s[2]);let m=s[1].clear();for(let e=0,n=0;e<h&&n<l.n;e++,n+=d){m=f(m,u.harrisDerivatives(t,n),n)}const _=p.outputs(n,i,s[2])(m,d);u.harrisScoreFindMax.outputs(n,i,s[0],s[1]);const g=Math.ceil(Math.log2(Math.max(n,i)));let x=_;for(let e=0;e<g;e++)x=u.harrisScoreFindMax(x,e);const y=u.harrisScoreCutoff.outputs(n,i,x==s[0]?s[1]:s[0])(_,x,a),v=u.harrisScoreTo8bits.outputs(n,i,s[2])(y),w=this._encodeKeypoints(e,v,this._outputTexture),S=w.width;this.output().swrite(w,0,0,S)}}class Rs extends Fi{constructor(e,t=0,n){super(e,t+1,n)}_allocateSpaceForTheDescriptors(e,t,n,s,r,o){i.a.assert(0===t&&0===n),i.a.assert(s>0&&r===n);const a=o.width,c=ws.encoderCapacity(t,n,a),l=ws.encoderLength(c,s,r),d=this._tex[this._tex.length-1];return e.programs.keypoints.expandEncoder.outputs(l,l,d)(o,t,n,a,s,r,l)}}class Ns extends Rs{constructor(e){super(e,2,[Ni("image").expects(Pi.Image).satisfying(e=>e.format===y.c.GREY&&e.image.hasMipmaps()),Ni("keypoints").expects(Pi.Keypoints).satisfying(e=>0==e.descriptorSize&&0==e.extraSize),Ki().expects(Pi.Keypoints)])}_run(e){const{encodedKeypoints:t,descriptorSize:n,extraSize:i,encoderLength:s}=this.input("keypoints").read(),r=this.input("image").read().image,o=this._outputTexture,a=this._tex,c=ws.encoderCapacity(n,i,s),l=Math.max(1,Math.ceil(Math.sqrt(c))),d=e.programs.keypoints.orbOrientation.outputs(l,l,a[0])(r,t,n,i,s),h=e.programs.keypoints.transferOrientation.outputs(s,s,a[1])(d,t,n,i,s),u=this._allocateSpaceForTheDescriptors(e,n,i,32,i,h),p=u.width,f=e.programs.keypoints.orbDescriptor.outputs(p,p,o)(r,u,i,p);this.output().swrite(f,32,i,p)}}const Ks=new Gt(15,15),Ds=Math.min(6,l.n);class Cs extends Fi{constructor(e){super(e,3,[Ni("previousImage").expects(Pi.Image).satisfying(e=>e.format===y.c.GREY),Ni("nextImage").expects(Pi.Image).satisfying(e=>e.format===y.c.GREY),Ni("previousKeypoints").expects(Pi.Keypoints),Ki().expects(Pi.Keypoints)]),this._windowSize=Ks,this._levels=Ds,this._discardThreshold=1e-4,this._numberOfIterations=5,this._epsilon=.01}get windowSize(){return this._windowSize}set windowSize(e){i.a.assert(e.width==e.height&&e.area()>0),i.a.assert(e.width%2==1&&e.height%2==1),this._windowSize=e;const t=this._windowSize.width;if(t>21)throw new r.i(`LK: window ${this._windowSize} is too large!`);if(t<5)throw new r.i(`LK: window ${this._windowSize} is too small!`)}get levels(){return this._levels}set levels(e){i.a.assert(e>=1&&e<=l.n),this._levels=0|e}get discardThreshold(){return this._discardThreshold}set discardThreshold(e){i.a.assert(e>=0),this._discardThreshold=+e}get numberOfIterations(){return this._numberOfIterations}set numberOfIterations(e){i.a.assert(e>=1),this._numberOfIterations=0|e}get epsilon(){return this._epsilon}set epsilon(e){i.a.assert(e>=0),this._epsilon=+e}_run(e){const{encodedKeypoints:t,descriptorSize:n,extraSize:i,encoderLength:s}=this.input("previousKeypoints").read(),o=this.input("previousImage").read().image,a=this.input("nextImage").read().image,c=t,l=this._levels,d=this._windowSize.width,h=this._numberOfIterations,u=this._discardThreshold,p=this._epsilon,f=e.programs.trackers,m=this._tex;if(!(1==l||o.hasMipmaps()&&a.hasMipmaps()))throw new r.g("LK: a pyramid is required if levels > 1");const _=d<=7?f.lk7:d<=11?f.lk11:d<=15?f.lk15:d<=21?f.lk21:null,g=ws.encoderCapacity(n,i,s),x=Math.max(1,Math.ceil(Math.sqrt(g)));_.outputs(x,x,m[0],m[1]);let y=m[1].clear();for(let e=l-1;e>=0;e--)y=_(y,c,a,o,d,e,l,h,u,p,n,i,s);f.transferFlow.outputs(s,s,m[2]);const v=f.transferFlow(y,c,n,i,s);f.lkDiscard.outputs(s,s,this._outputTexture);const w=f.lkDiscard(a,d,v,n,i,s);this.output().swrite(w,n,i,s)}}class Fs extends mt{static FAST(e){return new Ls(e)}static Harris(e){return new Ts(e)}}class js extends mt{static ORB(e){return new Ns(e)}}class Bs extends mt{static LK(e){return new Cs(e)}}class $s extends mt{static get Detector(){return Fs}static get Descriptor(){return js}static get Tracker(){return Bs}static Source(e){return new Es(e)}static Sink(e){return new Is(e)}static Clipper(e){return new Ms(e)}static Buffer(e){return new ks(e)}static Mixer(e){return new Xs(e)}}const Us=new class extends Function{constructor(){return super("...args","return this._create(...args)"),this.bind(this)}Zeros(e,t=e,n=qt.MatrixType.default){const i=new Array(e*t).fill(0);return this._create(e,t,i,n)}Ones(e,t=e,n=qt.MatrixType.default){const i=new Array(e*t).fill(1);return this._create(e,t,i,n)}Eye(e,t=e,n=qt.MatrixType.default){const i=new Array(e*t).fill(0);for(let n=Math.min(e,t)-1;n>=0;n--)i[n*e+n]=1;return this._create(e,t,i,n)}_create(e,t=e,n=null,i=qt.MatrixType.default){let s=new Wt(e,t,i),o=null;if(null!=n){if(!Array.isArray(n))throw new r.f("Can't initialize SpeedyMatrix with values "+n);n.length>0&&(o=new Tn(s,n))}return new Qn(s,o)}get Settings(){return Nn.instance}evaluate(e){return new Qn(e._shape).assign(e)}fromPoints(e,t=qt.MatrixType.default){if(!(Array.isArray(e)&&e.length>0))throw new r.f("Can't create matrix from points: "+e);const n=[],i=e.length;for(let t=0;t<i;t++)n.push(e[t].x),n.push(e[t].y);return this._create(2,i,n,t)}toPoints(e){if(2!==e.rows)throw new r.f(`Can't convert ${e._shape.toString()} matrix to points`);return e.read().then(e=>{const t=[],n=e.length;for(let i=0;i<n;i+=2)t.push(new Ht(e[i],e[i+1]));return t})}QR(e,t={}){const n=e.rows,i=e.columns,s=e.dtype,r="full"==t.mode,o=r?this._create(n,n+i,null,s):this._create(n,i+i,null,s),a=r?o.block(0,n-1,0,n-1):o.block(0,n-1,0,i-1),c=r?o.block(0,n-1,n,n+i-1):o.block(0,i-1,i,i+i-1);return o.assign(e.qr(t.mode)).then(()=>[a,c]).turbocharge()}Perspective(e,t){if(2!==e.rows||4!==e.columns||!e._shape.equals(t._shape))throw new r.f(`Can't compute perspective transformation using ${e} and ${t}. 4 correspondences of points are required`);return new mi(e,t)}findHomography(e,t,n={}){if(n.method=n.method||"p-ransac",n.parameters=Object.assign({mask:null,numberOfHypotheses:500,bundleSize:100,reprojectionError:2},n.parameters||{}),!(2===e.rows&&e.columns>=4&&e._shape.equals(t._shape)))throw new r.f(`Can't compute homography matrix using ${e} and ${t}. 4 or more correspondences of points are required`);const i=n.parameters;if("p-ransac"===n.method){const s=new Wt(1,e.columns,e.dtype),o=i.mask||new Qn(s,new Tn(s)),a=0|i.numberOfHypotheses,c=0|i.bundleSize,l=+i.reprojectionError;if(!(o instanceof Yn&&o._shape.equals(s)))throw new r.f("Can't compute homography matrix: invalid mask");if(a<=0||c<=0||l<0)throw new r.f(`Can't compute homography matrix: invalid parameters for "${n.method}"`);return new vi(e,t,a,c,l,o)}if("dlt"===n.method)return new _i(e,t);throw new r.f(`Can't compute homography matrix using method "${n.method}"`)}transform(e,t){if(2!==t.rows)throw new r.f(`Can't apply transform: invalid set of points (${t._shape.toString()})`);if(3===e.columns){if(3===e.rows)return new gi(e,t);if(2===e.rows)return new xi(e,t)}else if(2===e.columns&&2===e.rows)return new yi(e,t);throw new r.f(`Can't apply transformation: invalid transformation matrix (${e._shape.toString()})`)}};class Hs{static load(e,t={}){return ut.load(e,t)}static camera(e=640,t=360,n={},i={}){return ut.loadCameraStream(e,t,n,i)}static get version(){return"0.7.0-wip"}static get fps(){return ft.instance.fps}static get FeatureDetector(){return Dt}static get FeatureTracker(){return Ut}static get FeatureDescriptor(){return Kt}static Vector2(e,t){return new Ft(e,t)}static Point2(e,t){return new Ht(e,t)}static Size(e,t){return new Gt(e,t)}static get Matrix(){return Us}static get Promise(){return s.a}static Pipeline(){return new $i}static get Image(){return Vi}static get Filter(){return ms}static get Transform(){return ys}static get Keypoint(){return $s}}Object.assign(Hs.constructor.prototype,_t),l.g||i.a.warn("Running on a big-endian machine")}]);